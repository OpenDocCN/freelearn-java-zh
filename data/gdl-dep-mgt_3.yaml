- en: Chapter 3. Resolving Dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 解析依赖项
- en: In [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Defining Dependencies"),
    *Defining Dependencies*, you learned how to add dependencies to your projects.
    We have seen different ways of specifying dependencies, such as module or project
    dependencies. In the previous chapter, we explored how to define the repositories
    that host our dependencies. Gradle will use this information to do the actual
    dependency resolution. In this chapter, we will see how Gradle resolves dependencies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0014.xhtml#aid-DB7S1 "第1章。定义依赖项")中，*定义依赖项*，你学习了如何将依赖项添加到你的项目中。我们看到了指定依赖项的不同方法，例如模块或项目依赖项。在前一章中，我们探讨了如何定义托管我们依赖项的仓库。Gradle将使用这些信息来进行实际的依赖项解析。在本章中，我们将看到Gradle是如何解析依赖项的。
- en: Gradle has a different way of resolving version conflicts than other build tools,
    so we will take a good look at what happens when a dependency is resolved. We
    will see how we can customize the resolution process in Gradle so that we can
    have the exact dependencies we want and have reliable and repeatable builds.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle在解决版本冲突方面与其他构建工具不同，因此我们将仔细观察依赖项解析时发生的情况。我们将看到如何在Gradle中自定义解析过程，以便我们可以获得我们想要的精确依赖项，并实现可靠和可重复的构建。
- en: Understanding dependency resolution
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖解析
- en: 'Gradle will use the information in the `repositories` and `dependencies` configuration
    blocks to gather and download all dependencies. This process is also called **dependency
    resolution**. The following steps are taken by Gradle to resolve dependencies:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle将使用`repositories`和`dependencies`配置块中的信息来收集和下载所有依赖项。这个过程也被称为**依赖解析**。Gradle在解析依赖项时采取以下步骤：
- en: The module descriptor file for a dependency is searched in the defined repositories.
    The order of the repository definitions is used for searching. So, repositories
    defined before other repositories are searched first, and so on. If a POM or Ivy
    descriptor file is found, it is used. If no descriptor file is found, then the
    artifact file for the dependency is searched. If either the descriptor file or
    the artifact file is found, then Gradle knows this repository can be used to download
    the dependencies.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义的仓库中搜索依赖项的模块描述符文件。使用仓库定义的顺序进行搜索。因此，先于其他仓库定义的仓库首先被搜索，依此类推。如果找到了POM或Ivy描述符文件，则使用它。如果没有找到描述符文件，则搜索依赖项的工件文件。如果找到了描述符文件或工件文件，那么Gradle就知道这个仓库可以用来下载依赖项。
- en: If a POM descriptor file is found with a parent POM descriptor file, then the
    parent POM is resolved by Gradle.
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到一个带有父POM描述符文件的POM描述符文件，则Gradle将解析父POM。
- en: A dynamic version, like *4.1.+*, is resolved to the highest available static
    version in the repository. For example if the repository contains versions *4.1.0*
    and *4.1.1* then the *4.1.1* version is used.
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态版本，如*4.1.+*，解析为仓库中可用的最高静态版本。例如，如果仓库包含版本*4.1.0*和*4.1.1*，则使用*4.1.1*版本。
- en: 'Gradle will determine which repository is the best to use based on the following
    criteria:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gradle将根据以下标准确定哪个仓库最适合使用：
- en: Module descriptor files, like POM and Ivy descriptor files, are preferred over
    artifact file only.
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块描述符文件，如POM和Ivy描述符文件，比仅包含工件文件的文件更受欢迎。
- en: Dependencies found in earlier repositories are preferred over later repositories.
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先考虑在早期仓库中找到的依赖项，而不是在后期仓库中找到的依赖项。
- en: If a dynamic version like *2.+* is used, than a higher static version is preferred
    over a lower static version.
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用了类似*2.+*的动态版本，则更倾向于使用比它低的静态版本。
- en: The artifacts for the module dependency are downloaded from the repository that
    is chosen by Gradle. This means that artifacts are not downloaded from a different
    repository than where the descriptor file or artifact file for the defined dependency
    are found.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块依赖项的工件是从Gradle选择的仓库下载的。这意味着工件不是从与定义的依赖项的描述符文件或工件文件不同的仓库下载的。
- en: If a dependency is defined with a static version, and Gradle finds a module
    descriptor file for this dependency in a repository, then the search for this
    dependency is complete, and other repositories will not be used for the search.
    The process cannot come up with a better repository candidate, so the dependency
    resolution is finished for the dependency.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个依赖项使用静态版本定义，并且Gradle在仓库中找到了这个依赖项的模块描述符文件，那么对这个依赖项的搜索就完成了，其他仓库将不会用于搜索。这个过程无法找到更好的仓库候选者，因此对于这个依赖项的依赖项解析就完成了。
- en: Configuring transitive dependencies
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置传递依赖项
- en: Most of the time dependencies in our project are also dependent on other libraries.
    So, the dependencies have dependencies of their own. These are so-called transitive
    dependencies. Gradle must be able to resolve the transitive dependencies as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们项目中的依赖项也依赖于其他库。因此，这些依赖项有自己的依赖项。这些被称为传递依赖项。Gradle 必须能够解析传递依赖项。
- en: 'In the following example build file, we define the `logback-classic` module
    dependency with the version `1.1.2` and the group name `ch.qos.logback`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们使用版本 `1.1.2` 和组名 `ch.qos.logback` 定义了 `logback-classic` 模块依赖项：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we run the Gradle `dependencies` task, we can see that our defined dependency
    for `logback-classic` depends on `ch.qos.logback:logback-core:1.1.2` and `org.slf4j:slf4j-api:1.7.6`.
    The following code shows this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 Gradle 的 `dependencies` 任务时，我们可以看到我们定义的 `logback-classic` 依赖项依赖于 `ch.qos.logback:logback-core:1.1.2`
    和 `org.slf4j:slf4j-api:1.7.6`。以下代码显示了这一点：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Disabling transitive dependencies
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用传递依赖项
- en: If we don't want to have transitive dependencies in our project, we must reconfigure
    the dependency or configuration. With Gradle, we have different ways to disable
    transitive behavior for dependencies. First, we can add a configuration closure
    to our dependency definition, use the `transitive` property, and set the value
    to `false`. By default, all dependencies are treated as transitive, as we saw
    in our example build file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想在我们的项目中包含传递依赖项，我们必须重新配置依赖项或配置。使用 Gradle，我们有不同的方法来禁用依赖项的传递行为。首先，我们可以在依赖定义中添加一个配置闭包，使用
    `transitive` 属性，并将其值设置为 `false`。默认情况下，所有依赖项都被视为传递依赖项，正如我们在示例构建文件中看到的那样。
- en: 'In the following example build file, we specify that we want to treat or use
    the `logback-classic` dependency as nontransitive:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们指定我们想要将 `logback-classic` 依赖项视为非传递依赖项：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we run the `dependencies` task again, we can see in the output that the
    transitive dependencies are no longer resolved:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行 `dependencies` 任务，我们可以在输出中看到传递依赖项不再被解析：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also disable transitive dependencies for a dependency configuration
    as a whole. So, this means that any dependencies defined with the configuration
    will not have transitive dependencies. Single dependencies within the configuration
    can use the `transitive` property in the configuration closure to enable transitive
    behavior again for that dependency. To accomplish this, perform the following
    steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以完全禁用依赖项配置中的传递依赖项。这意味着使用该配置定义的任何依赖项都不会有传递依赖项。配置中的单个依赖项可以在配置闭包中使用 `transitive`
    属性来再次启用该依赖项的传递行为。要完成此操作，请执行以下步骤：
- en: 'First, we will disable transitive dependencies for the `compile` configuration
    in the next example build file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将在下一个示例构建文件中禁用 `compile` 配置的传递依赖项：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we will execute the `dependencies` task and see that transitive dependencies
    are no longer resolved:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将执行 `dependencies` 任务，并看到传递依赖项不再被解析：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Excluding transitive dependencies
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排除传递依赖项
- en: We can also have more fine-grained control of transitive dependencies. We can
    exclude certain transitive dependencies in our dependency definition. This way,
    we can choose to use only certain transitive dependencies and leave others out.
    To define which transitive dependencies we want to exclude, we use the `exclude`
    method in the configuration closure of our dependency.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对传递依赖项有更精细的控制。我们可以在依赖定义中排除某些传递依赖项。这样，我们可以选择只使用某些传递依赖项，而排除其他依赖项。要定义我们想要排除的传递依赖项，我们使用依赖项配置闭包中的
    `exclude` 方法。
- en: 'Let''s see how we can include the `logback-core` transitive dependency but
    remove the `slf4j-api` dependency. We use the `exclude` method in the configuration
    closure. The `exclude` method takes `Map` as an argument with one or both of the
    keys: `module` and `group`. In the following build file, we include the `logback-core`
    transitive dependency:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何包含 `logback-core` 传递依赖项，但移除 `slf4j-api` 依赖项。我们在配置闭包中使用 `exclude` 方法。`exclude`
    方法接受一个 `Map` 作为参数，其中包含一个或两个键：`module` 和 `group`。在以下构建文件中，我们包含 `logback-core` 传递依赖项：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We execute the `dependencies` task to see whether our configuration definition
    has the desired effect:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行 `dependencies` 任务以查看我们的配置定义是否具有预期的效果：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that in the output, the transitive dependency, `org.slf4j:slf4j-api:1.7.6`,
    is no longer part of our transitive dependencies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在输出中，传递依赖项 `org.slf4j:slf4j-api:1.7.6` 已不再是我们的传递依赖项的一部分。
- en: 'We can also set exclude rules on a configuration in addition to a single dependency.
    The exclude rule on a configuration will be used for all dependencies defined
    within the configuration. In the next example Gradle build file, we will exclude
    the `slf4j-api` module from all dependencies in the `compile` configuration:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在单个依赖项之外对配置设置排除规则。配置上的排除规则将用于配置中定义的所有依赖项。在下一个示例 Gradle 构建文件中，我们将从 `compile`
    配置中排除 `slf4j-api` 模块：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Any exclude rule that we add to either the configuration or the dependency
    is accessible again via the `excludeRules` property of the corresponding objects.
    We can use this to find out the configuration or dependency that is responsible
    for excluding a certain dependency. In the following example build file, we create
    a new task, `showExcludeRules`, where we loop through all configurations and dependencies
    and collect exclude rules. At the end of the task, we print all the information
    to standard output. The following code shows this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到配置或依赖项中的任何排除规则都可以通过相应对象的 `excludeRules` 属性再次访问。我们可以使用此属性来找出负责排除特定依赖项的配置或依赖项。在以下示例构建文件中，我们创建了一个新的任务
    `showExcludeRules`，其中我们遍历所有配置和依赖项并收集排除规则。在任务的末尾，我们将所有信息打印到标准输出。以下代码显示了这一点：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When we run the task, we get the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行任务时，我们得到以下输出：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using artifact-only dependencies
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用仅软件包依赖项
- en: Finally, we can use the `ext` attribute for an external module dependency if
    we know we only want to include a single artifact from the dependency. With this
    attribute, no transitive dependencies are resolved because we specify that we
    specifically want the artifact specified by the `ext` attribute.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们知道我们只想包含依赖项中的一个软件包，我们可以使用 `ext` 属性来为外部模块依赖项。使用此属性，不会解决传递依赖项，因为我们指定了我们特别想要由
    `ext` 属性指定的软件包。
- en: 'In our example, we can use the `ext` attribute with the `jar` value to resolve
    only the JAR artifact for the `logback-classic` dependency. In the next example
    build file, we will use the `ext` attribute for our `logback-classic` dependency:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以使用具有 `jar` 值的 `ext` 属性来仅解决 `logback-classic` 依赖项的 JAR 软件包。在下一个示例构建文件中，我们将使用
    `ext` 属性为我们的 `logback-classic` 依赖项：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Resolving version conflicts
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决版本冲突
- en: Our previous examples were simple and only contained one dependency with some
    transitive dependencies. When we add more dependencies to our project, or have
    a multimodule project where each project has a lot of dependencies, then it can
    happen that the same dependency or transitive dependency is included multiple
    times. Gradle detects this and makes sure that the dependency is only downloaded
    once. We will see more about the advanced dependency cache management in Gradle
    later.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的示例很简单，只包含一个依赖项和一些传递依赖项。当我们向我们的项目添加更多依赖项，或者有一个多模块项目，其中每个项目都有很多依赖项时，可能会发生相同或传递依赖项被多次包含的情况。Gradle
    会检测到这一点，并确保依赖项只下载一次。我们将在 Gradle 中稍后看到关于高级依赖项缓存管理的更多内容。
- en: 'The trouble begins when the same dependency is included multiple times but
    with different versions. Which version of the dependency should be used? This
    is where Gradle''s resolution strategy comes into play. The next table shows the
    resolution strategies that Gradle has:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一个依赖被多次包含但版本不同时，问题就开始了。应该使用哪个版本的依赖？这正是 Gradle 的解析策略发挥作用的地方。下表显示了 Gradle 具有的解析策略：
- en: '| Name | Description |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Newest | The newest version of a conflicting dependency is used. This is
    the default strategy used by Gradle. If the versions of the conflicting dependency
    are backward compatible, this works fine. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 最新版 | 使用冲突依赖项的最新版本。这是 Gradle 使用的默认策略。如果冲突依赖项的版本向后兼容，则此策略有效。|'
- en: '| Fail | The build process fails when there is a version conflict with dependencies.
    We must explicitly add code to our build file that will resolve the version conflict.
    We will see later in this chapter how we can customize the resolution strategy
    to solve version conflicts explicitly. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 失败 | 当依赖项存在版本冲突时，构建过程会失败。我们必须明确地在我们的构建文件中添加代码来解决版本冲突。我们将在本章后面看到如何自定义解析策略来显式解决版本冲突。|'
- en: Using the newest version
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用最新版本
- en: 'Let''s see what happens if we have a version conflict and use the default resolution
    strategy of Gradle. Gradle will use the newest version of the dependency that
    has a version conflict. To accomplish this, perform the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们有一个版本冲突并使用Gradle的默认解决策略会发生什么。Gradle将使用具有版本冲突的依赖项的最新版本。为了完成此操作，请执行以下步骤：
- en: 'In the next build file, we define a dependency on `slf4j-api` in the `compile`
    configuration and on `logback-classic` in the `runtime` configuration:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个构建文件中，我们在`compile`配置中定义了对`slf4j-api`的依赖，在`runtime`配置中定义了对`logback-classic`的依赖：
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We run the `dependencies` task to see which versions of the dependencies are
    used. The following output shows that the `org.slf4j:slf4j-api:1.7.6` transitive
    dependency of `logback-classic` is changed, so the version `1.7.7` is used, which
    is defined in the `compile` configuration:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们运行`dependencies`任务以查看使用了哪些依赖项的版本。以下输出显示，`logback-classic`的传递依赖项`org.slf4j:slf4j-api:1.7.6`已更改，因此使用了定义在`compile`配置中的版本`1.7.7`。
- en: '[PRE13]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice the line `org.slf4j:slf4j-api:1.7.6 → 1.7.7`, where it visually shows
    that the version is increased for this dependency from `1.7.6` to `1.7.7`.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到行`org.slf4j:slf4j-api:1.7.6 → 1.7.7`，它直观地显示了该依赖项的版本已从`1.7.6`增加到`1.7.7`。
- en: The `dependencies` task shows a hierarchical tree view of the dependencies and
    transitive dependencies. To get a view from a specific dependency, and to see
    how it got in the dependency graph, we use the `dependencyInsight` task. With
    this task, we can see how the dependency is resolved and whether any conflict
    resolution has happened.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dependencies`任务显示了依赖项和传递依赖项的层次树视图。要从一个特定的依赖项获取视图，并查看它是如何进入依赖项图的，我们使用`dependencyInsight`任务。使用此任务，我们可以看到依赖项是如何解决的，以及是否发生了任何冲突解决。'
- en: 'We must use the following two options when we invoke the `dependencyInsight`
    task from the command line:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们从命令行调用`dependencyInsight`任务时，我们必须使用以下两个选项：
- en: We specify the configuration of the dependency with the `--configuration` option.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`--configuration`选项指定依赖项的配置。
- en: Then, we use the `--dependency` option to specify the name of the dependency.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`--dependency`选项来指定依赖项的名称。
- en: The name of the dependency doesn't have to be the full name; we can even use
    part of the name. For example, we can use `org.slf4j:slf4j-api`, `slf4j-api`,
    and `slf4j` to gain insight into a dependency.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖项的名称不必是全名；我们甚至可以使用名称的一部分。例如，我们可以使用`org.slf4j:slf4j-api`、`slf4j-api`和`slf4j`来深入了解一个依赖项。
- en: 'We execute the `dependencyInsight` task to see more information about the `slf4j-api`
    dependency in our example build file:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们执行`dependencyInsight`任务以查看示例构建文件中`slf4j-api`依赖项的更多信息：
- en: '[PRE14]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the output, we see that the `org.slf4j:slf4j-api:1.7.7` dependency is resolved
    for the `runtime` configuration and that conflict resolution has happened for
    the dependency. In the next lines, we will see that the `org.slf4j:slf4j-api:1.7.6`
    transitive dependency has its version increased from `1.7.6` to `1.7.7`. The `dependencyInsight`
    task already tells us more about the dependency resolution that is applied. We
    will probably start with a broad overview using the `dependencies` task, and if
    we want to get more information about a particular dependency, we will use the
    `dependencyInsight` task.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在输出中，我们看到`org.slf4j:slf4j-api:1.7.7`依赖项已为`runtime`配置解决，并且已对该依赖项进行了冲突解决。在下一行中，我们将看到`org.slf4j:slf4j-api:1.7.6`的传递依赖项版本已从`1.7.6`增加到`1.7.7`。`dependencyInsight`任务已经告诉我们更多关于应用的依赖项解决信息。我们可能会从使用`dependencies`任务进行的大致概述开始，如果我们想获取有关特定依赖项的更多信息，我们将使用`dependencyInsight`任务。
- en: 'There is another task that we can use that will combine both the `dependencies`
    and `dependencyInsight` tasks. The `htmlDependencyReport` task is part of the
    `project-report` plugin. With this task, we get an HTML report showing all dependencies,
    and we can click on dependencies to get more insight. To use the task, we first
    add the `project-report` plugin to our example project file. The following code
    shows this:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用另一个任务，该任务将`dependencies`和`dependencyInsight`任务结合起来。`htmlDependencyReport`任务是`project-report`插件的一部分。使用此任务，我们可以获得一个HTML报告，显示所有依赖项，并且我们可以点击依赖项以获取更多信息。要使用此任务，我们首先将`project-report`插件添加到我们的示例项目文件中。以下代码显示了这一点：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We execute the `htmlDependencyReport` task for this build file. The following
    code shows this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为这个构建文件执行`htmlDependencyReport`任务。以下代码显示了这一点：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After the task is executed, new files are created in `build/reports/project/dependencies/`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任务执行后，`build/reports/project/dependencies/`目录中会创建新的文件。
- en: When we open the `index.html` file in a web browser, we can see the name of
    our project. If we had a multimodule project, we would see all project names here.
    We can click on the name and get an overview of all configurations. In the next
    screenshot, we see an overview of all the configuration in our project:![Using
    the newest version](img/image00128.jpeg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在网页浏览器中打开 `index.html` 文件时，我们可以看到我们项目的名称。如果我们有一个多模块项目，我们在这里会看到所有项目的名称。我们可以点击名称并获取所有配置的概述。在下一张截图中，我们看到我们项目中所有配置的概述：![使用最新版本](img/image00128.jpeg)
- en: When we click on the `runtime` configuration link, all dependencies are shown.
    We can see that there is a version conflict because the `org.sfl4j:slf4j-api:1.7.6`
    dependency is orange in color. This view is what we also see when the dependencies
    task from the command line is invoked:![Using the newest version](img/image00129.jpeg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们点击 `runtime` 配置链接时，所有依赖项都会显示出来。我们可以看到存在版本冲突，因为 `org.sfl4j:slf4j-api:1.7.6`
    依赖项的颜色是橙色。这个视图就是我们通过命令行调用依赖项任务时看到的：![使用最新版本](img/image00129.jpeg)
- en: To get the dependency insight view, we click on the `org.sfl4j:slf4j-api:1.7.6
    → 1.7.7` link. A pop-up window is opened in our web browser, and we see the following
    screenshot:![Using the newest version](img/image00130.jpeg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取依赖项洞察视图，我们点击 `org.sfl4j:slf4j-api:1.7.6 → 1.7.7` 链接。在我们的网页浏览器中打开一个弹出窗口，我们看到以下截图：![使用最新版本](img/image00130.jpeg)
- en: Now, we see what we normally see if we run the `dependencyInsight` task from
    the command line.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到如果我们从命令行运行 `dependencyInsight` 任务时通常会看到的内容。
- en: The `htmlDependencyReport` is very useful to get a graphical and interactive
    view of the dependencies in our project. It is also easy to get more details about
    a dependency by just clicking on it in the generated HTML reports.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`htmlDependencyReport` 非常有用，可以获取我们项目中依赖项的图形化和交互式视图。通过在生成的 HTML 报告中点击它，我们也可以轻松地获取更多关于依赖项的详细信息。'
- en: Failing on version conflict
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在版本冲突时失败
- en: If the default Gradle resolution strategy of using the newest version of a (transitive)
    dependency is not solving the problem, we can choose to let the build fail if
    there is a version conflict. To run the build successfully again, we must explicitly
    solve the version conflict in our build file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认的 Gradle 解析策略（使用（传递性）依赖项的最新版本）不能解决问题，我们可以选择在版本冲突时让构建失败。为了再次成功运行构建，我们必须明确在我们的构建文件中解决版本冲突。
- en: 'In the following example build file, we configure the resolution strategy for
    the `runtime` configuration to fail if there is a version conflict. The `resolutionStrategy`
    method accepts a configuration closure where we invoke the `failOnVersionConflict`
    method. The following code shows this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们为 `runtime` 配置配置了解决策略，如果存在版本冲突则失败。`resolutionStrategy` 方法接受一个配置闭包，在其中我们调用
    `failOnVersionConflict` 方法。以下代码展示了这一点：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The build is now configured to fail on a version conflict. We know from the
    previous examples in this chapter that there is a version conflict on `slf4j-api`.
    We now execute the `dependencies` task to see what happens:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构建现在配置为在版本冲突时失败。我们知道在本章前面的示例中，`slf4j-api` 上存在版本冲突。我们现在执行 `dependencies` 任务来看看会发生什么：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We see that the build has failed this time. In the output, we see why. There
    is a conflict between the `org.slf4j:slf4j-api:1.7.7` and `org.slf4j:slf4j-api:1.7.6`
    modules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到这次构建失败了。在输出中，我们看到原因。`org.slf4j:slf4j-api:1.7.7` 和 `org.slf4j:slf4j-api:1.7.6`
    模块之间存在冲突。
- en: Forcing a version
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制版本
- en: We can force Gradle to use a specific version for a dependency in our project.
    The dependency can also be transitive. We use the configuration closure for a
    dependency and set the `force` property with the value `true`. This instructs
    the Gradle dependency resolution process to always use the specified version for
    this dependency, even when the dependency is a transitive dependency in the dependency
    graph.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以强制 Gradle 在我们的项目中使用特定版本的依赖项。这个依赖项也可以是传递性的。我们使用依赖项的配置闭包，并将 `force` 属性设置为
    `true`。这指示 Gradle 依赖项解析过程始终使用指定的版本，即使依赖项是依赖图中的传递性依赖项。
- en: 'In our example build file, we have a version conflict. We can fix this by forcing
    Gradle to use the version `1.7.7` for the `org.slf4j:slf4j-api` dependency. The
    following example build file applies the `force` property:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例构建文件中，我们有一个版本冲突。我们可以通过强制 Gradle 使用 `org.slf4j:slf4j-api` 依赖项的版本 `1.7.7`
    来修复这个问题。以下示例构建文件应用了 `force` 属性：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s run the `dependencies` task to see whether the version conflict is now
    resolved:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 `dependencies` 任务来看看版本冲突是否已经解决：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have resolved the version conflict, and the build is now successful again.
    We can also see in the output that for the `org.slf4j:slf4j-api:1.7.6` transitive
    dependency, the version is now the version `1.7.7`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了版本冲突，构建现在再次成功。我们还可以在输出中看到，对于 `org.slf4j:slf4j-api:1.7.6` 传递依赖项，版本现在是
    `1.7.7`。
- en: Instead of setting the `force` property in the dependency configuration, we
    can also force a version for a dependency as part of the `resolutionStrategy`
    method in the `configurations` configuration block. We use the `force` method
    to add a dependency with a forced version. Alternatively, we can use the `forcedModules`
    property to define all forced dependencies. This might be a better solution because
    we can have multiple dependencies with a forced version and put them all together
    in the `resolutionStrategy` configuration closure for a more readable and maintainable
    build file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在依赖项配置中设置 `force` 属性外，我们还可以在 `configurations` 配置块的 `resolutionStrategy` 方法中作为依赖项的一部分强制设置版本。我们使用
    `force` 方法添加具有强制版本的依赖项。或者，我们可以使用 `forcedModules` 属性来定义所有强制依赖项。这可能是一个更好的解决方案，因为我们可以在
    `resolutionStrategy` 配置闭包中将具有强制版本的多个依赖项放在一起，从而使构建文件更易于阅读和维护。
- en: 'In the next example build file, we will force the version of the `org.slf4j:slf4j-api`
    dependency to be `1.7.7`, but this time as part of the `resolutionStrategy` configuration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将强制 `org.slf4j:slf4j-api` 依赖项的版本为 `1.7.7`，但这次作为 `resolutionStrategy`
    配置的一部分：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we execute the `dependencies` task from the command line, we see that
    the version `1.7.7` is used for all `org.slf4j:slf4j-api` dependencies:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从命令行执行 `dependencies` 任务时，我们看到所有 `org.slf4j:slf4j-api` 依赖项都使用了版本 `1.7.7`：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Customizing dependency resolution rules
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义依赖项解析规则
- en: For each dependency we define in our build file, there is a dependency resolution
    rule. This rule is executed when the dependency needs to be resolved. We can customize
    this rule in our build file, so we can change certain parts of the rule before
    the dependency is actually resolved. Gradle allows us to change the dependency
    group, name, and version with a customized resolution rule. This way, we can even
    completely replace dependencies with other dependencies or force a particular
    version.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在构建文件中定义的每个依赖项，都有一个依赖项解析规则。当需要解析依赖项时，将执行此规则。我们可以在构建文件中自定义此规则，因此我们可以在依赖项实际解析之前更改规则的某些部分。Gradle
    允许我们通过自定义解析规则来更改依赖项组、名称和版本。这样，我们甚至可以用其他依赖项完全替换依赖项或强制使用特定版本。
- en: Dependency resolution rule details are implemented in the `org.gradle.api.artifacts.DependencyResolveDetails`
    class. Inside the `resolutionStrategy` configuration block, we use the `eachDependency`
    method to customize a resolution rule. This method accepts a closure, and the
    closure argument is an instance of `DependencyResolveDetails`. We use the `useVersion`
    and `useTarget` methods of `DependencyResolveDetails` to change either the version
    or the complete group, name, and version for a requested dependency.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项解析规则细节在 `org.gradle.api.artifacts.DependencyResolveDetails` 类中实现。在 `resolutionStrategy`
    配置块内部，我们使用 `eachDependency` 方法来自定义解析规则。此方法接受一个闭包，闭包参数是 `DependencyResolveDetails`
    的一个实例。我们使用 `DependencyResolveDetails` 的 `useVersion` 和 `useTarget` 方法来更改请求的依赖项的版本或完整的组、名称和版本。
- en: 'Let''s change our previous example build file and define a customized resolution
    rule for the `org.slf4j:slf4j-api` dependency so that the version `1.7.7` is always
    used. In the next example build file, we will see how to achieve this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改之前的示例构建文件，并为 `org.slf4j:slf4j-api` 依赖项定义一个自定义解析规则，以便始终使用版本 `1.7.7`。在下一个示例构建文件中，我们将看到如何实现这一点：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This mechanism is very powerful. Besides forcing a particular version, we can
    use the dependency resolution rules to replace a complete dependency with another.
    Let's suppose we have a dependency in our project and this dependency has a transitive
    dependency on the Log4j logging framework. We don't want this dependency, and
    instead want to use the log4j-over-slf4j bridge. This bridge contains alternative
    implementations for Log4j classes, so we can use an SLF4J API implementation.
    The log4j-over-slf4j bridge is defined by the `org.slf4j:log4j-over-slf4j:1.7.7`
    dependency. We use the `useTarget` method of the resolution rule details to set
    a new target. The method accepts both string notations and map notations for dependencies.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制非常强大。除了强制指定特定版本外，我们还可以使用依赖项解析规则将完整的依赖项替换为另一个依赖项。假设我们项目中的一个依赖项有一个对Log4j日志框架的传递依赖。我们不希望这个依赖项，而是想使用log4j-over-slf4j桥接。这个桥接包含Log4j类的替代实现，因此我们可以使用SLF4J
    API实现。log4j-over-slf4j桥接由`org.slf4j:log4j-over-slf4j:1.7.7`依赖项定义。我们使用解析规则细节的`useTarget`方法设置新的目标。该方法接受依赖项的字符串表示法和映射表示法。
- en: 'The following example build file contains the dependency resolution rule to
    replace a dependency on the `Log4j to the log4j-over-slf4j` bridge:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例构建文件包含替换`Log4j`依赖项到`log4j-over-slf4j`桥接的依赖项解析规则：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can verify that the Log4j dependency is replaced with the `dependencies`
    task from the command line. This is shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过命令行验证Log4j依赖项是否被`dependencies`任务替换。以下代码显示了这一点：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice the `log4j:log4j:1.2.17 → org.slf4j:log4j-over-slf4j:1.7.7` line, which
    visually shows the replacement of the dependency with a new dependency.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`log4j:log4j:1.2.17 → org.slf4j:log4j-over-slf4j:1.7.7`这一行，它直观地显示了依赖项被新的依赖项替换。
- en: Custom dependency resolution rules also allow us to define a custom version
    scheme. For example, in our organization, we can define that if the version of
    a dependency is set to the `fixed` value, the actual version is fetched from a
    central location on the corporate intranet. This way, all projects in the organization
    can share the same version for dependencies.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义依赖项解析规则还允许我们定义自定义版本方案。例如，在我们的组织中，我们可以定义如果依赖项的版本设置为`fixed`值，则实际版本将从企业内部网络的中央位置获取。这样，组织中的所有项目都可以共享依赖项的相同版本。
- en: 'In the next example build file, we will implement a custom version scheme.
    If the `version` attribute is omitted or has the `fixed` value, then the version
    information is fetched from a predefined list of versions. The following code
    shows this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将实现自定义版本方案。如果省略了`version`属性或具有`fixed`值，则版本信息将从预定义的版本列表中获取。以下代码显示了这一点：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It is interesting to see what the output of the `dependencies` task is when
    we run it from the command line:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从命令行运行`dependencies`任务时，看到其输出是很有趣的：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the output, we clearly see how the `org.slf4j:slf4j-api` dependency without
    a version is now using the version `1.7.7`. The `fixed` version of the `ch.qos.logback:logback-classic`
    dependency is resolved to the version `1.1.2`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以清楚地看到没有版本号的`org.slf4j:slf4j-api`依赖项现在使用的是版本`1.7.7`。`ch.qos.logback:logback-classic`依赖项的`fixed`版本解析为版本`1.1.2`。
- en: Using client modules
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用客户端模块
- en: Instead of relying on the module descriptor found in the repository for our
    external module dependency, we can define the metadata for the module in our build
    file as a client module. Remember from [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Defining
    Dependencies"), *Defining Dependencies*, that with a client module, we define
    the module descriptor in our build file and still get the artifacts from the repository.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不在存储库中找到的模块描述符上依赖外部模块依赖项，而是在我们的构建文件中将模块的元数据定义为客户端模块。记得从[第1章](part0014.xhtml#aid-DB7S1
    "第1章。定义依赖项")，*定义依赖项*，中提到的，使用客户端模块，我们在构建文件中定义模块描述符，并仍然从存储库获取工件。
- en: 'Let''s use a client module in the following example build file. We redefine
    the transitive dependencies for the `logback-classic` dependency and use the version
    `1.7.7` for the `slf4j-api` dependency. The following code shows this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下示例构建文件中使用客户端模块。我们重新定义了`logback-classic`依赖项的传递依赖，并使用`slf4j-api`依赖项的版本`1.7.7`。以下代码显示了这一点：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We invoke the `dependencies` task from the command line to check whether the
    correct dependencies are used:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从命令行调用`dependencies`任务来检查是否使用了正确的依赖项：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We see in the output that the dependency on `org.slf4j:slf4j-api` is now `1.7.7`
    and we don't have version conflict anymore.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在输出中看到，对`org.slf4j:slf4j-api`的依赖现在为`1.7.7`，并且我们不再有版本冲突。
- en: Using dynamic versions and changing modules
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态版本和变更模块
- en: In [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Defining Dependencies"),
    *Defining Dependencies*, we already learned about dynamic versions. For example,
    we can use a range of versions such as `[4.0.1.RELEASE,4.0.4.RELEASE[`. When the
    dependency is resolved by Gradle, the latest available static version in the range
    is selected.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0014.xhtml#aid-DB7S1 "第1章. 定义依赖") *定义依赖* 中，我们已经学习了动态版本的概念。例如，我们可以使用一系列版本，如
    `[4.0.1.RELEASE,4.0.4.RELEASE[`。当依赖项通过Gradle解析时，会选取该范围内可用的最新静态版本。
- en: A changing module is different than a dynamic version. A changing module references
    a dependency with the same version but with changing artifacts. For example, in
    a Maven repository, a changing module is the snapshot module indicated by `-SNAPSHOT`
    in the `version` attribute. Gradle can resolve a changing module dependency and
    get the latest artifact for the given version. However, the next time, a new artifact
    might be downloaded because the content has changed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 变更模块与动态版本不同。变更模块引用具有相同版本但具有变更artifacts的依赖项。例如，在一个Maven仓库中，变更模块是由`version`属性中的`-SNAPSHOT`指示的快照模块。Gradle可以解析变更模块依赖项并获取给定版本的最新artifacts。然而，下次可能会下载新的artifacts，因为内容已更改。
- en: Gradle caches dynamic versions and changing modules for 24 hours. We will see
    how we can customize this behavior in our Gradle build file and from the command
    line. However, before we take a look at the options, we will first see how Gradle
    caching works.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle会缓存动态版本和变更模块24小时。我们将看到如何在我们的Gradle构建文件和命令行中自定义此行为。然而，在我们查看选项之前，我们首先会了解Gradle缓存的工作原理。
- en: Understanding the dependency cache
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖项缓存
- en: 'The dependency cache of Gradle tries to minimize the number of remote requests
    and downloads so that builds can be fast and reliable. The cache has two parts
    to perform proper dependency caching:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的依赖项缓存试图最小化远程请求和下载的数量，以便构建可以快速且可靠。缓存有两个部分来执行适当的依赖项缓存：
- en: First, it has a cache for dependency metadata (POM or Ivy descriptor files)
    for a dependency group, name, and version. Gradle keeps a separate cache for each
    repository. So, if the same dependency is found in multiple repositories, then
    the metadata information is cached in multiple dependency metadata caches.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它有一个用于依赖项元数据（POM或Ivy描述文件）的缓存，包括依赖项组、名称和版本。Gradle为每个仓库保留一个单独的缓存。因此，如果相同的依赖项在多个仓库中找到，则元数据信息将缓存在多个依赖项元数据缓存中。
- en: The dependency cache also has a single cache with downloaded artifacts for the
    dependencies. The multiple metadata caches share the same cache for downloaded
    artifacts. The artifacts are stored by the SHA1 hash code of their contents and
    not by metadata, such as group, name, or version.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项缓存也有一个用于存储依赖项下载的artifacts的单个缓存。多个元数据缓存共享下载artifacts的相同缓存。artifacts通过其内容的SHA1哈希码存储，而不是通过元数据，如组、名称或版本。
- en: The separation of a metadata cache based on the repository and the artifact
    cache provides enough flexibility to perform repeatable and reliable dependency
    resolution. If the dependency metadata cannot be resolved by Gradle, then the
    dependency resolution will stop, even if the local cache has a copy of the artifact
    that was downloaded from a different repository (not defined in our build). This
    repository independence isolates builds from each other and prevents problems
    with dependency artifacts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据仓库和artifacts缓存分离的元数据缓存提供了足够的灵活性，以执行可重复和可靠的依赖项解析。如果Gradle无法解析依赖项元数据，则依赖项解析将停止，即使本地缓存有从不同仓库（未定义在我们的构建中）下载的artifacts副本。这种仓库独立性将构建彼此隔离，并防止依赖项artifacts的问题。
- en: Gradle first tries to determine the SHA1 checksum for an artifact file before
    downloading the artifact. If the checksum can be determined, the file will not
    be downloaded if it is already in the cache with the same checksum. Gradle also
    tries to reuse artifacts from the local Maven repository. If the checksum for
    an artifact in the local Maven repository matches the checksum for the artifact
    from the remote repository, then the artifact doesn't need to be downloaded and
    can be copied from the local Maven repository.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 首先尝试确定一个工件文件的 SHA1 校验和，然后再下载该工件。如果可以确定校验和，并且缓存中已经存在具有相同校验和的文件，则不会下载该文件。Gradle
    还尝试重用本地 Maven 仓库中的工件。如果本地 Maven 仓库中某个工件的校验和与远程仓库中工件的校验和匹配，则不需要下载该工件，可以直接从本地 Maven
    仓库复制。
- en: Because Gradle uses an SHA1 checksum for the artifact contents, different versions
    for the same artifact can be stored. For example, when an artifact is part of
    a changing module or the contents of the artifact have changed in the repository
    without a change in the version number.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Gradle 使用 SHA1 校验和来验证工件内容，因此可以存储同一工件的多个版本。例如，当一个工件是变化模块的一部分，或者工件的 内容在仓库中发生变化，而版本号没有变化时。
- en: 'Both the metadata cache and artifact cache are stored in the directory defined
    by the `GRADLE_USER_HOME` environment variable that is, by default, the `.gradle/caches`
    directory in the user home directory. Gradle uses a sophisticated locking mechanism
    for the caches, so multiple projects can use the cache directories and files simultaneously.
    In the next example build file, we create the `artifactsLocation` task to print
    out where the downloaded artifacts are stored:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据缓存和工件缓存都存储在由 `GRADLE_USER_HOME` 环境变量定义的目录中，默认情况下是用户主目录中的 `.gradle/caches`
    目录。Gradle 使用复杂的锁定机制来管理缓存，因此多个项目可以同时使用缓存目录和文件。在下一个示例构建文件中，我们创建 `artifactsLocation`
    任务以打印下载的工件存储位置：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we execute the `artifactsLocation` task, we see in the output that the
    files are stored in the `.gradle/caches` directory in the user home directory
    (`/Users/mrhaki`). We also see the SHA1 checksums with which the directory names
    are used. The following code shows this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 `artifactsLocation` 任务时，在输出中可以看到文件存储在用户主目录（`/Users/mrhaki`）中的 `.gradle/caches`
    目录中。我们还可以看到用于目录名的 SHA1 校验和。以下代码展示了这一点：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Command-line options for caching
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存命令行选项
- en: We can use the `--offline` command-line option to skip any network requests.
    So, with this option, Gradle never tries to access remote repositories and all
    information is fetched from the Gradle dependency caches. If the information in
    the caches is not sufficient for a build, then the build fails.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `--offline` 命令行选项来跳过任何网络请求。因此，使用此选项时，Gradle 从不尝试访问远程仓库，所有信息都从 Gradle
    依赖缓存中获取。如果缓存中的信息不足以进行构建，则构建失败。
- en: With the `--refresh-dependencies` option, we can refresh the metadata caches.
    If, for some reason, we expect the metadata to be no longer correct, we can use
    this option. Gradle will then refresh all information in the metadata caches for
    each repository. Artifacts are only downloaded when the SHA1 checksum is different
    than the checksum for artifacts in the artifacts cache.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--refresh-dependencies` 选项，我们可以刷新元数据缓存。如果由于某种原因，我们预期元数据不再正确，可以使用此选项。Gradle
    将刷新每个仓库中的元数据缓存中的所有信息。只有当 SHA1 校验和与工件缓存中工件的校验和不同时，才会下载工件。
- en: Changing cache expiration
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改缓存过期时间
- en: A dependency with a static version can be easily cached. The contents of the
    artifact has a checksum, and this can be used to either use the cache or download
    the artifact (and place it in the artifact cache). A dependency with a dynamic
    version or changing module can have a changing artifact, so we need to be able
    to customize the cache settings. We can change the expiration time for cached
    dependencies with a dynamic version and changing modules. The default expiration
    time is 24 hours. After the expiration time, Gradle will invalidate the cache
    and determine whether an artifact needs to be downloaded again.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 具有静态版本的依赖关系可以轻松缓存。工件的内容有一个校验和，这可以用来决定是使用缓存还是下载工件（并将其放置在工件缓存中）。具有动态版本或变化模块的依赖关系可能具有变化的工件，因此我们需要能够自定义缓存设置。我们可以更改具有动态版本和变化模块的缓存依赖关系的过期时间。默认过期时间是
    24 小时。在过期时间之后，Gradle 将使缓存失效并确定是否需要再次下载工件。
- en: We change the expiration time for dependencies with a dynamic version using
    the `cacheDynamicVersionsFor` method of the `resolutionStrategy` configuration
    closure. The method accepts a number and time unit to set the value for the cache
    expiration. The time unit can be either of the `java.util.concurrent.TimeUnit`
    type or a string that is converted to `TimeUnit`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`resolutionStrategy`配置闭包中的`cacheDynamicVersionsFor`方法更改具有动态版本的依赖项的过期时间。此方法接受一个数字和时间单位来设置缓存过期时间的值。时间单位可以是`java.util.concurrent.TimeUnit`类型或转换为`TimeUnit`的字符串。
- en: To change modules, we use the `cacheChangingModulesFor` method to change the
    expiration time. This method also accepts a number and time unit just as the `cacheDynamicVersionsFor`
    method does.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改模块，我们使用`cacheChangingModulesFor`方法来更改过期时间。此方法也接受一个数字和时间单位，就像`cacheDynamicVersionsFor`方法一样。
- en: 'In the next example build file, we change the cache expiration for both dynamic
    versions and changing modules for `runtime` configurations. We can also set it
    for all configurations with the `all` method and configuration block. The following
    code shows this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们更改了`runtime`配置中动态版本和更改模块的缓存过期时间。我们也可以使用`all`方法和配置块将其设置为所有配置。以下代码展示了这一点：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Gradle knows about artifacts that are stored in a Maven repository, and that
    if the version attribute ends with `-SNAPSHOT`, the module is a changing module.
    We can also define in our build script whether a dependency is a changing module,
    for example, if this cannot be derived from the version attribute. We must set
    the `changing` property to the value `true` in the configuration closure for a
    dependency.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle了解存储在Maven仓库中的工件，并且如果版本属性以`-SNAPSHOT`结尾，则模块是更改模块。我们也可以在我们的构建脚本中定义一个依赖项是否是更改模块，例如，如果无法从版本属性中推导出来。我们必须在依赖项的配置闭包中将`changing`属性设置为`true`。
- en: 'In the following example build file, we have the `com.vehicles:cars` dependency,
    which is a changing module, but we use the static version `1.0`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例构建文件中，我们有`com.vehicles:cars`依赖项，这是一个更改模块，但我们使用静态版本`1.0`：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how Gradle resolves dependencies and how to customize
    this. You saw how to reconfigure your build scripts to handle transitive dependencies
    and how to resolve version conflicts between dependencies in your builds. Gradle
    offers some fine-grained control on how we define dependencies and allows very
    explicit dependency definitions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Gradle如何解析依赖项以及如何自定义它。你看到了如何重新配置你的构建脚本以处理传递依赖，以及如何解决构建中依赖项之间的版本冲突。Gradle提供了对我们如何定义依赖项的精细控制，并允许非常明确的依赖项定义。
- en: For transitive dependencies, we have several ways to redefine which dependencies
    need to be used by either disabling or excluding transitive dependencies.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传递依赖，我们有几种方法来重新定义哪些依赖需要使用，可以通过禁用或排除传递依赖来实现。
- en: When a version conflict arises between dependencies in our build, we can either
    rely on the default strategy of using the newest version or implement a custom
    strategy. Gradle has several ways to customize dependency resolution rules by
    redefining the resolution strategy. For example, we can override the version attribute
    for a dependency or even totally replace it with a compatible but different dependency.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的构建中的依赖项出现版本冲突时，我们可以依赖使用最新版本的默认策略，或者实现一个自定义策略。Gradle有几种方法可以通过重新定义解析策略来自定义依赖项解析规则。例如，我们可以覆盖依赖项的版本属性，甚至完全用兼容但不同的依赖项替换它。
- en: Finally, you saw how the dependency cache of Gradle works. It is designed to
    reduce network requests and provide reliable and repeatable builds that have dependencies.
    You learned how you can customize the expiration time for dependency modules that
    are changing or are defined with dynamic versions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你看到了Gradle的依赖项缓存是如何工作的。它是为了减少网络请求，提供具有依赖项的可靠和可重复的构建。你学习了如何自定义更改或定义为动态版本的依赖项模块的过期时间。
- en: Up until now, we saw how to include dependencies in our projects, but in the
    next chapter, we will see how we can publish artifacts that we created as dependencies
    for other projects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了如何在项目中包含依赖项，但在下一章中，我们将看到如何发布我们为其他项目创建的依赖项的工件。
