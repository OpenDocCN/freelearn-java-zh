- en: SpringWebFlux for Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpringWebFlux for Microservices
- en: Up until this point, we have discussed Reactor as a standalone framework. We
    have also seen how we can build publishers and subscribe to them. Reactor is well
    suited to handling the exchanging of large volumes of data, but it is important
    to note that Reactor is not limited to standalone programming only; it can also
    be used to build web applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了 Reactor 作为独立框架。我们还看到了如何构建发布者并订阅它们。Reactor 非常适合处理大量数据的交换，但需要注意的是，Reactor
    不仅限于独立编程；它还可以用于构建 Web 应用程序。
- en: Traditionally, we built enterprise-grade web applications using the SpringMVC
    framework, a synchronous and blocking framework from the Spring ecosystem. SpringMVC
    can also serve asynchronous non-blocking data using Servlet 3.1, but then it moves
    away from the concepts of request mappers and filters. This makes the framework
    quite difficult to work with. Furthermore, when building microservice architecture
    for high performance, the framework may not be the optimum choice. With such an
    architecture, we would like to have independent, scalable, and resilient services.
    SpringMVC doesn't define any of these characteristics. As discussed in [Chapter
    1](56427f5d-9ba0-4582-be2a-1b7f3f116287.xhtml), *Getting Started with Reactive
    Streams,* the previously discussed non-functional requirements are the characteristics
    of the Reactive Manifesto.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们使用 SpringMVC 框架构建企业级 Web 应用程序，SpringMVC 是 Spring 生态系统中的一个同步和阻塞框架。SpringMVC
    还可以使用 Servlet 3.1 提供异步非阻塞数据，但那时它就远离了请求映射器和过滤器的概念。这使得框架相当难以使用。此外，在构建高性能的微服务架构时，该框架可能不是最佳选择。在这种架构中，我们希望拥有独立、可扩展和有弹性的服务。SpringMVC
    并没有定义这些特性中的任何一项。如 [第 1 章](56427f5d-9ba0-4582-be2a-1b7f3f116287.xhtml) 所述，“开始使用反应式流”，之前讨论的非功能性需求是反应式宣言的特性。
- en: Noticing this gap, the Spring community came up with the SpringWebFlux framework.
    This framework is based on Reactor and enables the creation of web-based microservices.
    Not just non-blocking, SpringWebFlux is a functional framework, which allows us
    to use Java 8 lambda functions as web endpoints. The framework offers a complete
    solution for non-blocking web stacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这个差距，Spring 社区提出了 SpringWebFlux 框架。此框架基于 Reactor，并能够创建基于 Web 的微服务。SpringWebFlux
    不仅是非阻塞的，它还是一个函数式框架，允许我们使用 Java 8 lambda 函数作为 Web 端点。该框架为非阻塞 Web 栈提供了一套完整的解决方案。
- en: Technical requirements
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Java Standard Edition, JDK 8 or above
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 标准版，JDK 8 或更高版本
- en: IntelliJ IDEA IDE 2018.1 or above
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE 2018.1 或更高版本
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter05).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 GitHub 链接为 [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter05)。
- en: Introduction to SpringWebFlux
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpringWebFlux 简介
- en: 'To enable us to build web-based services, SpringWebFlux offers the following
    programming models:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们能够构建基于 Web 的服务，SpringWebFlux 提供以下编程模型：
- en: '**Annotations**: Annotations were originally part of the SpringMVC stack. These
    annotations are also supported by the SpringWebFlux framework. This is the easiest
    way of getting started with the SpringWebFlux stack.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注解**：注解最初是 SpringMVC 栈的一部分。这些注解也由 SpringWebFlux 框架支持。这是开始使用 SpringWebFlux
    栈的最简单方法。'
- en: '**Functional endpoints**: This model allows us to build Java 8 functions as
    web endpoints. The application can be configured as a set of routes, handlers,
    and filters. It then enables passing all of these as lambda functions in order
    to build the application in a functional paradigm.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能端点**：此模型允许我们构建 Java 8 函数作为 Web 端点。应用程序可以配置为一系列路由、处理器和过滤器。然后它允许将这些全部作为 lambda
    函数传递，以便在函数式范式下构建应用程序。'
- en: 'In order to work with SpringWebFlux, we need to configure an underlying server.
    While writing this book, Netty, Tomcat, Jetty, and Undertow are the choices currently
    offered here. Netty is often used as the standard choice because it performs well
    for asynchronous, non-blocking applications. It is also a non-servlet-based server,
    unlike Tomcat and Jetty. The following diagram depicts this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 SpringWebFlux，我们需要配置一个底层服务器。在编写本书时，Netty、Tomcat、Jetty 和 Undertow 是这里提供的当前选择。Netty
    通常被用作标准选择，因为它在异步、非阻塞应用程序中表现良好。它也是一个非 servlet 服务器，与 Tomcat 和 Jetty 不同。以下图表展示了这一点：
- en: '![](img/d262aa1a-cecf-41cc-b454-11fba6e16c16.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d262aa1a-cecf-41cc-b454-11fba6e16c16.png)'
- en: Configuring annotations
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置注解
- en: 'SpringWebFlux supports annotation-based controllers. This is in line with SpringMVC.
    There are two annotations used to create controllers:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SpringWebFlux 支持基于注解的控制器。这与 SpringMVC 保持一致。用于创建控制器有两个注解：
- en: '`@Controller`: The annotation defines a generic web component. Given a request,
    it creates a model object and generates a dynamic view response for it.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Controller`: 这个注解定义了一个通用的网络组件。给定一个请求，它创建一个模型对象并为它生成动态视图响应。'
- en: '`@RestController`: The annotation defines a RESTful web service. Given a request,
    it returns a response as JSON or XML. This is unlike the generic controller, which
    is capable of generating a dynamic web page for a request.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RestController`: 这个注解定义了一个 RESTful 网络服务。给定一个请求，它返回 JSON 或 XML 格式的响应。这与能够为请求生成动态网页的通用控制器不同。'
- en: 'Each of the controllers serves a request pattern. The following are annotations
    that can be used to define the request patterns served by a controller:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器都服务于一个请求模式。以下是可以用来定义控制器所服务请求模式的注解：
- en: '`@RequestMapping`: This annotation is used to mark a controller. It defines
    a request pattern prefix. It can also be used to define request headers, media
    types, HTTP methods, and so on.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping`: 这个注解用于标记控制器。它定义了一个请求模式前缀。它还可以用来定义请求头、媒体类型、HTTP 方法等。'
- en: '`@GetMapping`: This annotation is specific to the `GET` HTTP method. It can
    be used to define a `GET` HTTP request URL.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GetMapping`: 这个注解特定于 `GET` HTTP 方法。它可以用来定义一个 `GET` HTTP 请求 URL。'
- en: '`@PostMapping`: This annotation is specific to the `POST` HTTP method. It can
    be used to define a `POST` HTTP request URL.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PostMapping`: 这个注解特定于 `POST` HTTP 方法。它可以用来定义一个 `POST` HTTP 请求 URL。'
- en: '`@PutMapping`: This annotation is specific to the `PUT` HTTP method. It can
    be used to define a `PUT` HTTP request URL.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PutMapping`: 这个注解特定于 `PUT` HTTP 方法。它可以用来定义一个 `PUT` HTTP 请求 URL。'
- en: '`@DeleteMapping`: This annotation is specific to the `DELETE` HTTP method.
    It can be used to define a `DELETE` HTTP request URL.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DeleteMapping`: 这个注解特定于 `DELETE` HTTP 方法。它可以用来定义一个 `DELETE` HTTP 请求 URL。'
- en: '`@PatchMapping`: This annotation is specific to the `PATCH` HTTP method. It
    can be used to define a `PATCH` HTTP request URL.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PatchMapping`: 这个注解特定于 `PATCH` HTTP 方法。它可以用来定义一个 `PATCH` HTTP 请求 URL。'
- en: It is important to note that `@RequestMapping` matches all HTTP request methods,
    unlike the rest of the specific method annotations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，`@RequestMapping` 匹配所有 HTTP 请求方法，与其它特定方法注解不同。
- en: SpringBoot Starter
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpringBoot Starter
- en: Now, let's try to define a RESTful Fibonacci web service using the previously
    discussed annotations support. To do this, we are going to use Spring Boot as
    it offers a quick way to create enterprise-grade Spring applications. The Spring
    Boot project provides starter dependencies for all Spring modules. Each starter
    has assumed default conventions to ensure that a project is up and running without
    a fuss.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用之前讨论的注解支持来定义一个 RESTful 斐波那契网络服务。为此，我们将使用 Spring Boot，因为它提供了一种快速创建企业级
    Spring 应用程序的方法。Spring Boot 项目为所有 Spring 模块提供了启动依赖项。每个启动器都假设了默认约定，以确保项目无需麻烦即可启动运行。
- en: 'In order to use SpringWebFlux, we need to add the `spring-boot-starter-webflux`
    dependency to our project. Let''s revisit our `build.gradle`, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 SpringWebFlux，我们需要将 `spring-boot-starter-webflux` 依赖项添加到我们的项目中。让我们回顾一下
    `build.gradle` 文件，如下所示：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding `build.gradle`, we have the following changes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `build.gradle` 文件中，我们有以下更改：
- en: The `spring-boot` plugin has been added to our `gradle` build.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经将 `spring-boot` 插件添加到我们的 `gradle` 构建中。
- en: The `spring-boot-dependency` plugin has been added to our `gradle` build. The
    plugin adds a Maven-like dependency management capability to our `gradle` build.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经将 `spring-boot-dependency` 插件添加到我们的 `gradle` 构建中。该插件为我们的 `gradle` 构建添加了类似
    Maven 的依赖项管理功能。
- en: '`spring-boot-starter-webflux` has been added as a dependency. This project
    brings in transitive dependencies for other `webflux`-related projects, such as
    `webflux`, `netty-core`, and so on.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-webflux` 已作为依赖项添加。此项目引入了其他 `webflux` 相关项目的传递依赖项，例如 `webflux`、`netty-core`
    等。'
- en: The `spring-boot-gradle` plugin has been added under the plugins configuration.
    This enables us to run the Spring application from the command line using the
    `gradlew bootrun` command.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插件配置下已经添加了 `spring-boot-gradle` 插件。这使我们能够使用 `gradlew bootrun` 命令从命令行运行 Spring
    应用程序。
- en: By default, `Spring-boot-start-webflux` will bring a Netty dependency. If we
    decide to use Tomcat or any other server, we would exclude `spring-boot-starter-reactor-netty`
    and include said server dependency.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Spring-boot-start-webflux`会引入Netty依赖项。如果我们决定使用Tomcat或其他服务器，我们将排除`spring-boot-starter-reactor-netty`并包含该服务器依赖项。
- en: Adding a controller
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加控制器
- en: 'We need to add a controller that can serve Fibonacci numbers. As discussed
    in the preceding sections, we need to add a class with the `@RestController` annotation.
    Let''s look at the following controller:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个可以提供斐波那契数的控制器。如前所述，我们需要添加一个带有`@RestController`注解的类。让我们看看以下控制器：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding class, we have done the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中，我们做了以下操作：
- en: 'Added `@RestController` to the `ReactiveController` class. This enables the
    class as a RESTful web service:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@RestController`添加到`ReactiveController`类中。这使该类成为RESTful Web服务：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Added `@GetMapping` to the `fibonacciSeries` method. This allows us to invoke
    the method on receiving a HTTP `GET` request for the `/fibonacci` URL.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@GetMapping`添加到`fibonacciSeries`方法中。这允许我们在接收到对`/fibonacci` URL的HTTP `GET`请求时调用该方法。
- en: It is important to note here that the `fibonacciSeries` method returns a `Flux<Long>`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里需要注意的是，`fibonacciSeries`方法返回一个`Flux<Long>`。
- en: 'Now, we also need to add a `Main` class, which can run `SpringApplication`.
    The `Main` class must be annotated with `@EnableWebFlux` to ensure that the Spring
    context instantiates and registers SpringWebFlux-related classes. This is depicted
    using the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要添加一个`Main`类，它可以运行`SpringApplication`。`Main`类必须注解为`@EnableWebFlux`，以确保Spring上下文实例化和注册与SpringWebFlux相关的类。这可以通过以下代码表示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the application using the `gradlew bootrun` command. This will start the
    Netty server on port `8080`. Lastly, look up `http://localhost:8080/fibonacci`
    to receive the following result:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gradlew bootrun`命令运行应用程序。这将启动端口`8080`上的Netty服务器。最后，查找`http://localhost:8080/fibonacci`以接收以下结果：
- en: '![](img/6e5eb5b5-51b0-4239-a8e3-b9073d10773d.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e5eb5b5-51b0-4239-a8e3-b9073d10773d.png)'
- en: Method parameters
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法参数
- en: 'In the preceding code, the `fibonacciSeries` request method did not accept
    any arguments. This is because we did not expect any input. In case we foresee
    any input parameters, they can be bound with the following annotations:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`fibonacciSeries`请求方法不接受任何参数。这是因为我们没有期望任何输入。如果我们预见任何输入参数，它们可以用以下注解进行绑定：
- en: '`@PathVariable`: This annotation is used to access values for URI template
    variables. These templates are automatically converted into an appropriate type.
    If no matching type is found, a `TypeMismatchException` is raised:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PathVariable`：此注解用于访问URI模板变量的值。这些模板将自动转换为适当类型。如果没有找到匹配的类型，将引发`TypeMismatchException`：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`@RequestParam`: The annotation is used to determine values passed as query
    parameters. Here, data type conversion is also performed automatically:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestParam`：此注解用于确定作为查询参数传递的值。这里也执行了数据类型的自动转换：'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`@RequestHeader`: The annotation is used to determine values passed in request
    headers. Data type conversion into the target type is performed automatically:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestHeader`：此注解用于确定请求头中传递的值。数据类型转换到目标类型是自动执行的：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`@RequestBody`: The annotation is used to determine values passed in the request
    body. Data type conversion into the target type is performed automatically. SpringWebFlux
    supports reading data as reactive types of Flux and `Mono`, and thus performs
    a non-blocking read:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestBody`：此注解用于确定请求体中传递的值。数据类型转换到目标类型是自动执行的。SpringWebFlux支持以反应式类型Flux和Mono读取数据，因此执行非阻塞读取：'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`@CookieValue`: This annotation is used to determine the HTTP cookie value
    as part of the request. Data type conversion into the target type is performed
    automatically.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CookieValue`：此注解用于确定请求中作为一部分的HTTP cookie值。数据类型转换到目标类型是自动执行的。'
- en: '`@ModelAttribute`: This annotation is used to determine an attribute from the
    request model or instantiate one if not present. Once created, property values
    of the attribute are initialized using the query parameters passed and the submitted
    form fields:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ModelAttribute`：此注解用于确定请求模型中的属性或在没有提供的情况下实例化一个。一旦创建，属性的属性值将使用传递的查询参数和提交的表单字段进行初始化：'
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`@SessionAttribute`: This annotation is used to determine preexisting session
    attributes. Data type conversion into the target type is performed automatically.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SessionAttribute`：此注解用于确定预存在的会话属性。数据类型转换到目标类型是自动执行的。'
- en: '`@RequestAttribute`: This annotation is used to determine preexisting request
    attributes created by a previous filter execution. Data type conversion into the
    target type is performed automatically.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestAttribute`: 这个注解用于确定由先前过滤器执行创建的现有请求属性。数据类型自动转换为目标类型。'
- en: Apart from the method parameters, there is `@ResponseBody`, which is used to
    serialize the `return` method using the appropriate HTTP writer. This can be used
    to return JSON and XML type responses from the request method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了方法参数外，还有`@ResponseBody`，它用于使用适当的HTTP写入器序列化`return`方法。这可以用于从请求方法返回JSON和XML类型的响应。
- en: Exception handling
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'Applications often raise exceptions while processing requests. These exceptions
    must be handled properly, otherwise they will send back a HTTP 500 error to the
    requesting client. SpringWebFlux supports exception handling by creating methods
    that are annotated with `@ExceptionHandler`. These exception handlers can have
    the exception raised as an argument:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在处理请求时经常会抛出异常。这些异常必须得到适当的处理，否则它们将向请求客户端发送HTTP 500错误。SpringWebFlux通过创建带有`@ExceptionHandler`注解的方法来支持异常处理。这些异常处理器可以将抛出的异常作为参数：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An exception handler can have the same return types as request methods. Optionally,
    we would like to set the HTTP status as part of exception handling, but Spring
    does not do this automatically. It can be accomplished by returning a `ResponseEntity`,
    which contains the response body as well as the required HTTP status code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理器可以具有与请求方法相同的返回类型。可选地，我们希望在异常处理过程中设置HTTP状态，但Spring不会自动执行此操作。可以通过返回一个包含响应体以及所需的HTTP状态码的`ResponseEntity`来实现。
- en: Configuring functions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置函数
- en: In the preceding section, we configured SpringWebFlux using the traditional
    annotation approach. Now, we will see how we can use Java 8 lambdas to configure
    SpringWebFlux in a functional manner. Let's looks at the key components required
    to get this up and running.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用传统的注解方法配置了SpringWebFlux。现在，我们将看到如何使用Java 8 lambda以函数式方式配置SpringWebFlux。让我们看看启动所需的关键组件。
- en: The handler function
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理函数
- en: 'The handler function is responsible for serving a given request. It takes the
    request in the form of a `ServerRequest` class and generates the response as `ServerResponse`.
    Both `ServerRequest` and `ServerResponse` are immutable Java 8 classes. These
    classes support reactive types of `Mono` and Flux for reading/writing data passed
    in the body of the request/response. Let''s try to build our first `hello-world`
    example using the preceding components:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数负责服务给定的请求。它以`ServerRequest`类的形式接收请求，并生成`ServerResponse`响应。`ServerRequest`和`ServerResponse`都是不可变的Java
    8类。这些类支持用于读取/写入请求/响应体中传递的数据的反应式类型`Mono`和`Flux`。让我们尝试使用前面的组件构建我们的第一个`hello-world`示例：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we are doing the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在执行以下操作：
- en: The lambda takes a `ServerRequest` input request type
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda函数接受`ServerRequest`输入请求类型
- en: It tries to determine whether a `name` query parameter has been passed
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它试图确定是否传递了`name`查询参数
- en: The function returns the OK(HTTP 200) response
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数返回OK（HTTP 200）响应
- en: The response body contains `Hello to the world`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应体包含`Hello to the world`
- en: 'This was only a simple example but it clearly demonstrates what can be accomplished
    using Java 8 lambdas. We can add a query to a reactive database such as Mongo,
    or an external invocation, and return the response as Mono or Flux. If we look
    closely at `ServerRequest`, the following methods have been provided to convert
    request-body as reactive type:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的示例，但它清楚地展示了使用Java 8 lambda可以实现什么。我们可以向反应式数据库（如Mongo）或外部调用添加查询，并将响应作为Mono或Flux返回。如果我们仔细查看`ServerRequest`，以下方法已被提供以将请求体转换为反应类型：
- en: '`bodyToMono(Class<T> type)`: This reads a single object of the specified type
    as a Mono response'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bodyToMono(Class<T> type)`: 这个方法将指定类型的单个对象作为Mono响应读取'
- en: '`bodyToFlux(Class<T> type)`: This reads multiple objects of the specified type
    as a Flux response'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bodyToFlux(Class<T> type)`: 这个方法将指定类型的多个对象作为Flux响应读取'
- en: 'If we look at the preceding code, we have used the `BodyInserters.fromObject()`
    static method to write to the response body. This is not the only method to do
    this. There are many methods to write back the response body, some of which are
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看前面的代码，我们使用了`BodyInserters.fromObject()`静态方法来写入响应体。这不是唯一的方法来做这件事。有许多方法可以写回响应体，以下是一些方法：
- en: '`fromObject`: This method writes back data as an object'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromObject`: 此方法将数据写回为对象'
- en: '`fromPublisher`: This method writes back data from a given Reactive Streams
    publisher'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromPublisher`: 此方法将数据从给定的Reactive Streams发布者写回'
- en: '`fromFormData`: This method writes back the given key-value pair and form data'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromFormData`: 此方法将给定的键值对和表单数据写回'
- en: '`fromMultipartData`: This method writes back the given data as multipart data'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromMultipartData`: 此方法将给定数据写回为多部分数据'
- en: Handler functions written as lambdas are quite convenient but they become difficult
    to read and maintain in the long run. It is often recommended to group the handler
    functions for a particular functionality in one single handler class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以lambda表达式编写的处理函数非常方便，但长期来看它们变得难以阅读和维护。通常建议将特定功能的手动函数组合在一个单独的处理类中。
- en: The router function
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由函数
- en: The router function is responsible for routing incoming requests to the correct
    handler function. If we compare this to the annotation approach, then it is analogous
    to the `@RequestMapping` annotation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 路由函数负责将传入的请求路由到正确的处理函数。如果我们将其与注解方法进行比较，那么它类似于`@RequestMapping`注解。
- en: 'A request is matched using `RequestPredicate`, which tries to validate the
    intended matching criteria. Our previously created `helloHandler` can be configured
    in the following manner:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RequestPredicate`来匹配请求，它试图验证预期的匹配标准。我们之前创建的`helloHandler`可以按以下方式配置：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code is doing the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: It registers a predicate for the `/hello` path
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它为`/hello`路径注册了一个谓词
- en: If a request matches this path, the router invokes `helloHandler`
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求匹配此路径，则路由器调用`helloHandler`
- en: 'If we look at `RequestPredicate`, this is a functional interface in which we
    need to implement the test method only:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`RequestPredicate`，这是一个需要仅实现测试方法的函数式接口：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, implementing `RequestPredicate` is not required. The framework provides
    the `RequestPredicates` utility class with most commonly used predicates. The
    utility provides routing based on HTTP methods, HTTP headers, query parameters,
    URL path, and so on. Let''s looks at the methods offered by the `RequestPredicates`
    utils class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实现`RequestPredicate`不是必需的。框架提供了`RequestPredicates`实用类，其中包含大多数常用谓词。该实用类提供了基于HTTP方法、HTTP头、查询参数、URL路径等的路由。让我们看看`RequestPredicates`实用类提供的方法：
- en: '| **Methods** | **Match** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **匹配** |'
- en: '| `path(String pattern)` | Predicate matches the passed URL |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `path(String pattern)` | 谓词匹配传入的URL |'
- en: '| `patternDELETE(String pattern)` | Predicate matches the passed URL pattern
    when HTTP method is `DELETE` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `patternDELETE(String pattern)` | 当HTTP方法为`DELETE`时，谓词匹配传入的URL模式 |'
- en: '| `GET(String pattern)` | Predicate matches the passed URL pattern when HTTP
    method is `GET` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `GET(String pattern)` | 当HTTP方法为`GET`时，谓词匹配传入的URL模式 |'
- en: '| `PUT(String pattern)` | Predicate matches the passed URL pattern when HTTP
    method is `PUT` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `PUT(String pattern)` | 当HTTP方法为`PUT`时，谓词匹配传入的URL模式 |'
- en: '| `POST(String pattern)` | Predicate matches the passed URL pattern when HTTP
    method is `POST` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `POST(String pattern)` | 当HTTP方法为`POST`时，谓词匹配传入的URL模式 |'
- en: '| `PATCH(String pattern)` | Predicate matches the passed URL pattern when HTTP
    method is `PATCH` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH(String pattern)` | 当HTTP方法为`PATCH`时，谓词匹配传入的URL模式 |'
- en: '| `HEAD(String pattern)` | Predicate matches the passed URL pattern when HTTP
    method is `HEAD` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD(String pattern)` | 当HTTP方法为`HEAD`时，谓词匹配传入的URL模式 |'
- en: '| `method(HttpMethod method)` | Predicate determines if the request method
    is the same as that passed |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `method(HttpMethod method)` | 谓词确定请求方法是否与传入的方法相同 |'
- en: '| `oneaccept(MediaType type)` | Predicate determines if the request accepts
    header contains the given `MediaType` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `oneaccept(MediaType type)` | 谓词确定请求接受头是否包含给定的`MediaType` |'
- en: '| `contentType(mediaType type)` | Predicate determines if the request''s `contentType`
    header contains the given `MediaType` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `contentType(mediaType type)` | 谓词确定请求的`contentType`头是否包含给定的`MediaType` |'
- en: '| `headers(Predicate headerPredicate)` | Predicate determines if the request
    header matches the predicate query |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `headers(Predicate headerPredicate)` | 谓词确定请求头是否匹配谓词查询 |'
- en: '| `Param(String name, String value)` | Predicate determines if the request
    query parameters contain the key-value pair |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `Param(String name, String value)` | 谓词确定请求查询参数是否包含键值对 |'
- en: '| `all()` | Predicate always matches the request |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `all()` | 谓词始终匹配请求 |'
- en: 'We can combine one or more of these predicates to build composite matching
    criteria. The criteria can be combined using the following methods of `RequestPredicate`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个或多个这些谓词组合起来构建复合匹配条件。可以使用以下`RequestPredicate`方法组合条件：
- en: '`RequestPredicate.and(RequestPredicate)`: Builds the logical `AND` criteria,
    where both must match'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestPredicate.and(RequestPredicate)`: 构建逻辑`AND`条件，其中两者都必须匹配'
- en: '`RequestPredicate.or(RequestPredicate)`: Builds the logical `OR` criteria,
    where either can match'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestPredicate.or(RequestPredicate)`: 构建逻辑`OR`条件，其中任一可以匹配'
- en: '`RequestPredicate.negate()`: Builds the logical `NOT` criteria, which it must
    not match'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestPredicate.negate()`: 构建逻辑`NOT`条件，它必须不匹配'
- en: '`RequestPredicates` are configured using the `Route` functions from the `RouterFunctions`
    utility class. Additional routes can be configured using the following methods
    from `RouterFunction`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RouterFunctions`实用类的`Route`函数配置`RequestPredicates`。可以使用以下`RouterFunction`方法配置额外的路由：
- en: '`RouterFunctions.router(predicate,handler)`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouterFunctions.router(predicate,handler)`'
- en: '`RouterFunction.andRoute(predicate,handler)`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouterFunction.andRoute(predicate,handler)`'
- en: HandlerFilter
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HandlerFilter
- en: '`HandlerFilter` is analogous to the Servlet filter. This executes before the
    request gets processed by `HandlerFunction`. There could be chain filters that
    get executed before the request gets served. If a filter sends back a `ServerResponse`,
    then the request is terminated as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlerFilter`类似于Servlet过滤器。它在`HandlerFunction`处理请求之前执行。在请求被服务之前，可能会有链式过滤器被执行。如果过滤器返回`ServerResponse`，则请求将按以下方式终止：'
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code is doing the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码正在执行以下操作：
- en: Adding a filter to `helloRoute` using the `filter()` method
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`filter()`方法向`helloRoute`添加过滤器
- en: The filter takes a request and the next handler function
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤器接收一个请求和下一个处理函数
- en: Validating whether or not the request headers contain the `UTF-8` charset in
    the Accept-Language header
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证请求头是否在`Accept-Language`头中包含`UTF-8`字符集
- en: If so, forward the request to the next function
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，将请求转发到下一个函数
- en: 'If not, then build a `ServerResponse` with the status as `BAD_REQUEST`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，则构建状态为`BAD_REQUEST`的`ServerResponse`：
- en: '![](img/da920649-70ec-46c0-a396-7fed5ef78992.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da920649-70ec-46c0-a396-7fed5ef78992.png)'
- en: HttpHandler
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HttpHandler
- en: 'Now that we have mapped a request using the handler and router, the only step
    left is to start the server. SpringWebFlux enables us to programmatically start
    the server. In order to do so, we have to get `HttpHandler` from `RouterFunction`
    and then start the required server:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用处理程序和路由器映射了一个请求，剩下的唯一步骤是启动服务器。SpringWebFlux使我们能够以编程方式启动服务器。为了做到这一点，我们必须从`RouterFunction`获取`HttpHandler`然后启动所需的服务器：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code is specific to Netty, as we are using `reactor-netty` in
    our current example. In the preceding code, we are doing the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码特定于Netty，因为我们当前示例中使用了`reactor-netty`。在上述代码中，我们正在执行以下操作：
- en: Converting the `helloRoute` to a `HttpHandler` using `RoterFunctions.toHttpHandler`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RoterFunctions.toHttpHandler`将`helloRoute`转换为`HttpHandler`
- en: Instantiating Netty's `ReactorHttpHandlerAdapter` and using it to configure
    the Netty `HttpServer`
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化Netty的`ReactorHttpHandlerAdapter`并使用它来配置Netty `HttpServer`
- en: Finally, we block to listen for incoming requests and serve them
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们阻塞以监听传入的请求并为其提供服务
- en: 'The preceding configuration is specific to the underlying server. While working
    with `Undertow`, the configuration can be built using the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置特定于底层服务器。当使用`Undertow`时，可以使用以下代码构建配置：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code is applicable to Tomcat:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码适用于Tomcat：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, we can leave all this configuration to Spring and use the Spring
    `DispatcherHandler`-based configuration to start the server. The configuration
    is Java annotation-based. The configuration automatically registers the following
    additional components to support functional endpoints:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将所有这些配置留给Spring，并使用基于Spring `DispatcherHandler`的配置来启动服务器。该配置基于Java注解。配置自动注册以下附加组件以支持功能端点：
- en: '`RouterFunctionMapping`:  This determines the list of `RouterFunction` `<?>`
    beans in the Spring configuration. This combines them and routes the request to
    the correct `RouterFunction`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouterFunctionMapping`:  这确定Spring配置中`RouterFunction` `<?>` bean的列表。它将它们组合并将请求路由到正确的`RouterFunction`。'
- en: '`HandlerFunctionAdapter`: This invokes the correct `HandlerFunction` when a
    request is received.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HandlerFunctionAdapter`: 当收到请求时，调用正确的`HandlerFunction`。'
- en: '`ServerResponseResultHandler`: This writes back the `ServerResponse` from the
    `HandlerFunction` invocation.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerResponseResultHandler`：这将从`HandlerFunction`调用中写回`ServerResponse`。'
- en: All the preceding components are registered by Spring when we use the `@EnableWebFlux`
    annotation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`@EnableWebFlux`注解时，所有前面的组件都是由Spring注册的。
- en: Fibonacci functional router
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斐波那契功能路由器
- en: 'Now that we have seen the basics of functional mappings, let''s try to render
    the Fibonacci series using them. We will use the same Fibonacci generator developed
    in the previous section. We have seen that we can write a Reactive Stream publisher
    into `ServerResponse`, as demonstrated in the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了功能映射的基础，让我们尝试使用它们来渲染斐波那契序列。我们将使用上一节中开发的相同的斐波那契生成器。我们看到了我们可以将Reactive
    Stream发布者写入`ServerResponse`，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we did the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Created a `FibonacciGenerator` to generate the series
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个`FibonacciGenerator`来生成序列
- en: Configured a route for `/fibonacci` and then sent back the response of Fibonacci
    numbers
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`/fibonacci`配置了一个路由，然后返回了斐波那契数的响应
- en: The method is annotated with `@Bean`, which will automatically register this
    route with `SpringContext`
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法被注解为`@Bean`，这将自动将此路由注册到`SpringContext`
- en: The class is annotated with `@Configuration`
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类被注解为`@Configuration`
- en: 'Now, all that remains is to configure SpringWebFlux to pick this configuration.
    This is done by creating a `Main` class and annotating it with the required annotations:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的只是配置SpringWebFlux以选择此配置。这是通过创建一个`Main`类并使用所需的注解来完成的：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding class is exactly the same as we used to work with annotations
    in SpringWebFlux. Now, let''s run the server using the `spring-boot` plugin:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类与我们用于在SpringWebFlux中处理注解的类完全相同。现在，让我们使用`spring-boot`插件运行服务器：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This brings up Netty on port `8080`. Let''s submit the `http://localhost:8080/fibonacci`
    URL to determine the response:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口`8080`上启动Netty。让我们提交`http://localhost:8080/fibonacci` URL以确定响应：
- en: '![](img/b9b25ad7-bdeb-44b4-bd2b-1f3df4240645.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9b25ad7-bdeb-44b4-bd2b-1f3df4240645.png)'
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at using the SpringWebFlux framework to build web-based
    microservices. We also discussed the various server options offered by the project
    and looked at the traditional annotation-based approach to building microservices.
    We discovered that all annotations from the SpringMVC project are supported by
    the SpringWebFlux project. Next, we took the functional approach to building microservices.
    We configured the router and handler functions to build the Fibonacci web service.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用SpringWebFlux框架构建基于Web的微服务。我们还讨论了项目提供的各种服务器选项，并查看了解决微服务的传统基于注解的方法。我们发现SpringMVC项目中的所有注解都由SpringWebFlux项目支持。接下来，我们采用了构建微服务的功能方法。我们配置了路由和处理函数来构建斐波那契Web服务。
- en: In the next chapter, we will look at ways to add other web features, such as
    web page templates, security, and much more, to a SpringWebFlux-based web service.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨向基于SpringWebFlux的Web服务添加其他Web功能的方法，例如网页模板、安全性和更多内容。
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can we configure the SpringWebFlux project?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何配置SpringWebFlux项目？
- en: What `MethodParameter` annotations are supported by SpringWebFlux?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SpringWebFlux支持哪些`MethodParameter`注解？
- en: What is the use of `ExceptionHandler`?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExceptionHandler`的用途是什么？'
- en: What is the use of `HandlerFunction`?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HandlerFunction`的用途是什么？'
- en: What is the use of `RouterFunction`?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RouterFunction`的用途是什么？'
- en: What is the use of `HandlerFilter`?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HandlerFilter`的用途是什么？'
