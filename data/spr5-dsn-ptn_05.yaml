- en: Understanding the Bean Life Cycle and Used Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Bean生命周期和使用的模式
- en: In the previous chapter, you saw how Spring creates beans in the container.
    You also learned how to configure the dependency injection pattern using XML,
    Java, and Annotation. In this chapter, we will go into more detail, beyond injecting
    beans and the configuration of dependencies in a Spring application. Here, you
    will explore the life and scope of beans in the container, and learn how the Spring
    container works on the defined Spring bean configuration with XML, Annotation,
    and Java. Spring allows us to control not only the various configurations for
    the DI pattern and dependency values that are to be injected into the object created
    from a particular bean definition, but also the life and scope of the beans created
    from a particular bean definition.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到了Spring如何在容器中创建bean。你还学习了如何使用XML、Java和注解来配置依赖注入模式。在本章中，我们将更深入地探讨，不仅限于在Spring应用程序中注入bean和配置依赖项。在这里，你将探索容器中bean的生命周期和范围，并了解Spring容器如何使用XML、注解和Java在定义的Spring
    bean配置上工作。Spring不仅允许我们控制从特定bean定义创建的对象的DI模式的各种配置和要注入的依赖值，还控制从特定bean定义创建的bean的生命周期和范围。
- en: When I was writing this chapter, my two and a half year old son, Arnav, came
    to me and started playing a video game on my mobile. He was wearing a T-Shirt,
    which had an interesting quote on it, and these lines described his whole day.
    The lines went like this--
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写这一章时，我两岁半的儿子Arnav走过来，开始在我的手机上玩电子游戏。他穿着一件印有有趣引语的T恤，这些线条描述了他的一天。这些线条是这样的—
- en: '*My Perfect Day: Wake up, Play Video Games, Eat, Play Video Games, Eat, Play
    Video Games, and Sleep*.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*我的完美一天：醒来，玩电子游戏，吃饭，玩电子游戏，吃饭，玩电子游戏，然后睡觉*。'
- en: Actually, these lines perfectly reflected his life cycle for each day, as he
    woke up, played, ate, and played again before, finally, going to sleep. With this
    example, I just wanted to demonstrate that everything has a life cycle. We could
    discuss the life cycle of a butterfly, a star, a frog, or a plant. But let's talk
    about something more interesting--the life cycle of a bean!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些线条完美地反映了他每天的生活周期，因为他醒来，玩耍，吃饭，然后再玩耍，最后睡觉。通过这个例子，我只是想证明万物都有生命周期。我们可以讨论蝴蝶、星星、青蛙或植物的生命周期。但让我们谈谈更有趣的事情——bean的生命周期！
- en: 'Every bean in the Spring container has a life cycle and its own scope. The
    Spring container manages the life of the beans in a Spring application. We can
    customize it in some phases by using Spring-aware interfaces. This chapter will
    talk about the life of a bean in the container, and how it is managed using design
    patterns in the various phases of its life. By the end of this chapter, you would
    have a fair idea of the bean life cycle and its various phases in the container.
    You will also learn about the many types of bean scope in Spring. This chapter
    will cover the following points:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Spring容器中的每个bean都有其生命周期和作用域。Spring容器管理Spring应用程序中bean的生命。我们可以通过使用Spring感知接口在某些阶段自定义它。本章将讨论容器中bean的生命，以及它是如何在其生命周期的各个阶段使用设计模式进行管理的。到本章结束时，你将对容器中bean生命周期及其各个阶段有一个相当的了解。你还将了解Spring中许多类型的bean作用域。本章将涵盖以下要点：
- en: 'The Spring bean life cycle, and its phases, which are listed as follows:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring bean的生命周期及其阶段，如下所示：
- en: The initialization phase
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化阶段
- en: The Use phase
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阶段
- en: The destruction phase
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁阶段
- en: Spring callbacks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring回调
- en: Understanding bean scopes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解bean作用域
- en: Singleton pattern
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: Prototype pattern
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式
- en: Custom scopes
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义作用域
- en: Other bean scopes
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他bean作用域
- en: Now let's take a moment to see how Spring manages the life cycle of a bean from
    creation to destruction in the Spring application
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们花一点时间看看Spring如何在Spring应用程序中管理bean从创建到销毁的生命周期
- en: The Spring bean life cycle and its phases
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring bean生命周期及其阶段
- en: 'In a Spring application, the term life cycle applies to any class of application--Standalone
    Java, Spring Boot application, or Integration/System Test. Also, life cycle applies
    to all three dependency injection styles--XML, Annotations, and Java configuration.
    You define the configuration for beans as per business goals. But Spring creates
    these beans and manages the life cycle of the Spring beans. Spring loads the bean
    configurations either in Java or XML through `ApplicationContext`. After loading
    these beans, the Spring container handles the creation and instantiation of these
    beans as per your configuration. Let''s divide the Spring application life cycle
    into three phases as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring 应用程序中，生命周期这一术语适用于任何应用程序类——独立 Java、Spring Boot 应用程序或集成/系统测试。生命周期也适用于所有三种依赖注入样式——XML、注解和
    Java 配置。你根据业务目标定义 Bean 的配置。但是 Spring 创建这些 Bean 并管理 Spring Bean 的生命周期。Spring 通过
    `ApplicationContext` 加载 Bean 配置；一旦创建应用程序上下文，初始化阶段就完成了。让我们看看 Spring 是如何加载 Java
    或 XML 配置文件的。
- en: The initialization phase
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化阶段
- en: The Use phase
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阶段
- en: The destruction phase
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁阶段
- en: 'Please refer to the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下图表：
- en: '![](img/3ca661ad-4883-4927-b755-08a69c8efffe.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ca661ad-4883-4927-b755-08a69c8efffe.png)'
- en: As you can see in the preceding diagram, each Spring bean goes through these
    three phases in the complete life cycle. Each phase has some set of operations
    to be performed for each Spring bean (depending on the configuration). Spring
    fits in to manage your application life cycle. It plays an important role in all
    three phases.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，每个 Spring 容器在完整生命周期中都会经历这三个阶段。每个阶段都有一些针对每个 Spring 容器（根据配置）要执行的操作。Spring
    介入以管理你的应用程序生命周期。它在所有三个阶段中都发挥着重要作用。
- en: Now let's take a moment to see how Spring works in the first, initialization
    phase.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们花一点时间看看 Spring 在第一个、初始化阶段是如何工作的。
- en: The initialization phase
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阶段
- en: In this phase, first of all Spring loads all the configuration files of any
    style-XML, Annotations, and Java configuration. This phase prepares the beans
    for use. The application is not usable until this phase is complete. This phase,
    actually, creates the application services for use, and it allocates the system
    resources to the bean. Spring provides `ApplicationContext` to load the bean configurations;
    once the application context is created, the initialization phase completes. Let's
    see how Spring loads the configuration files in Java or XML.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，首先 Spring 加载任何样式（XML、注解和 Java 配置）的所有配置文件。这个阶段为 Bean 的使用做准备。应用程序在这个阶段完成之前是不可用的。实际上，这个阶段创建了应用程序服务以供使用，并为
    Bean 分配系统资源。Spring 提供 `ApplicationContext` 来加载 Bean 配置；一旦创建应用程序上下文，初始化阶段就完成了。让我们看看
    Spring 是如何加载 Java 或 XML 配置文件的。
- en: Creating the application context from configuration
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从配置创建应用程序上下文
- en: 'Spring provides multiple implementations of `ApplicationContext` to load the
    various styles of configuration file. These are listed next:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了多个 `ApplicationContext` 的实现来加载各种配置文件样式。这些将在下面列出：
- en: 'For Java configuration, the following is used:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Java 配置，使用以下内容：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For XML configuration, the implementation is as follows:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 XML 配置，实现如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding codes, Spring loads the Java configuration files by using
    the `AnnotationConfigApplicationContext` class, and the XML configuration files
    by using the `ClassPathXmlApplicationContext` class for the Spring container.
    Spring behaves the same for all types of configuration. It does not matter what
    configuration styles you use in your application. The following diagram shows
    what exactly happens in this phase:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，Spring 通过 `AnnotationConfigApplicationContext` 类加载 Java 配置文件，通过 `ClassPathXmlApplicationContext`
    类加载 XML 配置文件以用于 Spring 容器。对于所有类型的配置，Spring 的行为都是相同的。你可以在应用程序中使用任何配置样式。以下图表显示了这一阶段的确切情况：
- en: '![](img/646b0215-c1dc-4108-b1bc-edd9726445ec.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/646b0215-c1dc-4108-b1bc-edd9726445ec.png)'
- en: 'As you can see in the preceding diagram, the initialization phase is divided
    into these two steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，初始化阶段分为以下两个步骤：
- en: Load bean definitions
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载 Bean 定义
- en: Initialize bean instances
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化 Bean 实例
- en: Load bean definitions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载 Bean 定义
- en: 'In this step, all the configuration files--`@Configuration` classes or XML
    files-are processed. For Annotation-based configuration, all the classes annotated
    with `@Components` are scanned to load the bean definitions. All XML files are
    parsed, and the bean definitions are added to a `BeanFactory`. Each bean is indexed
    under its `id`. Spring provides multiple `BeanFactoryPostProcessor` beans, so,
    it is invoked to resolve runtime dependencies such as reading values from external
    property files. In a Spring application, `BeanFactoryPostProcessor` can modify
    the definition of any bean. The following diagram describes this step:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，所有配置文件--`@Configuration` 类或 XML 文件--都被处理。对于基于注解的配置，所有带有 `@Components`
    注解的类都会被扫描以加载 bean 定义。所有 XML 文件都会被解析，bean 定义会被添加到 `BeanFactory` 中。每个 bean 都会按其
    `id` 进行索引。Spring 提供了多个 `BeanFactoryPostProcessor` bean，因此，它会调用以解决运行时依赖，例如从外部属性文件中读取值。在
    Spring 应用程序中，`BeanFactoryPostProcessor` 可以修改任何 bean 的定义。以下图表描述了这一步：
- en: '![](img/ecea9112-8d34-49fa-8e2a-60cbfed386f0.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecea9112-8d34-49fa-8e2a-60cbfed386f0.png)'
- en: 'As shown in the preceding diagram, Spring first loads the bean definitions,
    and then calls `BeanFactoryProcessor` for some beans to modify its definitions
    accordingly. Let''s see this with an example. We have two configuration files--`AppConfig.java`
    and `InfraConfig.java`, which are defined as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Spring 首先加载 bean 定义，然后调用 `BeanFactoryProcessor` 对某些 bean 进行相应的定义修改。让我们通过一个例子来看一下。我们有两个配置文件--`AppConfig.java`
    和 `InfraConfig.java`，它们被定义为如下：
- en: 'Following is the `AppConfig.java` file:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是对 `AppConfig.java` 文件的描述：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Following is the `InfraConfig.java` file:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是对 `InfraConfig.java` 文件的描述：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These Java configuration files are loaded by the **ApplicationContext** to
    the container, and indexed with its `id`, as shown in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 Java 配置文件被 **ApplicationContext** 载入容器，并按其 `id` 进行索引，如下所示：
- en: '![](img/923a2b5d-4f0d-4bd2-9c25-852474ea7221.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/923a2b5d-4f0d-4bd2-9c25-852474ea7221.png)'
- en: 'In the last diagram, Spring beans are indexed under its IDs into Spring''s
    `BeanFactory`, and then, that `BeanFactory` object is passed as an argument to
    the `postProcess()` method of `BeanFactoryPostProcessor`. The `BeanFactoryPostProcessor`
    can modify the bean definition for some beans; this depends on the bean configurations
    provided by the developer. Let''s see how `BeanFactoryPostProcessor` works, and
    how to override it in our application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个图中，Spring beans 按其 ID 索引到 Spring 的 `BeanFactory` 中，然后，该 `BeanFactory` 对象被传递给
    `BeanFactoryPostProcessor` 的 `postProcess()` 方法。`BeanFactoryPostProcessor` 可以修改某些
    bean 的定义；这取决于开发者提供的 bean 配置。让我们看看 `BeanFactoryPostProcessor` 的工作原理以及如何在我们的应用程序中覆盖它：
- en: '`BeanFactoryPostProcessor` works on the bean definitions or the configuration
    metadata of the bean before the beans are actually created.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BeanFactoryPostProcessor` 在 bean 实际创建之前，对 bean 定义或配置元数据进行操作。'
- en: Spring provides several useful implementations of `BeanFactoryPostProcessor`,
    such as reading properties and registering a custom scope.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring 提供了几个有用的 `BeanFactoryPostProcessor` 实现，例如读取属性和注册自定义作用域。
- en: You can write your own implementation of the `BeanFactoryPostProcessor` interface.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以编写自己的 `BeanFactoryPostProcessor` 接口实现。
- en: If you define a `BeanFactoryPostProcessor` in one container, it will only be
    applied to the bean definitions in that container.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在一个容器中定义了 `BeanFactoryPostProcessor`，它将只应用于该容器中的 bean 定义。
- en: 'The following is the code snippet for `BeanFactoryPostProcessor`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `BeanFactoryPostProcessor` 的代码片段：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s now see the following examples of the `BeanFactoryPostProcessor` extension
    point:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下 `BeanFactoryPostProcessor` 扩展点的以下示例：
- en: '**Reading external property files (**`database.properties`**)**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**读取外部属性文件（**`database.properties`**）**'
- en: 'Here, we''ll use the `DataSource` bean to be configured with the database values
    such as `username`, `password`, `db url`, and `driver`, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 `DataSource` bean 来配置数据库值，如 `username`、`password`、`db url` 和 `driver`，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the `DataSource` bean definition in the configuration file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在配置文件中的 `DataSource` bean 定义：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, in the preceding code, how do we resolve the `@Value` and `${..}` variables?
    We need a `PropertySourcesPlaceholderConfigurer` to evaluate them. This is a `BeanFactoryPostProcessor`.
    If you are using the XML configuration, the `<context:property-placeholder/>`
    namespace creates a `PropertySourcesPlaceholderConfigurer` for you.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在前面的代码中，我们是如何解析 `@Value` 和 `${..}` 变量的呢？我们需要一个 `PropertySourcesPlaceholderConfigurer`
    来评估它们。这是一个 `BeanFactoryPostProcessor`。如果您使用 XML 配置，`<context:property-placeholder/>`
    命名空间会为您创建一个 `PropertySourcesPlaceholderConfigurer`。
- en: Loading the bean definition is a one-time process at the time of loading the
    configuration file, but the initializing phase for bean instances is executed
    for each bean in the container. Let's have a look at the initialization of bean
    instances in the application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载配置文件时，加载Bean定义是一个一次性过程，但Bean实例的初始化阶段会在容器中的每个Bean上执行。让我们看看应用中Bean实例的初始化过程。
- en: Initializing bean instances
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化Bean实例
- en: 'After loading the bean definitions into the `BeanFactory`, the Spring IoC container
    instantiates the beans for the application; the following diagram shows the process
    flow:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Bean定义加载到`BeanFactory`之后，Spring IoC容器为应用实例化Bean；以下图显示了流程：
- en: '![](img/88a156a9-9afc-4c41-8377-8f645f4257eb.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88a156a9-9afc-4c41-8377-8f645f4257eb.png)'
- en: 'As you can see in the preceding diagram, the bean initialization step is executed
    for each bean in the container. We can summarize the bean creation process as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，容器中的每个Bean都会执行Bean初始化步骤。我们可以将Bean创建过程总结如下：
- en: Each bean is eagerly instantiated by default. It is created in the right order
    with its dependencies injected unless marked as lazy.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，每个Bean都会被急切地实例化。除非标记为懒加载，否则它会按照正确的顺序创建，并注入其依赖项。
- en: Spring provides multiple `BeanPostProcessor`, so, each bean goes through a post-processing
    phase such as `BeanFactoryPostProcessor`, which can modify the bean definition.
    However, the `BeanPostProcessor` can change the instance of the bean.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring提供了多个`BeanPostProcessor`，因此，每个Bean都会经历一个后处理阶段，例如`BeanFactoryPostProcessor`，它可以修改Bean定义。然而，`BeanPostProcessor`可以改变Bean的实例。
- en: After execution of this phase, the bean is fully initialized and ready for use.
    It is tracked by its `id` till the context is destroyed, except for the prototype
    beans.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个阶段执行完成后，Bean就完全初始化并准备好使用。它通过其`id`被跟踪，直到上下文被销毁，除了原型Bean。
- en: In the next section, we'll discuss how to customize the Spring container by
    using a `BeanPostProcessor`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何通过使用`BeanPostProcessor`来自定义Spring容器的行为。
- en: Customizing beans using a BeanPostProcessor
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BeanPostProcessor自定义Bean
- en: 'The `BeanPostProcessor` is an important extension point in Spring. It can modify
    bean instances in any way. It is used to enable a powerful feature such as the
    AOP proxy. You can write your own `BeanPostProcessor` in your application to create
    a custom `post-processor`--the class must implement the `BeanPostProcessor` interface.
    Spring provides several implementations of `BeanPostProcessor`. In Spring, the
    `BeanPostProcessor` interface has two callback methods, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeanPostProcessor`是Spring中的一个重要扩展点。它可以以任何方式修改Bean实例。它用于启用如AOP代理等强大功能。你可以在你的应用中编写自己的`BeanPostProcessor`来创建自定义的`post-processor`--该类必须实现`BeanPostProcessor`接口。Spring提供了`BeanPostProcessor`的几个实现。在Spring中，`BeanPostProcessor`接口有两个回调方法，如下：'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can implement these two methods of the `BeanPostProcessor` interface to
    provide your own custom logic for bean instantiation, dependency-resolution, and
    so on. You can configure multiple `BeanPostProcessor` implementations to add custom
    logic to the Spring container. You can also manage the order of execution of these
    `BeanPostProcessor` by setting the order property. `BeanPostProcessor` work on
    Spring bean instances after instantiation of the bean by the Spring container.
    The scope of the `BeanPostProcessor` is within the Spring container, which means
    that beans that are defined in one container are not post-processed by a `BeanPostProcessor`
    defined in another container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过实现`BeanPostProcessor`接口的这两种方法来提供自己的自定义逻辑，用于Bean实例化、依赖解析等。你可以配置多个`BeanPostProcessor`实现来向Spring容器添加自定义逻辑。你还可以通过设置order属性来管理这些`BeanPostProcessor`的执行顺序。`BeanPostProcessor`在Spring容器实例化Bean之后工作。`BeanPostProcessor`的作用域在Spring容器内，这意味着在一个容器中定义的Bean不会被另一个容器中定义的`BeanPostProcessor`后处理。
- en: Any class in a Spring application is registered as a `post-processor` with the
    container; it is created for each bean instance by the Spring container. And the
    Spring container calls the `postProcessBeforeInitialization()` method before the
    container initialization methods (Initializing Bean's `afterPropertiesSet()` and
    the bean's `init` method). It also calls the `postProcessAfterInitialization()`
    method after any bean initialization callbacks. The Spring AOP uses the `post-processor`
    to provide proxy-wrapping logic (Proxy design pattern) although we can take any
    action by using the `post-processor`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序中的任何类都被注册为容器的`后处理器`；它由Spring容器为每个bean实例创建。Spring容器在容器初始化方法（初始化Bean的`afterPropertiesSet()`和bean的`init`方法）之前调用`postProcessBeforeInitialization()`方法。它还在任何bean初始化回调之后调用`postProcessAfterInitialization()`方法。Spring
    AOP使用`后处理器`提供代理包装逻辑（代理设计模式），尽管我们可以通过使用`后处理器`执行任何操作。
- en: Spring's `ApplicationContext` automatically detects those beans which implement
    the `BeanPostProcessor` interface, and registers these beans as `post-processors`.
    These beans are called at the time of any other bean creation. Let's explore the
    following example of `BeanPostProcessor`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的`ApplicationContext`自动检测实现`BeanPostProcessor`接口的bean，并将这些bean注册为`后处理器`。这些bean在创建任何其他bean时被调用。让我们探索以下`BeanPostProcessor`的示例。
- en: 'Let''s create a custom bean `post-processor` as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式创建一个自定义的`后处理器`：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This example illustrates basic usage, here this example shows a `post-processor`
    prints the string to the system console for each bean registered with the container.
    This `MyBeanPostProcessor` class annotated with `@Component` that means this class
    same as other bean class in the application context, now run the following demo
    class. Please refer to the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了基本用法，这里此示例显示一个`后处理器`将字符串打印到系统控制台，对于容器中注册的每个bean。此`MyBeanPostProcessor`类使用`@Component`注解，这意味着此类与应用程序上下文中的其他bean类相同，现在运行以下演示类。请参考以下代码：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the output that we''ll get on the console:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在控制台上获得的输出：
- en: '![](img/b3eaae71-6091-4bcc-ab41-40d10793f1e8.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3eaae71-6091-4bcc-ab41-40d10793f1e8.png)'
- en: 'As you can see in the preceding output, a string of both the callback methods
    is printed for each bean method in the Spring container. Spring provides many
    pre-implemented `BeanPostProcessor` for some specific features, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，Spring容器中每个bean的方法都会打印出回调方法的字符串。Spring为一些特定功能提供了许多预实现的`BeanPostProcessor`，如下所示：
- en: '`RequiredAnnotationBeanPostProcessor`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequiredAnnotationBeanPostProcessor`'
- en: '`AutowiredAnnotationBeanPostProcessor`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutowiredAnnotationBeanPostProcessor`'
- en: '`CommonAnnotationBeanPostProcessor`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommonAnnotationBeanPostProcessor`'
- en: '`PersistenceAnnotationBeanPostProcessor`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistenceAnnotationBeanPostProcessor`'
- en: The namespace `<context:annotation-config/>` in the XML configuration enables
    several `post-processor` in the same application context in which it is defined.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: XML配置中的`<context:annotation-config/>`命名空间启用了在同一应用程序上下文中定义的多个`后处理器`。
- en: Let us now move on to our next section, and see how we can enable the Initializer
    extension point by using `BeanPostProcessor`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一节，看看我们如何通过使用`BeanPostProcessor`来启用初始化器扩展点。
- en: The Initializer extension point
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化器扩展点
- en: This special case of a bean `post-processor` causes `init` (`@PostConstruct`)
    methods to be called. Internally, Spring uses several **BeanPostProcessors** (**BPPs**)
    `CommonAnnotationBeanPostProcessor` to enable initialization. The following diagram
    illustrates the relationship between initializer and BPPs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的“后处理器”情况会导致调用`init`（`@PostConstruct`）方法。内部，Spring使用多个**BeanPostProcessors**（**BPPs**）`CommonAnnotationBeanPostProcessor`来启用初始化。以下图表展示了初始化器和BPPs之间的关系。
- en: '![](img/187db208-db73-4cb0-a955-49a0ec79b4da.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/187db208-db73-4cb0-a955-49a0ec79b4da.png)'
- en: 'Now let''s see the following example for the Initializer extension point in
    XML:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下XML中初始化器扩展点的示例：
- en: 'Namespace `<context:annotation-config/>` explicitly enables many `post-processor`,
    let see the following configuration file in XML:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`<context:annotation-config/>`命名空间明确启用了许多`后处理器`，让我们看看以下XML配置文件：'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding configuration code, you can see that I have defined some beans
    out of which one of the bean `accountRepository` repository has the `init` method
    attribute of the bean tag; this attribute has a value, `populateCache`. This is
    nothing but an `initializer` method of the `accountRepository` bean. It is called
    by the container at the time of bean initialization if the `post-processor` is
    explicitly enabled by the `<context:annotation-config/>` namespace. Let''s see
    the `JdbcAccountRepository` class, shown as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置代码中，你可以看到我定义了一些豆类，其中之一是`accountRepository`仓库，它具有`init`方法属性；这个属性有一个值，`populateCache`。这实际上就是`accountRepository`豆的`initializer`方法。如果通过`<context:annotation-config/>`命名空间显式启用了`post-processor`，容器会在豆初始化时调用这个方法。让我们看看下面的`JdbcAccountRepository`类，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the Java configuration, we can use `initMethod` attribute of the `@Bean`
    annotation as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java配置中，我们可以使用`@Bean`注解的`initMethod`属性如下：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the Annotation-based configuration, we can use the *JSR-250* annotation,
    `@PostConstruct` as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于注解的配置中，我们可以使用*JSR-250*注解`@PostConstruct`如下：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have seen the first phase of a bean life cycle, where Spring loads the bean
    definitions by using XML-, Java-, and Annotation-based configuration, and after
    that, the Spring container initializes each bean in the correct order in the Spring
    application. The next diagram gives an overview of the first phase of the configuration
    life cycle:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了豆生命周期中的第一个阶段，Spring通过使用XML、Java和注解配置来加载豆定义，然后，Spring容器以正确的顺序在Spring应用程序中初始化每个豆。下面的图给出了配置生命周期第一个阶段的概述：
- en: '![](img/2a7e9ec4-ad6c-40c7-acad-1c76bec040ff.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a7e9ec4-ad6c-40c7-acad-1c76bec040ff.png)'
- en: The last diagram shows Spring bean metadata in any style-XML, Annotation, or
    Java-loaded by the respective implementation of `ApplicationContext`. All XML
    files are parsed, and loaded with the bean definitions. In Annotation configuration,
    Spring scans all the components, and loads the bean definitions. In the Java configuration,
    Spring reads all the `@Bean` methods to load the bean definitions. After loading
    the bean definitions from all styles of configurations, `BeanFactoryPostProcessor`
    comes into the picture to modify the definition of some beans, and then the container
    instantiates the beans. Finally, `BeanPostProcessor` works on the beans, and it
    can modify and change the bean object. This is the initialization phase. Now let's
    see the next Use phase of a bean in its life cycle.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个图显示了由`ApplicationContext`的相应实现加载的任何风格的Spring豆元数据——XML、注解或Java。所有XML文件都被解析并加载了豆定义。在注解配置中，Spring扫描所有组件，并加载豆定义。在Java配置中，Spring读取所有的`@Bean`方法来加载豆定义。从所有配置风格加载豆定义之后，`BeanFactoryPostProcessor`出现来修改一些豆的定义，然后容器实例化豆。最后，`BeanPostProcessor`在豆上工作，它可以修改和改变豆对象。这是初始化阶段。现在让我们看看豆在其生命周期中的下一个使用阶段。
- en: The Use phase of beans
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 豆的使用阶段
- en: 'In a Spring application, all Spring beans spend 99.99% of their time in this
    phase. If the initialization phase is completed successfully, then the Spring
    beans come into this phase. Here, beans are used by clients as application services.
    These beans process client requests, and carry out application behaviors. In the
    Use phase, let''s see how to invoke a bean obtained from the context **in the
    application where it is used**. Please refer to the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring应用程序中，所有Spring豆有99.99%的时间都处于这个阶段。如果初始化阶段成功完成，那么Spring豆就会进入这个阶段。在这里，豆被客户端作为应用服务使用。这些豆处理客户端请求，并执行应用行为。在使用阶段，让我们看看如何在应用中使用时调用从上下文中获得的豆。请参考以下代码：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Suppose the `return` service returns a raw object, then it is simply invoked
    directly; nothing special here. But if your bean has been wrapped in a proxy,
    then things become more interesting. Let''s explore the following diagram to understand
    this more clearly:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`return`服务返回一个原始对象，那么它可以直接调用；这里没有特别之处。但如果你的豆被包装在代理中，那么事情就更有趣了。让我们通过以下图来更清楚地理解这一点：
- en: '![](img/15ae37a0-4d43-4ca2-8e19-da8ca4ad7976.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15ae37a0-4d43-4ca2-8e19-da8ca4ad7976.png)'
- en: In the preceding diagram, you can see the `service` method call through the
    `Proxy` class; it is created in the `init` phase by dedicated `BeanPostProcessor`.
    It wraps your beans in a dynamic proxy, which adds behavior to your bean transparently.
    It is an implementation of the Decorator Design pattern and Proxy Design pattern.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到通过`Proxy`类调用的`service`方法；它是在`init`阶段由专门的`BeanPostProcessor`创建的。它将你的Bean包装在动态代理中，从而为你的Bean添加行为，这是透明的。它是装饰器设计模式和代理设计模式的一个实现。
- en: Let's see how Spring creates a proxy for your bean in the Spring application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Spring如何在Spring应用程序中为你的Bean创建代理。
- en: Implementing the Decorator and Proxy patterns in Spring using Proxies
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理在Spring中实现装饰器和代理模式
- en: 'Spring uses two types of proxy in a Spring application. The following are the
    kind of proxies used by Spring:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Spring在Spring应用程序中使用两种类型的代理。以下是由Spring使用的代理类型：
- en: '**JDK Proxy**: This is also known as a dynamic proxy. Its API is built into
    the JDK. For this proxy, the `Java` interface is required.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDK代理**：这也被称为动态代理。它的API内置在JDK中。对于这个代理，需要`Java`接口。'
- en: '**CGLib Proxy**: This is *NOT* built into JDK. However, it is included in Spring
    JARS, and is used when the interface is not available. It cannot be applied to
    final classes or methods.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CGLib代理**：这并不是JDK内置的。然而，它包含在Spring JARS中，并在接口不可用时使用。它不能应用于final类或方法。'
- en: 'Let''s see the features of both the proxies in the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图中两个代理的特性：
- en: '![](img/ff68c3d1-47fb-49d9-bd87-440a6ed7a481.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff68c3d1-47fb-49d9-bd87-440a6ed7a481.png)'
- en: This is all about the Use Phase of the Spring Bean life cycle. Now let's move
    to the next phase of life cycle, that is, the destruction phase.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于Spring Bean生命周期中的使用阶段的所有内容。现在让我们转到生命周期的下一个阶段，即销毁阶段。
- en: The destruction phase of the beans
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean的销毁阶段
- en: 'In this phase, Spring releases any system resource acquired by the application
    services. These are eligible for garbage collection. When you close an application
    context, the destruction phase completes. Let''s see the following lines of code
    in this phase:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，Spring会释放应用程序服务获取的任何系统资源。这些资源有资格进行垃圾回收。当你关闭应用程序上下文时，销毁阶段完成。让我们看看这个阶段的以下代码行：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, what do you think happens when we call the `applicationContext.close()`
    method in this phase? The process that takes place is given as follows :'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当你在这个阶段调用`applicationContext.close()`方法时，你认为会发生什么？发生的进程如下所示：
- en: 'Any bean implementing the `org.springframework.beans.factory.DisposableBean`
    interface gets a callback from the container when it is destroyed. The `DisposableBean`
    interface specifies a single method:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何实现`org.springframework.beans.factory.DisposableBean`接口的Bean在销毁时都会从容器中收到一个回调。`DisposableBean`接口指定了一个单一的方法：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `bean` instances are destroyed if instructed to call their `destroy` methods.
    Beans must have a `destroy` method defined, that is, a `no-arg` method returning
    `void`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指示调用它们的`destroy`方法，`bean`实例将被销毁。Bean必须定义一个`destroy`方法，即一个无参数返回`void`的方法。
- en: The context then destroys itself, and this context is not usable again.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，上下文会自我销毁，并且这个上下文将不再可用。
- en: Only GC actually destroys objects and remember, it is called only when the `ApplicationContext`/JVM
    exit normally. It is not called for prototype beans.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有GC（垃圾回收器）实际上销毁对象，并且记住，它仅在`ApplicationContext`/JVM正常退出时被调用。它不会为原型Bean调用。
- en: 'Let''s see how to implement it with the XML Configuration:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用XML配置来实现它：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the configuration, the `accountRepository` bean has a `destroy` method named
    `clearCache`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置中，`accountRepository`Bean有一个名为`clearCache`的`destroy`方法：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s see the same configuration with Java. In the Java configuration, we
    can use the `destroyMethod` attribute of the `@Bean` annotation as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Java看看同样的配置。在Java配置中，我们可以使用`@Bean`注解的`destroyMethod`属性，如下所示：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can do the same using Annotations. Annotations require `annotation-config`
    or the component scanner to be activated by using `<context:component-scan ...
    />``, as seen in the following`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用注解做同样的事情。注解需要通过使用`<context:component-scan ... />`激活`annotation-config`或组件扫描器，如下所示：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You have now seen the Spring bean life cycle in all its phases. In the initialization
    phase, Bean Post Processors for initialization and proxies. In the Use phase,
    Spring beans use the magic of proxy. Finally, in the destruction phase, it allows
    the application to terminate cleanly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了Spring bean生命周期的所有阶段。在初始化阶段，有初始化和代理的Bean后处理器。在使用阶段，Spring beans使用了代理的魔法。最后，在销毁阶段，它允许应用程序干净地终止。
- en: Now that you have seen the bean life cycle, let's learn about bean scopes, and
    how to create custom bean scopes in the Spring container.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了bean的生命周期，让我们来学习bean的作用域，以及如何在Spring容器中创建自定义bean作用域。
- en: Understanding bean scopes
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解bean作用域
- en: In Spring, each bean has one scope in the container. You can control not only
    the bean metadata and its life, but also the scope of that bean. You can create
    a custom scope of the bean, and register it with the container. You can decide
    the scope of the bean by configuring it with the bean definition with the XML-,
    Annotations-, or Java-based configuration.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，每个bean在容器中都有一个作用域。你可以控制不仅bean元数据和其生命周期，还可以控制该bean的作用域。你可以创建一个自定义的bean作用域，并将其注册到容器中。你可以通过配置基于XML、注解或Java的bean定义来决定bean的作用域。
- en: The Spring application context *creates* all beans *by using* a singleton scope.
    That means, it is always the same bean each time; it doesn't matter how many times
    it is injected into another bean or called by other services. Because of this
    singleton behavior, the scope reduces the cost of instantiating. It is suitable
    for stateless objects in the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Spring应用程序上下文通过使用单例作用域来创建所有bean。这意味着每次都是同一个bean；无论它被注入到另一个bean中多少次或被其他服务调用多少次，都不会改变。正因为这种单例行为，作用域减少了实例化的成本。它适用于应用中的无状态对象。
- en: In a Spring application, sometimes it is required to save the state of some
    objects that aren't safe for reuse. For such a requirement, declaring the bean
    scope as a singleton is not safe, because it may cause unexpected problems when
    reused later. Spring provides another scope for such a requirement, which is known
    as the prototype scope of the Spring bean.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring应用程序中，有时需要保存某些对象的状态，这些对象不适合重用。对于这种需求，将bean作用域声明为单例是不安全的，因为它可能在稍后重用时引起意外问题。Spring为这种需求提供了另一个作用域，这被称为Spring
    bean的原型作用域。
- en: 'Spring defines several scopes under which a bean can be created, and these
    are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Spring定义了多个作用域，bean可以在这些作用域下创建，如下所示：
- en: The singleton bean scope
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例bean作用域
- en: 'In Spring, any bean that has a singleton scope has only one instance of the
    bean created for an application context, where it is defined for the entire application.
    This is the default behavior of the Spring container. But it is different from
    the singleton pattern as defined in the **Gang of Four** (**GoF**) patterns book.
    In Java, singleton means per object of a particular class per Classloader in the
    JVM. But in Spring, it implies per instance of a bean per bean definition per
    Spring IoC container. This is explained in the following diagram:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，任何具有单例作用域的bean，在应用程序上下文中只创建一个bean实例，它在整个应用程序中定义。这是Spring容器的默认行为。但它与**Gang
    of Four**（**GoF**）模式书籍中定义的单例模式不同。在Java中，单例意味着在JVM中每个特定类的每个对象。但在Spring中，它意味着每个Spring
    IoC容器中每个bean定义的每个bean实例。这将在以下图中解释：
- en: '![](img/4c743f7e-3f0c-4c38-890c-7bd06953c578.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c743f7e-3f0c-4c38-890c-7bd06953c578.png)'
- en: As you can see in the preceding diagram, the same instance of the object is
    defined by the bean definition, `accountRepository`, injected to other collaborating
    beans in the same IoC container. Spring stores all singleton bean instances in
    a cache, and all collaborating beans fetch the dependency of that object returned
    by the cache.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前图所示，相同的对象实例由bean定义`accountRepository`注入到同一IoC容器中的其他协作bean。Spring将所有单例bean实例存储在缓存中，所有协作bean都会从缓存中获取该对象依赖项。
- en: The prototype bean scope
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型bean作用域
- en: 'In Spring, any bean defined with the prototype scope has one instance of the
    bean created for every time the bean is injected into other collaborating beans.
    The following figure illustrates the Spring prototype scope:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在春季，任何定义为原型范围的bean，每次被注入到其他协作bean时，都会为其创建一个bean实例。以下图示说明了Spring的原型范围：
- en: '![](img/57c51044-2bd1-4043-97c9-ae928ac05bc7.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57c51044-2bd1-4043-97c9-ae928ac05bc7.png)'
- en: As you can see in the preceding diagram, an `accountRepository` class is configured
    as a prototype bean, and the container creates a brand new instance for each time
    that bean is injected into other beans.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`accountRepository`类被配置为一个原型bean，每次该bean被注入到其他bean时，容器都会为其创建一个新的实例。
- en: The session bean scope
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话bean范围
- en: A new instance is created once for every user session in the web environment
    only.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web环境中，为每个用户会话只创建一个新实例。
- en: 'Consider the following XML configuration for a bean definition:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下XML配置的bean定义：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The request bean scope
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求bean范围
- en: A new instance is created once for every request in the web environment only.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web环境中，为每个请求只创建一个新实例。
- en: 'Consider the following XML configuration for a bean definition:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下XML配置的bean定义：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Other scopes in Spring
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的其他范围
- en: 'Spring has other more specialized scopes, which are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Spring还有其他更专业的范围，如下所示：
- en: WebSocket scope
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket范围
- en: Refresh scope
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新范围
- en: Thread scope (defined, but not registered by default)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程范围（已定义，但默认未注册）
- en: Spring also supports the creation of your own custom scope for a bean. We'll
    discuss this in the following section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Spring还支持为bean创建自己的自定义范围。我们将在下一节中讨论这个问题。
- en: Custom scopes
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义范围
- en: We can create a custom scope of any bean, and register this scope with the application
    context. Let's see how to create a custom bean scope with the following example.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为任何bean创建一个自定义范围，并将此范围注册到应用程序上下文中。让我们通过以下示例看看如何创建一个自定义bean范围。
- en: Creating custom scopes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义范围
- en: 'For creating your customer scope in the Spring IoC container, Spring provides
    the `org.springframework.beans.factory.config.Scope` interface. You have to implement
    this interface to create your own custom scopes. Take a look at the following
    `MyThreadScope` class as a custom scope in the Spring IoC container:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring IoC容器中创建您的客户范围时，Spring提供了`org.springframework.beans.factory.config.Scope`接口。您必须实现此接口以创建自己的自定义范围。请看以下`MyThreadScope`类，作为Spring
    IoC容器中的自定义范围：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we have overridden multiple methods of the `Scope` interface
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经按照如下方式覆盖了`Scope`接口的多个方法：
- en: '**Object get(String name, ObjectFactory objectFactory)**: This method returns
    the object from the underlying scope'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Object get(String name, ObjectFactory objectFactory)**: 此方法从底层范围返回对象'
- en: '**Object remove(String name)**: This method removes the object from the underlying
    scope'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Object remove(String name)**: 此方法从底层范围中移除对象'
- en: '**void registerDestructionCallback(String name, Runnable destructionCallback)**:
    This method registers the destruction callbacks, and is executed when the specified
    object with this custom scope is destroyed'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**void registerDestructionCallback(String name, Runnable destructionCallback)**:
    此方法注册销毁回调，并在具有此自定义范围的指定对象销毁时执行'
- en: Now let's see how to register this custom scope with the Spring IoC container,
    and how to use it in the Spring application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何将这个自定义范围注册到Spring IoC容器中，以及如何在Spring应用程序中使用它。
- en: 'You can register this custom bean scope with the Spring IoC container declaratively
    by using the `CustomScopeConfigurer` class as follows :'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`CustomScopeConfigurer`类声明性地将此自定义bean范围注册到Spring IoC容器中，如下所示：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see in the preceding configuration file, I have registered my custom
    bean scope named `myThreadScope` with the application context by using the `CustomScopeConfigurer`
    class. This custom scope that I am using is similar to the singleton or prototype
    scope through the scope attribute of the bean tag in the XML configuration.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如前配置文件所示，我已使用`CustomScopeConfigurer`类将名为`myThreadScope`的自定义bean范围注册到应用程序上下文中。我正在使用的这个自定义范围与XML配置中bean标签的scope属性类似，类似于单例或原型范围。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, you should now have a good idea about the Spring
    bean life cycle in the container, and the several types of bean scope in a container.
    You now know that there are three phases of the Spring bean life cycle in the
    container. The first is the initialization phase. In this phase, Spring loads
    the bean definitions from XML, Java, or Annotation configurations. After loading
    these beans, the container constructs each bean, and applies the post-process
    logic on that bean.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，您现在应该对容器中Spring bean的生命周期以及容器中的几种bean范围有一个很好的了解。您现在知道在容器中Spring bean的生命周期有三个阶段。第一个是初始化阶段。在这个阶段，Spring从XML、Java或注解配置中加载bean定义。加载这些bean后，容器构建每个bean，并对此bean应用后处理逻辑。
- en: The next is the Use phase, in which the Spring beans are ready to be used, and
    Spring shows the magic of the proxy pattern.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是使用阶段，在这个阶段中，Spring的bean已经准备好被使用，Spring展示了代理模式的魔法。
- en: Finally, the last phase is the destruction phase. In this phase, when the application
    calls the `close()` method of Spring's `ApplicationContext`, the container calls
    the clean-up method of each bean to release resources.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个阶段是销毁阶段。在这个阶段，当应用程序调用Spring的`ApplicationContext`的`close()`方法时，容器会调用每个bean的清理方法来释放资源。
- en: In Spring, you can control not only the bean life cycle but also the scope of
    the bean in the container. The default scope of a bean in the Spring IoC container
    is the Singleton, but you can override the default scope by defining other scope
    prototypes with the bean using the scope attribute of the bean tag in XML or the
    `@Scope` annotation in Java. You can also create your own custom scope, and register
    it with the container.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，你可以控制不仅bean的生命周期，还可以在容器中控制bean的作用域。Spring IoC容器中bean的默认作用域是单例（Singleton），但你可以通过在XML中定义bean标签的scope属性或在Java中使用`@Scope`注解来覆盖默认作用域，以定义其他作用域原型。你还可以创建自己的自定义作用域，并将其注册到容器中。
- en: Now we'll turn to the magic chapter of this book, that is, Spring **Aspect-Oriented
    Programming** (**AOP**). Much as dependency injection helps decouple components
    from the other components they collaborate with, AOP helps decouple your application
    components from tasks that span multiple components in an application. Let's move
    on to the next chapter, covering Spring Aspect Oriented Programming with Proxy
    and Decorator Design Pattern.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转向这本书的魔法章节，即Spring **面向切面编程**（**AOP**）。正如依赖注入有助于将组件与其协作的其他组件解耦一样，AOP有助于将你的应用程序组件与应用程序中跨越多个组件的任务解耦。让我们继续到下一章，介绍使用代理和装饰器设计模式的Spring面向切面编程。
