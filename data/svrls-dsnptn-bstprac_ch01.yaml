- en: Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: It's an exciting time to be in the software industry. Over the past few years,
    we've seen an evolution in architectural patterns, with a considerable movement
    away from large, monolithic applications toward microservices. As cloud computing
    has evolved, so too have the systems and services we software developers have
    at our disposal. One of the most revolutionary tools in this domain is lambda
    functions, or more accurately, Functions as a Service. A step beyond microservices,
    being able to run, manage, and deploy a single function as a different entity
    has pushed us into the realm of nanoservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件行业，这是一个激动人心的时刻。在过去的几年里，我们看到了架构模式的演变，从大型单体应用向微服务的重大转变。随着云计算的发展，我们软件开发者可用的系统和服务的数量也在增加。在这个领域最具革命性的工具之一是lambda函数，或者更准确地说，是“函数即服务”。它超越了微服务，能够作为一个不同实体运行、管理和部署单个函数，这使我们进入了纳米服务的领域。
- en: Of course, this book focuses on design patterns for serverless computing. The
    best place to start then is: what are design patterns and what is serverless computing?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，本书专注于无服务器计算的设计模式。那么，首先应该从：什么是设计模式，什么是无服务器计算？开始。
- en: If you're just beginning your journey into the world of serverless systems and
    patterns, I encourage you to read other resources to get more details on these
    and related topics. Our upcoming discussion intends to set the stage for building
    systems with patterns, but it's not necessary to explain the foundations of serverless
    platforms or its concepts in excruciating detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始探索无服务器系统和模式的世界，我鼓励你阅读其他资源，以获取更多关于这些和相关主题的详细信息。我们即将进行的讨论旨在为构建具有模式的系统奠定基础，但无需对无服务器平台或其概念进行详尽的解释。
- en: In this chapter, I'll first define a few relevant terms and concepts before
    diving deeper into those topics. Then, I'll discuss when serverless architectures
    are or are not a good fit. Finally, I'll explain the various categories of serverless
    patterns that I'll present in this book. I presume that you, the reader, are somewhat
    familiar with these large topics, but absolute mastery is not required.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将在深入探讨这些主题之前，首先定义一些相关术语和概念。然后，我将讨论无服务器架构何时或何时不适合。最后，我将解释本书中将要介绍的各类无服务器模式。我假设你，作为读者，对这些大型主题有一定的了解，但绝对精通不是必需的。
- en: 'At the end of this chapter, you should be able to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该能够做到以下几件事情：
- en: Describe the term *serverless* in your own words
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用你自己的话描述“无服务器”这个术语
- en: Know how design patterns relate to serverless architectures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解设计模式与无服务器架构的关系
- en: Understand general classifications of serverless design patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解无服务器设计模式的一般分类
- en: What is serverless computing?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是无服务器计算？
- en: 'Let''s start with the simpler of the two questions first—what is serverless
    computing? While there may be several ways to define serverless computing, or
    perhaps more accurately serverless architectures, most people can agree on a few
    key attributes. Serverless computing platforms share the following features:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从这两个问题中较简单的一个开始——什么是无服务器计算？虽然可能存在几种定义无服务器计算或更准确地说无服务器架构的方法，但大多数人可以就几个关键属性达成一致。无服务器计算平台共享以下特性：
- en: No operating systems to configure or manage
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需配置或管理操作系统
- en: Pay-per-invocation billing model
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按调用付费的计费模式
- en: Ability to automatically scale with usage
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够根据使用情况自动扩展
- en: Built-in availability and fault tolerance
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置可用性和容错性
- en: While there are other attributes that come with serverless platforms, they all
    share these common traits. Additionally, there are other serverless systems that
    provide functionality other than general computing power. Examples of these are
    DynamoDB, Kinesis, and Simple Queue Service, all of which fall under the Amazon
    Web Services (AWS) umbrella. Even though these systems are not pay-per-invocation,
    they fall into the serverless category since the management of the underlying
    systems is delegated to the AWS team, scaling is a matter of changing a few settings, fault-tolerance
    is built-in, and high availability is handled automatically.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无服务器平台具有其他一些属性，但它们都具备这些共同特征。此外，还有一些无服务器系统提供除通用计算能力之外的功能。这些系统的例子包括DynamoDB、Kinesis和简单队列服务，它们都属于亚马逊网络服务（AWS）的范畴。尽管这些系统不是按调用付费，但它们属于无服务器类别，因为底层系统的管理委托给了AWS团队，扩展只需更改几个设置，容错性是内置的，高可用性是自动处理的。
- en: No servers to manage
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需管理服务器
- en: Arguably, this is where the term *serverless* came from and is at the heart
    of this entire movement. If we look back not too long ago, we can see a time when
    operations teams had to purchase physical hardware, mount it in a data center,
    and configure it. All of this was required before engineers even had the chance
    of deploying their software.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，这就是“无服务器”这个术语的来源，也是整个运动的中心。如果我们回顾不久前的时光，我们可以看到当时运维团队必须购买物理硬件，将其安装在数据中心，并对其进行配置。所有这些都是在工程师有机会部署他们的软件之前必须完成的。
- en: 'Cloud computing, of course, revolutionized this process and turned it upside
    down, putting individual engineers in the driver''s seat. With a few clicks or
    API calls, we could now get our very own **virtual private server** (**VPS**)
    in minutes rather than weeks or months. While this was and is incredibly enabling,
    most of the work of setting up systems remained. A short list of things to worry
    about includes the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，云计算彻底改变了这个过程，将其颠倒过来，将个人工程师置于驾驶员的位置。通过几点击或API调用，我们现在可以在几分钟内而不是几周或几个月内获得我们自己的**虚拟专用服务器**（**VPS**）。虽然这过去和现在都极大地提高了效率，但设置系统的许多工作仍然存在。以下是一些需要担心的事项的简短列表：
- en: Updating the operating system
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新操作系统
- en: Securing the operating system
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护操作系统
- en: Installing system packages
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装系统包
- en: Dealing with dependency management
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理依赖管理
- en: This list goes on and on. A point worth noting is that there may be hours and
    hours of configuration and management before we're in a position to deploy and
    test our software.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表可以一直继续下去。值得注意的是，在我们可以部署和测试我们的软件之前，可能需要花费数小时进行配置和管理。
- en: To ease the burden of system setup, configuration software such as Puppet, Chef,
    SaltStack, and Ansible arrived on the scene. Again, these were and are incredibly
    enabling. Once you have your recipes in place, configuring a new virtual host
    is, most importantly, repeatable and hopefully less error-prone than doing a manual
    setup. In systems that comprise hundreds or even thousands of virtual servers,
    some automation is a requirement rather than a mere convenience.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻系统设置的压力，像Puppet、Chef、SaltStack和Ansible这样的配置软件应运而生。同样，这些工具在过去和现在都极大地提高了效率。一旦你有了你的食谱，配置一个新的虚拟主机，最重要的是，是可重复的，并且可能比手动设置更少出错。在由数百甚至数千个虚拟服务器组成的系统中，一些自动化是必需的，而不仅仅是便利。
- en: As lovely as these provisioning tools are, they do come with a significant cost
    of ownership and can be incredibly time-consuming to develop and maintain. Often,
    iterating on this infrastructure-as-code tooling requires making changes and then
    executing them. Starting up a new virtual host is orders of magnitude faster than
    setting up a physical server; however, we measure VPS boot time and provisioning
    time in minutes. Additionally, these are software systems in and of themselves
    that a dedicated team needs to learn, test, debug, and maintain. On top of this,
    you need to continually maintain and update provisioning tools and scripts in
    parallel with any changes to your operating systems. If you wanted to change the
    base operating system, it would be possible but not without significant investment
    and updates to your existing code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些配置工具非常可爱，但它们确实伴随着高昂的拥有成本，并且开发和维护它们可能非常耗时。通常，迭代这些基础设施即代码工具需要做出更改然后执行它们。启动一个新的虚拟主机比设置物理服务器快得多；然而，我们测量VPS启动时间和配置时间以分钟为单位。此外，这些本身就是软件系统，需要专门的团队来学习、测试、调试和维护。在此基础上，你还需要在操作系统任何更改的同时持续维护和更新配置工具和脚本。如果你想要更改基础操作系统，这是可能的，但需要大量的投资和对现有代码的更新。
- en: When Lambda was launched by AWS in 2014, a new paradigm for computing and software
    management was born. In contrast to managing your virtual hosts, AWS Lambda provided
    developers the ability to deploy application code in a managed environment without
    needing to manage virtual hosts themselves. Of course, there are servers running
    somewhere that are operated by someone. However, the details of these servers
    are opaque to us as application developers. No longer do we need to worry about
    the operating system and its configuration directly. With AWS Lambda and other
    Functions as a Service (FaaS) platforms, we can now delegate the work of VPS management
    to the teams behind those platforms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当AWS在2014年推出Lambda时，一种新的计算和软件管理范式诞生了。与管理和维护虚拟主机相比，AWS Lambda为开发者提供了在托管环境中部署应用程序代码的能力，而无需自己管理虚拟主机。当然，某处有服务器在运行，由某人运营。然而，这些服务器的细节对我们这些应用程序开发者来说是模糊不清的。我们不再需要直接担心操作系统及其配置。有了AWS
    Lambda和其他函数即服务（FaaS）平台，我们现在可以将VPS管理的任务委托给那些平台背后的团队。
- en: The most significant shift in thinking with FaaS platforms is that the unit
    of measure has shrunk from a virtual machine to a single function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS平台最显著的思想转变是度量单位已从虚拟机缩小到单个函数。
- en: Pay-per-invocation billing model
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按调用付费计费模型
- en: Another significant change with the invention of serverless platforms is the
    pay-per-invocation model. Before this, billing models were typically per minute
    or hour. While this was the backbone of elastic computing, servers needed to stay
    up and running if they were used in any production environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器平台的发明带来的另一个重大变化是按调用付费的模型。在此之前，计费模型通常是按分钟或小时计费。虽然这是弹性计算的基础，但在任何生产环境中使用时，服务器需要保持运行和运行。
- en: Paying for a VPS only while it's running is a great model when developing since
    you can just start it at the beginning of the d``
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发时，只为运行中的VPS付费是一个很好的模型，因为你可以在一天开始时启动它。
- en: ay and terminate it at the end of the day. However, when a system needs to be
    available all the time, the price you pay is nearly the same whether its CPU is
    at 100% usage or 0.0001% usage.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每天开始时启动它，并在结束时停止它。然而，当系统需要始终可用时，无论其CPU使用率是100%还是0.0001%，你付出的价格几乎是一样的。
- en: Serverless platforms, on the other hand, the bill only while the code is being
    executed. They are designed and shine for systems that are stateless and have
    a finite, relatively short duration. As such, billing is typically calculated
    based on a total invocation time. This model works exceptionally well for smaller
    systems that may get only a few calls or invocations per day. On many platforms,
    it's possible to run a production system that is always available completely for
    free. There is no such thing as idle time in the world of serverless.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，无服务器平台只在代码执行时计费。它们被设计和优化用于无状态系统和有限、相对较短的时间段。因此，计费通常基于总调用时间。这种模式对于每天可能只收到几个调用或调用的较小系统来说非常有效。在许多平台上，可以运行一个始终可用的生产系统，而且完全免费。在无服务器世界中，没有空闲时间。
- en: Ability to automatically scale with usage
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动根据使用情况扩展的能力
- en: Gone are the days of needing to overprovision a system with more virtual hosts
    than you typically need. As invocations ramp up, the underlying system automatically
    scales up, providing you with a known number of concurrent invocations. Moving
    this limit higher is merely a matter of making a support request to Amazon, in
    the case of AWS Lambda. Before this, managing horizontal scalability was an exercise
    for the team designing the system. Never has horizontal scalability for computing
    resources been so easy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那些需要为系统配置比通常所需更多的虚拟主机来过度配置系统的日子已经过去了。随着调用数量的增加，底层系统会自动扩展，为你提供已知数量的并发调用。将这个限制提高只是向亚马逊提出支持请求的问题，在AWS
    Lambda的情况下。在此之前，管理横向扩展是系统设计团队的练习。计算资源的横向扩展从未如此简单。
- en: Different cloud providers provide the ability to scale up or down (that is,
    be elastic) based on various parameters and metrics. Talk to DevOps folks or engineers
    who run systems with autoscaling and they will tell you it's not a trivial matter
    and is difficult to get right.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的云服务提供商提供了根据各种参数和指标进行扩展或缩减（即弹性）的能力。与使用自动扩展的系统运行系统的DevOps人员或工程师交谈，他们会告诉你这不是一件小事，而且很难做对。
- en: Built-in availability and fault tolerance
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置可用性和容错性
- en: Servers, real or virtual, can and do fail. Since the hosts that run your code
    are now of little or no concern for you, it's a worry not worth having.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器，无论是真实的还是虚拟的，都可能失败。由于运行你的代码的主机对你来说现在几乎或根本不重要，所以这是一个不值得担忧的问题。
- en: Just as the management of the operating system is handled for you, so too is
    the management of failing servers. You can be guaranteed that when your application
    code should be invoked, it will be.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如操作系统管理是由你处理的，同样，失败服务器的管理也是由你处理的。你可以保证，当你的应用程序代码应该被调用时，它将会被调用。
- en: Design patterns
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: With a good understanding of serverless computing behind us, let's turn our
    attention to design patterns.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对无服务器计算有了良好的理解之后，让我们将注意力转向设计模式。
- en: If you've spent any amount of time working with software, you will have heard
    the term *design pattern* and may very well be familiar with them to some degree.
    Stepping back slightly, let's discuss what a design pattern is.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花过任何时间与软件打交道，你肯定听说过“设计模式”这个术语，并且可能在一定程度上熟悉它们。稍微退一步，让我们讨论一下什么是设计模式。
- en: I will assert that if you ask 10 different developers to define the term *design
    pattern*, you will get 10 different answers. While we all may have our definition,
    and while those definitions may not be wrong, it's relatively simple to agree
    on the general spirit or idea of a software design pattern. Within the context
    of software engineering, design patterns are reusable solutions or code organization
    applied to a frequently occurring problem. For example, the Model-View-Controller
    pattern evolved to solve the problem of GUI applications. The Model-View-Controller
    pattern can be implemented in almost any language for nearly any GUI application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我将断言，如果你问10个不同的开发者定义“设计模式”这个术语，你会得到10个不同的答案。虽然我们可能都有自己的定义，而且这些定义可能并不错误，但相对简单的是，我们可以就软件设计模式的一般精神或理念达成一致。在软件工程背景下，设计模式是应用于频繁出现问题的可重用解决方案或代码组织。例如，模型-视图-控制器模式是为了解决GUI应用程序的问题而演变的。模型-视图-控制器模式几乎可以在任何语言中实现，适用于几乎任何GUI应用程序。
- en: Software design patterns evolved as a solution to help software authors be more
    efficient by applying well-known and proven templates to their application code.
    Likewise, architectural patterns provide the same benefits but at the level of
    the overall system design, rather than at the code level.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计模式是为了帮助软件作者通过应用已知和经过验证的模板到他们的应用程序代码中来提高效率而演变的解决方案。同样，架构模式提供了相同的益处，但是在整体系统设计的层面，而不是在代码层面。
- en: In this book, we won't be focusing on software design, but rather architectural
    design in serverless systems. In that vein, it's worth noting that the context
    of this book is serverless architectures and our patterns will manifest themselves
    as reusable solutions that you can use to organize your functions and other computing
    resources to solve various types of problem on your serverless platform of choice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会关注软件设计，而是关注无服务器系统中的架构设计。在这方面，值得注意的是，本书的背景是无服务器架构，我们的模式将体现为可重用的解决方案，你可以使用这些解决方案来组织你的函数和其他计算资源，以解决你在所选无服务器平台上的各种类型的问题。
- en: Of course, there is an infinite number of ways to organize your application
    code and hundreds of software and architectural patterns you can use. The primary
    focus here is the general organization or grouping of your functions, how they
    interact with one another, the roles and responsibilities of each function, and
    how they operate in isolation but work together to compose a larger and more complex
    system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，组织你的应用程序代码有无限种方式，你可以使用数百种软件和架构模式。这里的主要焦点是你函数的一般组织或分组，它们如何相互交互，每个函数的角色和责任，以及它们在独立操作时如何运作，但又能共同组成一个更大、更复杂的系统。
- en: As serverless systems gain traction and become more and more popular, I would
    expect serverless patterns such as those we will discuss in this book to grow
    in both popularity and number.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着无服务器系统越来越受欢迎，我预计我们将在本书中讨论的无服务器模式在受欢迎程度和数量上都将增长。
- en: When to use serverless
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用无服务器
- en: Many types of computing problem can be solved with a serverless design. Personally
    speaking, I have a hard time not using serverless systems nowadays due to the
    speed, flexibility, and adaptability they provide. The classes of problem that
    are suitable for serverless systems are extensive. Still, there is a sweet spot
    that is good to keep in mind when approaching new problems. Outside of the sweet
    spot, there are problems that are not a good fit.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型的计算问题都可以用无服务器设计来解决。就我个人而言，由于它们提供的速度、灵活性和适应性，我现在很难不使用无服务器系统。适合无服务器系统的计算问题类别非常广泛。然而，在处理新问题时，仍有一个值得注意的“甜蜜点”。在“甜蜜点”之外，有一些问题并不适合。
- en: The sweet spot
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “甜蜜点”
- en: 'Since serverless systems work on the basis of a single function, they are well
    suited to problems that are, or can be broken down into, the following subsystems:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无服务器系统基于单个函数运行，因此它们非常适合以下子系统的问题，或者可以将这些问题分解为以下子系统：
- en: Stateless
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Computationally small and predictable
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算量小且可预测
- en: Serverless functions are ephemeral; that is, they have a known lifetime. Computation
    that is itself stateless is the type of problem where FaaS platforms shine. Application
    state may exist, and functions may store that state using a database or some other
    kind of data store, but the functions themselves retain no state between invocations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数是短暂的；也就是说，它们有一个已知的生命周期。本身是无状态的计算是FaaS平台发光的问题类型。应用程序状态可能存在，函数可以使用数据库或其他类型的数据存储来存储该状态，但函数本身在调用之间不保留任何状态。
- en: In terms of computing resources, serverless functions have an upper bound, both
    in memory and total duration. Your software should have an expected or predictable
    upper limit that is below that of your FaaS provider. At the time of writing,
    AWS Lambda functions have an upper bound of 1,536 MB for memory and 300 seconds
    in duration. Google Compute advertises an upper limit of 540 seconds. Regardless
    of the actual values, systems, where you can reliably play within these bounds,
    are good candidates for moving to serverless architecture.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算资源方面，无服务器函数在内存和总持续时间上都有一个上限。您的软件应该有一个预期或可预测的上限，这个上限应低于您的FaaS提供商的上限。在撰写本文时，AWS
    Lambda函数的内存上限为1,536 MB，持续时间上限为300秒。Google Compute宣称的上限为540秒。无论实际值如何，只要系统能够在这些限制内可靠地运行，那么这些系统就是迁移到无服务器架构的良好候选者。
- en: A good, albeit trivial, an example of this would be a data transformation function—given
    some input data, transform it into a different data structure. It should be clear
    with such a simple example that no state needs to be or is carried between one
    invocation and the next. Of course, data comes in various sizes, but if your system
    is fed data of a predictable size, you should be able to process the data within
    a certain timeframe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的、尽管是微不足道的例子是数据转换函数——给定一些输入数据，将其转换成不同的数据结构。从这样一个简单的例子中可以清楚地看出，在每次调用之间不需要也不携带任何状态。当然，数据的大小各不相同，但如果您的系统接收到的数据大小可预测，您应该能够在一定时间内处理这些数据。
- en: In contrast, long-running processes that share state are not good fits for serverless.
    The reason for this is that functions die at the end of their life, leaving any
    in-memory state to die with them. Imagine a long-running process such as an application
    server handling WebSocket connections.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，共享状态的长运行过程不适合无服务器。原因是函数在其生命周期结束时死亡，任何内存状态也会随之死亡。想象一下像应用程序服务器处理WebSocket连接这样的长运行过程。
- en: 'WebSockets are, by definition, stateful and can be compared to a phone call—a
    client opens up a connection to a server that is kept open as long as the client
    would like. Scenarios such as this are not a good fit for serverless functions
    for the two following reasons:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，WebSocket是有状态的，可以比作电话通话——客户端打开到服务器的连接，只要客户端愿意，这个连接就会保持打开状态。以下两种原因使得这种场景不适合无服务器函数：
- en: State exists (i.e., state of a phone call is connected or disconnected)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在状态（即电话通话的状态是连接还是断开）
- en: The process is long-lived because the connection can remain open for hours or
    days
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该过程持续时间长，因为连接可以保持数小时或数天。
- en: 'Whenever I approach a new problem and begin to consider serverless, I ask myself
    these two questions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我遇到一个新问题并开始考虑无服务器时，我都会问自己这两个问题：
- en: Is there any global state involved that needs to be kept track of within the
    application code?
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序代码中是否涉及任何需要跟踪的全局状态？
- en: Is the computation to be performed beyond the system limits of my serverless
    platform?
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行的计算是否超出了我的无服务器平台系统限制？
- en: The good news is that, very often, the answer to these questions is no and I
    can move forward and build my application using a serverless architecture.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，对于这些问题，答案往往是“不”，我可以继续前进并使用无服务器架构构建我的应用程序。
- en: Classes of serverless pattern
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器模式类别
- en: 'In this book, we''ll discuss four major classes of serverless design pattern:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将讨论四种主要的无服务器设计模式：
- en: Three-tier web application patterns
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三层Web应用程序模式
- en: '**Extract**, **transform**, **load** (**ETL**) patterns'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提取**、**转换**、**加载**（**ETL**）模式'
- en: Big data patterns
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大数据模式
- en: Automation and deployment patterns
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化和部署模式
- en: Three-tier web application patterns
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三层Web应用程序模式
- en: Web applications with the traditional request/response cycle are a sweet spot
    for serverless systems. Because serverless functions are short-lived, they lend
    themselves well to problems that are themselves short-lived and stateless. We
    have seen stateful systems emerge and become popular, such as WebSockets; however,
    much of the web and web applications still run in the traditional stateless request/response
    cycle. In our first set of patterns, we'll build different versions of web application
    APIs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 基于传统请求/响应周期的Web应用程序是服务器无服务系统的理想选择。因为无服务器函数是短暂的，它们非常适合那些本身也是短暂和无状态的問題。我们已经看到有状态系统出现并变得流行，例如WebSockets；然而，大部分的网页和Web应用程序仍然运行在传统的无状态请求/响应周期中。在我们的第一组模式中，我们将构建不同版本的Web应用程序API。
- en: 'While there are three different patterns to cover for web applications, they
    will all share a common basis, which is the three-tier model. Here, the tiers
    are made up of the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然需要涵盖三种不同的Web应用程序模式，但它们都将共享一个共同的基础，即三层模型。在这里，层由以下组成：
- en: Content Delivery Network (CDN) for presentation code/static assets (HTML, JavaScript,
    CSS, and so on)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容分发网络（CDN）用于展示代码/静态资源（HTML、JavaScript、CSS等）
- en: Database for persistence
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于持久化的数据库
- en: Serverless functions for application logic
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于应用程序逻辑的无服务器函数
- en: REST APIs should be a common and familiar tool for most web developers. In [Chapter
    2](svrls-dsnptn-bstprac_ch02.html), *A Three-Tier Web Application Using REST*,
    we'll build out a fully featured REST API with a serverless design. This API will
    have all of the methods you'd expect in a classic REST API—**create**, **read**,
    **update**, **delete** (**CRUD**).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: REST API应该是大多数Web开发人员常见且熟悉的工具。在[第2章](svrls-dsnptn-bstprac_ch02.html)，“使用REST的三层Web应用程序”，我们将构建一个具有完整功能的REST
    API，该API将具有经典REST API中所有预期的功能——**创建**、**读取**、**更新**、**删除**（**CRUD**）。
- en: While REST APIs are common and well understood, they do face some challenges.
    After starting with a serverless REST API, we'll walk through the process of designing
    the changes needed to make that same API work as a single GraphQL endpoint that
    provides the same functionality in [Chapter 3](svrls-dsnptn-bstprac_ch03.html), *A
    Three-Tier Web Application Pattern with GraphQL*[](svrls-dsnptn-bstprac_ch03.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然REST API很常见且易于理解，但它们确实面临一些挑战。在开始使用无服务器REST API之后，我们将介绍设计更改的过程，以使相同的API在[第3章](svrls-dsnptn-bstprac_ch03.html)，“带有GraphQL的三层Web应用程序模式”中作为一个单一的GraphQL端点提供相同的功能。
- en: Finally, in [Chapter 4](svrls-dsnptn-bstprac_ch04.html), *Integrating Legacy
    APIs with the Proxy Pattern*, we'll use a proxy pattern to show how it's possible
    to completely change an API  but use a legacy API backend. This design is especially
    interesting for those who would like to get started migrating an API to a serverless
    platform but have an existing API to maintain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[第4章](svrls-dsnptn-bstprac_ch04.html)，“使用代理模式集成遗留API”，我们将使用代理模式来展示如何完全改变一个API，但使用遗留API后端。这种设计对于那些希望开始将API迁移到无服务器平台但需要维护现有API的人来说特别有趣。
- en: ETL patterns
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ETL模式
- en: 'ETL patterns is another area of computing that lends itself very well to serverless
    platforms. At a high level, ETL jobs comprise the following three steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ETL模式是计算领域另一个非常适合无服务器平台的领域。在较高层面，ETL作业包括以下三个步骤：
- en: Extracting data from one data source
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个数据源提取数据
- en: Transforming that data appropriately
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当地转换数据
- en: Loading the processed data into another data source
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将处理后的数据加载到另一个数据源
- en: Often used in analytics and/or data warehousing, ETL jobs are hard to escape.
    Since this problem is again ephemeral and because users would probably like their
    ETL jobs to execute as quickly as possible, serverless systems are a great platform
    in this problem space. While serverless computation is typically short-lived,
    we will see how ETL processes can be designed to be long-running in order to work
    through large amounts of data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 经常用于分析和/或数据仓库的 ETL 任务难以避免。由于这个问题又是短暂的，而且用户可能希望他们的 ETL 任务尽可能快地执行，因此无服务器系统在这个问题领域是一个很好的平台。虽然无服务器计算通常是短暂的，但我们将看到如何设计
    ETL 流程以使其长时间运行，以便处理大量数据。
- en: In the fan-out pattern, discussed in [Chapter 5](svrls-dsnptn-bstprac_ch05.html), *Scaling
    Out with the Fan-Out Pattern*,[](svrls-dsnptn-bstprac_ch05.html) a single unit
    of work will be broken up into multiple smaller units of work and processed in
    parallel. This pattern may be used as a standalone system or as a subcomponent
    in a more extensive system. We'll build out an application using the fan-out pattern
    in isolation, but later discuss how it can work as a piece in a more extensive
    system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](svrls-dsnptn-bstprac_ch05.html)“使用扇出模式扩展”中讨论的扇出模式中，一个单独的工作单元将被分解成多个更小的单元，并并行处理。这个模式可以用作独立系统或更大系统中的子组件。我们将使用扇出模式构建一个独立的应用程序，但稍后我们将讨论它如何作为一个更大系统中的组成部分工作。
- en: Messaging patterns themselves can be an entire class of design pattern. In our
    context, we will show how to use this as a general pattern to process data asynchronously
    with a known or fixed amount of processing power. [Chapter 6](svrls-dsnptn-bstprac_ch06.html),[](svrls-dsnptn-bstprac_ch06.html)
    *Asynchronous Processing with the Messaging Pattern*, will walk through a full
    example of this pattern and its variants in a serverless context.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 消息模式本身可以是一个完整的模式类别。在我们的上下文中，我们将展示如何使用这个通用模式以已知或固定的处理能力异步处理数据。[第 6 章](svrls-dsnptn-bstprac_ch06.html)“使用消息模式进行异步处理”，将介绍这个模式及其变体在无服务器环境中的完整示例。
- en: Big data patterns
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大数据模式
- en: It may seem confusing that *lambda* can refer to both AWS Lambda functions as
    well as a pattern in and of itself. The lambda pattern was born from the need
    to analyze large amounts of data in real time. Before this, the big data movement,
    where large batch jobs would run to calculate and recalculate things, was in full
    swing. The problem faced by this movement was that these batch jobs, in order
    to get the latest results, would need to spend the majority of their computing
    resources recalculating metrics on data that hadn't changed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让人困惑的是，*lambda* 可以指 AWS Lambda 函数，也可以指一个模式本身。Lambda 模式源于实时分析大量数据的需求。在此之前，大数据运动中，大型批量作业会运行以计算和重新计算事物，正处于全速运转。这个运动面临的问题是，这些批量作业为了得到最新的结果，需要花费大部分计算资源重新计算未发生变化的数据的指标。
- en: The lambda pattern, which we will discuss in [Chapter 7](svrls-dsnptn-bstprac_ch07.html),
    *Data Processing Using the Lambda Pattern*, creates two parallel planes of computation,
    a batch layer, and a speed layer. The naming of these layers should give you an
    idea of what they're responsible for.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 模式，我们将在[第 7 章](svrls-dsnptn-bstprac_ch07.html)“使用 Lambda 模式进行数据处理”中讨论，创建了两个并行的计算平面，一个批处理层和一个速度层。这些层的命名应该能让你了解它们各自负责的内容。
- en: MapReduce is another well-known and tested paradigm that has been popular in
    the software world for some time now. Hadoop, arguably the most famous framework
    for MapReduce, helped to bring this pattern front and center after Google's original
    MapReduce paper in 2004.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: MapReduce 是另一个众所周知且经过测试的范式，在软件世界中已经流行了一段时间。Hadoop，可以说是最著名的 MapReduce 框架，在 2004
    年 Google 原始的 MapReduce 论文发布后，帮助将这个模式推向了前台。
- en: As amazing as Hadoop is as a software system, there are substantial hurdles
    to overcome in running a production Hadoop cluster of your own. Due to this, systems
    such as Amazon's **Elastic MapReduce** (**EMR**) were developed, which provide
    on-demand Hadoop jobs to the developer. Still, authoring Hadoop jobs and managing
    the underlying computing resources can be non-trivial. We'll walk through writing
    your serverless MapReduce system in [Chapter 8](svrls-dsnptn-bstprac_ch08.html),
    *The MapReduce Pattern*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Hadoop作为一个软件系统非常出色，但要运行自己的生产级Hadoop集群仍然存在许多障碍。因此，像Amazon的**弹性MapReduce**（**EMR**）这样的系统被开发出来，为开发者提供按需的Hadoop作业。然而，编写Hadoop作业和管理底层计算资源可能并不简单。我们将在第
    8 章 [MapReduce 模式](svrls-dsnptn-bstprac_ch08.html)中介绍如何编写你的无服务器MapReduce系统。
- en: Automation and deployment patterns
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化和部署模式
- en: Many of us are used to logging onto a machine via `ssh` and grepping through
    log files to look for problems. Our worlds are now turned upside down since there
    are no longer any servers to SSH into. Fortunately, there are methods of handling
    errors and getting the information needed to debug and monitor your programs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人习惯于通过 `ssh` 登录到一台机器，并通过 grep 查找日志文件以查找问题。现在，由于没有服务器可以 SSH 登录，我们的世界已经完全颠倒。幸运的是，有处理错误和获取调试和监控程序所需信息的方法。
- en: In [Chapter 9](svrls-dsnptn-bstprac_ch09.html), *Deployment and CI/CD Patterns*,
    we'll focus on error handling, as well as some of the dos and don'ts of serverless
    systems and what modern-day best practices look like in the serverless world.
    Many development practices change when building on top of a serverless platform
    and there are a lot of gotchas that, if you're unfamiliar with them, may surprise
    you. [Chapter 9](svrls-dsnptn-bstprac_ch09.html), *Deployment and CI/CD Patterns*,
    will walk through some of the biggest issues that may bite you if you're brand
    new to this ecosystem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 9 章 [部署和 CI/CD 模式](svrls-dsnptn-bstprac_ch09.html)，我们将重点关注错误处理，以及无服务器系统的一些“应该做”和“不应该做”的事项，以及无服务器世界中的现代最佳实践。当在无服务器平台上构建时，许多开发实践都会发生变化，而且有很多陷阱，如果你不熟悉它们，可能会让你感到惊讶。[第
    9 章](svrls-dsnptn-bstprac_ch09.html)，*部署和 CI/CD 模式*，将探讨一些如果你是新手可能会遇到的最大问题。
- en: While some tooling and techniques may change, let's not forget a healthy software
    development life cycle consists of well-structured code, **continuous integration**
    (**CI**), **continuous deployment** (**CD**), and unit tests. Coupled with the
    myriad of hosted CI/CD platforms, running tests and deploying code automatically
    is quite painless and even fun. In [Chapter 10](svrls-dsnptn-bstprac_ch10.html), *Deployment
    and CI/CD Patterns* will discuss various options and examples with hosted CI and
    CD platforms. I'm confident that you'll find the velocity at which you can ship
    code using serverless technologies exciting and enabling.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些工具和技术可能会发生变化，但我们不要忘记，一个健康的软件开发生命周期包括结构良好的代码、**持续集成**（**CI**）、**持续部署**（**CD**）和单元测试。结合众多的托管
    CI/CD 平台，运行测试和自动部署代码变得相当轻松，甚至很有趣。[第 10 章](svrls-dsnptn-bstprac_ch10.html)，*部署和
    CI/CD 模式*，将讨论托管 CI 和 CD 平台的各种选项和示例。我相信你会发现使用无服务器技术发布代码的速度既令人兴奋又具有启发性。
- en: Serverless frameworks
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器框架
- en: With the advent of serverless platforms came the creation of multiple frameworks
    to help us manage our serverless applications. Just as Ruby on Rails, Spring,
    Django, Express, and other web frameworks aid in the creation and management of
    web applications, various serverless frameworks have sprung up that make the software
    development lifecycle easier for serverless applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 随着无服务器平台的出现，出现了多个框架来帮助我们管理我们的无服务器应用程序。正如Ruby on Rails、Spring、Django、Express和其他网络框架有助于创建和管理网络应用程序一样，各种无服务器框架也应运而生，使无服务器应用程序的软件开发生命周期变得更加容易。
- en: 'An essential difference between web frameworks and serverless frameworks is
    that serverless frameworks often help with the management of application code
    on a serverless platform. In contrast, much of the help web frameworks provide
    revolves around web logic and tasks such as the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器框架和无服务器框架之间的一个基本区别是，无服务器框架通常有助于在无服务器平台上管理应用程序代码。相比之下，大多数网络框架提供的帮助都围绕着网络逻辑和以下任务：
- en: Producing HTML output via templating engines
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模板引擎生成HTML输出
- en: Managing database records via Object Relational Mappers (ORMs)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对象关系映射器（ORM）管理数据库记录
- en: Validating submitted form data
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证提交的表单数据
- en: Dealing with the details of HTTP requests and responses
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理HTTP请求和响应的细节
- en: Not all applications that run on a serverless platform are HTTP-based. Therefore,
    serverless frameworks do not necessarily have application-specific functionality
    baked in but, instead, they have deployment and management functionality. Some
    frameworks do target web developers and aid in web-centric tasks; however, there
    are several other frameworks that do not and instead focus on managing arbitrary
    application code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有在无服务器平台上运行的应用程序都是基于HTTP的。因此，无服务器框架不一定具有特定于应用程序的功能，而是具有部署和管理功能。一些框架针对Web开发者，并有助于Web中心任务；然而，还有几个其他框架并不针对Web开发者，而是专注于管理任意应用程序代码。
- en: 'A few popular serverless frameworks worth noting are the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的几个流行的无服务器框架如下：
- en: Apex
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apex
- en: Serverless
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器
- en: ClaudiaJS
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ClaudiaJS
- en: Kappa
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kappa
- en: SAM (Serverless Application Model from AWS)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SAM (AWS的无服务器应用程序模型)
- en: Chalice (from AWS)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chalice（来自AWS）
- en: Zappa
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zappa
- en: Throughout this book, I'll be using a serverless framework to manage application
    code and the entire stack of resources that we will deploy during the examples.
    Serverless works with a variety of programming languages and various platforms,
    such as AWS, Azure, Google Compute Cloud, and IBM Open Whisk. We will build all
    of our examples using AWS, but the patterns discussed should apply to other cloud
    providers unless explicitly noted otherwise. Since serverless frameworks such
    as Zappa don't give us any web-specific functionality, we will be responsible
    for some of the lower-level web application details in [Chapter 2](svrls-dsnptn-bstprac_ch02.html), *A
    Three-Tier Web Application Using REST,* and [Chapter 3](svrls-dsnptn-bstprac_ch03.html),
    *A Three-Tier Web Application Pattern with GraphQL*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将使用无服务器框架来管理应用程序代码以及我们在示例中部署的所有资源堆栈。无服务器与各种编程语言和平台一起工作，例如AWS、Azure、Google
    Compute Cloud和IBM Open Whisk。我们将使用AWS构建所有示例，但讨论的模式应该适用于其他云提供商，除非明确指出否则不适用。由于Zappa之类的无服务器框架不提供任何特定的Web功能，我们将在[第2章](svrls-dsnptn-bstprac_ch02.html)，“使用REST的分层Web应用程序”和[第3章](svrls-dsnptn-bstprac_ch03.html)，“使用GraphQL的分层Web应用程序模式”中负责一些较低级别的Web应用程序细节。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this introduction, we covered the main points regarding serverless platforms
    and discussed the attributes that make a system *serverless*. We covered the main
    differences between building software on top of self-managed systems, either physical
    or virtual, compared to building software systems on a serverless platform. Additionally,
    readers should have a clearer perspective of when serverless architectures are
    a good fit and when they are not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本介绍中，我们涵盖了有关无服务器平台的主要观点，并讨论了使一个系统成为无服务器的属性。我们比较了在自管理系统（无论是物理的还是虚拟的）上构建软件与在无服务器平台上构建软件系统之间的主要区别。此外，读者应该对何时无服务器架构是一个好的选择以及何时不是有更清晰的看法。
- en: We also reviewed the main categories of design pattern that I will cover in
    this book and gained a high-level overview of each one. Finally, I covered the
    differences between web and serverless frameworks and gave some examples of the
    latter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还回顾了本书中我将涵盖的主要设计模式类别，并对每个类别进行了高级概述。最后，我讨论了Web和无服务器框架之间的区别，并给出了一些后者的例子。
- en: With the stage set, we can jump into our first pattern with a real-world example.
    By the end of [Chapter 2](svrls-dsnptn-bstprac_ch02.html), *A Three-Tier Web Application
    Using REST*, we will have produced a complete three-tier web application using
    REST API, all with serverless technologies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段设置完毕后，我们可以通过一个现实世界的例子来进入我们的第一个模式。到[第2章](svrls-dsnptn-bstprac_ch02.html)，“使用REST的分层Web应用程序”结束时，我们将使用无服务器技术构建一个完整的分层Web应用程序，使用REST
    API。
