- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Java Object Pooling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java对象池
- en: Our mission to make our Java applications highly performant includes a look
    at Java **object pooling**. This chapter dives into the concept of object pooling
    in Java and how to achieve high performance with them in your Java applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使Java应用程序高度性能化的使命包括对Java **对象池**的考察。本章深入探讨了Java中对象池的概念以及如何在您的Java应用程序中使用它们来实现高性能。
- en: The chapter begins with an explanation of object pooling and how to implement
    an **object pool** in Java. Sample code is provided to help you understand object
    pooling operations specific to the Java programming language. You will also have
    the opportunity to learn about the advantages and disadvantages of object pooling
    in Java. Finally, the chapter shows how you can implement performance testing
    with Java object pools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先解释了对象池及其在Java中的实现方法。提供了示例代码，以帮助您理解Java编程语言中特定的对象池操作。您还将有机会了解Java中对象池的优点和缺点。最后，本章展示了如何使用Java对象池进行性能测试。
- en: 'This chapter covers the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Jumping into the object pool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入对象池
- en: Advantages and disadvantages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: Performance testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: By the end of this chapter, you should have a strong theoretical understanding
    of Java object pooling as well as hands-on implementation experience. This experience
    can help ensure you get high performance out of your Java applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该对Java对象池有坚实的理论理解，以及实际操作经验。这种经验可以帮助确保您从Java应用程序中获得高性能。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    please refer back to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的示例和说明，您需要能够加载、编辑和运行Java代码。如果您尚未设置您的开发环境，请参阅[*第1章*](B21942_01.xhtml#_idTextAnchor014)。
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter04](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter04).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完成代码可以在这里找到：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter04](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter04)。
- en: Jumping into the object pool
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入对象池
- en: Before we jump into the object pool, let’s look at what an object pool is.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入对象池之前，让我们看看什么是对象池。
- en: Object pool
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池
- en: An object pool is a collection (pool) of objects that can be reused.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池是一组可以重复使用的对象。
- en: Using object pools is an optimization approach that can positively impact the
    performance of an application. Instead of recreating objects every time we need
    them, we pool a collection of objects and simply recycle them. To help understand
    object pooling, consider a real-world example of a physical library. The library
    can lend out books (our objects) and return them to the collection (our pool)
    when the person is done with the book. This allows the library to reissue the
    book to the next person that needs it. Consider the alternative. If the library
    destroyed (garbage collection) the book after each use, it would have to create
    a new one each time it is needed. This would not be efficient.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象池是一种优化方法，可以积极影响应用程序的性能。我们不需要每次需要时都重新创建对象，而是将一组对象池化，并简单地回收它们。为了帮助理解对象池，可以考虑一个现实世界的例子，即物理图书馆。图书馆可以借出书籍（我们的对象），当读者用完书后，将它们归还到集合（我们的池）中。这允许图书馆将书籍重新借给下一个需要的人。考虑一下另一种情况。如果图书馆在每次使用后销毁（垃圾收集）书籍，那么每次需要时都必须创建一个新的。这将不会高效。
- en: Database example
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库示例
- en: A common object pooling implementation in Java programming is with database
    connections. The typical approach to database connections is to open a connection
    to the database and then perform the desired operations to update or query the
    database. The **open-query-close** process is used. The problem with this approach
    is that opening and closing databases frequently can impact the overall performance
    of the Java application. This processing overhead is something we should try to
    avoid.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java编程中，一个常见的对象池实现是使用数据库连接。数据库连接的典型方法是与数据库建立连接，然后执行所需的操作来更新或查询数据库。使用**打开-查询-关闭**过程。这种方法的问题在于频繁地打开和关闭数据库可能会影响Java应用程序的整体性能。这种处理开销是我们应该尽量避免的。
- en: The object pooling approach, with our database example, involves maintaining
    a pool of pre-created database requests that are idle. When the app signals a
    request for a database connection, one is used from the pool. The next section
    demonstrates how to create and use these pools in a Java application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象池的方法，以我们的数据库示例为例，涉及维护一个空闲的预创建数据库请求池。当应用程序请求数据库连接时，会从池中取出一个。下一节将演示如何在Java应用程序中创建和使用这些池。
- en: Implementing an object pool in Java
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java中实现对象池
- en: Implementing an object pool, based on the database connection example from the
    previous section, involves a database connection class, an object pool class,
    and a class that contains a `main()` method. Let’s look at each of these individually.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前一小节中的数据库连接示例实现对象池，涉及一个数据库连接类、一个对象池类以及一个包含`main()`方法的类。让我们逐一查看这些类。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This example simulates object pooling and does not connect to an actual database.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例模拟对象池，并不连接到实际的数据库。
- en: 'First, we have our `DBConnect` class. This is the class that we will pool:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有我们的`DBConnect`类。这是我们将会池化的类：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see by the preceding code, there are placeholders for functionality.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，这里有一些功能占位符。
- en: 'Next, we create a `DBConnectObjectPool` class to maintain a collection (pool)
    of `DBConnect` objects:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`DBConnectObjectPool`类来维护一个`DBConnect`对象集合（池）：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As shown in the preceding code, we assume a maximum number of connections. This
    is considered a best practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们假设了一个最大连接数。这被认为是一种最佳实践。
- en: 'Lastly, we have a partial application to demonstrate how to use our object
    pool:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个部分应用示例来展示如何使用我们的对象池：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When our application requests a database connection, one is provided from the
    pool. In the case when a connection is not available from the pool, a new one
    is created. We do check to ensure that we do not exceed the maximum number of
    allowed connections. Lastly, after a `DBConnect` object is used, it is returned
    to the object pool.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序请求数据库连接时，会从池中提供一个。在连接不可从池中获取的情况下，会创建一个新的连接。我们确实检查以确保不超过允许的最大连接数。最后，在`DBConnect`对象使用后，将其返回到对象池。
- en: Advantages and disadvantages of object pooling
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池的优势和劣势
- en: Now that you understand what object pooling is and how to implement it in Java,
    we should consider if this is the right strategy for our application. With most
    application code optimization approaches, there are both advantages and disadvantages.
    This section looks at both.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了对象池是什么以及如何在Java中实现它，我们应该考虑这是否是我们应用程序的正确策略。与大多数应用程序代码优化方法一样，都有其优缺点。本节将探讨这两者。
- en: Advantages
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势
- en: There are several potential advantages of using object pooling. These advantages
    can be grouped into performance, resource management, and scalability categories.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象池有几个潜在的优势。这些优势可以分为性能、资源管理和可扩展性类别。
- en: Performance advantages
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能优势
- en: Implementing object pooling stands to allow us to avoid the overhead from object
    creation. This approach is especially useful in high transaction applications
    and when system response time is important. Through object pooling, we can help
    ensure our Java applications are able to be more performant by avoiding excessive
    object creation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实现对象池可以让我们避免对象创建的开销。这种方法在需要高交易量应用和系统响应时间重要的场景中尤其有用。通过对象池，我们可以帮助确保我们的Java应用程序能够通过避免过多的对象创建来提高性能。
- en: We can also experience consistent performance between app usage. For example,
    using object pooling should result in consistent app performance with both a minimal
    load and a heavy load. This predictable behavior is possible due to the stability
    of our application. That stability is enabled by avoiding frequent object creation
    and a heavy reliance on garbage collection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在应用程序使用过程中体验到一致的性能。例如，使用对象池应该导致在最小负载和重负载下应用程序性能的一致性。这种可预测的行为是由于我们应用程序的稳定性。这种稳定性是通过避免频繁的对象创建和对垃圾回收的过度依赖来实现的。
- en: Resource management advantages
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源管理优势
- en: In the context of object pooling advantages, a resource refers to real time,
    processing load, and memory. Reducing the number of object creation and destruction
    operations is a benefit of the object pooling approach. The example used earlier
    in this chapter was with database connections. That example was used because database
    connection operations are notoriously resource hogs. The object pooling approach
    reduces the time it takes to perform these operations and is less resource intensive.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象池优势的背景下，资源指的是实时、处理负载和内存。减少对象创建和销毁操作的数量是对象池方法的一个好处。本章前面提到的例子是数据库连接。之所以使用这个例子，是因为数据库连接操作是众所周知的资源消耗者。对象池方法减少了执行这些操作所需的时间，并且资源消耗较少。
- en: Another resource management advantage is that it increases our memory management
    schema. When object creation is not controlled, the amount of memory consumed
    is variable and could result in system errors.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个资源管理优势是它增加了我们的内存管理架构。当对象创建不受控制时，消耗的内存量是可变的，可能会导致系统错误。
- en: Scalability advantages
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展性优势
- en: The third category of advantages is the ability for our applications to be more
    scalable. This is especially true when we have applications with a large number
    of simultaneous users. It is also beneficial when dealing with database connections
    where the database is a shared resource. The object pool essentially serves as
    a buffer for those requests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个优势类别是使我们的应用程序更具可扩展性。这在我们有大量同时用户的应用程序中尤其如此。在处理数据库连接时，数据库是共享资源，这也很有益。对象池本质上充当了这些请求的缓冲。
- en: Another reason our applications that use object pooling are more scalable is
    the increased amount of control we have with our resources. In the database connection
    example presented earlier in this chapter, we set the maximum number of objects
    that could be in the pool.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是我们使用对象池的应用程序更具可扩展性，那就是我们对资源的控制能力得到了增强。在本章前面提到的数据库连接示例中，我们设置了池中对象的最大数量。
- en: Disadvantages
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 劣势
- en: Unfortunately, there are more potential disadvantages to using object pooling
    than there are advantages. These disadvantages can be grouped into code complexity
    and resource management categories.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用对象池的潜在劣势比优势多。这些劣势可以分为代码复杂性和资源管理类别。
- en: Code complexity disadvantages
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码复杂性劣势
- en: Like with any non-standard programming approach, object pooling adds complexity
    to our code. We create our object pooling-related classes, which must contain
    algorithms to manage the object pool and interfaces with the main program. Although
    it is not apt to result in bloated code, it can make it difficult to maintain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何非标准编程方法一样，对象池会增加我们的代码复杂性。我们创建了与对象池相关的类，这些类必须包含管理对象池的算法以及与主程序的接口。尽管这不太可能导致代码膨胀，但它可能会使维护变得困难。
- en: Object pooling, when implemented in a Java application, adds another component
    to test each time the system, connected systems, or data changes. This can be
    time and resource intensive.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java应用程序中实现对象池时，每次系统、连接系统或数据发生变化时，都会增加一个测试组件。这可能会消耗时间和资源。
- en: Resource management disadvantages
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源管理劣势
- en: There is always a risk, especially during peak load times, of having enough
    available resources. When we set a maximum size of our object pools, they might
    not be sufficient to handle those peak load times. This can also be referred to
    as **resource starvation** because all objects in our pool have been allocated,
    preventing new requests from being queued. These delays can result in overall
    performance lag and user dissatisfaction.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有风险，尤其是在高峰负载时段，资源可能不足。当我们设置对象池的最大大小时，它们可能不足以处理那些高峰负载时段。这也可以被称为**资源饥饿**，因为我们的池中所有对象都已分配，阻止新的请求入队。这些延迟可能导致整体性能下降和用户不满。
- en: Working with memory allocation and deallocation can be problematic. If we do
    not, for example, manage how objects are returned to the pool, there could be
    data loss. This could compound a situation where there are no objects available
    in the pool. Implementing error checking and exception handling becomes critical.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与内存分配和释放一起工作可能会出现问题。如果我们没有，例如，管理对象返回池的方式，可能会造成数据丢失。这可能会加剧池中无可用对象的情况。实现错误检查和异常处理变得至关重要。
- en: Finally, we need to maintain the balance of an object pool being too large or
    too small. If it is too small, it could result in extensive queue times for pooled
    objects. If the pool is too large, the application might overconsume memory, taking
    away from other areas of the application that could make use of it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要保持对象池过大或过小的平衡。如果它太小，可能会导致池化对象的大量排队时间。如果池子太大，应用程序可能会过度消耗内存，从而影响其他可能利用它的应用程序区域。
- en: After looking at both the advantages and disadvantages, you should be able to
    determine whether object pooling is ideally suited for your application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了优点和缺点之后，你应该能够确定对象池是否最适合你的应用程序。
- en: Performance testing
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: 'When we implement object pooling in our Java applications, we want to do three
    things:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Java应用程序中实现对象池时，我们想要做三件事：
- en: Ensure our program works
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们的程序正常工作
- en: Prove that our implementation resulted in greater performance
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明我们的实现提高了性能
- en: Quantify the optimization
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量化优化
- en: In previous sections, we looked at how to implement object pools in Java. In
    this section, we will look at how to design a performance test, how to implement
    the object pooling performance test, and how to analyze the testing results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了如何在Java中实现对象池。在本节中，我们将探讨如何设计性能测试，如何实施对象池性能测试，以及如何分析测试结果。
- en: Designing a performance test
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计性能测试
- en: 'After we decide to implement a performance test, our first action is to design
    the test. The questions we need to answer here include the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们决定实施性能测试后，我们的第一个行动是设计测试。我们需要回答的问题包括以下内容：
- en: What is our goal?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的目标是什么？
- en: What will we measure?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将测量什么？
- en: How will we measure?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将如何测量？
- en: What conditions will exist for our tests?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的测试将存在什么条件？
- en: With these questions in mind, we can start designing our performance test. We
    should have a clear goal or set of goals for our performance test. We might, for
    example, want to focus on system memory, CPU load, and so on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑这些问题的基础上，我们可以开始设计我们的性能测试。我们应该为我们的性能测试设定一个明确的目标或一系列目标。例如，我们可能希望关注系统内存、CPU负载等。
- en: Once we have a specific goal, we must decide what to measure. In testing, what
    we measure are considered **key performance indicators** (**KPIs**). The performance
    testing of object pools might be memory usage, CPU use, data throughput, and response
    time. These are just some examples.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个具体的目标，我们必须决定要测量什么。在测试中，我们测量的是被认为是**关键性能指标**（**KPIs**）。对象池的性能测试可能包括内存使用、CPU使用、数据吞吐量和响应时间。这些只是其中的一些例子。
- en: Next, we will need to set up our test environment and create test scenarios.
    The test environment closely replicates the production system. You might duplicate
    your system in a development environment, so the live system is not impacted.
    Likewise, the test scenarios should closely resemble the real-world use of your
    system. To the extent possible, we should create as many different scenarios as
    needed to represent what our live system handles.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们的测试环境并创建测试场景。测试环境紧密地复制了生产系统。你可能会在开发环境中复制你的系统，这样就不会影响实时系统。同样，测试场景应该紧密地反映你系统在现实世界中的使用。在尽可能的范围内，我们应该创建尽可能多的不同场景来代表我们的实时系统所处理的内容。
- en: At this point, you are ready to document your test plan and implement it. The
    next section covers how to implement a performance test.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经准备好记录你的测试计划并实施它。下一节将介绍如何实施性能测试。
- en: Implementing a performance test
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施性能测试
- en: Implementing your test plan should not be terribly difficult. Here, you are
    simply putting your plan into action. The test environment is established, and
    you run your test scenarios. As the test is running, you should be collecting
    the data for later analysis. Of critical importance is the ability to reproduce
    your test conditions to support future comparative tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实施你的测试计划不应该非常困难。在这里，你只是在将你的计划付诸实施。测试环境已经建立，你运行你的测试场景。在测试运行时，你应该收集数据以供后续分析。至关重要的是能够重现你的测试条件以支持未来的比较测试。
- en: Let’s look at how a performance test might be written in Java using the database
    connection example from this chapter. We will set the goal of decreasing the time
    our application takes to obtain a database connection from our object pool and
    perform a simple operation on that database. Our test plan will compare the results
    of our test with the same test on a version of our application that does not implement
    an object pool.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用本章中的数据库连接示例在Java中编写性能测试。我们的目标是减少应用程序从对象池获取数据库连接并在此数据库上执行简单操作所需的时间。我们的测试计划将比较我们的测试结果与未实现对象池的应用程序版本上的相同测试结果。
- en: 'Our code starts with the class declaration and class variables:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码从类声明和类变量开始：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will write the first part of the `main()` method. This first snippet
    of code will be how we perform the test with our object pool:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`main()`方法的第一部分。这段代码将是我们使用对象池进行测试的方式：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we will write the code to test without using the object pool:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写代码来测试不使用对象池的情况：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With both sets of performance testing written, we need to add the ability to
    calculate and output the results. We generate the results by simply subtracting
    the `startTime` value from the `endTime` value and converting it to milliseconds.
    We then output the results to the console:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写完两组性能测试后，我们需要添加计算和输出结果的能力。我们通过简单地从`endTime`值中减去`startTime`值并将其转换为毫秒来生成结果。然后我们将结果输出到控制台：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This simple example of an object pool performance test is intended to give you
    a general idea of how to code these tests. Every application is different and
    how you write your performance tests will vary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的对象池性能测试示例旨在给你一个如何编写这些测试的一般概念。每个应用程序都是不同的，你编写性能测试的方式也会有所不同。
- en: Analyzing the results
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析结果
- en: Once our tests have concluded, we can analyze the results. How you analyze the
    results will depend on your goals and KPIs. The analysis task should not be rushed.
    Remember, you collected this data so it could help inform your decision on your
    object pool. The complexity will vary based on the performance test plan.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的测试完成，我们就可以分析结果。你如何分析结果将取决于你的目标和关键绩效指标（KPIs）。分析任务不应仓促完成。记住，你收集这些数据是为了帮助你在对象池上做出决策。复杂性将根据性能测试计划而变化。
- en: 'Given the database connection example, we can simply add it to the bottom of
    our `DBConnectionPerformanceTest` class to compare the two sets of results. Here
    is the first section of that code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以数据库连接为例，我们可以简单地将它添加到`DBConnectionPerformanceTest`类的底部，以比较两组结果。以下是该代码的第一部分：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we simply check to see whether `totalTime_withPooling` is less
    than `totalTime_withoutPooling`. If this is the case, the relevant results are
    displayed on the console.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只是检查`totalTime_withPooling`是否小于`totalTime_withoutPooling`。如果是这种情况，相关结果将在控制台上显示。
- en: 'Next, we will check to see whether `totalTime_withPooling` is greater than
    `totalTime_withoutPooling`. The relevant results are displayed on the console:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查`totalTime_withPooling`是否大于`totalTime_withoutPooling`。相关结果将在控制台上显示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our final code snippet executes when the first two conditions are not met.
    This means that both tests took the same amount of time:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当前两个条件不满足时，我们的最终代码片段将执行。这意味着两次测试花费了相同的时间：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As with all testing, you should document your plan, the test results, your analysis,
    your conclusions, and your actions following the testing. This robust documentation
    approach will help you retain the history of your testing in detail.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有测试一样，你应该记录你的计划、测试结果、分析、结论以及测试后的行动。这种稳健的文档方法将帮助你详细保留测试的历史。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took an in-depth look at Java object pooling. It was suggested
    that object pooling is an important technique for ensuring our Java applications
    perform at a high level. Armed with theoretical knowledge, the chapter explored
    the advantages and disadvantages of object pooling. We focused on areas such as
    memory, CPU use, and code complexity. Finally, we demonstrated how to create a
    performance testing plan, how to implement it, and how to analyze the results.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了Java对象池。建议对象池是确保我们的Java应用程序在高水平上运行的重要技术。在掌握理论知识的基础上，本章探讨了对象池的优点和缺点。我们关注了内存、CPU使用和代码复杂度等方面。最后，我们展示了如何创建性能测试计划，如何实施它，以及如何分析结果。
- en: In the next chapter, we will focus on algorithm efficiencies. Our goal will
    be to ensure our algorithms have low time complexities. The chapter will demonstrate
    inefficient algorithms and how to transform them to support high performance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注算法效率。我们的目标将是确保我们的算法具有低时间复杂度。本章将展示低效算法以及如何将它们转换为支持高性能。
