- en: '*Chapter 4*: Graal Just-In-Time Compiler'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*: Graal即时编译器'
- en: In [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054), *GraalVM Architecture*,
    we went through the GraalVM architecture and the various components that constitute
    it. We went through some details of the GraalVM Polyglot architecture with Truffle
    and touched upon the Graal's **just-in-time** (**JIT**) compiler. We looked at
    how Graal JIT plugs into the Java Virtual Machine by implementing the Java Virtual
    Machine Compiler Interface. In this chapter, we will explore how the Graal JIT
    compiler works by running sample code and visualizing the Graal graphs and optimizations
    that Graal JIT performs, using the Ideal Graph Visualizer tool.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054)“GraalVM架构”中，我们探讨了GraalVM架构及其构成的各种组件。我们详细介绍了带有Truffle的GraalVM多语言架构，并简要提到了Graal的**即时**（**JIT**）编译器。我们探讨了Graal
    JIT如何通过实现Java虚拟机编译器接口插入Java虚拟机。在本章中，我们将通过运行示例代码并使用理想图可视化器工具可视化Graal JIT执行的Graal图和优化来探索Graal
    JIT编译器的工作原理。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up the environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: Understanding the Graal JIT compiler
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Graal JIT编译器
- en: Understanding Graal compiler optimizations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Graal编译器优化
- en: Debugging and monitoring applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和监控应用程序
- en: By the end of the chapter, you will have a very clear understanding of how Graal
    JIT compilation works, understand the various optimization techniques, know how
    to diagnose and debug performance problems using the Ideal Graph Visualizer, and
    be able to fine-tune Graal JIT compiler configurations for optimum performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对Graal JIT编译器的工作原理有一个非常清晰的理解，了解各种优化技术，知道如何使用理想图可视化器诊断和调试性能问题，并且能够微调Graal
    JIT编译器配置以获得最佳性能。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will take some sample code and use tools to analyze it.
    The following are some of the tools/runtimes that are required to follow this
    chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一些示例代码并使用工具进行分析。以下是一些遵循本章所需的工具/运行时：
- en: OpenJDK ([https://openjdk.java.net/](https://openjdk.java.net/))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenJDK ([https://openjdk.java.net/](https://openjdk.java.net/))
- en: GraalVM ([https://www.graalvm.org/](https://www.graalvm.org/))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM ([https://www.graalvm.org/](https://www.graalvm.org/))
- en: VisualVM ([https://visualvm.github.io/index.html](https://visualvm.github.io/index.html))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VisualVM ([https://visualvm.github.io/index.html](https://visualvm.github.io/index.html))
- en: The Ideal Graph Visualizer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想图可视化器
- en: There are some sample code snippets, which are available in our Git repository.
    The code can be downloaded from [https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter04](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter04).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一些示例代码片段，这些代码片段可在我们的Git仓库中找到。代码可以从[https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter04](https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter04)下载。
- en: The Code in Action video for this chapter can be found at [https://bit.ly/3fmPsaP.](https://bit.ly/3fmPsaP.)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可在[https://bit.ly/3fmPsaP.](https://bit.ly/3fmPsaP.)找到。
- en: Setting up the environment
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: In this chapter, we will be using VisualVM and the Ideal Graph Visualizer to
    understand how Graal JIT works. This understanding will help us, in the subsequent
    chapters, to build optimum code with Graal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用VisualVM和理想图可视化器来理解Graal JIT的工作原理。这种理解将有助于我们在后续章节中用Graal构建最佳代码。
- en: Setting up Graal
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Graal
- en: In [*Chapter 3*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054), *GraalVM Architecture*,
    we discussed the two editions of Graal – Community Edition and **Enterprise Edition**
    (**EE**). Graal Community Edition can be downloaded from the Git repository mentioned
    in the *Technical requirements* section, while EE requires you to register with
    Oracle to download it. EE is available for free for evaluation and non-production
    applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16878_03_Final_SK_ePub.xhtml#_idTextAnchor054)“GraalVM架构”中，我们讨论了Graal的两个版本——社区版和企业版（**EE**）。社区版可以从*技术要求*部分提到的Git仓库中下载，而EE则需要你注册Oracle以下载。EE可用于免费评估和非生产应用。
- en: Installing the Community Edition
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装社区版
- en: To install GraalVM Community Edition, go to [https://github.com/graalvm/graalvm-ce-builds/releases](https://github.com/graalvm/graalvm-ce-builds/releases)
    and download the latest release for the target operating system (macOS, Linux,
    and Windows). At the time of writing this book, the latest version is 21.0.0.2,
    with base Java 8 or Java 11 versions. The Community Edition is built on OpenJDK.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 GraalVM 社区版，请访问 [https://github.com/graalvm/graalvm-ce-builds/releases](https://github.com/graalvm/graalvm-ce-builds/releases)，并下载针对目标操作系统（macOS、Linux
    和 Windows）的最新版本。在撰写本书时，最新版本是 21.0.0.2，基于 Java 8 或 Java 11 版本。社区版基于 OpenJDK 构建。
- en: Please follow the instructions provided next for your target operating system.
    The latest instructions can be found at https://www.graalvm.org/docs/getting-started/#install-graalvm.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照下一部分提供的针对目标操作系统的说明进行操作。最新说明可以在 https://www.graalvm.org/docs/getting-started/#install-graalvm
    找到。
- en: Installing GraalVM on macOS
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 macOS 上安装 GraalVM
- en: For macOS, after downloading the GraalVM archive file, unzip the archive and
    copy the contents of the unzipped folder to `/Library/Java/JavaVirtualMachines/<graalvm>/Contents/Home`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS，下载 GraalVM 归档文件后，解压归档并将解压文件夹的内容复制到 `/Library/Java/JavaVirtualMachines/<graalvm>/Contents/Home`。
- en: 'Once we have copied the files, we have to export the paths to access the GraalVM
    binaries. Let''s run the following `export` commands on the terminal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们复制了文件，我们必须导出路径以访问 GraalVM 二进制文件。让我们在终端上运行以下 `export` 命令：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For macOS Catalina and later, the `quarantine` attribute needs to be removed.
    It can be done with the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS Catalina 及更高版本，需要移除 `quarantine` 属性。可以使用以下命令完成：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If this is not done, you will see the following error message:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这样做，你会看到以下错误信息：
- en: '![Figure 4.1 – Error message while running Graal on MacOS'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 在 MacOS 上运行 Graal 时出现的错误信息'
- en: '](img/Figure_4.1_B16878.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.1_B16878.jpg]'
- en: Figure 4.1 – Error message while running Graal on MacOS
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 在 MacOS 上运行 Graal 时出现的错误信息
- en: SDKMAN provides an automated way of installing GraalVM. Please refer to [https://sdkman.io/](https://sdkman.io/)
    for more details.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SDKMAN 提供了一种自动安装 GraalVM 的方法。有关更多详细信息，请参阅 [https://sdkman.io/](https://sdkman.io/)。
- en: Installing GraalVM on Linux
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 GraalVM
- en: 'To install GraalVM on Linux, extract the downloaded zip file, copy it to any
    target folder, and set the `PATH` and `JAVA_HOME` paths to point to the folder
    where the extracted files are. To do this, execute the following commands on the
    command line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 上安装 GraalVM，请解压下载的 zip 文件，将其复制到任何目标文件夹，并将 `PATH` 和 `JAVA_HOME` 路径设置为指向提取文件的文件夹。为此，请在命令行上执行以下命令：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing GraalVM on Windows
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 GraalVM
- en: 'To install GraalVM on Windows, extract the `.zip` file, copy it to any target
    folder, set the `PATH` and `JAVA_HOME` paths to point to the folder where the
    extracted files are. To set the `PATH` environment variables, execute the following
    commands on the terminal:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上安装 GraalVM，请解压 `.zip` 文件，将其复制到任何目标文件夹，并将 `PATH` 和 `JAVA_HOME` 路径设置为指向提取文件的文件夹。要设置
    `PATH` 环境变量，请在终端上执行以下命令：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To check that the installation and setup are complete, run the `java -version`
    command on the terminal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查安装和设置是否完成，请在终端上运行 `java -version` 命令。
- en: 'After executing the command, you should see something like the following output
    (I am using GraalVM EE 21.0.0 on Java 11\. You should see the version that you
    installed):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，你应该会看到以下类似输出（我在使用 GraalVM EE 21.0.0 和 Java 11。你应该看到你安装的版本）：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s now explore the folder structure of GraalVM installation. In the GraalVM
    installation folder, you will find the folder structure explained in the following
    table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索 GraalVM 安装的文件夹结构。在 GraalVM 安装文件夹中，你可以找到以下表格中解释的文件夹结构：
- en: '![](img/01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01.jpg)'
- en: 'In the previous chapter, we covered in detail the various runtimes, tools,
    and utilities that come with Graal. Graal Updater is one of the very important
    tools that is used to install optional runtimes. To check the runtimes that are
    available, execute `gu list`. The following screenshot shows the typical output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们详细介绍了 Graal 伴随的各种运行时、工具和实用程序。Graal 更新器是用于安装可选运行时的非常重要的工具之一。要检查可用的运行时，请执行
    `gu list`。以下截图显示了典型的输出：
- en: '![Figure 4.2 – Graal Updater listing'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – Graal 更新器列表'
- en: '](img/Figure_4.2_B16878.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.2_B16878.jpg]'
- en: Figure 4.2 – Graal Updater listing
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – Graal 更新器列表
- en: We can run `gu install <runtime>` to install other runtimes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行 `gu install <runtime>` 来安装其他运行时。
- en: Installing EE
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 EE
- en: GraalVM EE is available for free for trial and non-production use. It can be
    downloaded from [https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM EE 可免费用于试用和非生产用途。可以从 [https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/)
    下载。
- en: 'Select the required GraalVM Enterprise version. The website will redirect you
    to Oracle''s registration page. If you are already registered, you should be able
    to log in, and you will be redirected to a page from where you can download GraalVM
    and the supporting tools. At the time of writing this book, the screen looks something
    like the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所需的 GraalVM Enterprise 版本。网站将重定向您到 Oracle 的注册页面。如果您已经注册，您应该能够登录，然后将被重定向到一个可以下载
    GraalVM 和支持工具的页面。在撰写本书时，屏幕看起来大致如下截图：
- en: '![Figure 4.3 – GraalVM EE download page'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.3 – GraalVM EE 下载页面'
- en: '](img/Figure_4.3_B16878.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.3_B16878.jpg)'
- en: Figure 4.3 – GraalVM EE download page
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – GraalVM EE 下载页面
- en: 'You can select the right version of EE that you want to download along with
    the base JDK version. At the time of writing the book, Java 8 and Java 11 are
    two viable versions. When you scroll down this page, you will find download links
    for the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择要下载的 EE 版本以及基础 JDK 版本。在撰写本书时，Java 8 和 Java 11 是两个可行的版本。当您滚动此页面时，您将找到以下下载链接：
- en: '**Oracle GraalVM Enterprise Edition Core**: This the code for GraalVM.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle GraalVM Enterprise Edition 核心**：这是 GraalVM 的代码。'
- en: '**Oracle GraalVM Enterprise Edition Native Image**: This is the native image
    tool. It can also be downloaded using Graal Updater later.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle GraalVM Enterprise Edition 本地图像工具**：这是一个本地图像工具。它也可以稍后使用 Graal 更新器下载。'
- en: '**Ideal Graph Visualizer**: This is a very powerful Graal graph analyzer tool.
    It needs to be downloaded for this chapter. See the instructions in the *Installing
    the Ideal Graph Visualizer* section.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理想图可视化器**：这是一个非常强大的 Graal 图分析工具。您需要为此章节下载它。请参阅“安装理想图可视化器”部分的说明。'
- en: '**GraalVM LLVM Toolchain**: This is the LLVM toolchain, which is required if
    you want to compile and run C/C++ applications on GraalVM.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraalVM LLVM 工具链**：如果您想在 GraalVM 上编译和运行 C/C++ 应用程序，则需要此 LLVM 工具链。'
- en: '**Oracle GraalVM Enterprise Edition Ruby Language Plugin**: This is the Ruby
    language compiler and runtime. It can also be downloaded using Graal Updater later.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle GraalVM Enterprise Edition Ruby 语言插件**：这是一个 Ruby 语言编译器和运行时。它也可以稍后使用
    Graal 更新器下载。'
- en: '**Oracle GraalVM Enterprise Edition Python Language Plugin**: This is the Python
    language compiler and runtime. It can also be downloaded using Graal Updater later.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle GraalVM Enterprise Edition Python 语言插件**：这是一个 Python 语言编译器和运行时。它也可以稍后使用
    Graal 更新器下载。'
- en: '**Oracle GraalVM Enterprise Edition WebAssembly Language Plugin**: This is
    the WebAssembly language compiler and runtime. It can also be downloaded using
    Graal Updater later.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle GraalVM Enterprise Edition WebAssembly 语言插件**：这是一个 WebAssembly 语言编译器和运行时。它也可以稍后使用
    Graal 更新器下载。'
- en: '**Oracle GraalVM Enterprise Edition Java on Truffle**: This is the JVM implementation
    on the Truffle interpreter.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle GraalVM Enterprise Edition 在 Truffle 上的 Java**：这是在 Truffle 解释器上的 JVM
    实现。'
- en: Switching between editions
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在版本之间切换
- en: We can have multiple versions/distributions of GraalVM installed on the same
    machine, and we can switch between these various distributions. In this chapter,
    we will be switching between the distributions to compare their performance. The
    best way to switch between distributions is by using Visual Studio Code. Visual
    Studio Code provides a GraalVM plugin that helps us to add the various distributions,
    and with single click of a button, allows us to switch between the various distributions.
    Please refer to [https://www.graalvm.org/tools/vscode/](https://www.graalvm.org/tools/vscode/)
    and [https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm](https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm
    ) for more details. Refer to the *Debugging and monitoring applications* section
    later in this chapter for more details on how to install Visual Studio Code and
    use it for debugging applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在同一台机器上安装多个版本的 GraalVM，并且可以在这些不同的发行版之间切换。在本章中，我们将切换到不同的发行版以比较它们的性能。在发行版之间切换的最佳方式是使用
    Visual Studio Code。Visual Studio Code 提供了一个 GraalVM 插件，帮助我们添加各种发行版，并且只需单击一下按钮，就可以在各个发行版之间切换。请参阅
    [https://www.graalvm.org/tools/vscode/](https://www.graalvm.org/tools/vscode/)
    和 [https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm](https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm
    ) 获取更多详细信息。请参阅本章后面的 *调试和监控应用程序* 部分，以获取有关如何安装 Visual Studio Code 并用于调试应用程序的更多详细信息。
- en: We can also create shell scripts to switch between the various distributions
    by setting the PATH and JAVA_HOME environment variables to point to appropriate
    distributions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建 shell 脚本来在各个发行版之间切换，通过设置 PATH 和 JAVA_HOME 环境变量指向适当的发行版。
- en: Installing Graal VisualVM
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Graal VisualVM
- en: Java VisualVM is one of the most powerful tools for analyzing an application's
    heap, thread, and CPU utilization. VisualVM is widely used to analyze core dumps,
    heap dumps, and applications that are offline. It is a very sophisticated tool
    that can identify bottlenecks and optimize Java code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Java VisualVM 是分析应用程序堆、线程和 CPU 利用率的最强大工具之一。VisualVM 广泛用于分析核心转储、堆转储和离线的应用程序。它是一个非常复杂的工具，可以识别瓶颈并优化
    Java 代码。
- en: Since JDK 9, VisualVM has been moved and upgraded to Graal VisualVM. Graal VisualVM
    extends the functionality to include the analysis of Graal processes, and currently
    supports JavaScript, Python, Ruby, and R. Graal VisualVM also supports some limited
    monitoring and analysis functionality for native image processes. Graal VisualVM
    comes bundled with both Graal Community Edition and EE. Graal VisualVM can be
    found at `.bin/jvisualvm` (`.exe` for windows).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 自 JDK 9 以来，VisualVM 已迁移并升级为 Graal VisualVM。Graal VisualVM 扩展了功能，包括对 Graal 进程的分析，并目前支持
    JavaScript、Python、Ruby 和 R。Graal VisualVM 还为原生图像进程提供了一些有限的监控和分析功能。Graal VisualVM
    与 Graal Community Edition 和 EE 一起捆绑提供。Graal VisualVM 可在 `.bin/jvisualvm`（Windows
    的 `.exe`）中找到。
- en: 'Let''s quickly go through the key features of Graal VisualVM. Graal VisualVM
    has a very intuitive interface. The left panel of the main window (see *Figure
    4.3*) shows all the **Local** and **Remote** processes. Using this, we can easily
    connect to those processes to start our analysis:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下 Graal VisualVM 的关键特性。Graal VisualVM 具有一个非常直观的界面。主窗口的左侧面板（见 *图 4.3*）显示了所有
    **本地** 和 **远程** 进程。使用这个功能，我们可以轻松连接到这些进程以开始我们的分析：
- en: '![Figure 4.4 – VisualVM, left pane'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4 – VisualVM，左侧面板'
- en: '](img/Figure_4.4_B16878.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.4_B16878.jpg)'
- en: Figure 4.4 – VisualVM, left pane
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – VisualVM，左侧面板
- en: 'Once we connect to the process, in the right panel, we will see the following
    five tabs:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们连接到进程，在右侧面板中，我们将看到以下五个选项卡：
- en: '**Overview**: On this tab, we can see the process configuration, JVM arguments,
    and system properties. The following screenshot shows the typical screen for the
    **FibonacciCalculator** process that we are running:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概述**：在此选项卡中，我们可以看到进程配置、JVM 参数和系统属性。以下截图显示了我们所运行的 **FibonacciCalculator**
    进程的典型屏幕：'
- en: '![Figure 4.5 – VisualVM – application overview'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – VisualVM – 应用概述'
- en: '](img/Figure_4.5_B16878.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.5_B16878.jpg)'
- en: Figure 4.5 – VisualVM – application overview
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – VisualVM – 应用概述
- en: '**Monitor**: On this tab, we can see CPU usage, heap allocation, the number
    of classes that are loaded, the number of threads that are running, and so on.
    We can also force a garbage collection to see how the process behaves. We can
    perform a heap dump to do a deeper analysis of the heap allocations. Here is a
    screenshot of the window:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：在此选项卡上，我们可以看到 CPU 使用率、堆分配、加载的类数量、正在运行的线程数量等。我们还可以强制进行垃圾收集以查看进程的行为。我们可以执行堆转储以对堆分配进行更深入的分析。以下是窗口的截图：'
- en: '![Figure 4.6 – VisualVM – application monitoring'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6 – VisualVM – 应用程序监控'
- en: '](img/Figure_4.6_B16878.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.6_B16878.jpg)'
- en: Figure 4.6 – VisualVM – application monitoring
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – VisualVM – 应用程序监控
- en: '**Threads**: This tab provides detailed information about the various threads
    that are running the processes. We can also capture a thread dump to perform further
    analysis. This tab not only shows the live threads, but we can also analyze the
    threads that have finished execution. The following screenshot shows the typical
    **Threads** tab:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程**：此选项卡提供了有关正在运行进程的各种线程的详细信息。我们还可以捕获线程转储以进行进一步分析。此选项卡不仅显示了活动线程，我们还可以分析已完成的线程。以下是一个典型的**线程**选项卡截图：'
- en: '![Figure 4.7 – VisualVM – application threads'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.7 – VisualVM – 应用程序线程'
- en: '](img/Figure_4.7_B16878.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.7_B16878.jpg)'
- en: Figure 4.7 – VisualVM – application threads
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – VisualVM – 应用程序线程
- en: 'Here is a typical screenshot of the thread dump that can be used to identify
    if there are any deadlocks or thread waits:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个典型的线程转储截图，可以用来确定是否存在任何死锁或线程等待：
- en: '![Figure 4.8 – VisualVM – thread dump'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.8 – VisualVM – 线程转储'
- en: '](img/Figure_4.8_B16878.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.8_B16878.jpg)'
- en: Figure 4.8 – VisualVM – thread dump
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – VisualVM – 线程转储
- en: '**Sampler**: This tab can be used to take a snapshot of the running process
    and carry out analysis on CPU, memory, and so on. Here is a screenshot that shows
    the memory usage for the snapshot we take by clicking the **Snapshots** button:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采样器**：此选项卡可以用来对运行中的进程进行快照，并对 CPU、内存等进行分析。以下是点击**快照**按钮所获取的快照的内存使用截图：'
- en: '![Figure 4.9 – VisualVM – Memory usage using Snapshot'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.9 – VisualVM – 使用快照的内存使用'
- en: '](img/Figure_4.9_B16878.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.9_B16878.jpg)'
- en: Figure 4.9 – VisualVM – Memory usage using Snapshot
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – VisualVM – 使用快照的内存使用
- en: '**Profiler**: This is like the sampler, but it runs all the time. Apart from
    CPU and memory, we can also look at JDBC invocations and the time it takes to
    get the response. The next screenshot shows CPU profiling:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析器**：这就像采样器，但它一直运行。除了 CPU 和内存之外，我们还可以查看 JDBC 调用和获取响应所需的时间。下一张截图显示了 CPU 分析：'
- en: '![Figure 4.10 – VisualVM – application profiler'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10 – VisualVM – 应用程序分析器'
- en: '](img/Figure_4.10_B16878.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.10_B16878.jpg)'
- en: Figure 4.10 – VisualVM – application profiler
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – VisualVM – 应用程序分析器
- en: Apart from this, Graal VisualVM can be used to analyze Core dumps and to identify
    the root cause of any Java process crashes. At the time of writing this book,
    Graal VisualVM supports JavaScript and Ruby (heap, object view, and thread view
    only), Python, and R (heap and object view only).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，Graal VisualVM 还可以用来分析核心转储，以确定任何 Java 进程崩溃的根本原因。在撰写本书时，Graal VisualVM
    支持 JavaScript 和 Ruby（仅限于堆、对象视图和线程视图），Python 和 R（仅限于堆和对象视图）。
- en: '**JDK Flight Recorder** (**JFR**) analysis is another powerful feature of VisualVM.
    It helps us to analyze the data that is connected by JFR with no overhead on the
    running process. JFR provides more advanced analysis, including capturing and
    analyzing file I/O, socket I/O, and thread locks apart from CPU and thread.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**JDK 飞行记录器**（**JFR**）分析是 VisualVM 的另一个强大功能。它帮助我们分析通过 JFR 连接的数据，而不会对运行中的进程产生开销。JFR
    提供了更高级的分析，包括捕获和分析文件 I/O、套接字 I/O 和线程锁，除了 CPU 和线程之外。'
- en: 'Graal VisualVM also provides extension APIs so we can write custom plugins.
    Various plugins can be used to extend Graal VisualVM. Here are some of the most
    widely used plugins:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Graal VisualVM 还提供了扩展 API，因此我们可以编写自定义插件。可以使用各种插件来扩展 Graal VisualVM。以下是一些最广泛使用的插件：
- en: '**Visual GC plugin**: This plugin provides a powerful interface to monitor
    garbage collection, class loader, and JIT compiler performance. It is a very powerful
    plugin that can identify optimizations in the code to improve performance.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视 GC 插件**：此插件提供了一个强大的界面来监控垃圾收集、类加载器和 JIT 编译器的性能。这是一个非常强大的插件，可以识别代码中的优化以改进性能。'
- en: '**Tracer**: Tracer provides a better user interface for detailed monitoring
    and analyzing of the applications.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪器**：跟踪器提供了一个更好的用户界面，用于详细监控和分析应用程序。'
- en: '**Startup Profiler**: As the name suggests, this provides instrumentation to
    profile the startups and identify any optimizations that can be performed to improve
    the startups.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动分析器**：正如其名所示，它提供了用于分析启动过程并识别可以执行的优化以改进启动的仪器。'
- en: You can find the full list of available plugins at [https://visualvm.github.io/pluginscenters.html](https://visualvm.github.io/pluginscenters.html).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://visualvm.github.io/pluginscenters.html](https://visualvm.github.io/pluginscenters.html)找到可用的插件完整列表。
- en: Installing the Ideal Graph Visualizer
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装理想图可视化器
- en: Ideal Graph Visualizer is a very powerful tool for analyzing how Graal JIT is
    performing various optimizations. This requires an advanced understanding of Graal
    Graphs, which is an intermediate representation. Later in this chapter, we will
    cover Graal Graph and how to use the Ideal Graph Visualizer so that we can see
    how Graal performs various optimizations. This is critical, as it helps us write
    better code and optimize the code at development time, and reduces the load on
    the compiler to perform it just in time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Ideal Graph Visualizer is a very powerful tool for analyzing how Graal JIT is
    performing various optimizations. This requires an advanced understanding of Graal
    Graphs, which is an intermediate representation. Later in this chapter, we will
    cover Graal Graph and how to use the Ideal Graph Visualizer so that we can see
    how Graal performs various optimizations. This is critical, as it helps us write
    better code and optimize the code at development time, and reduces the load on
    the compiler to perform it just in time.
- en: 'The The Ideal Graph Visualizer is available with GraalVM EE. It can be downloaded
    from the Oracle website. The Ideal Graph Visualizer can be launched with the following
    command, after setting the `PATH` to the location where it has been unzipped/installed:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'The Ideal Graph Visualizer is available with GraalVM EE. It can be downloaded
    from the Oracle website. The Ideal Graph Visualizer can be launched with the following
    command, after setting the `PATH` to the location where it has been unzipped/installed:'
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `--jdkhome` flag can be used to point to the right version of GraalVM.
    Once it has been launched, you will see the following screen:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `--jdkhome` flag can be used to point to the right version of GraalVM.
    Once it has been launched, you will see the following screen:'
- en: '![Figure 4.11 – The Ideal Graph Visualizer – main window'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.11 – 理想图可视化器 – 主窗口'
- en: '](img/Figure_4.11_B16878.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.11_B16878.jpg]'
- en: Figure 4.11 – The Ideal Graph Visualizer – main window
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 理想图可视化器 – 主窗口
- en: 'The Ideal Graph Visualizer requires Graal dumps to render and analyze Graal
    Graphs. Graal dumps can be created using the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'The Ideal Graph Visualizer requires Graal dumps to render and analyze Graal
    Graphs. Graal dumps can be created using the following command:'
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `n` in the preceding command can be `1`, `2`, or `3`, and each number denotes
    a level of verbosity. This generates a folder called `graal_dumps`, which consists
    of `bgv` files (Binary Graph Files). Sometimes you will find various `bgv` files
    due to invalidation and recompilation (deoptimization or on-stack replacements
    – please refer to [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, HotSpot, and GraalJIT* , and find the *On-stack replacement* section to
    find out more). These `bgv` files can be opened in The Ideal Graph Visualizer
    to do the analysis. Once the `bgv` file is loaded, you will see a screen like
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`n`可以是`1`、`2`或`3`，每个数字代表一个详细程度级别。这将生成一个名为`graal_dumps`的文件夹，其中包含`bgv`文件（二进制图文件）。有时你会因为无效化和重新编译（去优化或栈上替换）而找到各种`bgv`文件（请参阅[*第2章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028)，*JIT、HotSpot和GraalJIT*，并查找*栈上替换*部分以获取更多信息）。这些`bgv`文件可以在理想图可视化器中打开以进行分析。一旦`bgv`文件被加载，你将看到如下屏幕：
- en: '![Figure 4.12 – The Ideal Graph Visualizer – main window–Graal dump'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.12 – 理想图可视化器 – 主窗口–Graal转储'
- en: '](img/Figure_4.12_B16878.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_4.12_B16878.jpg]'
- en: Figure 4.12 – The Ideal Graph Visualizer – main window–Graal dump
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 理想图可视化器 – 主窗口–Graal转储
- en: The left pane can be used to navigate through the various phases of compilation
    and optimization, the main window shows the graph, and the right pane can be used
    to configure how to render these graphs. We can view the Graal Graphs, Call Graph,
    AST, and Truffle Call Tree.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: The left pane can be used to navigate through the various phases of compilation
    and optimization, the main window shows the graph, and the right pane can be used
    to configure how to render these graphs. We can view the Graal Graphs, Call Graph,
    AST, and Truffle Call Tree.
- en: The Ideal Graph Visualizer can also be connected from the Java runtime (using
    the `Dgraal.PrintGraph=Network` flag) to view the graphs in real time, while the
    application code is executing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: The Ideal Graph Visualizer can also be connected from the Java runtime (using
    the `Dgraal.PrintGraph=Network` flag) to view the graphs in real time, while the
    application code is executing.
- en: In the next section, we will explore how these Graal Graphs can be read to understand
    how the Graal compiler works.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: In the next section, we will explore how these Graal Graphs can be read to understand
    how the Graal compiler works.
- en: Understanding the Graal JIT compiler
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Graal JIT编译器
- en: In the previous chapter, we briefly touched upon the Graal compiler and the
    ecosystem around it. In this section, we will dig deeper into various compiler
    options and see how Graal optimizes the code just in time. In the next section,
    we will take a look at Ahead-of-Time compilation, and how a native image can be
    created. Before we get into the details of how the Graal compiler works, let's
    quickly go through some of the Graal compiler configurations, which can be passed
    as arguments to the virtual machine.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了 Graal 编译器和其生态系统。在本节中，我们将深入了解各种编译器选项，并了解 Graal 如何即时优化代码。在下一节中，我们将探讨即时编译，以及如何创建原生镜像。在我们深入了解
    Graal 编译器的工作原理之前，让我们快速浏览一些可以传递给虚拟机的 Graal 编译器配置。
- en: Graal compiler configuration
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Graal 编译器配置
- en: The Graal compiler can be configured with various arguments that can be passed
    from the `java` command (in the GraalVM version of `java`). In this section, we
    will go through some of the most useful command-line configurations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Graal 编译器可以通过传递给 `java` 命令（在 GraalVM 版本的 `java` 中）的各种参数进行配置。在本节中，我们将介绍一些最有用的命令行配置。
- en: We will be trying these various flags on a sample application to see how it
    affects the Graal compiler.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个示例应用程序上尝试这些不同的标志，以查看它如何影响 Graal 编译器。
- en: 'Let''s write a simple Java class called `FibonacciCalculator`. Here is the
    source code of the class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的 Java 类，称为 `FibonacciCalculator`。以下是类的源代码：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we are generating `1000000000` to `1000000010` Fibonacci numbers,
    and then later calculating the sum total of all the Fibonacci number that are
    generated. The code is written to loops to trigger the compilation threshold.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在生成 `1000000000` 到 `1000000010` 个斐波那契数，然后稍后计算生成的所有斐波那契数的总和。代码被编写成循环以触发编译阈值。
- en: 'There are a lot of optimization opportunities for JIT. Let''s first run this
    program with Java HotSpot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: JIT 有很多优化机会。让我们首先使用 Java HotSpot 运行此程序：
- en: '![Figure 4.13 – FibonnaciCalculator – Java HotSpot output'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13 – FibonacciCalculator – Java HotSpot 输出'
- en: '](img/Figure_4.13_B16878.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.13_B16878.jpg)'
- en: Figure 4.13 – FibonnaciCalculator – Java HotSpot output
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – FibonacciCalculator – Java HotSpot 输出
- en: 'As you can see, the initial iterations took the most time, and it optimized
    to around 1,300 ms over the iterations. Let''s now compile the code with `javac`,
    which we got from the Graal EE distribution, and run the same program with Graal
    JIT. The following screenshot shows the output of running the same application
    with GraalVM (GraalVM EE 21.0.0.2 on Java 11):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，初始迭代花费了最多时间，并且经过迭代优化到大约 1,300 毫秒。现在让我们使用从 Graal EE 分发中获得的 `javac` 编译代码，并使用
    Graal JIT 运行相同的程序。以下截图显示了使用 GraalVM（Java 11 上的 GraalVM EE 21.0.0.2）运行相同应用程序的输出：
- en: '![Figure 4.14 – FibonnaciCalculator – GraalVM output'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14 – FibonacciCalculator – GraalVM 输出'
- en: '](img/Figure_4.14_B16878.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.14_B16878.jpg)'
- en: Figure 4.14 – FibonnaciCalculator – GraalVM output
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – FibonacciCalculator – GraalVM 输出
- en: 'We can see significant improvement in performance. Graal started similarly
    to Java HotSpot, but over the iterations it optimized to 852 ms, compared to the
    1,300 ms it took to run with HotSpot. The following option is used to disable
    GraalJIT and use HotSpot on GraalVM:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到性能有显著提升。Graal 的起始速度与 Java HotSpot 相似，但在迭代过程中优化到 852 毫秒，而使用 HotSpot 运行则需要
    1,300 毫秒。以下选项用于禁用 GraalJIT 并在 GraalVM 上使用 HotSpot：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is normally used to compare the performance of Graal. Let''s run this
    option with the preceding source code, with the GraalVM EE 21.0.0.2 compiler:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于比较 Graal 的性能。让我们使用 GraalVM EE 21.0.0.2 编译器运行此选项，并使用前面的源代码：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is a screenshot of the output after running the preceding command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在运行前面命令后的输出截图：
- en: '![Figure 4.15 – FibonnaciCalculator – GraalVM (21/Java 11) output'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15 – FibonacciCalculator – GraalVM (21/Java 11) 输出'
- en: '](img/Figure_4.15_B16878.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.15_B16878.jpg)'
- en: Figure 4.15 – FibonnaciCalculator – GraalVM (21/Java 11) output
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – FibonacciCalculator – GraalVM (21/Java 11) 输出
- en: As you can see, even though we are using the Graal compiler, the performance
    is similar to Java HotSpot, and in fact is slower than Java HotSpot 15\. Note
    that our Graal is running on Java 11.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，尽管我们使用的是 Graal 编译器，但性能与 Java HotSpot 相似，实际上比 Java HotSpot 15 慢。请注意，我们的
    Graal 是在 Java 11 上运行的。
- en: 'The `CompilerConfiguration` flag is used to specify which JIT compiler is to
    be used. The following is the argument that we can pass to set the compiler configuration:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompilerConfiguration` 标志用于指定要使用哪个 JIT 编译器。以下是我们可以传递给设置编译器配置的参数：'
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have three options; let''s also run these options with our sample code to
    see how it performs:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个选项；让我们也用我们的示例代码运行这些选项，看看它的性能如何：
- en: '`-Dgraal.CompilerConfiguration=enterprise`: This uses the enterprise JIT, and
    generates the optimum code. However, there will be initial slowdowns due to compilation:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Dgraal.CompilerConfiguration=enterprise`：这使用企业 JIT，并生成最优代码。然而，由于编译，会有初始的减速：'
- en: '![Figure 4.16 – FibonnaciCalculator – enterprise compiler configuration'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.16 – Fibonacci 计算器 – 企业编译器配置'
- en: '](img/Figure_4.16_B16878.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.16_B16878.jpg)'
- en: Figure 4.16 – FibonnaciCalculator – enterprise compiler configuration
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – Fibonacci 计算器 – 企业编译器配置
- en: '`-Dgraal.CompilerConfiguration=community`: This produces the community version
    of JIT, which optimizes to a decent extent. The compilation is therefore faster.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Dgraal.CompilerConfiguration=community`：这会产生社区版本的 JIT，它优化到相当的程度。因此，编译速度更快。'
- en: '![Figure 4.17 – FibonnaciCalculator – community compiler configuration'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.17 – Fibonacci 计算器 – 社区编译器配置'
- en: '](img/Figure_4.17_B16878.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.17_B16878.jpg)'
- en: Figure 4.17 – FibonnaciCalculator – community compiler configuration
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – Fibonacci 计算器 – 社区编译器配置
- en: '`-Dgraal.CompilerConfiguration=economy`: This compiles quickly, with fewer
    optimizations:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Dgraal.CompilerConfiguration=economy`：这编译得很快，优化较少：'
- en: '![Figure 4.18 – FibonnaciCalculator – economy compiler configuration'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.18 – Fibonacci 计算器 – 经济型编译器配置'
- en: '](img/Figure_4.18_B16878.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.18_B16878.jpg)'
- en: Figure 4.18 – FibonnaciCalculator – economy compiler configuration
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – Fibonacci 计算器 – 经济型编译器配置
- en: 'We can see a significant difference in the performance when using enterprise,
    community, and economy. Here is a comparison of the performances of three options:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在使用企业、社区和经济配置时性能的显著差异。以下是三种选项性能的比较：
- en: '![Figure 4.19 – FibonnaciCalculator – enterprise versus community versus economy
    configuration'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.19 – Fibonacci 计算器 – 企业、社区和经济配置对比'
- en: '](img/Figure_4.19_B16878.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.19_B16878.jpg)'
- en: Figure 4.19 – FibonnaciCalculator – enterprise versus community versus economy
    configuration
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 – Fibonacci 计算器 – 企业、社区和经济配置对比
- en: 'Apart from this, there are a lot of other performance tuning options that can
    be used to improve the performance of the compiler, such as this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，还有很多其他性能调整选项可以用来提高编译器的性能，例如这个：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding flag can be used to enable/disable advanced inlining algorithm.
    Disabling this improves the compilation time and helps throughput.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的标志可用于启用/禁用高级内联算法。禁用此选项可以提高编译时间并帮助提高吞吐量。
- en: 'This flag can be used to disable auto-vectorization optimization:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志可用于禁用自动向量化优化：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This flag can be used to disable the path duplication optimization, such as
    Dominance-Based Duplication Simulation. When this is disabled, it has an impact
    on the throughput:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志可用于禁用路径重复优化，例如基于支配的重复模拟。当禁用时，它会对吞吐量产生影响：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is a very useful flag that can be enabled to trace how the JIT compiler
    takes decisions on inlining optimization:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的标志，可以启用以跟踪 JIT 编译器在内联优化上的决策：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we enable this flag for sample code, we get the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为示例代码启用此标志时，我们得到以下结果：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can see how the JIT compiler is taking decisions on inlining.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 JIT 编译器是如何在内联上做出决策的。
- en: These optimization flags can be set even for other GraalVM launchers, such as
    `js` (for JavaScript), `node`, and `lli`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优化标志甚至可以设置在其他 GraalVM 启动器上，例如 `js`（用于 JavaScript）、`node` 和 `lli`。
- en: Graal JIT compilation pipeline and tiered optimization
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Graal JIT 编译器管道和分层优化
- en: In the previous chapter, in the *Graal JIT compiler* section, we looked at how
    Graal JIT integrates with the virtual machine through JVMCI. In this section,
    let's take a deeper look at how Graal JIT interacts with virtual machine.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，在 *Graal JIT 编译器* 部分，我们探讨了 Graal JIT 如何通过 JVMCI 与虚拟机集成。在本节中，让我们更深入地了解
    Graal JIT 如何与虚拟机交互。
- en: 'Graal optimizes the code in three tiers. The tiered approach helps Graal to
    perform optimizations starting from more platform-independent representations
    (high-level intermediate representation) to more platform-dependent representations
    (low-level intermediate representation). The following diagram shows how Graal
    JIT interfaces with the virtual machine and performs these three tiers of optimization:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Graal 在三个级别上优化代码。分层方法有助于 Graal 从更平台无关的表示（高级中间表示）开始执行优化，到更平台相关的表示（低级中间表示）。以下图表显示了
    Graal JIT 如何与虚拟机接口并执行这三个级别的优化：
- en: '![Figure 4.20 – Graal JIT compiler – compilation tiers'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.20 – Graal JIT 编译器 – 编译层级'
- en: '](img/Figure_4.20_B16878.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.20_B16878.jpg)'
- en: Figure 4.20 – Graal JIT compiler – compilation tiers
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20 – Graal JIT 编译器 – 编译层级
- en: 'Let''s try to understand this picture better:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试更好地理解这张图：
- en: The virtual machine passes the bytecode and metadata to the Graal JIT when it
    hits the compilation threshold (refer to [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, HotSpot, and GraalJIT*, to find out more about the compilation thresholds).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当虚拟机达到编译阈值时，它将字节码和元数据传递给 Graal JIT（参考 [*第 2 章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028)，*JIT、HotSpot
    和 GraalJIT*，了解更多关于编译阈值的信息）。
- en: Graal parses the bytecode and generates a **high-level intermediate representation**
    (**HIR**).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Graal 解析字节码并生成 **高级中间表示**（**HIR**）。
- en: It then performs various optimizations on the **HIR**. These are some of the
    standard Java optimization techniques that are applied, with some new techniques
    that have been introduced in Graal, such as partial escape analysis and advanced
    inlining techniques.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它对 **HIR** 执行各种优化。这些是一些标准 Java 优化技术，以及 Graal 中引入的一些新技术，例如部分逃逸分析和高级内联技术。
- en: Once these high-level optimizations are performed, Graal starts converting the
    high-level operations to low-level operations. This phase is called lowering.
    There are two tiers of optimizations that it performs during this phase, and it
    eventually generates the **low-level intermediate representation** (**LIR**) for
    the target processor architecture.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦执行了这些高级优化，Graal 开始将高级操作转换为低级操作。这个阶段称为降低。在这个阶段，它执行两个层级的优化，并最终为目标处理器架构生成 **低级中间表示**（**LIR**）。
- en: Once all the optimizations are performed on the LIR, the final optimized machine
    code is generated and stored in the code cache, along with the reference maps
    that the garbage collector will use and the metadata that will be required for
    deoptimization.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦对 LIR 执行所有优化，就会生成最终的优化机器代码，并将其存储在代码缓存中，同时还包括垃圾收集器将使用的引用映射和用于反优化的元数据。
- en: In this section, we looked at how the Graal JIT compiler works internally, and
    we also explored various compiler configurations that will affect the compiler's
    performance. Now let's understand the Graal Intermediate Representation better.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了 Graal JIT 编译器内部的工作原理，并研究了各种会影响编译器性能的编译器配置。现在让我们更好地理解 Graal 中间表示。
- en: Graal intermediate representation
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Graal 中间表示
- en: '`AddNode`, `IfNode`, and `SwitchNode`, all of them deriving from the base class,
    `Node`. The edges (operands) are represented as fields of the class. The following
    diagram shows the hierarchy of various types of node:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddNode`、`IfNode` 和 `SwitchNode`，它们都继承自基类 `Node`。边（操作数）表示为类的字段。以下图显示了各种类型节点的层次结构：'
- en: '![Figure 4.21 – Graal Graph nodes – The class hierarchy'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.21 – Graal 图节点 – 类层次结构'
- en: '](img/Figure_4.21_B16878.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.21_B16878.jpg)'
- en: Figure 4.21 – Graal Graph nodes – The class hierarchy
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – Graal 图节点 – 类层次结构
- en: 'The representation of code in SSA enables the creation of a single version
    of the variable for each value. This helps perform better data flow analysis and
    optimizations. A phi function (Φ) is used to convert decision-based control paths
    (such as `if` and `switch`). The Phi function is a function of two values, and
    the value is selected based on the control flow. Refer to the following papers
    on SSA for more details: https://gcc.gnu.org/onlinedocs/gccint/SSA.html and [https://en.wikipedia.org/wiki/Static_single_assignment_form](https://en.wikipedia.org/wiki/Static_single_assignment_form).
    The key point is that the complete program is converted into an SSA to perform
    the optimizations.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SSA 中表示代码可以创建每个值的单个变量版本。这有助于执行更好的数据流分析和优化。使用 phi 函数（Φ）将基于决策的控制路径（如 `if` 和
    `switch`）转换为单一代码。Phi 函数是两个值的函数，值的选择基于控制流。有关 SSA 的更多详细信息，请参阅以下论文：https://gcc.gnu.org/onlinedocs/gccint/SSA.html
    和 [https://en.wikipedia.org/wiki/Static_single_assignment_form](https://en.wikipedia.org/wiki/Static_single_assignment_form)。关键点是，整个程序被转换为
    SSA 以执行优化。
- en: Graal IRs are built as a Graal graph, where each node has input edges that point
    to the nodes that create the operands and the successor edges that show the control
    flow. The successor edge points to the node that succeeds the current node in
    terms of the control flow.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Graal IRs 作为 Graal 图构建，其中每个节点都有指向创建操作数的节点的输入边，以及显示控制流的后续边。后续边指向在控制流方面继当前节点之后的节点。
- en: 'To demonstrate everything that we have discussed so far, let''s analyze some
    simple Java code with The Ideal Graph Visualizer. The logic in this code may not
    generate a simple graph – the code is intentionally kept simple. The loops are
    there to hit the threshold so that when the JVM hits the threshold, it will perform
    Graal JIT compilation, as shown next:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示我们迄今为止讨论的所有内容，让我们使用理想图可视化器分析一些简单的 Java 代码。这段代码中的逻辑可能不会生成一个简单的图——代码故意保持简单。循环是为了达到阈值，当
    JVM 达到阈值时，它将执行 Graal JIT 编译，如下所示：
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s now compile the preceding code using the `javac DemonstrateGraalGraph.java`
    command. To keep the graph simple, we will compile only the `calculateResult()`
    method by using the `-XX:CompileOnly=DemonstrateGraalGraph:calculateResult` flag.
    Let''s also disable some optimizations using the following flags:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 `javac DemonstrateGraalGraph.java` 命令来编译前面的代码。为了保持图简单，我们将只编译 `calculateResult()`
    方法，使用 `-XX:CompileOnly=DemonstrateGraalGraph:calculateResult` 标志。我们还将使用以下标志禁用一些优化：
- en: '`-Dgraal.FullUnroll=false`, `-Dgraal.PartialUnroll=false`, `-Dgraal.LoopPeeling=false`,
    `-Dgraal.LoopUnswitch=false`, `-Dgraal.OptScheduleOutOfLoops=false`, and `-Dgraal.VectorizeLoops=false`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Dgraal.FullUnroll=false`, `-Dgraal.PartialUnroll=false`, `-Dgraal.LoopPeeling=false`,
    `-Dgraal.LoopUnswitch=false`, `-Dgraal.OptScheduleOutOfLoops=false`, 和 `-Dgraal.VectorizeLoops=false`'
- en: 'So, we get the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到以下内容：
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will create a folder called `graal_dumps` with a dump of all the Graal
    JIT activities. Once you load the `bgv` file that is generated by Graal, you will
    find the various tiers of optimization listed in the left pane, as shown in the
    following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `graal_dumps` 的文件夹，其中包含所有 Graal JIT 活动的转储。一旦你加载由 Graal 生成的 `bgv` 文件，你将在左侧面板中找到列出的各种优化层，如下面的截图所示：
- en: '![Figure 4.22 – The Ideal Graph Visualizer – DemonstrateGraalGraph – left pane'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.22 – 理想图可视化器 – DemonstrateGraalGraph – 左侧面板'
- en: '](img/Figure_4.22_B16878.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.22_B16878.jpg)'
- en: Figure 4.22 – The Ideal Graph Visualizer – DemonstrateGraalGraph – left pane
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 – 理想图可视化器 – DemonstrateGraalGraph – 左侧面板
- en: 'When you click on `calculateResult()` method as we asked the JVM to create
    only compile `calculateResult()` method. Let''s understand this graph better:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击 `calculateResult()` 方法时，正如我们要求 JVM 只编译 `calculateResult()` 方法一样。让我们更好地理解这个图：
- en: '![Figure 4.23 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal
    Graph after parsing'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.23 – 理想图可视化器 – DemonstrateGraalGraph – 解析后的 Graal 图'
- en: '](img/Figure_4.23_B16878.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.23_B16878.jpg)'
- en: Figure 4.23 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal Graph
    after parsing
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 – 理想图可视化器 – DemonstrateGraalGraph – 解析后的 Graal 图
- en: The program starts with **0 Start** and the loop starts at the **7 LoopBegin**
    node. To make the graph easier to understand, some of the sections are highlighted
    with the labels **A** and **B**. Let's explore what these sections of the graph
    are.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从 **0 Start** 开始，循环从 **7 LoopBegin** 节点开始。为了使图更容易理解，一些部分被标签 **A** 和 **B**
    突出显示。让我们探索这些图的部分是什么。
- en: '**Section A**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分A**'
- en: Section A highlights the `for` loop. It is converted into a `18 if` statement.
    The input for the `if` statement is the current value of I, which is the output
    of the Phi node `9 Phi(4,22,i32)` and constant 2000 node `11 C(2000) i32`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分A突出了 `for` 循环。它被转换成了 `18 if` 语句。`if` 语句的输入是 I 的当前值，它是 Phi 节点 `9 Phi(4,22,i32)`
    和常数 2000 节点 `11 C(2000) i32` 的输出。
- en: Phi is attached where the control flows merge. In this case, *9 Phi (4,22, i32)*
    merges the output from `4 C(0) i32` (`i=0` in the `for` loop) and the output of
    the `22 +` node (which is `i++`). This node will simply output the current value
    of the `i` after incrementing by the value of the **21 C(1) i32 node**.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Phi 节点连接在控制流合并的地方。在这种情况下，*9 Phi (4,22, i32)* 合并了 `4 C(0) i32`（`for` 循环中的 `i=0`）和
    `22 +` 节点的输出（即 `i++`）。这个节点将简单地输出 `i` 在增加 **21 C(1) i32 节点** 值后的当前值。
- en: This then flows into the **12 <** node and is compared with **11 C(2000) i32**
    (which is the maximum value of the loop), and this expression is evaluated by
    control flow node **18 if**.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，这个表达式流入 **12 <** 节点，并与 **11 C(2000) i32**（循环的最大值）进行比较，这个表达式由控制流节点 **18 if**
    进行评估。
- en: '**Section B**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分B**'
- en: Section B highlights the section where the result is calculated.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分 B 突出了计算结果的部分。
- en: The initial value of the result is represented as `i64`, as we declared it as
    a `long`.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果的初始值表示为 `i64`，因为我们将其声明为 `long`。
- en: The `result = result + i` expression. The value of `i` is flowing from the `I`,
    which flows from **9 Phi(4,22, i32)**.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result = result + i` 表达式。`i` 的值从 `I` 流出，`I` 从 **9 Phi(4,22, i32)** 流出。'
- en: The final out flows into **24 Return** when the loop ends at **18 if**.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当循环在 **18 if** 处结束时，最终输出流向 **24 Return**。
- en: 'Now we can go through each phase of optimization by selecting the phase in
    the left pane to see how the code is optimized. Let''s quickly look at how this
    graph is transformed through the phases. When we select **Before Phase Lowering**
    in the left pane''s **Outline** window, we will see the following graph:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过在左侧面板中选择优化阶段来遍历每个优化阶段，以查看代码是如何被优化的。让我们快速看一下这个图是如何通过各个阶段进行转换的。当我们选择左侧面板的
    **大纲** 窗口中的 **Before Phase Lowering** 时，我们将看到以下图：
- en: '![Figure 4.24 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal
    graph before lowering'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.24 – 理想图可视化器 – 展示 Graal 图 – Graal 图在降低之前'
- en: '](img/Figure_4.24_B16878.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.24_B16878.jpg)'
- en: Figure 4.24 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal graph
    before lowering
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 – 理想图可视化器 – 展示 Graal 图 – Graal 图在降低之前
- en: 'In this phase, we can see the following optimizations:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以看到以下优化：
- en: The **19 Sign Extend** node is replaced with **27 Zero Extend**, as the compiler
    found out that it is an unsigned integer. Operations with unsigned integers are
    less expensive than operations with signed integers.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**19 Sign Extend** 节点被替换为 **27 Zero Extend**，因为编译器发现它是一个无符号整数。与有符号整数相比，无符号整数的操作成本更低。'
- en: The **12 <** node is replaced with **26 |<|**, which is an unsigned less than
    operation, which is faster. The compiler arrives at this conclusion based on the
    various iterations and profiling. Since the operands are considered unsigned,
    even the operations are considered unsigned.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**12 <** 节点被替换为 **26 |<|**，这是一个无符号小于操作，速度更快。编译器基于各种迭代和性能分析得出这个结论。由于操作数被认为是无符号的，因此操作也认为是无符号的。'
- en: The graph also illustrates application of the canonicalization technique of
    replacing <= with <, to speed up the `if` (which is originally the `for` loop)
    statements.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该图还说明了应用规范化技术，用 < 替换 <=，以加快 `if`（最初是 `for` 循环）语句。
- en: 'The subsequent phases – high tier, mid tier, and low tier – may not show significant
    optimizations, as the code is relatively simple and we have disabled some of the
    optimizations to keep the graph simple to read and understand:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 后续阶段 – 高级、中级和低级 – 可能不会显示显著的优化，因为代码相对简单，并且我们已经禁用了一些优化以保持图的可读性和易于理解：
- en: '![Figure 4.25 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal
    Graph, other tiers'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.25 – 理想图可视化器 – 展示 Graal 图 – Graal 图，其他层级'
- en: '](img/Figure_4.25_B16878.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.25_B16878.jpg)'
- en: Figure 4.25 – The Ideal Graph Visualizer – DemonstrateGraalGraph – Graal Graph,
    other tiers
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – 理想图可视化器 – 展示 Graal 图 – Graal 图，其他层级
- en: '*Figure 4.26* is a diagram of the graph with all optimizations enabled. You
    will see that loop unrolling has been used very prominently to speed up the loops:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.26* 是所有优化都启用时的图示。您将看到循环展开被非常突出地使用来加速循环：'
- en: '![Figure 4.26 – The Ideal Graph Visualizer – DemonstrateGraalGraph – The final
    optimized graph'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.26 – 理想图可视化器 – 展示 Graal 图 – 最终优化的图'
- en: '](img/Figure_4.26_B16878.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.26_B16878.jpg)'
- en: Figure 4.26 – The Ideal Graph Visualizer – DemonstrateGraalGraph – The final
    optimized graph
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26 – 理想图可视化器 – 展示 Graal 图 – 最终优化的图
- en: Graal performs various optimizations as part of the tiered compilation. We will
    go through this in detail in the next section, and also see how we can use this
    knowledge to improve the way we write the code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Graal 作为分层编译的一部分执行各种优化。我们将在下一节中详细介绍这一点，并了解我们如何利用这些知识来改进我们的代码编写方式。
- en: Understanding Graal compiler optimizations
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Graal 编译器优化
- en: The Graal compiler performs some of the most advanced optimizations on the code
    just in time. The most critical ones are discussed in the following subsections.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Graal 编译器在即时对代码执行一些最先进的优化。以下小节将讨论其中最关键的。
- en: Before getting into this session, please refer to the *Understanding the optimizations
    performed by JIT* section of [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, HotSpot, and GraalJIT*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入本节之前，请参考[*第二章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028)中“理解JIT执行的优化”部分，*JIT、HotSpot和GraalJIT*。
- en: Speculative optimization
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投机优化
- en: JIT compilation relies heavily on the runtime profiling of the code. As we have
    seen, the graphs are optimized based on the HotSpots. HotSpots, as we covered
    in [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028), *JIT, HotSpot,
    and GraalJIT*, are the control flows that the program goes through most frequently.
    There is no point in trying to optimize the whole code; instead, the JIT compiler
    tries to optimize the hot control paths/flows. This is based on speculation and
    assumption. When an assumption is proven wrong during execution, the compiler
    quickly deoptimizes and waits for another opportunity to optimize based on new
    HotSpots. We covered compiler thresholds and Hot Spots in [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, HotSpot, and GraalJIT*, in the *Compiler threshold* section. Graal JIT also
    uses similar techniques to identify the hotspots. Graal performs all the optimizations
    that we discussed in [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028),
    *JIT, Hotspot, and GraalJIT*, in the *Understanding the optimizations performed
    by JIT* section, but also uses some advanced techniques. Let's go through some
    of the most important optimization techniques that Graal JIT applies to the code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: JIT编译依赖于代码的运行时分析。正如我们所见，图是基于热点进行优化的。热点，如我们在[*第二章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028)中“JIT、HotSpot和GraalJIT”所讨论的，是程序最频繁经过的控制流。试图优化整个代码是没有意义的；相反，JIT编译器试图优化热点控制路径/流。这是基于投机和假设。当执行过程中假设被证明是错误的时候，编译器会迅速去优化，并等待基于新的热点进行优化的另一个机会。我们在[*第二章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028)中“JIT、HotSpot和GraalJIT”的“编译器阈值”部分讨论了编译器的阈值和热点。Graal
    JIT也使用类似的技术来识别热点。Graal执行我们在[*第二章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028)中“JIT、Hotspot和GraalJIT”的“理解JIT执行的优化”部分所讨论的所有优化，但还使用了一些高级技术。让我们来看看Graal
    JIT应用于代码的一些最重要的优化技术。
- en: Partial escape analysis
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分逃逸分析
- en: In [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028), *JIT, HotSpot,
    and GraalJIT*, in the section titled *Understanding the optimizations performed
    by JIT*, we explored escape analysis. Escape analysis is one of the most powerful
    techniques. It identifies the object's scope and the objects escape from local
    to global scope. If it identifies objects that don't escape, there is an opportunity
    to optimize, and the compiler will optimize the code to use stack allocation instead
    of heap allocation for the objects that are within the local scope. This saves
    a significant amount of time in allocating and deallocating memory in the heap.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028)中“理解JIT执行的优化”部分，我们探讨了逃逸分析。逃逸分析是最强大的技术之一。它确定了对象的作用域以及对象从局部作用域逃逸到全局作用域。如果它识别出不会逃逸的对象，就有机会进行优化，编译器将优化代码以使用栈分配而不是堆分配来处理局部作用域内的对象。这可以在堆内存的分配和释放上节省大量时间。
- en: Partial escape analysis takes this further by not just limiting to identifying
    objects that escape a method level scope to control branches. This helps to optimize
    the code when an object is found to be escaping only in certain control flows.
    Other control flows where the object is not escaping can be optimized to either
    use a local value or scalar replacements.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 部分逃逸分析进一步扩展了这一概念，不仅限于识别逃逸方法级别作用域的控制分支。当发现对象仅在特定控制流中逃逸时，这有助于优化代码。其他对象未逃逸的控制流可以被优化为使用局部值或标量替换。
- en: 'Partial escape analysis looks for escapes that might happen through method
    calls, return values, throw statements, and so on. Let''s use a simple code to
    understand how this works:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 部分逃逸分析寻找可能通过方法调用、返回值、抛出语句等方式发生的逃逸。让我们用一个简单的代码示例来理解它是如何工作的：
- en: '[PRE18]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding is some sample code, just to illustrate partial escape analysis.
    In this code we are creating `object1` as an instance of `Class1` and `object2`
    as an instance of `Class2`. Some processing is happening, and `object1` fields
    are updated with some values that are calculated. Based on the flag, `object1`
    or `object2` will escape. Let''s assume that most of the time the flag is `false`,
    and only `object1` escapes, so there is no point in creating `object1` every time
    the method is called. This code gets optimized to something like the following
    (this is just an illustration of how partial escape analysis works; the Graal
    JIT may not do this exact refactoring):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一些示例代码，仅用于说明部分逃逸分析。在这段代码中，我们创建 `object1` 作为 `Class1` 的实例，`object2` 作为 `Class2`
    的实例。正在进行一些处理，并使用计算出的某些值更新 `object1` 的字段。根据标志，`object1` 或 `object2` 将逃逸。假设大多数时间标志是
    `false`，只有 `object1` 逃逸，因此每次方法调用时创建 `object1` 没有意义。这段代码被优化为以下类似的内容（这只是一个说明部分逃逸分析如何工作的示例；Graal
    JIT 可能不会进行这种精确的重构）：
- en: '[PRE19]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`object1` is only created if required, and a temporary variable is used to
    store the intermediate values, and if `object1` has to be initialized then it
    uses the temporary values before it escapes. This optimizes heap allocation time
    and heap size.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`object1` 仅在需要时创建，并使用临时变量存储中间值，如果 `object1` 需要初始化，则使用它逃逸之前的临时值。这优化了堆分配时间和堆大小。'
- en: Inter-procedural analysis and inlining
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨过程分析和内联
- en: Graal performs optimization at the AST/Graph level. This helps Graal to perform
    inter-procedural analysis and identify any option that may never become empty
    and skips compiling that part of the code, as it may never be called. It adds
    a guard to that code block, just in case. If the control flows through that block,
    the JIT can deoptimize the code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Graal 在 AST/Graph 层级进行优化。这有助于 Graal 进行跨过程分析和识别任何可能永远不会为空的选项，并跳过编译代码的这一部分，因为它可能永远不会被调用。它为该代码块添加了一个守卫，以防万一。如果控制流通过该块，JIT
    可以降级代码。
- en: 'To understand inter-procedural analysis and inlining, one commonly used example
    is a JDK class, `OptionalDouble`. Here is a snippet of the `OptionalDouble` class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解跨过程分析和内联，一个常用的例子是 JDK 类 `OptionalDouble`。以下是 `OptionalDouble` 类的一个片段：
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s say we call this `getAsDouble()` method, and the method has a `throw`
    block, but that `throw` block may never be called. The Graal compiler will compile
    all the code, except the `if` block, and will place a `guard` statement so that,
    if it gets called, it can deoptimize the code. Apart from this, Graal performs
    more advanced inlining to optimize the code. We can look at the complete set of
    optimizations that Graal performs by passing `-Dgraal.Dump=:2`. With Graal dump
    at level 2, we get a much more detailed list of graphs for each phase. In the
    next screenshot, you can see a whole list of optimizations the Graal JIT performed
    on the code across the various tiers of compilation:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们调用这个 `getAsDouble()` 方法，并且方法有一个 `throw` 块，但那个 `throw` 块可能永远不会被调用。Graal 编译器将编译所有代码，除了
    `if` 块，并将放置一个 `guard` 语句，以便如果它被调用，它可以降级代码。除此之外，Graal 还执行更高级的内联来优化代码。我们可以通过传递 `-Dgraal.Dump=:2`
    来查看 Graal 执行的完整优化集。在 Graal 溢出级别 2 时，我们得到每个阶段的更详细的图列表。在下一张屏幕截图中，你可以看到 Graal JIT
    在编译的各个层级上对代码执行的整个优化列表：
- en: '![Figure 4.27 – The Ideal Graph Visualizer – DemonstrateGraalGraph – compilation
    tiers'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.27 – 理想图可视化器 – 展示 GraalGraph – 编译层级'
- en: '](img/Figure_4.27_B16878.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.27_B16878.jpg)'
- en: Figure 4.27 – The Ideal Graph Visualizer – DemonstrateGraalGraph – compilation
    tiers
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.27 – 理想图可视化器 – 展示 GraalGraph – 编译层级
- en: By looking at how the graph is optimized at each step, we can see every area
    where the code can be optimized at development time. This will reduce the load
    on Graal JIT and the code will perform better. Some of these optimization techniques
    are covered in the *Understanding the optimizations performed by JIT* section
    of [*Chapter 2*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028), *JIT, HotSpot,
    and GraalJIT*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看图在每一步的优化情况，我们可以看到代码在开发时间可以优化的每个区域。这将减少 Graal JIT 的负载，代码将表现得更好。其中一些优化技术已在
    [*第 2 章*](B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028) 的 *理解 JIT 执行的优化* 部分中介绍，*JIT、HotSpot
    和 GraalJIT*。
- en: Debugging and monitoring applications
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和监控应用程序
- en: GraalVM comes with a rich set of tools for debugging and monitoring applications.
    We have already looked at VisualVM and the Ideal Graph Visualizer. As you saw
    in the previous sections, these two tools are very powerful for detailed analysis.
    This analysis also provides insights into how we can improve the code at the development
    time to reduce the load on Graal JIT, and write high-performing and low-footprint
    Java code. Apart from these two tools, the following are some of the other tools
    that Graal comes with.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 随带了一套丰富的工具，用于调试和监控应用程序。我们已经探讨了 VisualVM 和理想图可视化器。正如你在前面的章节中看到的，这两个工具非常适合详细分析。这种分析还提供了关于我们如何在开发时间改进代码以减少
    Graal JIT 的负载，并编写高性能和低内存占用 Java 代码的见解。除了这两个工具之外，以下是一些 Graal 随带的其他工具。
- en: Visual Studio Code extension
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio Code 扩展
- en: 'The Visual Studio Code extension is one of the most powerful integrated development
    environments for Graal. The following screenshot shows the GraalVM Extension for
    Visual Studio Code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 扩展是 Graal 最强大的集成开发环境之一。以下截图显示了 Visual Studio Code 的 GraalVM
    扩展：
- en: '![Figure 4.28 – GraalVM environments on Visual Studio Code'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.28 – Visual Studio Code 上的 GraalVM 环境'
- en: '](img/Figure_4.28_B16878.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.28_B16878.jpg)'
- en: Figure 4.28 – GraalVM environments on Visual Studio Code
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28 – Visual Studio Code 上的 GraalVM 环境
- en: In the previous screenshot, you can see all the various GraalVM installations
    that have been configured on the left pane. It is very easy to switch between
    various versions of GraalVM, and the terminal and the whole environment will use
    the selected GraalVM.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图的左侧面板中，你可以看到所有已配置的 GraalVM 安装。在各个版本的 GraalVM 之间切换非常容易，终端和整个环境都将使用所选的 GraalVM。
- en: This extension also makes it easy to install optional components. We don't have
    to manually run `gu` commands. This extension provides easy way to build, debug,
    and run code written in Java, Python, R, Ruby, and Polyglot (mixed language code).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展还使得安装可选组件变得容易。我们不必手动运行 `gu` 命令。此扩展提供了一种简单的方式来构建、调试和运行用 Java、Python、R、Ruby
    和 Polyglot（混合语言代码）编写的代码。
- en: 'This extension can be directly installed from the Visual Studio Code Extensions
    tab by searching for Graal. The following screenshot shows the extension installation
    page:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展可以直接从 Visual Studio Code 扩展选项卡中通过搜索 Graal 进行安装。以下截图显示了扩展安装页面：
- en: '![Figure 4.29 – Installing the GraalVM Extension for Visual Studio Code'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.29 – 安装 Visual Studio Code 的 GraalVM 扩展'
- en: '](img/Figure_4.29_B16878.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.29_B16878.jpg)'
- en: Figure 4.29 – Installing the GraalVM Extension for Visual Studio Code
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29 – 安装 Visual Studio Code 的 GraalVM 扩展
- en: 'There is also a GraalVM Extension Pack that comes with additional features
    such as Micronaut framework integration and NetBeans Language Server, which provide
    Java code completion, refactoring, Javadoc integration, and many more advanced
    features. The next screenshot shows the installation page for the GraalVM Extension
    Pack:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个包含额外功能的 GraalVM 扩展包，例如 Micronaut 框架集成和 NetBeans 语言服务器，它们提供 Java 代码补全、重构、Javadoc
    集成以及许多其他高级功能。下一张截图显示了 GraalVM 扩展包的安装页面：
- en: '![Figure 4.30 – GraalVM Extension Pack plugin for Visual Studio Code'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.30 – Visual Studio Code 的 GraalVM 扩展包插件'
- en: '](img/Figure_4.30_B16878.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.30_B16878.jpg)'
- en: Figure 4.30 – GraalVM Extension Pack plugin for Visual Studio Code
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30 – Visual Studio Code 的 GraalVM 扩展包插件
- en: You can learn more about this extension on the GraalVM website at [https://www.graalvm.org/tools/vscode/graalvm-extension/](https://www.graalvm.org/tools/vscode/graalvm-extension/).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GraalVM 网站上了解更多关于此扩展的信息，网址为 [https://www.graalvm.org/tools/vscode/graalvm-extension/](https://www.graalvm.org/tools/vscode/graalvm-extension/)。
- en: GraalVM Dashboard
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraalVM 仪表板
- en: GraalVM Dashboard is a web-based tool with which we can perform detailed analysis
    of both static and dynamic compilations. This is very powerful for Native Image
    analysis. The tool provides details dashboard reports on compilation, reachability,
    usability, profiling data, dynamic compilation parameters, deoptimization, and
    more.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM 仪表板是一个基于 Web 的工具，我们可以用它来执行静态和动态编译的详细分析。这对于原生图像分析非常有用。该工具提供了关于编译、可达性、可用性、性能数据、动态编译参数、去优化等方面的详细仪表板报告。
- en: We will run this tool in the next chapter, when we create a native image of
    our sample code and perform more detailed analysis of the native image code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中运行此工具，当我们创建示例代码的原生图像并执行原生图像代码的更详细分析时。
- en: Command-line tools
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行工具
- en: 'There are two command-line tools that can be used in the context of Polyglot
    to identify further opportunities the optimize the code. We will be using these
    tools in [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle
    – An Overview*, for Polyglot optimization. The following are the two command-line
    tools that come with GraalVM:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在Polyglot的上下文中，有两个命令行工具可以用来识别进一步优化代码的机遇。我们将在[*第6章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)“Truffle
    – 概述”中，用于Polyglot优化时使用这些工具。以下是与GraalVM一起提供的两个命令行工具：
- en: '**Profiling CLI**: This tool helps to identify opportunities to optimize CPU
    and memory usage. Please refer to [https://www.graalvm.org/tools/profiling/](https://www.graalvm.org/tools/profiling/)
    for more details.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能分析CLI**：这个工具有助于识别优化CPU和内存使用的机遇。请参阅[https://www.graalvm.org/tools/profiling/](https://www.graalvm.org/tools/profiling/)获取更多详细信息。'
- en: '**Code Coverage CLI**: This tools records and analyzes the code coverage for
    each execution. This is very powerful for running test cases and ensuring good
    code coverage. This tool can also identify possible dead code that can be eliminated,
    or hot code that can be optimized at development time. Please refer to [https://www.graalvm.org/tools/code-coverage/](https://www.graalvm.org/tools/code-coverage/)
    for more details.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码覆盖率CLI**：这个工具记录并分析每次执行的代码覆盖率。这对于运行测试用例和确保良好的代码覆盖率非常有用。此工具还可以识别可以消除的可能死代码，或在开发时间可以优化的热点代码。请参阅[https://www.graalvm.org/tools/code-coverage/](https://www.graalvm.org/tools/code-coverage/)获取更多详细信息。'
- en: Chrome debugger
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chrome调试器
- en: The Chrome debugger provides the Chrome developer tool extension to debug guest
    language applications. The Chrome debugger can be used while running the application
    with the `--inspect` option. This helps debug JavaScript (Node.js) using Chrome.
    The extension can be installed from [https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/).We
    will be covering this tool while we discuss JavaScript and Node.js on Graal in
    [*Chapter 6*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120), *Truffle – An Overview*.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome调试器提供了Chrome开发者工具扩展，用于调试客户端语言应用程序。当使用`--inspect`选项运行应用程序时，可以使用Chrome调试器。可以从[https://developers.google.com/web/tools/chrome-devtools/](https://developers.google.com/web/tools/chrome-devtools/)安装此扩展。我们将在[*第6章*](B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120)“Truffle
    – 概述”中讨论JavaScript和Node.js在Graal上的使用时介绍此工具。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through Graal JIT and Ahead of Time compilers in detail.
    We took a sample code and looked at how Graal JIT performs various optimizations
    using the Ideal Graph Visualizer. We also went through Graal Graphs in detail.
    This is very critical knowledge that will help you analyze and identify optimizations
    that can be applied during development to speed up Graal JIT compilation at runtime.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了Graal JIT和即时编译器。我们通过一个示例代码，查看Graal JIT如何使用理想图可视化器执行各种优化。我们还详细介绍了Graal图。这是非常关键的知识，将帮助你分析并识别在开发过程中可以应用以加快运行时Graal
    JIT编译的优化。
- en: In this chapter, you have gained a detailed understanding of the internal workings
    of Graal JIT compilation, and how to fine-tune Graal JIT. You also have gained
    a good understanding of how to use some of the advanced analysis and diagnosis
    tools to debug Graal JIT compilation, and identify opportunities to optimize the
    code.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经详细了解了Graal JIT编译的内部工作原理以及如何微调Graal JIT。你还对如何使用一些高级分析和诊断工具来调试Graal JIT编译以及识别优化代码的机会有了很好的理解。
- en: In the next chapter, we will take a more detailed look at Graal Ahead of Time
    compilation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地探讨Graal的即时编译。
- en: Questions
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the various tiers of Graal JIT compilation?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Graal JIT编译的各个层级是什么？
- en: What is an intermediate representation?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是中间表示？
- en: What is SSA?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSA是什么？
- en: What is speculative optimization?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是投机优化？
- en: What is the difference between escape analysis and partial escape analysis?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逃逸分析与部分逃逸分析有什么区别？
- en: Further reading
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Partial Escape Analysis and Scalar Replacement for Java ([https://ssw.jku.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf](https://ssw.jku.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf))
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的局部逃逸分析和标量替换([https://ssw.jku.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf](https://ssw.jku.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf))
- en: Understanding Basic Graal Graphs ([https://chrisseaton.com/truffleruby/basic-graal-graphs/](https://chrisseaton.com/truffleruby/basic-graal-graphs/))
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基本 Graal 图 ([https://chrisseaton.com/truffleruby/basic-graal-graphs/](https://chrisseaton.com/truffleruby/basic-graal-graphs/))
- en: Optimizing Strategies of GraalVM ([https://www.beyondjava.net/graalvm-plugin-replacement-to-jvm](https://www.beyondjava.net/graalvm-plugin-replacement-to-jvm))
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 优化策略 ([https://www.beyondjava.net/graalvm-plugin-replacement-to-jvm](https://www.beyondjava.net/graalvm-plugin-replacement-to-jvm))
- en: GraalVM Enterprise Edition (EE) ([https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html))
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 企业版 (EE) ([https://docs.oracle.com/en/graalvm/enterprise/19/index.html](https://docs.oracle.com/en/graalvm/enterprise/19/index.html))
- en: GraalVM documentation ([https://www.graalvm.org/docs/introduction/](https://www.graalvm.org/docs/introduction/))
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM 文档 ([https://www.graalvm.org/docs/introduction/](https://www.graalvm.org/docs/introduction/))
- en: Static Single Assignment ([https://gcc.gnu.org/onlinedocs/gccint/SSA.html](https://gcc.gnu.org/onlinedocs/gccint/SSA.html))
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态单赋值 ([https://gcc.gnu.org/onlinedocs/gccint/SSA.html](https://gcc.gnu.org/onlinedocs/gccint/SSA.html))
