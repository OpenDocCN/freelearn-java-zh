- en: Scripting Using Oracle Nashorn
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Oracle Nashorn 进行脚本编写
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Using the jjs command-line tool
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 jjs 命令行工具
- en: Embedding the Oracle Nashorn engine
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入 Oracle Nashorn 引擎
- en: Invoking Java from Oracle Nashorn
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Oracle Nashorn 调用 Java
- en: Using the ES6 features implemented in Oracle Nashorn
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Oracle Nashorn 实现的 ECMAScript 6 功能
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Oracle Nashorn is the JavaScript engine developed for the Java platform. This
    was introduced in Java 8\. Prior to Nashorn, the JavaScript engine for the Java
    platform was based on the Mozilla Rhino JavaScript engine. The Oracle Nashorn
    engine leverages the `invokedynamic` support introduced in Java 8 for better runtime
    performance, and also provides better compliance with the ECMAScript specification.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Nashorn 是为 Java 平台开发的 JavaScript 引擎。这是在 Java 8 中引入的。在 Nashorn 之前，Java
    平台的 JavaScript 引擎基于 Mozilla Rhino JavaScript 引擎。Oracle Nashorn 引擎利用 Java 8 中引入的
    `invokedynamic` 支持以获得更好的运行时性能，并且也提供了对 ECMAScript 规范的更好遵守。
- en: Oracle Nashorn supports JavaScript code execution in a standalone mode using
    the `jjs` tool, as well as embedded in Java using its embedded scripting engine.
    In this chapter, we will look at executing the JavaScript code from Java and invoking
    the JavaScript function from Java, and vice versa, including accessing Java types
    from JavaScript. We will also look at using the command-line tool, `jjs`, for
    executing the JavaScript code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle Nashorn 支持使用 `jjs` 工具以独立模式执行 JavaScript 代码，以及使用其嵌入的脚本引擎在 Java 中嵌入。在本章中，我们将探讨从
    Java 执行 JavaScript 代码以及从 Java 调用 JavaScript 函数，反之亦然，包括从 JavaScript 访问 Java 类型。我们还将探讨使用命令行工具
    `jjs` 执行 JavaScript 代码。
- en: Throughout the rest of the chapter, we will use the term ES6 to refer to ECMAScript
    6.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将使用术语 ES6 来指代 ECMAScript 6。
- en: Using the jjs command-line tool
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jjs 命令行工具
- en: The `jjs` command-line tool supports the execution of JavaScript code files
    as well as an interactive execution of JavaScript code snippets, as supported
    by other JavaScript shells, such as `node.js`. It uses Oracle Nashorn, a next
    generation JavaScript engine for JVM to provide this support. In addition to the
    JavaScript code, `jjs` supports the execution of shell commands, thereby allowing
    us to create shell script utilities in JavaScript.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`jjs` 命令行工具支持执行 JavaScript 代码文件以及交互式执行 JavaScript 代码片段，如其他 JavaScript shell（如
    `node.js`）所支持的那样。它使用 Oracle Nashorn，这是一个为 JVM 提供支持的下一代 JavaScript 引擎。除了 JavaScript
    代码外，`jjs` 还支持执行 shell 命令，从而允许我们使用 JavaScript 创建 shell 脚本实用程序。'
- en: In this recipe, we will look at executing JavaScript code files via `jjs`, as
    well as the interactive execution of code snippets.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨通过 `jjs` 执行 JavaScript 代码文件，以及代码片段的交互式执行。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, verify whether the `jjs` tool is available by issuing the command, `jjs
    -version`. This will print the version as `nashorn 9-ea` and enter it into the
    shell, as shown in the following image:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过执行命令 `jjs -version` 验证 `jjs` 工具是否可用。这将打印版本为 `nashorn 9-ea` 并将其输入到 shell
    中，如下面的图像所示：
- en: '![](img/357afdd6-cf90-45b6-80e2-ff4762151532.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/357afdd6-cf90-45b6-80e2-ff4762151532.png)'
- en: We can even get more specific version information using `jjs -fv`, which prints
    the version as `nashorn full version 9-ea+169`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用 `jjs -fv` 获取更具体的版本信息，它打印的版本为 `nashorn full version 9-ea+169`。
- en: The JavaScript code files used in this recipe are available at the location, `chp14/1_jjs_demo`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中使用的 JavaScript 代码文件位于位置 `chp14/1_jjs_demo`。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s use `jjs` to execute the script, `$ jjs hellojjs.js`, which gives this
    output: `Hello via JJS using Nashorn`.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 `jjs` 执行脚本，`$ jjs hellojjs.js`，它给出以下输出：`Hello via JJS using Nashorn`。
- en: 'Let''s now try this with ECMAScript 6 features of using `Set`, `Map`, and template
    strings. A template string supports building a `String` with placeholders for
    dynamic values. A placeholder is identified by `${variable}` and the complete
    `String` is embedded within [PRE0]. We run this script using the `jjs --language=es6
    using_map_set_demo.js` command. By default, `jjs` runs in `es5` mode and we enable
    it to run in `es6` by giving this option, as shown in the following screenshot:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们尝试使用 ECMAScript 6 的 `Set`、`Map` 和模板字符串功能。模板字符串支持使用占位符构建 `String`，占位符由 `${variable}`
    标识，完整的 `String` 被嵌入在 [PRE0] 中。我们使用 `jjs --language=es6 using_map_set_demo.js`
    命令运行此脚本。默认情况下，`jjs` 以 `es5` 模式运行，我们通过提供此选项来启用它以在 `es6` 模式下运行，如下面的截图所示：
- en: '![](img/dcf1cc89-2120-4397-92c6-ceceb2f9594a.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcf1cc89-2120-4397-92c6-ceceb2f9594a.png)'
- en: 'Now, let''s use the `jjs` tool interactively. Run `$ jjs --language=es6` on
    the Command Prompt to launch the shell and execute a few JavaScript code snippets,
    as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们交互式地使用 `jjs` 工具。在命令提示符中运行 `$ jjs --language=es6` 以启动外壳并执行一些 JavaScript
    代码片段，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following will be printed on the screen:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上将会打印以下内容：
- en: '![](img/45733591-96d6-4e2a-b43e-e339ed909291.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/45733591-96d6-4e2a-b43e-e339ed909291.png)'
- en: There's more...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The shell scripting mode can be enabled in `jjs` using the `-scripting` command.
    So, one can embed Shell/Batch commands within the JavaScript code, as shown here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `-scripting` 命令在 `jjs` 中启用 shell 脚本模式。因此，可以在 JavaScript 代码中嵌入 Shell/Batch
    命令，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you are using ES5 as the language for `jjs`, then you can replace `$EXEC("dir")`
    with `` `dir` ``. But in ES6, [PRE3] are used for representing template strings.
    The preceding script can be executed using `jjs`, as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 ES5 作为 `jjs` 的语言，则可以将 `$EXEC("dir")` 替换为 `` `dir` ``。但在 ES6 中，使用 ``[PRE3]``
    来表示模板字符串。前面的脚本可以使用 `jjs` 执行，如下所示：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are two more variables available, `$ARG` and `$ENV`, which can be used
    to access the arguments passed to the script and the environment variables, respectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个可用的变量，分别是 `$ARG` 和 `$ENV`，可以用来访问传递给脚本的参数和相应的环境变量。
- en: Embedding the Oracle Nashorn engine
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入 Oracle Nashorn 引擎
- en: In this recipe, we will look at embedding the Nashorn JavaScript engine in the
    Java code and execute different JavaScript code snippets, functions, and JavaScript
    source files.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看在 Java 代码中嵌入 Nashorn JavaScript 引擎并执行不同的 JavaScript 代码片段、函数和 JavaScript
    源文件。
- en: Getting ready
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have JDK 9 installed, as we will be using a few ES6 JavaScript language
    features with the Nashorn engine.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了 JDK 9，因为我们将在 Nashorn 引擎中使用一些 ES6 JavaScript 语言特性。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we get an instance of `ScriptEngine` with the ES6 language features
    enabled:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们获取一个启用 ES6 语言特性的 `ScriptEngine` 实例：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s define a JavaScript function to find the sum of two numbers:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个 JavaScript 函数来计算两个数字的和：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s invoke the function defined in the previous step:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们调用上一步定义的函数：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we will look at the template string support:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将查看模板字符串支持：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will use the new `Set` construct in ES6 and the new `for` loop to print
    the `Set` elements:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 ES6 中的新 `Set` 构造和新的 `for` 循环来打印 `Set` 元素：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we will look at loading the JavaScript source file and executing the
    methods defined in it:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将查看如何加载 JavaScript 源文件并执行其中定义的方法：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The complete code for this can be found at the location, `chp14/2_embedded_nashorn`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的完整内容可以在以下位置找到，`chp14/2_embedded_nashorn`。
- en: 'The output after executing the sample will be as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 执行示例后的输出将如下所示：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Invoking Java from Oracle Nashorn
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Oracle Nashorn 调用 Java
- en: In this recipe, we will look at calling Java APIs from the JavaScript code,
    including using the Java types, and dealing with package and class imports. There
    is a greater potential in combining the vastness of the Java API and the dynamic
    nature of JavaScript leveraged by the Oracle Nashorn JavaScript engine. We will
    look at creating a purely JavaScript code, which uses the Java APIs, and we'll
    use the `jjs` tool to execute this.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看从 JavaScript 代码中调用 Java API，包括使用 Java 类型，以及处理包和类导入。结合 Java API 的广泛性和
    Oracle Nashorn JavaScript 引擎利用的 JavaScript 的动态性具有更大的潜力。我们将查看创建一个纯 JavaScript 代码，该代码使用
    Java API，并使用 `jjs` 工具来执行它。
- en: We will also look at creating a Swing-based application purely in JavaScript.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看纯 JavaScript 创建基于 Swing 的应用程序。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create a `List` of numbers using the `Arrays.asList` API:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 `Arrays.asList` API 创建一个数字 `List`：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, compute the maximum number in the list:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，计算列表中的最大数：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can print `max` using the JavaScript `print()` method, and we can use template
    strings:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 JavaScript 的 `print()` 方法打印 `max`，并且可以使用模板字符串：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s run the script created using `jjs`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行使用 `jjs` 创建的脚本：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s import the `java.util` package:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们导入 `java.util` 包：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s use the imported package to print today''s date:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用导入的包来打印今天的日期：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s create an alias for a Java type using the `Java.type` API:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Java.type` API 为 Java 类型创建一个别名：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the alias to create a set, add a few elements, and print it:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用别名创建一个集合，添加一些元素，并打印它：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We get the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code for this script file can be found at the location, `chp14/3_java_from_nashorn/java_from_javascript.js`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本文件的代码可以在以下位置找到，`chp14/3_java_from_nashorn/java_from_javascript.js`。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Java types and their APIs can be accessed from the JavaScript code by using
    their fully qualified name, as we saw in the previous section while creating the
    list of numbers using `java.util.Arrays.asList()` and finding the maximum using
    `java.util.Collections.max()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用它们的完全限定名从 JavaScript 代码中访问 Java 类型及其 API，就像我们在上一节中创建数字列表时使用 `java.util.Arrays.asList()`
    和使用 `java.util.Collections.max()` 查找最大值时所看到的那样。
- en: 'If we want to skip specifying the package name along with the class name, we
    can make use of `JavaImporter` to import the packages and use the `with` clause
    to wrap the code, which uses the classes from the imported package within it,
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想省略包名和类名一起指定，我们可以使用 `JavaImporter` 来导入包，并使用 `with` 子句来包装代码，这样就可以在内部使用导入包中的类，如下所示：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The other feature we saw was creating a type alias for the Java type by using
    `Java.type(<fully qualified class name>)`, as done in the example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的另一个特性是通过使用 `Java.type(<fully qualified class name>)` 为 Java 类型创建类型别名，就像在以下示例中所做的那样：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The type has to be an implementation class if you are creating objects using
    the alias:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用别名创建对象，类型必须是实现类：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's more...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's create a script to create a simple Swing GUI with a button and an event
    handler for the button. We will also look at how we leverage imports and implement
    interfaces using an anonymous inner class approach.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个脚本，创建一个简单的 Swing GUI，包含一个按钮和一个按钮的事件处理器。我们还将探讨如何利用导入和通过匿名内部类方法实现接口。
- en: 'First, we''ll create a new `JavaImporter` object with the required Java packages:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的 `JavaImporter` 对象，包含所需的 Java 包：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We use the `with(obj){}` clause to wrap all the statements using the required
    imports:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `with(obj){}` 子句来包装所有使用所需导入的语句：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we create `JButton` and provide `ActionListener` to listen to its click
    events:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建 `JButton` 并提供 `ActionListener` 来监听其点击事件：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we create `JFrame` to render the GUI with its components:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建 `JFrame` 来渲染包含其组件的 GUI：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The complete code for this can be found in `chp14/3_java_from_nashorn/gui_from_javascript.js`.Let''s
    run the script using `jjs`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整的代码可以在 `chp14/3_java_from_nashorn/gui_from_javascript.js` 中找到。让我们使用 `jjs`
    运行这个脚本：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can see a small GUI, as shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个小型 GUI，如下面的截图所示：
- en: '![](img/283e7780-2ed0-4ea4-9f9b-d1423184e371.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/283e7780-2ed0-4ea4-9f9b-d1423184e371.png)'
- en: To exit the program, we will have to use *Ctrl* + *C* to stop the process because
    `setDefaultCloseOperation` works when running in Java. The other option is to
    override the JFrame's `close` operation to exit from the program.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出程序，我们必须使用 *Ctrl* + *C* 来停止进程，因为 `setDefaultCloseOperation` 在 Java 运行时才会生效。另一个选项是覆盖
    JFrame 的 `close` 操作来退出程序。
- en: Using the ES6 features implemented in Oracle Nashorn
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Oracle Nashorn 实现的 ES6 特性
- en: In this recipe, we will look at some of the ES6 features implemented in the
    Oracle Nashorn JavaScript engine. For this, we will create a JavaScript file and
    use `jjs` to execute the same. Remember to use `jjs` in the ES6 mode, which can
    be enabled by passing the `--language=es6` command-line option.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨一些在 Oracle Nashorn JavaScript 引擎中实现的 ES6 特性。为此，我们将创建一个 JavaScript
    文件并使用 `jjs` 来执行它。请记住使用 `jjs` 在 ES6 模式下，可以通过传递 `--language=es6` 命令行选项来启用。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Template strings are strings with variable placeholders, thereby allowing the
    creation of dynamic texts. The strings have to be embedded within the symbols
    [PRE29]:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板字符串是带有变量占位符的字符串，从而允许创建动态文本。这些字符串必须嵌入在符号 [PRE29] 内：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Any variable in JavaScript has a global scope. ES6 introduced the block scope,
    which can be declared using the `let` keyword. Constants can now be defined using
    the `const` keyword, as shown in the following code snippet:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript 中的任何变量都具有全局作用域。ES6 引入了块作用域，可以使用 `let` 关键字声明。现在可以使用 `const` 关键字定义常量，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s look at the new iteration construct, `for ... of`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看新的迭代构造 `for ... of`：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s look at creating sets and maps using the new `Set` and `Map` classes:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何使用新的 `Set` 和 `Map` 类来创建集合和映射：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s look at arrow functions. These are similar to the lambda expression
    concept that we have from Java 8 onward. Arrow functions are of the form, `(parameters
    ) => {function body }`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看箭头函数。这些与从 Java 8 开始的 lambda 表达式概念类似。箭头函数的形式为 `(parameters) => {function
    body}`：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The complete code for this can be found in the file, `chp14/4_es6_features/es6_features.js`.
    The output after executing the complete script using the `jjs --language=es6 es6_features.js` command
    is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的完整版本可以在文件中找到，`chp14/4_es6_features/es6_features.js`。使用`jjs --language=es6
    es6_features.js`命令执行完整脚本后的输出如下：
- en: '![](img/637b5b67-8cbe-4371-9dbe-e91ae0009c5a.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/637b5b67-8cbe-4371-9dbe-e91ae0009c5a.png)'
