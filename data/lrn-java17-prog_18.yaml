- en: '*Chapter 15*: Reactive Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：反应式编程'
- en: In this chapter, you will be introduced to the **Reactive Manifesto** and the
    world of reactive programming. We start with defining and discussing the main
    concepts of reactive programming – asynchronous, non-blocking, and responsive.
    Using them, we then define and discuss reactive programming, the main reactive
    frameworks, and talk about **RxJava** in more detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解**反应式宣言**和反应式编程的世界。我们首先定义并讨论反应式编程的主要概念——异步、非阻塞和响应性。使用这些概念，我们接下来定义并讨论反应式编程、主要反应式框架，并更详细地讨论**RxJava**。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Asynchronous processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理
- en: Non-blocking APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非阻塞API
- en: Reactive – responsive, resilient, elastic, and message-driven systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式——响应性、弹性、可恢复性和消息驱动系统
- en: Reactive streams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式流
- en: RxJava
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJava
- en: By the end of the chapter, you will be able to write code for asynchronous processing
    using reactive programming.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用反应式编程编写异步处理的代码。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples that are provided in this chapter,
    you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够执行本章提供的代码示例，您需要以下条件：
- en: 'A computer with an operating system: Microsoft Windows, Apple macOS, or Linux'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备操作系统的计算机：Microsoft Windows、Apple macOS 或 Linux
- en: Java SE version 17 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE版本17或更高
- en: Any IDE or code editor you prefer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您喜欢的任何IDE或代码编辑器
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*, of this book. The files and the code examples for this chapter are available
    from the GitHub repository at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git).
    You can locate them in the [examples/src/main/java/com/packt/learnjava/ch15_reactive](https://examples/src/main/java/com/packt/learnjava/ch15_reactive)
    folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书[*第1章*](B18388_01_ePub.xhtml#_idTextAnchor015)“Java 17入门”中提供了如何设置Java SE和IntelliJ
    IDEA编辑器的说明。本章的文件和代码示例可以从GitHub仓库[https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)获取。您可以在[examples/src/main/java/com/packt/learnjava/ch15_reactive](https://examples/src/main/java/com/packt/learnjava/ch15_reactive)文件夹中找到它们。
- en: Asynchronous processing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步处理
- en: '**Asynchronous** means that the requestor gets the response immediately, but
    the result is not there. Instead, the requestor waits until the result is sent
    to them, saved in the database, or, for example, presented as an object that allows
    you to check whether the result is ready. If the latter is the case, the requestor
    calls a certain method to this object periodically and, when the result is ready,
    retrieves it using another method on the same object. The advantage of asynchronous
    processing is that the requestor can do other things while waiting.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步**意味着请求者立即获得响应，但结果尚未出现。相反，请求者等待结果发送给他们、保存到数据库中，或者例如以允许您检查结果是否准备好的对象形式呈现。如果后者是情况，请求者将定期调用该对象上的某个方法，当结果准备好时，使用该对象上的另一个方法检索它。异步处理的优势在于请求者可以在等待时做其他事情。'
- en: In [*Chapter 8*](B18388_08_ePub.xhtml#_idTextAnchor187), *Multithreading and
    Concurrent Processing*, we demonstrated how a child thread can be created. Such
    a child thread then sends a non-asynchronous (blocking) request and waits for
    its return doing nothing. Meanwhile, the main thread continues executing and periodically
    calls the child thread object to see whether the result is ready. That is the
    most basic of asynchronous processing implementations. In fact, we already used
    it when we used parallel streams.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18388_08_ePub.xhtml#_idTextAnchor187)“多线程与并发处理”中，我们展示了如何创建一个子线程。然后，这个子线程发送一个非异步（阻塞）请求并等待其返回，什么都不做。同时，主线程继续执行并定期调用子线程对象以查看结果是否已准备好。这是异步处理实现中最基本的。实际上，我们在使用并行流时已经使用了它。
- en: The parallel stream operations that work behind the scenes to create the child
    threads break the stream into segments, assign each segment to a dedicated thread
    for processing, and then aggregate the partial results from all the segments into
    the final result. In the previous chapter, we even wrote functions that did the
    aggregating job. As a reminder, the function was called **combiner**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后创建子线程的并行流操作将流拆分为段，将每个段分配给一个专用线程进行处理，然后将所有段的局部结果汇总为最终结果。在前一章中，我们甚至编写了执行汇总工作的函数。作为提醒，该函数被命名为**combiner**。
- en: Let’s compare the performance of sequential and parallel streams using an example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例比较顺序流和并行流的性能。
- en: Sequential and parallel streams
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序流和并行流
- en: 'To demonstrate the difference between sequential and parallel processing, let’s
    imagine a system that collects data from 10 physical devices (such as sensors)
    and calculates an average. The following is the `get()` method, which collects
    a measurement from a sensor identified by its ID:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示顺序处理和并行处理之间的差异，让我们想象一个从10个物理设备（如传感器）收集数据并计算平均值的系统。以下是一个`get()`方法，它从由其ID标识的传感器收集测量值：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have included a delay of 100 ms to imitate the time it takes to collect the
    measurement from the sensor. As for the resulting measurement value, we use the
    `Math.random()` method. We are going to call this `get()` method using an object
    of the `MeasuringSystem` class, which is where the method belongs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了一个100毫秒的延迟来模拟从传感器收集测量值所需的时间。至于结果测量值，我们使用`Math.random()`方法。我们将使用`MeasuringSystem`类的对象调用这个`get()`方法，这是该方法所属的地方。
- en: 'Then, we are going to calculate an average to offset the errors and other idiosyncrasies
    of individual devices:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将计算平均值以抵消单个设备中的误差和其他个性特征：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how we convert the stream of IDs into `DoubleStream` using the `mapToDouble()`
    operation so that we can apply the `average()` operation. The `average()` operation
    returns an `Optional<Double>` object, and we call its `orElse(0)` method, which
    returns either the calculated value or zero (for example, if the measuring system
    could not connect to any of its sensors and returned an empty stream).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`mapToDouble()`操作将ID流转换为`DoubleStream`，以便我们可以应用`average()`操作。`average()`操作返回一个`Optional<Double>`对象，我们调用它的`orElse(0)`方法，该方法返回计算值或零（例如，如果测量系统无法连接到其任何传感器并返回一个空流）。
- en: The last line of the `getAverage()` method prints the result and the time it
    took to calculate it. In real code, we would return the result and use it for
    other calculations. However, for demonstration purposes, we will just print it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAverage()`方法的最后一行打印结果及其计算所需的时间。在实际代码中，我们会返回结果并用于其他计算。然而，出于演示目的，我们只打印它。'
- en: 'Now we can compare the performance of sequential stream processing with the
    performance of parallel processing (see the `MeasuringSystem` class and the `compareSequentialAndParallelProcessing()`
    method):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以比较顺序流处理与并行处理的性能（请参阅`MeasuringSystem`类和`compareSequentialAndParallelProcessing()`方法）：
- en: '[PRE18]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The results might be different if you run this example because, as you might
    recall, we simulate the collected measurements as random values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此示例，结果可能会有所不同，因为如您所记得的，我们模拟收集的测量值为随机值。
- en: As you can see, the processing of a parallel stream is five times faster than
    the processing of a sequential stream. The results are different because the measurement
    produces a slightly different result each time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，并行流的处理速度比顺序流快五倍。结果不同，因为测量每次产生略微不同的结果。
- en: Although the parallel stream uses asynchronous processing behind the scenes,
    this is not what programmers have in mind when talking about the asynchronous
    processing of requests. From the application’s perspective, it is just parallel
    (also called concurrent) processing. It is faster than sequential processing,
    but the main thread has to wait until all the calls are made and the data has
    been retrieved. If each call takes at least 100 ms (as it is in our case), then
    the processing of all the calls cannot be completed in less time, even when each
    call is made by a dedicated thread.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并行流在幕后使用异步处理，但这并不是程序员在谈论请求的异步处理时所考虑的内容。从应用程序的角度来看，它只是并行处理（也称为并发处理）。它比顺序处理更快，但主线程必须等待所有调用完成并且数据被检索。如果每个调用至少需要100毫秒（正如我们的情况），那么即使每个调用都由专用线程执行，所有调用的处理也无法在更短的时间内完成。
- en: Of course, we can create a service that uses a child thread to make all the
    calls, while the main thread does something else. Later, the main thread can call
    the service again and get the result or pick it up from a previously agreed location.
    That truly would be the asynchronous processing programmers are talking about.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以创建一个服务，使用子线程来执行所有调用，而主线程做其他事情。稍后，主线程可以再次调用该服务并获取结果或从之前约定的位置获取。这正是程序员所讨论的异步处理。
- en: But before writing such code, let’s look at the `CompletableFuture` class located
    in the `java.util.concurrent` package. It does everything described and more.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但在编写这样的代码之前，让我们看看位于`java.util.concurrent`包中的`CompletableFuture`类。它做了所有描述的事情，还有更多。
- en: Using the CompletableFuture object
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`CompletableFuture`对象
- en: 'Using the `CompletableFuture` object, we can separate sending the request to
    the measuring system from getting the result from the `CompletableFuture` object.
    That is exactly the scenario we described while explaining what asynchronous processing
    was. Let’s demonstrate it in the code (see the `MeasuringSystem` class and the
    `completableFuture()` method):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CompletableFuture`对象，我们可以将向测量系统发送请求与从`CompletableFuture`对象获取结果分开。这正是我们在解释异步处理时描述的场景。让我们在代码中演示它（参见`MeasuringSystem`类和`completableFuture()`方法）：
- en: '[PRE23]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `supplyAsync()` method does not wait for the call to the measuring system
    to return. Instead, it immediately creates a `CompletableFuture` object and returns
    it. This is so that a client can use this object any time later on to retrieve
    the result returned by the measuring system. The following code takes the list
    of `CompletableFuture` objects and iterates over it, retrieving the result from
    each object and calculating the average value:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`supplyAsync()`方法不会等待调用测量系统的返回。相反，它立即创建一个`CompletableFuture`对象并返回它。这样，客户端可以在稍后任何时候使用此对象来检索测量系统返回的结果。以下代码获取`CompletableFuture`对象列表，遍历它，从每个对象中检索结果并计算平均值：'
- en: '[PRE26]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Additionally, some methods allow you to check whether the value was returned
    at all, but that is not the point of this demonstration, which is to show how
    the `CompletableFuture` class can be used to organize asynchronous processing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些方法允许你检查值是否被返回，但这不是本演示的重点，重点是展示如何使用`CompletableFuture`类来组织异步处理。
- en: The created list of `CompletableFuture` objects can be stored anywhere and processed
    very quickly (in our case, in 6 ms), provided that the measurements have been
    received already (all the `get()` methods were invoked and returned values). After
    creating the list of `CompletableFuture` objects and before processing it, the
    system is not blocked and can do something else. That is the advantage of asynchronous
    processing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`CompletableFuture`对象列表可以存储在任何地方，并且可以非常快速地处理（在我们的案例中，6毫秒），前提是已经收到了测量值（所有`get()`方法都被调用并返回了值）。在创建`CompletableFuture`对象列表并在处理之前，系统不会被阻塞，可以执行其他操作。这正是异步处理的优势。
- en: 'The `CompletableFuture` class has many methods and is supported by several
    other classes and interfaces. For example, a fixed-size thread pool can be added
    to limit the number of threads (see the `MeasuringSystem` class and the `threadPool()`
    method):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletableFuture`类有许多方法，并支持几个其他类和接口。例如，可以添加一个固定大小的线程池来限制线程数量（参见`MeasuringSystem`类和`threadPool()`方法）：'
- en: '[PRE34]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There is a variety of such pools for different purposes and different performances.
    But using a pool does not change the overall system design, so we omit such a
    detail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种这样的池，用于不同的目的和不同的性能。但使用池不会改变整体系统设计，所以我们省略了这个细节。
- en: As you can see, the power of asynchronous processing is great. There is also
    a variation of the asynchronous API called a **non-blocking API**. We are going
    to discuss this in the next section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，异步处理的力量是巨大的。还有一个异步API的变体，称为**非阻塞API**。我们将在下一节中讨论这个问题。
- en: Non-blocking APIs
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞API
- en: The client of a non-blocking API gets the results without being blocked for
    a significant amount of time, thus allowing the client to do something else during
    the period when the results are being prepared. So, the notion of a non-blocking
    API implies a highly responsive application. The processing of the request (that
    is, getting the results) can be done synchronously or asynchronously – it does
    not matter to the client. In practice, though, typically, the application uses
    asynchronous processing to facilitate an increased throughput and improved performance
    of the API.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞API的客户端可以在不阻塞很长时间的情况下获取结果，从而允许客户端在结果准备期间做其他事情。因此，非阻塞API的概念意味着一个高度响应的应用程序。请求的处理（即获取结果）可以是同步的或异步的——对客户端来说无关紧要。然而，在实践中，通常应用程序使用异步处理来提高API的吞吐量和性能。
- en: 'The term `java.nio` package. The **non-blocking input/output** (**NIO**) provides
    support for intensive **input/output** (**I/O**) operations. It describes how
    the application is implemented: it does not dedicate an execution thread to each
    of the requests but provides several lightweight worker threads that do the processing
    asynchronously and concurrently.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio`包术语。**非阻塞输入/输出**（**NIO**）为密集的**输入/输出**（**I/O**）操作提供支持。它描述了应用程序的实现方式：它不为每个请求分配一个执行线程，而是提供几个轻量级的工作线程，它们异步和并发地执行处理。'
- en: The java.io package versus the java.nio package
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java.io包与Java.nio包
- en: Writing and reading data to and from external memory (for example, a hard drive)
    is a much slower operation than processing in memory only. Initially, the already-existing
    classes and interfaces of the `java.io` package worked well, but once in a while,
    they would create a performance bottleneck. The new `java.nio` package was created
    to provide more effective I/O support.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据写入和读取到外部内存（例如，硬盘）的操作比仅内存处理慢得多。最初，`java.io`包中已经存在的类和接口运行良好，但偶尔会创建性能瓶颈。新的`java.nio`包被创建以提供更有效的I/O支持。
- en: The `java.io` implementation is based on I/O stream processing. As we saw in
    the previous section, essentially, this is a blocking operation even if some kind
    of concurrency is happening behind the scenes. To increase speeds, the `java.nio`
    implementation was introduced based on the reading/writing to/from a buffer in
    the memory. Such a design allowed it to separate the slow process of filling/emptying
    the buffer and quickly reading/writing from/to it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.io`实现基于I/O流处理。正如我们在上一节所看到的，本质上，即使幕后发生某种并发，这仍然是一个阻塞操作。为了提高速度，引入了基于内存中缓冲区读写操作的`java.nio`实现。这种设计允许它将填充/清空缓冲区的缓慢过程与快速读写操作分开。'
- en: In a way, it is similar to what we have done in our example of `CompletableFuture`
    usage. The additional advantage of having data in a buffer is that it is possible
    to inspect the data, going there and back along with the buffer, which is impossible
    while reading sequentially from the stream. It has provided more flexibility during
    data processing. In addition, the `java.nio` implementation introduced another
    middleman process called a **channel** for bulk data transfers to and from a buffer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，这与我们在`CompletableFuture`使用示例中所做的是相似的。拥有缓冲区中数据的额外优势是，可以检查数据，在缓冲区中来回移动，这在从流中顺序读取时是不可能的。它在数据处理期间提供了更多的灵活性。此外，`java.nio`实现引入了另一个中间过程，称为**通道**，用于大量数据在缓冲区之间传输。
- en: The reading thread is getting data from a channel and only receives what is
    currently available or nothing at all (if no data is in the channel). If data
    is not available, the thread, instead of remaining blocked, can do something else–for
    example, reading/writing to/from other channels in the same way the main thread
    in our `CompletableFuture` example was free to do whatever had to be done while
    the measuring system was getting data from its sensors.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 读取线程从通道获取数据，并且只接收当前可用的数据或什么也不接收（如果没有数据在通道中）。如果数据不可用，线程不会保持阻塞，而是可以执行其他操作——例如，以与我们的`CompletableFuture`示例中的主线程相同的方式读取/写入其他通道。
- en: This way, instead of dedicating a thread to one I/O process, a few worker threads
    can serve many I/O processes. Such a solution was eventually called NIO and was
    later applied to other processes, the most prominent being the *event processing
    in an event loop*, which is also called a **run loop**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，不再为每个I/O过程分配一个线程，而是几个工作线程可以服务许多I/O过程。这种解决方案最终被称为NIO，后来应用于其他过程，最突出的是在事件循环中的**事件处理**，这也可以称为**运行循环**。
- en: The event/run loop
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件/运行循环
- en: Many non-blocking systems are based on the **event** (or **run**) loop – a thread
    that is continually executed. It receives events (requests and messages) and then
    dispatches them to the corresponding event handlers (workers). There is nothing
    special about event handlers. They are just methods (functions) dedicated by the
    programmer for the processing of the particular event type.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多非阻塞系统基于**事件**（或**运行**）循环——一个持续执行的线程。它接收事件（请求和消息），然后将它们分发给相应的事件处理器（工作者）。事件处理器并没有什么特别之处。它们只是程序员为处理特定事件类型而指定的方法（函数）。
- en: Such a design is called a **reactor design pattern**. It is constructed around
    processing events and service requests concurrently. Also, it gives the name to
    the **reactive programming** and **reactive systems** that *react* to events and
    process them concurrently.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计被称为**反应器设计模式**。它是围绕处理事件和服务请求并发构建的。此外，它还为**响应式编程**和**响应式系统**命名，这些系统对事件做出反应并并发处理它们。
- en: Event loop-based design is widely used in operating systems and graphical user
    interfaces. It has been available in Spring WebFlux since Spring 5 and can be
    implemented in JavaScript and the popular executing environment, Node.js. The
    latter uses an event loop as its processing backbone. The toolkit, Vert.x, is
    built around the event loop, too.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件循环的设计在操作系统和图形用户界面中得到了广泛应用。自Spring 5以来，Spring WebFlux就提供了这种功能，并且可以在JavaScript和流行的执行环境Node.js中实现。后者使用事件循环作为其处理的核心。工具包Vert.x也是围绕事件循环构建的。
- en: Before the adoption of an event loop, a dedicated thread was assigned to each
    incoming request – much like in our demonstration of stream processing. Each of
    the threads required the allocation of a certain amount of resources that were
    not request-specific, so some of the resources – mostly memory allocation – were
    wasted. Then, as the number of requests grew, the CPU needed to switch its context
    from one thread to another more frequently to allow more or less concurrent processing
    of all the requests. Under the load, the overhead of switching the context is
    substantial enough to affect the performance of an application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用事件循环之前，每个传入的请求都会分配一个专用线程——就像我们在流处理演示中所做的那样。每个线程都需要分配一定数量的资源，这些资源不是针对请求的，因此一些资源——主要是内存分配——被浪费了。然后，随着请求数量的增加，CPU需要更频繁地在线程之间切换上下文，以便更或更少地并发处理所有请求。在负载下，切换上下文的开销足够大，足以影响应用程序的性能。
- en: Implementing an event loop has addressed these two issues. It has eliminated
    the waste of resources by avoiding the creation of a thread for each request and
    removed the overhead of switching the context. With an event loop in place, a
    much smaller memory allocation is needed for each request to capture its specifics,
    which makes it possible to keep many more requests in memory so that they can
    be processed concurrently. The overhead of the CPU context-switching has become
    far smaller too because of the diminishing context size.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实现事件循环解决了这两个问题。它通过避免为每个请求创建线程来消除资源浪费，并移除了切换上下文的开销。有了事件循环，每个请求捕获其具体信息所需的内存分配会更小，这使得能够将更多的请求保留在内存中，以便它们可以并发处理。由于上下文大小的减小，CPU上下文切换的开销也变得非常小。
- en: The non-blocking API is a way of processing requests so that systems are able
    to handle a much bigger load while remaining highly responsive and resilient.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞API是一种处理请求的方式，使得系统能够在保持高度响应性和弹性的同时处理更大的负载。
- en: Reactive
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式
- en: Usually, the term `java.util.concurrent` package. It allows a `Publisher` to
    generate a stream of data to which a `Subscriber` can asynchronously subscribe.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，术语`java.util.concurrent`包。它允许一个`Publisher`生成一个数据流，`Subscriber`可以异步订阅。
- en: One principal difference between reactive streams and standard streams (which
    are also called `java.util.stream` package) is that a source (publisher) of the
    reactive stream pushes elements to subscribers at its own rate, while in standard
    streams, a new element is pulled and emitted only after the previous one has been
    processed (in fact, it acts like a `for` loop).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式流与标准流（也称为`java.util.stream`包）的一个主要区别在于，反应式流中的源（发布者）会以自己的速率将元素推送给订阅者，而在标准流中，只有在处理完前一个元素之后，才会拉取并发射新的元素（实际上，它就像一个`for`循环）。
- en: 'As you have seen, we were able to process data asynchronously even without
    this new API by using `CompletableFuture`. But after writing such code a few times,
    you might notice that most of the code is just plumbing, so you get the feeling
    that there has to be an even simpler and more convenient solution. That’s how
    the reactive streams initiative ([http://www.reactive-streams.org](http://www.reactive-streams.org))
    was born. The scope of the effort was defined as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们甚至没有使用这个新API，也能通过使用`CompletableFuture`来异步处理数据。但写了几次这样的代码后，你可能会注意到大部分代码只是管道，所以你会觉得肯定有一个更简单、更方便的解决方案。这就是反应式流倡议（[http://www.reactive-streams.org](http://www.reactive-streams.org)）产生的原因。该努力的范畴如下定义：
- en: '*The scope of Reactive Streams is to find a minimal set of interfaces, methods,
    and protocols that will describe the necessary operations and entities to achieve
    the goal – asynchronous streams of data with non-blocking back pressure.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*反应式流的范畴是找到一组最小的接口、方法和协议，这些将描述必要的操作和实体，以实现目标——具有非阻塞背压的异步数据流。*'
- en: 'The term **non-blocking backpressure** refers to one of the problems of asynchronous
    processing: coordinating the speed rate of the incoming data with the ability
    of the system to process them without the need for stopping (blocking) the data
    input. The solution is to inform the source that the consumer has difficulty keeping
    up with the input. Also, processing should react to the change in the rate of
    the incoming data in a more flexible manner than just blocking the flow, hence
    the name *reactive*.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**非阻塞背压**指的是异步处理中存在的问题之一：协调输入数据的速度与系统处理这些数据的能力，无需停止（阻塞）数据输入。解决方案是通知源，消费者难以跟上输入。此外，处理应该比仅仅阻塞流更灵活地响应输入数据速率的变化，因此得名*反应式*。
- en: 'Several libraries already implement the reactive streams API: RxJava ([http://reactivex.io](http://reactivex.io)),
    Reactor ([https://projectreactor.io](https://projectreactor.io)), Akka Streams
    ([https://akka.io/docs](https://akka.io/docs)), and Vert.x ([https://vertx.io/](https://vertx.io/))
    are among the most well known. Writing code using RxJava or another library of
    asynchronous streams constitutes *reactive programming*. It realizes the goal
    declared in the Reactive Manifesto ([https://www.reactivemanifesto.org](https://www.reactivemanifesto.org))
    by building reactive systems that are *responsive*, *resilient*, *elastic*, and
    *message-driven*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有几个库实现了反应式流API：RxJava ([http://reactivex.io](http://reactivex.io))、Reactor
    ([https://projectreactor.io](https://projectreactor.io))、Akka Streams ([https://akka.io/docs](https://akka.io/docs))和Vert.x
    ([https://vertx.io/](https://vertx.io/))是最著名的。使用RxJava或其他异步流库编写代码构成了*反应式编程*。它通过构建*响应式*、*弹性*、*可伸缩*和*消息驱动*的系统来实现反应式宣言（[https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)）中声明的目标。
- en: Responsive
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应式
- en: This term is relatively self-explanatory. The ability to respond in a timely
    manner is one of the primary qualities of any system. There are many ways to achieve
    it. Even a traditional blocking API supported by enough servers and other infrastructure
    can achieve decent responsiveness under a growing load.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语相对容易理解。及时响应的能力是任何系统的主要品质之一。实现它的方法有很多。即使是传统阻塞API，只要服务器和其他基础设施足够强大，也能在增长负载下实现良好的响应性。
- en: Reactive programming helps to do this using less hardware. It comes at a price,
    as reactive code requires changing the way we think about control flow. But after
    some time, this new way of thinking becomes as natural as any other familiar skill.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程通过使用更少的硬件来帮助实现这一点。这需要我们改变对控制流的传统思考方式。但经过一段时间，这种新的思维方式会像其他任何熟悉的技能一样自然。
- en: In the following sections, we will see quite a few examples of reactive programming.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到许多反应式编程的示例。
- en: Resilient
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性
- en: Failures are inevitable. The hardware crashes, the software has defects, unexpected
    data is received, or an untested execution path has been taken – any of these
    events, or a combination of them, can happen at any time. *Resilience* is the
    ability of a system to continue delivering the expected results under unexpected
    circumstances.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 失败是不可避免的。硬件崩溃、软件有缺陷、收到意外数据或采取了未经测试的执行路径——任何这些事件，或它们的组合，都可能随时发生。*弹性*是指系统在意外情况下继续提供预期结果的能力。
- en: For example, it can be achieved using redundancy of the deployable components
    and hardware, using isolation of parts of the system so the domino effect becomes
    less probable, by designing the system with automatically replaceable parts, or
    by raising an alarm so that qualified personnel can interfere. Additionally, we
    have talked about distributed systems as a good example of resilient systems by
    design.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以通过部署组件和硬件的冗余、通过隔离系统的一部分以减少多米诺效应的可能性、通过设计具有自动可替换部件的系统，或者通过发出警报以便合格人员介入来实现。此外，我们已经讨论了分布式系统作为设计良好的弹性系统的好例子。
- en: A distributed architecture eliminates a single point of failure. Also, breaking
    the system into many specialized components that talk to one another using messages
    allows better tuning for the duplication of the most critical parts and creates
    more opportunities for their isolation and potential failure containment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式架构消除了单点故障。此外，将系统分解成许多相互通过消息通信的专用组件，可以更好地调整最关键部分的复制，并创造更多隔离和潜在故障控制的机会。
- en: Elastic
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性
- en: Usually, the ability to sustain the biggest possible load is associated with
    **scalability**. But the ability to preserve the same performance characteristics
    under a varying load, not just under the growing one, is called **elasticity**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，能够承受最大可能的负载的能力与**可扩展性**相关联。但能够在变化负载下保持相同的性能特征，而不仅仅是增长负载下，这种能力被称为**弹性**。
- en: The client of an elastic system should not notice any difference between the
    idle periods and the periods of peak load. A non-blocking reactive style of implementation
    facilitates this quality. Also, breaking the program into smaller parts and converting
    them into services that can be deployed and managed independently allows for the
    fine-tuning of resource allocation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性系统的客户端不应在空闲期间和高峰负载期间之间注意到任何差异。非阻塞的反应式实现风格促进了这一品质。此外，将程序分解成更小的部分并将它们转换为可以独立部署和管理的服务，允许对资源分配进行微调。
- en: Such small services are called microservices, and many of them together can
    comprise a reactive system that can be both scalable and elastic. We will talk
    about such architecture, in more detail, in the following sections and the next
    chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的小型服务被称为微服务，许多微服务组合在一起可以构成一个既可扩展又具有弹性的反应式系统。我们将在接下来的章节和下一章中更详细地讨论这种架构。
- en: Message-driven
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息驱动
- en: We have already established that component isolation and system distribution
    are two aspects that help to keep the system responsive, resilient, and elastic.
    Loose and flexible connections are important conditions that support these qualities,
    too. And the asynchronous nature of the reactive system simply does not leave
    the designer any other choice but to build communication between the components
    and the messages.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，组件隔离和系统分布是帮助保持系统响应性、弹性和弹性的两个方面。松散和灵活的连接也是支持这些品质的重要条件。反应式系统的异步特性也迫使设计者别无选择，只能构建组件之间的通信和消息。
- en: It creates breathing space around each component without which the system would
    become a tightly coupled monolith that was susceptible to all kinds of problems,
    not to mention a maintenance nightmare.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它为每个组件周围创造了呼吸空间，没有这些空间，系统将变成一个紧密耦合的单体，容易受到各种问题的困扰，更不用说维护噩梦了。
- en: In the next chapter, we are going to look at an architectural style that can
    be used to build an application as a collection of loosely coupled microservices
    that communicate using messages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一种可以用来构建应用作为松散耦合的微服务集合的架构风格，这些微服务通过消息进行通信。
- en: Reactive streams
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式流
- en: 'The reactive streams API, which was introduced in Java 9, consists of the following
    four interfaces:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中引入的反应式流 API 包含以下四个接口：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A `Flow.Subscriber` object can be passed, as a parameter, into the `subscribe()`
    method of `Flow.Publisher<T>`. Then, the publisher calls the subscriber’s `onSubscribe()`
    method and passes to it a `Flow.Subscription` object as a parameter. Now, the
    subscriber can call `request(long numberOfItems)` on the subscription object to
    request data from the publisher. That is the way the `cancel()` method on the
    subscription.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `Flow.Subscriber` 对象作为参数传递给 `Flow.Publisher<T>` 的 `subscribe()` 方法。然后，发布者调用订阅者的
    `onSubscribe()` 方法，并将一个 `Flow.Subscription` 对象作为参数传递给它。现在，订阅者可以在订阅对象上调用 `request(long
    numberOfItems)` 来请求从发布者那里获取数据。这就是订阅上的 `cancel()` 方法的工作方式。
- en: In return, the publisher can pass a new item to the subscriber by calling the
    subscriber’s `onNext()` method. When no more data will be coming (that is, all
    the data from the source was emitted) the publisher calls the subscriber’s `onComplete()`
    method. Also, by calling the subscriber’s `onError()` method, the publisher can
    tell the subscriber that it has encountered a problem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回报，发布者可以通过调用订阅者的 `onNext()` 方法将新项目传递给订阅者。当没有更多数据将到来（即，所有来自源的数据都已发出）时，发布者调用订阅者的
    `onComplete()` 方法。此外，通过调用订阅者的 `onError()` 方法，发布者可以告诉订阅者它遇到了问题。
- en: The `Flow.Processor` interface describes an entity that can act as both a subscriber
    and a publisher. It allows you to create chains (or pipelines) of such processors,
    so a subscriber can receive an item from a publisher, transform it, and then pass
    the result to the next subscriber or processor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Processor` 接口描述了一个可以同时作为订阅者和发布者的实体。它允许你创建这样的处理器的链（或管道），因此订阅者可以从发布者那里接收一个项目，对其进行转换，然后将结果传递给下一个订阅者或处理器。'
- en: In a push model, the publisher can call `onNext()` without any request from
    the subscriber. If the rate of processing is lower than the rate of the item being
    published, the subscriber can use various strategies to relieve the pressure.
    For example, it can skip the items or create a buffer for temporary storage with
    the hope that the item production will slow down and the subscriber will be able
    to catch up.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送模型中，发布者可以在没有订阅者请求的情况下调用 `onNext()`。如果处理速度低于发布项目的速度，订阅者可以使用各种策略来缓解压力。例如，它可以跳过项目或创建一个用于临时存储的缓冲区，希望项目生产速度会减慢，订阅者能够赶上。
- en: This is the minimal set of interfaces that the reactive streams initiative has
    defined in support of the asynchronous data streams with non-blocking backpressure.
    As you can see, it allows the subscriber and publisher to talk to each other and
    coordinate the rate of incoming data; therefore, it makes possible a variety of
    solutions for the backpressure problem that we discussed in the *Reactive* section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是反应式流倡议定义的接口的最小集合，以支持具有非阻塞背压的异步数据流。正如你所见，它允许订阅者和发布者相互通信并协调数据流入的速度；因此，它使得我们讨论的
    *Reactive* 部分中提到的背压问题有各种解决方案。
- en: 'There are many ways to implement these interfaces. Currently, in JDK 9, there
    is only one implementation of one of the interfaces: the `SubmissionPublisher`
    class implements `Flow.Publisher`. The reason for this is that these interfaces
    are not supposed to be used by an application developer. It is a **Service Provider
    Interface** (**SPI**) that is used by the developers of the reactive streams libraries.
    If needed, use one of the already-existing toolkits to implement the reactive
    streams API that we mentioned earlier: RxJava, Reactor, Akka Streams, Vert.x,
    or any other library of your preference.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些接口的方法有很多。目前，在 JDK 9 中，只有一个接口的实现：`SubmissionPublisher` 类实现了 `Flow.Publisher`。这是因为这些接口不应该被应用程序开发者使用。它是一个
    **服务提供者接口** (**SPI**)，由反应式流库的开发者使用。如果需要，可以使用现有的工具包之一来实现我们之前提到的反应式流 API：RxJava、Reactor、Akka
    Streams、Vert.x 或任何其他你偏好的库。
- en: RxJava
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava
- en: 'In our examples, we will use **RxJava 2.2.21** ([http://reactivex.io](http://reactivex.io))
    . It can be added to the project using the following dependency:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用 **RxJava 2.2.21** ([http://reactivex.io](http://reactivex.io))。它可以通过以下依赖项添加到项目中：
- en: '[PRE56]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'First, let’s compare two implementations of the same functionality using the
    `java.util.stream` package and the `io.reactivex` package. The sample program
    is going to be very simple:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们比较使用 `java.util.stream` 包和 `io.reactivex` 包实现的相同功能的两种实现。示例程序将会非常简单：
- en: 'Create a stream of integers: `1`, `2`, `3`, `4`, and `5`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个整数流：`1`、`2`、`3`、`4` 和 `5`。
- en: Only filter the even numbers (that is, `2` and `4`).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只过滤偶数（即，`2` 和 `4`）。
- en: Calculate the square root of each of the filtered numbers.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每个过滤数字的平方根。
- en: Calculate the sum of all the square roots.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算所有平方根的总和。
- en: 'Here is how it can be implemented using the `java.util.stream` package (see
    the `ObservableIntro` class and the `squareRootSum()` method):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用`java.util.stream`包实现的（请参阅`ObservableIntro`类和`squareRootSum()`方法）：
- en: '[PRE61]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Additionally, the same functionality implemented with RxJava looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用RxJava实现相同功能的样子如下：
- en: '[PRE67]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: RxJava is based on the `Observable` object (which plays the role of `Publisher`)
    and `Observer` that subscribes to the `Observable` object and waits for the data
    to be emitted.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava基于`Observable`对象（充当`Publisher`）和订阅`Observable`对象并等待数据发射的`Observer`。
- en: 'In contrast to the `Stream` functionality, `Observable` has significantly different
    capabilities. For example, a stream, once closed, cannot be reopened, while an
    `Observable` object can be used again. Here is an example (see the `ObservableIntro`
    class and the `reuseObservable()` method):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Stream`功能相比，`Observable`具有显著不同的能力。例如，一旦流关闭，就不能重新打开，而`Observable`对象可以再次使用。以下是一个示例（请参阅`ObservableIntro`类和`reuseObservable()`方法）：
- en: '[PRE73]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In the preceding example, as you can see from the comments, the `doOnNext()`
    operation was called twice, which means the observable object also emitted values
    twice, once for each processing pipeline:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如注释所示，`doOnNext()`操作被调用了两次，这意味着可观察对象也发射了两次值，每次处理管道一次：
- en: '![](img/B18388_Figure_15.1.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_15.1.jpg)'
- en: 'If we do not want `Observable` to run twice, we can cache its data, by adding
    the `cache()` operation (see the `ObservableIntro` class and the `cacheObservableData()`
    method):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望`Observable`运行两次，我们可以通过添加`cache()`操作来缓存其数据（请参阅`ObservableIntro`类和`cacheObservableData()`方法）：
- en: '[PRE86]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'As you can see, the second usage of the same `Observable` object took advantage
    of the cached data, thus allowing for better performance:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，相同`Observable`对象的第二次使用利用了缓存的数据，从而提高了性能：
- en: '![](img/B18388_Figure_15.2.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_15.2.jpg)'
- en: RxJava provides such a rich functionality that there is no way we can review
    it all in this book. Instead, we will try to cover the most popular functionality.
    The API describes the methods available for invocation using an `Observable` object.
    Such methods are also called **operations** (as in the case with the standard
    Java 8 streams) or **operators** (this term is mostly used in connection to reactive
    streams). We will use these three terms – methods, operations, and operators –
    interchangeably as synonyms.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava提供了如此丰富的功能，以至于我们无法在这本书中全部进行回顾。相反，我们将尝试涵盖最流行的功能。API描述了使用`Observable`对象可调用的方法。这些方法也被称为**操作**（如在标准Java
    8流的情况下）或**算子**（这个术语主要与响应式流相关联）。我们将将这些三个术语——方法、操作和算子——互换使用，作为同义词。
- en: Observable types
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察类型
- en: Talking about the RxJava 2 API (notice that is it quite different from RxJava
    1), we will use the online documentation, which can be found at [http://reactivex.io/RxJava/2.x/javadoc/index.html](http://reactivex.io/RxJava/2.x/javadoc/index.html).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论RxJava 2 API（请注意，它与RxJava 1相当不同），我们将使用在线文档，该文档可以在[http://reactivex.io/RxJava/2.x/javadoc/index.html](http://reactivex.io/RxJava/2.x/javadoc/index.html)找到。
- en: 'An observer subscribes to receive values from an observable object, which can
    behave as one of the following types:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者订阅以接收来自可观察对象的价值，它可以表现为以下类型之一：
- en: '**Blocking**: This waits until the result is returned.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻塞**: 这会等待直到结果返回。'
- en: '**Non-blocking**: This processes the emitted elements asynchronously.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞**: 这以异步方式处理发射的元素。'
- en: '**Cold**: This emits an element at the observer’s request.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷处理**: 这会在观察者的请求下发射一个元素。'
- en: '**Hot**: This emits elements whether an observer has subscribed or not.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热**: 无论观察者是否已订阅，都会发射元素。'
- en: 'An observable object can be an object of one of the following classes of the
    `io.reactivex` package:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可观察的对象可以是`io.reactivex`包中以下类之一：
- en: '`Observable<T>`: This can emit none, one, or many elements; it does not support
    backpressure.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable<T>`：这可以发射零个、一个或多个元素；它不支持背压。'
- en: '`Flowable<T>`: This can emit none, one, or many elements; it supports backpressure.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flowable<T>`：这可以发射零个、一个或多个元素；它支持背压。'
- en: '`Single<T>`: This can emit either one element or an error; the notion of backpressure
    does not apply.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Single<T>`：这可以发射一个元素或一个错误；不适用背压的概念。'
- en: '`Maybe<T>`: This represents a deferred computation. It can emit either no value,
    one value, or an error; the notion of backpressure does not apply.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Maybe<T>`：这表示一个延迟的计算。它可以发出没有值、一个值或一个错误；背压的概念不适用。'
- en: '`Completable`: This represents a deferred computation without any value. This
    indicates the completion of a task or an error; the notion of backpressure does
    not apply.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Completable`：这表示一个没有值的延迟计算。这表示任务的完成或错误；背压的概念不适用。'
- en: An object of each of these classes can behave as a blocking, non-blocking, cold,
    or hot observable. They differ from each other by the number of values that can
    be emitted, their ability to defer the returning of the result or returning the
    flag of the task completion only, and their ability to handle backpressure.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些类的对象都可以作为阻塞、非阻塞、冷或热可观察对象的行为。它们之间的区别在于可以发出的值的数量、延迟返回结果或仅返回任务完成标志的能力，以及处理背压的能力。
- en: Blocking versus non-blocking
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阻塞与非阻塞
- en: 'To demonstrate this behavior, we create an observable that emits five sequential
    integers, starting with `1` (see the `BlockingOperators` class and the `observableBlocking1()`
    method):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种行为，我们创建了一个可观察对象，该对象发出五个连续的整数，从`1`开始（参见`BlockingOperators`类和`observableBlocking1()`方法）：
- en: '[PRE100]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'All the blocking methods (operators) of `Observable` start with the “blocking.”
    For example, the `blockingLast()` operator blocks the pipeline until the last
    elements are emitted:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`的所有阻塞方法（操作符）都以“blocking.”开头。例如，`blockingLast()`操作符会阻塞管道，直到最后一个元素被发出：'
- en: '[PRE101]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In this example, we only select even numbers, print the selected element, and
    then calculate the square root and wait for 100 ms (imitating a long-running calculation).
    The result of this example is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只选择偶数，打印选定的元素，然后计算平方根并等待100毫秒（模拟长时间运行的计算）。这个例子的结果如下：
- en: '![](img/B18388_Figure_15.3.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_15.3.jpg)'
- en: 'The non-blocking version of the same functionality is as follows (see the `BlockingOperators`
    class and the second half of the `observableBlocking1()` method):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 相同功能的非阻塞版本如下（参见`BlockingOperators`类和`observableBlocking1()`方法的第二部分）：
- en: '[PRE107]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We use the `List` object to capture the result because, as you might remember,
    the lambda expression does not allow us to use the non-final variables.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`List`对象来捕获结果，因为，你可能记得，lambda表达式不允许我们使用非final变量。
- en: As you can see, the resulting list is empty. That is because the pipeline calculations
    are performed without blocking (asynchronously). We set a delay of 100 ms (to
    simulate processing, which takes a long time), but there is no blocking operation,
    so the control goes down to the next line that prints the list content, which
    is still empty.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果列表是空的。这是因为管道计算是在非阻塞（异步）的情况下进行的。我们设置了100毫秒的延迟（模拟耗时处理），但没有阻塞操作，所以控制流到下一行，打印列表内容，仍然是空的。
- en: 'To prevent the control from going to this line too early, we can set a delay
    in front of it (see the `BlockingOperators` class and the `observableBlocking2()`
    method):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止控制过早地转到这一行，我们可以在它前面设置一个延迟（参见`BlockingOperators`类和`observableBlocking2()`方法）：
- en: '[PRE119]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Note that the delay has to be 200 ms at least because the pipeline processes
    two elements, each with a delay of 100 ms. Now you can see the list contains an
    expected value of `2.0`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，延迟至少需要200毫秒，因为管道处理两个元素，每个元素都有100毫秒的延迟。现在你可以看到列表中有一个预期的值`2.0`。
- en: 'Esentially, that is the difference between blocking and non-blocking operators.
    Other classes that represent an `observable` have similar blocking operators.
    Here are some examples of blocking `Flowable`, `Single`, and `Maybe` (see the
    `BlockingOperators` class and the `flowableBlocking()`, `singleBlocking()`, and
    `maybeBlocking()` methods):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这就是阻塞和非阻塞操作符之间的区别。其他表示`observable`的类也有类似的阻塞操作符。以下是一些阻塞的`Flowable`、`Single`和`Maybe`的示例（参见`BlockingOperators`类和`flowableBlocking()`、`singleBlocking()`、`maybeBlocking()`方法）：
- en: '[PRE125]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `Completable` class has blocking operators that allow us to set a timeout
    (see the `BlockingOperators` class and the second half of the `completableBlocking()`
    method):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Completable`类有阻塞操作符，允许我们设置超时（参见`BlockingOperators`类和`completableBlocking()`方法的第二部分）：'
- en: '[PRE138]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The result of the preceding code is presented in the following screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的结果如下所示：
- en: '![](img/B18388_Figure_15.4.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_15.4.jpg)'
- en: The first `Run` message comes from line 2 in response to the call of the blocking
    `blockingGet()` method. The first `null` message comes from line 3\. Line 4 throws
    an exception because the timeout was set to 15 ms, while the actual processing
    was set to a delay of 100 ms. The second `Run` message comes from line 5 in response
    to the `blockingGet()` method call. This time, the timeout is set to 150 ms, which
    is more than 100 ms, so the method is able to return before the timeout was up.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`Run`消息来自第2行，是对阻塞`blockingGet()`方法调用的响应。第一个`null`消息来自第3行。第4行抛出异常，因为超时设置为15毫秒，而实际处理设置为100毫秒的延迟。第二个`Run`消息来自第5行，是对`blockingGet()`方法调用的响应。这次，超时设置为150毫秒，这比100毫秒多，所以方法能够在超时之前返回。
- en: The last two lines, 7 and 8, demonstrate the usage of the `blockingAwait()`
    method with and without a timeout. This method does not return a value but allows
    the observable pipeline to run its course. Interestingly, it does not break with
    an exception even when the timeout is set to a smaller value than the time the
    pipeline takes to finish. Apparently, it starts waiting after the pipeline has
    finished processing unless it is a defect that will be fixed later (the documentation
    is not clear regarding this point).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行，第7行和第8行，展示了在有无超时的情况下使用`blockingAwait()`方法的使用方法。此方法不返回任何值，但允许可观察管道运行其流程。有趣的是，即使超时设置得比管道完成所需的时间短，它也不会抛出异常。显然，它会在管道完成处理之后开始等待，除非这是一个将在以后修复的缺陷（关于这一点，文档并不明确）。
- en: Although blocking operations do exist (and we will review more of them while
    talking about each observable type in the following sections), they are and should
    only be used in cases when it is not possible to implement the required functionality
    of using non-blocking operations only. The main thrust of reactive programming
    is to strive to process all requests asynchronously in a non-blocking style.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在阻塞操作（我们将在以下各节中讨论每个可观察类型时回顾更多），但它们应该只在使用非阻塞操作无法实现所需功能的情况下使用。响应式编程的主要目标是努力以非阻塞方式异步处理所有请求。
- en: Cold versus hot
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冷与热
- en: 'So far, all the examples we have seen have only demonstrated a cold observable,
    which only provides the next value at the request of the processing pipeline after
    the previous value has been processed. Here is another example (see the `ColdObservable`
    class and the `main()` method):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的所有示例都只展示了冷可观察对象，它只在处理完前一个值后，在处理管道的请求下提供下一个值。这里还有一个示例（参见`ColdObservable`类和`main()`方法）：
- en: '[PRE155]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'We have used the `interval()` method to create an `Observable` object that
    represents a stream of sequential numbers emitted at every specified interval
    (in our case, every 10 ms). Then, we subscribe to the created object, wait 25
    ms, subscribe again, and wait another 55 ms. The `pauseMs()` method is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`interval()`方法创建了一个表示每指定间隔（在我们的情况下，每10毫秒）发出序列数字的可观察对象。然后，我们订阅创建的对象，等待25毫秒，再次订阅，并等待另一个55毫秒。`pauseMs()`方法如下：
- en: '[PRE161]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'If we run the preceding example, the output will look similar to the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的示例，输出将类似于以下内容：
- en: '![](img/B18388_Figure_15.5.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_15.5.jpg)'
- en: As you can see, each of the pipelines processed every value emitted by the cold
    observable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个管道都处理了冷可观察对象发出的每个值。
- en: 'To convert the *cold* observable into a *hot* one, we use the `publish()` method,
    which converts the observable into a `ConnectableObservable` object that extends
    the `Observable` object (see the `HotObservable` class and the `hot1()` method):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要将*冷*可观察对象转换为*热*可观察对象，我们使用`publish()`方法，该方法将可观察对象转换为扩展`Observable`对象的`ConnectableObservable`对象（参见`HotObservable`类和`hot1()`方法）：
- en: '[PRE168]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'As you can see, we have to call the `connect()` method so that the `ConnectableObservable`
    object starts emitting values. The output looks similar to the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们必须调用`connect()`方法，这样`ConnectableObservable`对象才会开始发出值。输出看起来类似于以下内容：
- en: '![](img/B18388_Figure_15.6.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_15.6.jpg)'
- en: The preceding output shows that the second pipeline did not receive the first
    three values because it was subscribed to the observable later on. So, the observable
    emits values independent of the ability of the observers to process them. If the
    processing falls behind, and new values keep coming while the previous ones are
    not fully processed yet, the `Observable` class puts them into a buffer. If this
    buffer grows large enough, the JVM can run out of memory because, as we mentioned
    earlier, the `Observable` class is not capable of backpressure management.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，第二个管道没有收到前三个值，因为它是在稍后订阅了可观察对象。因此，可观察对象发出的值独立于观察者处理它们的能力。如果处理落后，并且新的值不断到来，而先前的值尚未完全处理，`Observable`类将它们放入缓冲区。如果这个缓冲区变得足够大，JVM可能会耗尽内存，因为我们之前提到，`Observable`类不具备背压管理能力。
- en: 'For such cases, the `Flowable` class is a better candidate for the observable
    because it does have the ability to handle backpressure. Here is an example (see
    the `HotObservable` class and the `hot2()` method):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，`Flowable`类是更好的候选者，因为它确实具有处理背压的能力。以下是一个示例（参见`HotObservable`类和`hot2()`方法）：
- en: '[PRE175]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: The `PublishProcessor` class extends `Flowable` and has an `onNext(Object o)`
    method that forces it to emit the passed-in object. Before calling it, we have
    subscribed to the observable using the `Schedulers.io()` thread. We will talk
    about schedulers in the *Multithreading (scheduler)* section.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`PublishProcessor`类扩展了`Flowable`，并有一个`onNext(Object o)`方法，它强制它发出传入的对象。在调用它之前，我们已经使用`Schedulers.io()`线程订阅了可观察对象。我们将在*多线程（调度器）*部分讨论调度器。'
- en: 'The `subscribe()` method has several overloaded versions. We decided to use
    the one that accepts two `Consumer` functions: the first one processes the passed-in
    value, and the second one processes an exception if it was thrown by any of the
    pipeline operations (it works similar to a `Catch` block).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe()`方法有几个重载版本。我们决定使用接受两个`Consumer`函数的那个版本：第一个处理传入的值，第二个处理如果管道操作抛出异常的情况（它的工作方式类似于`Catch`块）。'
- en: 'If we run the preceding example, it will successfully print the first 127 values
    and then throw `MissingBackpressureException`, as shown in the following screenshot:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的示例，它将成功打印前127个值，然后抛出`MissingBackpressureException`，如下面的截图所示：
- en: '![](img/B18388_Figure_15.7.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_15.7.jpg)'
- en: 'The message in the exception provides a clue: `Could not emit value due to
    lack of requests`. Apparently, the rate of emitting values is higher than the
    rate of consuming them, while an internal buffer can only keep 128 elements. If
    we add a delay (to simulate a longer processing time), the result will be even
    worse (see the `HotObservable` class and the `hot3()` method):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 异常中的消息提供了一个线索：“由于请求不足，无法发出值”。显然，发出值的速率高于消费它们的速率，而内部缓冲区只能保持128个元素。如果我们添加延迟（以模拟更长的处理时间），结果会更糟（参见`HotObservable`类和`hot3()`方法）：
- en: '[PRE181]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Even the first 128 elements will not get through and the output will only have
    `MissingBackpressureException`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 即使前128个元素也无法通过，输出将只有`MissingBackpressureException`。
- en: 'To address this issue, a backpressure strategy has to be set. For example,
    let’s drop every value that the pipeline did not manage to process (see the `HotObservable`
    class and the `hot4()` method):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，必须设置一个背压策略。例如，让我们丢弃管道未能处理的每个值（参见`HotObservable`类和`hot4()`方法）：
- en: '[PRE188]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Notice that the strategy has to be set before the `observeOn()` operation, so
    it will be picked up by the created `Schedulers.io()` thread.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，策略必须在`observeOn()`操作之前设置，这样它就会被创建的`Schedulers.io()`线程获取。
- en: 'The output shows that many of the emitted values were dropped. Here is an output
    fragment:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示许多发出的值都被丢弃了。以下是一个输出片段：
- en: '![](img/B18388_Figure_15.8.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_15.8.jpg)'
- en: We will talk about other backpressure strategies in the *Operators* section
    when we overview the corresponding operators.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们概述相应的操作符时，我们将在*操作符*部分讨论其他背压策略。
- en: Disposable
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可处置
- en: 'Notice that a `subscribe()` method actually returns a `Disposable` object that
    can be queried to check whether the pipeline processing has been completed and
    disposed of (see the `DisposableUsage` class and the `disposable1()` method):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`subscribe()`方法实际上返回一个`Disposable`对象，可以查询以检查管道处理是否已完成并已处置（参见`DisposableUsage`类和`disposable1()`方法）：
- en: '[PRE195]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Also, it is possible to enforce the disposing of a pipeline, thus effectively
    canceling the processing (see the `DisposableUsage` class and the `disposable2()`
    method):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以强制销毁管道，从而有效地取消处理（参见 `DisposableUsage` 类和 `disposable2()` 方法）。
- en: '[PRE217]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: As you can see, by adding the call to `disposable.dispose()`, we have stopped
    processing, so even after a delay of 200 ms, the list remains empty (see the last
    line of the preceding example).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过添加对 `disposable.dispose()` 的调用，我们已经停止了处理，因此即使延迟了 200 毫秒，列表仍然为空（参见前一个示例的最后一行）。
- en: This method of forced disposal can be used to make sure that there are no runaway
    threads. Each created `Disposable` object can be disposed of in the same way that
    resources are released in a `finally` block. The `CompositeDisposable` class helps
    us to handle multiple `Disposable` objects in a coordinated manner.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这种强制销毁的方法可以用来确保没有失控的线程。每个创建的 `Disposable` 对象都可以以与 `finally` 块中释放资源相同的方式销毁。`CompositeDisposable`
    类帮助我们以协调的方式处理多个 `Disposable` 对象。
- en: When an `onComplete` or `onError` event happens, the pipeline is disposed of
    automatically.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生 `onComplete` 或 `onError` 事件时，管道会自动销毁。
- en: For example, you can use the `add()` method and add a newly created `Disposable`
    object to the `CompositeDisposable` object. Then, when necessary, the `clear()`
    method can be invoked on the `CompositeDisposable` object. It will remove the
    collected `Disposable` objects and call the `dispose()` method on each of them.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用 `add()` 方法并将新创建的 `Disposable` 对象添加到 `CompositeDisposable` 对象中。然后，在需要时，可以在
    `CompositeDisposable` 对象上调用 `clear()` 方法。它将移除收集到的 `Disposable` 对象，并对每个对象调用 `dispose()`
    方法。
- en: Creating an observable
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可观察对象
- en: 'You have already seen a few methods of how to create an observable in our examples.
    There are many other factory methods, including `Observable`, `Flowable`, `Single`,
    `Maybe`, and `Completable`. However, not all of the following methods are available
    in each of these interfaces (see the comments; *all* means that all of the listed
    interfaces have it):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在我们的示例中看到了一些创建可观察对象的方法。还有很多其他的工厂方法，包括 `Observable`, `Flowable`, `Single`,
    `Maybe`, 和 `Completable`。然而，以下方法并不在所有这些接口中都有（见注释；*所有* 表示所有列出的接口都有它）：
- en: '`create()`: This creates an `Observable` object by providing the full implementation
    (all).'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create()`: 通过提供完整的实现来创建一个 `Observable` 对象（所有）。'
- en: '`defer()`: This creates a new `Observable` object every time a new `Observer`
    subscribes (all).'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer()`: 每次有新的 `Observer` 订阅时，都会创建一个新的 `Observable` 对象（所有）。'
- en: '`empty()`: This creates an empty `Observable` object that completes immediately
    upon subscription (all, except for `Single`).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty()`: 这将创建一个空的 `Observable` 对象，在订阅时立即完成（所有，除了 `Single`）。'
- en: '`never()`: This creates an `Observable` object that does not emit anything
    and does nothing at all; it does not even complete (all).'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never()`: 这将创建一个不发出任何内容且什么都不做的 `Observable` 对象；它甚至不会完成（所有）。'
- en: '`error()`: This creates an `Observable` object that emits an exception immediately
    upon subscription (all).'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error()`: 这将创建一个在订阅时立即抛出异常的 `Observable` 对象（所有）。'
- en: '`fromXXX()`: This creates an `Observable` object, where XXX can be *Callable*,
    *Future* (all), *Iterable*, *Array*, *Publisher* (`Observable` and `Flowable`),
    *Action*, or *Runnable* (`Maybe` and `Completable`); this means it creates an
    `Observable` object based on the provided function or object.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromXXX()`: 这将创建一个 `Observable` 对象，其中 XXX 可以是 *Callable*，*Future*（所有），*Iterable*，*Array*，*Publisher*（`Observable`
    和 `Flowable`），*Action* 或 *Runnable*（`Maybe` 和 `Completable`）；这意味着它基于提供的函数或对象创建一个
    `Observable` 对象。'
- en: '`generate()`: This creates a cold `Observable` object that generates values
    based on the provided function or object (`Observable` and `Flowable` only).'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate()`: 这将创建一个基于提供的函数或对象的冷 `Observable` 对象，生成值（仅限 `Observable` 和 `Flowable`）。'
- en: '`range(), rangeLong(), interval(), intervalRange()`: This creates an `Observable`
    object that emits sequential `int` or `long` values, which may or may not be limited
    by the specified range and spaced by the specified time interval (`Observable`
    and `Flowable` only).'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range(), rangeLong(), interval(), intervalRange()`: 这将创建一个发出连续 `int` 或 `long`
    值的 `Observable` 对象，这些值可能或可能不被指定的范围限制，并且由指定的时间间隔分隔（仅限 `Observable` 和 `Flowable`）。'
- en: '`just()`: This creates an `Observable` object based on the provided object
    or a set of objects (all, except for `Completable`).'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`just()`: 这将基于提供的对象或一组对象创建一个 `Observable` 对象（所有，除了 `Completable`）。'
- en: '`timer()`: This creates an `Observable` object that, after the specified time,
    emits an `0L` signal (all) and then completes for `Observable` and `Flowable`.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timer()`: 这将创建一个`Observable`对象，在指定时间后，发出一个`0L`信号（所有）然后对`Observable`和`Flowable`完成。'
- en: There are also many other helpful methods, such as `repeat()`, `startWith()`,
    and more. We just do not have enough space to list all of them. Refer to the online
    documentation ([http://reactivex.io/RxJava/2.x/javadoc/index.html](http://reactivex.io/RxJava/2.x/javadoc/index.html)).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有很多其他有用的方法，例如`repeat()`、`startWith()`等。我们只是没有足够的空间列出所有这些方法。请参阅在线文档([http://reactivex.io/RxJava/2.x/javadoc/index.html](http://reactivex.io/RxJava/2.x/javadoc/index.html))。
- en: 'Let’s look at an example of the `create()` method usage. The `create()` method
    of `Observable` is as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`create()`方法的使用示例。`Observable`的`create()`方法如下：
- en: '[PRE240]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'The passed-in object has to be an implementation of the `ObservableOnSubscribe<T>`
    functional interface, which only has one abstract method, `subscribe()`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的对象必须实现`ObservableOnSubscribe<T>`功能接口，该接口只有一个抽象方法`subscribe()`：
- en: '[PRE241]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'The `ObservableEmitter<T>` interface contains the following methods:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableEmitter<T>`接口包含以下方法：'
- en: '`boolean isDisposed()`: This returns `true` if the processing pipeline was
    disposed of or the emitter was terminated.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isDisposed()`: 如果处理管道被销毁或发射器被终止，则返回`true`。'
- en: '`ObservableEmitter<T> serialize()`: This provides the serialization algorithm
    used by the calls to `onNext()`, `onError()`, and `onComplete()`, located in the
    `Emitter` base class.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObservableEmitter<T> serialize()`: 这提供了`Emitter`基类中位于`onNext()`、`onError()`和`onComplete()`调用中使用的序列化算法。'
- en: '`void setCancellable(Cancellable c)`: This sets, on this emitter, a `Cancellable`
    implementation (that is, a functional interface that has only one method, `cancel()`).'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void setCancellable(Cancellable c)`: 这在此发射器上设置一个`Cancellable`实现（即只有一个方法`cancel()`的功能接口）。'
- en: '`void setDisposable(Disposable d)`: This sets, on this emitter, a `Disposable`
    implementation (which is an interface that has two methods: `isDispose()` and
    `dispose()`).'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void setDisposable(Disposable d)`: 这在此发射器上设置一个`Disposable`实现（这是一个有两个方法`isDispose()`和`dispose()`的接口）。'
- en: '`boolean tryOnError(Throwable t)`: This handles the error condition, attempts
    to emit the provided exception, and returns `false` if the emission is not allowed.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean tryOnError(Throwable t)`: 这处理错误条件，尝试发出提供的异常，如果发出不被允许则返回`false`。'
- en: 'To create an observable, all the preceding interfaces can be implemented as
    follows (see the `CreateObservable` class and the `main()` method):'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可观察对象，所有前面的接口都可以按以下方式实现（参见`CreateObservable`类和`main()`方法）：
- en: '[PRE242]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Let’s take a closer look at the preceding example. We created an `ObservableOnSubscribe`
    function as `source` and implemented the emitter: we told the emitter to emit
    `One` at the first call to `onNext()`, to emit `Two` at the second call to `onNext()`,
    and then to call `onComplete()`. We passed the `source` function to the `create()`
    method and built the pipeline to process all of the emitted values.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看前面的例子。我们创建了一个`ObservableOnSubscribe`函数作为`source`并实现了发射器：我们告诉发射器在第一次调用`onNext()`时发出`One`，在第二次调用`onNext()`时发出`Two`，然后调用`onComplete()`。我们将`source`函数传递给`create()`方法并构建处理所有发出值的管道。
- en: 'To make it more interesting, we added the `filter()` operator, which only allows
    you to further propagate the values with the *w* character. Additionally, we chose
    the `subscribe()` method version with three parameters: the `Consumer onNext`,
    `Consumer onError`, and `Action onComplete` functions. The first is called every
    time a next value reached the method, the second is called when an exception was
    emitted, and the third is called when the source emits an `onComplete()` signal.
    After creating the pipeline, we paused for 100 ms to give the asynchronous process
    a chance to finish. The result is as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它更有趣，我们添加了`filter()`运算符，它只允许你使用字符`*w*`进一步传播值。此外，我们选择了带有三个参数的`subscribe()`方法版本：`Consumer
    onNext`、`Consumer onError`和`Action onComplete`函数。第一个在每次下一个值达到方法时被调用，第二个在发出异常时被调用，第三个在源发出`onComplete()`信号时被调用。在创建管道后，我们暂停了100毫秒，以给异步过程一个完成的机会。结果是如下所示：
- en: '![](img/B18388_Figure_15.9.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_15.9.jpg)'
- en: If we remove the `emitter.onComplete()` line from the emitter implementation,
    only the message `Two` will be displayed.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从发射器实现中移除`emitter.onComplete()`这一行，则只会显示消息`Two`。
- en: So, those are the basics of how the `create()` method can be used. As you can
    see, it allows for full customization. In practice, it is rarely used because
    there are far simpler ways to create an observable. We will review them in the
    following sections.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些都是`create()`方法的基本用法。正如你所见，它允许完全自定义。在实践中，它很少被使用，因为创建可观察对象有更简单的方法。我们将在接下来的章节中回顾它们。
- en: Additionally, you will see examples of other factory methods that are used in
    our examples throughout other sections of this chapter.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将看到其他在本章其他部分示例中使用的工厂方法的示例。
- en: Operators
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符
- en: There are literally hundreds (if we count all of the overloaded versions) of
    operators available in each of the observable interfaces, `Observable`, `Flowable`,
    `Single`, `Maybe`, and `Completable`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个可观察接口中，`Observable`、`Flowable`、`Single`、`Maybe`和`Completable`，实际上都有数百（如果我们计算所有重载版本）的操作符可用。
- en: In the `Observable` and `Flowable` interfaces, the number of methods goes beyond
    500\. That is why, in this section, we are going to provide just an overview and
    a few examples that will help you to navigate the maze of possible options.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Observable`和`Flowable`接口中，方法数量超过500。这就是为什么在本节中，我们将只提供一个概述和一些示例，帮助你导航可能的选项迷阵。
- en: 'We have grouped all the operators into 10 categories: transforming, filtering,
    combining, converting from XXX, exceptions handling, life cycle events handling,
    utilities, conditionals and Booleans, backpressure, and connectable.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将所有操作符分为10个类别：转换、过滤、组合、从XXX转换、异常处理、生命周期事件处理、实用工具、条件性和布尔值、背压和可连接。
- en: Please note that these are not all of the operators that are available. You
    can see more in the online documentation ([http://reactivex.io/RxJava/2.x/javadoc/index.html](http://reactivex.io/RxJava/2.x/javadoc/index.html)).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些并不是所有可用的操作符。你可以在在线文档中查看更多（[http://reactivex.io/RxJava/2.x/javadoc/index.html](http://reactivex.io/RxJava/2.x/javadoc/index.html)）。
- en: Transforming
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换
- en: 'The following operators transform the values emitted by an observable:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作符将转换由可观察对象发出的值：
- en: '`buffer()`: This collects the emitted values into bundles according to the
    provided parameters or by using the provided functions. It periodically emits
    these bundles one at a time.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer()`：根据提供的参数或使用提供的函数收集发出的值。它定期逐个发出这些包。'
- en: '`flatMap()`: This produces observables based on the current observable and
    inserts them into the current flow; it is one of the most popular operators.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap()`：根据当前可观察对象产生可观察对象，并将它们插入到当前流中；这是最受欢迎的操作符之一。'
- en: '`groupBy()`: This divides the current `Observable` object into groups of observables
    (`GroupedObservables` objects).'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupBy()`：将当前的`Observable`对象划分为可观察对象（`GroupedObservables`对象）的组。'
- en: '`map()`: This transforms the emitted value using the provided function.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`：使用提供的函数转换发出的值。'
- en: '`scan()`: This applies the provided function to each value in combination with
    the value produced as the result of the previous application of the same function
    to the previous value.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan()`：将提供的函数应用于每个值，并结合前一次应用相同函数到前一个值产生的结果。'
- en: '`window()`: This emits groups of values similar to `buffer()` but as observables,
    each of which emits a subset of values from the original observable and then terminates
    with `onCompleted()`.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window()`：发出与`buffer()`类似的值组，但作为可观察对象，每个可观察对象都发出原始可观察对象的一个子集的值，然后通过`onCompleted()`终止。'
- en: 'The following code demonstrates the use of `map()`, `flatMap()`, and `groupBy()`
    (see the `NonBlockingOperators` class and the `transforming()` method):'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了`map()`、`flatMap()`和`groupBy()`的使用（请参阅`NonBlockingOperators`类和`transforming()`方法）：
- en: '[PRE253]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Filtering
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤
- en: 'The following operators (and their multiple overloaded versions) select which
    of the values will continue to flow through the pipeline:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作符（及其多重重载版本）用于选择哪些值将继续通过管道流动：
- en: '`debounce()`: This emits a value only when a specified span of time has passed
    without the observable emitting another value.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debounce()`：仅在经过指定的时间间隔没有可观察对象发出另一个值时才发出值。'
- en: '`distinct()`: This selects unique values only.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct()`：仅选择唯一值。'
- en: '`elementAt(long n)`: This emits only one value with the specified `n` position
    in the stream.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elementAt(long n)`：仅发出流中指定`n`位置的值。'
- en: '`filter()`: This emits only the values that match the specified criteria.'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`：仅发出符合指定标准的值。'
- en: '`firstElement()`: This emits the first value only.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firstElement()`：仅发出第一个值。'
- en: '`ignoreElements()`: This does not emit values; only the `onComplete()` signal
    goes through.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignoreElements()`: 这不发出值；只有`onComplete()`信号通过。'
- en: '`lastElement()`: This emits the last value only.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastElement()`: 这只发出最后一个值。'
- en: '`sample()`: This emits the most recent value emitted within the specified time
    interval.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample()`: 这在指定的时问间隔内发出最近发出的值。'
- en: '`skip(long n)`: This skips the first `n` values.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip(long n)`: 这将跳过前`n`个值。'
- en: '`take(long n)`: This only emits the first `n` values.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take(long n)`: 这只发出前`n`个值。'
- en: 'The following code showcases examples of some of the uses of the preceding
    operators (see the `NonBlockingOperators` class and the `filtering()` method):'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了上述操作符的一些用法示例（请参阅`NonBlockingOperators`类和`filtering()`方法）：
- en: '[PRE270]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Combining
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合
- en: 'The following operators (and their multiple overloaded versions) create a new
    observable using multiple source observables:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作符（及其多重重载版本）使用多个源可观察对象创建一个新的可观察对象：
- en: '`concat(src1, src2)`: This creates an `Observable` object that emits all values
    of `src1` and then all values of `src2`.'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat(src1, src2)`: 这创建一个`Observable`对象，它发出`src1`的所有值，然后是`src2`的所有值。'
- en: '`combineLatest(src1, src2, combiner)`: This creates an `Observable` object
    that emits a value emitted by either of the two sources combined with the latest
    value emitted by each source using the provided `combiner` function.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combineLatest(src1, src2, combiner)`: 这创建一个`Observable`对象，它发出两个源中任一源发出的值，并结合每个源最近发出的值，使用提供的`combiner`函数。'
- en: '`join(src2, leftWin, rightWin, combiner)`: This combines the values emitted
    by two observables during the `leftWin` and `rightWin` time windows according
    to the `combiner` function.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join(src2, leftWin, rightWin, combiner)`: 这根据`combiner`函数，在`leftWin`和`rightWin`时间窗口内结合两个可观察对象发出的值。'
- en: '`merge()`: This combines multiple observables into one; in contrast to `concat()`,
    it might interleave them, whereas `concat()` never interleaves the emitted values
    from different observables.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge()`: 这将多个可观察对象合并为一个；与`concat()`不同，它可能会交错它们，而`concat()`永远不会交错来自不同可观察对象的发出值。'
- en: '`startWith(T item)`: This adds the specified value before emitting values from
    the source observable.'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startWith(T item)`: 这在从源可观察对象发出值之前，添加指定的值。'
- en: '`startWith(Observable<T> other)`: This adds the values from the specified observable
    before emitting values from the source observable.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startWith(Observable<T> other)`: 这将在从源可观察对象发出值之前，添加指定可观察对象的值。'
- en: '`switchOnNext(Observable<Observable> observables)`: This creates a new `Observable`
    object that emits the most-recently emitted values of the specified observables.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switchOnNext(Observable<Observable> observables)`: 这创建一个新的`Observable`对象，它发出指定可观察对象最近发出的值。'
- en: '`zip()`: This combines the values of the specified observables using the provided
    function.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip()`: 这使用提供的函数组合指定可观察对象的值。'
- en: 'The following code demonstrates the use of some of these operators (see the
    `NonBlockingOperators` class and the `combined()` method):'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了这些操作符的一些用法（请参阅`NonBlockingOperators`类和`combined()`方法）：
- en: '[PRE293]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: Converting from XXX
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从XXX转换
- en: 'These operators are pretty straightforward. Here is a list of from-XXX operators
    of the `Observable` class:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符相当直观。以下是`Observable`类的from-XXX操作符列表：
- en: '`fromArray(T... items)`: This creates an `Observable` object from a varargs.'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromArray(T... items)`: 这从一个可变参数创建一个`Observable`对象。'
- en: '`fromCallable(Callable<T> supplier)`: This creates an `Observable` object from
    a `Callable` function.'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromCallable(Callable<T> supplier)`: 这从一个`Callable`函数创建一个`Observable`对象。'
- en: '`fromFuture(Future<T> future)`: This creates an `Observable` object from a
    `Future` object.'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromFuture(Future<T> future)`: 这从一个`Future`对象创建一个`Observable`对象。'
- en: '`fromFuture(Future<T> future, long timeout, TimeUnit unit)`: This creates an
    `Observable` object from a `Future` object with the timeout parameters applied
    to the `future`.'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromFuture(Future<T> future, long timeout, TimeUnit unit)`: 这将从带有超时参数应用于`future`的`Future`对象创建一个`Observable`对象。'
- en: '`fromFuture(Future<T> future, long timeout, TimeUnit unit, Scheduler scheduler)`:
    This creates an `Observable` object from a `Future` object with the timeout parameters
    applied to the `future` and the scheduler (note that `Schedulers.io()` is recommended;
    please see the *Multithreading (scheduler)* section).'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromFuture(Future<T> future, long timeout, TimeUnit unit, Scheduler scheduler)`:
    这将从带有超时参数应用于`future`和调度器的`Future`对象创建一个`Observable`对象（注意`Schedulers.io()`被推荐；请参阅*多线程（调度器）*部分）。'
- en: '`fromFuture(Future<T> future, Scheduler scheduler)`: This creates an `Observable`
    object from a `Future` object on the specified scheduler (note that `Schedulers.io()`
    is recommended; please see the *Multithreading (scheduler)* section).'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromFuture(Future<T> future, Scheduler scheduler)`: 从指定调度器上的 `Future` 对象创建一个
    `Observable` 对象（注意，推荐使用 `Schedulers.io()`；请参阅 *多线程（调度器）* 部分）。'
- en: '`fromIterable(Iterable<T> source)`: This creates an `Observable` object from
    an iterable object (for example, `List`).'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromIterable(Iterable<T> source)`: 从可迭代对象（例如，`List`）创建一个 `Observable` 对象。'
- en: '`fromPublisher(Publisher<T> publisher)`: This creates an `Observable` object,
    for example from a `Publisher` object.'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromPublisher(Publisher<T> publisher)`: 从 `Publisher` 对象创建一个 `Observable`
    对象。'
- en: Exceptions handling
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理
- en: The `subscribe()` operator has an overloaded version that accepts the `Consumer<Throwable>`
    function, which handles exceptions raised anywhere in the pipeline. It works in
    a similar way to the all-embracing `try-catch` block. If you have this function
    passed into the `subscribe()` operator, you can be sure that is the only place
    where all exceptions will end up.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe()` 算子有一个重载版本，它接受 `Consumer<Throwable>` 函数，该函数处理管道中引发的异常。它的工作方式类似于全面的
    `try-catch` 块。如果您将此函数传递给 `subscribe()` 算子，您可以确信这是所有异常最终结束的唯一地方。'
- en: 'However, if you need to handle the exceptions in the middle of the pipeline,
    the values flow can be recovered and processed by the rest of the operators, that
    is, after the operator has thrown the exception. The following operators (and
    their multiple overloaded versions) can help with that:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您需要在管道中间处理异常，值流可以被恢复并由其余算子处理，即算子抛出异常之后。以下算子（及其多个重载版本）可以帮助做到这一点：
- en: '`onErrorXXX()`: This resumes the provided sequence when an exception was caught;
    XXX indicates what the operator does: `onErrorResumeNext()`, `onErrorReturn()`,
    or `onErrorReturnItem()`.'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onErrorXXX()`: 当捕获到异常时恢复提供的序列；XXX 表示算子执行的操作：`onErrorResumeNext()`、`onErrorReturn()`
    或 `onErrorReturnItem()`。'
- en: '`retry()`: This creates an `Observable` object that repeats the emissions emitted
    from the source; it resubscribes to the source `Observable` if it calls `onError()`.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retry()`: 这将创建一个重复从源发出的发射的 `Observable` 对象；如果它调用 `onError()`，则重新订阅源 `Observable`。'
- en: 'The demo code appears as follows (see the `NonBlockingOperators` class and
    the `exceptions()` method):'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 演示代码如下（请参阅 `NonBlockingOperators` 类和 `exceptions()` 方法）：
- en: '[PRE314]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: Life cycle events handling
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期事件处理
- en: These operators are each invoked on a certain event that happened anywhere in
    the pipeline. They work similarly to the operators described in the *Exceptions
    handling* section.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算子在每个管道中发生的某个事件上被调用。它们的工作方式与 *异常处理* 部分中描述的算子类似。
- en: 'The format of these operators is `doXXX()`, where XXX is the name of the event:
    `onComplete`, `onNext`, `onError`, and similar. Not all of them are available
    in all the classes, and some of them are slightly different in `Observable`, `Flowable`,
    `Single`, `Maybe`, or `Completable`. However, we do not have space to list all
    the variations of all these classes and will limit our overview to a few examples
    of the life cycle events-handling operators of the `Observable` class:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算子的格式为 `doXXX()`，其中 XXX 是事件的名称：`onComplete`、`onNext`、`onError` 等。并非所有这些类都提供所有这些，其中一些在
    `Observable`、`Flowable`、`Single`、`Maybe` 或 `Completable` 中略有不同。然而，我们没有空间列出所有这些类的所有变体，因此我们将概述限制在
    `Observable` 类的生命周期事件处理算子的几个示例：
- en: '`doOnSubscribe(Consumer<Disposable> onSubscribe)`: This executes when an observer
    subscribes.'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnSubscribe(Consumer<Disposable> onSubscribe)`: 当观察者订阅时执行。'
- en: '`doOnNext(Consumer<T> onNext)`: This applies the provided `Consumer` function
    when the source observable calls `onNext`.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnNext(Consumer<T> onNext)`: 当源可观察对象调用 `onNext` 时应用提供的 `Consumer` 函数。'
- en: '`doAfterNext(Consumer<T> onAfterNext)`: This applies the provided `Consumer`
    function to the current value after it is pushed downstream.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doAfterNext(Consumer<T> onAfterNext)`: 在当前值被推送到下游之后，应用提供的 `Consumer` 函数。'
- en: '`doOnEach(Consumer<Notification<T>> onNotification)`: This executes the `Consumer`
    function for each emitted value.'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnEach(Consumer<Notification<T>> onNotification)`: 对每个发出的值执行 `Consumer`
    函数。'
- en: '`doOnEach(Observer<T> observer)`: This notifies an `Observer` object for each
    emitted value and the terminal event it emits.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnEach(Observer<T> observer)`: 对每个发出的值和它发出的终端事件通知一个 `Observer` 对象。'
- en: '`doOnComplete(Action onComplete)`: This executes the provided `Action` function
    after the source observable generates the `onComplete` event.'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnComplete(Action onComplete)`: 在源可观察对象生成`onComplete`事件后，执行提供的`Action`函数。'
- en: '`doOnDispose(Action onDispose)`: This executes the provided `Action` function
    after the pipeline was disposed of downstream.'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnDispose(Action onDispose)`: 在管道被下游处置后，执行提供的`Action`函数。'
- en: '`doOnError(Consumer<Throwable> onError)`: This executes when the `onError`
    event is sent.'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnError(Consumer<Throwable> onError)`: 当发送`onError`事件时执行。'
- en: '`doOnLifecycle(Consumer<Disposable> onSubscribe, Action onDispose)`: This calls
    the corresponding `onSubscribe` or `onDispose` function for the corresponding
    event.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnLifecycle(Consumer<Disposable> onSubscribe, Action onDispose)`: 为相应的事件调用相应的`onSubscribe`或`onDispose`函数。'
- en: '`doOnTerminate(Action onTerminate)`: This executes the provided `Action` function
    when the source observable generates the `onComplete` event or an exception (the
    `onError` event) is raised.'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnTerminate(Action onTerminate)`: 当源可观察对象生成`onComplete`事件或抛出异常（`onError`事件）时，执行提供的`Action`函数。'
- en: '`doAfterTerminate(Action onFinally)`: This executes the provided `Action` function
    after the source observable generates the `onComplete` event or an exception (the
    `onError` event) is raised.'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doAfterTerminate(Action onFinally)`: 在源可观察对象生成`onComplete`事件或抛出异常（`onError`事件）后，执行提供的`Action`函数。'
- en: '`doFinally(Action onFinally)`: This executes the provided `Action` function
    after the source observable generates the `onComplete` event or an exception (the
    `onError` event) is raised, or the pipeline was disposed of downstream.'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doFinally(Action onFinally)`: 在源可观察对象生成`onComplete`事件或抛出异常（`onError`事件）后，或管道被下游处置后，执行提供的`Action`函数。'
- en: 'Here is demo code (see the `NonBlockingOperators` class and the `events()`
    method):'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是演示代码（见`NonBlockingOperators`类和`events()`方法）：
- en: '[PRE330]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'If we run this code, the output will be as follows:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，输出将如下所示：
- en: '![](img/B18388_Figure_15.10.jpg)'
  id: totrans-600
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_15.10.jpg)'
- en: You will also see other examples of these operators’ usage in the *Multithreading
    (scheduler)* section.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 你也将在*多线程（调度器）*部分看到这些操作符使用的其他示例。
- en: Utilities
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具
- en: 'Various useful operators (and their multiple overloaded versions) can be used
    for controlling the pipeline behavior:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用各种有用的操作符（及其多种重载版本）来控制管道行为：
- en: '`delay()`: This delays the emission for a specified period.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay()`: 这会延迟指定时间段内的发射。'
- en: '`materialize()`: This creates an `Observable` object that represents both the
    emitted values and the notifications sent.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`materialize()`: 这会创建一个`Observable`对象，它代表发射的值和发送的通知。'
- en: '`dematerialize()`: This reverses the result of the `materialize()` operator.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dematerialize()`: 这会反转`materialize()`操作符的结果。'
- en: '`observeOn()`: This specifies the `Scheduler` (thread) on which the `Observer`
    should observe the `Observable` object (see the *Multithreading (scheduler)* section).'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observeOn()`: 指定`Observer`应该观察`Observable`对象的`Scheduler`（线程）（见*多线程（调度器）*部分）。'
- en: '`serialize()`: This forces the serialization of the emitted values and notifications.'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialize()`: 强制序列化发射的值和通知。'
- en: '`subscribe()`: This subscribes to the emissions and notifications from an observable;
    various overloaded versions accept callbacks used for a variety of events, including
    `onComplete` and `onError`; only after `subscribe()` is invoked do the the values
    start flowing through the pipeline.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe()`: 订阅来自可观察对象的发射和通知；各种重载版本接受用于各种事件的回调，包括`onComplete`和`onError`；只有在调用`subscribe()`之后，值才开始通过管道流动。'
- en: '`subscribeOn()`: This subscribes the `Observer` to the `Observable` object
    asynchronously using the specified `Scheduler` (see the *Multithreading (scheduler)*
    section).'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribeOn()`: 使用指定的`Scheduler`（线程）异步地将`Observer`订阅到`Observable`对象（见*多线程（调度器）*部分）。'
- en: '`timeInterval(), timestamp()`: This converts an `Observable<T>` class that
    emits values into `Observable<Timed<T>>`, which, in turn, emits the amount of
    time elapsed between the emissions or the timestamp correspondingly.'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeInterval(), timestamp()`: 将发射值的`Observable<T>`类转换为`Observable<Timed<T>>`，它反过来发射发射之间的时间间隔或相应的时间戳。'
- en: '`timeout()`: This repeats the emissions of the source `Observable`; it generates
    an error if no emissions happen after the specified period of time.'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout()`: 重复源`Observable`的发射；如果在指定时间段内没有发生发射，则生成错误。'
- en: '`using()`: This creates a resource that is disposed of automatically along
    with the `Observable` object; it works similarly to the try-with-resources construct.'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using()`: 这创建一个资源，它将与`Observable`对象一起自动释放；它的工作方式类似于try-with-resources构造。'
- en: 'The following code contains examples of some of these operators being used
    in a pipeline (see the `NonBlockingOperators` class and the `utilities()` method):'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含一些这些操作符在管道中使用示例（请参阅`NonBlockingOperators`类和`utilities()`方法）：
- en: '[PRE337]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: 'If we run all these examples, the output will appear as follows:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行所有这些示例，输出将如下所示：
- en: '![](img/B18388_Figure_15.11.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_15.11.jpg)'
- en: As you can see, when completed, the pipeline sends the `DISPOSED` signal to
    the `using` operator (the third parameter), so the `Consumer` function we pass
    as the third parameter can dispose of the resources used by the pipeline.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当完成时，管道将`DISPOSED`信号发送到`using`操作符（第三个参数），因此我们作为第三个参数传递的`Consumer`函数可以释放管道使用的资源。
- en: Conditional and Boolean
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Conditional and Boolean
- en: 'The following operators (and their multiple overloaded versions) allow you
    to the evaluate one or more observables or emitted values and change the logic
    of the processing accordingly:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作符（及其多个重载版本）允许您评估一个或多个可观察对象或发出的值，并相应地更改处理逻辑：
- en: '`all(Predicate criteria)`: This returns `Single<Boolean>` with a `true` value,
    that is, if all the emitted values match the provided criteria.'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all(Predicate criteria)`: 这返回带有`true`值的`Single<Boolean>`，即如果所有发出的值都符合提供的标准。'
- en: '`amb()`: This accepts two or more source observables and emits values from
    only the first of them that starts emitting.'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amb()`: 这接受两个或更多源可观察对象，并只从它们中发出开始发出的第一个值。'
- en: '`contains(Object value)`: This returns `Single<Boolean>` with `true`, that
    is, if the observable emits the provided value.'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains(Object value)`: 这返回带有`true`的`Single<Boolean>`，即如果可观察对象发出提供的值。'
- en: '`defaultIfEmpty(T value)`: This emits the provided value if the source `Observable`
    does not emit anything.'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultIfEmpty(T value)`: 如果源`Observable`没有发出任何内容，则发出提供值。'
- en: '`sequenceEqual()`: This returns `Single<Boolean>` with `true`, that is, if
    the provided sources emit the same sequence; an overloaded version allows us to
    provide the equality function used for comparison.'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sequenceEqual()`: 这返回带有`true`的`Single<Boolean>`，即如果提供的源发出相同的序列；一个重载版本允许我们提供用于比较的相等函数。'
- en: '`skipUntil(Observable other)`: This discards emitted values until the provided
    `Observable other` emits a value.'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipUntil(Observable other)`: 这将丢弃发出的值，直到提供的`Observable other`发出一个值。'
- en: '`skipWhile(Predicate condition)`: This discards emitted values as long as the
    provided condition remains `true`.'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipWhile(Predicate condition)`: 只要提供的条件保持`true`，就会丢弃发出的值。'
- en: '`takeUntil(Observable other)`: This discards emitted values after the provided
    `Observable other` emits a value.'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeUntil(Observable other)`: 在提供的`Observable other`发出值后，将丢弃发出的值。'
- en: '`takeWhile(Predicate condition)`: This discards emitted values after the provided
    condition becomes `false`.'
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeWhile(Predicate condition)`: 在提供的条件变为`false`后，将丢弃发出的值。'
- en: 'The following code contains a few demo examples (see the `NonBlockingOperators`
    class and the `conditional()` method):'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码包含一些演示示例（请参阅`NonBlockingOperators`类和`conditional()`方法）：
- en: '[PRE354]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: Backpressure
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Backpressure
- en: 'So, we discussed and demonstrated the **backpressure** effect and the possible
    drop strategy in the *Cold versus hot* section. The other strategy might be as
    follows:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在*冷与热*部分讨论并演示了**背压**效果和可能的丢弃策略。另一种策略可能如下：
- en: '[PRE371]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: The buffering strategy allows you to define the buffer size and provide a function
    that can be executed if the buffer overflows. The latest strategy tells the values
    producer to pause (when the consumer cannot process the emitted values on time)
    and emit the next value on request.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲策略允许您定义缓冲区大小，并提供一个在缓冲区溢出时可以执行的功能。最新的策略告诉值生产者在消费者无法及时处理发出的值时暂停，并在请求时发出下一个值。
- en: Note that the backpressure operators are available only in the `Flowable` class.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，背压操作符仅在`Flowable`类中可用。
- en: Connectable
  id: totrans-672
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Connectable
- en: 'The operators of this category allow us to connect observables and, thus, achieve
    more precisely controlled subscription dynamics:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 此类操作符允许我们连接可观察对象，从而实现更精确的订阅动态控制：
- en: '`publish()`: This converts an `Observable` object into a `ConnectableObservable`
    object.'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish()`: 这将`Observable`对象转换为`ConnectableObservable`对象。'
- en: '`replay()`: This returns a `ConnectableObservable` object that repeats all
    the emitted values and notifications every time a new `Observer` subscribes.'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replay()`: 这返回一个`ConnectableObservable`对象，每次新的`Observer`订阅时都会重复所有发出的值和通知。'
- en: '`connect()`: This instructs a `ConnectableObservable` object to begin emitting
    values to the subscribers.'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect()`: 这指示`ConnectableObservable`对象开始向订阅者发出值。'
- en: '`refCount()`: This converts a `ConnectableObservable` object into an `Observable`
    object.'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refCount()`: 这将`ConnectableObservable`对象转换为`Observable`对象。'
- en: We have demonstrated how `ConnectableObservable` works in the *Cold versus hot*
    section. One principal difference between `ConnectableObservable` and `Observable`
    is that `ConnectableObservable` does not start emitting values until its `connect`
    operator has been called.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在“冷与热”部分展示了`ConnectableObservable`的工作原理。`ConnectableObservable`与`Observable`之间的一个主要区别是，`ConnectableObservable`不会开始发出值，直到其`connect`操作符被调用。
- en: Multithreading (scheduler)
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程（调度器）
- en: By default, RxJava is single-threaded. This means that the source observable
    and all its operators notify the observers on the same thread that the `subscribe()`
    operator is called.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，RxJava是单线程的。这意味着源可观察对象及其所有操作符都在调用`subscribe()`操作符的同一线程上通知观察者。
- en: Тhere are two operators, `observeOn()` and `subscribeOn()`, that allow you to
    move the execution of individual actions to a different thread. These methods
    take a `Scheduler` object as an argument that, well, schedules the individual
    actions to be executed on a different thread.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个操作符，`observeOn()`和`subscribeOn()`，允许您将单个操作的执行移动到不同的线程。这些方法接受一个`Scheduler`对象作为参数，该参数将单个操作调度到不同的线程上执行。
- en: The `subscribeOn()` operator declares which scheduler should emit the values.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn()`操作符声明了哪个调度器应该发出值。'
- en: The `observeOn()` operator declares which scheduler should observe and process
    values.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '`observeOn()`操作符声明了哪个调度器应该观察和处理值。'
- en: 'The `Schedulers` class contains factory methods that create `Scheduler` objects
    with different life cycles and performance configurations:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers`类包含创建具有不同生命周期和性能配置的`Scheduler`对象的工厂方法：'
- en: '`computation()`: This creates a scheduler based on a bounded thread pool with
    a size up to the number of available processors; it should be used for CPU-intensive
    computations. Use `Runtime.getRuntime().availableProcessors()` to avoid using
    more of these types of schedulers than available processors; otherwise, the performance
    might become degraded because of the overhead of the thread-context switching.'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`computation()`: 这创建了一个基于有界线程池的调度器，其大小最多可达可用处理器的数量；它应该用于CPU密集型计算。使用`Runtime.getRuntime().availableProcessors()`来避免使用比可用处理器更多的此类调度器；否则，由于线程上下文切换的开销，性能可能会下降。'
- en: '`io()`: This creates a scheduler based on an unbounded thread pool used for
    I/O-related work, such as working with files and databases in general when the
    interaction with the source is blocking by nature; avoid using it otherwise because
    it might spin too many threads and negatively affect performance and memory usage.'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io()`: 这创建了一个基于无界线程池的调度器，用于I/O相关的工作，例如在源交互本质上是阻塞的情况下，通常用于处理文件和数据库；避免在其他情况下使用它，因为它可能会启动太多线程，从而对性能和内存使用产生负面影响。'
- en: '`newThread()`: This creates a new thread every time and does not use any pool;
    it is an expensive way to create a thread, so you are expected to know exactly
    what the reason is for using it.'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newThread()`: 每次都会创建一个新线程，并且不使用任何池；这是一种昂贵的创建线程的方式，因此您应该确切知道使用它的原因。'
- en: '`single()`: This creates a scheduler based on a single thread that executes
    all the tasks sequentially; this is useful when the sequence of the execution
    matters.'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`single()`: 这根据单个线程创建一个调度器，该线程按顺序执行所有任务；当执行顺序很重要时很有用。'
- en: '`trampoline()`: This creates a scheduler that executes tasks in a first-in-first-out
    manner; this is useful for executing recursive algorithms.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trampoline()`: 这创建了一个以先入先出方式执行任务的调度器；这对于执行递归算法很有用。'
- en: '`from(Executor executor)`: This creates a scheduler based on the provided executor
    (thread pool), which allows for better control over the max number of threads
    and their life cycles.'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from(Executor executor)`: 这根据提供的执行器（线程池）创建一个调度器，这允许更好地控制最大线程数及其生命周期。'
- en: 'In [*Chapter 8*](B18388_08_ePub.xhtml#_idTextAnchor187), *Multithreading and
    Concurrent Processing*, we talked about thread pools. To remind you, here are
    the pools we discussed:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B18388_08_ePub.xhtml#_idTextAnchor187)，*多线程和并发处理*中，我们讨论了线程池。为了提醒您，以下是讨论的线程池：
- en: '[PRE375]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: As you can see, some of the other factory methods of the `Schedulers` class
    are backed by one of these thread pools, and they serve as just a simpler and
    shorter expression of a thread pool declaration. To make the examples simpler
    and more comparable, we are only going to use a `computation()` scheduler. Let’s
    look at the basics of parallel/concurrent processing in RxJava.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Schedulers` 类的一些其他工厂方法背后是这些线程池之一，它们只是线程池声明的更简单、更简短的表示。为了使示例更简单、更具有可比性，我们只将使用
    `computation()` 调度器。让我们看看 RxJava 中并行/并发处理的基本知识。
- en: 'The following code is an example of delegating CPU-intensive calculations to
    dedicated threads (see the `Scheduler` class and the `parallel1()` method):'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是将 CPU 密集型计算委托给专用线程的示例（参见 `Scheduler` 类和 `parallel1()` 方法）：
- en: '[PRE380]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'In this example, we decided to create a sub-flow of characters from each emitted
    word and let a dedicated thread process the characters of each word. The output
    of this example appears as follows:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们决定从每个发出的单词创建一个子流，并让一个专用线程处理每个单词的字符。本例的输出如下所示：
- en: '![](img/B18388_Figure_15.12.jpg)'
  id: totrans-713
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_15.12.jpg)'
- en: As you can see, the main thread was used to emit the words, and the characters
    of each word were processed by a dedicated thread. Please note that although in
    this example the sequence of the results coming to the `subscribe()` operation
    corresponds to the sequence the words and characters were emitted, in real-life
    cases, the calculation time of each value will not be the same. So, there is no
    guarantee that the results will come in the same sequence.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主线程用于发出单词，每个单词的字符由一个专用线程处理。请注意，尽管在这个示例中，到达 `subscribe()` 操作的结果序列与单词和字符发出的序列相对应，但在实际情况下，每个值的计算时间可能不同。因此，不能保证结果将以相同的顺序到来。
- en: 'If needed, we can put each word emission on a dedicated non-main thread too,
    so the main thread can be free to do anything else. For example, note the following
    (see the `Scheduler` class and the `parallel2()` method):'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们还可以将每个单词的发出放在一个专用的非主线程上，这样主线程就可以自由地做其他任何事情。例如，注意以下内容（参见 `Scheduler` 类和
    `parallel2()` 方法）：
- en: '[PRE393]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: 'The output of this example is as follows:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的输出如下：
- en: '![](img/B18388_Figure_15.13.jpg)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_15.13.jpg)'
- en: As you can see, the main thread no longer emits the words.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，主线程不再发出单词。
- en: 'In RxJava 2.0.5, a new, simpler way of parallel processing was introduced,
    similar to parallel processing in the standard Java 8 streams. Using `ParallelFlowable`,
    the same functionality can be achieved as follows (see the `Scheduler` class and
    the `parallel3()` method):'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJava 2.0.5 中，引入了一种新的、更简单的并行处理方式，类似于标准 Java 8 流中的并行处理。使用 `ParallelFlowable`，可以以以下方式实现相同的功能（参见
    `Scheduler` 类和 `parallel3()` 方法）：
- en: '[PRE404]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: 'As you can see, the `ParallelFlowable` object is created by applying the `parallel()`
    operator to the regular `Flowable` operator. Then, the `runOn()` operator tells
    the created observable to use the `computation()` scheduler to emit the values.
    Please note that there is no need to set another scheduler (for processing the
    characters) inside the `flatMap()` operator. It can be set outside it – just in
    the main pipeline, which makes the code simpler. The result looks like this:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ParallelFlowable` 对象是通过将 `parallel()` 操作符应用于常规的 `Flowable` 操作符来创建的。然后，`runOn()`
    操作符指示创建的观察者使用 `computation()` 调度器来发出值。请注意，在 `flatMap()` 操作符内部无需设置另一个调度器（用于处理字符）。它可以在外部设置——只需在主管道中，这使得代码更简单。结果如下所示：
- en: '![Text'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '![文本'
- en: Description automatically generated](img/B18388_Figure_15.14.png)
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B18388_Figure_15.14.png)
- en: 'As for the `subscribeOn()` operator, its location in the pipeline does not
    play any role. Wherever it is placed, it still tells the observable which scheduler
    should emit the values. Here is an example (see the `Scheduler` class and the
    `subscribeOn1()` method):'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `subscribeOn()` 操作符，它在管道中的位置不起任何作用。无论它放在哪里，它仍然告诉观察者哪个调度器应该发出值。以下是一个示例（参见
    `Scheduler` 类和 `subscribeOn1()` 方法）：
- en: '[PRE416]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: 'The result looks like this:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/B18388_Figure_15.15.jpg)'
  id: totrans-755
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_15.15.jpg)'
- en: 'Even if we change the location of the `subscribeOn()` operator, as shown in
    the following example, the result does not change (see the `Scheduler` class and
    the `subscribeOn2()` method):'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将`subscribeOn()`操作符的位置改变，如以下示例所示，结果也不会改变（参见`Scheduler`类和`subscribeOn2()`方法）：
- en: '[PRE423]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: 'Finally, here is the example with both operators (see the `Scheduler` class
    and the `subscribeOnAndObserveOn()` method):'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是包含两个操作符的示例（参见`Scheduler`类和`subscribeOnAndObserveOn()`方法）：
- en: '[PRE430]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'Now the result shows that two threads are used: one for subscribing and another
    for observing:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的结果显示使用了两个线程：一个用于订阅，另一个用于观察：
- en: '![](img/B18388_Figure_15.16.jpg)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_15.16.jpg)'
- en: This concludes our short overview of RxJava, which is a big and still-growing
    library with a lot of possibilities, many of which we just did not have space
    in this book to review. We encourage you to try and learn it because it seems
    that reactive programming is the way modern data processing is heading.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对RxJava的简要概述，RxJava是一个庞大且仍在增长的库，具有许多可能性，其中许多我们在这本书中没有空间进行回顾。我们鼓励你尝试并学习它，因为似乎响应式编程是现代数据处理的发展方向。
- en: In the following chapters, we will demonstrate how to build reactive applications
    (microservices) using Spring Boot and Vert.x.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将演示如何使用Spring Boot和Vert.x构建响应式应用程序（微服务）。
- en: Summary
  id: totrans-777
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned what reactive programming is and what its main
    concepts are: asynchronous, non-blocking, responsive, and more. Reactive streams
    were introduced and explained in simple terms, along with the RxJava library,
    which is the first solid implementation that supports reactive programming principles.'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了响应式编程是什么以及其主要概念：异步、非阻塞、响应式等。以简单术语介绍了响应式流，并解释了RxJava库，这是第一个支持响应式编程原则的稳定实现。
- en: Now you can write code for asynchronous processing using reactive programming.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用响应式编程编写异步处理代码。
- en: 'In the next chapter, we will talk about microservices as the foundation for
    creating reactive systems, and we will review another library that successfully
    supports reactive programming: **Vert.x**. We will use it to demonstrate how various
    microservices can be built.'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论微服务作为创建响应式系统的基石，并回顾另一个成功支持响应式编程的库：**Vert.x**。我们将使用它来演示如何构建各种微服务。
- en: Quiz
  id: totrans-781
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: 'Select all the correct statements:'
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有正确的陈述：
- en: Asynchronous processing always provides results later.
  id: totrans-783
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步处理总是比阻塞调用提供结果晚。
- en: Asynchronous processing always provides responses quickly.
  id: totrans-784
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步处理总是能快速提供响应。
- en: Asynchronous processing can use parallel processing.
  id: totrans-785
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步处理可以使用并行处理。
- en: Asynchronous processing always provides results faster than a blocking call.
  id: totrans-786
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步处理总是比阻塞调用提供结果更快。
- en: Can `CompletableFuture` be used without using a thread pool?
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在不使用线程池的情况下使用`CompletableFuture`吗？
- en: What does the *nio* in `java.nio` stand for?
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.nio`中的`nio`代表什么？'
- en: Is an `event` loop the only design that supports a non-blocking API?
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`event`循环是唯一支持非阻塞API的设计吗？'
- en: What does the *Rx* in RxJava stand for?
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RxJava中的`Rx`代表什么？
- en: Which Java package of the **Java Class Library** (**JCL**) supports reactive
    streams?
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Java类库（JCL**）的哪个Java包支持响应式流？'
- en: 'Select all classes from the following list that can represent an observable
    in a reactive stream:'
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下列表中选择所有可以表示响应式流中可观察对象的类：
- en: '`Flowable`'
  id: totrans-793
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Flowable`'
- en: '`Probably`'
  id: totrans-794
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Probably`'
- en: '`CompletableFuture`'
  id: totrans-795
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CompletableFuture`'
- en: '`Single`'
  id: totrans-796
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Single`'
- en: How do you know that a particular method (operator) of the `Observable` class
    is blocking?
  id: totrans-797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何知道`Observable`类的特定方法（操作符）是阻塞的？
- en: What is the difference between a cold and a hot observable?
  id: totrans-798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冷和热可观察对象之间的区别是什么？
- en: The `subscribe()` method of `Observable` returns a `Disposable` object. What
    happens when the `dispose()` method is called on this object?
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Observable`的`subscribe()`方法返回一个`Disposable`对象。当在这个对象上调用`dispose()`方法时会发生什么？'
- en: 'Select all the names of the methods that create an `Observable` object:'
  id: totrans-800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有创建`Observable`对象的方法的名称：
- en: '`interval()`'
  id: totrans-801
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`interval()`'
- en: '`new()`'
  id: totrans-802
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new()`'
- en: '`generate()`'
  id: totrans-803
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`generate()`'
- en: '`defer()`'
  id: totrans-804
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`defer()`'
- en: Name two transforming `Observable` operators.
  id: totrans-805
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两个转换`Observable`操作符。
- en: Name two filtering `Observable` operators.
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两个过滤`Observable`操作符。
- en: Name two backpressure-processing strategies.
  id: totrans-807
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两种背压处理策略。
- en: Name two `Observable` operators that allow you to add threads to the pipeline
    processing.
  id: totrans-808
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两个允许你向管道处理中添加线程的`Observable`操作符。
