- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Putting it All Together
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: In previous chapters, we’ve been covering Jakarta EE APIs and specifications
    individually. In this chapter, however, we will develop an application using popular
    Jakarta EE APIs, illustrating how to use them together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们分别介绍了 Jakarta EE API 和规范。然而，在本章中，我们将使用流行的 Jakarta EE API 开发一个应用，展示如何将它们一起使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The sample application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样例应用
- en: Creating customer data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建客户数据
- en: Viewing customer data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看客户数据
- en: Updating customer data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新客户数据
- en: Deleting customer data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除客户数据
- en: Implementing pagination
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现分页
- en: By the end of this chapter, you will have learned how to develop a complete
    application combining several popular Jakarta EE APIs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何开发一个结合了几个流行的 Jakarta EE API 的完整应用。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch15_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch15_src)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch15_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch15_src)
- en: The sample application
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样例应用
- en: The sample application that we will develop in this chapter is a typical CRUD
    (Create, Read, Update and Delete) application. We will be using CDI to develop
    our controllers, Jakarta Persistence as our Object-Relational Mapping tool, leveraging
    Jakarta Enterprise Beans to handle transactions, plus Jakarta Faces to develop
    the user interface. We’ll cover some advanced Jakarta Faces features such as developing
    custom converters and implementing custom **Expression Language** (**EL**) Resolvers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将开发一个典型的 CRUD（创建、读取、更新和删除）应用示例。我们将使用 CDI 来开发我们的控制器，使用 Jakarta Persistence
    作为我们的对象关系映射工具，利用 Jakarta Enterprise Beans 来处理事务，以及使用 Jakarta Faces 来开发用户界面。我们将介绍一些高级的
    Jakarta Faces 功能，例如开发自定义转换器和实现自定义**表达式语言**（**EL**）解析器。
- en: The application is a web-based application used to maintain customers in a database.
    It provides functionality to view all customers, views details for a single customer,
    and updates and deletes new customers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用是一个基于 Web 的应用，用于在数据库中维护客户信息。它提供了查看所有客户、查看单个客户的详细信息以及更新和删除新客户的功能。
- en: The landing page
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首页
- en: Our application’s landing page is a very simple Facelets page, that has a simple
    command link that invokes a method on the main controller, as shown in the following
    snippet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序首页是一个非常简单的 Facelets 页面，它有一个简单的命令链接，该链接会在主控制器上调用方法，如下面的代码片段所示。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The main controller for our application is a class called `CustomerController`.
    It is implemented as a session-scoped CDI named bean. When the user clicks on
    the link on the page, our Facelets page invokes a method called `listSetup()`
    on our controller. This method does some initialization and then directs the user
    to a page displaying all existing customers, as illustrated in the following code
    segment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的主要控制器是一个名为 `CustomerController` 的类。它被实现为一个会话作用域的 CDI 命名豆。当用户点击页面上的链接时，我们的
    Facelets 页面会调用控制器上的 `listSetup()` 方法。这个方法进行一些初始化，然后将用户引导到显示所有现有客户的页面，如下面的代码段所示。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `listSetup()` method in our controller invokes a `reset()` method which
    is used for pagination (more on that later), then returns a string matching the
    path of the page that displays the list of existing customers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们控制器中的 `listSetup()` 方法调用一个 `reset()` 方法，用于分页（稍后会有更多介绍），然后返回一个与显示现有客户列表页面路径匹配的字符串。
- en: The first time we navigate to the page displaying the list of customers, we
    simply display a message stating that no customers have been found, as the CUSTOMERS
    table in the database is empty.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次导航到显示客户列表的页面时，我们简单地显示一条消息，说明没有找到客户，因为数据库中的 CUSTOMERS 表是空的。
- en: "![Figure 15.1 – \uFEFF Empty Customer List](img/B21231_15_01.jpg)"
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1 – 空客户列表](img/B21231_15_01.jpg)'
- en: Figure 15.1 – Empty Customer List
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 空客户列表
- en: Our Facelets page has an `<h:outputText>` tag that is rendered only if the list
    of customers is empty.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Facelets 页面有一个 `<h:outputText>` 标签，仅在客户列表为空时渲染。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our Facelets page also has a command button labeled **New Customer**, which
    invokes logic on our controller to insert Customer data into the database.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Facelets 页面还有一个标记为 **New Customer** 的命令按钮，它会在控制器上调用逻辑以将客户数据插入数据库。
- en: Creating customer data
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建客户数据
- en: The command button on the Facelets page displaying a list of customers invokes
    a method called `createSetup()` on our `CustomerController`, which does some initialization
    before displaying a form allowing the user to enter data for a new customer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显示客户列表的 Facelets 页面上的命令按钮调用 `CustomerController` 上的 `createSetup()` 方法，该方法在显示允许用户输入新客户数据的表单之前进行一些初始化。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, the `createSetup()` method invokes the `reset()` method, which
    simply clears some data from memory and performs some logic for pagination, then
    creates a new `Customer` object. The `Customer` class is a straightforward JPA
    Entity, it has one too many relationships with two additional JPA Entities, `Address`
    and `Telephone`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`createSetup()` 方法调用了 `reset()` 方法，该方法简单地从内存中清除一些数据并执行一些分页逻辑，然后创建一个新的
    `Customer` 对象。`Customer` 类是一个简单的 JPA 实体，它与两个额外的 JPA 实体 `Address` 和 `Telephone`
    有一个多对多的关系。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `createSetup()` method initializes the lists of `Address` and `Telephone`
    on the new instance of `Customer` to instances of `ArrayList` containing a single
    element of the corresponding type, then navigates to the Facelets page where the
    user can enter data for the new customer. See *Figure 15**.2*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`createSetup()` 方法初始化 `Customer` 新实例上的 `Address` 和 `Telephone` 列表，将其设置为包含相应类型单个元素的
    `ArrayList` 实例，然后导航到用户可以输入新客户数据的 Facelets 页面。见 *图 15**.2*。'
- en: '![Figure 15.2 – Entering New Customer data](img/B21231_15_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.2 – 输入新客户数据](img/B21231_15_02.jpg)'
- en: Figure 15.2 – Entering New Customer data
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – 输入新客户数据
- en: The markup for our page is a fairly standard Facelets page, it implements some
    custom logic to populate all drop-down menus on the page, for example, to obtain
    the options on the `addressTypeItemsAvailableSelectOne()`, on a CDI bean named
    `AddressTypeController`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们页面的标记是一个相当标准的 Facelets 页面，它实现了一些自定义逻辑来填充页面上的所有下拉菜单，例如，获取 `addressTypeItemsAvailableSelectOne()`
    上的选项，在一个名为 `AddressTypeController` 的 CDI 实体上。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `AddressTypeController.getAddressTypeItemsAvailableSelectOne()` method invokes
    a trivial method on a `getSelectItems()` on a utility class called `JSFUtil`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddressTypeController.getAddressTypeItemsAvailableSelectOne()` 方法在名为 `JSFUtil`
    的实用类上的 `getSelectItems()` 上调用一个简单的方法。'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `JSFUtil.getSelectItems()` method iterates through the returned entities
    and returns an array of `SelectItem`, using the return value of the `toString()`
    method of each entities as the label, and the entity itself as the value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSFUtil.getSelectItems()` 方法遍历返回的实体，并返回一个 `SelectItem` 数组，使用每个实体的 `toString()`
    方法的返回值作为标签，实体本身作为值。'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The logic to populate other drop-down menus on the page is very similar.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 填充页面上的其他下拉菜单的逻辑非常相似。
- en: 'The **Save** button on the new customer page is implemented as a command button:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 新客户页面上的 **保存** 按钮实现为一个命令按钮：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The command button invokes a method called `create()` on our `CustomerController`
    class.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 命令按钮在 `CustomerController` 类中调用一个名为 `create()` 的方法。
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `CustomerController.create()` method simply invokes a similarly named `create()`
    method on our data access object, the DAO method simply inserts a new row into
    the `CUSTOMERS`, `ADDRESSES` and `TELEPHONES` database tables, which correspond
    to the `Customer`, `Address` and `Telephone` Jakarta Persistence Entities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerController.create()` 方法简单地调用我们数据访问对象（DAO）中同名的 `create()` 方法，DAO 方法简单地在一个新的行中插入
    `CUSTOMERS`、`ADDRESSES` 和 `TELEPHONES` 数据库表，这些表分别对应于 `Customer`、`Address` 和 `Telephone`
    Jakarta Persistence 实体。'
- en: The `CustomerrController.create()` method then displays a success message to
    the user if the operation was successful, or an error message if the operation
    failed. It then directs the user to the page listing all customer objects. See
    *Figure 15**.3*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerrController.create()` 方法在操作成功时向用户显示一条成功消息，如果操作失败则显示一条错误消息。然后它将用户导向列出所有客户对象的页面。见
    *图 15**.3*。'
- en: "![Figure 15.3 – \uFEFFPopulated Customer List](img/B21231_15_03.jpg)"
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.3 – 已填充的客户列表](img/B21231_15_03.jpg)'
- en: Figure 15.3 – Populated Customer List
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 – 已填充的客户列表
- en: Now that we have created a customer, our **Customer List** page displays a data
    table listing the customer we just created. It contains command links for viewing,
    editing or deleting each customer. We will cover how to view existing customer
    data in the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个客户，我们的 **客户列表** 页面显示一个数据表，列出我们刚刚创建的客户。它包含用于查看、编辑或删除每个客户的命令链接。我们将在下一节中介绍如何查看现有客户数据。
- en: Viewing customer data
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看客户数据
- en: 'As mentioned in the previous section, each row on the data table on the **Customer
    List** page has a **View** command link. The markup for the command link looks
    like the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**客户列表**页面上的数据表中的每一行都有一个**查看**命令链接。命令链接的标记如下：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice the `<f:param>` tag inside the command link. This tag adds a request
    parameter to the HTTP request created when the user clicks the button.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令链接内的`<f:param>`标签。此标签在用户点击按钮时创建的HTTP请求中添加一个请求参数。
- en: We are using an advanced Jakarta Faces technique to dynamically generate the
    value of the request parameter. We are using a custom Expression Language resolver,
    so that we can implement custom logic to our Jakarta Faces expression language.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用高级的Jakarta Faces技术来动态生成请求参数的值。我们使用自定义的表达式语言解析器，这样我们就可以在我们的Jakarta Faces表达式语言中实现自定义逻辑。
- en: In order to use a custom Expression Language resolver, we need to declare it
    in our application’s `faces-config.xml` `configuration` file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用自定义的表达式语言解析器，我们需要在我们的应用程序的`faces-config.xml`配置文件中声明它。
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, we register our custom Expression Language resolver by placing
    its fully qualified name inside the `<el-resolver>` tag in faces-config.xml.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们通过在faces-config.xml中的`<el-resolver>`标签内放置其完全限定名称来注册我们的自定义表达式语言解析器。
- en: The details of our Expression Language resolver are out of scope, suffice to
    say that its `getValue()` method is invoked automatically when resolving the value
    attribute of `<f:param>`, it uses Java’s reflection API to determine which method
    to call. In our specific example, it calls a method call `getConvertedAsString()`
    in a class called `JsfUtil`, passing an instance of a custom converter called
    `CustomerConverter` as a parameter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表达式语言解析器的详细信息超出了范围，只需说，它的`getValue()`方法在解析`<f:param>`的值属性时自动调用，它使用Java的反射API来确定要调用哪个方法。在我们的具体示例中，它调用名为`JsfUtil`的类中的`getConvertedAsString()`方法，并将一个名为`CustomerConverter`的自定义转换器的实例作为参数传递。
- en: The following code snippet shows the signature of the `getValue()` method of
    our custom `ELResolver`, the GitHub repository for this book contains the complete
    source code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们的自定义`ELResolver`的`getValue()`方法的签名，本书的GitHub仓库包含完整的源代码。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After all is said and done, our `ELResolver` returns the value of the primary
    key for the corresponding `Customer` object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都完成后，我们的`ELResolver`返回相应`Customer`对象的键值。
- en: When the user clicks on the `CustomerController.detailSetup()` is invoked, which
    performs some initialization before displaying customer information on the browser.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`CustomerController.detailSetup()`时，它被调用，在浏览器上显示客户信息之前执行一些初始化操作。
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `CustomerController.detailSetup()` method simply delegates most of its logic
    to the `scalarSetup()` method, which is used every time we need to display information
    about a single customer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerController.detailSetup()`方法简单地将其大部分逻辑委托给`scalarSetup()`方法，该方法在每次我们需要显示单个客户信息时使用。'
- en: '`CustomerController.scalarSetup()` invokes `JsfUtil.getObjectFromRequestParameter()`,
    passing the request parameter name, and our custom Jakarta Faces converter.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerController.scalarSetup()`调用`JsfUtil.getObjectFromRequestParameter()`，传递请求参数名称和我们的自定义Jakarta
    Faces转换器。'
- en: '`JSFUtil.getObjectFromRequestParameter()`, in turn, uses our custom converter
    to obtain an instance of our `Customer` object.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSFUtil.getObjectFromRequestParameter()`，反过来，使用我们的自定义转换器来获取我们的`Customer`对象的一个实例。'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see, `JSFUtil` invokes the `getAsObject()` method of our custom Faces
    converter. Our converter, in turn, obtains our session-scoped `CustomerController`
    instance via the Jakarta Faces API, then invokes its `findCustomer()` method to
    obtain the corresponding instance of the `Customer` Jakarta Persistence entity,
    as shown in the following example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`JSFUtil`调用了我们自定义的Faces转换器的`getAsObject()`方法。我们的转换器反过来，通过Jakarta Faces
    API获取我们的会话作用域的`CustomerController`实例，然后调用它的`findCustomer()`方法来获取相应的`Customer`
    Jakarta Persistence实体实例，如下面的示例所示。
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once we obtain the `Customer` instance, control is passed to the **Customer
    Detail** page, which is a basic Facelets page that displays customer information.
    See *Figure 15**.4*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了`Customer`实例，控制权传递到**客户详情**页面，这是一个基本的Facelets页面，用于显示客户信息。见*图15*.4。
- en: "![Figure 15.4 – \uFEFFThe Customer Detail page](img/B21231_15_04.jpg)"
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4 – 客户详情页面](img/B21231_15_04.jpg)'
- en: Figure 15.4 – The Customer Detail page
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 – 客户详情页面
- en: Now that we’ve seen how we can display customer information, we’ll focus our
    attention on updating existing customer data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何显示客户信息，我们将关注更新现有客户数据。
- en: Updating customer data
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新客户数据
- en: 'There isn’t much we haven’t already discussed when it comes to updating customer
    data. The command link labeled **Edit** on each row navigates to the **Edit Customer**
    page. The markup for the command link looks as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新客户数据方面，我们还没有太多未讨论的内容。每行上的标记为 **编辑** 的命令链接导航到 **编辑客户** 页面。命令链接的标记如下：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The command link uses the same technique to pass involving a custom Expression
    Language resolver we discussed in the previous section to pass the id of the customer
    to update as a request parameter, then invokes the `CustomerController.editSetup()`
    method which performs some initialization before directing the user to the `CustomerController`
    CDI bean are shown in the following code snippet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 命令链接使用与之前章节中讨论的相同的技术，包括一个自定义的表达式语言解析器，将需要更新的客户的 ID 作为请求参数传递，然后调用 `CustomerController.editSetup()`
    方法，该方法执行一些初始化操作，然后引导用户到 `CustomerController` CDI 实例。以下代码片段显示了这些操作：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the `editSetup()` method follows the same pattern we discussed
    when we covered how to navigate to the read-only `scalarSetup()` method to obtain
    the appropriate instance of the Customer entity, then directs the user to the
    **Edit** **Customer** page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`editSetup()` 方法遵循我们在介绍如何导航到只读的 `scalarSetup()` 方法以获取客户实体的适当实例时讨论的相同模式，然后引导用户到
    **编辑** **客户** 页面。
- en: The markup for the **Edit Customer** page is fairly trivial. It includes a number
    of input fields using binding expressions mapping to different fields on the Customer
    entity. It uses the same technique we discussed in the Creating Customer Data
    section to populate all drop-downs on the page. Upon successful navigation, the
    **Edit Customer** page is rendered as illustrated in *Figure 15**.5*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**编辑客户** 页面的标记相当简单。它包括多个输入字段，使用绑定表达式映射到客户实体的不同字段。它使用我们在创建客户数据部分讨论的技术来填充页面上的所有下拉列表。在成功导航后，**编辑客户**
    页面如 *图 15.5* 所示渲染。'
- en: '![Figure 15.5 – Edit Customer page](img/B21231_15_05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.5 – 编辑客户页面](img/B21231_15_05.jpg)'
- en: Figure 15.5 – Edit Customer page
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5 – 编辑客户页面
- en: 'The `edit()` method on our `CustomerController` class. The markup Our DAO retrieves
    the customer:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `CustomerController` 类上的 `edit()` 方法。标记我们的 DAO 获取客户：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `edit()` method on `CustomerController`, which looks as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerController` 上的 `edit()` 方法如下所示：'
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `edit()` method on `CustomerController` performs a sanity check to make
    sure the ID of the customer in memory matches the ID passed as a request parameter,
    and displays an error message if this is not the case. If the sanity check is
    successful, the method invokes the `edit()` method on the `CustomerDao` data access
    object, as illustrated in the following code snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerController` 上的 `edit()` 方法执行一个合理性检查，以确保内存中客户的 ID 与作为请求参数传递的 ID 匹配，如果不匹配则显示错误消息。如果合理性检查成功，该方法将调用
    `CustomerDao` 数据访问对象上的 `edit()` 方法，如下面的代码片段所示：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `edit()` method on our DAO invokes the `merge()` method on its injected
    `EntityManager`, which updates the corresponding customer data in the database.
    If there is an exception, the method rolls back the transaction and then attempts
    to retrieve the customer from the database. In case the `edit()` method can’t
    find the customer in the database, it displays an error message stating that the
    customer doesn’t exist anymore. The reason why this logic is necessary is because
    another user or process may have deleted our customer from the database while
    our user was updating it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 DAO 上的 `edit()` 方法在其注入的 `EntityManager` 上调用 `merge()` 方法，从而更新数据库中相应的客户数据。如果发生异常，该方法将回滚事务然后尝试从数据库中检索客户。如果
    `edit()` 方法在数据库中找不到客户，它将显示一条错误消息，指出客户已不再存在。这种逻辑之所以必要，是因为在我们用户更新客户信息的同时，另一个用户或进程可能已将我们的客户从数据库中删除。
- en: If the customer data is successfully updated, the user is directed to the **Customer
    Detail** page, displaying updated customer data. See *Figure 15**.6*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户数据成功更新，用户将被引导到 **客户详情** 页面，显示更新后的客户数据。见 *图 15.6*。
- en: '![Figure 15.6 – Customer Detail page displaying updated customer data](img/B21231_15_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.6 – 显示更新客户数据的客户详情页面](img/B21231_15_06.jpg)'
- en: Figure 15.6 – Customer Detail page displaying updated customer data
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.6 – 显示更新客户数据的客户详情页面
- en: In the next section, we will discuss how our sample application deletes customer
    data from the database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论我们的示例应用程序如何从数据库中删除客户数据。
- en: Deleting customer data
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除客户数据
- en: The **Customer List** page has a link labeled Destroy for each element on the
    table.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户列表**页面上的每个表元素都有一个标记为“删除”的链接。'
- en: "![Figure 15.7\uFEFF – Customer List page](img/B21231_15_07.jpg)"
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7 – 客户列表页面](img/B21231_15_07.jpg)'
- en: Figure 15.7 – Customer List page
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 – 客户列表页面
- en: The markup for the **Delete** command link follows the previously discussed
    pattern of setting a request parameter with the ID of the customer to delete,
    as seen in the following example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除**命令链接的标记遵循之前讨论的模式，即设置一个带有要删除的客户ID的请求参数，如下例所示。'
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When clicked, the command link invokes the `destroy()` method on `CustomerController`,
    as shown in the following example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击时，命令链接会在以下示例中调用`CustomerController`上的`destroy()`方法。
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `destroy()` method in `CustomerController` simply invokes the `destroy()`
    method on `CustomerDAO`, passing the customer ID as obtained from the request
    parameter. The controller then navigates back to the **Customer List** page and
    displays a success message upon successful deletion. If there are any exceptions
    when attempting to delete the customer, they are handled appropriately.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerController`中的`destroy()`方法简单地调用`CustomerDAO`上的`destroy()`方法，传递从请求参数中获取的客户ID。控制器随后导航回**客户列表**页面，并在成功删除后显示一个成功消息。如果在尝试删除客户时发生任何异常，它们将被适当地处理。'
- en: Our DAO retrieves the customer from the database, using the ID it receives as
    a parameter, performs a sanity check to make sure the data wasn’t deleted by another
    process and then deletes the customer from the database by invoking the `remove()`
    method on the injected `EntityManager` instance, as illustrated below.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的DAO使用接收到的ID从数据库中检索客户，执行一个检查以确保数据没有被其他进程删除，然后通过在注入的`EntityManager`实例上调用`remove()`方法从数据库中删除客户，如下所示。
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After successfully deleting a customer from the database, the **Customer List**
    is displayed, containing a success message indicating the deletion was successful.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功从数据库中删除客户后，显示的是**客户列表**，其中包含一个成功消息，表明删除操作成功。
- en: '![Figure 15.8 – Successful deletion](img/B21231_15_08.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8 – 删除成功](img/B21231_15_08.jpg)'
- en: Figure 15.8 – Successful deletion
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 – 删除成功
- en: We have now seen how our sample application creates, updates, displays and deletes
    data, including some advanced techniques it uses involving custom converters and
    a custom Expression Language resolver.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了我们的示例应用程序如何创建、更新、显示和删除数据，包括它使用的某些高级技术，例如自定义转换器和自定义表达式语言解析器。
- en: Our sample application also contains logic to handle pagination when there is
    a large number command link is displayed if thereof customers in the database.
    We will discuss this functionality in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序还包含处理大量命令链接显示时分页的逻辑。我们将在下一节中讨论此功能。
- en: Implementing pagination
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现分页
- en: The standard Jakarta Faces data table component simply displays all elements
    on a list on the page. This works fine when we have a small number of elements
    to display, but becomes cumbersome when displaying lots of elements. In many production
    environments, it is not uncommon to have to display hundreds of elements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的Jakarta Faces数据表组件简单地显示页面上的列表中的所有元素。当我们需要显示少量元素时，这工作得很好，但当显示大量元素时，就会变得繁琐。在许多生产环境中，显示数百个元素并不罕见。
- en: Our sample application implements custom pagination logic, if there are more
    than five customers to display, it only displays five customers at a time, then
    has **Previous** and/or **Next** links displayed as appropriate to navigate between
    all customers. *Figure 15**.9* illustrates our custom pagination logic in action.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序实现了自定义分页逻辑，如果有超过五个客户需要显示，它一次只显示五个客户，然后显示适当的**上一页**和/或**下一页**链接以在所有客户之间导航。*图15.9*展示了我们的自定义分页逻辑的实际应用。
- en: '![Figure 15.9 – Custom pagination](img/B21231_15_09.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图15.9 – 自定义分页](img/B21231_15_09.jpg)'
- en: Figure 15.9 – Custom pagination
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 – 自定义分页
- en: Our **Customer List** page renders a **Previous** link to navigate back to the
    previous link, or a **Next** or **Remaining** link to navigate to the next page.
    The **Next** link is rendered if there are at least 5 more customers to display,
    if there are less than 5, then the **Remaining** link is rendered.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**客户列表**页面渲染一个**Previous**链接，用于导航回上一链接，或者渲染**Next**或**Remaining**链接以导航到下一页。如果至少还有5个客户需要显示，则渲染**Next**链接；如果少于5个，则渲染**Remaining**链接。
- en: All three links are conditionally rendered via the command link’s rendered attribute,
    which takes a boolean expression to determine if the link should be rendered.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个链接都是通过命令链接的`rendered`属性条件渲染的，该属性接受一个布尔表达式来决定链接是否应该被渲染。
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `renderPrevLink` property on our controller.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们控制器上的`renderPrevLink`属性。
- en: The `next()` and `prev()` methods update the value of the `renderPrevLink` property.
    The `next()` method is invoked when either the `prev()` method is invoked when
    the `renderPrevLink` value is used to determine if the **Previous** command link
    should be rendered.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`和`prev()`方法更新`renderPrevLink`属性的值。当使用`renderPrevLink`值来确定是否渲染**Previous**命令链接时，会调用`next()`方法；当调用`prev()`方法时，也会调用`next()`方法。'
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The **Next** command link is displayed if there are at least five more customers
    to display.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当至少还有五个客户需要显示时，会显示**Next**命令链接。
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, the logic of the `rendered` attribute is embedded on the page,
    as opposed to relying on the controller as is the case for the **Previous** command
    link.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`rendered`属性的逻辑被嵌入在页面上，而不是像**Previous**命令链接那样依赖于控制器。
- en: The **Remaining** command link is displayed if there are less than five customers
    to display on the next page.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当下一页显示的客户少于五个时，会显示**Remaining**命令链接。
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command link also embeds the logic of its rendered attribute as an expression
    on the page.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令链接也将其`rendered`属性的逻辑作为页面上的一种表达式嵌入。
- en: The pagination logic relies on a `PagingInfo` utility class, this class has
    methods to obtain the first and last elements to display, as logic to determine
    which elements to display on every page of our data table.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 分页逻辑依赖于`PagingInfo`实用类，这个类有获取要显示的第一和最后元素的方法，以及确定在数据表的每一页上显示哪些元素的逻辑。
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As seen in previous code examples, our controller relies on the `PaginationInfo`
    utility class to implement pagination.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码示例所示，我们的控制器依赖于`PaginationInfo`实用类来实现分页。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we illustrated how to integrate several Jakarta EE technologies
    via a sample application. We covered the following topics:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过一个示例应用程序说明了如何通过整合几个Jakarta EE技术。我们涵盖了以下主题：
- en: How to create customer data by integrating Jakarta Faces, CDI, Jakarta Enterprise
    Beans and Jakarta Persistence
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过整合Jakarta Faces、CDI、Jakarta Enterprise Beans和Jakarta Persistence来创建客户数据
- en: How to view customer data by integrating Jakarta Faces, CDI, Jakarta Enterprise
    Beans and Jakarta Persistence
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过整合Jakarta Faces、CDI、Jakarta Enterprise Beans和Jakarta Persistence来查看客户数据
- en: How to update customer data by integrating Jakarta Faces, CDI, Jakarta Enterprise
    Beans and Jakarta Persistence
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过整合Jakarta Faces、CDI、Jakarta Enterprise Beans和Jakarta Persistence来更新客户数据
- en: How to delete customer data by integrating Jakarta Faces, CDI, Jakarta Enterprise
    Beans and Jakarta Persistence
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过整合Jakarta Faces、CDI、Jakarta Enterprise Beans和Jakarta Persistence来删除客户数据
- en: How to implement custom pagination logic when displaying tabular data with the
    Jakarta Faces data table component
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在显示Jakarta Faces数据表组件中的表格数据时实现自定义分页逻辑
- en: Jakarta EE APIs are designed to work together, and, as seen in this chapter,
    they can be seamlessly integrated to build robust applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE API设计为协同工作，正如本章所示，它们可以无缝集成来构建健壮的应用程序。
