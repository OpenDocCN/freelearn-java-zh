- en: Chapter 5. Multiprojects Build
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 多项目构建
- en: Now that we are familiar with the build script syntax, we are prepared to handle
    more complex project structures. In this chapter, we will focus on builds spanning
    across multiple projects, their interdependencies, and many more things in between.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了构建脚本语法，我们准备处理更复杂的项目结构。在本章中，我们将重点关注跨越多个项目的构建，它们之间的相互依赖关系，以及许多其他相关内容。
- en: As the projects code base grows, many times, it is desirable to split it into
    multiple modules based on layers, responsibilities, artifacts produced, or sometimes
    even depending on development teams, to effectively break the work down. Whatever
    is the reason, the reality is big projects are broken down into smaller subprojects
    sooner or later. Also, a build tool such as Gradle is completely capable of handling
    the complexity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目代码库的增长，很多时候，根据层、责任、生成的工件，有时甚至根据开发团队来将其拆分为多个模块是很有必要的，以有效地分解工作。无论原因是什么，现实是大型项目迟早会被拆分为更小的子项目。此外，像Gradle这样的构建工具完全能够处理这种复杂性。
- en: The multiproject directory layout
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多项目目录布局
- en: A multiproject (or multimodule, as some prefer to call it) is a group of projects
    that are logically related to each other and often have the same develop-build-release
    cycles. The directory structure is important for laying out the strategy for building
    such projects. Typically, a top-level root project contains one or more subprojects.
    The root project may contain source sets of its own, may contain only the integration
    tests that test the integration of the subprojects, or may even act just as a
    master build without any source and tests. Gradle supports every such configuration.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 多项目（或称为多模块，有些人更喜欢这样称呼）是一组逻辑上相互关联的项目，通常具有相同的开发-构建-发布周期。目录结构对于布局此类项目的策略非常重要。通常，顶级根项目包含一个或多个子项目。根项目可能包含自己的源集，可能只包含集成测试，这些测试用于测试子项目的集成，或者甚至仅作为一个没有源和测试的母构建。Gradle支持所有此类配置。
- en: The arrangement of subprojects relative to the root project may be flat, that
    is, all the subprojects are the direct children of the root project (as shown
    in sample 1) or are hierarchical, such that the subproject may also have nested
    child projects (as shown in sample 2) or any hybrid directory structure.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 子项目相对于根项目的排列可能是平的，也就是说，所有子项目都是根项目的直接子项目（如样本1所示）或者是有层次的，这样子项目也可能有嵌套的子项目（如样本2所示）或者任何混合的目录结构。
- en: 'Let''s refer to the following directory structure as sample 1:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下目录结构称为样本1：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In sample 1, we see a fictitious example project in which all the subprojects
    are the direct children of the root project and are siblings of each other. Just
    for the sake of this example, we broke our app into three subprojects named `:repository`,
    `:services`, and `:web-app`. As their names suggest, a repository contains the
    data access code, whereas services is the layer encapsulating the business rules
    in the form of a consumable API. The `web-app` contains only the web application-specific
    code such as controllers and view templates. However, note that the `:web-app`
    project may depend on the `:services` project, which in turn may depend on the
    `:repository` project. We will soon see how these dependencies work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在样本1中，我们看到一个虚构的示例项目，其中所有子项目都是根项目的直接子项目，彼此之间是兄弟关系。仅为了这个例子，我们将我们的应用程序拆分为三个子项目，分别命名为`:repository`、`:services`和`:web-app`。正如它们的名称所暗示的，一个仓库包含数据访问代码，而服务层封装了以可消费API形式存在的业务规则。`web-app`只包含特定于Web应用程序的代码，例如控制器和视图模板。然而，请注意，`:web-app`项目可能依赖于`:services`项目，而`:services`项目反过来可能依赖于`:repository`项目。我们很快就会看到这些依赖是如何工作的。
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not confuse the multiproject structure with multiple source directories in
    a single project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将多项目结构与单个项目中的多个源目录混淆。
- en: 'Let''s see a relatively more complex structure and call it sample 2:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个相对更复杂的结构，并将其称为样本2：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our app has now evolved and to cater for more needs, we have added more functionalities
    to it. We have created more subprojects such as a desktop client for our app and
    a command-line interface. In sample 2, the root project is split into three projects
    (groups), which have their own child projects. In this example, every directory
    can be treated as a project. The purpose of this sample is to only show one of
    the possible directory structures. Gradle does not impose one directory structure
    over another.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在已经进化，为了满足更多需求，我们为其添加了更多功能。我们创建了更多子项目，例如应用桌面客户端和命令行界面。在示例2中，根项目被分割成三个项目（组），它们各自有自己的子项目。在这个例子中，每个目录都可以被视为一个项目。这个示例的目的是仅展示可能的目录结构之一。Gradle不会强制使用一种目录结构代替另一种。
- en: One might wonder, where do we put all the `build.gradle` files and what goes
    in them? It depends on our needs and how we want to structure our build. We will
    answer all these questions shortly after we understand what is `settings.gradle`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人可能会想知道，我们把这些`build.gradle`文件放在哪里，里面有什么内容？这取决于我们的需求和如何构建我们的项目结构。在我们理解了什么是`settings.gradle`之后，我们将很快回答所有这些问题。
- en: The settings.gradle file
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: settings.gradle文件
- en: 'During initialization, Gradle reads the `settings.gradle` file to figure out
    which projects are to take part in a build. Gradle creates an object of type `Setting`.
    This happens even before any `build.gradle` is parsed. It is usually placed in
    the root project parallel to `build.gradle`. It is recommended to put `setting.gradle`
    in the root project, otherwise we have to explicitly tell Gradle the location
    to the settings file with the command-line option `-c`. Adding these two files
    to sample 1''s directory structure would gives us something as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化过程中，Gradle读取`settings.gradle`文件以确定哪些项目将参与构建。Gradle创建一个类型为`Setting`的对象。这发生在任何`build.gradle`被解析之前。它通常放置在根项目与`build.gradle`平行的地方。建议将`setting.gradle`放在根项目中，否则我们必须使用命令行选项`-c`显式告诉Gradle设置文件的路径。将这两个文件添加到示例1的目录结构中，我们会得到如下内容：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The most common use of `settings.gradle` is to enlist all the subprojects participating
    in the build:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`settings.gradle`最常见的使用是将所有参与构建的子项目列出：'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Also, this is all that is required to tell Gradle that the current build is
    a multiproject build. Of course, this not the end of the story and there is a
    lot more that we can do with multiproject builds, but this is the bare minimum
    and sometimes just enough to get multiproject builds working.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这就是告诉Gradle当前构建是一个多项目构建所需的所有内容。当然，这并不是故事的结尾，我们还可以在多项目构建中做更多的事情，但这是最基本的要求，有时也足以让多项目构建工作。
- en: The methods and properties of `Settings` are available in the `settings.gradle`
    file and are implicitly called on a `Settings` instance just the way the methods
    of `Project` API are available in the `build.gradle` file, as we saw in the previous
    chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Settings`的方法和属性在`settings.gradle`文件中可用，并且在对`Settings`实例进行操作时隐式调用，就像我们在上一章中看到的那样，`Project`
    API的方法在`build.gradle`文件中可用。'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Are you wondering why a colon (`:`) is used before the project name in the
    preceding section? It denotes the project path relative to the root project. However,
    the `include` method allows level 1 subproject names to omit the colon. So, the
    `include` call can be rewritten as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想知道为什么在上一节的项目名称前使用了冒号（`:`）？它表示相对于根项目的项目路径。然而，`include`方法允许一级子项目名称省略冒号。因此，`include`调用可以重写如下：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s just query the projects by calling the task `projects` from the command
    line. The `projects` task lists all the projects available in a Gradle build:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只通过从命令行调用任务`projects`来查询项目。`projects`任务列出了Gradle构建中可用的所有项目：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In case of nesting that is more than one level deep, like in sample 2, all
    the projects must be included in the root project `settings.gradle` with the syntax
    as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套超过一个级别的场景中，例如在示例2中，所有项目都必须使用以下语法包含在根项目的`settings.gradle`中：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can find more information on `Settings` at the *Settings* DSL documentation
    ([http://www.gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html](http://www.gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html))
    and the *Settings* API documentation ([http://www.gradle.org/docs/current/javadoc/org/gradle/api/initialization/Settings.html](http://www.gradle.org/docs/current/javadoc/org/gradle/api/initialization/Settings.html)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *Settings* DSL 文档（[http://www.gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html](http://www.gradle.org/docs/current/dsl/org.gradle.api.initialization.Settings.html)）和
    *Settings* API 文档（[http://www.gradle.org/docs/current/javadoc/org/gradle/api/initialization/Settings.html](http://www.gradle.org/docs/current/javadoc/org/gradle/api/initialization/Settings.html)）中找到更多关于
    `Settings` 的信息。
- en: Organizing build logic in multiproject builds
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多项目构建中组织构建逻辑
- en: 'Gradle gives us the flexibility to create one build file for all projects or
    individual build file per project; you can also mix and match. Let''s start with
    adding a simple task to our root project''s `build.gradle`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 给我们提供了创建一个构建文件用于所有项目或每个项目单独的构建文件；你也可以混合使用。让我们从向根项目的 `build.gradle` 中添加一个简单的任务开始：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are creating a task with an action that just prints a message. Now, let''s
    check what tasks are available on our root project. From the `root` directory,
    let''s call the task `tasks`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个带有打印消息动作的任务。现在，让我们检查根项目中可用的任务。从 `root` 目录，让我们调用任务 `tasks`：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'No wonder, the `sayHello` task is available on the root project. However, what
    if we just want to see the tasks available on a subproject? Let''s say `:repository`.
    For a multiproject build, we can call tasks on any nested project using the `gradle
    <project-path>:<task-name>` syntax or by going into the subproject directory and
    executing `gradle <task-name>`. So now, if we execute the following code, we won''t
    see the `sayHello` task:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 没有疑问，`sayHello` 任务在根项目中可用。然而，如果我们只想查看子项目上可用的任务怎么办？比如说 `:repository`。对于多项目构建，我们可以使用
    `gradle <project-path>:<task-name>` 语法或进入子项目目录并执行 `gradle <task-name>` 来调用任何嵌套项目的任务。所以现在，如果我们执行以下代码，我们将看不到
    `sayHello` 任务：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is because the `sayHello` is only defined for the root project; hence,
    it is not available on the subproject.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `sayHello` 只在根项目中定义；因此，它不在子项目中可用。
- en: Applying a build logic to all projects
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将构建逻辑应用于所有项目
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Before trying to understand the code snippet, let''s run the familiar task
    again. Firstly, from the root project:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试理解代码片段之前，让我们再次运行熟悉的任务。首先，从根项目开始：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, from the repository project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从仓库项目：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The content inside the closure being passed to `allproject` would look exactly
    like a single-project `build.gradle` file. We can even apply plugins, declare
    repositories and dependencies, and so on. So, in essence, we can write any build
    logic that is common to all projects and then it will be applied to all projects.
    The `allprojects` method can also be used to query the project object in the current
    build. Refer to the API of the project for more details on `allprojects`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `allprojects` 的闭包中的内容将完全像一个单项目 `build.gradle` 文件。我们甚至可以应用插件、声明仓库和依赖项等等。所以，本质上，我们可以编写适用于所有项目的任何通用构建逻辑，然后它将被应用到所有项目上。`allprojects`
    方法也可以用来查询当前构建中的项目对象。有关 `allprojects` 的更多详细信息，请参阅项目的 API。
- en: 'If we pass the `--all` flag to the `tasks` task, we will see the `whoami` task
    being present on all the child projects, in addition to the `root` project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `--all` 标志传递给 `tasks` 任务，我们将看到 `whoami` 任务存在于所有子项目中，包括 `root` 项目：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we want to just execute `whoami` on a specific project, let''s say `:repository`,
    it''s as simple as the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想在特定的项目上执行 `whoami`，比如说 `:repository`，那么命令就像以下这样简单：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we execute `whoami` without any project path:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在没有任何项目路径的情况下执行 `whoami`：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Wow, Gradle goes an extra mile to ensure that the child project tasks with the
    same name are also executed when we execute the task from the parent project.
    This comes in very handy when we think about tasks such as `assemble`, where we
    actually want all the subprojects to assemble, or test, which tests the root and
    also the subprojects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，Gradle 走得更远，以确保当我们从父项目执行任务时，具有相同名称的子项目任务也会被执行。当我们考虑像 `assemble` 这样的任务时，这非常有用，因为我们实际上希望所有子项目都进行组装，或者测试，它测试根项目以及子项目。
- en: 'However, what about executing a task only on the root project? Indeed, a valid
    scenario. Remember the absolute task path:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于仅在根项目上执行任务怎么办？这确实是一个有效场景。记住绝对任务路径：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The colon makes all the difference. Here, we are referring to `whoami` of the
    `root` project only. No other task matches the same path. For example, repository's
    `whoami` has a path `repository:whoami`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号起着至关重要的作用。在这里，我们只引用`root`项目的`whoami`。没有其他任务匹配相同的路径。例如，`repository`的`whoami`有一个路径`repository:whoami`。
- en: 'Now, `cd` in the `repository` directory and then execute the `whoami`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，切换到`repository`目录，然后执行`whoami`：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So the task execution is context-sensitive. Here, by default, Gradle assumes
    that the task has to be called on the current project only. Nice, isn't it?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任务执行是上下文相关的。在这里，默认情况下，Gradle假设任务必须在当前项目上调用。不错，不是吗？
- en: 'Let''s add a little more dynamic code to our existing `build.gradle` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在现有的`build.gradle`文件中添加一些更动态的代码：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, depending on the project name, we are setting the task name to be `describe`,
    prefixed to the project name. So all projects get their tasks, but the name won''t
    be the same. We add an action that just prints the project name. If we execute
    the `tasks` on our project now, we can see the task names include the project
    name:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，根据项目名称，我们将任务名称设置为`describe`，并在项目名称前加上前缀。因此，所有项目都得到了它们自己的任务，但名称不会相同。我们添加了一个仅打印项目名称的操作。如果我们现在在我们的项目上执行`tasks`，我们可以看到任务名称包括项目名称：
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although the example is very trivial, we learn a few things. Firstly, the `allprojects`
    blocks are additive as most of the other methods in Gradle. We added the second
    `allprojects` block and both worked just fine. Secondly, the task name can be
    dynamically assigned, for example, using the project name.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子非常简单，但我们学到了一些东西。首先，`allprojects`块是累加的，就像Gradle中的大多数其他方法一样。我们添加了第二个`allprojects`块，并且两者都运行得很好。其次，任务名称可以动态分配，例如，使用项目名称。
- en: 'Now, we can call any of the `describe*` tasks from the project root. Also,
    as we might guess, the task name is unique; we don''t need to prepend the project
    path:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从项目根目录调用任何`describe*`任务。正如我们可能猜测的那样，任务名称是唯一的；我们不需要在项目路径前加上前缀：
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s `cd` into the `repository` directory and list tasks:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到`repository`目录并列出任务：
- en: '[PRE23]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We see only the applicable tasks for the current project, which is `repository`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只看到适用于当前项目的任务，即`repository`。
- en: Applying build logic to subprojects
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将构建逻辑应用于子项目
- en: 'Let''s continue further with our example. Here, the root project will not have
    any source sets as all the Java code is going to be in one of the three child
    projects. Hence, wouldn''t it be wise to apply a `java` plugin to only child projects?
    This is exactly where the `subprojects` method comes into the picture, that is,
    when we want to apply some build logic only on subprojects without affecting the
    parent project. Its usage is similar to `allprojects`. Let''s just apply the `java`
    plugin to all subprojects:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的例子。在这里，根项目将没有任何源集，因为所有的Java代码都将位于三个子项目中的任何一个。因此，只将`java`插件应用于子项目不是明智的吗？这正是`subprojects`方法发挥作用的地方，即当我们只想在子项目上应用一些构建逻辑而不影响父项目时。它的用法类似于`allprojects`。让我们将`java`插件应用于所有子项目：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, running `gradle tasks` should show us the tasks added by the `java` plugin
    as well. Although it might appear that these tasks are available on the root project,
    it's actually not so. Check the output of `gradle -q tasks --all` in this case.
    The tasks being there on the child project can be called from the root project,
    but this does not mean they are present on the root project. The tasks added by
    the `java` plugin will only be available on subprojects, whereas tasks such as
    help tasks will be available on all projects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`gradle tasks`应该会显示由`java`插件添加的任务。尽管这些任务可能看起来在根项目中可用，但实际上并非如此。在这种情况下，检查`gradle
    -q tasks --all`的输出。在子项目上存在的任务可以从根项目调用，但这并不意味着它们在根项目中存在。由`java`插件添加的任务仅可在子项目中使用，而如帮助任务这样的任务将在所有项目中可用。
- en: Dependency on subprojects
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子项目依赖
- en: In the beginning of the chapter, we mentioned that a subproject might depend
    on another subproject(s) just the way it can depend on the external library dependency.
    For example, the `services` project's compilation depends on the `repository`
    project, which means we need the compiled classes from the `repository` project
    to be available on the compilation classpath of the `services` project.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提到一个子项目可能依赖于另一个子项目（或多个子项目），就像它可以依赖于外部库依赖一样。例如，`services`项目的编译依赖于`repository`项目，这意味着我们需要`repository`项目的编译类在`services`项目的编译类路径上可用。
- en: To achieve this, we can, of course, create a `build.gradle` file in the `services`
    project and put the dependency declaration there. However, just for the sake of
    showing an alternate way, we will put this declaration in the `root` project's
    `build.gradle`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们当然可以在`services`项目中创建一个`build.gradle`文件并将依赖声明放在那里。然而，为了展示一种替代方法，我们将这个声明放在`root`项目的`build.gradle`中。
- en: Unlike `allprojects` or `subprojects`, we need a finer mechanism to configure
    only a single project from the `root` project's `build.gradle`. As it turns out,
    it is very easy using the `project` method. This method accepts a closure just
    like the `allprojects` and `subprojects` methods in addition to the project name
    on which the closure will be applied. In the configuration phase, the closure
    is executed on that project's object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与`allprojects`或`subprojects`不同，我们需要一个更精细的机制来仅从`root`项目的`build.gradle`中配置单个项目。实际上，使用`project`方法非常简单。此方法除了接受一个闭包，就像`allprojects`和`subprojects`方法一样，还需要指定一个项目名称，该闭包将应用于该项目。在配置阶段，闭包将在该项目的对象上执行。
- en: 'So, let''s add this to the root project''s `build.gradle`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将其添加到`root`项目的`build.gradle`中：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we are configuring dependencies only for the `services` project. In the
    `dependencies` block, we declare that the `:repository` project is the compile
    time dependency for the `services` project. This is more or less similar to the
    external library declaration; instead of the library name in the `group-id:artifact-id:version`
    notation, we used `project(:sub-project)` to refer to a subproject.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只为`services`项目配置依赖项。在`dependencies`块中，我们声明`:repository`项目是`services`项目的编译时依赖项。这基本上类似于外部库声明；我们使用`project(:sub-project)`来引用子项目，而不是在`group-id:artifact-id:version`表示法中使用库名称。
- en: 'We had also said that the `web-app` project depends on the `services` project.
    So this time, let''s use `web-app`''s own `build.gradle` to declare this dependency.
    We will create a `build.gradle` file in the `web-app` directory:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前也说过`web-app`项目依赖于`services`项目。所以这次，让我们使用`web-app`自己的`build.gradle`来声明这个依赖项。我们将在`web-app`目录中创建一个`build.gradle`文件：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As this is a project-specific build file, we can just add the `dependencies`
    block as we would in any other project:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个特定于项目的构建文件，我们只需像在其他任何项目中一样添加`dependencies`块即可：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s visualize the dependencies of the web project, using the `dependencies`
    tasks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`dependencies`任务可视化Web项目的依赖关系：
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Gradle shows us the dependencies of the `web-app` under various configurations.
    Also, we can clearly see that Gradle understands the transitive dependency; hence,
    it shows `web-app` transitively dependent on `repository` through `services`.
    Note that we have not actually declared any external dependencies (such as `servlet-api`)
    in any of the projects, otherwise they would also show up here.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle向我们展示了`web-app`在不同配置下的依赖关系。我们还可以清楚地看到Gradle理解了传递依赖；因此，它显示了`web-app`通过`services`传递依赖于`repository`。请注意，我们实际上并没有在任何项目中声明任何外部依赖项（如`servlet-api`），否则它们也会在这里显示。
- en: It is worth taking a look at the variations of the `configure` methods on the
    `project` object in order to filter and configure selected projects. More information
    on the `configure` method can be found at [https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html](https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，查看`project`对象上`configure`方法的变体，以便过滤和配置选定的项目。有关`configure`方法的更多信息，请参阅[https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html](https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html)。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this short chapter, we learned that Gradle supports flexible directory structure
    for complex project hierarchies and allows us to choose the right structure for
    our build. We then looked at the importance of `settings.gradle` in the context
    of mutliprojects build. We then saw various ways of applying a build logic to
    all projects, subprojects, or only a single project. Finally, took a small example
    of inter-project dependencies.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一简短的章节中，我们了解到Gradle支持灵活的目录结构，适用于复杂的项目层次结构，并允许我们为我们的构建选择合适的结构。然后我们探讨了在多项目构建的背景下`settings.gradle`的重要性。接着我们看到了将构建逻辑应用于所有项目、子项目或单个项目的各种方法。最后，我们举了一个关于项目间依赖关系的小例子。
- en: This is all we need to worry about in terms of the Gradle syntax. Now the next
    chapters will majorly focus on the functionalities that various plugins add to
    our builds and how we can configure them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle语法方面，我们只需要关注这些。接下来几章将主要关注各种插件为我们构建添加的功能以及如何配置它们。
