- en: 'Chapter 1: Designing Software Architectures in Java – Methods and Styles'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：使用Java设计软件架构 – 方法与风格
- en: In this chapter, we will focus on some core concepts that we can use as a base
    to build on in the upcoming chapters. We will explore different ways to represent
    the software architecture, paying attention to the intended audience and their
    specific point of view. Additionally, we will elaborate on the importance of a
    proper architectural design and its role in the software development life cycle.
    Following this, we will move on to the Java ecosystem, which is the core topic
    of this book, to discover why it’s a good choice for implementing a complete enterprise
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注一些核心概念，这些概念可以作为我们在后续章节中构建的基础。我们将探讨表示软件架构的不同方法，关注目标受众及其特定的观点。此外，我们将详细阐述适当架构设计的重要性及其在软件开发生命周期中的作用。随后，我们将转向本书的核心主题Java生态系统，以了解为什么它是实现完整企业应用的好选择。
- en: 'In particular, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是以下内容：
- en: The importance of software architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构的重要性
- en: Different types of architecture design – from doodling on paper to more accurate
    modeling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的架构设计 – 从纸上涂鸦到更精确的建模
- en: Other kinds of architectural diagrams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型的架构图
- en: The changing role of Java in cloud-native applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java在云原生应用中的角色变化
- en: Case studies and examples
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究和示例
- en: Software components diagram
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件组件图
- en: By the end of this chapter, you should have a clear view of why design is a
    critical part of the software development process and what the main types of architecture
    schemas are. Additionally, you will become familiar with the role of Java technology
    in modern application development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对为什么设计是软件开发过程中的关键部分以及主要类型的架构模式有一个清晰的了解。此外，你将熟悉Java技术在现代应用开发中的作用。
- en: These skills are crucial for implementing functional and elegant software solutions.
    It will also be a good basis for personal development and career enhancement.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技能对于实现功能强大且优雅的软件解决方案至关重要。这也会为个人发展和职业提升提供一个良好的基础。
- en: The importance of software architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构的重要性
- en: Often, software development is all about cost and time. No one knows exactly
    why, but the software industry is almost always associated with tight deadlines,
    insufficient resources, and long hours. Under this kind of pressure, it’s common
    to question the importance of everything that is not strictly *coding*. Testing
    is a common victim of this, along with documentation and, of course, design. But
    of course, these phases are essential for the success of a project. While we will
    quickly touch on most of those aspects, architecture design is the core of this
    book, and I believe that by understanding the practices and goals, the need for
    it will become clear to everybody.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，软件开发完全是关于成本和时间。没有人确切知道为什么，但软件行业几乎总是与紧张的截止日期、资源不足和长时间工作联系在一起。在这种压力下，质疑一切非严格意义上的*编码*的重要性是很常见的。测试是这种质疑的常见受害者，包括文档和当然还有设计。但当然，这些阶段对于项目的成功是至关重要的。虽然我们将快速触及这些方面的多数内容，但架构设计是本书的核心，我相信通过理解实践和目标，其必要性将变得对每个人都很清楚。
- en: In this section, we will discover what the fundamental objects of a properly
    designed architecture are. Highlighting those simple but crucial points is useful
    in raising awareness about the importance of this phase. If you start advocating
    those good practices in your team, the quality of your software deliverables will
    increase.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一个设计合理的架构的基本对象是什么。突出这些简单但至关重要的观点对于提高人们对这一阶段重要性的认识是有用的。如果你开始在团队中倡导这些良好的实践，你交付的软件质量将会提高。
- en: The objectives of architecture design in the software life cycle
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件生命周期中架构设计的目标
- en: The ultimate goal of this book is not to define the architecture *per se*; there
    are plenty of papers and interesting things available on that matter, including
    the awesome work of Martin Fowler. Nevertheless, there are a couple of considerations
    that we need to bear in mind.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书最终目标不是定义架构本身；关于这一点，有大量的论文和有趣的内容可供参考，包括马丁·福勒的杰出工作。尽管如此，还有一些考虑因素我们需要牢记。
- en: The architecture should support the crucial decisions within our software project.
    However, the architecture itself is actually a loose concept, often including
    different plans (such as physical, logical, network, and more) and points of view
    (such as users, business logic, machine-to-machine interactions, and more).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 架构应支持我们软件项目中的关键决策。然而，架构本身实际上是一个较为宽泛的概念，通常包括不同的计划（如物理、逻辑、网络等）和观点（如用户、业务逻辑、机器间交互等）。
- en: 'Let’s take the most overused metaphor as an example: a software project is
    like a building. And similarly to a construction project, we require many different
    points of view, with different levels of detail, ranging from general overviews
    to detailed calculations and the bills of materials. A general overview is useful
    to give us an idea of where we are and where we want to go. In addition to this,
    it is an essential tool for being sure we are on the right path. However, a system
    overview doesn’t provide enough details for teams such as networking, security,
    sysops, and, ultimately, the developers that require a more substantiated and
    quantitative view to drive their day-to-day decisions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以最常用的比喻为例：软件项目就像一座建筑。同样地，就像建设项目一样，我们需要许多不同的观点，不同层次的细节，从一般概述到详细的计算和材料清单。一般概述有助于我们了解自己的位置和想要去的地方。此外，它还是确保我们走在正确道路上的一个基本工具。然而，系统概述并不能为网络、安全、系统操作等需要更实质性和定量观点以指导日常决策的团队提供足够的信息。
- en: 'The main goals of designing a proper software architecture include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设计合适的软件架构的主要目标包括以下内容：
- en: Prospecting a **birds-eye view** to project sponsors and investors. While it
    is not a good practice to drive a business discussion (for example, an elevator
    pitch) toward technical elements too soon, a higher level of management, venture
    capitalists, and the like are becoming increasingly curious about technical details,
    so a high-level overview of the application components can be crucial for winning
    this kind of discussion.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目发起人和投资者提供一个**宏观视角**。虽然过早地将业务讨论（例如，电梯演讲）引导到技术元素上并不是一个好的做法，但管理层、风险投资家等高级管理人员对技术细节的兴趣日益浓厚，因此，对应用程序组件的高级概述对于赢得这类讨论至关重要。
- en: Defining a **shared lingo** for components of our solution, which is crucial
    for collaborating across the team.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们解决方案的组件定义一个**共同术语**，这对于跨团队协作至关重要。
- en: Providing **guidance for technological choices** since putting our design decisions
    on paper will clarify important traits of our application. *Will data be central?*
    *Do we need to focus on multiple geographies?* *Are user interactions the most
    common use case?* Some of those reasonings will change over time. However, correctly
    designing our application will drive some crucial technology choices, in terms
    of choosing components and stacks to rely on.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对**技术选择**的**指导**，因为将我们的设计决策记录在纸上将阐明我们应用程序的重要特性。*数据是否为核心？* *我们需要关注多个地理区域吗？*
    *用户交互是否是最常见的用例？* 其中一些推理可能会随时间而变化。然而，正确设计我们的应用程序将推动一些关键的技术选择，包括选择依赖的组件和堆栈。
- en: Splitting **roles and responsibilities**. While a proper project plan, a statement
    of work, or a **Responsible**, **Accountable**, **Consulted**, **Informed** (**RACI**)
    (which is a classical way to categorize who does what) table will be used for
    real project management, writing the software backbone down on paper is our first
    look at who we have to involve for proper project execution.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**划分****角色和责任**。虽然一个适当的项目计划、工作说明书或**负责的**、**可问责的**、**咨询的**、**通知的**（**RACI**）（这是一种分类谁做什么的经典方法）表格将被用于实际的项目管理，但将软件骨干写在纸上是我们第一次了解为了正确执行项目我们需要涉及的人员。'
- en: Indeed, the architecture is an excellent example of planning in advance. However,
    a proper software architecture should be much more than a technological datasheet.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，架构是提前规划的一个很好的例子。然而，一个合适的软件架构应该远不止是一份技术数据表。
- en: Architecture, as with buildings, is more about the styles and guidelines to
    be followed all around the project. The final goal of a piece of software architecture
    is to find elegant solutions to the problems that will arise during the project
    plan. Ultimately, it will act as guidance throughout the project’s life cycle.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像建筑一样，架构更多地关乎整个项目要遵循的风格和指南。软件架构的最终目标是找到在项目计划期间出现的各种问题的优雅解决方案。最终，它将在整个项目生命周期中起到指导作用。
- en: The software architect – role and skills
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件架构师 – 角色和技能
- en: As a role, the software architect is often identified as the more senior technical
    resource in the IT team. In fact, the job role of an architect is almost always
    seen as a career progression for developers, especially in enterprise environments.
    While not necessary, being good at coding is crucial for a complete comprehension
    of the overall functioning of the system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种角色，软件架构师通常被认定为IT团队中更高级的技术资源。实际上，架构师的职位几乎总是被视为开发者的职业发展路径，尤其是在企业环境中。虽然这不是必需的，但擅长编码对于全面理解系统的整体运作至关重要。
- en: There are several different other skills that are required to be a successful
    architect, including creativity, the ability to synthesize, and vision. However,
    above all, experience is what it takes to become an architect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一名成功的架构师，还需要具备其他几种不同的技能，包括创造力、综合能力和远见。然而，最重要的是经验，这是成为架构师的必要条件。
- en: 'This includes firsthand experience on many different projects, solving real-world
    issues: what a proper software design looks like and how the design has evolved.
    This skillset is very useful to have in the background of the architect.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括在许多不同项目中的第一手经验，解决现实世界的问题：合适的软件设计是什么样的，设计是如何演变的。这种技能集对于架构师来说是非常有用的背景知识。
- en: Additionally, it’s vital to have a huge library of solutions to choose from
    in order to avoid reinventing the wheel. While we love to think that our problem
    is very unique, it’s very unlikely to be so.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，拥有一个庞大的解决方案库以供选择，以避免重复造轮子，这一点至关重要。虽然我们喜欢认为我们的问题是独一无二的，但实际上这种情况非常不可能发生。
- en: 'This leads us to the approach that we will use in this book: we will not focus
    on just one aspect or technology to drill down on, but we will take a *horizontal*
    approach, discussing a number of different topics and offering ideas on how to
    approach potential problems. We hope to act as a handbook to support you when
    making real-world choices.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们采用本书中的方法：我们不会只关注一个方面或技术进行深入探讨，而是采取一种**横向**的方法，讨论多个不同的话题，并提供如何应对潜在问题的想法。我们希望成为一本手册，在你做出现实世界选择时提供支持。
- en: Is architecture design still relevant in modern development?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构设计在现代开发中是否仍然相关？
- en: There will be a couple of chapters dedicated to discussing **Microservices**,
    **DevOps**, and the cloud-native avalanche, but it’s safe to assume that in one
    form or another, you will have plenty of opportunities to hear something about
    them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将有几章专门讨论**微服务**、**DevOps**和云原生浪潮，但可以安全地假设，以某种形式，你将有很多机会听到关于它们的内容。
- en: As you might have gathered, most of these concepts are not really new. The **Agile
    Manifesto**, which is a seminal work detailing some of the practices commonly
    used in modern development techniques, was published in 2001, yet most of the
    common-sense principles it contains are misinterpreted. When I was working in
    IT consulting back in 2008, a common joke among development teams was "*Yes, we
    do agile. We skip documentation and testing.*"
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些概念并不是真正的新。**敏捷宣言**，这是一部详述现代开发技术中常用实践的经典作品，于2001年发布，但其中包含的大多数常识性原则都被误解了。当我2008年在IT咨询公司工作时，开发团队中有一个常见的笑话是：“是的，我们做敏捷。我们跳过文档和测试。”
- en: Of course, that’s just an opinion based on personal experience. There are plenty
    of teams who do not underestimate the importance of proper planning and documentation
    and are doing wonderfully while working with Agile. Yet, in some cases, less structured
    development methodologies have been taken as an excuse to skip some crucial steps
    of the development life cycle.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个基于个人经验的观点。有很多团队并不低估适当规划和文档的重要性，并且在敏捷开发中表现得很出色。然而，在某些情况下，不太结构化的开发方法被当作跳过开发生命周期中一些关键步骤的借口。
- en: As we will elaborate, in [*Chapter 5*](B16354_05_Final_JM_ePUB.xhtml#_idTextAnchor109),
    *Exploring the Most Common Development Models*, Agile is much more than slimming
    down boring phases of the project. Indeed, testing and documentation are still
    very relevant, and Agile is no excuse to skip that.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将详细阐述的，在[第5章](B16354_05_Final_JM_ePUB.xhtml#_idTextAnchor109)《探索最常见的发展模型》中，敏捷不仅仅是简化项目中的无聊阶段。事实上，测试和文档仍然非常相关，敏捷不是跳过这些内容的借口。
- en: 'There are plenty of reflections you can take in terms of how to adapt your
    design techniques to DevOps, Agile, and more, and we will discuss this topic later
    in this book. However, one thing is certain: *architecture matters*. *Design is
    very relevant*. We have to spend the correct amount of time planning our choices,
    revisiting them when needed, and generally, sticking with some well-defined guiding
    principles. The alternative is poor quality deliverables or no deliverables at
    all.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在如何适应DevOps、敏捷和更多设计技术方面有很多反思，我们将在本书的后面讨论这个话题。然而，有一点是肯定的：*架构很重要*。*设计非常相关*。我们必须花费正确的时间来规划我们的选择，在需要时重新审视它们，并且通常，坚持一些定义良好的指导原则。否则，结果可能是质量低劣的交付品，或者根本没有交付品。
- en: Now, let’s take a look at what the first phases of software design usually look
    like.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看软件设计的第一阶段通常是什么样的。
- en: Different types of architecture design – from doodling on paper to more accurate
    modeling
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的架构设计类型——从纸上涂鸦到更精确的建模
- en: When we start to shape the architecture of a new application, the result is
    often familiar.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始构建新应用程序的架构时，结果通常是熟悉的。
- en: I would say that across different geographies, industries, and application types,
    some elements are common. The architectural sketches are usually made of boxes
    and lines, with labels, arrows, and similar artifacts. That’s an intuitive way
    to shape our thoughts on paper.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以说，在不同的地理、行业和应用类型中，一些元素是共同的。建筑草图通常由盒子、线条、标签、箭头和类似的人工制品组成。这是一种直观的方法，将我们的想法在纸上形成。
- en: However, in the following section, we will go through *different* ways of expressing
    those concepts. This will make us aware of available styles and techniques and
    will make our diagram clearer and, ultimately, easier to share and understand.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在下一节中，我们将介绍*不同*的表达这些概念的方法。这将使我们意识到可用的风格和技术，并使我们的图表更清晰，最终更容易分享和理解。
- en: But first, let’s find out what the characteristics of architectural sketching
    actually are.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们了解建筑草图的实际特点。
- en: Sketching the main architectural components
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制主要架构组件
- en: 'As we discussed earlier, there are a number of different components that are
    recurrent in a high-level architectural sketch. Let’s examine them one by one:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，在高级架构草图中有许多不同的组件是反复出现的。让我们逐一检查它们：
- en: '**Boxes**: These represent the software components. They can refer to one complete
    application or specific subcomponents (such as packages, modules, or similar things).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**盒子**：这些代表软件组件。它们可以指一个完整的应用程序或特定的子组件（例如包、模块或类似的东西）。'
- en: '**Lines**: These describe the relationships between the boxes. Those links
    imply some sort of communication, commonly in the form of APIs. The lines can
    also represent inheritance or a grouping of some sort. A direction (that is, *an
    arrow*) can also be specified.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线条**：这些描述盒子之间的关系。这些链接暗示某种形式的通信，通常是API的形式。线条也可以表示继承或某种分组。还可以指定一个方向（即*箭头*）。'
- en: '**Layers**: These are a dotted or dashed line, grouping components and their
    relationships. They are used to identify logical slices of the architecture (such
    as the frontend, backend, and more), the grouping of subcomponents (for example,
    validation and business logic), network segments (such as the intranet and DMZ),
    physical data centers, and more.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层**：这些是点划线或虚线，将组件及其关系分组。它们用于识别架构的逻辑切片（例如前端、后端等）、子组件的分组（例如验证和业务逻辑）、网络段（例如内网和DMZ）、物理数据中心等。'
- en: '**Actors**: Simulating the interactions of users within the systems, actors
    are usually represented as stickmen, sitting on top of some components (usually
    frontends or UIs of some sort). It is not uncommon to observe different channels
    represented, in the form of laptops or mobile phones, depending on the industry
    and type of application (for example, ATMs, branch offices, and physical industrial
    plants).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**演员**：模拟系统内用户之间的交互，演员通常以木偶的形式表示，坐在某些组件的顶部（通常是某些前端或某种用户界面）。观察不同渠道以笔记本电脑或手机的形式表示，这取决于行业和应用类型（例如，自动柜员机、分支机构以及物理工业设施）并不罕见。'
- en: 'Now, let’s view an example sketch:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下一个示例草图：
- en: '![Figure 1.1 – The common components on a first architectural sketch'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 – 第一张架构草图上的常见组件'
- en: '](img/Figure_1.1_B16354.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.1_B16354.jpg)'
- en: Figure 1.1 – The common components on a first architectural sketch
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 第一张架构草图上的常见组件
- en: 'As we’ve already mentioned, the quick and dirty representation shown in this
    diagram is useful since it’s an easy way to start thinking about how our application
    should look. However, on a closer look, there are some common inaccuracies:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，图中展示的快速且粗略的表示法是有用的，因为它是一种简单的方式来思考我们的应用程序应该如何呈现。然而，仔细观察后，我们发现其中存在一些常见的错误：
- en: 'The software components (that is, our boxes) might be represented with different
    levels of zoom: sometimes representing applications, sometimes features, and sometimes
    software modules. This is inconsistent and could generate confusion.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件组件（即我们的框）可能以不同的缩放级别表示：有时表示应用程序，有时表示功能，有时表示软件模块。这种不一致性可能会导致混淆。
- en: Some components are specialized (for example, databases), while others are not.
    As noted in the preceding point, this leads to an inhomogeneous view.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些组件是专业的（例如，数据库），而另一些则不是。正如前一点所述，这会导致不均匀的视角。
- en: In some parts of the diagram, we are representing use cases or information flows
    (for example, with the actors), while elsewhere, we are drawing a static picture
    of the components.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些部分，我们表示用例或信息流（例如，通过参与者），而在其他地方，我们绘制组件的静态图。
- en: Some points of view don’t cope well with others because we might be representing
    network firewalls but not referencing any other networking setup.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们可能表示网络防火墙而不引用任何其他网络设置，因此某些视角可能无法很好地与其他视角配合。
- en: Now that we’ve learned what a naïve representation looks like and what its limits
    are, let’s take a look at some other types of diagrams and how they represent
    alternative points of view.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了天真表示法的外观及其局限性，让我们来看看其他类型的图以及它们如何表示不同的视角。
- en: Other kinds of architectural diagrams
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型的架构图
- en: As we discovered in the previous section, the first sketches of a piece of architecture
    often end up as an intuitive and naïve view, lacking essential details. In this
    section, we will look at an overview of different types of architectural diagrams.
    This will help us to pick the right diagram for the right situation, defining
    a clearer view of our architecture. So, let’s dig into some details.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节中发现的，一个架构的初步草图通常最终会变成一个直观且天真的视角，缺乏必要的细节。在本节中，我们将概述不同类型的架构图。这将帮助我们选择合适的图来应对不同的情况，定义我们架构的更清晰视图。因此，让我们深入了解一些细节。
- en: Common types of architectural diagrams
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的架构图类型
- en: 'In order to define a clearer and more detailed view of what our software will
    look like, it’s essential to start picking layers and points of view to represent.
    This will naturally lead us to focus on more tailored designs. While not exhaustive,
    a list of possible architectural diagrams includes the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地定义我们的软件将如何呈现，开始挑选层次和视角来表示是至关重要的。这自然会引导我们关注更定制化的设计。虽然不是详尽的，但可能包含以下类型的架构图：
- en: '**Software components**: This kind of schema includes different software modules
    (such as applications or other components) and the interaction between them (for
    example, read from, write to, listen, and more). One particular instance of this
    diagram could include protocols and formats of communication between those components,
    becoming close to a complete API documentation:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件组件**：这种类型的图包括不同的软件模块（如应用程序或其他组件）以及它们之间的交互（例如，读取、写入、监听等）。这种图的特定实例可能包括这些组件之间通信的协议和格式，接近完整的API文档：'
- en: '![Figure 1.2 – Software components diagram'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – 软件组件图'
- en: '](img/Figure_1.2_B16354.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.2_B16354.jpg)'
- en: Figure 1.2 – Software components diagram
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 软件组件图
- en: '**Network architecture**: This is a pretty common design type and is often
    considered the more *scientific* and detailed one. It includes data such as network
    segments (**DMZ** and **INTRANET**), **Firewall**, IP addressing, and more:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络架构**：这是一种相当常见的设计类型，通常被认为是更“科学”和详细的。它包括网络段（如**DMZ**和**INTRANET**）、**防火墙**、IP地址等信息：'
- en: '![Figure 1.3 – Network architecture diagram'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 – 网络架构图'
- en: '](img/Figure_1.3_B16354.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.3_B16354.jpg)'
- en: Figure 1.3 – Network architecture diagram
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 网络架构图
- en: '**Physical architecture**: This is a mapping of software modules into server
    deployments. Usually, it’s complete with information about the server hardware
    and model. In the case of a multiple datacenter setup (which is pretty common
    in enterprise environments), it can also contain details about racks and rooms.
    Storage is another relatively common component. Depending on the implementation,
    this architecture might include information about virtualization technology (for
    example, the mapping of VMS to the physical servers that are hosting it). Additionally,
    it could, where relevant, include references to cloud or container deployments:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理架构**：这是将软件模块映射到服务器部署的过程。通常，它包括有关服务器硬件和型号的信息。在多个数据中心设置的情况下（这在企业环境中相当常见），它还可以包含有关机架和房间的详细信息。存储是另一个相对常见的组件。根据实现方式，这种架构可能包括有关虚拟化技术（例如，VMS映射到托管它的物理服务器）的信息。此外，如果相关，它还可以包括对云或容器部署的引用：'
- en: '![Figure 1.4 – Physical architecture diagram'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 – 物理架构图'
- en: '](img/Figure_1.4_B16354.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.4_B16354.jpg)'
- en: Figure 1.4 – Physical architecture diagram
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 物理架构图
- en: These are the very basic points of view in an architecture diagram and an essential
    starting point when detailing the design of your application. Diving further into
    the application specification life, other kinds of diagrams, often derivatives
    of those, could be elaborated (for example, cloud deployment diagrams, software
    modules, and more) depending on your specific needs. In the next section, we will
    focus on Java technology, which is the other fundamental topic of this book and
    crucial for completing our architectural view of modern applications.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是架构图中的基本观点，也是详细设计应用程序时的一个重要起点。在进一步深入到应用程序规范的生命周期时，根据您的具体需求，可能会详细阐述其他类型的图表，通常是那些图表的衍生（例如，云部署图、软件模块等）。在下一节中，我们将关注Java技术，这是本书的另一个基本主题，对于完成我们对现代应用程序的架构视图至关重要。
- en: The changing role of Java in cloud-native applications
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java在云原生应用中的变化角色
- en: 'Now that we’ve briefly touched on the various kinds of designs and diagrams
    of an application, let’s focus on the other fundamental topic of this book: the
    Java language.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要地提到了应用程序的各种设计和图表，让我们专注于本书的另一个基本主题：Java语言。
- en: It’s not uncommon to hear that Java is dead. However, if you are reading this
    book, you probably agree that this is far from the truth.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 听到Java已经死亡的说法并不罕见。然而，如果你正在阅读这本书，你可能会同意这远非事实。
- en: Of course, the panorama of software development languages for enterprise applications
    is now wider and more complicated than the golden age of Java; nevertheless, the
    language is still alive and widespread, especially in some areas.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，企业应用软件开发语言的景象现在比Java的黄金时代更广泛、更复杂；尽管如此，这门语言仍然充满活力且广泛使用，尤其是在某些领域。
- en: In this section, we will explore the usage of Java technology in the enterprise
    software landscape. Then, we will take a quick glance at the history of **Java
    Enterprise Edition** (**JEE**). This will be a good foundation to understand existing
    enterprise architectures and model modern, cloud-native applications based on
    this technology.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Java技术在企业软件领域的应用。然后，我们将快速浏览一下**Java企业版**（**JEE**）的历史。这将为我们理解现有的企业架构以及基于该技术构建现代、云原生应用奠定良好的基础。
- en: Now, let’s examine why Java technology is still thriving.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨为什么Java技术至今仍然繁荣。
- en: Why Java technology is still relevant today
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么Java技术至今仍具有相关性
- en: The most important reason for Java’s popularity is probably the availability
    of skill. There are plenty of experts on this language, as many polls and studies
    show (for example, PYPL and Tiobe). Another crucial point is the relevance of
    the ecosystem, in terms of the quantity and quality of libraries, resources, and
    tooling available for the Java platform.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Java受欢迎的最重要原因可能是技能的可用性。正如许多调查和研究表明的那样（例如，PYPL和Tiobe），有大量的专家精通这门语言。另一个关键点是生态系统的相关性，从数量和质量上讲，Java平台可用的库、资源和工具都很多。
- en: Rewriting complex applications (including their dependencies) from Java to another
    language could probably take years, and, long story short, there might be no reason
    to do that. Java just works, and it’s an incredibly productive platform. It might
    be slow and resource-intensive in some scenarios, but this is balanced by its
    stability. The language has been battle-tested, is feature-rich, and essentially,
    covers all the use cases required in an enterprise, such as transactionality,
    integration with legacy environments, and manageability.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将复杂的应用程序（包括其依赖项）从Java重写到另一种语言可能需要数年，简而言之，可能没有必要这么做。Java运行良好，并且是一个极其高效的平台。在某些场景下，Java可能运行缓慢且资源密集，但这一点通过其稳定性得到了平衡。这种语言已经过实战检验，功能丰富，并且基本上涵盖了企业中所需的所有用例，例如事务性、与旧环境的集成以及可管理性。
- en: Now, let’s take a look at where and how Java technology is used in enterprise
    environments. This can be very useful to understand existing scenarios and fit
    new applications into existing application landscapes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Java技术在企业环境中的使用情况和方式。这有助于理解现有场景，并将新应用程序融入现有应用景观中。
- en: Java usage in enterprise environments
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 企业环境中的Java使用
- en: In order to fit our Java application in the overall architecture, it’s important
    to understand the typical context of a large enterprise, from a software architecture
    perspective.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的Java应用程序适应整体架构，从软件架构的角度来看，了解大型企业的典型环境是很重要的。
- en: 'Of course, the enterprise architecture depends a lot on the industry domain
    (for instance, banking, telecommunications, media, and more), geography, and the
    tenure of the organization, so my vision might be slightly biased toward the segment
    I have worked with for the longest (a large enterprise in the EMEA area). Still,
    I think we can summarize it as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，企业架构在很大程度上取决于行业领域（例如，银行、电信、媒体等）、地理位置以及组织的任期，因此我的观点可能略微偏向于我工作时间最长的领域（EMEA地区的的大型企业）。尽管如此，我认为我们可以总结如下：
- en: '**Legacy**: Big applications, usually running very core functions of the enterprise
    for many years (at least more than 10 and commonly more than 20). Needless to
    say, the technology here is not the most current (**Cobol** is widespread in this
    area, but it is not uncommon to see other things such as **PL SQL**, huge batch
    scripts, and even **C**/**C++** code). However, the language is seldom an issue
    here. Of course, nowadays, those skills are very rare to find on the job market,
    but usually, the software *just works*. The point here is that most of the time,
    nobody exactly knows what the software does, as it’s poorly documented and tested.
    Moreover, you usually don’t have automated release procedures, so every time you
    perform a bugfix, you have to cross your fingers. Needless to say, a proper testing
    environment has never been utilized, so most of the things have to be tested in
    production.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旧系统**：大型应用程序，通常运行企业核心功能多年（至少超过10年，通常超过20年）。不用说，这里的科技不是最新的（**Cobol**在这个领域很常见，但也可以看到其他东西，如**PL
    SQL**、巨大的批处理脚本，甚至**C**/**C++**代码）。然而，语言在这里很少成为问题。当然，如今，这些技能在就业市场上非常罕见，但通常软件“只是运行”。这里的重点是，大多数时候，没有人确切知道软件做什么，因为它的文档和测试都很差。此外，你通常没有自动发布程序，所以每次进行错误修复时，你都必须交叉手指。不用说，适当的测试环境从未被利用，所以大多数东西都必须在生产中进行测试。'
- en: '**Web (and mobile)**: This is another big chunk of the enterprise architecture.
    Usually, it is easier to govern than legacy but still very critical. Indeed, by
    design, these applications are heavily customer-facing, so you can’t afford downtime
    or critical bugs. In terms of technologies, the situation here is more fragmented.
    Newer deployments are almost exclusively made of **Single-Page Applications**
    (**SPAs**) based on JavaScript (implemented with frameworks such as Angular, Vue,
    and React). Backends are REST services implemented in JavaScript (**Node.js**)
    or Java.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web（和移动）**：这是企业架构的另一大块。通常，它比旧系统更容易管理，但仍非常关键。事实上，按照设计，这些应用程序面向客户非常严重，因此你无法承受停机时间或关键错误。在技术方面，这里的状况更加碎片化。较新的部署几乎全部由基于JavaScript的**单页应用程序（SPA**）（使用Angular、Vue和React等框架实现）组成。后端是使用JavaScript（**Node.js**）或Java实现的REST服务。'
- en: '**Business applications**: Often, the gap between web applications and business
    applications is very thin. Here, the rule of thumb is that business applications
    are less web-centric (even if they often have a web GUI), and usually, they are
    not customer exposed. The most common kind of business application is the management
    of internal back-office processes. It’s hard to find a recurrent pattern in business
    applications since it’s an area that contains very different things (such as CRMs,
    HR applications, branch office management, and more).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**商业应用**：通常，Web应用和商业应用之间的差距非常小。在这里，经验法则是商业应用不太以Web为中心（即使它们通常有一个Web图形用户界面），而且通常它们不直接面向客户。最常见的商业应用是内部后台流程的管理。在商业应用中很难找到一个反复出现的模式，因为这个领域包含了很多不同的事物（如CRM、HR应用、分支机构管理等等）。'
- en: '**BigData**: Under various names and nuances (such as data warehouses, data
    lakes, and AI), BigData is commonly a very huge workload in terms of the resources
    required. Here, the technologies are often packaged software, while custom development
    is done using various languages, depending on the core engine chosen. The most
    common languages in this area are Java (Scala), **R** (which is decreasing in
    popularity), and **Python** (which is increasing in popularity). In some implementations,
    a big chunk of SQL is used to stitch calculations together.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大数据**：在各种各样的名称和细微差别（如数据仓库、数据湖和AI）下，大数据通常在所需资源方面是一个非常大的工作负载。在这里，技术通常是打包的软件，而定制开发则使用各种语言进行，具体取决于所选的核心引擎。这个领域最常用的语言是Java（Scala）、**R**（其受欢迎程度正在下降）和**Python**（其受欢迎程度正在上升）。在某些实现中，大量SQL被用来拼接计算。'
- en: '**Middlewares and infrastructure**: Here falls everything that glues the other
    apps together. The most common pattern here is the integration (synchronous or
    asynchronous). The keywords are ESB, SOA, and messaging. Other things such as
    **Single Sign-On** and identity providers can be included here.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件和基础设施**：这里包括了所有粘合其他应用的东西。这里最常见的模式是集成（同步或异步）。关键词是ESB、SOA和消息传递。其他如**单点登录**和身份提供者也可以包括在内。'
- en: As I mentioned, this is just a coarse-grained classification, useful as reference
    points regarding where our application will fit and which other actor our application
    will be interacting with.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，这仅仅是一个粗粒度的分类，作为参考点，了解我们的应用程序将适合哪里，以及我们的应用程序将与其他哪些参与者进行交互。
- en: Notice that the technologies mentioned are mostly *traditional* ones. With the
    emergence of modern paradigms (such as the cloud, microservices, and serverless),
    new languages and stacks are quickly gaining their place. Notable examples are
    Go in the microservice development area and Rust for system programming.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，提到这些技术大多是**传统**的。随着现代范例（如云、微服务和无服务器）的出现，新的语言和堆栈正在迅速占据其位置。值得注意的例子是在微服务开发领域的Go和用于系统编程的Rust。
- en: However, those technologies and approaches are often just evolutions (or brand-new
    applications) belonging to the same categories. Here, the most interesting exception
    is in the middleware area, where some approaches are decreasing in popularity
    (for example, SOA) in favor of lighter alternatives. We will discuss this in [*Chapter
    7*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164), *Exploring Middleware and
    Frameworks*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些技术和方法通常只是同一类别中的演变（或全新的应用）。在这里，最有趣的例外是在中间件领域，其中一些方法（例如SOA）在更轻量级的替代品面前正在减少其受欢迎程度。我们将在[*第7章*](B16354_07_Final_JM_ePUB.xhtml#_idTextAnchor164)中讨论这一点，*探索中间件和框架*。
- en: Now that we’ve explored the widespread usage of Java in an enterprise context,
    let’s take a look at its recent history.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了Java在企业环境中的广泛应用，让我们来看看它的近期历史。
- en: JEE evolution and criticism
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JEE的演变和批评
- en: JEE, as we have learned, is still central in common enterprise applications.
    The heritage of this language is just great. The effort that has been done in
    terms of standardizing a set of APIs for common features (such as transactionality,
    web services, and persistence) is just amazing, and the cooperation between different
    vendors, to provide interoperability and reference implementation, has been a
    very successful one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JEE，正如我们所学的，在常见的企业应用中仍然处于核心地位。这种语言的遗产非常伟大。在标准化一组用于常见功能（如事务性、Web服务和持久性）的API方面所付出的努力令人惊叹，而且不同供应商之间的合作，为了提供互操作性和参考实现，已经是非常成功的一次。
- en: However, in the last couple of years, a different set of needs has emerged.
    The issue with JEE is that in order to preserve long-term stability and cross-vendor
    compatibility, the evolution of the technology is not very quick. With the emergence
    of cloud and more modular applications, features such as observability, modular
    packaging, and access to no SQL databases have become essential for modern applications.
    Of course, standards and committees have also had their moments, with developers
    starting to move away from vanilla implementations and using third-party libraries
    and non-standard approaches.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在过去的几年里，出现了一组不同的需求。JEE的问题在于，为了保持长期稳定性和跨供应商兼容性，技术的演进并不非常迅速。随着云和更模块化应用的兴起，可观察性、模块化打包以及访问No
    SQL数据库等特性已成为现代应用的必要条件。当然，标准和委员会也曾经有过它们的时代，开发者开始从纯实现转向使用第三方库和非标准方法。
- en: 'Important Note:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The objective of this book is not to recap the history and controversy of the
    JEE platform. However, organizational issues (culminating with the donation of
    the project to the Eclipse Foundation) and less frequent releases have contributed
    to the decrease in popularity of the platform.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目标不是回顾JEE平台的过去历史和争议。然而，组织问题（最终以项目捐赠给Eclipse基金会为标志）以及发布频率较低，导致了该平台受欢迎程度的下降。
- en: The upcoming of the **Platform-as-a-Service** (**PaaS**) paradigm is another
    important event that is changing the landscape. Modern orchestration platforms
    (with Kubernetes as the most famous example), both in the cloud or on-premises,
    are moving toward a different approach. We will examine this in greater detail
    later, but essentially, the core concept is that for the sake of scalability and
    control, some of the typical features of the application server (for example,
    clustering and the service registry) are delegated to the platform itself. This
    has a strict liaison with the microservice approach and the benefits they bring.
    In the JEE world, this means that those features become duplicated.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**平台即服务（PaaS**）范式的兴起是另一个重要的变化事件，它正在改变着这一领域的格局。现代编排平台（以Kubernetes为最著名的例子），无论是在云端还是本地，都在朝着不同的方法发展。我们将在稍后更详细地探讨这一点，但核心概念是，为了可扩展性和控制，一些典型的应用服务器特性（例如，集群和服务注册）被委托给了平台本身。这与微服务方法和它们带来的好处有严格的联系。在JEE世界中，这意味着这些特性变得重复。'
- en: Another point is about containerization. One of the focal points of container
    technology is immutability and its impacts in terms of stability and the quality
    of the applications. You package one application into a container and easily move
    it between different environments. Of course, this is, not in the same direction
    as JEE servers, which have been engineered to host multiple applications, managing
    hot deploys and live changes of configurations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点是关于容器化。容器技术的一个焦点是不变性及其在稳定性和应用质量方面的影响。你将一个应用打包到一个容器中，并轻松地在不同环境中移动它。当然，这与设计用来托管多个应用、管理热部署和配置实时更改的JEE服务器不是同一个方向。
- en: A further consideration regarding application servers is that they are, by design,
    optimized for transaction throughput (often at the expense of startup times),
    and their runtime is general-purpose (including libraries covering many different
    use cases). Conversely, the cloud-native approach is usually aimed at a faster
    startup time and a runtime that is as small as possible, bringing only the features
    needed by that particular application. This will be the focus of our next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于应用服务器的一个进一步考虑是，它们在设计上是为了优化事务吞吐量（通常以启动时间为代价），并且它们的运行时是通用性的（包括覆盖许多不同用例的库）。相反，云原生方法通常旨在更快的启动时间和尽可能小的运行时，只提供特定应用需要的特性。这将是我们下一节的重点。
- en: Introducing cloud-native Java
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍云原生Java
- en: 'Since the inception of the microservices concept, in the Java development community,
    the paradigm has increasingly shifted toward the *fat jar approach*. This concept
    is nothing new, as the first examples of *uber jars* (a synonym of the fat jar)
    have been around since the early 2000s, mainly in the desktop development area.
    The idea around them is pretty simple: instead of using dynamic loading of libraries
    at runtime, let’s package them all together into an executable jar to simplify
    the distribution of our application. This is actually the opposite of the model
    of the application servers, which aim to create an environment as configurable
    as possible, supporting things such as hot deployment and the hot-swapping of
    libraries, privileging the uptime to immutability (and predictability).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 自从微服务概念诞生以来，在Java开发社区中，范式已经越来越多地转向**胖jar方法**。这个概念并不新鲜，因为*uber jars*（胖jar的同义词）的早期例子可以追溯到2000年代初，主要在桌面开发领域。围绕它们的想法相当简单：与其在运行时动态加载库，不如将它们全部打包到一个可执行jar中，以简化我们应用程序的分布。这实际上是应用程序服务器模型的相反，应用程序服务器旨在创建尽可能可配置的环境，支持诸如热部署和库的热插拔等功能，优先考虑可用性而不是不可变性（和可预测性）。
- en: 'In container-based and cloud-native applications, fat jar approaches have begun
    to be viewed as the perfect candidate for the implementation of cloud-native,
    microservices-oriented applications. This is for many different reasons:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于容器和云原生应用程序中，胖jar方法已经开始被视为实现云原生、面向微服务的应用程序的完美候选者。这有多个不同的原因：
- en: '**Testability**: You can easily run and test the application in a local environment
    (it’s enough to have a compatible **Java Virtual Machine** or **JVM**). Moreover,
    if the interface is properly defined and documented, it’s easy to mock other components
    and simulate integration testing.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：你可以在本地环境中轻松运行和测试应用程序（只需要一个兼容的**Java虚拟机**或**JVM**）。此外，如果接口得到适当的定义和文档化，模拟其他组件和进行集成测试就很容易了。'
- en: '`.jar` file and configuration (normally, on a text file or environment variable).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.jar` 文件和配置（通常，在文本文件或环境变量中）。'
- en: '**Stability across environments**: Since everything is self-contained, it’s
    easy to avoid the *works-on-my-machine* effect. The development execution environment
    (usually, the developer machine) is designed pretty similarly to the production
    environment (aside from the configuration, which is usually well separated from
    the code, and of course, the external systems such as the databases). This behavior
    mirrors what is provided by containers, and it’s probably one of the most important
    reasons for the adoption of this approach in the development of microservices.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境稳定性**：由于所有内容都是自包含的，因此很容易避免“在我的机器上工作”的效果。开发执行环境（通常，开发者的机器）设计得与生产环境非常相似（除了配置，通常与代码很好地分离，当然，还有外部系统，如数据库）。这种行为反映了容器提供的内容，这可能是采用这种微服务开发方法最重要的原因之一。'
- en: 'There is one last important consideration to pay attention to: curiously enough,
    the all-in-one fat jar approach, in contrast with what I’ve just said, is theoretically
    conflicting with the optimization provided by the containerization.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个重要的考虑因素需要注意：有趣的是，与我所说的相反，一站式胖jar方法在理论上与容器化的优化相冲突。
- en: 'Indeed, one of the benefits provided by every container technology is *layerization*.
    Put simply, every container is composed by starting with a *base image* and just
    adding what’s needed. A pretty common scenario in the Java world is to create
    the application as a tower composed of the operating system plus the JVM plus
    dependencies plus the application artifact. Let’s take a glance at what this looks
    like in the following diagram. In gray, you will see the base image, which doesn’t
    change with a new release of the application. Indeed, a change to the application
    artifact means only redeploying the last layer on top of the underlying **Base
    Image**:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，每种容器技术都提供了一种好处，那就是**分层**。简单来说，每个容器都是从**基础镜像**开始，只添加所需的内容。在Java世界中，一个相当常见的场景是将应用程序创建为一个由操作系统、JVM、依赖项以及应用程序工件组成的塔楼。让我们看一下以下图中它看起来是什么样子。在灰色部分，你会看到基础镜像，它不会随着应用程序的新版本发布而改变。确实，对应用程序工件所做的更改意味着只需重新部署在底层**基础镜像**之上的最后一层：
- en: '![Figure 1.5 – Layering container images ](img/Figure_1.5_B16354.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 容器镜像分层](img/Figure_1.5_B16354.jpg)'
- en: Figure 1.5 – Layering container images
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 容器镜像分层
- en: As you can see in the preceding diagram, the release in this scenario is as
    light as simply replacing the **Application Artifact** layer (that is, the top
    layer).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图中所见，在这种场景下的发布就像简单地替换 **应用程序工件** 层（即顶层）一样轻。
- en: 'By using the fat jar approach, you cannot implement this behavior. If you change
    something in your application but nothing in the dependencies, you have to rebuild
    the whole **Fat JAR** and put it on top of the JVM layer. You can observe what
    this look like in the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用胖 JAR 方法，您无法实现这种行为。如果您在应用程序中更改了某些内容，但在依赖项中没有更改，您必须重新构建整个 **胖 JAR** 并将其放在
    JVM 层之上。您可以在以下图中观察到这看起来是什么样子：
- en: '![Figure 1.6 – Layering container images and fat jars'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – 层叠容器镜像和胖 JAR'
- en: '](img/Figure_1.6_B16354.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.6_B16354.jpg)'
- en: Figure 1.6 – Layering container images and fat jars
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 层叠容器镜像和胖 JAR
- en: In this scenario, the release includes all of the application dependencies,
    other than the application by itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，发布包括所有应用程序依赖项，除了应用程序本身之外。
- en: While this might appear to be a trivial issue, it could mean hundreds of megabytes
    copied back and forth into your environment, impacting the development and release
    time since most of the things composing the container cannot be cached by the
    container runtime.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能是一个微不足道的问题，但它可能意味着数百兆字节的数据在您的环境中来回复制，影响开发和发布时间，因为容器运行时无法缓存组成容器的多数内容。
- en: Some ecosystems do a bit of experimentation in the field of *hollow jars* to
    essentially replicate an approach similar to the application server. Here, the
    composed (fat) jar is split between the application layer and the dependencies
    layer in order to avoid having to repackage/move everything each time. However,
    this approach is far from being widespread.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生态系统在 *空壳 JAR* 领域进行了一些实验，以本质上复制类似于应用服务器的做法。在这里，组合的（胖）JAR 被分割在应用层和依赖层之间，以便避免每次都需要重新打包/移动所有内容。然而，这种方法远未得到广泛应用。
- en: The Java microservices ecosystem
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 微服务生态系统
- en: One last consideration goes to the ecosystem in the Java microservices world.
    As we were beginning to mention earlier, the approach here is to delegate more
    things to *the platform*. The service itself becomes simpler, having only the
    dependency that is required (to reduce the size and the resource footprint) and
    focusing only on the business logic.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个考虑因素是 Java 微服务世界的生态系统。正如我们之前开始提到的，这里的做法是将更多事情委托给 *平台*。服务本身变得简单，只包含所需的依赖（以减少大小和资源占用），并专注于业务逻辑。
- en: However, some of the features delegated to the application server are still
    required. The service registry, clustering, and configuration are the simplest
    examples that come to mind.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些委托给应用服务器的功能仍然是必需的。服务注册、集群和配置是首先想到的简单例子。
- en: 'Additionally, other, newer needs start to emerge:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，其他，更新的需求开始出现：
- en: '**HealthCheck** is the first need. Since there is no application server to
    ensure your application is up and running, and the application is implemented
    as more than one running artifact, you will end up having to monitor every single
    microservice and possibly restarting it (or doing something different) if it becomes
    unhealthy.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康检查**是第一个需求。由于没有应用服务器来确保您的应用程序正在运行，并且应用程序被实现为多个运行的工件，您最终将不得不监控每个微服务，并在它变得不健康时可能重新启动它（或执行其他操作）。'
- en: '**Visibility** is another need. I might want to visualize the network of connections
    and dependencies, the traffic flowing between components, and more.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见性**是另一个需求。我可能想要可视化连接和依赖的网络，组件之间的流量，以及更多。'
- en: 'Last but not least: **resiliency**. This is often translated as the circuit
    breaker even if it’s not the only pattern to help with that. If something in the
    chain of calls fails, you don’t want the failure to cascade.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是：**弹性**。这通常被翻译为断路器，即使它不是帮助实现这一点的唯一模式。如果调用链中的某个部分失败，您不希望失败级联。
- en: So, as we will discover in the upcoming chapters, a new ecosystem will be needed
    to survive outside the JEE world.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们将在接下来的章节中发现的，需要一个新生态系统才能在 JEE 世界之外生存。
- en: 'Microservices has been a groundbreaking innovation in the world of software
    architectures, and it has started a whole new trend in the world of so-called
    cloud-native architectures (which is the main topic of this book). With this in
    mind, I cannot avoid mentioning another very promising paradigm: **Serverless**.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务在软件架构的世界中是一次颠覆性的创新，它开启了一个全新的趋势，即所谓的云原生架构（本书的主要话题）。考虑到这一点，我无法避免提及另一个非常有前景的范式：**无服务器**。
- en: Serverless borrows some concepts from microservices, such as standardization
    and horizontal scaling, and takes it to the extreme, by relieving the developer
    of any responsibility outside the code itself and delegating aspects such as packaging
    and deployment to an underlying platform. Serverless, as a trend, has become popular
    as a proprietary technology on cloud platforms, but it is increasingly used in
    hybrid cloud scenarios.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器借鉴了微服务的一些概念，如标准化和水平扩展，并将其推向极致，通过减轻开发者在代码本身之外的责任，并将打包和部署等任务委托给底层平台。作为一种趋势，无服务器已成为云平台上的专有技术，但在混合云场景中越来越受欢迎。
- en: Java is not famous in the serverless world. The need for compilation and the
    weight added by the JVM has, traditionally, been seen as a showstopper in the
    serverless world. However, as we will explore further in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*, Java technology is now also gaining some
    momentum in that area.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Java在无服务器世界中并不出名。编译的需要以及JVM带来的重量级问题，传统上被视为无服务器世界的一个障碍。然而，正如我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)中进一步探讨的，*设计云原生架构*，Java技术现在也在该领域获得了一些动力。
- en: And now, in order to better clarify different architectural designs, we will
    examine some examples based on a reference case study.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更好地阐明不同的架构设计，我们将基于一个参考案例研究来检查一些示例。
- en: Case studies and examples
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究和示例
- en: Following up on the handbook approach, each time we face a complex concept,
    I will try to clarify it by providing case studies. Of course, while the cases
    are not real (for reasons you can imagine), the challenges closely resemble several
    first-hand experiences I’ve incurred in my professional history.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着手册方法，每次我们面对一个复杂的概念，我都会尝试通过提供案例研究来澄清它。当然，虽然案例不是真实的（原因你可以想象），但挑战与我在职业生涯中经历的一些亲身经历非常相似。
- en: In this section, we will start from scratch by designing a piece of software
    architecture. Then, we will add details to portray a more precise view. This will
    help you to better understand the first steps in the design of a complex piece
    of architecture.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从头开始设计一个软件架构。然后，我们将添加细节以描绘一个更精确的视图。这将帮助你更好地理解复杂架构设计的第一步。
- en: Case study – mobile payments
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 – 移动支付
- en: In this case study, we will simulate the architecture design of a mobile payment
    solution. As contextual background, let’s suppose that a huge bank, in order to
    increase the service offering toward their customers and following some market
    research, wants to implement a mobile payment application. By definition, a mobile
    payment is a pretty broad term, and it includes many different use cases involving
    financial transactions completed using smartphones.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究中，我们将模拟一个移动支付解决方案的架构设计。作为背景，让我们假设一家大型银行，为了增加面向客户的服务并提供，并遵循一些市场研究，希望实施一个移动支付应用程序。根据定义，移动支付是一个相当宽泛的概念，它包括许多不同的用例，涉及使用智能手机完成的金融交易。
- en: In this particular implementation, we will consider the use case of paying with
    your smartphone by charging you via your mobile phone bill.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的实现中，我们将考虑通过手机账单收费使用智能手机支付的场景。
- en: Essentially, this means implementing a client-server architecture (with the
    clients implemented as a mobile application), interacting both with existing enterprise
    applications and external systems exposed by telecommunication operators. Now,
    let’s now try to analyze some use cases related to this scenario and model it
    by using the different schemas we’ve discussed so far.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，这意味着实现一个客户端-服务器架构（客户端以移动应用程序的形式实现），与现有的企业应用程序和电信运营商公开的外部系统进行交互。现在，让我们尝试分析一些与这一场景相关的用例，并使用我们迄今为止讨论的不同模式对其进行建模。
- en: Whiteboarding the overall architecture
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制整体架构图
- en: 'Beginning on white space, let’s start whiteboarding the overall architecture.
    As we’ve learned, the first step is usually to sketch, at a high level, the relevant
    modules and the relationships between them. It’s not important to be super detailed,
    nor to use a particular style. We are just brainstorming the first shapes on paper:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从空白处开始，让我们开始绘制整体架构。正如我们所学的，第一步通常是高层次的绘制相关模块及其之间的关系。不必过于详细，也不必使用特定的风格。我们只是在纸上头脑风暴第一个形状：
- en: '![Figure 1.7 – Architecture whiteboarding'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.7 – 架构草图'
- en: '](img/Figure_1.7_B16354.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.7 – 软件组件图](img/Figure_1.7_B16354.jpg)'
- en: Figure 1.7 – Architecture whiteboarding
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 架构草图
- en: Here, we have drafted a birds-eye view of the use case. We now know where the
    transaction starts, where the data is saved, and how the user interacts with the
    system.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们草拟了用例的鸟瞰图。我们现在知道交易从哪里开始，数据在哪里保存，以及用户如何与系统交互。
- en: 'Additionally, we have identified the main components of the application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还确定了应用程序的主要组件：
- en: The mobile application (represented together with the user)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动应用程序（与用户一起表示）
- en: The (**CDN**) to serve static resources to the application
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （**CDN**）为应用提供静态资源
- en: The (**CMS**) to configure content to be delivered to the app
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置要发送到应用的（**CMS**）
- en: The backend (**mobile Backend as a Service** or **mBaaS**) to proxy requests
    and responses
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端（**移动后端即服务**或**mBaaS**）用于代理请求和响应
- en: The business logic of the application
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的业务逻辑
- en: '**Session** and **Cache**, to store non-persistent data of the users'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**和**缓存**，用于存储用户的非持久数据'
- en: '**Database**, to store persistent data'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**，用于存储持久数据'
- en: 'Other parts of the application: reporting and data warehousing, authentication,
    **Transactional Backend**, and **Customer Relationship Management** (**CRM**)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的其他部分：报告和数据仓库、身份验证、**事务后端**和**客户关系管理**（**CRM**）
- en: 'As expected, this kind of design has some intrinsic issues:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这种设计有一些固有的问题：
- en: You can observe mixed-use cases (both of the mobile user and the CMS administrator),
    which can be foreseen by the arrows between different components, but it’s barely
    designed.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以观察到混合用例（既包括移动用户也包括CMS管理员），这可以通过不同组件之间的箭头预见，但设计得并不完善。
- en: There is a view in the project timeline regarding the implementation of components
    (reporting and data warehousing appear to be optional in the first phase of the
    project).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目时间线中有一个关于组件实现（报告和数据仓库似乎在项目的第一阶段是可选的）的视图。
- en: Some protocols in the interactions are named (for example, SOAP and REST), but
    it’s not an API specification, nor a network schema. Anyway, even if it’s not
    super detailed, this schema is a good starting point. It helps us to define the
    main application boundaries, it gives a high-level overview of the integration
    points, and overall, it’s a good way to kick off a more detailed analysis. We
    will improve on this in the next section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 交互中的一些协议被命名（例如，SOAP和REST），但这既不是API规范，也不是网络架构。无论如何，即使它不是非常详细，这个架构也是一个好的起点。它帮助我们定义主要的应用边界，提供了一个高级的集成点概述，总的来说，这是一个启动更详细分析的好方法。我们将在下一节中对其进行改进。
- en: Software components diagram
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件组件图
- en: 'In order to address some of the issues highlighted in the previous section,
    I’ve modeled the same system by focusing on software components. This does not
    follow any specific standard even if is pretty similar to the **C4** approach
    (where **C4** stands for **Context, Containers, Components, and Code**; we will
    discuss this further in later chapters):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决前一部分中提出的一些问题，我通过关注软件组件来模拟了相同的系统。即使它与**C4**方法（其中**C4**代表**上下文、容器、组件和代码**）相当相似，但这并不遵循任何特定的标准（我们将在后面的章节中进一步讨论）：
- en: '![Figure 1.8 – Software components diagram'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.8 – 软件组件图'
- en: '](img/Figure_1.8_B16354.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.8_B16354.jpg]'
- en: Figure 1.8 – Software components diagram
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 软件组件图
- en: As you can see, this schema is more homogeneous and better organized than the
    first sketch. At a first glance, you can view what features are provided to the
    user. Additionally, it highlights how the system interacts with each other in
    a structured way (for example, using API calls, reads and writes, and more).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个架构比第一个草图更加统一和有组织。乍一看，您可以查看提供给用户的功能。此外，它还突出了系统如何以结构化的方式相互交互（例如，使用API调用、读取和写入等）。
- en: 'Compared to the first sketch, there are some considerations that we can observe:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个草图相比，我们可以观察到一些考虑因素：
- en: The components are almost the same as the other schema.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件几乎与其他架构相同。
- en: The diagram is less focused on the use case, even if the user is still represented
    (together with a high-level recap of the features available to them).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该图不太关注用例，尽管用户仍然被表示（以及他们可用的功能的高级概述）。
- en: There is no view on the project phases. This helps you to focus on just one
    point of view (architectural components), making the schema less confusing.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有对项目阶段进行概述。这有助于你只关注一个视角（架构组件），使架构图更不令人困惑。
- en: No protocols are named, only high-level interactions (such as reads, writes,
    and API calls).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有命名协议，只有高级交互（如读取、写入和API调用）。
- en: Some technical components are preserved (the database), while others are skipped
    since they have less impact on the functional view (for example, the CDN, which
    is probably more relevant on a network schema).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些技术组件被保留（例如数据库），而其他组件则被跳过，因为它们对功能视图的影响较小（例如，CDN，这可能更适用于网络架构）。
- en: In this section, we learned how to approach the first design of our mobile payments
    application; first, with a more naïve view, then by trying to detail the view
    in a more structured way. In the upcoming chapters, we will discuss how to further
    clarify and enrich those views.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何处理我们移动支付应用程序的第一个设计；首先，以一种更天真的方式，然后尝试以更结构化的方式详细说明视图。在接下来的章节中，我们将讨论如何进一步澄清和丰富这些视图。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this first chapter, we just scratched the surface on the two most essential
    topics of this book: the different types of architectural design and the relevance
    of Java technology in the enterprise world.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只是触及了本书两个最基本主题的表面：不同的架构设计类型以及Java技术在企业世界中的相关性。
- en: We have discovered what the first sketches of our software architecture look
    like and why they are relevant, even if they are not very detailed. Then, we moved
    on to different schemas (such as software components, the infrastructure, and
    the network) to get a glimpse of other schema styles, which is useful to address
    specific areas of interest. On the Java side, we made some considerations about
    the role of Java in the enterprise landscape and how the language is evolving
    to meet the challenges of modern cloud environments.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经发现了我们的软件架构初稿的样子以及为什么它们是相关的，即使它们并不非常详细。然后，我们转向不同的架构（如软件组件、基础设施和网络）以一瞥其他架构风格，这对于解决特定兴趣领域是有用的。在Java方面，我们对Java在企业景观中的作用以及该语言如何演变以应对现代云环境挑战进行了一些思考。
- en: These concepts will be useful starting points for the two core concepts of this
    book. On the architectural side, we’ve grasped how complex and important it is
    to view, analyze, and design a proper architecture. From a technological point
    of view, we’ve learned how Java, the technology we will focus on for the rest
    of this book, is very widespread in the enterprise context and how it is still
    relevant for building modern, cloud-native applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念将是本书两个核心概念的有用起点。在架构方面，我们已经掌握了如何观察、分析和设计适当的架构的复杂性和重要性。从技术角度来看，我们已经了解到Java，本书余下部分我们将关注的语言，在企业环境中非常普遍，并且它对于构建现代、云原生应用仍然相关。
- en: In the next chapter, we will start working with requirements. Requirement gathering
    and specifications are essential in order to rework our architectural design,
    adding more details and ensuring the final product will meet customer expectations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始处理需求。需求收集和规范对于重新设计我们的架构设计至关重要，以便添加更多细节并确保最终产品能够满足客户期望。
- en: Further reading
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Who Needs an Architect?* by Martin Fowler ([http://files.catwell.info/misc/mirror/2003-martin-fowler-who-needs-an-architect.pdf](http://files.catwell.info/misc/mirror/2003-martin-fowler-who-needs-an-architect.pdf))'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*谁需要架构师？*，作者Martin Fowler ([http://files.catwell.info/misc/mirror/2003-martin-fowler-who-needs-an-architect.pdf](http://files.catwell.info/misc/mirror/2003-martin-fowler-who-needs-an-architect.pdf))'
- en: '*Don’t Put Fat Jars in Docker Images* by Philipp Hauer ([https://phauer.com/2019/no-fat-jar-in-docker-image](https://phauer.com/2019/no-fat-jar-in-docker-image))'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要在Docker镜像中放入胖JAR*，作者Philipp Hauer ([https://phauer.com/2019/no-fat-jar-in-docker-image](https://phauer.com/2019/no-fat-jar-in-docker-image))'
