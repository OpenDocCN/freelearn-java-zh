- en: Thread Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程管理
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating, running, and setting the characteristics of a thread
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、运行和设置线程的特性
- en: Interrupting a thread
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断一个线程
- en: Controlling the interruption of a thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制线程的中断
- en: Sleeping and resuming a thread
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 睡眠和恢复线程
- en: Waiting for the finalization of a thread
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待线程的最终化
- en: Creating and running a daemon thread
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和运行守护线程
- en: Processing uncontrolled exceptions in a thread
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程中处理未受控的异常
- en: Using thread local variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程局部变量
- en: Grouping threads and processing uncontrolled exceptions in a group of threads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组线程和处理线程组中的未受控异常
- en: Creating threads through a factory
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过工厂创建线程
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the computer world, when we talk about concurrency, we refer to a series
    of independent and unrelated tasks that run simultaneously on a computer. This
    simultaneity can be real if the computer has more than one processor or a multi-core
    processor, or it can be apparent if the computer has only one core processor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机世界中，当我们谈论并发时，我们指的是一系列在计算机上同时独立且无关的任务。这种同时性可以是真实的，如果计算机有多个处理器或多核处理器，或者如果计算机只有一个核心处理器，它也可以是明显的。
- en: All modern operating systems allow the execution of concurrent tasks. You can
    read your e-mails while listening to music or reading news on a web page. We can
    say this is process-level concurrency. But inside a process, we can also have
    various simultaneous tasks. Concurrent tasks that run inside a process are called
    **threads**. Another concept related to concurrency is parallelism. There are
    different definitions and relations with the concurrency concept. Some authors
    talk about concurrency when you execute your application with multiple threads
    in a single-core processor. With this, you can see when your program execution
    is apparent. They talk about parallelism when you execute your application with
    multiple threads in a multi-core processor or in a computer with more than one
    processor, so this case is real as well. Other authors talk about concurrency
    when the threads of an application are executed without a predefined order, and
    they discuss parallelism when all these threads are executed in an ordered way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代操作系统都允许执行并发任务。您可以在听音乐或阅读网页上的新闻时阅读电子邮件。我们可以称这为进程级别的并发。但在一个进程内部，我们也可以有各种同时进行的任务。在进程内部运行的并发任务被称为**线程**。与并发相关的另一个概念是并行性。关于并发概念有不同的定义和关系。一些作者在您在单核处理器上使用多个线程执行应用程序时谈论并发。有了这个，您可以看到程序执行何时明显。他们谈论并行性，当您在多核处理器或具有多个处理器的计算机上使用多个线程执行应用程序时，这种情况也是真实的。其他作者在应用程序的线程没有预定义的顺序执行时谈论并发，他们在所有这些线程有顺序执行时讨论并行性。
- en: This chapter presents a number of recipes that will show you how to perform
    basic operations with threads, using the Java 9 API. You will see how to create
    and run threads in a Java program, how to control their execution, process exceptions
    thrown by them, and how to group some threads to manipulate them as a unit.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一系列的食谱，展示了如何使用Java 9 API对线程执行基本操作。您将了解如何在Java程序中创建和运行线程，如何控制它们的执行，处理它们抛出的异常，以及如何将一些线程分组以作为一个单元来操作。
- en: Creating, running, and setting the characteristics of a thread
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、运行和设置线程的特性
- en: 'In this recipe, we will learn how to do basic operations over a thread using
    the Java API. As with every element in the Java language, threads are objects.
    We have two ways of creating a thread in Java:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用Java API对线程执行基本操作。与Java语言中的每个元素一样，线程是对象。在Java中创建线程有两种方式：
- en: Extending the `Thread` class and overriding the `run()` method.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`Thread`类并重写`run()`方法。
- en: Building a class that implements the `Runnable` interface and the `run()` method
    and then creating an object of the `Thread` class by passing the `Runnable` object
    as a parameter--this is the preferred approach and it gives you more flexibility.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个实现`Runnable`接口和`run()`方法的类，然后通过传递`Runnable`对象作为参数来创建`Thread`类的对象--这是首选的方法，并且给您更多的灵活性。
- en: 'In this recipe, we will use the second approach to create threads. Then, we
    will learn how to change some attributes of the threads. The `Thread` class saves
    some information attributes that can help us identify a thread, know its status,
    or control its priority. These attributes are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用第二种方法来创建线程。然后，我们将学习如何更改线程的一些属性。`Thread` 类保存一些信息属性，可以帮助我们识别线程，了解其状态或控制其优先级。这些属性包括：
- en: '**ID**: This attribute stores a unique identifier for each thread.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID**：此属性存储每个线程的唯一标识符。'
- en: '**Name**: This attribute stores the name of the thread.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：此属性存储线程的名称。'
- en: '**Priority**: This attribute stores the priority of the `Thread` objects. In
    Java 9, threads can have priority between 1 and 10, where 1 is the lowest priority
    and 10 is the highest. It''s not recommended that you change the priority of the
    threads. It''s only a hint to the underlying operating system and it doesn''t
    guarantee anything, but it''s a possibility that you can use if you want.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：此属性存储 `Thread` 对象的优先级。在 Java 9 中，线程的优先级介于 1 和 10 之间，其中 1 是最低优先级，10
    是最高优先级。不建议更改线程的优先级。它只是对底层操作系统的提示，并不保证任何事情，但它是一个你可以使用的可能性。'
- en: '**Status**: This attribute stores the status of a thread. In Java, a thread
    can be present in one of the six states defined in the `Thread.State` enumeration:
    `NEW`, `RUNNABLE`, `BLOCKED`, `WAITING`, `TIMED_WAITING`, or `TERMINATED`. The
    following is a list specifying what each of these states means:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：此属性存储线程的状态。在 Java 中，线程可以存在于 `Thread.State` 枚举中定义的六个状态之一：`NEW`、`RUNNABLE`、`BLOCKED`、`WAITING`、`TIMED_WAITING`
    或 `TERMINATED`。以下是一个列表，说明了这些状态的含义：'
- en: '`NEW`: The thread has been created and it has not yet started'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEW`：线程已被创建，但尚未启动'
- en: '`RUNNABLE`: The thread is being executed in the JVM'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNABLE`：线程正在 JVM 中执行'
- en: '`BLOCKED`: The thread is blocked and it is waiting for a monitor'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOCKED`：线程被阻塞，正在等待监视器'
- en: '`WAITING`: The thread is waiting for another thread'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAITING`：线程正在等待另一个线程'
- en: '`TIMED_WAITING`: The thread is waiting for another thread with a specified
    waiting time'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMED_WAITING`：线程正在等待另一个具有指定等待时间的线程'
- en: '`TERMINATED`: The thread has finished its execution'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERMINATED`：线程已完成其执行'
- en: In this recipe, we will implement an example that will create and run 10 threads
    that would calculate the prime numbers within the first 20,000 numbers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现一个示例，该示例将创建并运行 10 个线程，这些线程将计算前 20,000 个数字内的素数。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example for this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Calculator` that implements the `Runnable` interface:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Calculator` 的类，该类实现了 `Runnable` 接口：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implement the `run()` method. This method will execute the instructions of
    the thread we are creating, so this method will calculate the prime numbers within
    the first `20000` numbers:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。此方法将执行我们创建的线程的指令，因此此方法将在前 `20000` 个数字内计算素数：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, implement the *auxiliar* `isPrime()` method. This method determines whether
    a number is a prime number or not:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现 *辅助* 的 `isPrime()` 方法。此方法确定一个数是否为素数：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now implement the main class of the application. Create a class named `Main`
    that contains the `main()` method:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现应用程序的主类。创建一个名为 `Main` 的类，其中包含 `main()` 方法：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, write some information regarding the values of the maximum, minimum,
    and default priority of the threads:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编写一些关于线程的最大、最小和默认优先级值的信息：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then create 10 `Thread` objects to execute 10 `Calculator` tasks. Also, create
    two arrays to store the `Thread` objects and their statuses. We will use this
    information later to check the finalization of the threads. Execute five threads
    (the even ones) with maximum priority and the other five with minimum priority:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建 10 个 `Thread` 对象来执行 10 个 `Calculator` 任务。同时，创建两个数组来存储 `Thread` 对象及其状态。我们将在以后使用这些信息来检查线程的最终化。执行五个线程（偶数个）以最大优先级，其他五个以最小优先级：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are going to write information in a text file, so create a try-with-resources
    statement to manage the file. Inside this block of code, write the status of the
    threads in the file before you launch them. Then, launch the threads:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要在一个文本文件中写入信息，因此创建一个try-with-resources语句来管理文件。在这个代码块内部，在启动线程之前，将线程的状态写入文件。然后，启动线程：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After this, wait for the finalization of the threads. As we will learn in the
    *Waiting for the finalization of a thread* recipe of this chapter, we can use
    the `join()` method to wait for this to happen. In this case, we want to write
    information about the threads when their statuses change, so we can''t use this
    method. We use this block of code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，等待线程的最终化。正如我们将在本章的*等待线程最终化*食谱中学习的那样，我们可以使用`join()`方法等待这一事件发生。在这种情况下，我们想在线程状态改变时写入有关线程的信息，因此不能使用此方法。我们使用以下代码块：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the previous block of code, we called the `writeThreadInfo()` method to
    write information about the status of a thread in the file. This is the code for
    this method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们调用了`writeThreadInfo()`方法来将有关线程状态的信息写入文件。这是此方法的代码：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program and see how the different threads work in parallel.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并查看不同的线程是如何并行工作的。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the console part of the output of the program.
    We can see that all the threads we have created run in parallel to do their respective
    jobs:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序的输出控制台部分。我们可以看到，我们创建的所有线程都在并行运行，以完成它们各自的工作：
- en: '![](img/00005.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.jpeg)'
- en: 'In this screenshot, you can see how threads are created and how the ones with
    an even number are executed first, as they have the highest priority, and the
    others executed later, as they have minimum priority. The following screenshot
    shows part of the output of the `log.txt` file where we write information about
    the status of the threads:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，你可以看到线程是如何创建的，以及具有偶数编号的线程由于具有最高优先级，因此首先执行，而其他线程由于具有最低优先级，因此稍后执行。以下截图显示了`log.txt`文件的部分输出，我们在其中记录了线程的状态信息：
- en: '![](img/00006.gif)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.gif)'
- en: Every Java program has at least one execution thread. When you run the program,
    JVM runs the execution thread that calls the `main()` method of the program.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Java程序至少有一个执行线程。当你运行程序时，JVM会运行调用程序`main()`方法的执行线程。
- en: When we call the `start()` method of a `Thread` object, we are creating another
    execution thread. Our program will have as many execution threads as the number
    of calls made to the `start()` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`Thread`对象的`start()`方法时，我们正在创建另一个执行线程。我们的程序将拥有与调用`start()`方法的次数一样多的执行线程。
- en: The `Thread` class has attributes to store all of the information of a thread.
    The OS scheduler uses the priority of threads to select the one that uses the
    CPU at each moment and actualizes the status of every thread according to its
    situation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类有属性来存储线程的所有信息。操作系统调度程序使用线程的优先级来选择在每个时刻使用CPU的线程，并根据其情况实际化每个线程的状态。'
- en: 'If you don''t specify a name for a thread, JVM automatically assigns it one
    in this format: Thread-XX, where XX is a number. You can''t modify the ID or status
    of a thread. The `Thread` class doesn''t implement the `setId()` and `setStatus()`
    methods as these methods introduce modifications in the code.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为线程指定名称，JVM会自动按此格式为其分配一个名称：Thread-XX，其中XX是一个数字。你不能修改线程的ID或状态。`Thread`类没有实现`setId()`和`setStatus()`方法，因为这些方法会在代码中引入修改。
- en: A Java program ends when all its threads finish (more specifically, when all
    its non-daemon threads finish). If the initial thread (the one that executes the
    `main()` method) ends, the rest of the threads will continue with their execution
    until they finish. If one of the threads uses the `System.exit()` instruction
    to end the execution of the program, all the threads will end their respective
    execution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java程序的所有线程都结束时（更具体地说，当所有非守护线程都结束时），Java程序结束。如果初始线程（执行`main()`方法的线程）结束，其余的线程将继续执行，直到它们完成。如果其中一个线程使用`System.exit()`指令结束程序的执行，所有线程将结束各自的执行。
- en: Creating an object of the `Thread` class doesn't create a new execution thread.
    Also, calling the `run()` method of a class that implements the `Runnable` interface
    doesn't create a new execution thread. Only when you call the `start()` method,
    a new execution thread is created.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Thread`类的对象不会创建一个新的执行线程。同样，调用实现`Runnable`接口的类的`run()`方法也不会创建一个新的执行线程。只有当你调用`start()`方法时，才会创建一个新的执行线程。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As mentioned in the introduction of this recipe, there is another way of creating
    a new execution thread. You can implement a class that extends the `Thread` class
    and overrides the `run()` method of this class. Then, you can create an object
    of this class and call the `start()` method to have a new execution thread.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如本菜谱的引言中所述，还有另一种创建新执行线程的方法。您可以实现一个扩展`Thread`类的类，并覆盖该类的`run()`方法。然后，您可以创建此类的一个对象并调用`start()`方法以创建一个新的执行线程。
- en: You can use the static method `currentThread()` of the `Thread` class to access
    the thread object that is running the current object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Thread`类的静态方法`currentThread()`来访问正在运行当前对象的线程对象。
- en: You have to take into account that the `setPriority()` method can throw an `IllegalArgumentException`
    exception if you try to establish priority that isn't between 1 and 10.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须考虑到，如果您尝试设置不在1到10之间的优先级，`setPriority()`方法可能会抛出`IllegalArgumentException`异常。
- en: See also
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating threads through a factory* recipe of this chapter
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*通过工厂创建线程*菜谱
- en: Interrupting a thread
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断线程
- en: A Java program with more than one execution thread only finishes when the execution
    of all of its threads end (more specifically, when all its non-daemon threads
    end their execution or when one of the threads uses the `System.exit()` method).
    Sometimes, you may need to finish a thread because you want to terminate a program
    or when a user of the program wants to cancel the tasks that a thread object is
    doing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有多个执行线程的Java程序仅在所有线程的执行结束（更具体地说，当所有非守护线程结束执行或当其中一个线程使用`System.exit()`方法时）后才结束。有时，您可能需要结束一个线程，因为您想终止程序或当程序的用户想要取消线程对象正在执行的任务时。
- en: Java provides an interruption mechanism that indicates to a thread that you
    want to finish it. One peculiarity of this mechanism is that thread objects have
    to check whether they have been interrupted or not, and they can decide whether
    they respond to the finalization request or not. A thread object can ignore it
    and continue with its execution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一个中断机制，该机制指示线程您想要结束它。这个机制的一个特点是线程对象必须检查它们是否被中断，并且它们可以决定是否响应终止请求。线程对象可以忽略它并继续执行。
- en: In this recipe, we will develop a program that creates a thread and forces its
    finalization after 5 seconds, using the interruption mechanism.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将开发一个程序，创建一个线程并在5秒后通过中断机制强制其终止。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example for this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用Eclipse IDE实现。如果您使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class called `PrimeGenerator` that extends the `Thread` class:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PrimeGenerator`的类，该类扩展了`Thread`类：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Override the `run()` method including a loop that will run indefinitely. In
    this loop, process consecutive numbers beginning from one. For each number, calculate
    whether it''s a prime number; if yes, as in this case, write it to the console:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`run()`方法，包括一个无限循环。在这个循环中，从1开始处理连续的数字。对于每个数字，计算它是否为素数；如果是，就像这个例子一样，将其写入控制台：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After processing a number, check whether the thread has been interrupted by
    calling the `isInterrupted()` method. If this method returns `true`, the thread
    has been interrupted. In this case, we write a message in the console and end
    the execution of the thread:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理一个数字后，通过调用`isInterrupted()`方法检查线程是否被中断。如果此方法返回`true`，则线程已被中断。在这种情况下，我们在控制台写入一条消息并结束线程的执行：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implement the `isPrime()` method. You can get its code from the *Creating, running,
    and setting information of a thread* recipe of this chapter.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`isPrime()`的方法。您可以从本章的*创建、运行和设置线程信息*菜谱中获取其代码。
- en: 'Now implement the main class of the example by implementing a class called
    `Main` and the `main()` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过实现一个名为`Main`的类和`main()`方法来实现示例的主类：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create and start an object of the `PrimeGenerator` class:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动`PrimeGenerator`类的一个对象：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Wait for 5 seconds and interrupt the `PrimeGenerator` thread:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待5秒并中断`PrimeGenerator`线程：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, write information related to the status of the interrupted thread. The
    output of this piece of code will depend on whether the thread ends its execution
    before or after:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，写入与中断线程状态相关的信息。此代码的输出将取决于线程是在执行结束之前还是之后结束：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the example and see the results.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the result of the execution of the previous
    example. We can see how the `PrimeGenerator` thread writes the message and ends
    its execution when it detects that it has been interrupted. Refer to the following
    screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上一个示例的执行结果。我们可以看到当 `PrimeGenerator` 线程检测到它被中断时，它会写入消息并结束其执行。请参考以下截图：
- en: '![](img/00007.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.jpeg)'
- en: The `Thread` class has an attribute that stores a `boolean` value indicating
    whether the thread has been interrupted or not. When you call the `interrupt()`
    method of a thread, you set that attribute to `true`. The `isInterrupted()` method
    only returns the value of that attribute.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread` 类有一个属性，用于存储一个表示线程是否被中断的 `boolean` 值。当你调用线程的 `interrupt()` 方法时，你将该属性设置为
    `true`。`isInterrupted()` 方法仅返回该属性的值。'
- en: The `main()` method writes information about the status of the interrupted thread.
    In this case, as this code is executed before the thread has finished its execution,
    the status is `RUNNABLE`, the return value of the `isInterrupted()` method is
    `true`, and the return value of the `isAlive()` method is `true` as well. If the
    interrupted `Thread` finishes its execution before the execution of this block
    of code (you can, for example, sleep the main thread for a second), the methods
    `isInterrupted()` and `isAlive()` will return a `false` value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 方法会写入有关中断线程状态的信息。在这种情况下，由于此代码在线程完成执行之前执行，状态为 `RUNNABLE`，`isInterrupted()`
    方法的返回值为 `true`，同样 `isAlive()` 方法的返回值也是 `true`。如果中断的 `Thread` 在此代码块执行之前完成其执行（例如，你可以让主线程休眠一秒钟），则
    `isInterrupted()` 和 `isAlive()` 方法将返回 `false` 值。'
- en: There's more...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `Thread` class has another method to check whether a thread has been interrupted
    or not. It's the static method, `interrupted()`, that checks whether the current
    thread has been interrupted or not.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread` 类还有一个方法来检查线程是否被中断。这是静态方法 `interrupted()`，它检查当前线程是否被中断。'
- en: There is an important difference between the `isInterrupted()` and `interrupted()`
    methods. The first one doesn't change the value of the interrupted attribute,
    but the second one sets it to `false`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInterrupted()` 和 `interrupted()` 方法之间存在一个重要的区别。第一个方法不会改变中断属性值，但第二个方法将其设置为
    `false`。'
- en: As mentioned earlier, a thread object can ignore its interruption, but this
    is not the expected behavior.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，线程对象可以忽略其中断，但这不是预期的行为。
- en: Controlling the interruption of a thread
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制线程的中断
- en: In the previous recipe, you learned how you can interrupt the execution of a
    thread and what you have to do to control this interruption in the thread object.
    The mechanism shown in the previous example can be used if the thread that can
    be interrupted is simple. But if the thread implements a complex algorithm divided
    into some methods or it has methods with recursive calls, we will need to use
    a better mechanism to control the interruption of the thread. Java provides the
    `InterruptedException` exception for this purpose. You can throw this exception
    when you detect the interruption of a thread and catch it in the `run()` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，你学习了如何中断线程的执行以及如何在线程对象中控制这种中断。如果可以中断的线程很简单，那么前面示例中显示的机制可以使用。但如果线程实现了一个复杂算法，该算法被分成几个方法，或者它有递归调用的方法，我们将需要使用更好的机制来控制线程的中断。Java
    提供了 `InterruptedException` 异常来达到这个目的。当你检测到线程被中断时，你可以抛出这个异常，并在 `run()` 方法中捕获它。
- en: In this recipe, we will implement a task that will look for files with a determined
    name in a folder and in all its subfolders. This is to show how you can use the
    `InterruptedException` exception to control the interruption of a thread.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将实现一个任务，该任务将在文件夹及其所有子文件夹中查找具有指定名称的文件。这是为了展示如何使用 `InterruptedException`
    异常来控制线程的中断。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example for this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例是使用 Eclipse IDE 实现的。如果你使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class called `FileSearch` and specify that it implements the `Runnable`
    interface:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FileSearch` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Declare two private attributes: one for the name of the file we are going to
    search for and one for the initial folder. Implement the constructor of the class,
    which initializes these attributes:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个私有属性：一个用于我们即将搜索的文件名，另一个用于初始文件夹。实现类的构造函数，初始化这些属性：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement the `run()` method of the `FileSearch` class. It checks whether the
    attribute `fileName` is a directory; if it is, it calls the `directoryProcess()`
    method. This method can throw an `InterruptedException` exception, so we have
    to catch them:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `FileSearch` 类的 `run()` 方法。它检查属性 `fileName` 是否是目录；如果是，它将调用 `directoryProcess()`
    方法。此方法可能会抛出 `InterruptedException` 异常，因此我们必须捕获它们：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement the `directoryProcess()` method. This method will obtain the files
    and subfolders in a folder and process them. For each directory, the method will
    make a recursive call, passing the directory as a parameter. For each file, the
    method will call the `fileProcess()` method. After processing all files and folders,
    the method checks whether the thread has been interrupted; if yes, as in this
    case, it will throw an `InterruptedException` exception:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `directoryProcess()` 的方法。此方法将获取文件夹中的文件和子文件夹，并对它们进行处理。对于每个目录，该方法将进行递归调用，并将目录作为参数传递。对于每个文件，该方法将调用
    `fileProcess()` 方法。在处理完所有文件和文件夹后，该方法将检查线程是否被中断；如果是，就像在这个例子中，它将抛出一个 `InterruptedException`
    异常：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the `fileProcess()` method. This method will compare the name of
    the file it''s processing with the name we are searching for. If the names are
    equal, we will write a message in the console. After this comparison, the thread
    will check whether it has been interrupted; if yes, as in this case, it will throw
    an `InterruptedException` exception:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `fileProcess()` 的方法。此方法将比较它正在处理的文件名与我们正在搜索的文件名。如果名称相等，我们将在控制台写入一条消息。在此比较之后，线程将检查它是否被中断；如果是，就像在这个例子中，它将抛出一个
    `InterruptedException` 异常：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let''s implement the main class of the example. Implement a class called
    `Main` that contains the `main()` method:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来实现示例的主类。实现一个名为 `Main` 的类，其中包含 `main()` 方法：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create and initialize an object of the `FileSearch` class and thread to execute
    its task. Then start executing the thread. I have used a Windows operating system
    route. If you work with other operating systems, such as Linux or iOS, change
    the route to the one that exists on your operating system:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并初始化 `FileSearch` 类的对象和线程以执行其任务。然后开始执行线程。我使用了 Windows 操作系统的路径。如果您使用其他操作系统，例如
    Linux 或 iOS，请将路径更改为您操作系统上存在的路径：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Wait for 10 seconds and interrupt the thread:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 10 秒并中断线程：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the example and see the results.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The following screenshot shows the result of an execution of this example. You
    can see how the `FileSearch` object ends its execution when it detects that it
    has been interrupted.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此示例的执行结果。您可以看到当 `FileSearch` 对象检测到它被中断时，它如何结束其执行。
- en: '![](img/00008.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: In this example, we use Java exceptions to control the interruption of a thread.
    When you run the example, the program starts going through folders by checking
    whether they have the file or not. For example, if you enter in the `\b\c\d` folder,
    the program will have three recursive calls to the `directoryProcess()` method.
    When it detects that it has been interrupted, it throws an `InterruptedException`
    exception and continues the execution in the `run()` method, no matter how many
    recursive calls have been made.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 Java 异常来控制线程的中断。当您运行示例时，程序开始通过检查文件夹中是否有文件来遍历文件夹。例如，如果您进入 `\b\c\d`
    文件夹，程序将对 `directoryProcess()` 方法进行三次递归调用。当它检测到被中断时，它将抛出一个 `InterruptedException`
    异常，并在 `run()` 方法中继续执行，无论已经进行了多少次递归调用。
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `InterruptedException` exception is thrown by some Java methods related
    to a concurrency API, such as `sleep()`. In this case, this exception is thrown
    if the thread is interrupted (with the `interrupt()` method) when it's sleeping.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`InterruptedException` 异常是由一些与并发 API 相关的 Java 方法抛出的，例如 `sleep()`。在这种情况下，如果线程在睡眠时被中断（使用
    `interrupt()` 方法），则会抛出此异常。'
- en: See also
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Interrupting a thread* recipe of this chapter
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *中断线程* 菜单
- en: Sleeping and resuming a thread
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 睡眠和恢复线程
- en: Sometimes, you may be interested in pausing the execution of a thread during
    a determined period of time. For example, a thread in a program checks the sensor
    state once per minute. The rest of the time, it does nothing. During this time,
    the thread doesn't use any resources of the computer. After this period is over,
    the thread will be ready to continue with its execution when the operating system
    scheduler chooses it to be executed. You can use the `sleep()` method of the `Thread`
    class for this purpose. This method receives a long number as a parameter that
    indicates the number of milliseconds during which the thread will suspend its
    execution. After that time, the thread continues with its execution in the next
    instruction to the `sleep()` one when the JVM assigns it CPU time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想在确定的时间内暂停线程的执行。例如，程序中的线程每分钟检查一次传感器状态。其余时间，它什么都不做。在这段时间内，线程不使用计算机的任何资源。当这个周期结束后，线程将准备好在操作系统调度器选择它执行时继续执行。你可以使用`Thread`类的`sleep()`方法来实现这个目的。此方法接收一个长整型参数，表示线程将暂停执行多少毫秒。在那之后，线程将在`sleep()`方法的下一个指令继续执行，当JVM分配给它CPU时间时。
- en: Another possibility is to use the `sleep()` method of an element of the `TimeUnit`
    enumeration. This method uses the `sleep()` method of the `Thread` class to put
    the current thread to sleep, but it receives the parameter in the unit that it
    represents and converts it into milliseconds.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是使用`TimeUnit`枚举元素中的`sleep()`方法。此方法使用`Thread`类的`sleep()`方法将当前线程休眠，但它接收的参数是以它所代表的单位，并将其转换为毫秒。
- en: In this recipe, we will develop a program that uses the `sleep()` method to
    write the actual date every second.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将开发一个使用`sleep()`方法每秒写入实际日期的程序。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example for this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class called `ConsoleClock` and specify that it implements the `Runnable`
    interface:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ConsoleClock`的类，并指定它实现`Runnable`接口：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the `run()` method:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现该`run()`方法：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Write a loop with 10 iterations. In each iteration, create a `Date` object,
    write it to the console, and call the `sleep()` method of the `SECONDS` attribute
    of the `TimeUnit` class to suspend the execution of the thread for 1 second. With
    this value, the thread will be sleeping for approximately 1 second. As the `sleep()`
    method can throw an `InterruptedException` exception, we have to include some
    code to catch it. It''s good practice to include code that frees or closes the
    resources the thread is using when it''s interrupted:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个包含10次迭代的循环。在每次迭代中，创建一个`Date`对象，将其写入控制台，并调用`TimeUnit`类中`SECONDS`属性的`sleep()`方法来暂停线程的执行1秒。使用这个值，线程将睡眠大约1秒。由于`sleep()`方法可能会抛出`InterruptedException`异常，我们必须包含一些代码来捕获它。当线程被中断时，释放或关闭线程正在使用的资源是一种良好的做法：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have implemented the thread. Now let''s implement the main class of the
    example. Create a class called `Main` that contains the `main()` method:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经实现了线程。现在让我们实现示例的主类。创建一个名为`Main`的类，其中包含`main()`方法：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create an object of the `FileClock` class and a `thread` to execute it. Then,
    start executing a thread:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`FileClock`类的一个对象和一个执行它的`thread`。然后，开始执行线程：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Call the `sleep()` method of the `SECONDS` attribute of the `TimeUnit` class
    in the main thread to wait for 5 seconds:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主线程中调用`TimeUnit`类中`SECONDS`属性的`sleep()`方法以等待5秒：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Interrupt the `FileClock` thread:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断`FileClock`线程：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the example and see the results.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you run the example, you would see how the program writes a `Date` object
    per second and also the message indicating that the `FileClock` thread has been
    interrupted.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行示例时，你会看到程序每秒写入一个`Date`对象，以及指示`FileClock`线程已被中断的消息。
- en: When you call the `sleep()` method, the thread leaves the CPU and stops its
    execution for a period of time. During this time, it's not consuming CPU time,
    so the CPU could be executing other tasks.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`sleep()`方法时，线程离开CPU并停止执行一段时间。在这段时间内，它不消耗CPU时间，因此CPU可以执行其他任务。
- en: When the thread is sleeping and is interrupted, the method throws an `InterruptedException`
    exception immediately and doesn't wait until the sleeping time is finished.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程正在睡眠并被中断时，该方法会立即抛出`InterruptedException`异常，而不会等待睡眠时间结束。
- en: There's more...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Java concurrency API has another method that makes a thread object leave
    the CPU. It's the `yield()` method, which indicates to the JVM that the thread
    object can leave the CPU for other tasks. The JVM does not guarantee that it will
    comply with this request. Normally, it's only used for debugging purposes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API还有一个使线程对象离开CPU的方法。它是`yield()`方法，它指示JVM线程对象可以离开CPU以执行其他任务。JVM不保证它会遵守这个请求。通常，它仅用于调试目的。
- en: Waiting for the finalization of a thread
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待线程的最终化
- en: In some situations, we will have to wait for the end of the execution of a thread
    (the `run()` method ends its execution). For example, we may have a program that
    will begin initializing the resources it needs before proceeding with the rest
    of the execution. We can run initialization tasks as threads and wait for their
    finalization before continuing with the rest of the program.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们将不得不等待线程（`run()`方法结束执行）的执行结束。例如，我们可能有一个程序，在继续执行其余部分之前，将开始初始化它需要的资源。我们可以将初始化任务作为线程运行，并在继续程序的其他部分之前等待它们的最终化。
- en: For this purpose, we can use the `join()` method of the `Thread` class. When
    we call this method using a thread object, it suspends the execution of the calling
    thread until the object that is called finishes its execution.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们可以使用`Thread`类的`join()`方法。当我们使用线程对象调用此方法时，它会暂停调用线程的执行，直到被调用的对象完成执行。
- en: In this recipe, we will learn the use of this method with an initialization
    example.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将通过初始化示例学习使用此方法。
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example for this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例是使用Eclipse IDE实现的。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class called `DataSourcesLoader` and specify that it implements the
    `Runnable` interface:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DataSourcesLoader`的类，并指定它实现`Runnable`接口：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the `run()` method. It writes a message to indicate that it starts
    its execution, sleeps for 4 seconds, and writes another message to indicate that
    it ends its execution:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它会写一条消息来指示它开始执行，睡眠4秒钟，然后写另一条消息来指示它结束执行：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Create a class called `NetworkConnectionsLoader` and specify that it implements
    the `Runnable` interface. Implement the `run()` method. It will be equal to the
    `run()` method of the `DataSourcesLoader` class, but it will sleep for 6 seconds.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NetworkConnectionsLoader`的类，并指定它实现`Runnable`接口。实现`run()`方法。它将等于`DataSourcesLoader`类的`run()`方法，但它将睡眠6秒钟。
- en: 'Now, create a class called `Main` that contains the `main()` method:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`Main`的类，其中包含`main()`方法：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create an object of the `DataSourcesLoader` class and a thread to run it:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`DataSourcesLoader`类的对象和一个运行它的线程：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create an object of the `NetworkConnectionsLoader` class and a thread to run
    it:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`NetworkConnectionsLoader`类的对象和一个运行它的线程：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Call the `start()` method of both the thread objects:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用两个线程对象的`start()`方法：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Wait for the finalization of both the threads using the `join()` method. This
    method can throw an `InterruptedException` exception, so we have to include the
    code to catch it:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待两个线程的最终化。此方法可能会抛出`InterruptedException`异常，因此我们必须包含捕获它的代码：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Write a message to indicate the end of the program:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一条消息来指示程序的结束：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Run the program and see the results.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并查看结果。
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you run this program, you would understand how both the thread objects
    start their execution. First, the `DataSourcesLoader` thread finishes its execution.
    Then, the `NetworkConnectionsLoader` class finishes its execution. At this moment,
    the `main` thread object continues its execution and writes the final message.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会理解线程对象是如何开始执行的。首先，`DataSourcesLoader`线程完成其执行。然后，`NetworkConnectionsLoader`类完成其执行。在这个时候，`main`线程对象继续执行并写入最终消息。
- en: There's more...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Java provides two additional forms of the `join()` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了`join()`方法的两种附加形式：
- en: '`join (long milliseconds)`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join(long milliseconds)`'
- en: '`join (long milliseconds, long nanos)`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join (long milliseconds, long nanos)`'
- en: 'In the first version of the `join()` method, instead of indefinitely waiting
    for the finalization of the thread called, the calling thread waits for the milliseconds
    specified as the parameter of the method. For example, if the object `thread1`
    has `thread2.join(1000)`, `thread1` suspends its execution until one of these
    two conditions are met:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `join()` 方法的第一个版本中，调用线程不是无限期地等待被调用线程的终止，而是等待方法参数指定的毫秒数。例如，如果对象 `thread1` 有
    `thread2.join(1000)`，则 `thread1` 暂停其执行，直到以下两个条件之一满足：
- en: '`thread2` has finished its execution'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread2` 已完成其执行'
- en: 1,000 milliseconds have passed
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经过去 1,000 毫秒
- en: When one of these two conditions is `true`, the `join()` method returns. You
    can check the status of the thread to know whether the `join()` method was returned
    because it finished its execution or because the specified time had passed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两个条件之一为真时，`join()` 方法返回。您可以通过检查线程的状态来了解 `join()` 方法是因为它完成了执行还是因为指定的超时时间已过而返回。
- en: The second version of the `join()` method is similar to the first one, but it
    receives the number of milliseconds and nanoseconds as parameters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()` 方法的第二个版本与第一个版本类似，但它接收毫秒数和纳秒数作为参数。'
- en: Creating and running a daemon thread
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和运行守护线程
- en: Java has a special kind of thread called **daemon** thread. When daemon threads
    are the only threads running in a program, the JVM ends the program after finishing
    these threads.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Java 有一种特殊的线程称为 **守护线程**。当守护线程是程序中唯一运行的线程时，JVM 在完成这些线程后结束程序。
- en: With these characteristics, daemon threads are normally used as service providers
    for normal (also called **user**) threads running in the same program. They usually
    have an infinite loop that waits for the service request or performs the tasks
    of a thread. A typical example of these kinds of threads is the Java garbage collector.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这些特性的守护线程通常用作同一程序中运行的正常（也称为 **用户**）线程的服务提供者。它们通常有一个无限循环，等待服务请求或执行线程的任务。这些线程的典型示例是
    Java 垃圾收集器。
- en: 'In this recipe, we will learn how to create a daemon thread by developing an
    example with two threads: one user thread that would write events on a queue and
    a daemon thread that would clean the queue, removing the events that were generated
    more than 10 seconds ago.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将通过开发一个包含两个线程的示例来学习如何创建守护线程：一个用户线程将在队列上写入事件，一个守护线程将清理队列，移除生成时间超过 10 秒的事件。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example for this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本例子的实现使用了 Eclipse IDE。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create the `Event` class. This class only stores information about the events
    our program will work with. Declare two private attributes: one called the date
    of the `java.util.Date` type and the other called the event of the `String` type.
    Generate the methods to write and read their values.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Event` 类。此类仅存储程序将处理的事件的信息。声明两个私有属性：一个称为 `java.util.Date` 类型的日期，另一个称为 `String`
    类型的 `event`。生成写入和读取其值的方法。
- en: 'Create the `WriterTask` class and specify that it implements the `Runnable`
    interface:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `WriterTask` 类并指定它实现 `Runnable` 接口：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Declare the queue that stores the events and implement the constructor of the
    class that initializes this queue:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明存储事件的队列并实现初始化此队列的类的构造函数：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Implement the `run()` method of this task. This method will have a loop with
    100 iterations. In each iteration, we create a new event, save it in the queue,
    and sleep for 1 second:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现此任务的 `run()` 方法。该方法将有一个 100 次迭代的循环。在每次迭代中，我们创建一个新的事件，将其保存到队列中，并暂停 1 秒：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the `CleanerTask` class and specify that it extends the `Thread` class:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `CleanerTask` 类并指定它扩展 `Thread` 类：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Declare the queue that stores the events and implement the constructor of the
    class that initializes this queue. In the constructor, mark this thread as a daemon
    thread with the `setDaemon()` method:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明存储事件的队列并实现初始化此队列的类的构造函数。在构造函数中，使用 `setDaemon()` 方法将此线程标记为守护线程：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Implement the `run()` method. It has an infinite loop that gets the actual
    date and calls the `clean()` method:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现该 `run()` 方法。它有一个无限循环，获取实际日期并调用 `clean()` 方法：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Implement the `clean()` method. It gets the last event, and if it was created
    more than 10 seconds ago, it deletes it and checks the next event. If an event
    is deleted, it writes the message of the event and the new size of the queue so
    you can see its evolution:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`clean()`方法。它获取最后一个事件，如果它是在10秒前创建的，则删除它并检查下一个事件。如果事件被删除，则写入事件的消息和队列的新大小，以便你可以看到其演变：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now implement the `main` class. Create a class called `Main` with a `main()`
    method:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现`main`类。创建一个名为`Main`的类，其中包含一个`main()`方法：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create the queue to store the events using the `Deque` class:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Deque`类创建存储事件的队列：
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create and start as many `WriterTask` threads as available processors have
    the JVM and one `CleanerTask` method:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动尽可能多的`WriterTask`线程，数量与JVM可用的处理器数量相同，以及一个`CleanerTask`方法：
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Run the program and see the results.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并查看结果。
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you analyze the output of one execution of the program, you would see how
    the queue begins to grow until it has a size of, in our case, `40` events. Then,
    its size will vary around `40` events it has grown up to until the end of the
    execution. This size may depend on the number of cores of your machine. I have
    executed the code in a four-core processor, so we launch four `WriterTask` tasks.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分析程序的一次执行输出，你会看到队列开始增长，直到它达到我们案例中的`40`个事件大小。然后，它的大小将围绕`40`个事件波动，直到执行结束。这个大小可能取决于你机器的核心数。我在一个四核处理器上执行了代码，所以我们启动了四个`WriterTask`任务。
- en: The program starts with four `WriterTask` threads. Each thread writes an event
    and sleeps for 1 second. After the first `10` seconds, we have `40` events in
    the queue. During these `10` seconds, `CleanerTask` are executed whereas the four `WriterTask`
    threads sleep; however, but it doesn't delete any event because all of them were
    generated less than `10` seconds ago. During the rest of the execution, `CleanerTask`
    deletes four events every second and the four `WriterTask` threads write another
    four; therefore, the size of the queue varies around `40` events it has grown
    up to. Remember that the execution of this example depends on the number of available
    cores to the JVM of your computer. Normally, this number is equal to the number
    of cores of your CPU.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从四个`WriterTask`线程开始。每个线程写入一个事件并休眠1秒。在最初的`10`秒后，队列中有`40`个事件。在这`10`秒内，`CleanerTask`正在执行，而四个`WriterTask`线程处于休眠状态；然而，它并没有删除任何事件，因为所有事件都是在`10`秒前生成的。在剩余的执行过程中，`CleanerTask`每秒删除四个事件，而四个`WriterTask`线程再写入四个；因此，队列的大小在`40`个事件左右波动。记住，这个示例的执行取决于你电脑的JVM可用的核心数。通常，这个数字等于你CPU的核心数。
- en: You can play with time until the `WriterTask` threads are sleeping. If you use
    a smaller value, you will see that `CleanerTask` has less CPU time and the size
    of the queue will increase because `CleanerTask` doesn't delete any event.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整时间，直到`WriterTask`线程处于休眠状态。如果你使用较小的值，你会看到`CleanerTask`的CPU时间更少，队列的大小会增加，因为`CleanerTask`不会删除任何事件。
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You only can call the `setDaemon()` method before you call the `start()` method.
    Once the thread is running, you can't modify its daemon status calling the `setDaemon()`
    method. If you call it, you will get an `IllegalThreadStateException` exception.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在调用`start()`方法之前调用`setDaemon()`方法。一旦线程开始运行，就不能通过调用`setDaemon()`方法来修改其守护状态。如果你调用它，你会得到一个`IllegalThreadStateException`异常。
- en: You can use the `isDaemon()` method to check whether a thread is a daemon thread
    (the method returns `true`) or a non-daemon thread (the method returns `false`).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`isDaemon()`方法来检查一个线程是否是守护线程（该方法返回`true`）或非守护线程（该方法返回`false`）。
- en: Processing uncontrolled exceptions in a thread
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程中处理未受控的异常
- en: A very important aspect in every programming language is the mechanism that
    helps you manage error situations in your application. The Java programming language,
    as almost all modern programming languages, implements an exception-based mechanism
    to manage error situations. These exceptions are thrown by Java classes when an
    error situation is detected. You can also use these exceptions or implement your
    own exceptions to manage the errors produced in your classes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种编程语言中，一个非常重要的方面是帮助你在应用程序中管理错误情况的机制。Java编程语言，就像几乎所有现代编程语言一样，实现了一个基于异常的机制来管理错误情况。当检测到错误情况时，Java类会抛出这些异常。你也可以使用这些异常或实现你自己的异常来管理你在类中产生的错误。
- en: 'Java also provides a mechanism to capture and process these exceptions. There
    are exceptions that must be captured or re-thrown using the `throws` clause of
    a method. These exceptions are called checked exceptions. There are exceptions
    that don''t have to be specified or caught. These are unchecked exceptions:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Java还提供了一个机制来捕获和处理这些异常。有一些异常必须使用方法的`throws`子句捕获或重新抛出。这些异常被称为检查异常。还有一些异常不需要指定或捕获。这些是未检查异常：
- en: '**Checked exceptions**: These must be specified in the `throws` clause of a
    method or caught inside them, for example, `IOException` or `ClassNotFoundException`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查异常**：这些必须在方法的`throws`子句中指定或在其中捕获，例如`IOException`或`ClassNotFoundException`。'
- en: '**Unchecked exceptions**: These don''t need to be specified or caught, for
    example, `NumberFormatException`.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未检查异常**：这些不需要指定或捕获，例如`NumberFormatException`。'
- en: When a checked exception is thrown inside the `run()` method of a thread object,
    we have to catch and treat them because the `run()` method doesn't accept a `throws`
    clause. When an unchecked exception is thrown inside the `run()` method of a thread
    object, the default behavior is to write the stack trace in the console and exit
    the program.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程对象的`run()`方法内部抛出检查异常时，我们必须捕获并处理它们，因为`run()`方法不接受`throws`子句。当线程对象的`run()`方法内部抛出未检查异常时，默认行为是在控制台写入堆栈跟踪并退出程序。
- en: Fortunately, Java provides us with a mechanism to catch and treat unchecked
    exceptions thrown in a thread object to avoid ending the program.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Java为我们提供了一个机制来捕获和处理线程对象中抛出的未检查异常，以避免程序结束。
- en: In this recipe, we will learn this mechanism using an example.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将通过示例学习这个机制。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example for this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'First of all, we have to implement a class to treat unchecked exceptions. This
    class must implement the `UncaughtExceptionHandler` interface and implement the
    `uncaughtException()` method declared in this interface. It''s an interface enclosed
    in the `Thread` class. In our case, let''s call this class `ExceptionHandler`
    and create a method to write information about `Exception` and `Thread` that threw
    it. The following is the code:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须实现一个类来处理未检查异常。这个类必须实现`UncaughtExceptionHandler`接口并实现该接口中声明的`uncaughtException()`方法。这是一个包含在`Thread`类中的接口。在我们的情况下，让我们称这个类为`ExceptionHandler`并创建一个方法来写入有关`Exception`和抛出它的`Thread`的信息。以下是其代码：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now implement a class that throws an unchecked exception. Call this class `Task`,
    specify that it implements the `Runnable` interface, implement the `run()` method,
    and force the exception; for example, try to convert a `String` value into an
    `int` value:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现一个抛出未检查异常的类。将此类命名为`Task`，指定它实现`Runnable`接口，实现`run()`方法，并强制抛出异常；例如，尝试将`String`值转换为`int`值：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now implement the main class of the example. Implement a class called `Main`
    with its `main()` method:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现示例的主类。实现一个名为`Main`的类，并实现其`main()`方法：
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a `Task` object and `Thread` to run it. Set the unchecked exception
    handler using the `setUncaughtExceptionHandler()` method and start executing the
    thread:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Task`对象和一个`Thread`来运行它。使用`setUncaughtExceptionHandler()`方法设置未捕获异常处理器并开始执行线程：
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Run the example and see the results.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following screenshot, you can see the results of the execution of the
    example. The exception is thrown and captured by the handler that writes the information
    about `Exception` and `Thread` that threw it. This information is presented in
    the console:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图，你可以看到示例执行的输出结果。异常被抛出并由写入有关`Exception`和抛出它的`Thread`信息的处理器捕获。这些信息在控制台显示：
- en: '![](img/00009.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00009.jpeg)'
- en: When an exception is thrown in a thread and remains uncaught (it has to be an
    unchecked exception), the JVM checks whether the thread has an uncaught exception
    handler set by the corresponding method. If it does, the JVM invokes this method
    with the `Thread` object and `Exception` as arguments.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程中抛出异常且未被捕获（它必须是一个未检查异常）时，JVM会检查线程是否设置了相应方法指定的未捕获异常处理器。如果设置了，JVM会使用`Thread`对象和`Exception`作为参数调用此方法。
- en: If the thread doesn't have an uncaught exception handler, the JVM prints the
    stack trace in the console and ends the execution of the thread that had thrown
    the exception.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程没有未捕获异常处理程序，JVM将在控制台打印堆栈跟踪，并结束抛出异常的线程的执行。
- en: There's more...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Thread` class has another method related to the process of uncaught exceptions.
    It's the static method `setDefaultUncaughtExceptionHandler()` that establishes
    an exception handler for all the thread objects in the application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类还有一个与未捕获异常处理过程相关的静态方法。它是`setDefaultUncaughtExceptionHandler()`，它为应用程序中所有线程对象设置异常处理程序。'
- en: When an uncaught exception is thrown in the thread, the JVM looks for three
    possible handlers for this exception.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程抛出未捕获异常时，JVM会寻找三种可能的异常处理程序。
- en: First it looks for the uncaught exception handler of the thread objects, as
    we learned in this recipe. If this handler doesn't exist, the JVM looks for the
    uncaught exception handler of `ThreadGroup` as explained in the *Grouping threads
    and processing uncontrolled exceptions in a group of threads* recipe. If this
    method doesn't exist, the JVM looks for the default uncaught exception handler,
    as we learned in this recipe.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先它查找线程对象的未捕获异常处理程序，正如我们在本配方中学到的。如果此处理程序不存在，JVM将查找`ThreadGroup`的未捕获异常处理程序，正如我们在*将线程分组并处理线程组中的未受控异常*配方中解释的那样。如果此方法不存在，JVM将查找默认的未捕获异常处理程序，正如我们在本配方中学到的。
- en: If none of the handlers exits, the JVM writes the stack trace of the exception
    in the console and ends the execution of the Thread that had thrown the exception.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有处理程序退出，JVM将在控制台写入异常的堆栈跟踪，并结束抛出异常的线程的执行。
- en: See also
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Grouping threads and processing uncontrolled exceptions in a group of threads*
    recipe of this chapter
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*将线程分组并处理线程组中的未受控异常*配方
- en: Using thread local variables
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程局部变量
- en: One of the most critical aspects of a concurrent application is shared data.
    This has special importance in objects that extend the `Thread` class or implement
    the `Runnable` interface and in objects that are shared between two or more threads.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 并发应用程序中最关键的一个方面是共享数据。这在扩展`Thread`类或实现`Runnable`接口的对象中，以及在两个或更多线程之间共享的对象中具有特殊的重要性。
- en: If you create an object of a class that implements the `Runnable` interface
    and then start various thread objects using the same `Runnable` object, all the
    threads would share the same attributes. This means that if you change an attribute
    in a thread, all the threads will be affected by this change.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个实现`Runnable`接口的类的对象，然后使用相同的`Runnable`对象启动各种线程对象，所有这些线程都会共享相同的属性。这意味着如果你在一个线程中更改一个属性，所有线程都会受到影响。
- en: Sometimes, you will be interested in having an attribute that won't be shared
    among all the threads that run the same object. The Java Concurrency API provides
    a clean mechanism called **thread-local variables** with very good performance.
    They have some disadvantages as well. They retain their value while the thread
    is alive. This can be problematic in situations where threads are reused.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能希望有一个属性，它不会被运行相同对象的全部线程共享。Java并发API提供了一个性能非常好的干净机制，称为**线程局部变量**。它们也有一些缺点。它们在线程存活期间保留其值。在线程重用的情况下，这可能会成为问题。
- en: 'In this recipe, we will develop two programs: one that would expose the problem
    in the first paragraph and another that would solve this problem using the thread-local
    variables mechanism.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将开发两个程序：一个将暴露第一段中的问题，另一个将使用线程局部变量机制解决这个问题。
- en: Getting ready
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example for this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的示例是使用Eclipse IDE实现的。如果你使用Eclipse或NetBeans等不同的IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement the example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'First, implement a program that has the problem exposed previously. Create
    a class called `UnsafeTask` and specify that it implements the `Runnable` interface.
    Declare a private `java.util.Date` attribute:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，实现一个暴露了之前问题的程序。创建一个名为`UnsafeTask`的类，并指定它实现`Runnable`接口。声明一个私有的`java.util.Date`属性：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Implement the `run()` method of the `UnsafeTask` object. This method will initialize
    the `startDate` attribute, write its value to the console, sleep for a random
    period of time, and again write the value of the `startDate` attribute:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现对象`UnsafeTask`的`run()`方法。此方法将初始化`startDate`属性，将其值写入控制台，随机暂停一段时间，然后再次写入`startDate`属性的值：
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, implement the main class of this problematic application. Create a class
    called `Main` with a `main()` method. This method will create an object of the
    `UnsafeTask` class and start `10` threads using this object, sleeping for 2 seconds
    between each thread:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现这个有问题的应用程序的主类。创建一个名为`Main`的类，并具有`main()`方法。此方法将创建一个`UnsafeTask`类的对象，并使用此对象启动`10`个线程，每个线程之间暂停2秒：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the following screenshot, you can see the results of this program''s execution.
    Each thread has a different start time, but when they finish, there is a change
    in the value of the attribute. So they are writing a bad value. For example, check
    out the thread with the ID 13:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，您可以看到此程序执行的结果。每个线程都有一个不同的开始时间，但它们完成时，属性值发生了变化。因此，它们正在写入一个错误值。例如，检查ID为13的线程：
- en: '![](img/00010.jpeg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00010.jpeg)'
- en: As mentioned earlier, we are going to use the thread-local variables mechanism
    to solve this problem.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用线程局部变量机制来解决这个问题。
- en: 'Create a class called `SafeTask` and specify that it implements the `Runnable`
    interface:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SafeTask`的类，并指定它实现`Runnable`接口：
- en: '[PRE57]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Declare an object of the `ThreadLocal<Date>` class. This object will have an
    implicit implementation that would include the `initialValue()` method. This method
    will return the actual date:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`ThreadLocal<Date>`类的对象。此对象将具有隐式实现，包括`initialValue()`方法。此方法将返回实际日期：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Implement the `run()` method. It has the same functionality as the `run()`
    method of `UnsafeTask class`, but it changes the way it accesses the `startDate`
    attribute. Now we will use the `get()` method of the `startDate` object:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它具有与`UnsafeTask`类的`run()`方法相同的功能，但它更改了访问`startDate`属性的方式。现在我们将使用`startDate`对象的`get()`方法：
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `Main` class of this example is the same as the unsafe example. The only
    difference is that it changes the name of the `Runnable` class.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本例中的`Main`类与不安全的示例相同。唯一的区别是它更改了`Runnable`类的名称。
- en: Run the example and analyze the difference.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并分析差异。
- en: How it works...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following screenshot, you can see the results of the execution of the
    safe sample. The ten `Thread` objects have their own value of the `startDate`
    attribute:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，您可以看到安全样本执行的结果。十个`Thread`对象都有自己的`startDate`属性值：
- en: '![](img/00011.jpeg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00011.jpeg)'
- en: The thread-local variables mechanism stores a value of an attribute for each
    thread that uses one of these variables. You can read the value using the `get()`
    method and change the value using the `set()` method. The first time you access
    the value of a thread-local variable, if it has no value for the thread object
    that it is calling, the thread-local variable will call the `initialValue()` method
    to assign a value for that thread and return the initial value.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 线程局部变量机制为使用这些变量的每个线程存储一个属性的值。您可以使用`get()`方法读取值，并使用`set()`方法更改值。第一次访问线程局部变量的值时，如果它为调用的线程对象没有值，线程局部变量将调用`initialValue()`方法为该线程分配一个值并返回初始值。
- en: There's more...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The thread-local class also provides the `remove()` method that deletes the
    value stored in a thread-local variable for the thread that it's calling.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 线程局部类还提供了`remove()`方法，用于删除调用线程的线程局部变量中存储的值。
- en: The Java Concurrency API includes the `InheritableThreadLocal` class that provides
    inheritance of values for threads created from a thread. If thread `A` has a value
    in a thread-local variable and it creates another thread `B`, then thread `B`
    will have the same value as thread `A` in the thread-local variable. You can override
    the `childValue()` method that is called to initialize the value of the child
    thread in the thread-local variable. It receives the value of the parent thread
    as a parameter in the thread-local variable.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API包括`InheritableThreadLocal`类，它为从线程创建的线程提供值的继承。如果线程`A`在线程局部变量中有一个值，并且它创建了另一个线程`B`，那么线程`B`将具有与线程`A`相同的线程局部变量值。您可以通过覆盖在线程局部变量中初始化子线程值的`childValue()`方法来实现。它接收线程局部变量中的父线程值作为参数。
- en: Grouping threads and processing uncontrolled exceptions in a group of threads
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对线程进行分组和处理线程组中的未受控异常
- en: An interesting functionality offered by the concurrency API of Java is the ability
    to group threads. This allows us to treat the threads of a group as a single unit
    and provide access to the thread objects that belong to a group in order to do
    an operation with them. For example, you have some threads doing the same task
    and you want to control them. You can, for example, interrupt all the threads
    of the group with a single call.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Java 并发 API 提供的一个有趣的功能是能够对线程进行分组。这允许我们将一个组的线程视为单个单元，并提供访问属于该组的线程对象，以便对它们进行操作。例如，您有一些线程正在执行相同的任务，您想控制它们。例如，您可以通过单个调用中断该组中所有线程。
- en: Java provides the `ThreadGroup` class to work with a groups of threads. A `ThreadGroup`
    object can be formed by thread objects and another `ThreadGroup` object, generating
    a tree structure of threads.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了 `ThreadGroup` 类来处理线程组。可以通过线程对象和另一个 `ThreadGroup` 对象形成 `ThreadGroup`
    对象，生成线程的树状结构。
- en: In the *Controlling the interruption of a thread* recipe, you learned how to
    use a generic method to process all the uncaught exceptions that are thrown in
    a thread object. In the *Processing uncontrolled exceptions in a thread* recipe,
    we wrote a handler to process the uncaught exceptions thrown by a thread. We can
    use a similar mechanism to process the uncaught exceptions thrown by a thread
    or a group of threads.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *控制线程中断* 的示例中，您学习了如何使用通用方法处理在线程对象中抛出的所有未捕获异常。在 *处理线程中的未受控异常* 的示例中，我们编写了一个处理程序来处理线程抛出的未捕获异常。我们可以使用类似的机制来处理线程或线程组抛出的未捕获异常。
- en: In this recipe, we will learn to work with `ThreadGroup` objects and how to
    implement and set the handler that would process uncaught exceptions in a group
    of threads. We'll do this using an example.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将学习如何与 `ThreadGroup` 对象一起工作，以及如何在多个线程的组中实现和设置处理未捕获异常的处理程序。我们将通过一个示例来完成这项工作。
- en: Getting ready
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example for this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的示例是通过 Eclipse IDE 实现的。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'First, extend the `ThreadGroup` class by creating a class called `MyThreadGroup`
    that would be extended from `ThreadGroup`. You have to declare a constructor with
    one parameter because the `ThreadGroup` class doesn''t have a constructor without
    it. Extend the `ThreadGroup` class to override the `uncaughtException()` method
    in order to process the exceptions thrown by the threads of the group:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过创建一个名为 `MyThreadGroup` 的类来扩展 `ThreadGroup` 类，该类将扩展 `ThreadGroup`。您必须声明一个带有参数的构造函数，因为
    `ThreadGroup` 类没有不带参数的构造函数。扩展 `ThreadGroup` 类以重写 `uncaughtException()` 方法，以便处理组中线程抛出的异常：
- en: '[PRE60]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Override the `uncaughtException()` method. This method is called when an exception
    is thrown in one of the threads of the `ThreadGroup` class. In this case, the
    method will write information about the exception and the thread that throws it;
    it will present this information in the console. Also, note that this method will
    interrupt the rest of the threads in the `ThreadGroup` class:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `uncaughtException()` 方法。当 `ThreadGroup` 类中的一个线程抛出异常时，将调用此方法。在这种情况下，该方法将写入有关异常及其抛出线程的信息；它将在控制台中呈现这些信息。此外，请注意，此方法将中断
    `ThreadGroup` 类中其余线程：
- en: '[PRE61]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a class called `Task` and specify that it implements the `Runnable`
    interface:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE62]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Implement the `run()` method. In this case, we will provoke an `AritmethicException`
    exception. For this, we will divide 1,000 with random numbers until the random
    generator generates zero to throw the exception:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。在这种情况下，我们将引发 `AritmethicException` 异常。为此，我们将用随机数除以 1,000，直到随机生成器生成零以抛出异常：
- en: '[PRE63]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, implement the main class of the example by creating a class called `Main`
    and implement the `main()` method:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过创建一个名为 `Main` 的类并实现 `main()` 方法来实现示例的主类：
- en: '[PRE64]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'First, calculate the number of threads you are going to launch. We use the
    `availableProcessors()` method of the `Runtime` class (we obtain the runtime object
    associated with the current Java application with the static method, called `getRuntime()`,
    of that class). This method returns the number of processors available to the
    JVM, which is normally equal to the number of cores of the computer that run the
    application:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，计算你将要启动的线程数量。我们使用`Runtime`类的`availableProcessors()`方法（我们通过该类的静态方法`getRuntime()`获取与当前Java应用程序关联的运行时对象）。此方法返回JVM可用的处理器数量，通常等于运行应用程序的计算机的核心数：
- en: '[PRE65]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create an object of the `MyThreadGroup` class:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`MyThreadGroup`类的对象：
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create an object of the `Task` class:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Task`类的对象：
- en: '[PRE67]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create the calculated number of `Thread` objects with this `Task` class and
    start them:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此`Task`类创建计算出的线程数量，并启动它们：
- en: '[PRE68]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, write information about `ThreadGroup` in the console:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在控制台中写入有关`ThreadGroup`的信息：
- en: '[PRE69]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, write the status of the threads that form the group:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，写出组成该组的线程的状态：
- en: '[PRE70]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Run the example and see the results.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following screenshot, you can see the output of the `list()` method
    of the `ThreadGroup` class and the output generated when we write the status of
    each `Thread` object:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，你可以看到`ThreadGroup`类的`list()`方法输出以及我们写入每个`Thread`对象状态时生成的输出：
- en: '![](img/00012.jpeg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.jpeg)'
- en: The `ThreadGroup` class stores thread objects and other `ThreadGroup` objects
    associated with it so it can access all of their information (status, for example)
    and perform operations over all its members (interrupt, for example).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadGroup`类存储与它关联的线程对象和其他`ThreadGroup`对象，以便它可以访问它们的所有信息（例如状态）并对其所有成员执行操作（例如中断）。'
- en: 'Check out how one of the thread objects threw the exception that interrupted
    the other objects:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 查看其中一个线程对象如何抛出中断其他对象的异常：
- en: '![](img/00013.jpeg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: When an uncaught exception is thrown in a `Thread` object, the JVM looks for
    three possible handlers for this exception.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Thread`对象中抛出未捕获的异常时，JVM会寻找三个可能的异常处理器：
- en: First, it looks for the uncaught exception handler of the thread, as explained
    in the *Processing uncontrolled exceptions in a thread* recipe. If this handler
    doesn't exist, then the JVM looks for the uncaught exception handler of the `ThreadGroup`
    class of the thread, as learned in this recipe. If this method doesn't exist,
    the JVM looks for the default uncaught exception handler, as explained in the
    *Processing uncontrolled exceptions in a thread* recipe.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它寻找线程的未捕获异常处理器，如*在线程中处理未受控异常*配方中所述。如果此处理器不存在，那么JVM将寻找线程的`ThreadGroup`类的未捕获异常处理器，如本配方中所学。如果此方法不存在，JVM将寻找默认的未捕获异常处理器，如*在线程中处理未受控异常*配方中所述。
- en: If none of the handlers exists, the JVM writes the stack trace of the exception
    in the console and ends the execution of the thread that had thrown the exception.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有处理器存在，JVM将在控制台写入异常的堆栈跟踪，并结束抛出异常的线程的执行。
- en: See also
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The *Processing uncontrolled exceptions in a thread* recipe
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在线程中处理未受控异常*的配方'
- en: Creating threads through a factory
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过工厂创建线程
- en: 'The factory pattern is one of the most used design patterns in the object-oriented
    programming world. It is a creational pattern, and its objective is to develop
    an object whose mission should be this: creating other objects of one or several
    classes. With this, if you want to create an object of one of these classes, you
    could just use the factory instead of using a new operator.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是面向对象编程世界中用得最多的设计模式之一。它是一个创建型模式，其目标是开发一个对象，其使命应该是创建一个或多个类中的对象。有了这个，如果你想创建这些类中的一个对象，你就可以使用工厂而不是使用new运算符。
- en: 'With this factory, we centralize the creation of objects with some advantages:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个工厂，我们可以集中创建对象，并带来一些优势：
- en: It's easy to change the class of the objects created or the way you'd create
    them.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变创建的对象的类或创建方式很容易。
- en: It's easy to limit the creation of objects for limited resources; for example,
    we can only have *n* objects of a given type.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于有限的资源，限制对象的创建很容易；例如，我们只能有给定类型的*n*个对象。
- en: It's easy to generate statistical data about the creation of objects.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成关于对象创建的统计数据很容易。
- en: Java provides an interface, the `ThreadFactory` interface, to implement a thread
    object factory. Some advanced utilities of the Java concurrency API use thread
    factories to create threads.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了一个接口，即 `ThreadFactory` 接口，用于实现线程对象工厂。Java 并发 API 的一些高级实用工具使用线程工厂来创建线程。
- en: In this recipe, you will learn how to implement a `ThreadFactory` interface
    to create thread objects with a personalized name while saving the statistics
    of the thread objects created.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何实现一个 `ThreadFactory` 接口，以创建具有个性化名称的线程对象，同时保存创建的线程对象的统计信息。
- en: Getting ready
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example for this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例是使用 Eclipse IDE 实现的。如果你使用 Eclipse 或其他 IDE，如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class called `MyThreadFactory` and specify that it implements the
    `ThreadFactory` interface:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyThreadFactory` 的类，并指定它实现 `ThreadFactory` 接口：
- en: '[PRE71]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Declare three attributes: an integer number called counter, which we will use
    to store the number of thread objects created, a string called name with the base
    name of every thread created, and a list of string objects called stats to save
    statistical data about the thread objects created. Also, implement the constructor
    of the class that initializes these attributes:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明三个属性：一个名为 counter 的整数，我们将用它来存储创建的线程对象数量；一个名为 name 的字符串，包含每个创建的线程的基本名称；以及一个名为
    stats 的字符串对象列表，用于保存关于创建的线程对象的统计数据。同时，实现类的构造函数，初始化这些属性：
- en: '[PRE72]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Implement the `newThread()` method. This method will receive a `Runnable` interface
    and return a thread object for this `Runnable` interface. In our case, we generate
    the name of the thread object, create the new thread object, and save the statistics:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `newThread()` 方法。这个方法将接收一个 `Runnable` 接口，并返回一个对应于这个 `Runnable` 接口的线程对象。在我们的例子中，我们生成线程对象的名称，创建新的线程对象，并保存统计信息：
- en: '[PRE73]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Implement the `getStatistics()` method; it returns a `String` object with the
    statistical data of all the thread objects created:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `getStatistics()` 方法；它返回一个包含所有创建的线程对象统计数据的 `String` 对象：
- en: '[PRE74]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Create a class called `Task` and specify that it implements the `Runnable`
    interface. In this example, these tasks are going to do nothing apart from sleeping
    for 1 second:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，并指定它实现 `Runnable` 接口。在这个例子中，这些任务除了休眠 1 秒外，将不会做任何事情：
- en: '[PRE75]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create the main class of the example. Create a class called `Main` and implement
    the `main()` method:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建示例的主类。创建一个名为 `Main` 的类，并实现 `main()` 方法：
- en: '[PRE76]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Create a `MyThreadFactory` object and a `Task` object:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `MyThreadFactory` 对象和一个 `Task` 对象：
- en: '[PRE77]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Create 10 `Thread` objects using the `MyThreadFactory` object and start them:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `MyThreadFactory` 对象创建 10 个 `Thread` 对象，并启动它们：
- en: '[PRE78]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Write the statistics of the thread factory in the console:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将线程工厂的统计信息写入控制台：
- en: '[PRE79]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Run the example and see the results.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `ThreadFactory` interface has only one method, called `newThread()`. It
    receives a `Runnable` object as a parameter and returns a `Thread` object. When
    you implement a `ThreadFactory` interface, you have to implement it and override
    the `newThread` method. The most basic `ThreadFactory` has only one line:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadFactory` 接口只有一个方法，称为 `newThread()`。它接收一个 `Runnable` 对象作为参数，并返回一个 `Thread`
    对象。当你实现 `ThreadFactory` 接口时，你必须实现它并重写 `newThread` 方法。最基本的 `ThreadFactory` 只有一行：'
- en: '[PRE80]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You can improve this implementation by adding some variants, as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加一些变体来改进这个实现，如下所示：
- en: Creating personalized threads, as in the example, using a special format for
    the name or even creating your own `Thread` class that would inherit the Java
    `Thread` class
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建个性化的线程，如示例中所示，使用特殊的名称格式，甚至创建自己的 `Thread` 类，该类将继承 Java 的 `Thread` 类
- en: Saving thread creation statistics, as shown in the previous example
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存线程创建统计信息，如前一个示例所示
- en: Limiting the number of threads created
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制创建的线程数量
- en: Validating the creation of the threads
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证线程的创建
- en: You can add anything else you can imagine to the preceding list. The use of
    the factory design pattern is a good programming practice, but if you implement
    a `ThreadFactory` interface to centralize the creation of threads, you will have
    to review the code to guarantee that all the threads are created using the same
    factory.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何你能想到的其他内容添加到前面的列表中。使用工厂设计模式是一种良好的编程实践，但如果你要实现一个`ThreadFactory`接口来集中创建线程，你将不得不审查代码以确保所有线程都是使用相同的工厂创建的。
- en: See also
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing the ThreadFactory interface to generate custom threads* and
    *Using our ThreadFactory in an Executor object* recipes in [Chapter 8](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736),
    *Customizing Concurrency Classes*
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[第8章](part0365.html#AS2TA0-69b77957c9a14e36a0bec5f5a1363736)中的*实现ThreadFactory接口以生成自定义线程*和*在Executor对象中使用我们的ThreadFactory*配方，*自定义并发类*
