- en: Database Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库编程
- en: 'This chapter covers both basic and commonly used interactions between a Java
    application and a **database** (**DB**), right from connecting to the DB and performing
    CRUD operations to creating transactions, storing procedures, and working with
    **large objects** (**LOBs**). We will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 Java 应用程序和数据库（**DB**）之间基本和常用的交互，从连接到数据库和执行 CRUD 操作，到创建事务、存储过程和与 **大型对象**
    （**LOBs**） 一起工作。我们将涵盖以下食谱：
- en: Connecting to a database using JDBC
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JDBC 连接到数据库
- en: Setting up the tables required for DB interactions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用于数据库交互所需的表格
- en: Performing CRUD operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 CRUD 操作
- en: Using prepared statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预处理语句
- en: Using transactions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事务
- en: Working with large objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大型对象
- en: Executing stored procedures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行存储过程
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: It is difficult to imagine a complex software application that does not use
    some kind of data storage. A structured and accessible data storage is called
    a database. This is why any modern language implementation includes a framework
    that allows you to access the DB and **create, read, update, and delete** (**CRUD**)
    data in it. In Java, it is the **Java Database Connectivity** (**JDBC**) API that
    provides access to *virtually any data source, from relational databases to spreadsheets
    and flat files*, according to the Javadoc.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象一个复杂的软件应用程序不会使用某种类型的数据存储。一种结构化和可访问的数据存储称为数据库。这就是为什么任何现代语言实现都包括一个框架，允许你访问数据库并在其中
    **创建、读取、更新和删除** （**CRUD**） 数据。在 Java 中，提供这种访问的是 **Java 数据库连接** （**JDBC**） API，它根据
    Javadoc 的描述，可以访问 *几乎所有数据源，从关系数据库到电子表格和平面文件*。
- en: The `java.sql` and `javax.sql` packages that compose the JDBC API are included in
    the **Java Platform Standard Edition** (**Java SE**). The `java.sql` package provides
    *the API for accessing and processing data stored in a data source (usually a
    relational database).* The `javax.sql` package provides the API for server-side
    data source access and processing. Specifically, it provides the `DataSource` interface
    for establishing a connection with a database, connection and statement pooling,
    distributed transactions, and rowsets. We will discuss each of these features
    in greater detail in the recipes of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 组成 JDBC API 的 `java.sql` 和 `javax.sql` 包包含在 **Java 平台标准版** （**Java SE**） 中。`java.sql`
    包提供了 *访问和处理存储在数据源中（通常是关系数据库）的数据的 API。* `javax.sql` 包提供了服务器端数据源访问和处理的 API。具体来说，它提供了
    `DataSource` 接口以建立与数据库的连接、连接和语句池、分布式事务和行集。我们将在本章的食谱中更详细地讨论这些功能。
- en: However, to actually connect `DataSource` to a physical database, one also needs a
    database-specific driver (provided by a database vendor, such as MySQL, Oracle, PostgreSQL,
    or SQL server database, to name a few). These might be written in Java or in a
    mixture of Java and **Java Native Interface** (**JNI**) native methods. This driver
    implements the JDBC API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要实际将 `DataSource` 连接到物理数据库，还需要一个数据库特定的驱动程序（由数据库供应商提供，例如 MySQL、Oracle、PostgreSQL
    或 SQL 服务器数据库等）。这些驱动程序可能用 Java 编写，也可能是 Java 和 **Java Native Interface** (**JNI**)
    本地方法的混合。此驱动程序实现了 JDBC API。
- en: 'Working with a database involves eight steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库一起工作涉及八个步骤：
- en: Installing the database by following the vendor instructions.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照供应商的说明安装数据库。
- en: Adding the dependency on a `.jar` to the application with the database-specific
    driver.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据库特定驱动程序的 `.jar` 依赖添加到应用程序中。
- en: 'Creating a user, database, and database schema: tables, views, stored procedures,
    and so on.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户、数据库和数据库模式：表、视图、存储过程等。
- en: Connecting to the database from the application.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用程序连接到数据库。
- en: Constructing an SQL statement.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个 SQL 语句。
- en: Executing the SQL statement.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 SQL 语句。
- en: Using the result of the execution.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用执行结果。
- en: Closing the database connection and other resources.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭数据库连接和其他资源。
- en: Steps 1-3 are done only once at the database setup stage before the application
    is run.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 1-3 在应用程序运行之前，在数据库设置阶段只执行一次。
- en: Steps 4-8 are performed by the application repeatedly as needed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 4-8 根据需要由应用程序重复执行。
- en: Steps 5-7 can be repeated multiple times with the same database connection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 5-7 可以使用相同的数据库连接重复多次。
- en: Connecting to a database using JDBC
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JDBC 连接到数据库
- en: In this recipe, you will learn how to connect to a database.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何连接到数据库。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Select the database you would like to work with. There are good commercial databases
    and good open source databases. The only thing we are going to assume is that
    the database of your choice supports **Structured Query Language** (**SQL**),
    which is a standardized language that allows you to perform CRUD operations on
    a database. In our recipes, we will use the standard SQL and avoid constructs
    and procedures specific to a particular database type.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要工作的数据库。有好的商业数据库和好的开源数据库。我们唯一要假设的是你选择的数据库支持 **结构化查询语言**（**SQL**），这是一种标准化的语言，允许你在数据库上执行
    CRUD 操作。在我们的食谱中，我们将使用标准 SQL 并避免特定于特定数据库类型的构造和过程。
- en: If the database is not installed yet, follow the vendor instructions and install
    it. Then, download the database driver. The most popular ones are types 4 and
    5, written in Java. They are very efficient and talk to the database server through
    a socket connection. If a `.jar` file with such a driver is placed on the classpath,
    it is loaded automatically. Type 4 and 5 drivers are database specific because
    they use database native protocol for accessing the database. We are going to
    assume that you are using a driver of such a type.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数据库尚未安装，请按照供应商的说明进行安装。然后，下载数据库驱动程序。最流行的是类型 4 和 5，用 Java 编写。它们非常高效，并通过套接字连接与数据库服务器通信。如果包含此类驱动程序的
    `.jar` 文件放置在类路径上，它将自动加载。类型 4 和 5 驱动程序是数据库特定的，因为它们使用数据库本机协议来访问数据库。我们将假设你正在使用此类类型的驱动程序。
- en: If your application has to access several types of databases, then you need
    a driver of type 3\. Such a driver can talk to different databases via a middleware
    application server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序需要访问多种类型的数据库，那么你需要一个类型 3 的驱动程序。这样的驱动程序可以通过一个中间件应用程序服务器与不同的数据库进行通信。
- en: Drivers of type 1 and 2 are used only when there are no other driver types available
    for your database.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 1 和 2 的驱动程序仅在没有其他数据库驱动程序类型可用时使用。
- en: Set the downloaded `.jar` file with the driver on your application's classpath. Now
    you can create a database and access it from your application.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的 `.jar` 文件（包含驱动程序）添加到你的应用程序的类路径中。现在你可以创建一个数据库，并通过你的应用程序访问它。
- en: Your database might have a console, a GUI, or some other way to interact with
    it. Read the instructions and create first a user, that is, `cook`, and then a
    database, namely `cookbook`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的数据库可能有一个控制台、一个图形用户界面（GUI）或某种其他与它交互的方式。阅读说明，首先创建一个用户，即 `cook`，然后创建一个数据库，即 `cookbook`。
- en: 'For example, here are the commands that do this for PostgreSQL:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是为 PostgreSQL 执行此操作的命令：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We selected the `SUPERUSER` role for our user; however, a good security practice
    is to assign such a powerful role to an administrator and create another application-specific
    user who can manage data but cannot change the database structure. It is good
    practice to create another logical layer, called schema, that can have its own
    set of users and permissions. This way, several schemas in the same database could
    be isolated, and each user (one of them is your application) will only have access
    to certain schemas.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的用户选择了 `SUPERUSER` 角色；然而，一个良好的安全实践是将如此强大的角色分配给管理员，并创建另一个特定于应用程序的用户，该用户可以管理数据但不能更改数据库结构。创建另一个名为模式（schema）的逻辑层是一个好习惯，它可以有自己的用户和权限集合。这样，同一个数据库中的多个模式可以隔离，每个用户（其中之一是你的应用程序）将只能访问特定的模式。
- en: Also, at the enterprise level, the common practice is to create synonyms for
    the database schema so that no application can access the original structure directly.
    You can also create a password for each user, but, again, for the purpose of this
    book, this is not needed. So we leave it to the database administrators to establish
    the rules and guidelines suitable to the particular working conditions of each
    enterprise.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在企业级应用中，常见的做法是为数据库模式创建同义词，这样没有任何应用程序可以直接访问原始结构。你也可以为每个用户创建密码，但，再次强调，对于本书的目的，这并不是必需的。因此，我们将这项工作留给数据库管理员，由他们根据每个企业的特定工作条件建立规则和指南。
- en: Now we connect our application to the database. In our demonstration, we will
    use, as you may have probably guessed by now, the open source (free) PostgreSQL
    database.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将我们的应用程序连接到数据库。在我们的演示中，我们将使用，正如你可能已经猜到的，开源（免费）的 PostgreSQL 数据库。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here is the code fragment that creates connection to our local PostgreSQL database:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建到我们本地 PostgreSQL 数据库连接的代码片段：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The commented lines show how you can set a user and password for your connection.
    Since, for this demo, we keep the database open and accessible to anyone, we could
    use an overloaded `DriverManager.getConnection(String url)` method. However, we
    will show the most general implementation that would allow anyone to read from
    a property file and pass other useful values (`ssl` as true/false, `autoReconnect`
    as true/false, `connectTimeout` in seconds, and so on) to the connection-creating
    method. Many keys for the passed-in properties are the same for all major database
    types, but some of them are database-specific.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注释行显示了如何为您的连接设置用户名和密码。由于在这个演示中，我们保持数据库开放并允许任何人访问，我们可以使用重载的 `DriverManager.getConnection(String
    url)` 方法。然而，我们将展示最通用的实现，这将允许任何人从属性文件中读取，并将其他有用的值（如 `ssl` 为真/假，`autoReconnect`
    为真/假，`connectTimeout` 以秒为单位等）传递给创建连接的方法。传递的属性键对于所有主要数据库类型都是相同的，但其中一些是数据库特定的。
- en: Alternatively, for passing only a user and password, we could use the third
    overloaded version, namely `DriverManager.getConnection(String url, String user,
    String password)`. It's worth mentioning that it is good practice to keep the
    password encrypted. We are not going to show how to do this, but there are plenty
    of guides available online.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，如果我们只想传递用户名和密码，我们可以使用第三个重载版本，即 `DriverManager.getConnection(String url,
    String user, String password)`。值得一提的是，保持密码加密是一个好的实践。我们不会展示如何做这件事，但网上有很多指南。
- en: Also, the `getConnection()` method throws `SQLException`, so we need to wrap
    it in a `try...catch` block.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`getConnection()` 方法会抛出 `SQLException`，因此我们需要将其包裹在 `try...catch` 块中。
- en: 'To hide all of this and other plumbing, it is a good idea to keep the connection-establishing
    code inside a method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隐藏所有这些和其他管道，将连接建立代码放在一个方法中是一个好主意：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another way of connecting to a database is to use the `DataSource` interface.
    Its implementation is typically included in the same `.jar` file as the database
    driver. In the case of PostgreSQL, there are two classes that implement the `DataSource` interface:
    `org.postgresql.ds.PGSimpleDataSource` and `org.postgresql.ds.PGPoolingDataSource`.
    We can use them instead of `DriverManager`. Here is an example of the usage of
    `PGSimpleDataSource`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库的另一种方式是使用 `DataSource` 接口。其实现通常包含在包含数据库驱动的同一 `.jar` 文件中。在 PostgreSQL 的例子中，有两个类实现了
    `DataSource` 接口：`org.postgresql.ds.PGSimpleDataSource` 和 `org.postgresql.ds.PGPoolingDataSource`。我们可以使用它们来代替
    `DriverManager`。以下是 `PGSimpleDataSource` 的使用示例：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And the following is an example of the usage of `PGPoolingDataSource`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 `PGPoolingDataSource` 的使用示例：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last version of the `getDbConnection()` method is usually the preferred
    way of connecting because it allows you to use connection pooling and some other
    features, in addition to those available when connecting via `DriverManager`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDbConnection()` 方法的最后一个版本通常是首选的连接方式，因为它允许你使用连接池和一些其他功能，而不仅仅是通过 `DriverManager`
    连接时可用的一些功能。'
- en: Whatever version of the `getDbConnection()` implementation you choose, you'll
    need to use it in all the code examples the same way.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种版本的 `getDbConnection()` 实现，你都需要以相同的方式在所有代码示例中使用它。
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is good practice to think about closing the connection as soon as you create
    it. The way to do this is using the `try-with-resources` construct, which ensures
    that the resource is closed at the end of the `try...catch` block:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的实践是在创建连接后立即考虑关闭它。这样做的方法是使用 `try-with-resources` 构造，它确保在 `try...catch` 块结束时关闭资源：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Such a construct can be used with any object that implements the `java.lang.AutoCloseable`
    or `java.io.Closeable` interface.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构可以与实现 `java.lang.AutoCloseable` 或 `java.io.Closeable` 接口的任何对象一起使用。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipe in this chapter:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下配方：
- en: Setting up the tables required for DB interactions
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用于数据库交互所需的表
- en: Setting up the tables required for DB interactions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用于数据库交互所需的表
- en: In this recipe, you will learn how to create, change, and delete tables and
    other logical database constructs that compose a database schema.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将学习如何创建、更改和删除表以及其他构成数据库模式的逻辑数据库结构。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The standard SQL statement for table creation looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 SQL 表创建语句看起来是这样的：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `table_name` and `column_name` have to be alphanumeric and unique (inside
    the schema) identifiers. The limitations for the names and possible data types
    are database-specific. For example, Oracle allows the table name to have 128 characters,
    while in PostgreSQL, the max length of the table name and column name is 63 characters.
    There are differences in the data types too, so read the database documentation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`table_name` 和 `column_name` 必须是字母数字且唯一的（在模式内）标识符。名称和数据类型的限制是数据库特定的。例如，Oracle
    允许表名有 128 个字符，而在 PostgreSQL 中，表名和列名的最大长度是 63 个字符。数据类型也有差异，所以请阅读数据库文档。
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here is an example of a command that creates the `traffic_unit` table in PostgreSQL:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在 PostgreSQL 中创建 `traffic_unit` 表的命令示例：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we did not set the size of the columns of the type `VARCHAR`, thus allowing
    those columns to store values of any length. The `integer` type, in this case,
    allows you to store numbers from -2147483648 to +2147483647\. The `NOT NULL` type
    was added because, by default, the column would be nullable and we wanted to make
    sure that all the columns would be populated for each record.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有设置 `VARCHAR` 类型列的大小，因此允许这些列存储任何长度的值。在这种情况下，`integer` 类型允许你存储从 -2147483648
    到 +2147483647 的数字。添加了 `NOT NULL` 类型，因为默认情况下，列将是可空的，我们想确保每个记录都会填充所有列。
- en: 'We also identified the `id` column as `PRIMARY KEY`, which indicates that the
    column (or the combination of columns) uniquely identifies the record. For example,
    if there is a table that contains information about all the people of all the
    countries, the unique combination would *probably* be their full name, address,
    and date of birth. Well, it is plausible to imagine that in some household, twins
    are born and given the same name, so we said probably. If the chance of such an
    occasion is high, we would need to add another column to the primary key combination,
    which is the order of birth, with the default value of 1\. Here is how we can
    do this in PostgreSQL:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还确定了 `id` 列作为 `PRIMARY KEY`，这表示该列（或列的组合）唯一地标识了记录。例如，如果有一个包含所有国家所有人的信息的表，唯一的组合可能就是他们的全名、地址和出生日期。嗯，可以想象在某些家庭中，双胞胎可能出生并拥有相同的名字，所以我们说是“可能”。如果这种情况发生的可能性很高，我们就需要向主键组合中添加另一个列，即出生顺序，默认值为
    1。下面是如何在 PostgreSQL 中实现这一点的示例：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the case of the `traffic_unit` table, there is no combination of columns
    that can serve as a primary key. Many cars have the same values. But we need to
    refer to a `traffic_unit` record so we could know which units have been selected
    and processed and which were not, for example. This is why, we added an `id` column
    to populate it with a unique generated number, and we would like the database to
    generate this primary key automatically.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `traffic_unit` 表的情况下，没有列的组合可以作为主键。许多汽车具有相同的值。但我们需要引用一个 `traffic_unit` 记录，以便知道哪些单位已被选择和处理，哪些没有被处理，例如。这就是为什么我们添加了一个
    `id` 列，并用一个唯一的生成数字填充它，我们希望数据库自动生成这个主键。
- en: 'If you look at the generated table description (`\d traffic_unit`), you will
    see the `nextval(''traffic_unit_id_seq''::regclass)` function assigned to the
    `id` column. This function generates numbers sequentially, starting with 1\. If
    you need some different behavior, create the sequence number generator manually.
    Here''s an example of how to do this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看生成的表描述（`\d traffic_unit`），你会看到分配给 `id` 列的 `nextval('traffic_unit_id_seq'::regclass)`
    函数。这个函数按顺序生成数字，从 1 开始。如果你需要不同的行为，可以手动创建序列号生成器。下面是如何做到这一点的示例：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This sequence starts from 1,000 and caches 10 numbers for better performance
    in case there is a need to generate numbers in quick succession.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列从 1,000 开始，缓存 10 个数字，以便在需要快速连续生成数字时提高性能。
- en: 'According to the code examples shared in the previous chapters, the values
    of `vehicle_type`, `road_condition`, and `tire_condition` are limited by the `enum`
    type in the code. That''s why when the `traffic_unit` table is populated, we would
    like to make sure that only the values present in the code in `enum` types are
    set in the columns. To accomplish this, we''ll create a lookup table called `enums`
    and populate it with the values from our `enum` types:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前几章中共享的代码示例，`vehicle_type`、`road_condition` 和 `tire_condition` 的值受代码中 `enum`
    类型的限制。这就是为什么当填充 `traffic_unit` 表时，我们希望确保只有代码中 `enum` 类型中存在的值被设置在列中。为了完成这个任务，我们将创建一个名为
    `enums` 的查找表，并用我们的 `enum` 类型的值填充它：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: PostgreSQL has an `enum` data type, but it incurs an overhead if the list of
    possible values is not fixed and has to be changed over time. We think it is quite
    possible that the list of values in our application will expand. So, we decided
    not to use a database `enum` type but create the lookup table ourselves.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 有一个 `enum` 数据类型，但如果可能值列表不是固定的并且需要随时间更改，则会造成开销。我们认为我们应用程序中的值列表很可能扩展。因此，我们决定不使用数据库
    `enum` 类型，而是自己创建查找表。
- en: 'Now we can refer to the values of the `enums` table from the `traffic_unit`
    table using their ID as a foreign key. First, we delete the table:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用它们的 ID 作为外键从 `traffic_unit` 表中引用 `enums` 表的值。首先，我们删除该表：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we recreate it with a slightly different SQL command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用稍微不同的 SQL 命令来重新创建它：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The columns `vehicle_type`, `road_condition`, and `tire_condition` must now
    be populated by the primary key of the corresponding record of the `enums` table.
    This way, we can make sure that our traffic-analyzing code will be able to match
    the values in these columns to the values of the `enum` types in the code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在必须使用 `enums` 表中相应记录的主键来填充 `vehicle_type`、`road_condition` 和 `tire_condition`
    列。这样，我们可以确保我们的交通分析代码能够将这些列中的值与代码中 `enum` 类型的值相匹配。
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `enums` table should not have a duplicate combination of type-value because
    this might lead to confusion, especially when the code that populates the `traffic_unit`
    table looks up the necessary `id` in the `enums` table. Instead of the one value
    that is expected, the query will return two. Which one to pick, then? To avoid
    duplication, we can add a unique constraint to the `enums` table:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`enums` 表不应有重复的类型-值组合，因为这可能会导致混淆，尤其是在填充 `traffic_unit` 表的代码在 `enums` 表中查找必要的
    `id` 时。查询将返回两个值，那么选择哪一个呢？为了避免重复，我们可以在 `enums` 表中添加一个唯一约束：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now if we try to add a duplicate, the database will not allow it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们尝试添加一个重复项，数据库将不允许这样做。
- en: 'Another important consideration of database table creation is whether an index
    has to be added. An index is a data structure that helps to accelerate data searches
    in the table without having to check every table record. It can include one or
    more columns of a table. For example, an index for a primary key is created automatically.
    If you bring up the description of the table we have created already, you will
    see the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表创建的另一个重要考虑因素是是否需要添加索引。索引是一种数据结构，它有助于加速表中的数据搜索，而无需检查每个表记录。它可以包括一个或多个表的列。例如，主键的索引是自动创建的。如果你查看我们已创建的表的描述，你会看到以下内容：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also add an index ourselves if we think (and have proven by experimentation)
    it will help the application performance. In the case of `traffic_unit`, we discovered
    that our code often searches this table by `vehicle_type` and `passengers_count`.
    So we measured the performance of our code during the search and added these two
    columns to the index:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们认为（并通过实验证明）它将有助于应用程序性能，我们也可以自己添加索引。在 `traffic_unit` 的例子中，我们发现我们的代码经常通过 `vehicle_type`
    和 `passengers_count` 搜索这个表。因此，我们在搜索期间测量了代码的性能，并将这两个列添加到索引中：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we measured the performance again. If it had improved, we would have left
    the index in place, but in our case, we removed it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次测量了性能。如果它有所改善，我们会保留索引，但在这个案例中，我们移除了它：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We did this because an index has an overhead of additional writes and storage
    space.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为索引有额外的写入和存储空间开销。
- en: In our examples of primary key, constraints, and indexes, we followed the naming
    convention of PostgreSQL. If you use a different database, we suggest you look
    up its naming convention and follow it, so that your naming aligns with the names
    created automatically.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主键、约束和索引的示例中，我们遵循了 PostgreSQL 的命名约定。如果你使用不同的数据库，我们建议你查找其命名约定并遵循它，以便你的命名与自动创建的名称相一致。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下食谱：
- en: Performing CRUD operations
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 CRUD 操作
- en: Working with large objects
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大型对象
- en: Performing CRUD operations
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 CRUD 操作
- en: In this recipe, you will learn how to populate, read, change, and delete data
    in the database.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何在数据库中填充、读取、更改和删除数据。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have already seen examples of SQL statements that create (populate) data
    in the database:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了创建（填充）数据库中数据的 SQL 语句的示例：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ve also seen examples of instances where several table records have to
    be added:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了需要添加多个表记录的实例的示例：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If a column has a default value specified, there is no need to list it in the
    `INSERT INTO` statement, unless a different value has to be inserted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一列指定了默认值，则不需要在`INSERT INTO`语句中列出它，除非要插入不同的值。
- en: 'The reading of the data is done by a `SELECT` statement:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的读取是通过`SELECT`语句完成的：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is also done when all the columns have to be selected in an order:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是在所有列都必须按顺序选择时所做的：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here''s a general definition of the `WHERE` clause:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`WHERE`子句的一般定义：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `column_name operator value` construct can be combined the with logical
    operators `AND` and `OR` and grouped with the brackets `(` and `)`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`column_name operator value`构造可以与逻辑运算符`AND`和`OR`结合，并用括号`(`和`)`分组。'
- en: 'The data can be changed with the `UPDATE` statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以通过`UPDATE`语句进行更改：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, it can be deleted with the `DELETE` statement:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以通过`DELETE`语句删除：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Without the `WHERE` clause, all the records of the table are going to be affected
    by the `UPDATE` or `DELETE` statement.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`WHERE`子句，`UPDATE`或`DELETE`语句将影响表中的所有记录。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We have already seen an `INSERT` statement. Here is an example of other types
    of statements:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个`INSERT`语句。这里是一个其他类型语句的例子：
- en: '![](img/1cb03683-da6c-4cf4-a5ae-16b25d85f6ab.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cb03683-da6c-4cf4-a5ae-16b25d85f6ab.png)'
- en: 'The preceding `SELECT` statement requires bringing up all the columns of all
    the rows of the table. If the number of rows was bigger than the number of lines
    on the screen, the database console would show only the first screen and you would
    need to type a command (database-specific) to show the next screen:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`SELECT`语句需要检索表中所有行的所有列。如果行数超过了屏幕上的行数，数据库控制台将只显示第一屏，你需要输入一个命令（特定于数据库）来显示下一屏：
- en: '![](img/a54b682d-5a42-47ee-96a2-a8c33cce32b0.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a54b682d-5a42-47ee-96a2-a8c33cce32b0.png)'
- en: 'This `SELECT` statement has a `WHERE` clause that requires you to show only
    those rows where the value in the `type` column is `vehicle` and the value in
    the `value` column is not `crewcab`. It also requires you to show the rows where
    the value in the `value` column is `new`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`SELECT`语句有一个`WHERE`子句，要求你只显示那些`type`列中的值为`vehicle`且`value`列中的值不为`crewcab`的行。它还要求你显示`value`列中的值为`new`的行：
- en: '![](img/7bd17df9-3af0-4055-a889-889a4533fcb2.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bd17df9-3af0-4055-a889-889a4533fcb2.png)'
- en: The preceding screenshot captures three statements. The first one is an `UPDATE`
    statement that requires you to change the value in the `value` column to `NEW`,
    but only in the rows where the value in the `value` column is `new` (apparently,
    the value is case-sensitive). The second statement requires you to delete all
    the rows that do not have the value `NEW` in the `value` column. The third statement
    is `SELECT`, which we just discussed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图捕获了三个语句。第一个是一个`UPDATE`语句，要求你将`value`列中的值更改为`NEW`，但只在没有`value`列中的值为`NEW`的行中更改（显然，值是区分大小写的）。第二个语句要求你删除所有`value`列中没有`NEW`值的行。第三个语句是`SELECT`，我们刚刚讨论过。
- en: It worth noting that we would not be able to delete the records of the `enums`
    table if these records were referred to as foreign keys in the `traffic_unit` table.
    Only after deleting the corresponding records of the `traffic_unit` table would
    we be able to do this. But, for now, that is, for demonstration purposes, we keep
    the `traffic_unit` table empty.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果我们不能删除`traffic_unit`表中的这些记录，因为它们作为外键被引用，我们就无法删除`enums`表中的记录。只有删除`traffic_unit`表中的相应记录后，我们才能这样做。但是，现在，也就是说，为了演示目的，我们保持`traffic_unit`表为空。
- en: 'To execute any of the CRUD operations in the code, one has to acquire a JDBC
    connection first, then create and execute a statement:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中执行任何CRUD操作，首先必须获取一个JDBC连接，然后创建并执行一个语句：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is good practice to use the `try-with-resources` construct for the `Statement`
    object too. The closing of the `Connection` object would close the `Statement`
    object automatically. However, when you close the `Statement` object explicitly,
    the cleanup happens immediately instead of waiting for the necessary checks and
    actions to propagate through the layers of the framework.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Statement`对象，使用`try-with-resources`构造也是良好的实践。`Connection`对象的关闭会自动关闭`Statement`对象。然而，当你显式关闭`Statement`对象时，清理会立即发生，而不是等待必要的检查和操作通过框架的各个层传播。
- en: The `execute()` method is the most generic one among the three methods that
    can execute a statement. The other two include `executeQuery()` (for `SELECT`
    statements only) and `executeUpdate()` (for `UPDATE`, `DELETE`, `CREATE`, or `ALTER`
    statements). As you can see in our example, the `execute()` method returns `boolean`,
    which indicates whether the result is a `ResultSet` object or just a count. This
    means that `execute()` acts as `executeQuery()` for the `SELECT` statement and
    `executeUpdate()` for the other statements that we just listed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute()` 方法是三种可以执行语句的方法中最通用的一个。其他两种包括 `executeQuery()`（仅用于 `SELECT` 语句）和
    `executeUpdate()`（用于 `UPDATE`、`DELETE`、`CREATE` 或 `ALTER` 语句）。正如您在我们的示例中所看到的，`execute()`
    方法返回 `boolean`，这表示结果是一个 `ResultSet` 对象还是只是一个计数。这意味着 `execute()` 对于 `SELECT` 语句充当
    `executeQuery()` 的角色，对于我们刚刚列出的其他语句充当 `executeUpdate()` 的角色。'
- en: 'We can demonstrate this by running the preceding code with the following sequence
    of statements:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下语句序列运行前面的代码来演示这一点：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result will be as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/896e111f-c133-4b13-8c4d-db39aa2d0ca5.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/896e111f-c133-4b13-8c4d-db39aa2d0ca5.png)'
- en: We carried out the positional extraction of the values from `ResultSet` because
    this is more efficient than using the column name (as in `rs.getInt("id")` or `rs.getInt("type")`).
    The difference in performance is very small, though, and becomes important only
    when the operation happens many times. Only the actual measuring and testing can
    tell you whether the difference in the case of your application is significant
    or not. Bear in mind that getting values by name provides better code readability,
    which pays well in the long term during application maintenance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `ResultSet` 中提取值的位置是因为这比使用列名（如 `rs.getInt("id")` 或 `rs.getInt("type")`）更高效。尽管性能差异很小，但只有在操作多次时才会变得重要。只有实际的测量和测试才能告诉你，在您应用程序的情况下，这种差异是否显著。请记住，通过名称获取值可以提供更好的代码可读性，这在长期的应用程序维护中是非常有益的。
- en: 'We used the `execute()` method for demonstration purposes. In practice, the `executeQuery()` method is
    used for `SELECT` statements because the programmer usually has to extract the
    data in a way specific to the executed SQL statement. By contrast, the call to
    `executeUpdate()` can be wrapped in a generic method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了演示目的使用了 `execute()` 方法。在实践中，`executeQuery()` 方法用于 `SELECT` 语句，因为程序员通常必须以针对执行
    SQL 语句特定的方式进行数据提取。相比之下，`executeUpdate()` 的调用可以封装在一个通用方法中：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'SQL is a rich language, and we do not have enough space to cover all its features.
    We would just like to enumerate a few of its most popular ones so you are aware
    of their existence and could look them up when needed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 是一种丰富的语言，我们没有足够的空间来涵盖其所有功能。我们只想列举其中一些最流行的功能，让您了解它们的存在，并在需要时查找它们：
- en: The `SELECT` statement allows the use of the `DISTINCT` keyword to get rid off
    all the duplicate values
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT` 语句允许使用 `DISTINCT` 关键字来去除所有重复的值'
- en: Adding the `ORDER BY` keyword presents the result in the specified order
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `ORDER BY` 关键字将结果按指定顺序呈现
- en: The keyword `LIKE` allows you to set the search pattern to the `WHERE` clause
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字 `LIKE` 允许您将搜索模式设置为 `WHERE` 子句
- en: 'The search pattern can use several wildcard: `%, _`, `[charlist]`, `[^charlist]`,
    or `[!charlist]`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索模式可以使用多个通配符：`%，_`，`[字符列表]`，`[^字符列表]` 或 `[!字符列表]`
- en: Matching values can be enumerated with the `IN` keyword
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `IN` 关键字列举匹配的值
- en: The `SELECT` statement can include several tables using the `JOIN` clause
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT` 语句可以使用 `JOIN` 子句包含多个表'
- en: '`SELECT * INTO table_2 from table_1 creates table_2` and copies data from `table_1`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT * INTO table_2 from table_1` 创建 `table_2` 表并从 `table_1` 表复制数据'
- en: '`TRUNCATE` is faster and uses fewer resources when removing all the rows of
    a table'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当删除一个表的全部行时，`TRUNCATE` 更快且使用的资源更少
- en: 'There are many other useful methods in the `ResultSet` interface as well. Here
    is an example of how some of its methods can be used to write generic code that
    would traverse the returned result and use metadata to print out the column name
    and the returned value:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet` 接口还有许多其他有用的方法。以下是一些方法如何被用来编写通用的代码，该代码将遍历返回的结果并使用元数据来打印出列名和返回的值：'
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We used `ResultSetMetaData` only once to collect the returned column names
    and the length (number of columns) of one row. Then, we extracted the values from
    each row by position and created `List<String>` elements with the corresponding
    column names. To print, we used something we are already familiar with--a programmer''s
    delight--the joining collector (we discussed this in a previous chapter). If we
    call the `traverseRS("select * from enums")` method, the result will be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用了一次 `ResultSetMetaData` 来收集返回的列名和一行（列数）。然后，我们通过位置提取每行的值，并使用相应的列名创建了 `List<String>`
    元素。为了打印，我们使用了我们已熟悉的——程序员的乐趣——连接收集器（我们已在之前的章节中讨论过）。如果我们调用 `traverseRS("select *
    from enums")` 方法，结果将如下所示：
- en: '![](img/fe5810e8-6253-430d-afc4-1d8bb975532c.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe5810e8-6253-430d-afc4-1d8bb975532c.png)'
- en: See also
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下菜谱：
- en: Using prepared statements
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预编译语句
- en: Using transactions
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事务
- en: Working with large objects
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大型对象
- en: Executing stored procedures
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行存储过程
- en: Using prepared statements
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预编译语句
- en: 'In this recipe, you will learn how to use a prepared statement: a statement
    template that can be stored in the database and executed efficiently with different
    input values.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用预编译语句：这是一种可以存储在数据库中并使用不同输入值高效执行的语句模板。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: An object of `PreparedStatement`--a subinterface of `Statement`--can be precompiled
    and stored in the database and then used to efficiently execute the SQL statement
    multiple times for different input values. Similar to an object of `Statement` (created
    by the `createStatement()` method), it can be created by the `prepareStatement()`
    method of the same `Connection` object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreparedStatement` 对象——`Statement` 的子接口——可以预先编译并存储在数据库中，然后用于针对不同输入值多次高效执行
    SQL 语句。类似于通过 `createStatement()` 方法创建的 `Statement` 对象，它可以通过同一 `Connection` 对象的
    `prepareStatement()` 方法创建。'
- en: There is also a third version of a statement that creates a method called `prepareCall()` that,
    in turn, creates the `CallableStatement` object used to execute a database-stored
    procedure, but we will discuss this in a separate recipe later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种声明的第三种版本，它创建了一个名为 `prepareCall()` 的方法，该方法反过来创建用于执行数据库存储过程的 `CallableStatement`
    对象，但我们将在此后的单独菜谱中讨论这一点。
- en: 'The same SQL statement that was used to generate `Statement` can be used to
    generate `PreparedStatement` too. In fact, it is a good idea to consider using
    `PrepdaredStatement` for any SQL statement that is called multiple times because
    it performs better than `Statement`. To do this, all we need to change are these
    two lines in the sample code of the previous section:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成 `Statement` 的相同 SQL 语句也可以用于生成 `PreparedStatement`。实际上，考虑为任何多次调用的 SQL 语句使用
    `PreparedStatement` 是一个好主意，因为它比 `Statement` 性能更好。为此，我们只需要更改上一节示例代码中的这两行：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We change these lines to the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些行更改为以下内容：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The true usefulness of `PreparedStatement` shines because of its ability to
    accept parameters--the input values that substitute (in the order of appearance)
    the `?` symbol. Here''s an example of this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreparedStatement` 的真正实用性体现在其接受参数的能力——即替代（按出现顺序）`?` 符号的输入值。以下是一个示例：'
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result of this is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/4d00bc67-c4b4-4efb-95f6-f562df470f9d.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d00bc67-c4b4-4efb-95f6-f562df470f9d.png)'
- en: There's more...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is not a bad idea to always use prepared statements for CRUD operations.
    They might be slower if executed only once, but you can test and see whether this
    is the price you are willing to pay. What you get with prepared statements is
    consistent (better readable) code, more security (prepared statements are not
    vulnerable to SQL injection), and one fewer decision to make (just reuse the same
    code everywhere).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 CRUD 操作，始终使用预编译语句并不是一个坏主意。如果只执行一次，它们可能会慢一些，但你可以在测试中看到这是否是你愿意付出的代价。使用预编译语句，你将获得一致的（更易读的）代码，更高的安全性（预编译语句不受
    SQL 注入攻击的影响），以及更少的决策（只需在所有地方重用相同的代码）。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章以下菜谱：
- en: Using transactions
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事务
- en: Working with large objects
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大型对象
- en: Executing stored procedures
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行存储过程
- en: Using transactions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事务
- en: In this recipe, you will learn what a database transaction is and how it can
    be used in Java code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习数据库事务是什么以及如何在 Java 代码中使用它。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A transaction is a unit of work that includes one or many operations that change
    data. If successful, all the data changes are *committed* (applied to the database).
    If one of the operations errors out or the transaction is *rolled back*, then
    none of the changes included in the transaction will be applied to the database.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 事务是包括一个或多个更改数据的操作的工作单元。如果成功，所有数据更改都将 *提交*（应用到数据库）。如果其中一个操作出错或事务被 *回滚*，则事务中包含的所有更改都不会应用到数据库中。
- en: Transaction properties are set up on the `Connection` object. They can be changed
    without closing the connection, so different transactions can reuse the same `Connection`
    object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 事务属性是在 `Connection` 对象上设置的。它们可以在不关闭连接的情况下进行更改，因此不同的交易可以重用同一个 `Connection` 对象。
- en: JDBC allows transaction control only for CRUD operations. Table modification
    (`CREATE TABLE`, `ALTER TABLE`, and so on) is committed automatically and cannot
    be controlled from the Java code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC 只允许对 CRUD 操作进行事务控制。表修改（`CREATE TABLE`、`ALTER TABLE` 等）会自动提交，并且无法从 Java
    代码中进行控制。
- en: By default, a CRUD operation transaction is set to be autocommitted too. This
    means that every data change that was introduced by an SQL statement is applied
    to the database as soon as the execution of the SQL statement is completed. All
    the preceding examples use this default behavior.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CRUD 操作事务也被设置为自动提交。这意味着由 SQL 语句引入的每个数据更改都会在 SQL 语句执行完成后立即应用到数据库中。所有前面的示例都使用了这种默认行为。
- en: To change this, one has to use the `setAutoCommit()` method of the `Connection` object.
    If set to false, that is, `setAutoCommit(false)`, the data changes will not be
    applied to the database until the `commit()` method on the `Connection` object
    is invoked. If the `rollback()` method is called, all the data changes since the
    beginning of the transaction or since the last call to `commit()` would be discarded.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变这一点，必须使用 `Connection` 对象的 `setAutoCommit()` 方法。如果设置为 `false`，即 `setAutoCommit(false)`，则数据更改将不会在调用
    `Connection` 对象上的 `commit()` 方法之前应用到数据库中。如果调用 `rollback()` 方法，则自事务开始以来或自上次调用 `commit()`
    以来所做的所有数据更改将被丢弃。
- en: Explicit programmatic transaction management improves performance, but it is
    insignificant in the case of short atomic operations that are called once and
    not very often. Taking over transaction control becomes crucial when several operations
    introduce changes that have to be applied, either all together or none of them.
    It allows you to group database changes into atomic units and thus avoid accidental
    violation of data integrity.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 显式的程序性事务管理可以提高性能，但在调用一次且不常调用的短原子操作的情况下，这是微不足道的。当多个操作引入必须应用的变化时，接管事务控制变得至关重要。它允许您将数据库更改分组为原子单元，从而避免意外违反数据完整性。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, let''s add an output to the `traverseRS()` method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向 `traverseRS()` 方法添加一个输出：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will help you analyze the output when many different SQL statements are
    executed in the same demo example.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助您分析在同一个演示示例中执行多个不同的 SQL 语句时的输出。
- en: 'Now let''s run the following code that reads data from the `enums` table, then
    inserts a row, and then reads all the data from the table again:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行以下代码，该代码从 `enums` 表中读取数据，然后插入一行，然后再次从表中读取所有数据：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that we took over transaction control by calling `conn.setAutoCommit(false)`.
    The result is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过调用 `conn.setAutoCommit(false)` 来接管事务控制。结果如下：
- en: '![](img/4ba8a330-8187-4e84-abff-45aadcb2e6c0.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ba8a330-8187-4e84-abff-45aadcb2e6c0.png)'
- en: 'As you can see, the changes were not applied because the call to `commit()` was
    commented out. When we uncomment it, the result is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，更改没有被应用，因为对 `commit()` 的调用被注释掉了。当我们取消注释它时，结果如下：
- en: '![](img/a4c1bbe0-12aa-4ef8-a906-6330ea3d26cf.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4c1bbe0-12aa-4ef8-a906-6330ea3d26cf.png)'
- en: 'Now let''s execute two inserts, but introduce a spelling error in the second
    insert:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行两个插入操作，但在第二个插入中引入一个拼写错误：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We get a stack trace (we do not show it to save space) of the error:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了错误堆栈跟踪（我们为了节省空间没有显示）：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/e643bfd1-e947-42f2-9e4e-55a555146ae9.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e643bfd1-e947-42f2-9e4e-55a555146ae9.png)'
- en: 'The second row was not inserted. If there was no `conn.commit()` after the
    first `INSERT INTO` statement, the first insert would not be applied either. This
    is the advantage of the programmatic transaction control in the case of many independent
    data changes: if one fails, we can skip it and continue applying other changes.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行没有插入。如果在第一个`INSERT INTO`语句之后没有`conn.commit()`，第一个插入也不会生效。这是在许多独立数据更改的情况下程序性事务控制的优点：如果其中一个失败，我们可以跳过它并继续应用其他更改。
- en: 'Now let''s try to insert three rows with an error (by not setting a number
    as the `id` value) in the second row:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试在第二行插入三行带有错误（未设置`id`值作为数字）的记录：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We put each insert execution in the `try...catch` block and commit the changes
    before printing out the result (update count or error message). The result will
    be as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个插入执行放在`try...catch`块中，并在打印出结果（更新计数或错误消息）之前提交更改。结果如下：
- en: '![](img/e676ed35-c821-42a9-897d-555d2ce8bc79.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e676ed35-c821-42a9-897d-555d2ce8bc79.png)'
- en: You can see that the second row was not inserted, although `conn.rollback()`
    was commented out. Why? This is because the only SQL statement included in this
    transaction failed, so there was nothing to roll back.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管注释掉了`conn.rollback()`，第二行还是没有插入。为什么？这是因为这个事务中唯一的SQL语句失败了，所以没有可以回滚的内容。
- en: 'Now let''s create a `test` table using the database console:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用数据库控制台创建一个`test`表：
- en: '![](img/1994a329-9e4c-4b24-9caf-20a81cc2a977.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1994a329-9e4c-4b24-9caf-20a81cc2a977.png)'
- en: 'We will use this table to record the vehicle types of the records inserted
    in the `enums` table:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个表格来记录插入到`enums`表中的记录的车辆类型：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With `conn.rollback()` commented out, the result will be as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释掉`conn.rollback()`之后，结果如下：
- en: '![](img/9371aa64-1517-404f-97a7-1451f1b463e4.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9371aa64-1517-404f-97a7-1451f1b463e4.png)'
- en: 'The row with `truck` was not inserted in the `enums` table but added to the
    `test` table, although our intent was to record all the vehicles inserted in `enums`,
    and only them, in the `test` table. This is when the usefulness of a rollback
    can be demonstrated. If we uncomment `conn.rollback()`, the result will be as
    follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`truck`的行没有在`enums`表中插入，而是添加到了`test`表中，尽管我们的意图是记录在`enums`中插入的所有车辆，并且只在`test`表中记录它们。这就是回滚的有用之处可以体现出来的时候。如果我们取消注释`conn.rollback()`，结果将如下：
- en: '![](img/1bdc5cde-04b9-4eb2-9bbe-605b8c28f165.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1bdc5cde-04b9-4eb2-9bbe-605b8c28f165.png)'
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another important property of a transaction is the *transaction isolation level*.
    It defines the boundaries between database users. For example, can other users
    see your database changes before they are committed? The higher the isolation
    (the highest is *serializable*), the more the time it takes a transaction to complete
    in the case of concurrent access to the same records. The less restrictive the
    isolation (the least restrictive is *read uncommitted*), the dirtier the data;
    this is because other users can get the values you are not going to commit eventually.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 事务的一个重要属性是*事务隔离级别*。它定义了数据库用户之间的边界。例如，其他用户在提交之前能看到你的数据库更改吗？隔离级别越高（最高是*可序列化*），在并发访问相同记录的情况下，事务完成所需的时间就越长。隔离级别越不严格（最不严格的是*读取未提交*），数据就越脏；这是因为其他用户可以获取你最终不会提交的值。
- en: Usually, it is enough to use the default level, which (although it may be different
    for different databases) is typically `TRANSACTION_READ_COMMITTED`. JDBC allows
    you to get the current transaction isolation level using the `Connection` method
    called `getTransactionIsolation()`, while the `setTransactionIsolation()` method
    allows you to set any other level as needed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用默认级别就足够了，尽管它可能因数据库而异，通常是`TRANSACTION_READ_COMMITTED`。JDBC允许你使用名为`getTransactionIsolation()`的`Connection`方法获取当前事务隔离级别，而`setTransactionIsolation()`方法允许你根据需要设置任何其他级别。
- en: In the case of complex decision-making logic about which changes need to be
    committed and which need to be rolled back, one can use two `Connection` methods to
    create and delete *savepoints*. The `setSavepoint(String savepointName)` method creates
    a new savepoint and returns a `Savepoint` object, which can later be used to roll
    back all the changes up to this point using the `rollback (Savepoint savepoint)`
    method. A savepoint can be deleted by calling `releaseSavepoint(Savepoint savepoint)`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于哪些更改需要提交以及哪些需要回滚的复杂决策逻辑中，可以使用两个`Connection`方法来创建和删除**保存点**。`setSavepoint(String
    savepointName)`方法创建一个新的保存点并返回一个`Savepoint`对象，该对象可以稍后用于使用`rollback (Savepoint savepoint)`方法回滚到这个点之前的所有更改。可以通过调用`releaseSavepoint(Savepoint
    savepoint)`来删除保存点。
- en: The most complex type of database transactions is *distributed transactions*.
    They are sometimes called *global transactions*, *XA transactions*, or *JTA transactions* (the
    latter is a Java API that consists of two Java packages, namely `javax.transaction`
    and `javax.transaction.xa`). They allow you to create and execute a transaction
    that spans operations across two different databases. Providing a detailed overview
    of distributed transactions is outside the scope of this book.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的数据库事务类型是**分布式事务**。有时它们被称为**全局事务**、**XA事务**或**JTA事务**（后者是一个Java API，由两个Java包组成，即`javax.transaction`和`javax.transaction.xa`）。它们允许你创建和执行跨越两个不同数据库的操作的事务。提供分布式事务的详细概述超出了本书的范围。
- en: Working with large objects
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理大型对象
- en: 'In this recipe, you will learn how to store and retrieve a LOB that can be
    one of the three types: **Binary Large Object** (**BLOB**), **Character Large
    Object** (**CLOB**), and **National Character Large Object** (**NCLOB**).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何存储和检索一个可以是三种类型之一的LOB：**二进制大对象**（**BLOB**）、**字符大对象**（**CLOB**）和**国家字符大对象**（**NCLOB**）。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The actual processing of LOB objects inside a database is vendor-specific, but
    JDBC APIs hide these implementation details from the application by representing
    the three LOB types as interfaces: `java.sql.Blob`, `java.sql.Clob`, and `java.sql.NClob`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库内部对LOB对象的实际处理是供应商特定的，但JDBC API通过将三种LOB类型表示为接口来隐藏这些实现细节：`java.sql.Blob`、`java.sql.Clob`和`java.sql.NClob`。
- en: '`Blob` is usually used to store images or other non-alphanumeric data. On the
    way to the database, an image can be converted into a stream of bytes and stored
    using the `INSERT INTO` statement. The `Blob` interface allows you to find the
    length of the object and convert it into an array of bytes that can be processed
    by Java for the purpose of displaying the image, for example.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blob`通常用于存储图像或其他非字母数字数据。在通往数据库的路上，一张图像可以被转换成字节流并使用`INSERT INTO`语句进行存储。`Blob`接口允许你找到对象长度并将其转换为Java可以处理的字节数组，例如用于显示图像。'
- en: '`Clob` allows you to store character data. `NClob` stores Unicode character
    data as a way to support internationalization. It extends the `Clob` interface
    and provides the same methods. Both interfaces allow you to find the length of
    LOB and a substring inside the value.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clob`允许你存储字符数据。`NClob`以支持国际化的方式存储Unicode字符数据。它扩展了`Clob`接口并提供了相同的方法。这两个接口都允许你找到LOB的长度和值内的子字符串。'
- en: 'The methods in the `ResultSet`, `CallableStatement` (we will discuss this in
    the next recipe) and `PreparedStatement` interfaces allow an application to store
    and access the stored value in a variety of ways: some of them via setters and
    getters of the corresponding objects, while others as `bytes[]`, or as a binary,
    character, or ASCII stream.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet`、`CallableStatement`（我们将在下一道菜谱中讨论）和`PreparedStatement`接口中的方法允许应用程序以各种方式存储和访问存储的值：其中一些通过相应对象的setter和getter方法，而其他则作为`bytes[]`或作为二进制、字符或ASCII流。'
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Each database has its specific way of storing a LOB. In the case of PostgreSQL,
    `Blob` is usually mapped to the `OID` or `BYTEA` data type, while `Clob` and `NClob` are
    mapped to the `TEXT` type. So let''s write a new method that will allow us to
    create tables programmatically:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库都有其特定的存储LOB的方式。在PostgreSQL的情况下，`Blob`通常映射到`OID`或`BYTEA`数据类型，而`Clob`和`NClob`则映射到`TEXT`类型。因此，让我们编写一个新的方法，允许我们以编程方式创建表：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This differs from `executeUpdate()`, as it calls the `execute()` method of
    `PreparedStatement` instead of `executeUpdate()`. In principle, we can use `execute()`
    instead of `executeUpdate()` everywhere, but in our implementation of `executeUpdate()`,
    we expect a return value (`count`), which is not returned in the case of creating
    a table; therefore, we wrote this new method. Now we can create three tables:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`executeUpdate()`不同，因为它调用`PreparedStatement`的`execute()`方法而不是`executeUpdate()`。原则上，我们可以用`execute()`代替`executeUpdate()`在任何地方使用，但在我们的`executeUpdate()`实现中，我们期望有一个返回值（`count`），在创建表的情况下没有返回，因此我们编写了这个新方法。现在我们可以创建三个表：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Look at the JDBC interfaces `PreparedStatement` and `ResultSet` and you'll notice
    the setters and getters for the objects--`get/setBlob()`, `get/setClob()`, `get/setNClob()`,
    `get/setBytes()`-- in memory and the methods that use `InputStream` and `Reader` (`get/setBinaryStream()`,
    `get/setAsciiStream()`, or `get/setCharacterStream()`). The big advantage of streaming
    methods is that they move data between the database and source without storing
    the whole LOB in memory.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 查看JDBC接口`PreparedStatement`和`ResultSet`，你会注意到对象的setter和getter--`get/setBlob()`、`get/setClob()`、`get/setNClob()`、`get/setBytes()`--在内存中以及使用`InputStream`和`Reader`的方法（`get/setBinaryStream()`、`get/setAsciiStream()`或`get/setCharacterStream()`）。流式方法的优点是它们在数据库和源之间移动数据，而不需要在内存中存储整个LOB。
- en: 'However, the object''s setters and getters are closer to our heart as they
    are used to object-oriented coding. So we will start with them, using not too
    big objects, for demo purposes. We expect the code to work just fine:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对象的setter和getter更接近我们的心，因为它们用于面向对象的编码。所以我们将从它们开始，使用不太大的对象进行演示。我们期望代码能够正常工作：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Alternatively, in the case of `Clob`, we write this code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在`Clob`的情况下，我们编写以下代码：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It turns out not all methods available in the JDBC API are actually implemented
    by the drivers of all the databases. For example, `createBlob()` seems to work
    just fine for Oracle and MySQL, but in the case of PostgreSQL, we get this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，并非所有JDBC API中可用的方法都由所有数据库的驱动程序实现。例如，`createBlob()`对于Oracle和MySQL似乎工作得很好，但在PostgreSQL的情况下，我们得到以下结果：
- en: '![](img/4a788ba8-abc4-4087-9122-96078f015058.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a788ba8-abc4-4087-9122-96078f015058.png)'
- en: 'For the `Clob` example, we get this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Clob`示例，我们得到以下结果：
- en: '![](img/746fbbc3-9a6c-4143-9725-2432107c32c1.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/746fbbc3-9a6c-4143-9725-2432107c32c1.png)'
- en: 'We can try to retrieve an object from `ResultSet` via the getter as well:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以尝试通过getter从`ResultSet`检索对象：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The result will be as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/290d67e0-091a-426e-bc12-9a15b1a9aafe.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/290d67e0-091a-426e-bc12-9a15b1a9aafe.png)'
- en: 'Apparently, knowing the JDBC API is not enough; one has to read the documentation
    for the database too. Here is what the documentation for PostgreSQL ([https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html))
    has to say about LOB handling:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，仅了解JDBC API是不够的；还必须阅读数据库的文档。以下是PostgreSQL ([https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html))
    文档关于LOB处理的说明：
- en: To use the BYTEA data type you should simply use the getBytes(), setBytes(),
    getBinaryStream(), or setBinaryStream() methods.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用BYTEA数据类型，应简单地使用getBytes()、setBytes()、getBinaryStream()或setBinaryStream()方法。
- en: To use the Large Object functionality you can use either the LargeObject class
    provided by the PostgreSQL JDBC driver, or by using the getBLOB() and setBLOB()
    methods.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用大型对象功能，可以使用PostgreSQL JDBC驱动程序提供的LargeObject类，或者使用getBLOB()和setBLOB()方法。
- en: Also, *you must access Large Objects within an SQL transaction block. You can
    start a transaction block by calling setAutoCommit(false)*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*你必须在一个SQL事务块内访问大型对象。你可以通过调用setAutoCommit(false)来开始一个事务块*。
- en: Without knowing such specifics, figuring out a way to handle LOBs would require
    a lot of time and cause much frustration.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在不知道这些具体信息的情况下，找出处理LOB的方法需要花费大量时间，并造成很多挫败感。
- en: 'When dealing with LOBs, we will use the streaming methods first because streaming
    directly from the source into the database or the other way around does not consume
    memory as much as the setters and getters do (which have to load LOB in memory
    first). Here is the code that streams `Blob` in/from PostgreSQL:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理LOB时，我们首先会使用流式方法，因为直接从源到数据库或相反方向的流式传输比setter和getter消耗的内存要少得多（它们必须首先在内存中加载LOB）。以下是流式传输PostgreSQL中的`Blob`的代码：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will be your result. We have cut the screenshot arbitrarily on the right-hand
    side; otherwise, it is very long horizontally:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是你的结果。我们在右侧任意裁剪了截图；否则，它水平上非常长：
- en: '![](img/7340788e-cfe4-47d5-addf-012aebd12d91.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7340788e-cfe4-47d5-addf-012aebd12d91.png)'
- en: 'Another way to process the retrieved image is to use `byte[]`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 处理检索到的图像的另一种方式是使用 `byte[]`：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'PostgreSQL limits the BYTEA size to 1 GB. Larger binary objects can be stored
    as the **object identifier** (**OID**) data type:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 将 BYTEA 的大小限制为 1 GB。更大的二进制对象可以存储为 **对象标识符**（**OID**）数据类型：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The result will be as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下：
- en: '![](img/31ad56e0-7cf0-4fe1-9754-b26c947d6084.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31ad56e0-7cf0-4fe1-9754-b26c947d6084.png)'
- en: 'Note that the `select` statement returns a long value from the `lob` column.
    This is because the `OID` column does not store the value itself like BYTEA does.
    Instead, it stores the reference to the object that is stored somewhere else in
    the database. Such an arrangement makes deleting the row with the OID type not
    as straightforward as this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`select` 语句从 `lob` 列返回一个长值。这是因为 OID 列本身不存储值，就像 BYTEA 一样。相反，它存储对存储在数据库其他地方的对象的引用。这种安排使得删除具有
    OID 类型的行不像这样直接：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If one does just that, it leaves the actual object an orphan that continues
    to consume disk space, but, that is not referred to by any of the application
    tables. To avoid this problem, one has to `unlink` the LOB first by executing
    the following command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只是这样做，它将实际的对象留作孤儿，继续消耗磁盘空间，但没有任何应用程序表引用它。为了避免这个问题，必须首先通过执行以下命令来 `unlink` LOB：
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Only after this can you safely execute the `delete from lobs where id = 100` command.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在执行完 `delete from lobs where id = 100` 命令之后，你才能安全地执行。
- en: 'If you forget to `unlink` first, or if you create an orphan LOB accidentally
    (because of an error in the code or something), there is a way to find orphans
    in system tables. Again, database documentation should provide you with instructions
    on how to do this. In the case of PostgreSQL v.9.3 or later, you can check whether
    you have an orphan LOB by executing the `select count(*) from pg_largeobject` command.
    If it returns a count that is bigger than 0, then you can delete all the orphans
    with the following join (assuming that the `lobs` table is the only one that can
    refer to a LOB):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记先 `unlink`，或者意外地创建了一个孤儿 LOB（因为代码中的错误或其他原因），有一种方法可以在系统表中找到孤儿。同样，数据库文档应该提供如何操作的说明。在
    PostgreSQL v.9.3 或更高版本中，你可以通过执行 `select count(*) from pg_largeobject` 命令来检查是否有孤儿
    LOB。如果返回的计数大于 0，则可以使用以下连接删除所有孤儿（假设 `lobs` 表是唯一可以引用 LOB 的表）：
- en: '[PRE47]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is an overhead, though--the price one has to pay for storing a LOB in a
    database. It's worth noticing that although BYTEA does not require such complexity
    during the delete operation, it has a different kind of overhead. According to
    the PostgreSQL documentation, when close to 1 GB, *it would require a huge amount
    of memory to process such a large value.*
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个开销，但这是存储 LOB 到数据库必须付出的代价。值得注意的是，尽管 BYTEA 在删除操作期间不需要这种复杂性，但它有不同类型的开销。根据
    PostgreSQL 文档，当接近 1 GB 时，*处理如此大的值将需要大量的内存*。
- en: 'To read LOB data, one can use the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取 LOB 数据，可以使用以下代码：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Alternatively, one can also use an even simpler version by getting `Blob` directly
    from the `ResultSet` object if the LOB is not too big:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果 LOB 不是太大，也可以通过直接从 `ResultSet` 对象获取 `Blob` 来使用一个更简单的版本：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To store `Clob` in PostgreSQL, one can use the same code as the preceding one.
    While reading from the database, one can convert bytes into a `String` data type
    or something similar (again, if the LOB is not too big):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PostgreSQL 中存储 `Clob`，可以使用与前面相同的代码。在从数据库读取时，可以将字节转换为 `String` 数据类型或类似类型（如果
    LOB 不是太大）：
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, `Clob` in PostgreSQL can be stored directly as data type `TEXT` that
    is unlimited in size. This code reads the file where this code is written and
    stores/retrieves it in/from the database:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，PostgreSQL 中的 `Clob` 可以直接存储为无限大小的 `TEXT` 数据类型。此代码读取编写此代码的文件，并将其存储/检索到数据库中：
- en: '[PRE51]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The result will be as follows (we have shown only the first few lines of the
    output):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下（我们只显示了输出结果的前几行）：
- en: '![](img/18e521c3-38de-4b3b-8724-816367d8e052.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18e521c3-38de-4b3b-8724-816367d8e052.png)'
- en: 'For bigger objects, streaming methods would be a better (if not the only) choice:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的对象，流式方法会是一个更好的（如果不是唯一的选择）：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that `setCharacterStream(int, Reader, long)` is not implemented, while `setCharacterStream(int,
    Reader, int)` works just fine.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`setCharacterStream(int, Reader, long)` 没有实现，而 `setCharacterStream(int, Reader,
    int)` 工作正常。
- en: 'We can also read the file from the `texts` table as a character stream and
    limit it to the first 160 characters:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将`texts`表中的文件作为字符流读取，并限制为前160个字符：
- en: '[PRE53]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result will be as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下：
- en: '![](img/4d8e1598-e94c-4dbf-b7b7-c347448de32c.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d8e1598-e94c-4dbf-b7b7-c347448de32c.png)'
- en: There's more...
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is another recommendation from the PostgreSQL documentation (you can access
    it at [https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html)):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自PostgreSQL文档的另一条建议（你可以在[https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html)访问它）：
- en: The BYTEA data type is not well suited for storing very large amounts of binary
    data. While a column of type BYTEA can hold up to 1 GB of binary data, it would
    require a huge amount of memory to process such a large value.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: BYTEA数据类型不适合存储大量的二进制数据。虽然BYTEA类型的列可以存储高达1 GB的二进制数据，但处理如此大的值需要大量的内存。
- en: The Large Object method for storing binary data is better suited to storing
    very large values, but it has its own limitations. Specifically deleting a row
    that contains a Large Object reference does not delete the Large Object. Deleting
    the Large Object is a separate operation that needs to be performed. Large Objects
    also have some security issues since anyone connected to the database can view
    and/or modify any Large Object, even if they don't have permissions to view/update
    the row containing the Large Object reference.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 大对象（Large Object）方法更适合存储非常大的值，但它也有自己的局限性。具体来说，删除包含大对象引用的行并不会删除大对象。删除大对象是一个需要单独执行的操作。大对象也存在一些安全问题，因为任何连接到数据库的人都可以查看和/或修改任何大对象，即使他们没有权限查看/更新包含大对象引用的行。
- en: While deciding to store LOBs in a database, one has to remember that the bigger
    the database, the more difficult it is to maintain it. The speed of access--the
    main advantage of choosing a database as a storage facility--also slows down,
    and it is not possible to create indices for LOB types to improve the search.
    Also, one cannot use LOB columns in a `WHERE` clause, except for a few CLOB cases,
    or use LOB columns in multiple rows of `INSERT` or `UPDATE` statements.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定将LOB存储在数据库中时，必须记住，数据库越大，维护它就越困难。访问速度——选择数据库作为存储设施的主要优势——也会减慢，而且无法为LOB类型创建索引以改进搜索。此外，除了少数CLOB情况外，不能在`WHERE`子句中使用LOB列，也不能在`INSERT`或`UPDATE`语句的多个行中使用LOB列。
- en: So, before thinking about a database for a LOB, one should always consider whether
    storing the name of a file, keywords, and some other content properties in the
    database would be enough for the solution.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在考虑为LOB选择数据库之前，应该始终考虑是否将文件名、关键词和一些其他内容属性存储在数据库中就足够解决问题。
- en: Executing stored procedures
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行存储过程
- en: In this recipe, you will learn how to execute a database-stored procedure from
    a Java program.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何从Java程序中执行数据库存储过程。
- en: Getting ready
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Once in a while, a real-life Java programmer encounters the need to manipulate
    and/or select data in/from several tables and comes up with a set of complex SQL
    statements. In one scenario, a database administrator looks at the suggested procedure
    and improves and optimizes it so much that it becomes impossible or at least impractical
    to implement it in Java. This is when the developed set of SQL statements can
    be wrapped into a stored procedure that is compiled and stored in the database
    and then invoked via the JDBC interface. Or, in another twist of fate, a Java
    programmer might encounter the need for incorporating a call to an existing stored
    procedure into the program. To accomplish this, the interface `CallableStatement` (which
    extends interface `PreparedStatement`) can be used, although some databases allow
    you to call a stored procedure using either interface `Statement` or `PreparedStatement`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，现实生活中的Java程序员会遇到需要在多个表中操作和/或选择数据的需要，并因此提出一系列复杂的SQL语句。在一个场景中，数据库管理员查看建议的流程，并对其进行改进和优化，以至于在Java中实现它变得不可能或至少不切实际。这就是将开发的一组SQL语句封装成存储过程，编译并存储在数据库中，然后通过JDBC接口调用的时刻。或者，在命运的另一个转折点，Java程序员可能会遇到需要在程序中包含对现有存储过程的调用的需要。为了完成这个任务，可以使用`CallableStatement`接口（它扩展了`PreparedStatement`接口），尽管一些数据库允许你使用`Statement`或`PreparedStatement`接口中的任何一个来调用存储过程。
- en: '`CallableStatement` can have parameters of three types: `IN` for an input value,
    `OUT` for the result, and `IN OUT` for either an input or an output value. `OUT`
    parameters must be registered by the `registerOutParameter()` method of `CallableStatement`.
    IN parameters are set the same way as the parameters of `PreparedStatement`.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallableStatement` 可以有三种类型的参数：`IN` 用于输入值，`OUT` 用于结果，以及 `IN OUT` 用于输入或输出值。`OUT`
    参数必须通过 `CallableStatement` 的 `registerOutParameter()` 方法进行注册。IN 参数的设置方式与 `PreparedStatement`
    的参数相同。'
- en: Bear in mind that executing a stored procedure from Java programmatically is
    one of the least standardized areas. PostgreSQL, for example, does not support
    stored procedures directly, but they can be invoked as functions, which have been
    modified for this purpose by interpreting `OUT` parameters as return values. Oracle,
    on the other hand, allows `OUT` parameters for functions too.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，从 Java 程序中程序化执行存储过程是标准化程度最低的领域之一。例如，PostgreSQL 不直接支持存储过程，但它们可以作为函数调用，这些函数已经通过将
    `OUT` 参数解释为返回值而进行了修改。另一方面，Oracle 允许函数也有 `OUT` 参数。
- en: 'This is why the following difference between database functions and stored
    procedures can serve only as a general guideline, not as a formal definition:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下数据库函数和存储过程之间的区别只能作为一般指南，而不是正式定义：
- en: A function has a return value, but it does not allow `OUT` parameters (except
    for some databases) and can be used in an SQL statement.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数有一个返回值，但它不允许 `OUT` 参数（除了某些数据库），并且可以在 SQL 语句中使用。
- en: A stored procedure does not have a return value (except for some databases);
    it allows `OUT` parameters (for most databases) and can be executed using the
    JDBC interface `CallableStatement`.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储过程没有返回值（除了某些数据库）；它允许 `OUT` 参数（对于大多数数据库）并且可以使用 JDBC 接口的 `CallableStatement`
    执行。
- en: This is why reading the database documentation in order to learn how to execute
    a stored procedure is as important as, say, handling LOBs, discussed in the previous
    recipe.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么阅读数据库文档以学习如何执行存储过程，与之前菜谱中讨论的，处理 LOBs 一样重要。
- en: Because stored procedures are compiled and stored in the database server, the
    `execute()` method of `CallableStatement` performs better for the same SQL statement
    than the corresponding method of `Statement` or `PreparedStatement`. This is one
    of the reasons a lot of Java code is sometimes replaced by one or several stored
    procedures that include even the business logic. Another reason for such a decision
    is that one can implement the solution the way one is most familiar with. So,
    there is no right answer for all cases and situations, and we will refrain from
    making specific recommendations, except to repeat the familiar mantra about the value
    of testing and the clarity of the code you are writing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因为存储过程是在数据库服务器上编译和存储的，所以 `CallableStatement` 的 `execute()` 方法对于相同的 SQL 语句比 `Statement`
    或 `PreparedStatement` 的相应方法性能更好。这就是为什么很多 Java 代码有时会被一个或多个包含甚至业务逻辑的存储过程所取代的原因之一。做出这种决定的另一个原因是，人们可以以最熟悉的方式实现解决方案。因此，对于所有情况和情况，没有正确答案，我们将避免提出具体建议，除了重复关于测试价值和编写代码清晰度的熟悉箴言。
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: As in the previous recipe, we will continue using the PostgreSQL database for
    demonstration purposes. Before writing custom SQL statements, functions, and stored
    procedures, one should look at the list of already existing functions first. Usually,
    they provide a wealth of functionality.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将继续使用 PostgreSQL 数据库进行演示。在编写自定义 SQL 语句、函数和存储过程之前，应该首先查看现有函数的列表。通常，它们提供了丰富的功能。
- en: 'Here is an example of calling the `replace(string text, from text, to text)`
    function that finds all the `from text ` substrings in `string text` and replaces
    them with `to text`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个调用 `replace(string text, from text, to text)` 函数的例子，该函数查找 `string text`
    中的所有 `from text` 子串，并将它们替换为 `to text`：
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result is as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/8e199295-8014-439c-a39b-e4bf4849f5e0.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e199295-8014-439c-a39b-e4bf4849f5e0.png)'
- en: We will incorporate this function into our custom functions and stored procedures
    in order to show how it can be done.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个功能整合到我们的自定义函数和存储过程中，以展示如何实现。
- en: 'A stored procedure can be without any parameters at all, with `IN` parameters
    only, with `OUT` parameters only, or with both. The result may be one or multiple
    values, or a `ResultSet` object. Here is an example of creating a stored procedure
    without any parameters in PostgreSQL:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 存储过程可以没有任何参数，只有 `IN` 参数，只有 `OUT` 参数，或者两者都有。结果可能是一个或多个值，或者一个 `ResultSet` 对象。以下是在
    PostgreSQL 中创建不带任何参数的存储过程的示例：
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We use a method we are already familiar with:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个我们已熟悉的方法：
- en: '[PRE56]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This stored procedure (it is always a function in PostgreSQL) creates a `texts` table
    (drops this if the table exists already). You can find the syntax of the SQL for
    function creation in the database documentation. The only thing we would like
    to comment here is that instead of the symbol `$$` that denotes the function body,
    you can use single quotes. We prefer `$$` because it helps avoid the escaping
    of single quotes in case we need to include them in the function body.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储过程（在 PostgreSQL 中它始终是一个函数）创建一个 `texts` 表（如果表已存在，则删除）。你可以在数据库文档中找到创建函数的 SQL
    语法。我们只想在这里评论一下，你可以使用单引号而不是表示函数体的符号 `$$`。我们更喜欢使用 `$$`，因为它有助于避免在需要将单引号包含在函数体中时进行转义。
- en: 'This procedure can be invoked by `CallableStatement`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以通过 `CallableStatement` 调用：
- en: '[PRE57]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Alternatively, it can be invoked with the SQL statement `select createTableTexts()` or `select
    * from createTableTexts()`. Both statements return a `ResultSet` object (which
    is `null` in the case of the `createTableTexts()` function), so we can traverse
    it by our method:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用 SQL 语句 `select createTableTexts()` 或 `select * from createTableTexts()`
    来调用它。这两个语句都返回一个 `ResultSet` 对象（在 `createTableTexts()` 函数的情况下为 `null`），因此我们可以通过我们的方法遍历它：
- en: '[PRE58]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We have already used this method in the previous recipes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的菜谱中使用了这个方法。
- en: The function can be deleted by the `drop function if exists createTableTexts()` statement.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `drop function if exists createTableTexts()` 语句删除函数。
- en: 'Now let''s put all of this together in Java code, create a function, and invoke
    it in three different styles:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这些内容全部整合到 Java 代码中，创建一个函数，并以三种不同的方式调用它：
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The result is as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/cc42e573-2b09-4dda-a2b5-c0f62aeea46b.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cc42e573-2b09-4dda-a2b5-c0f62aeea46b.png)'
- en: Note that the name of the function is case-insensitive. We keep it camel case
    for human readability only.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数的名称不区分大小写。我们保持驼峰式命名只是为了提高可读性。
- en: 'Now let''s create and call a stored procedure (function) with two input parameters:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建并调用一个带有两个输入参数的存储过程（函数）：
- en: '[PRE60]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the function body, the input parameters were referred to by their `$1` and
    `$2` positions. As mentioned before, we also used the built-in `replace()` function
    to manipulate the values of the second input parameter before inserting it in
    the table. We called the newly created stored procedure twice: first via `CallableStatment`
    and then via the `execute()` method, with different input values. Then we looked
    inside the table using `traverseRS("select * from texts")` and dropped the newly
    created function to perform a cleanup (in real code, the function, once created,
    stays and takes advantage of being there, compiled and ready to run). If we run
    this code, we''ll get the following result:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，输入参数通过它们的 `$1` 和 `$2` 位置引用。如前所述，我们在将第二个输入参数插入表之前，也使用了内置的 `replace()` 函数来操作该参数的值。我们调用了新创建的存储过程两次：首先通过
    `CallableStatment`，然后通过 `execute()` 方法，使用不同的输入值。然后我们使用 `traverseRS("select * from
    texts")` 查看表内容，并删除新创建的函数以进行清理（在实际代码中，一旦创建，函数就会保留并利用其存在，编译并准备好运行）。如果我们运行此代码，我们将得到以下结果：
- en: '![](img/fa933ce1-3f33-4adc-8036-e089af2e167c.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa933ce1-3f33-4adc-8036-e089af2e167c.png)'
- en: 'The following code adds two rows to the `texts` table, then looks into it and
    creates a stored procedure (function) that counts the number of rows in the table
    and returns the result (note the `bigint` value of the returned value and the
    matching type for the `OUT` parameter `Types.BIGINT`):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码向 `texts` 表中添加两行，然后查询它并创建一个存储过程（函数），该函数计算表中的行数并返回结果（注意返回值的 `bigint` 值和 `OUT`
    参数 `Types.BIGINT` 的匹配类型）：
- en: '[PRE61]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The newly created stored procedure is executed three times and then deleted.
    The result is as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的存储过程被执行了三次，然后被删除。结果如下：
- en: '![](img/faa8f054-3e42-4fb9-b6bf-81bc02e669dc.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/faa8f054-3e42-4fb9-b6bf-81bc02e669dc.png)'
- en: 'An example of a stored procedure with one input parameter (of the type `int`)
    that returns `ResultSet` will look like this (note the return type defined as
    `setof texts`, where `texts` is the name of the table):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有一个输入参数（类型为`int`）并返回`ResultSet`的存储过程示例将如下所示（注意返回类型定义为`setof texts`，其中`texts`是表名称）：
- en: '[PRE62]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The result will be as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/ad9e4a06-e481-491c-8cf3-4ea71834543f.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad9e4a06-e481-491c-8cf3-4ea71834543f.png)'
- en: It's worth analyzing the difference in the `ResultSet` content of two different
    calls to the stored procedure. Without `select *`, it contains the name of the
    procedure and the returned object (of the `ResultSet` type). But with `select
    *`, it returns the actual `ResultSet` content from the last SQL statement in the
    procedure.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 值得分析两次调用存储过程的`ResultSet`内容之间的差异。没有`select *`时，它包含过程名称和返回的对象（`ResultSet`类型）。但是，使用`select
    *`时，它返回过程中的最后一个SQL语句的实际`ResultSet`内容。
- en: 'Naturally, the question arises why we could not call this stored procedure
    via `CallableStatement`, like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，人们会问为什么我们不能像这样通过`CallableStatement`调用这个存储过程：
- en: '[PRE63]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We tried, but it did not work. Here is what the PostgreSQL documentation has
    to say about it:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试了，但不起作用。以下是PostgreSQL文档对此的说明：
- en: Functions that return data as a set should not be called via the CallableStatement
    interface, but instead should use the normal Statement or PreparedStatement interfaces.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 应该通过CallableStatement接口而不是通过CallableStatement接口调用返回数据集的函数。
- en: 'There is a way around this limitation, though. The same database documentation
    describes how to retrieve a `refcursor` (a PostgreSQL-specific feature) value
    that can then be cast to `ResultSet`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这种限制，但有一种方法可以绕过。相同的数据库文档描述了如何检索一个`refcursor`（一个PostgreSQL特定的功能）的值，然后可以将其转换为`ResultSet`：
- en: '[PRE64]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A few comments about the preceding code would probably help you understand
    how it was done:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面代码的一些注释可能有助于你理解它是如何完成的：
- en: Autocommit has to be turned off
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动提交必须关闭
- en: Inside the function, `$1` refers to the first `IN` parameter (not counting the
    `OUT` parameter)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部，`$1`指的是第一个`IN`参数（不包括`OUT`参数）
- en: The language is set to `plpgsql` in order to access the `refcursor` functionality
    (PL/pgSQL is a loadable procedural language of the PostgreSQL database)
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了访问`refcursor`功能（PL/pgSQL是PostgreSQL数据库的可加载过程语言），语言设置为`plpgsql`
- en: 'To traverse `ResultSet`, we wrote a new method, as follows:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要遍历`ResultSet`，我们编写了一个新方法，如下所示：
- en: '[PRE65]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'So, our old friend can now be refactored into this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的老朋友现在可以被重构为这样：
- en: '[PRE66]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The result will be as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/23c60d40-e621-4b5c-ab32-5bb63acbead8.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23c60d40-e621-4b5c-ab32-5bb63acbead8.png)'
- en: You can see that the result-traversing methods that do not extract an object
    and cast it to `ResultSet` don't show the correct data in this case.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在这种情况下，不提取对象并将其转换为`ResultSet`的结果遍历方法没有显示正确数据。
- en: There's more...
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We covered the most popular cases of calling stored procedures from Java code.
    The scope of this book did not allow us to present more complex and potentially
    useful forms of stored procedures in PostgreSQL and other databases. However,
    we would like to mention them here, so you can have an idea of other possibilities:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了从Java代码调用存储过程最常见的情况。本书的范围不允许我们展示PostgreSQL和其他数据库中更复杂且可能有用的存储过程形式。然而，我们想在这里提及它们，以便你了解其他可能性：
- en: Functions on composite types
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合类型上的函数
- en: Functions with parameter names
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有参数名称的函数
- en: Functions with variable numbers of arguments
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有可变数量参数的函数
- en: Functions with default values for arguments
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有默认参数值的函数
- en: Functions as table sources
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为表源的函数
- en: Functions returning tables
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回表格的函数
- en: Polymorphic SQL functions
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态SQL函数
- en: Functions with collations
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有校对的函数
