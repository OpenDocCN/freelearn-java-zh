- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Session Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话管理
- en: 'This chapter discusses Spring Security’s session management functionality.
    It starts off with an example of how Spring Security defends against session fixation.
    We will then discuss how concurrency control can be leveraged to restrict access
    to software licensed on a per-user basis. We will also see how session management
    can be leveraged for administrative functions. Last, we will explore how `HttpSession`
    is used in Spring Security and how we can manage sessions:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了Spring Security的会话管理功能。它从一个Spring Security如何防御会话固定的例子开始。然后我们将讨论如何利用并发控制来限制按用户许可的软件的访问。我们还将看到如何利用会话管理进行管理功能。最后，我们将探讨`HttpSession`在Spring
    Security中的使用以及如何管理会话：
- en: 'The following is a list of topics that will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本章中将要涉及的主题列表：
- en: Session management/session fixation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话管理/会话固定
- en: Concurrency control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发控制
- en: Managing logged-in users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理已登录用户
- en: How `HttpSession` is used in Spring Security and how to control creation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpSession`在Spring Security中的使用以及如何控制创建'
- en: How to use the `DebugFilter` class to discover where `HttpSession` was created
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`DebugFilter`类来发现`HttpSession`的创建位置
- en: 'This chapter’s code in action link is here: [https://packt.link/qaJyz](https://packt.link/qaJyz).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码实战链接在此：[https://packt.link/qaJyz](https://packt.link/qaJyz).
- en: Configuring session fixation protection
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置会话固定保护
- en: 'As we are using the security namespace style of configuration, session fixation
    protection is already configured on our behalf. If we wanted to explicitly configure
    it to mirror the default settings, we would do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是安全命名空间风格的配置，会话固定保护已经为我们配置好了。如果我们想显式配置以匹配默认设置，我们将执行以下操作：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Session fixation protection** is a feature of the framework that you most
    likely won’t even notice unless you try to act as a malicious user. We’ll show
    you how to simulate a session-stealing attack; before we do, it’s important to
    understand what session fixation does and the type of attack it prevents.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话固定保护**是框架的一个特性，除非你尝试扮演恶意用户，否则你很可能不会注意到它。我们将向您展示如何模拟会话窃取攻击；在我们这样做之前，了解会话固定做什么以及它阻止的攻击类型非常重要。'
- en: Understanding session fixation attacks
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解会话固定攻击
- en: Session fixation is a type of attack whereby a malicious user attempts to steal
    the session of an unauthenticated user of your system. This can be done by using
    a variety of techniques that result in the attacker obtaining the unique session
    identifier of the user (for example, `JSESSIONID`). If the attacker creates a
    cookie or a URL parameter with the user’s `JSESSIONID` identifier in it, they
    can access the user’s session.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 会话固定是一种攻击类型，恶意用户试图窃取系统未认证用户的会话。这可以通过使用各种技术实现，导致攻击者获得用户的唯一会话标识符（例如，`JSESSIONID`）。如果攻击者创建一个包含用户`JSESSIONID`标识符的cookie或URL参数，他们就可以访问用户的会话。
- en: Although this is obviously a problem, typically, if a user is unauthenticated,
    they haven’t entered any sensitive information. This becomes a more critical problem
    if the same session identifier continues to be used after a user has been authenticated.
    If the same identifier is used after authentication, the attacker may now gain
    access to the authenticated user’s session without even having to know their username
    or password!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这显然是一个问题，但通常情况下，如果用户未认证，他们没有输入任何敏感信息。如果用户认证后继续使用相同的会话标识符，这将成为一个更严重的问题。如果认证后使用相同的标识符，攻击者现在可能无需知道用户的用户名或密码就能访问认证用户的会话！
- en: Important note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: At this point, you may scoff in disbelief and think this is extremely unlikely
    to happen in the real world. In fact, session-stealing attacks happen frequently.
    We would suggest that you spend some time reading the very informative articles
    and case studies on the subject, published by the **Open Web Application Security
    Project** (**OWASP**) organization ([http://www.owasp.org/](http://www.owasp.org/)).
    Specifically, you will want to read the OWASP top 10 lists. Attackers and malicious
    users are real, and they can do very real damage to your users, your application,
    or your company if you don’t understand the techniques that they commonly use.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会嘲笑并认为这在现实世界中极不可能发生。事实上，会话窃取攻击经常发生。我们建议你花些时间阅读由**开放网络应用安全项目**（**OWASP**）组织发布的关于该主题非常有信息量的文章和案例研究（[http://www.owasp.org/](http://www.owasp.org/)）。特别是，你将想阅读OWASP前10名列表。攻击者和恶意用户是真实存在的，如果你不了解他们常用的技术，他们可能会对你的用户、你的应用程序或你的公司造成非常真实的损害。
- en: 'The following diagram illustrates how a session fixation attack works:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了会话固定攻击是如何工作的：
- en: '![Figure 14.1 – Session fixation attack](img/B21757_14_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 会话固定攻击](img/B21757_14_1.jpg)'
- en: Figure 14.1 – Session fixation attack
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 会话固定攻击
- en: In this diagram, we see that by fixing the session identifier to a known value,
    the attacker bypasses the normal authentication process and gains unauthorized
    access to the victim’s account or session. This type of attack underscores the
    importance of properly managing and securing session identifiers to prevent session
    fixation vulnerabilities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们可以看到通过将会话标识符固定为已知值，攻击者绕过了正常的认证过程，并获得了对受害者账户或会话的非授权访问。这种攻击强调了正确管理和保护会话标识符以防止会话固定漏洞的重要性。
- en: Now that we have seen how an attack like this works, we’ll see what Spring Security
    can do to prevent it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了这种攻击是如何工作的，我们将看看Spring Security能做些什么来预防它。
- en: Preventing session fixation attacks with Spring Security
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Spring Security预防会话固定攻击
- en: If we can prevent the same session that the user had prior to authentication
    from being used after authentication, we can effectively render the attacker’s
    knowledge of the session ID useless. Spring Security session fixation protection
    solves this problem by explicitly creating a new session when a user is authenticated
    and invalidating their old session.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在用户认证之前防止使用相同的会话，那么我们就可以有效地使攻击者对会话ID的了解变得无用。Spring Security会话固定保护通过在用户认证时显式创建一个新的会话并使旧的会话无效来解决这个问题。
- en: 'Let’s look at the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图示：
- en: '![Figure 14.2 – Preventing session fixation attacks with Spring Security](img/B21757_14_2.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 使用Spring Security预防会话固定攻击](img/B21757_14_2.jpg)'
- en: Figure 14.2 – Preventing session fixation attacks with Spring Security
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 使用Spring Security预防会话固定攻击
- en: We can see that a new filter, `o.s.s.web.session.SessionManagementFilter`, is
    responsible for evaluating if a particular user is newly authenticated. If the
    user is newly authenticated, a configured `o.s.s.web.authentication.session.SessionAuthenticationStrategy`
    interface determines what to do. `o.s.s.web.authentication.session.SessionFixation`
    **ProtectionStrategy** will create a new session (if the user already had one)
    and copy the contents of the existing session to the new one. That’s pretty much
    it—seems simple. However, as we can see in the preceding diagram, it effectively
    prevents the malicious user from reusing the session ID after the unknown user
    is authenticated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个新的过滤器`o.s.s.web.session.SessionManagementFilter`负责评估特定用户是否是新认证的。如果用户是新认证的，配置的`o.s.s.web.authentication.session.SessionAuthenticationStrategy`接口将决定要做什么。`o.s.s.web.authentication.session.SessionFixation
    ProtectionStrategy`将创建一个新的会话（如果用户已经有了），并将现有会话的内容复制到新会话中。就是这样——看起来很简单。然而，正如我们可以在前面的图中看到的，它有效地防止了恶意用户在未知用户认证后重新使用会话ID。
- en: Simulating a session fixation attack
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟会话固定攻击
- en: 'At this point, you may want to see what’s involved in simulating a session
    fixation attack:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想看看模拟会话固定攻击涉及的内容：
- en: Important note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter14.00-calendar`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从`chapter14.00-calendar`中的代码开始。
- en: You’ll first need to disable session fixation protection in the `SecurityConfig.java`
    file by adding the `sessionManagement()` method as a child of the `HTTP` element.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先需要在`SecurityConfig.java`文件中禁用会话固定保护，通过将`sessionManagement()`方法作为`HTTP`元素的子元素添加。
- en: 'Let’s take a look at the following code snippet:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看以下代码片段：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter14.01-calendar`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter14.01-calendar`。
- en: Next, you’ll need to open two browsers. We’ll initiate the session in Google
    Chrome, steal it from there, and our attacker will log in using the stolen session
    in Firefox. We will use the *Google Chrome* and *Firefox Web Developer* add-ons
    in order to view and manipulate cookies.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要打开两个浏览器。我们将在谷歌浏览器中启动会话，从那里窃取它，我们的攻击者将使用在Firefox中窃取的会话登录。我们将使用*Google
    Chrome*和*Firefox Web Developer*插件来查看和操作cookies。
- en: Open the JBCP calendar home page in Google Chrome.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在谷歌浏览器中打开JBCP日历主页。
- en: 'Next:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来：
- en: '**Open Developer Tools**: Right-click on the web page and select **Inspect**,
    or press *Ctrl + Shift + I* (Windows/Linux) or *Cmd + Opt + I* (Mac) to open the
    Developer Tools.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打开开发者工具**：右键点击网页并选择**检查**，或者按*Ctrl + Shift + I*（Windows/Linux）或*Cmd + Opt
    + I*（Mac）来打开开发者工具。'
- en: '**Navigate to the Application Tab**: In the Developer Tools, you will see a
    menu at the top. Click on the **Application** tab.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航到应用程序标签**：在开发者工具中，您会在顶部看到一个菜单。点击**应用程序**标签。'
- en: '**Locate Cookies in the Sidebar**: On the left sidebar, you should see a **Cookies**
    section. Expand it to see the list of domains with their associated cookies.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在侧边栏中定位Cookies**：在左侧侧边栏中，您应该看到一个**Cookies**部分。展开它以查看带有其关联cookie的域名列表。'
- en: '**Select the Specific Domain**: Click on the domain relevant to the website
    you are interested in. This will display the list of cookies associated with that
    domain.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择特定域名**：点击与您感兴趣的网站相关的域名。这将显示与该域名关联的cookie列表。'
- en: '**View the Cookie Values**: You can see the details of each cookie, including
    its name, value, domain, path, and so on. Look for the specific cookie you are
    interested in, and you will find its value.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看Cookie值**：您可以看到每个cookie的详细信息，包括其名称、值、域名、路径等。寻找您感兴趣的特定cookie，您将找到其值。'
- en: '![Figure 14.3 – Cookies explorer in Google Chrome](img/B21757_14_3.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – Google Chrome中的Cookies浏览器](img/B21757_14_3.jpg)'
- en: Figure 14.3 – Cookies explorer in Google Chrome
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – Google Chrome中的Cookies浏览器
- en: Select the `JSESSIONID` cookie, copy the value of `JSESSIONID` did not change
    after you logged in, making you vulnerable to a session fixation attack!
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`JSESSIONID` cookie，登录后`JSESSIONID`的值没有改变，这使得您容易受到会话固定攻击的攻击！
- en: 'In Firefox, open the JBCP calendar website. You will have been assigned a session
    cookie, which you can view by using *Ctrl + F2* to open the **bottom: Cookie**
    console. Then, type in *cookie list [enter]* to bring up cookies for the current
    page.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Firefox中打开JBCP日历网站。您将被分配一个会话cookie，您可以通过使用*Ctrl + F2*打开**底部：Cookie**控制台来查看它。然后，输入*cookie
    list [enter]*以显示当前页面的cookies。
- en: 'To complete our hack, we’ll click on the `JSESSIONID` cookie that we copied
    to the clipboard from Google Chrome, as shown in the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的黑客攻击，我们将点击从谷歌浏览器复制到剪贴板的`JSESSIONID` cookie，如下截图所示：
- en: '![Figure 14.4 – Cookies hack in Firefox](img/B21757_14_4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – Firefox中的Cookies黑客攻击](img/B21757_14_4.jpg)'
- en: Figure 14.4 – Cookies hack in Firefox
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – Firefox中的Cookies黑客攻击
- en: Keep in mind that newer versions of Firefox include web developer tools, too.
    However, you will need to ensure that you are using the extension and not the
    built-in one, as it provides additional capabilities.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，Firefox的新版本也包括了网页开发者工具。然而，您需要确保您使用的是扩展程序而不是内置的，因为它提供了额外的功能。
- en: Our session fixation hack is complete! If you now reload the page in Firefox,
    you will see that you are logged in as the same user who was logged in using Google
    Chrome, but without the knowledge of the username and password. Are you scared
    of malicious users yet?
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的会话固定黑客攻击已经完成！如果您现在在Firefox中重新加载页面，您会看到您以使用谷歌浏览器登录的同一用户身份登录，但不知道用户名和密码。您对恶意用户感到害怕了吗？
- en: Now, re-enable session fixation protection and try this exercise again. You’ll
    see that, in this case, the `JSESSIONID` changes after the user logs in. Based
    on our understanding of how session fixation attacks occur, this means that we
    have reduced the likelihood of an unsuspecting user falling victim to this type
    of attack. Excellent job!
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重新启用会话固定保护并再次尝试这个练习。您会看到，在这种情况下，`JSESSIONID`在用户登录后会发生变化。根据我们对会话固定攻击发生方式的了解，这意味着我们已经降低了不知情用户成为这种攻击受害者的可能性。干得好！
- en: Cautious developers should note that there are many methods of stealing session
    cookies, some of which—such as `XSS`—may make even session fixation-protected
    sites vulnerable. Please consult the OWASP site for additional resources on preventing
    these types of attacks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎的开发者应注意到有许多窃取会话cookie的方法，其中一些——例如`XSS`——甚至可能使会话固定保护网站变得脆弱。请参考OWASP网站以获取防止此类攻击的额外资源。
- en: Comparing the session-fixation-protection options
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较会话固定保护选项
- en: 'The `session-fixation-protection` attribute has the following three options
    that allow you to alter its behavior; they are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`session-fixation-protection`属性有三个选项，允许您更改其行为；它们如下所示：'
- en: '| **Attribute value** | **Description** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **属性值** | **描述** |'
- en: '| `none()` | This option disables session fixation protection and (unless other
    `sessionManagement()` attributes are non-default) does not configure `SessionManagementFilter`.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `none()` | 此选项禁用会话固定保护，并且（除非其他`sessionManagement()`属性非默认）不会配置`SessionManagementFilter`。
    |'
- en: '| `migrateSession()` | When the user is authenticated and a new session is
    allocated, it ensures that all attributes of the old session are moved to the
    new session. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `migrateSession()` | 当用户经过身份验证并分配新会话时，它确保将旧会话的所有属性移动到新会话中。 |'
- en: '| `newSession()` | When the user is authenticated, a new session is created
    and no attributes from the old (unauthenticated) session will be migrated. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `newSession()` | 当用户经过身份验证时，将创建新会话，并且不会从旧（未经身份验证）会话迁移任何属性。 |'
- en: Table 14.1 – session-fixation-protection options
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1 – 会话固定保护选项
- en: In most cases, the default behavior of `migrateSession()` will be appropriate
    for sites that wish to retain important attributes of the user’s session (such
    as click interest and shopping carts) after the user has been authenticated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`migrateSession()` 方法的默认行为将适用于希望保留用户会话重要属性（如点击兴趣和购物车）的网站，在用户经过身份验证后。
- en: Restricting the number of concurrent sessions per user
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制每个用户的并发会话数量
- en: In the software industry, software is often sold on a per-user basis. This means
    that, as software developers, we have an interest in ensuring that only a single
    session per user exists, to combat the sharing of accounts. Spring Security’s
    concurrent session control ensures that a single user cannot have more than a
    fixed number of active sessions simultaneously (typically one). Ensuring that
    this maximum limit is enforced involves several components working in tandem to
    accurately track changes in user session activity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件行业，软件通常按用户销售。这意味着，作为软件开发者，我们有一个确保每个用户只能存在一个会话的兴趣，以对抗账户共享。Spring Security的并发会话控制确保单个用户不能同时拥有超过固定数量的活动会话（通常是单个）。确保实施此最大限制需要多个组件协同工作，以准确跟踪用户会话活动的变化。
- en: Let’s configure the feature, review how it works, and then test it out!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置这个功能，查看它是如何工作的，然后测试一下！
- en: Configuring concurrent session control
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置并发会话控制
- en: 'Now that we have understood the different components involved in concurrent
    session control, setting it up should make much more sense. Let’s take a look
    at the following steps to configure concurrent session control:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了并发会话控制中涉及的不同组件，设置它应该更有意义。让我们看看以下步骤来配置并发会话控制：
- en: 'Firstly, you update your `SecurityConfig.java` file as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要按照以下方式更新您的`SecurityConfig.java`文件：
- en: '[PRE2]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to enable `o.s.s.web.session.HttpSessionEventPublisher` in the
    `SecurityConfig.java` deployment descriptor so that the servlet container will
    notify Spring Security (through `HttpSessionEventPublisher`) of session life cycle
    events, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`SecurityConfig.java`部署描述符中启用`o.s.s.web.session.HttpSessionEventPublisher`，以便servlet容器能够通知Spring
    Security（通过`HttpSessionEventPublisher`）会话生命周期事件，如下所示：
- en: '[PRE3]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With these two configuration bits in place, concurrent session control will
    now be activated. Let’s see what it actually does, and then we’ll demonstrate
    how it can be tested.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个配置位就绪后，并发会话控制现在将被激活。让我们看看它实际上做了什么，然后我们将演示如何对其进行测试。
- en: Understanding concurrent session control
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解并发会话控制
- en: Concurrent session control uses `o.s.s.core.session.SessionRegistry` to maintain
    a list of active HTTP sessions and the authenticated users with which they are
    associated. As sessions are created and expired, the registry is updated in real
    time based on the session life cycle events published by `HttpSessionEventPublisher`
    to track the number of active sessions per authenticated user.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并发会话控制使用 `o.s.s.core.session.SessionRegistry` 来维护活动HTTP会话及其关联的已认证用户列表。随着会话的创建和过期，注册表会根据
    `HttpSessionEventPublisher` 发布的会话生命周期事件实时更新，以跟踪每个已认证用户的活跃会话数量。
- en: 'Refer to the following diagram:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下图表：
- en: '![Figure 14.5 – Concurrent session control](img/B21757_14_5.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 并发会话控制](img/B21757_14_5.jpg)'
- en: Figure 14.5 – Concurrent session control
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 并发会话控制
- en: An extension of `SessionAuthenticationStrategy`, `o.s.s.web.authentication.session.ConcurrentSessionControlStrategy`
    is the method by which new sessions are tracked and the method by which concurrency
    control is actually enforced. Each time a user accesses the secured site, `SessionManagementFilter`
    is used to check the active session against `SessionRegistry`. If the user’s active
    session isn’t in the list of active sessions tracked in `SessionRegistry`, the
    least recently used session is immediately expired.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionAuthenticationStrategy` 的扩展 `o.s.s.web.authentication.session.ConcurrentSessionControlStrategy`
    是跟踪新会话以及实际执行并发控制的方法。每次用户访问受保护网站时，`SessionManagementFilter` 都会用来检查活动会话与 `SessionRegistry`
    中的活动会话列表是否匹配。如果用户的活跃会话不在 `SessionRegistry` 中跟踪的活动会话列表中，则最近最少使用的会话将被立即过期。'
- en: The secondary actor in the modified concurrent session control filter chain
    is `o.s.s.web.session.ConcurrentSessionFilter`. This filter will recognize expired
    sessions (typically, sessions that have been expired either by the servlet container
    or forcibly by the `ConcurrentSessionControlStrategy` interface) and notify the
    user that their session has expired.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的并发会话控制过滤器链中的次要参与者是 `o.s.s.web.session.ConcurrentSessionFilter`。这个过滤器将识别已过期的会话（通常是会话由于servlet容器或通过
    `ConcurrentSessionControlStrategy` 接口强制过期）并通知用户他们的会话已过期。
- en: Now that we have understood how concurrent session control works, it should
    be easy for us to reproduce a scenario in which it is enforced.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了并发会话控制的工作原理，我们应该能够轻松地重现一个强制执行该控制器的场景。
- en: Important note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter14.02-calendar`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像 `chapter14.02-calendar`。
- en: Testing concurrent session control
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试并发会话控制
- en: 'As we did when verifying session fixation protection, we will need to access
    two web browsers by performing the following steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们验证会话固定保护时，我们需要通过执行以下步骤来访问两个网络浏览器：
- en: In Google Chrome, log in to the site as `user1@example.com/user1`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Google Chrome中，以 `user1@example.com/user1` 登录到该网站。
- en: Now, in Firefox, log in to the site as the same user.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在Firefox中，以相同用户登录到该网站。
- en: 'Finally, go back to Google Chrome and take any action. You will see a message
    indicating that your session has expired, as shown in the following screenshot:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到Google Chrome并采取任何操作。你将看到一个消息指示你的会话已过期，如下面的截图所示：
- en: '![Figure 14.6 – Testing concurrent session control](img/B21757_14_6.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 测试并发会话控制](img/B21757_14_6.jpg)'
- en: Figure 14.6 – Testing concurrent session control
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 测试并发会话控制
- en: If you were using this application and received this message, you’d probably
    be confused. This is because it’s obviously not a friendly method of being notified
    that only a single user can access the application at a time. However, it does
    illustrate that the session has been forcibly expired by the software.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用此应用程序并收到此消息，你可能会感到困惑。这是因为这显然不是一种友好的通知方式，表明一次只能有一个用户可以访问应用程序。然而，它确实说明了会话已被软件强制过期。
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Concurrent session control tends to be a very difficult concept for new Spring
    Security users to grasp. Many users try to implement it without truly understanding
    how it works and what the benefits are. If you’re trying to enable this powerful
    feature and it doesn’t seem to be working as you expect, make sure you have everything
    configured correctly, and then review the theoretical explanations in this section—hopefully,
    they will help you understand what may be wrong.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 并发会话控制对于新Spring Security用户来说往往是一个很难理解的概念。许多用户试图在不真正理解其工作原理和好处的情况下实现它。如果你正在尝试启用这个强大的功能，但它似乎没有按预期工作，请确保你已经正确配置了一切，然后回顾本节的理论解释——希望它们能帮助你理解可能出了什么问题。
- en: When a session expiration event occurs, we should probably redirect the user
    to the login page and provide them with a message to indicate what went wrong.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话过期事件发生时，我们可能需要将用户重定向到登录页面，并给他们提供一条消息来指示出了什么问题。
- en: Configuring expired session redirect
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置过期会话重定向
- en: 'Fortunately, there is a simple method for directing users to a friendly page
    (typically the login page) when they are flagged by concurrent session control—simply
    specify the `expired-url` attribute and set it to a valid page in your application.
    Update your `SecurityConfig.java` file as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种简单的方法可以将用户引导到友好的页面（通常是登录页面），当并发会话控制标记他们时——只需指定 `expired-url` 属性并将其设置为应用程序中的一个有效页面。按照以下方式更新你的
    `SecurityConfig.java` 文件：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the case of our application, this will redirect the user to the standard
    login form. We will then use the query parameter to display a friendly message,
    indicating that we determined that they had multiple active sessions and should
    log in again. Update your `login.xhtml` page to use this parameter to display
    our message:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，这会将用户重定向到标准登录表单。然后我们将使用查询参数来显示一条友好的消息，指出我们确定他们有多个活动会话，应该重新登录。更新你的
    `login.xhtml` 页面以使用此参数显示我们的消息：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Go ahead and give it a try by logging in as the user `admin1@example.com/admin1`
    using both Google Chrome and Firefox.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试登录为用户 `admin1@example.com/admin1`，使用 Google Chrome 和 Firefox 进行登录。
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter14.03-calendar`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像 `chapter14.03-calendar`。
- en: 'This time, you should see a login page with a custom error message:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你应该看到一个带有自定义错误信息的登录页面：
- en: '![Figure 14.7 – A concurrent session login page custom error message](img/B21757_14_7.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 一个并发会话登录页面的自定义错误信息](img/B21757_14_7.jpg)'
- en: Figure 14.7 – A concurrent session login page custom error message
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 一个并发会话登录页面的自定义错误信息
- en: After setting up redirection for expired sessions, we’ll delve into typical
    challenges associated with concurrency control.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置过期会话的重定向之后，我们将深入了解与并发控制相关的典型挑战。
- en: Common problems with concurrency control
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发控制中的常见问题
- en: There are a few common reasons that logging in with the same user does not trigger
    a logout event. The first occurs when using the custom `UserDetails` (as we did
    in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*) while
    the equals and `hashCode` methods are not properly implemented. This occurs because
    the default `SessionRegistry` implementation uses an in-memory map to store `UserDetails`.
    In order to resolve this, you must ensure that you have properly implemented the
    `hashCode` and equals methods.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个常见的原因会导致使用相同用户登录不会触发注销事件。第一个原因是在使用自定义的 `UserDetails`（正如我们在 [*第 3 章*](B21757_03.xhtml#_idTextAnchor068)，*自定义身份验证*）时，`equals`
    和 `hashCode` 方法没有正确实现。这是因为默认的 `SessionRegistry` 实现使用内存映射来存储 `UserDetails`。为了解决这个问题，你必须确保你已经正确实现了
    `hashCode` 和 `equals` 方法。
- en: The second problem occurs when restarting the application container while the
    user sessions are persisted to a disk. When the container has started back up,
    the users who were already logged in with a valid session are logged in. However,
    the in-memory map of `SessionRegistry` that is used to determine if the user is
    already logged in will be empty. This means that Spring Security will report that
    the user is not logged in, even though the user is. To solve this problem, either
    a custom `SessionRegistry` is required along with disabling session persistence
    within the container, or you must implement a container-specific way to ensure
    that the persisted sessions get populated into the in-memory map at startup.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题发生在用户会话持久化到磁盘时重启应用程序容器。当容器重新启动后，已经使用有效会话登录的用户将被登录。然而，用于确定用户是否已经登录的 `SessionRegistry`
    的内存映射将是空的。这意味着 Spring Security 将报告用户未登录，尽管用户实际上已经登录。为了解决这个问题，需要自定义 `SessionRegistry`
    并在容器内禁用会话持久化，或者你必须实现一种特定于容器的解决方案，以确保在启动时将持久化的会话填充到内存映射中。
- en: The last common reason we will cover is that concurrency control will not work
    in a clustered environment with the default `SessionRegistry` implementation.
    The default implementation uses an in-memory map. This means that if `user1` logs
    in to `application server A`, the fact that they are logged in will be associated
    with that server. Thus, if `user1` then authenticates to `Application Server B`,
    the previously associated authentication will be unknown to `Application` `Server
    B`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个常见原因是，在默认的 `SessionRegistry` 实现的集群环境中，并发控制可能不起作用。默认实现使用内存映射。这意味着如果
    `user1` 登录到 `应用服务器 A`，他们登录的事实将与该服务器相关联。因此，如果 `user1` 然后对 `应用服务器 B` 进行身份验证，之前关联的身份验证对
    `应用服务器 B` 将是未知的。
- en: Preventing authentication instead of forcing logout
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻止身份验证而不是强制注销
- en: 'Spring Security can also prevent a user from being able to log in to the application
    if the user already has a session. This means that instead of forcing the original
    user to log out, Spring Security will prevent the second user from being able
    to log in. The configuration changes can be seen as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 还可以防止用户在已有会话的情况下登录到应用程序。这意味着，而不是强制原始用户注销，Spring Security 将阻止第二个用户登录。配置更改如下所示：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make the updates and log in to the calendar application with Google Chrome.
    Now, attempt to log in to the calendar application with Firefox using the same
    user. You should see our custom error message from our `login.xhtml` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Google Chrome 更新并登录到日历应用程序。现在，尝试使用相同的用户以 Firefox 登录到日历应用程序。您应该看到我们来自 `login.xhtml`
    文件的自定义错误消息：
- en: '![Figure 14.8 – A custom error message preventing authentication for concurrent
    sessions](img/B21757_14_8.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.8 – 阻止并发会话身份验证的自定义错误消息](img/B21757_14_8.jpg)'
- en: Figure 14.8 – A custom error message preventing authentication for concurrent
    sessions
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 – 阻止并发会话身份验证的自定义错误消息
- en: Important note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter14.04-calendar`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应类似于 `chapter14.04-calendar`。
- en: There is a disadvantage to this approach that may not be apparent without some
    thought. Try closing Google Chrome without logging out and then opening it up
    again. Now, attempt to log in to the application again. You will observe that
    you are unable to log in. This is because when the browser is closed, the `JSESSIONID`
    cookie is deleted. However, the application is not aware of this, so the user
    is still considered authenticated. You can think of this as a kind of memory leak,
    since `HttpSession` still exists but there is no pointer to it (the `JSESSIONID`
    cookie is gone). It is not until the session times out that our user will be able
    to authenticate again. Thankfully, once the session times out, our `SessionEventPublisher`
    interface will remove the user from our `SessionRegistry` interface. What we can
    take away from this is that if a user forgets to log out and closes the browser,
    they will not be able to log in to the application until the session times out.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个缺点，如果不仔细思考可能不会很明显。尝试在不注销的情况下关闭 Google Chrome，然后再次打开它。现在，再次尝试登录到应用程序。您将观察到您无法登录。这是因为当浏览器关闭时，`JSESSIONID`
    cookie 被删除。然而，应用程序并不知道这一点，所以用户仍然被认为是经过身份验证的。您可以将这视为一种内存泄漏，因为 `HttpSession` 仍然存在，但没有指向它的指针（`JSESSIONID`
    cookie 已消失）。只有在会话超时后，我们的用户才能再次进行身份验证。幸运的是，一旦会话超时，我们的 `SessionEventPublisher` 接口将把用户从我们的
    `SessionRegistry` 接口中删除。我们可以从中吸取的教训是，如果用户忘记注销并关闭浏览器，他们将在会话超时之前无法登录到应用程序。
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Just as in [*Chapter 7*](B21757_07.xhtml#_idTextAnchor220), *Remember-**m**e
    Services*, this experiment may not work if the browser decides to remember a session
    even after the browser is closed. Typically, this will happen if a plugin or the
    browser is configured to restore sessions. In this event, you might want to delete
    the `JSESSIONID` cookie manually to simulate the browser being closed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在第 [*7章*](B21757_07.xhtml#_idTextAnchor220) 中提到的 *Remember-me 服务*，如果浏览器决定即使在关闭浏览器后也记住一个会话，这个实验可能无法工作。通常，如果插件或浏览器被配置为恢复会话，就会发生这种情况。在这种情况下，您可能需要手动删除
    `JSESSIONID` cookie 来模拟浏览器已关闭。
- en: Other benefits of concurrent session control
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发会话控制的其它好处
- en: 'Another benefit of concurrent session control is that `SessionRegistry` exists
    to track active (and, optionally, expired) sessions. This means that we can get
    runtime information about what user activity exists in our system (for authenticated
    users, at least) by performing the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 并发会话控制的另一个好处是存在 `SessionRegistry` 来跟踪活动（以及可选的已过期）会话。这意味着我们可以通过执行以下步骤来获取关于我们系统中存在哪些用户活动（至少对于认证用户）的运行时信息：
- en: 'You can even do this if you don’t want to enable concurrent session control.
    Simply set `maximumSessions` to `-1`, and session tracking will remain enabled,
    even though no maximum will be enforced. Instead, we will use the explicit bean
    configuration provided in the `SessionConfig.java` file of this chapter, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使您不想启用并发会话控制，您也可以这样做。只需将 `maximumSessions` 设置为 `-1`，会话跟踪将保持启用，尽管不会强制执行最大值。相反，我们将使用本章
    `SessionConfig.java` 文件中提供的显式bean配置，如下所示：
- en: '[PRE7]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have already added the import of the `SessionConfig.java` file to the `SecurityConfig.java`
    file. So, all that we need to do is reference the custom configuration in our
    `SecurityConfig.java` file. Go ahead and replace the current `sessionManagement`
    and `maximumSessions` configurations with the following code snippet:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经将 `SessionConfig.java` 文件的导入添加到 `SecurityConfig.java` 文件中。所以，我们只需要在我们的 `SecurityConfig.java`
    文件中引用自定义配置。现在，将当前的 `sessionManagement` 和 `maximumSessions` 配置替换为以下代码片段：
- en: '[PRE8]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Important note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter14.05-calendar`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像 `chapter14.05-calendar`。
- en: Now, our application will allow an unlimited number of authentications for the
    same user. However, we can use `SessionRegistry` to forcibly log out the users.
    Let’s see how we can use this information to enhance the security of our users.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序将允许同一用户进行无限数量的认证。然而，我们可以使用 `SessionRegistry` 来强制注销用户。让我们看看我们如何使用这些信息来增强我们用户的安全性。
- en: Displaying active sessions for a user
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示用户的活跃会话
- en: 'You’ve probably seen how many websites allow a user to view and forcibly log
    out sessions for their account. We can easily use this forcible logout functionality
    to do the same. We have already provided `UserSessionController`, which obtains
    the active sessions for the currently logged-in user. You can see the implementation
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经看到许多网站允许用户查看并强制注销其账户的会话。我们可以轻松地使用这个强制注销功能来做同样的事情。我们已经提供了 `UserSessionController`，它可以获取当前登录用户的活跃会话。您可以看到以下实现：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our sessions method will use a Spring `Authentication`. If we were not using
    a Spring MVC, we could also get the current `Authentication` from `SecurityContextHolder`,
    as discussed in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*.
    The principal is then used to obtain all the `SessionInformation` objects for
    the current user. The information is easily displayed by iterating over the `SessionInformation`
    objects in our `sessions.xhtml` file, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的会话方法将使用 Spring `Authentication`。如果我们没有使用 Spring MVC，我们也可以从 `SecurityContextHolder`
    获取当前的 `Authentication`，如第 [*3章*](B21757_03.xhtml#_idTextAnchor068) 中讨论的，*自定义认证*。然后使用主体来获取当前用户的全部
    `SessionInformation` 对象。信息可以通过在 `sessions.xhtml` 文件中迭代 `SessionInformation` 对象轻松显示，如下所示：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can now safely start the JBCP calendar application and log in to it using
    `user1@example.com/user1` in Google Chrome. Now, log in using Firefox and click
    on the `user1@example.com` link in the upper-right corner. You will then see both
    sessions listed on the display, as shown in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以安全地启动 JBCP 日历应用程序，并使用 `user1@example.com/user1` 在 Google Chrome 中登录。现在，使用
    Firefox 登录并点击右上角的 `user1@example.com` 链接。然后您将在显示上看到两个会话列表，如下面的截图所示：
- en: '![Figure 14.9 – A list of available sessions](img/B21757_14_9.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.9 – 可用会话列表](img/B21757_14_9.jpg)'
- en: Figure 14.9 – A list of available sessions
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 – 可用会话列表
- en: While in Firefox, click on the `deleteSession` method of `UserSessionsController`.
    This indicates that the session should be terminated. Now, navigate to any page
    within Google Chrome. You will see the custom message saying that the session
    has been forcibly terminated. While the message could use updating, we see that
    this is a nice feature for users to terminate other active sessions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Firefox 中，点击 `UserSessionsController` 的 `deleteSession` 方法。这表示应该终止会话。现在，导航到
    Google Chrome 中的任何页面。您将看到自定义消息，表示会话已被强制终止。虽然消息可能需要更新，但我们认为这是用户终止其他活动会话的一个很好的功能。
- en: Other possible uses include allowing an administrator to list and manage all
    active sessions, displaying the number of active users on the site, or even extending
    the information to include things like an IP address or location information.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能的用途包括允许管理员列出和管理所有活动会话，显示网站上的活动用户数量，甚至扩展信息以包括诸如IP地址或位置信息等内容。
- en: How Spring Security use the HttpSession method?
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Security如何使用HttpSession方法？
- en: 'We have already discussed how Spring Security uses `SecurityContextHolder`
    to determine the currently logged-in user. However, we have not explained how
    `SecurityContextHolder` gets automatically populated by Spring Security. The secret
    to this lies in the `o.s.s.web.context.SecurityContextPersistenceFilter` filter
    and the `o.s.s.web.context.SecurityContextRepository` interface. Let’s take a
    look at the following diagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Spring Security如何使用`SecurityContextHolder`来确定当前登录的用户。然而，我们还没有解释`SecurityContextHolder`是如何被Spring
    Security自动填充的。这个秘密在于`o.s.s.web.context.SecurityContextPersistenceFilter`过滤器以及`o.s.s.web.context.SecurityContextRepository`接口。让我们看一下以下图表：
- en: '![Figure 14.10 – Spring Security usage of the HttpSession](img/B21757_14_10.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图14.10 – Spring Security使用HttpSession](img/B21757_14_10.jpg)'
- en: Figure 14.10 – Spring Security usage of the HttpSession
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 – Spring Security使用HttpSession
- en: 'Here is an explanation for each step shown in the preceding diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面图表中每个步骤的解释：
- en: At the beginning of each web request, `SecurityContextPersistenceFilter` is
    responsible for obtaining the current `SecurityContext` implementation using `SecurityContextRepository`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个Web请求的开始，`SecurityContextPersistenceFilter`负责使用`SecurityContextRepository`获取当前的`SecurityContext`实现。
- en: Immediately afterward, `SecurityContextPersistenceFilter` sets `SecurityContext`
    on `SecurityContextHolder`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，`SecurityContextPersistenceFilter`将`SecurityContext`设置在`SecurityContextHolder`上。
- en: For the remainder of the web request, `SecurityContext` is available via `SecurityContextHolder`.
    For example, if a Spring MVC controller or `CalendarService` wanted to access
    `SecurityContext`, it could use `SecurityContextHolder` to access it.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在剩余的Web请求中，`SecurityContext`可以通过`SecurityContextHolder`访问。例如，如果Spring MVC控制器或`CalendarService`想要访问`SecurityContext`，它可以使用`SecurityContextHolder`来访问它。
- en: Then, at the end of each request, `SecurityContextPersistenceFilter` gets the
    `SecurityContext` from `SecurityContextHolder`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在每个请求结束时，`SecurityContextPersistenceFilter`从`SecurityContextHolder`获取`SecurityContext`。
- en: Immediately afterward, `SecurityContextPersistenceFilter` saves `SecurityContext`
    in `SecurityContextRepository`. This ensures that if `SecurityContext` is updated
    at any point during the web requests (that is, when a user creates a new account,
    as done in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*),
    `SecurityContext` is saved.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，`SecurityContextPersistenceFilter`将`SecurityContext`保存到`SecurityContextRepository`。这确保了如果在任何时刻（即在用户创建新账户时，如在第[*第3章*](B21757_03.xhtml#_idTextAnchor068)，*自定义身份验证*）更新了`SecurityContext`，`SecurityContext`将被保存。
- en: Lastly, `SecurityContextPersistenceFilter` clears `SecurityContextHolder`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`SecurityContextPersistenceFilter`清除`SecurityContextHolder`。
- en: 'The question that now arises: How is this related to `HttpSession`? This is
    all tied together by the default `SecurityContextRepository` implementation, which
    uses `HttpSession`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在出现的问题：这与`HttpSession`有什么关系？这一切都由默认的`SecurityContextRepository`实现联系在一起，该实现使用`HttpSession`。
- en: The HttpSessionSecurityContextRepository interface
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HttpSessionSecurityContextRepository接口
- en: The default implementation of `SecurityContextRepository`, `o.s.s.web.context.HttpSessionSecurityContextRepository`,
    uses `HttpSession` to retrieve and store the current `SecurityContext` implementation.
    There are no other `SecurityContextRepository` implementations provided out of
    the box. However, since the usage of `HttpSession` is abstracted behind the `SecurityContextRepository`
    interface, we could easily write our own implementation if we desired.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityContextRepository`的默认实现是`o.s.s.web.context.HttpSessionSecurityContextRepository`，它使用`HttpSession`来检索和存储当前的`SecurityContext`实现。没有提供其他`SecurityContextRepository`实现。然而，由于`HttpSession`的使用被`SecurityContextRepository`接口抽象化，如果我们愿意，可以轻松编写我们自己的实现。'
- en: Configuring how Spring Security uses HttpSession
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Spring Security如何使用HttpSession
- en: 'Spring Security has the ability to configure when the session is created by
    Spring Security. This can be done with the `http` element’s `create-session` attribute.
    A summary of the options can be seen in the following table:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security具有配置Spring Security何时创建会话的能力。这可以通过`http`元素的`create-session`属性来完成。以下表格中可以看到选项的摘要：
- en: '| **Attribute value** | **Description** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **属性值** | **描述** |'
- en: '| `ifRequired` | Spring Security will create a session only if one is required
    (the default value). |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `ifRequired` | Spring Security仅在需要时才会创建会话（默认值）。|'
- en: '| `always` | Spring Security will proactively create a session if one does
    not exist. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `always` | 如果不存在会话，Spring Security将主动创建会话。|'
- en: '| `never` | Spring Security will never create a session but will make use of
    one if the application does create it. This means that if there is a `HttpSession`
    method, `SecurityContext` will be persisted or retrieve from it. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `never` | Spring Security永远不会创建会话，但如果应用程序创建了它，则会使用它。这意味着如果有`HttpSession`方法，`SecurityContext`将被持久化或从中检索。|'
- en: '| `stateless` | Spring Security will not create a session and will ignore the
    session for obtaining a Spring `Authentication`. In such instances, `NullSecurityContextRepository`
    is used, which will always state that the current `SecurityContext` is `null`.
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `stateless` | Spring Security不会创建会话，并且将忽略会话以获取Spring `Authentication`。在这种情况下，使用`NullSecurityContextRepository`，它将始终声明当前`SecurityContext`为`null`。|'
- en: Table 14.2 – The session-fixation-protection options
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.2 – 会话固定保护选项
- en: In practice, controlling session creation can be more difficult than it first
    appears. This is because the attributes only control a subset of Spring Security’s
    usage of `HttpSession`. It does not apply to any other components, such as `HttpSession`
    method was created, we can add Spring Security’s `DebugFilter`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，控制会话创建可能比最初看起来更困难。这是因为属性仅控制Spring Security对`HttpSession`使用的一部分。它不适用于任何其他组件，例如，如果创建了`HttpSession`方法，我们可以添加Spring
    Security的`DebugFilter`。
- en: Debugging with Spring Security’s DebugFilter
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Spring Security的DebugFilter进行调试
- en: 'Let’s take a look at the following steps and learn about how to debug with
    `DebugFilter` of Spring Security:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤，并了解如何使用Spring Security的`DebugFilter`进行调试：
- en: 'Update your `SecurityConfig.java` file to have a session policy of `NEVER`.
    Also, add the `debug` flag to `true` on the `@EnableWebSecurity` annotation so
    that we can track when the session was created. The updates can be seen as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的`SecurityConfig.java`文件，使其会话策略为`NEVER`。同时，在`@EnableWebSecurity`注解上将`debug`标志设置为`true`，以便我们可以跟踪会话何时被创建。更新如下所示：
- en: '[PRE11]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you start up the application, you should see something similar to the
    following code written to standard output. If you have not already, ensure that
    you have logging enabled across all levels of the Spring Security debugger category:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您启动应用程序时，您应该看到类似以下代码被写入标准输出。如果您还没有这样做，请确保您已经在Spring Security调试器类别中启用了日志记录：
- en: '[PRE12]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, clear out your cookies (this can be done in Firefox with *Shift + Ctrl
    + Delete*), start up the application, and navigate directly to `http://localhost:8080`.
    When we look at the cookies, as we did earlier in the chapter, we can see that
    `JSESSIONID` is created even though we stated that Spring Security should never
    create `HttpSession`. Look at the logs again, and you will see a call stack of
    the code that created `HttpSession` as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，清除您的cookies（这可以在Firefox中使用*Shift + Ctrl + Delete*完成），启动应用程序，并直接导航到`http://localhost:8080`。当我们查看cookies时，就像我们在本章前面所做的那样，我们可以看到即使我们声明Spring
    Security永远不会创建`HttpSession`，`JSESSIONID`仍然被创建。再次查看日志，您将看到创建`HttpSession`的代码调用堆栈如下：
- en: '[PRE13]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are several other uses for `DebugFilter`, which we encourage you to explore
    on your own, for example, determining when a request will match a particular URL,
    which Spring Security filters are being invoked, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`DebugFilter`还有其他一些用途，我们鼓励您自己探索，例如确定何时一个请求将匹配特定的URL，Spring Security正在调用哪些过滤器，等等。'
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, you should be familiar with how Spring Security
    manages sessions and protects against session fixation attacks. We also know how
    to use Spring Security’s concurrency control to prevent the same user from being
    authenticated multiple times.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，您应该熟悉Spring Security如何管理会话并防止会话固定攻击。我们还知道如何使用Spring Security的并发控制来防止同一用户被多次认证。
- en: We explored the utilization of concurrency control to allow a user to terminate
    sessions associated with their account. Also, we saw how to configure Spring Security’s
    creation of sessions. We also covered how to use Spring Security’s `DebugFilter`
    filter to troubleshoot issues related to Spring.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了利用并发控制来允许用户终止与其账户关联的会话的方法。此外，我们还了解了如何配置Spring Security创建会话。我们还介绍了如何使用Spring
    Security的`DebugFilter`过滤器来排查与Spring相关的问题。
- en: We also learned about security, including determining when a `HttpSession` method
    was created and the cause of it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了关于安全性的知识，包括确定何时创建了一个`HttpSession`方法及其原因。
- en: This concludes our discussion about Spring Security’s session management. In
    the next chapter, we will discuss some specifics about integrating Spring Security
    with other frameworks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Spring Security会话管理的讨论。在下一章中，我们将讨论一些关于将Spring Security与其他框架集成的具体细节。
