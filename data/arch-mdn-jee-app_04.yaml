- en: Lightweight Java EE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级Java EE
- en: Lightweight Java EE. Is that even possible? In the past, J2EE applications and
    especially application servers have been considered a heavyweight and cumbersome
    technology. And up to some degree deservedly so. APIs were quite unwieldy to use.
    There was a lot of XML configuration required, which eventually led to the use
    of **XDoclet**, a tool used to generate XML based on meta information put into
    JavaDoc comments. Application servers were also cumbersome to work with, especially
    with regard to startup and deployment times.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级Java EE。这甚至可能吗？在过去，J2EE应用以及特别是应用服务器被认为是一种重量级且繁琐的技术。在一定程度上，这是有道理的。API的使用相当不便。需要大量的XML配置，这最终导致了**XDoclet**的使用，这是一个基于放入JavaDoc注释中的元信息生成XML的工具。应用服务器的工作也相当繁琐，尤其是在启动和部署时间方面。
- en: However, since the name change to Java EE and especially since version 6, these
    assumptions are not true anymore. Annotations were introduced, which originally
    emerged from the XDoclet-motivated JavaDoc tags. And a lot has happened to improve
    the productivity and developer experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自从Java EE名称变更以及特别是从版本6开始，这些假设已经不再成立。引入了注解，这些注解最初源于XDoclet驱动的JavaDoc标签。而且已经发生了许多事情来提高生产力和开发者体验。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What makes a technology lightweight
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么使技术轻量级？
- en: Why Java EE standards help reducing work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Java EE标准有助于减少工作量
- en: How to choose project dependencies and archive formats
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择项目依赖和归档格式
- en: The benefits of zero-dependency enterprise applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零依赖企业应用的优势
- en: Modern Java EE application servers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代Java EE应用服务器
- en: The *one application per application server* approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个应用服务器一个应用的方案
- en: Lightweight enterprise technology
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级企业技术
- en: What makes a technology *lightweight*? And how lightweight, productive and relevant
    is Java EE in the age of containers and cloud?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 什么使技术*轻量级*？在容器和云的时代，Java EE的轻量级、生产力和相关性如何？
- en: One of the most important aspects of a lightweight technology is the productivity
    and effectiveness it enables. The time the development team spends is precious
    and expensive and the less time spent on overhead the better. This includes developing
    glue code, building projects, writing and executing tests, and deploying software,
    on both local and remote environments. Ideally, engineers can spend as much time
    as possible on implementing revenue-generating business functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级技术的最重要的方面之一是它所提供的生产力和效率。开发团队所花费的时间是宝贵的且昂贵的，因此花费在冗余上的时间越少越好。这包括开发粘合代码、构建项目、编写和执行测试，以及在本地和远程环境中部署软件。理想情况下，工程师可以尽可能多的时间用于实现盈利的业务功能。
- en: A technology should therefore not add much overhead on top of the business use
    cases. Technical cross-cutting concerns are certainly necessary but should be
    kept to a minimum. In the previous chapter, we have seen how Java EE enables developers
    to implement business use cases in a productive way. Project artifact builds and
    deployments should in the same way aim to minimize the required time and effort.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，技术不应该在业务用例之上增加太多冗余。技术横切关注点当然有必要，但应尽量保持最小化。在前一章中，我们看到了Java EE如何使开发者以高效的方式实现业务用例。项目工件构建和部署也应同样旨在最小化所需的时间和精力。
- en: This and the following chapter will show how Java EE supports crafting productive
    development workflows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章将展示Java EE如何支持构建高效的开发工作流程。
- en: Why Java EE standards?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要Java EE标准？
- en: One of the principles of Java EE is to provide a productive enterprise API.
    As seen in the *Concepts and design principles of modern Java EE* section in the
    previous chapter, one of the biggest advantages is the ability to integrate different
    standards without developer-side configuration required. The Java EE umbrella
    requires the different standards to work well together. The enterprise container
    has to meet this requirement. The software engineers only develop against the
    APIs and let the application server do the *hard integration work*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE的一个原则是提供高效的企业API。如前一章中“现代Java EE的概念和设计原则”部分所示，最大的优势之一是能够集成不同的标准而无需开发者进行配置。Java
    EE的伞形架构要求不同的标准能够良好地协同工作。企业容器必须满足这一要求。软件工程师只需针对API进行开发，让应用服务器完成*困难的集成工作*。
- en: Following the convention over configuration approach, using different, integrated
    standards that are part of the umbrella specification doesn't require initial
    configuration. As seen in various examples previously, the technologies that have
    emerged from different standards within Java EE work well with each other. We
    have seen examples such as using JSON-B to automatically map objects to JSON in
    JAX-RS resources; integrating Bean Validation into JAX-RS and therefore HTTP responses
    by introducing a single annotation; injecting managed beans into instances defined
    by other standards, such as Bean Validation validators or JSON-B type adapters;
    or managing technical transactions that span JPA database operations in EJBs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定优于配置的方法，使用伞形规范的一部分的不同、集成标准不需要初始配置。如前所述的各个示例所示，Java EE内部不同标准中产生的技术可以很好地协同工作。我们已经看到了一些示例，例如使用JSON-B在JAX-RS资源中自动将对象映射到JSON；通过引入单个注解将Bean
    Validation集成到JAX-RS和HTTP响应中；将管理Bean注入由其他标准定义的实例中，例如Bean Validation验证器或JSON-B类型适配器；或者在EJB中管理跨越JPA数据库操作的跨技术事务。
- en: What is the alternative to using an umbrella standard that embraces various
    reusable technologies? Well, to introduce vendor-specific frameworks with third-party
    dependencies that need to be wired together with manual developer work involved.
    One of the biggest advantages of the Java EE API is having the whole variety of
    technology right at the developer's fingertips; providing productive integration
    and saving developers time for focusing on business use cases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个包含各种可重用技术的伞形标准的替代方案是什么？嗯，引入需要与第三方依赖项手动连接的特定供应商的框架。Java EE API的最大优点之一是开发者可以直接使用整个技术种类；提供高效集成并节省开发者时间，以便他们可以专注于业务用例。
- en: Convention over configuration
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约定优于配置
- en: Pursuing the idea of convention over configuration, further, enterprise applications
    can be developed without any initial configuration required. The APIs provide
    default behavior that matches the majority of use cases. Engineer are only required
    to put extra effort in if that behavior is not sufficient.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 追求约定优于配置的理念，进一步来说，企业应用可以在没有任何初始配置的情况下进行开发。API提供了符合大多数用例的默认行为。工程师只有在默认行为不足时才需要付出额外的努力。
- en: This implies that in today's world, enterprise projects can be set up with minimal
    configuration involved. The days of extensive XML configuration are over. Especially,
    applications that don't ship web frontend technology can keep XML files to a minimum.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在当今世界，企业项目可以以最小的配置来设置。大量XML配置的日子已经过去了。特别是，不提供Web前端技术应用可以保持XML文件数量最少。
- en: Let's start with a simple example of an application that offers REST endpoints,
    and accesses databases and external systems. REST endpoints are integrated by
    JAX-RS that internally uses servlets to handle requests. Servlets traditionally
    are configured using the `web.xml` deployment descriptor file residing under `WEB-INF`.
    However, JAX-RS ships a shortcut by sub-classing `Application`, annotated with
    `@ApplicationPath`, as shown in the previous chapter. This registers a JAX-RS
    application servlet for the provided path. At startup time, the project will be
    scanned for JAX-RS related classes such as resources or providers. After the application
    has been started, the REST endpoints are available to handle requests even without
    a provided `web.xml` file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从提供一个REST端点的简单应用示例开始，该应用访问数据库和外部系统。REST端点通过JAX-RS集成，JAX-RS内部使用servlet来处理请求。Servlet传统上是通过位于`WEB-INF`下的`web.xml`部署描述符文件进行配置的。然而，JAX-RS通过在上一章中展示的`Application`子类和`@ApplicationPath`注解提供了一个快捷方式。这为提供的路径注册了一个JAX-RS应用servlet。在启动时，项目将扫描与JAX-RS相关的类，如资源或提供者。在应用启动后，即使没有提供`web.xml`文件，REST端点也可以处理请求。
- en: Managed beans are traditionally configured using a `beans.xml` configuration
    file. In web archive applications this file also resides under `WEB-INF`. Nowadays,
    it is primarily used to specify the bean discovery mode, that is, which CDI beans
    are considered per default. It's advisable to configure the `bean-discovery-mode`
    of `all`, not just `annotated` beans. The `beans.xml` file can override CDI bean
    composition of all sorts, such as interceptors, alternatives, decorators, and
    so on. As the CDI specification states, for the simplest example it's sufficient
    for this file to be empty.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Bean传统上使用`beans.xml`配置文件进行配置。在Web归档应用程序中，此文件也位于`WEB-INF`下。如今，它主要用于指定Bean发现模式，即默认情况下考虑哪些CDI
    Bean。建议配置`bean-discovery-mode`为`all`，而不仅仅是`annotated` Bean。`beans.xml`文件可以覆盖所有类型的CDI
    Bean组合，如拦截器、替代方案、装饰器等。根据CDI规范，对于最简单的示例，此文件为空就足够了。
- en: The JPA persistence units are configured using the `persistence.xml` file under
    `META-INF`. As previously shown, it comprises the datasource definitions that
    are used in the the application. Mapping JPA entities to database tables is configured
    via annotations in domain model classes. This approach keeps the concerns in a
    single place and minimizes XML usage.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JPA持久化单元是通过`META-INF`下的`persistence.xml`文件配置的。如前所述，它包含应用程序中使用的数据源定义。通过在领域模型类中添加注解来配置将JPA实体映射到数据库表。这种方法将关注点保持在单一位置，并最小化了XML的使用。
- en: For the majority of enterprise applications that don't include a web frontend,
    this amount of configuration is already sufficient. Frontend technologies such
    as JSF are usually configured via `web.xml` and `faces-config.xml` or if required,
    via additional, implementation-specific files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数不包含Web前端的企业应用程序，这种配置量已经足够。前端技术，如JSF，通常通过`web.xml`和`faces-config.xml`配置，或者在需要时通过额外的、特定于实现的文件配置。
- en: In the past, vendor-specific configuration files, such as `jboss-web.xml` or
    `glassfish-web.xml`, were quite common. In a modern Java EE world, the majority
    of applications don't require these workarounds anymore. In order to allow portability,
    it is highly advisable to implement features using standard APIs first and only
    if this is not possible within reasonable effort to go with vendor-specific features.
    Experience with legacy projects showed that this approach leads to better manageable
    situations. Unlike vendor-specific features, Java EE standards are guaranteed
    to continue to work in the future.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，供应商特定的配置文件，如`jboss-web.xml`或`glassfish-web.xml`，相当常见。在现代Java EE世界中，大多数应用程序不再需要这些解决方案。为了允许可移植性，强烈建议首先使用标准API实现功能，只有在合理努力内无法实现时才使用供应商特定的功能。对遗留项目的经验表明，这种方法会导致更好的可管理情况。与供应商特定的功能不同，Java
    EE标准保证在未来继续工作。
- en: At application startup, the container scans the available classes for annotations
    and known types. Managed beans, resources, entities, extensions, and cross-cutting
    concerns are discovered and configured appropriately. This mechanism is a great
    benefit for developers. They don't need to explicitly specify required classes
    in configuration files but can rely on the server's discovery; inversion of control
    at its best.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用启动时，容器会扫描可用的类以查找注解和已知类型。管理Bean、资源、实体、扩展和横切关注点会被发现并适当配置。这种机制对开发者来说是一个巨大的好处。他们不需要在配置文件中显式指定所需的类，而可以依赖服务器的发现；这是控制反转的最佳实践。
- en: Dependency management of Java EE projects
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE项目的依赖管理
- en: The dependency management of an enterprise project targets the dependencies
    that are added on top of the JDK. This includes dependencies that are required
    during compilation, tests, and at runtime. In a Java enterprise project, the Java
    EE API is required with *provided* dependency scope. Since the APIs are available
    on the application server, they don't have to be included in the packaged archive.
    The provided Java EE API therefore doesn't have an implication on the package
    size.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 企业项目的依赖管理针对的是在JDK之上添加的依赖。这包括编译、测试和运行时所需的依赖。在Java企业项目中，需要使用带有*provided*依赖范围的Java
    EE API。由于API在应用服务器上可用，因此不需要包含在打包的归档文件中。因此，提供的Java EE API对包大小没有影响。
- en: Real-world enterprise projects usually include more dependencies than this.
    Typical examples for third-party dependencies include logging frameworks such
    as **Slf4j**, **Log4j**, or **Logback**, JSON mapping frameworks such as **Jackson**,
    or general purpose libraries such as **Apache Commons**. There are several issues
    with these dependencies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的企业项目通常包含比这更多的依赖项。第三方依赖项的典型例子包括日志框架，如**Slf4j**、**Log4j**或**Logback**，JSON映射框架如**Jackson**，或通用库如**Apache
    Commons**。这些依赖项存在一些问题。
- en: First of all, third-party dependencies are usually not provided, thus increasing
    the size of the artifact. This doesn't sound that harmful, but has some implications
    that we'll see later. The more dependencies are added to the resulting artifact,
    the longer the build will take. Build systems need to copy potentially big dependencies
    into the artifact each and every time the project is built. As we will see in
    [Chapter 6](599c6821-8971-4489-931c-9e11b5e23afd.xhtml), *Application Development
    Workflows*, project builds need to be as fast as possible. Every dependency added
    to the package increases the turnaround time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，第三方依赖项通常不提供，这会增加构建物的大小。这听起来可能不是那么有害，但有一些影响我们将在后面看到。添加到最终构建物中的依赖项越多，构建所需的时间就越长。构建系统需要在每次构建项目时将可能很大的依赖项复制到构建物中。正如我们将在[第6章](599c6821-8971-4489-931c-9e11b5e23afd.xhtml)“应用开发工作流程”中看到的，项目构建需要尽可能快。添加到包中的每个依赖项都会增加周转时间。
- en: Potential collisions of dependencies and their versions represent an even bigger
    challenge. This includes both packaged dependencies and transitive dependencies
    as well as libraries that already exist on the application server. For example,
    logging frameworks are often already present in the container's classpath, potentially
    in a different version. Different versions being used introduce potential issues
    with the aggregate of libraries being there. Experience shows that implicit dependencies
    that are added transitively represent the biggest challenge in this regard.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项及其版本的潜在冲突代表了一个更大的挑战。这包括打包依赖项、传递依赖项以及已经存在于应用服务器上的库。例如，日志框架通常已经存在于容器的类路径中，可能版本不同。使用不同版本引入了潜在的问题，即库的聚合。经验表明，通过传递添加的隐式依赖项是这方面的最大挑战。
- en: Aside from technical reasons, there are some other aspects to consider before
    lightheadedly introducing dependencies to a software project. Dependency licenses,
    for example, can become an issue when developing a software product that is shipped
    to customers. It's not only required that the company is permitted to use certain
    dependencies, but also that involved licenses are compatible to each other, when
    shipped in a software package. The simplest way to meet licensing criteria is
    to avoid dependencies, at least, if they serve no business purpose. Engineers
    should make similar consideration in regard to security, especially for software
    being developed for sectors with high demands in security.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了技术原因之外，在轻率地将依赖项引入软件项目之前，还有一些其他方面需要考虑。例如，依赖项许可可能会成为开发向客户发货的软件产品时的问题。不仅公司被允许使用某些依赖项，而且涉及的许可在软件包中也需要相互兼容。满足许可标准的最简单方法是不添加依赖项，至少如果它们没有商业用途的话。工程师在考虑安全方面也应做出类似的考虑，特别是对于为对安全性有高度要求的行业开发的软件。
- en: I was once involved in a *firefighter* job responsible for updating versions
    of used frameworks in an enterprise project. The project included a lot of build
    dependencies. With all its included third-party dependencies, the project runtime
    eventually contained *all* known logging frameworks. The same was true for JSON
    mapping frameworks, which introduced a lot of version conflicts and runtime dependency
    mismatches. This was before the advent of JSON-B and JSON-P. We spent most of
    the time configuring the project build, untangling and excluding the transitive
    dependencies from the project artifact. This is a typical issue when using third-party
    libraries. The price for saving project code is to spend time and effort configuring
    the project build and potentially untangling dependencies, especially if they
    introduce a lot of transitive functionality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经参与过一个*消防员*工作，负责更新企业项目的使用框架的版本。该项目包含大量的构建依赖项。随着所有包含的第三方依赖项，项目运行时最终包含了*所有*已知的日志框架。对于JSON映射框架也是如此，它们引入了许多版本冲突和运行时依赖项不匹配。这还是在JSON-B和JSON-P出现之前。我们大部分时间都在配置项目构建，解开并排除项目工件中的传递依赖项。这是使用第三方库时的典型问题。节省项目代码的代价是花费时间和精力配置项目构建，并可能解开依赖项，尤其是如果它们引入了大量传递功能的话。
- en: By managing build dependencies, engineers focus on aspects that are insignificant
    to the business use cases. The question to be asked is whether it pays off to
    save some lines of code, when at the same time we introduce dependencies. Experience
    shows that the trade-off of duplication versus lightweightness, such as in dependency-free
    projects, is too often in favor of avoiding duplication. A prime example for this
    are projects that introduce the whole Apache Commons library to use a functionality
    that could have been realized with a few lines of code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过管理构建依赖项，工程师们专注于对业务用例无关紧要的方面。需要问的问题是，当我们引入依赖项的同时，节省一些代码行是否值得。经验表明，在避免重复与轻量级之间的权衡，例如在无依赖项的项目中，往往更倾向于避免重复。一个典型的例子是，为了使用可以用几行代码实现的功能，项目引入了整个Apache
    Commons库。
- en: Whereas it's good practice to not reinvent the wheel by developing own versions
    of functionality that could be reused, the consequences also have to be considered.
    Experience shows that introduced dependencies are quite often neglected and only
    utilized marginally. Most of them serve little business value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不重复造轮子，开发可重用的功能版本是良好的实践，但也要考虑其后果。经验表明，引入的依赖项往往被忽视，并且只被有限地利用。其中大部分几乎没有业务价值。
- en: When engineers inspect code quality, for example using code analysis tools,
    what also should be considered is the ratio of dependencies and project code that
    target business use cases versus *plumbing*. There is a straightforward method
    that can be applied for dependencies. Before a third-party dependency is introduced,
    consider a few questions. Does adding the functionality add value to the business?
    How much project code does it save? How big is the impact on the resulting artifact?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当工程师检查代码质量时，例如使用代码分析工具，还应考虑针对业务用例的依赖项与项目代码的比例，以及*管道*。对于依赖项有一个简单的方法可以应用。在引入第三方依赖项之前，考虑几个问题。添加的功能是否增加了业务价值？它节省了多少项目代码？对最终工件的影响有多大？
- en: For example, imagine part of the use case of the car manufacture application
    is to communicate with specific factory software using a proprietary Java API.
    Obviously, the communication is crucial to fulfill the business purpose and it
    makes a lot of sense to include this dependency in the project. On the contrary,
    adding a different logging framework hardly improves the application's business
    value. Furthermore, Chapter 9, *Monitoring, Performance, and Logging* will discuss
    the issues with traditional logging.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设汽车制造应用程序的一部分用例是使用专有的Java API与特定工厂软件进行通信。显然，这种通信对于实现业务目标至关重要，将这个依赖项包含在项目中是非常有意义的。相反，添加不同的日志框架几乎不会提高应用程序的业务价值。此外，第9章*监控、性能和日志*将讨论传统日志的问题。
- en: However, in order not to unnecessarily increase the build size, crucial dependencies
    can be installed on the application server and be declared as provided in the
    project's build.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了避免不必要地增加构建大小，关键依赖项可以安装在应用程序服务器上，并在项目的构建中声明为提供。
- en: In the first chapter, we saw the difficulties with shared business dependencies
    such as shared models. Ideally, applications are as self-sufficient as possible.
    Chapter 8, *Microservices and System Architecture* will deep-dive into self-contained
    systems and the motivation for architectures that share nothing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们看到了共享业务依赖（如共享模型）的困难。理想情况下，应用程序尽可能自给自足。第 8 章 *微服务和系统架构* 将深入探讨自包含系统和共享无架构的动机。
- en: In regard to technical dependencies, however, the Java EE API already includes
    the technology that the majority of enterprise applications need. Ideally, engineers
    develop zero-dependency Java EE applications that are packaged as thin deployment
    artifacts containing the application-relevant classes only. If some use cases
    require third-party dependencies, they can be installed in the container. The
    goal is to have a light footprint of deployment artifacts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于技术依赖，然而，Java EE API 已经包含了大多数企业应用所需的技术。理想情况下，工程师开发零依赖的 Java EE 应用程序，这些应用程序被打包成仅包含相关类的薄部署工件。如果某些用例需要第三方依赖，它们可以安装在容器中。目标是使部署工件具有轻量级的足迹。
- en: For production code, this means that only provided dependencies are included,
    ideally, only the Java EE API. Test dependencies, however, are a different story;
    software tests require some additional technology. Chapter 7, *Testing* covers
    the required dependencies for the test scope.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产代码，这意味着只包含提供的依赖项，理想情况下，只包含 Java EE API。然而，测试依赖项却是一个不同的情况；软件测试需要一些额外的技术。第
    7 章 *测试* 涵盖了测试范围所需的依赖项。
- en: Lightweight way of packaging applications
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级打包应用程序的方式
- en: The approach of zero-dependency applications simplifies many project build concerns.
    There is no need to manage third-party dependencies with regard to versions or
    collisions since there aren't any included.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 零依赖应用程序的方法简化了许多项目构建的担忧。由于没有包含任何依赖项，因此无需管理第三方依赖项的版本或冲突。
- en: What other aspects does this approach simplify? Project builds, no matter whether
    Gradle or Maven are being used, always show the best performance when nothing
    needs to be added to the artifact. The resulting size of the packages directly
    impacts the build time. In the case of zero-dependency applications, only the
    compiled classes are included, that is, only the actual business logic. Therefore,
    the resulting build times are as minimal as they will get. All build time is spent
    on compiling the project's classes, running the test cases, and packaging the
    classes into a thin deployment artifact. Building this approach should happen
    in seconds. Yes, seconds. As a general rule, every project build that takes more
    than 10 seconds should be reconsidered.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简化了哪些其他方面？无论使用 Gradle 还是 Maven，项目构建在不需要添加任何内容到工件时总是表现出最佳性能。包的大小直接影响构建时间。在零依赖的应用程序的情况下，只包含编译后的类，即只有实际的业务逻辑。因此，生成的构建时间是最小的。所有构建时间都用于编译项目的类、运行测试用例以及将类打包成薄部署工件。采用这种方法构建应该只需几秒钟。是的，几秒钟。一般来说，任何超过
    10 秒的项目构建都应该重新考虑。
- en: This rule, of course, puts certain pressure on project builds. It naturally
    requires to avoid including any larger dependency or implementation; these should
    be provided by the application server. Test run times are usually another aspect
    that prevents fast builds. Chapter 7, *Testing*, will shed light on how to develop
    tests in an effective way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这条规则对项目构建施加了一定的压力。它自然要求避免包含任何较大的依赖或实现；这些应由应用程序服务器提供。测试运行时间通常是另一个防止快速构建的方面。第
    7 章 *测试* 将阐明如何以有效的方式开发测试。
- en: Fast builds are one benefit of crafting zero-dependency applications. Another
    implication is fast artifact transmission. Built artifacts, such as WAR or JAR
    files, are usually kept in an artifact repository for later use, for example,
    **Sonatype Nexus** or **JFrog Artifactory**. Transmitting these artifacts over
    the wire greatly speeds up if only a few kilobytes of data are involved. This
    applies to all sorts of artifact deployment. No matter where the built archives
    are shipped to, smaller footprints always pay off especially when workflows are
    executed often, as it is the case for Continuous Delivery.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 快速构建是创建零依赖应用程序的一个好处。另一个影响是快速工件传输。构建的工件，如WAR或JAR文件，通常保存在工件存储库中，以供以后使用，例如**Sonatype
    Nexus**或**JFrog Artifactory**。如果只涉及少量数据，通过网络传输这些工件会大大加快速度。这适用于所有类型的工件部署。无论构建的存档被发送到何处，较小的体积总是有回报的，尤其是在工作流程经常执行的情况下，例如持续交付。
- en: The goal of reconsidering practices and stripping everything which does not
    provide value also targets the way of packaging applications. Traditionally, enterprise
    applications have been shipped as EAR files. The structure of these included a
    web archive, a WAR file, and one or more enterprise JARs. Enterprise JAR archives
    contained the business logic, usually implemented in EJBs. The web archive contained
    the web services and frontend technology communicating with the business logic
    using local or remote EJBs. However, this separation is not necessary, as all
    components are shipped on a single server instance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视实践并剥离所有不提供价值的部分，其目标也针对了应用程序的打包方式。传统上，企业应用程序是以EAR文件的形式交付的。这些文件的结构包括一个Web存档、一个WAR文件和一个或多个企业JAR文件。企业JAR存档包含了业务逻辑，通常是用EJB实现的。Web存档包含了与业务逻辑通过本地或远程EJB进行通信的Web服务和前端技术。然而，这种分离并不是必要的，因为所有组件都部署在单个服务器实例上。
- en: Packaging several technical concerns in several sub-archives is not required
    anymore. All business logic as well as web services and cross-cutting concerns
    are packaged into a single WAR file. This greatly simplifies the project setup
    as well as the build process. Applications don't have to be zipped in multiple
    hierarchies just to be unzipped on a single server instance again. WAR files containing
    the required business code deployed in a container is the best implementation
    of thin artifacts. Because of this reason, deploying thin WAR files is faster
    than the corresponding EAR files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个子存档中打包几个技术问题不再是必需的。所有业务逻辑以及Web服务和横切关注点都打包到一个单一的WAR文件中。这极大地简化了项目设置以及构建过程。应用程序不需要在多个层次结构中压缩，只是为了在单个服务器实例上再次解压缩。包含在容器中部署的所需业务代码的WAR文件是薄型工件的最佳实现。正因为如此，部署薄型WAR文件比相应的EAR文件要快。
- en: 'The following demonstrates the contents of a thin web application artifact
    with typical components:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了一个典型的薄型Web应用程序工件的内容：
- en: '![](img/fb372acc-bd04-436a-9058-306fd1046ebe.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb372acc-bd04-436a-9058-306fd1046ebe.png)'
- en: The deployment artifact only contains classes that are required to implement
    the business use case, no technology-specific implementation, and only minimal
    configuration. Especially, there are no library JAR files included.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 部署工件只包含实现业务用例所需的类，没有特定技术的实现，只有最小配置。特别是，不包括库JAR文件。
- en: The architecture of the Java EE platform encourages lightweight artifacts. This
    is due to the platform separating the API from the implementations. Developers
    only program against the API; the application server implements the API. This
    makes it possible to ship only the business logic, which includes certain aspects
    in lightweight artifacts. Besides the obvious benefits of avoiding dependency
    collisions and building vendor-independent solutions, this approach also enables
    fast deployments. The less content the artifacts include, the less unpacking needs
    to be done on the container side. Therefore, it's highly advisable to package
    enterprise applications into a single WAR file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE平台的架构鼓励轻量级工件。这是因为平台将API与实现分离。开发者只针对API编程；应用程序服务器实现API。这使得只发送业务逻辑成为可能，这些业务逻辑包括轻量级工件中的某些方面。除了避免依赖冲突和构建供应商独立解决方案的明显好处外，这种方法还使快速部署成为可能。工件包含的内容越少，容器端需要解包的内容就越少。因此，将企业应用程序打包成一个单一的WAR文件是非常推荐的。
- en: In the last year, we have seen more and more interest in shipping enterprise
    applications as *fat* JARs, that is, shipping the application together with the
    implementation. The approaches of fat deployment artifacts have usually been used
    in enterprise frameworks such as the Spring Framework. The motivation behind these
    approaches is that the versions of the required dependencies and frameworks are
    explicitly specified and shipped together with the business logic. Fat deployment
    artifacts can be created as fat WARs, which are deployed on a servlet container,
    or fat JARs started as standalone, executable JARs. A Java EE application packaged
    as fat JAR therefore ships the enterprise container together with the application
    in an executable JAR. However, as stated before, the build, shipping, and deployment
    times increase greatly if third-party dependencies are added to the artifact.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的一年里，我们看到了越来越多的兴趣在于将企业应用程序作为*胖*JAR进行打包，也就是说，将应用程序与其实现一起打包。胖部署工件的方法通常在企业框架，如Spring框架中使用。这些方法的背后动机是，所需的依赖项和框架的版本被明确指定，并随业务逻辑一起打包。胖部署工件可以创建为胖WAR，部署在servlet容器上，或者作为独立的、可执行的JAR启动。因此，打包为胖JAR的Java
    EE应用程序将企业容器与应用程序一起打包在一个可执行的JAR中。然而，正如之前所述，如果将第三方依赖项添加到工件中，构建、打包和部署时间将大大增加。
- en: Experience shows that explicitly shipping the enterprise implementation together
    with the application is in most cases not technically but business-politically
    motivated. Operational environments within companies that are inflexible regarding
    application server and Java installations, especially regarding version upgrades,
    in some cases force developers to find workarounds. Enterprise applications that
    are built using newer technology cannot be deployed on older, existing server
    installations. Sometimes, the business-politically easier solution is to ignore
    the existing installations altogether and to directly execute the standalone JAR,
    which only requires a certain Java version. However, whereas these solutions are
    certainly justified, the technically more reasonable solutions would be to package
    applications into thin deployment artifacts. Interestingly, as we will see in
    the next chapter, shipping software in Linux containers holds the advantages of
    both approaches.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 经验表明，将企业实现与应用程序一起明确打包，在大多数情况下不是技术上的原因，而是业务政治上的原因。公司内部对应用程序服务器和Java安装缺乏灵活性的运营环境，特别是在版本升级方面，有时迫使开发者寻找解决方案。使用较新技术构建的企业应用程序不能部署在较旧的现有服务器安装上。有时，业务政治上更容易的解决方案是完全忽略现有安装，并直接执行独立的JAR，这只需要特定的Java版本。然而，虽然这些解决方案无疑是合理的，但技术上更合理的解决方案是将应用程序打包到瘦部署工件中。有趣的是，正如我们将在下一章中看到的，在Linux容器中打包软件具有两种方法的优势。
- en: There is another interesting approach that enables to ship the whole application
    as an executable package and to keep fast workflows of thin deployments. Several
    application server vendors provide the solution to ship a custom application container
    as executable JAR that deploys the thin application as additional argument at
    startup time. By doing so, the whole package of both artifacts includes the business
    logic as well as the implementation and is started as a standalone application.
    The application is still separated from its runtime and packaged as thin artifact,
    as a so-called *hollow* JAR or WAR file. This approach especially makes sense
    if the addressed flexibility is required without the use of Linux containers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有趣的方法允许将整个应用程序作为一个可执行的包进行打包，并保持快速的工作流程进行瘦部署。几个应用程序服务器供应商提供将自定义应用程序容器作为可执行的JAR进行打包的解决方案，在启动时将瘦应用程序作为附加参数部署。通过这样做，整个包包括业务逻辑和实现，并作为一个独立的应用程序启动。应用程序仍然与其运行时分离，并打包为所谓的*空*JAR或WAR文件。这种方法在没有使用Linux容器的情况下，如果需要这种灵活性，尤其有意义。
- en: As a conclusion, it is highly advisable to build thin deployment artifacts,
    ideally thin WAR files. If this approach does not work for business-political
    reasons, hollow JARs can provide a reasonable workaround. However, as we will
    see in the next chapter, container technologies such as Docker don't require to
    make use of executable JAR approaches and provide the same benefits.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结论，强烈建议构建瘦部署工件，理想情况下是瘦WAR文件。如果出于业务政治原因这种方法不可行，空JAR可以提供一个合理的解决方案。然而，正如我们将在下一章中看到的，容器技术，如Docker，不需要使用可执行JAR方法，并提供相同的优势。
- en: Java EE application servers
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE应用服务器
- en: What else makes an enterprise technology lightweight besides the productiveness
    of the API? What about the runtime, the enterprise container?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了API的生产力之外，还有什么让企业技术变得轻量级？运行时和企业容器呢？
- en: Developers often complained about J2EE application servers being too slow, too
    cumbersome, and unwieldy to use. Installation sizes and memory consumption were
    quite high. Typically, a lot of applications ran on a server instance in parallel
    with being redeployed individually. This approach sometimes introduced additional
    challenges, such as classloader hierarchy issues.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常抱怨J2EE应用服务器运行太慢、使用起来太繁琐、难以操控。安装大小和内存消耗相当高。通常，许多应用程序在服务器实例上并行运行，同时各自重新部署。这种方法有时会引入额外的挑战，例如类加载器层次结构问题。
- en: Modern application servers are far from this negative image. Most of them have
    been heavily optimized for startup and deployment time. Especially, server-internal
    module approaches such as **Open Service Gateway Initiative** (**OSGi**) tackled
    the necessity of supporting the full Java EE API by loading required modules on
    demand and greatly speeding up operations. In terms of resource usage, application
    servers also greatly improved compared to the past. A modern container consumes
    less memory than a running browser instance on a desktop computer. For example,
    an **Apache TomEE** instance starts up in one second, consumes less than 40 megabytes
    on disk and less than 30 megabytes of memory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用服务器远非这种负面形象。大多数应用服务器都针对启动和部署时间进行了大量优化。特别是，服务器内部模块方法，如**开放服务网关倡议**（**OSGi**），通过按需加载所需模块，支持完整的Java
    EE API，极大地加快了操作速度。在资源使用方面，与过去相比，应用服务器也取得了很大的进步。现代容器消耗的内存比桌面计算机上运行的浏览器实例要少。例如，一个**Apache
    TomEE**实例在一秒钟内启动，磁盘上消耗不到40兆字节，内存消耗不到30兆字节。
- en: The performance overhead of managed beans is equally negligible. In fact, compared
    to CDI managed beans and other frameworks such as Spring Framework, stateless
    EJBs show the best results. This is due to the fact that stateless session beans
    are pooled and reused after their business methods have been invoked.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 管理bean的性能开销同样可以忽略不计。实际上，与CDI管理bean和其他框架，如Spring框架相比，无状态EJBs表现出最佳结果。这是因为无状态会话bean在调用业务方法后会被池化和复用。
- en: Besides that, application servers manage pools of connections and threads and
    they enable engineers to gather statistics and performance insights out of the
    box. The container is responsible for providing monitoring for these aspects.
    DevOps engineers have the possibility to directly use this data without introducing
    custom metrics.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应用服务器还管理着连接池和线程池，并允许工程师直接使用这些数据，无需引入自定义指标，从而能够直接从容器中收集统计信息和性能洞察。容器负责提供对这些方面的监控。DevOps工程师可以直接使用这些数据，而无需引入自定义指标。
- en: Besides these aspects, the application servers also manage the bean instances
    and life cycles, resources, and database transactions, as we have seen in the
    previous chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些方面，应用服务器还管理着bean实例和生命周期、资源以及数据库事务，正如我们在上一章所看到的。
- en: This is the point of having an application container. It does the required work
    to run an enterprise application in production; the software engineers are responsible
    for dealing with the business logic. The container provides and manages the required
    resources and is forced by the standards to provide insights into deployed applications.
    Due to the vendors that put a lot of effort into optimizing the required technologies,
    the resource overhead can be kept low.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是拥有应用容器的意义所在。它执行运行企业应用所需的工作；软件工程师负责处理业务逻辑。容器提供并管理所需资源，并且根据标准被迫提供已部署应用的洞察。由于许多厂商在优化所需技术方面投入了大量努力，资源开销可以保持较低水平。
- en: Application servers' installation sizes are still somewhat bigger than other
    enterprise frameworks. As of writing this book, vendors are striving to provide
    smaller, on-demand runtimes tailored for the application's needs. The **MicroProfile**
    initiative includes several application server vendors that define additional
    enterprise profiles complementary to the Java EE umbrella. These profiles are
    assembled from Java EE standards as well. This is a very interesting approach
    for developers since it doesn't require any change on the application side. The
    runtime, that is, the set of standards included, will be fitted to what the application
    needs in order to fulfill its business logic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器的安装大小仍然比其他企业框架要大一些。截至本书编写时，供应商们正在努力提供更小、按需运行的运行时，以满足应用程序的需求。**MicroProfile**
    创新项目包括几个应用服务器供应商，它们定义了与 Java EE 遮罩相补充的附加企业配置文件。这些配置文件也是从 Java EE 标准中组装的。这对于开发者来说是一个非常有趣的方法，因为它不需要在应用程序方面进行任何更改。运行时，即包含的标准集，将根据应用程序的需求进行调整，以满足其业务逻辑。
- en: One application per application server
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个应用服务器一个应用程序
- en: Traditionally, with big installation sizes and long startup times, application
    servers have been used to deploy several, if not dozens of, enterprise applications.
    A server instance was shared among several teams, sometimes a whole company. This
    comes with certain inflexibility, similar to shared application models. Teams
    cannot simply choose newer JDK or server versions, or restart or reconfigure the
    application server without coordinating with other teams. This naturally inhibits
    fast and productive processes, and complicates Continuous Delivery.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，由于安装大小大和启动时间长，应用服务器被用来部署多个，如果不是几十个企业应用程序。服务器实例被多个团队共享，有时是整个公司。这带来了一定的不灵活性，类似于共享应用程序模型。团队不能简单地选择新的
    JDK 或服务器版本，或者在没有与其他团队协调的情况下重启或重新配置应用服务器。这自然会阻碍快速和高效的过程，并使持续交付变得复杂。
- en: In terms of team working methods, and project and application life cycles, the
    easiest approach therefore is to deploy an application on a dedicated application
    server. The DevOps team has full control over its version, configuration, and
    life cycle. This approach simplifies processes and avoids potential issues such
    as collisions with other teams and used technology. Issues with hierarchical classloading
    that deploying several applications could introduce are avoided as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队协作方法、项目和应用程序生命周期方面，因此最简单的方法是在专用应用服务器上部署应用程序。DevOps 团队对其版本、配置和生命周期拥有完全控制权。这种方法简化了流程，避免了与其他团队和技术冲突等潜在问题。部署多个应用程序可能引入的层次化类加载问题也得到了避免。
- en: 'An application server certainly represents quite a construct for just a single
    application. However, as we have seen previously, the installation sizes of application
    servers have already decreased compared to the past. Apart from that, developers
    should care more about the sizes of the deployment artifacts, since these are
    the moving parts of the development workflow. In a Continuous Delivery approach,
    the application is potentially built and packaged many times a day. The longer
    the time spent on the project build and transmitting artifacts, the longer the
    turnaround times. This affects each and every build and can add up to a lot of
    overhead during a day. The application server is not installed and shipped that
    often. Therefore, it is advisable to deploy an application to a single, dedicated
    Java EE server:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器当然代表了一个相当大的结构，仅用于单个应用程序。然而，正如我们之前所看到的，应用服务器的安装大小已经与过去相比有所下降。除此之外，开发者应该更加关注部署实体的尺寸，因为这些是开发工作流程中的移动部分。在持续交付方法中，应用程序可能每天都会被构建和打包多次。项目构建和传输实体的时间越长，周转时间就越长。这会影响每一个构建，并在一天中累积大量的开销。应用服务器并不经常安装和运输。因此，建议将应用程序部署到单个、专用的
    Java EE 服务器：
- en: '![](img/f7fc2681-0118-4d06-ba47-a32640353b73.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7fc2681-0118-4d06-ba47-a32640353b73.png)'
- en: In the next chapter, we will see how container technologies such as Docker support
    this approach. Shipping the application, including the whole stack down to the
    operating system as a container, encourages the approach of one application per
    application server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到容器技术，如 Docker，如何支持这种方法。将应用程序，包括整个堆栈作为容器，直到操作系统，都作为容器运输，鼓励每个应用服务器一个应用程序的方法。
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The seamless integration of multiple Java EE standards with the convention over
    configuration approach minimizes the amount of boilerplate work developers have
    to do. The configuration of modern enterprise applications is thus kept to a minimum.
    Especially the default conventions, which work for the majority of enterprise
    applications and the possibility of overriding configuration only if required,
    increases the developer's productivity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 多个Java EE标准与约定优于配置方法的无缝集成，最大限度地减少了开发者需要做的样板工作。因此，现代企业应用程序的配置被保持在最低限度。特别是默认约定，适用于大多数企业应用程序，并且只有在需要时才允许覆盖配置，这提高了开发者的生产力。
- en: Enterprise applications should minimize their dependencies ideally to only the
    provided Java EE API. The third-party dependencies should only be added if they
    are a business necessity and not a technical one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序应尽量减少其依赖性，理想情况下仅依赖于提供的Java EE API。只有在业务上是必需的，而不是技术上的必需时，才应添加第三方依赖。
- en: Java EE applications should be packaged as thin WAR files, following a zero-dependency
    approach. This has a positive impact on the time spend to build as well as to
    publish the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE应用程序应打包为轻量级的WAR文件，遵循零依赖的方法。这有助于减少构建和发布应用程序所需的时间。
- en: Modern Java EE applications are far from the negative image of heavyweight J2EE
    runtimes. They start up and deploy fast and try to reduce the memory impact. Whereas
    application servers might not be the most lightweight runtime out there, they
    ship with enough benefits for enterprise applications such as integrating technology
    or managing life cycles, connections, transactions, or threads, that would have
    to be implemented otherwise.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Java EE应用程序远非重型J2EE运行时的负面形象。它们启动和部署速度快，并试图减少内存影响。虽然应用服务器可能不是最轻量级的运行时，但它们提供了足够的好处，例如集成技术或管理生命周期、连接、事务或线程，否则这些都需要实现。
- en: In order to simplify application life cycles and deployments it's advisable
    to deploy one application per application server. This gets rid of a few potential
    challenges and perfectly fits into a modern world of container technologies. The
    next chapter will show you this modern world in the age of cloud platforms, what
    container technologies are about and how Java EE fits into this picture.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化应用程序的生命周期和部署，建议每个应用程序服务器部署一个应用程序。这消除了几个潜在挑战，并且完美地适应了现代容器技术世界。下一章将向您展示在云平台时代的这个现代世界，容器技术是什么，以及Java
    EE如何融入这幅画面。
