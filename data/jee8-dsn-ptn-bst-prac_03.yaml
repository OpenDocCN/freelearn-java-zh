- en: Business Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务模式
- en: In this chapter, we will cover definitions of the Business Delegate pattern,
    the Session Façade pattern, and the business-object pattern. We will show the
    reasons to use these design patterns, common approaches to each of them, their
    interaction with other patterns, their evolution, and how they behave in the real
    world. We will also demonstrate some examples of these patterns' implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖业务代理模式、会话外观模式和业务对象模式的定义。我们将展示使用这些设计模式的原因、每种模式的常见方法、它们与其他模式的交互、它们的演变以及在现实世界中的行为。我们还将展示这些模式实现的一些示例。
- en: 'At the end of the chapter, you will be able to identify the correct scenarios
    to apply business patterns and choose the best methods for implementing them.
    The following topics will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够识别正确的应用业务模式场景并选择实现它们的最佳方法。以下主题将被涵盖：
- en: Understanding the business tier
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解业务层
- en: Explaining the Business Delegate pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释业务代理模式
- en: Explaining the Session Façade pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释会话外观模式
- en: Implementing the Session Façade pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现会话外观模式
- en: Explaining the business-object pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释业务对象模式
- en: Implementing the business-object pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现业务对象模式
- en: Understanding the business tier
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解业务层
- en: Before talking about the business patterns and the use of these patterns from
    the perspective of JEE8 and its technologies, we must identify where the business
    logic of an application will be within the JEE framework. As we have already seen,
    JEE architecture basically has three tiers. Most JEE technologies, such as **Enterprise
    Java Beans **(**EJB**) and **Java Persistence API** (**JPA**), are related to
    the business tier. The EJB container is located in the business tier, but there
    are a few other technologies that navigate the entire JEE framework, such as CDI
    and Bean Validation. However, the most important thing to know is that the core
    business-logic application is executed in the business tier.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在从JEE8及其技术的角度讨论业务模式和这些模式的使用之前，我们必须确定应用程序的业务逻辑将在JEE框架中的哪个位置。正如我们已经看到的，JEE架构基本上有三个层次。大多数JEE技术，如**企业JavaBeans
    (EJB**)和**Java持久化API (JPA**)，都与业务层相关。EJB容器位于业务层，但还有一些其他技术在整个JEE框架中导航，如CDI和Bean
    Validation。然而，最重要的是要知道，核心业务逻辑应用程序是在业务层执行的。
- en: 'We will see three important patterns in the business tier. We will briefly
    explain the definition and goal of each pattern:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在业务层看到三个重要的模式。我们将简要解释每个模式的定义和目标：
- en: '**Business Delegate pattern**: It is a proxy for the business service, hiding
    the service lookup and the remote invocation.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务代理模式**：它是业务服务的代理，隐藏了服务查找和远程调用的过程。'
- en: '**Session Façade ****pattern**: Encapsulates business rules and exposes coarse-grained
    services to clients.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话外观模式**：封装业务规则并向客户端暴露粗粒度服务。'
- en: '**Business-object ****pattern**: These are real-world objects with properties
    and methods for applications with a high level of complexity which help to separate
    business logic from the rest of the application, promoting a decoupling between
    business logic and the rest of the application.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务对象模式**：这些是具有属性和方法的真实世界对象，适用于具有高度复杂性的应用程序，有助于将业务逻辑从应用程序的其他部分分离出来，促进业务逻辑与其他应用程序部分的解耦。'
- en: 'Let''s look at the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图示：
- en: '![](img/e328af9d-10e6-424c-80c5-e4116fba3328.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e328af9d-10e6-424c-80c5-e4116fba3328.png)'
- en: We will see later in this chapter that, although the Business Delegate is a
    business-tier component, its physical location is on the web tier.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到，尽管业务代理是业务层组件，但其物理位置位于Web层。
- en: Explaining the Business Delegate pattern
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释业务代理模式
- en: To explain the Business Delegate pattern, we need to understand some points
    that show the reason and evidence for the real goals of this pattern. Thus, we
    will show these points and explain the Business Delegate pattern in detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释业务代理模式，我们需要理解一些表明该模式真实目标和证据的要点。因此，我们将展示这些要点并详细解释业务代理模式。
- en: Client tier, presentation tier, and business tier
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端层、表示层和业务层
- en: Before we go on, here is a brief explanation of the concept of tiers and layers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，这里是对层次和层概念的一个简要说明。
- en: Layers
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层次
- en: 'A layer is merely a logical division that has a responsibility within the architecture
    of the application. It is a logical way to organize the application code. Martin
    Fowler''s book *Patterns of Enterprise Application Architecture* describes the
    three main layers and their responsibilities:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 层仅是应用架构中具有职责的逻辑划分。这是一种组织应用程序代码的逻辑方式。马丁·福勒的书籍《企业应用架构模式》描述了三个主要层及其职责：
- en: '| **Layer** | **Responsibility** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **层** | **职责** |'
- en: '| Presentation | User interaction, validation of input fields, formatting display
    data |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 表示 | 用户交互、输入字段验证、显示数据格式化 |'
- en: '| Business | Application logic |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 业务 | 应用逻辑 |'
- en: '| Data | Database communication, messaging-system communication |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 数据库通信、消息系统通信 |'
- en: Thus, the classes of an application are logically separated according to their
    responsibilities. There are classes that are used in the data-access layer, while
    other classes prepare the data to be displayed as part of the presentation layer.
    This division is purely logical. A good architecture practice is to have a layered
    chain where a layer interacts with its adjacent layer, providing and consuming
    services. This leads to more cohesion (the same responsibilities are contained
    in the same layer) and low-coupling.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用程序的类根据它们的职责在逻辑上被分离。有些类用于数据访问层，而其他类则准备数据以作为表示层的一部分进行显示。这种划分完全是逻辑上的。良好的架构实践是拥有一个分层链，其中一层与其相邻层交互，提供和消费服务。这导致了更高的内聚性（相同的职责包含在同一层中）和低耦合性。
- en: 'Let''s look at the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表：
- en: '![](img/46bcf26c-96ea-4295-b37d-a63d6b04a013.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46bcf26c-96ea-4295-b37d-a63d6b04a013.png)'
- en: We can see that the JSF, JSP, and HTML pages, the bean-backing class, and even
    a servlet belong logically to the presentation layer group, since they have the
    same basic responsibility, which is to send information to the user and receive
    requests from a user. An EJB, a servlet (part of it), and a **Business Object**
    belong to the business layer. The DAO classes and the JPA entities belong to the
    data layer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，JSF、JSP和HTML页面、后端bean类，甚至servlet在逻辑上属于表示层组，因为它们具有相同的基本职责，即向用户发送信息并接收用户的请求。EJB、servlet（其中一部分）和**业务对象**属于业务层。DAO类和JPA实体属于数据层。
- en: Tiers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级别
- en: 'A tier is a physical unit, and it is related to hardware and software components.
    It is the infrastructure in which the layer components are deployed and executed.
    Examples of tiers are web browsers, application servers, and database servers.
    A typical *n*-tier application is defined with the following tiers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 级别是一个物理单元，它与硬件和软件组件相关。它是层组件部署和执行的基础设施。级别的例子包括网络浏览器、应用服务器和数据库服务器。一个典型的*n*层应用程序由以下级别定义：
- en: '| **Tier** | **Infrastructure** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **基础设施** |'
- en: '| Client  | Web browsers, a mobile device |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 | 网络浏览器、移动设备 |'
- en: '| Presentation  | Web server (container), HTTP protocol |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 表示 | Web服务器（容器）、HTTP协议 |'
- en: '| Business | Application server (such as Java EE server) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 业务 | 应用服务器（如Java EE服务器） |'
- en: '| Data/Integration | Database servers, messaging service, web services |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 数据/集成 | 数据库服务器、消息服务、Web服务 |'
- en: 'Let''s look at the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表：
- en: '![](img/126719f2-c50e-4c1c-8f5a-e62737e33a1a.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/126719f2-c50e-4c1c-8f5a-e62737e33a1a.png)'
- en: Here, it is very important to note the difference between the client tier and
    the presentation tier. The client tier is where a client application is executed
    (through platforms such as a browser or a mobile application). Generally, the
    client tier is the client machine or device, and the presentation tier is represented
    by the web server. The presentation tier receives a data request from the client
    tier, prepares the data (with some format defined previously, if necessary), and
    sends it to the business tier. This is the classic mechanism of how data is processed
    in a JEE scenario. We can identify some technologies in the presentation tier,
    such as Servlets, JSP, JSF, WebSockets, JAX‐RS and JAX‐WS, Java API for JSON processing,
    JSON-B, CDI, and bean validation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，非常重要的一点是要注意客户端级别和表示级别之间的区别。客户端级别是客户端应用程序被执行的地方（通过浏览器或移动应用程序等平台）。通常，客户端级别是客户端计算机或设备，而表示级别由Web服务器表示。表示层从客户端层接收数据请求，准备数据（如果需要，使用先前定义的某些格式），并将其发送到业务层。这是在JEE场景中处理数据的经典机制。我们可以在表示层中识别一些技术，如Servlets、JSP、JSF、WebSockets、JAX-RS和JAX-WS、Java
    API用于JSON处理、JSON-B、CDI和bean验证。
- en: 'Let''s look at the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的图：
- en: '![](img/2559f07b-01a4-48a9-87e0-4effbec201e9.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2559f07b-01a4-48a9-87e0-4effbec201e9.png)'
- en: As previously discussed, it is in the business tier that all business logic
    is executed. The presentation tier is the client of the business tier because
    it requires operations of the business tier and receives the result that comes
    from the business tier. At this point, we can see an additional responsibility
    for the presentation tier, which is to locate the service and make the request.
    It would be interesting if we had a mechanism that delegated the request to the
    real service. This is the role of the Business Delegate pattern, which prevents
    details of the business tier services from being exposed to the presentation tier. The
    coupling between the presentation and business tiers is reduced, and therefore
    modifications in the business tier have a minimal impact in the presentation tier.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有业务逻辑都在业务层执行。表示层是业务层的客户端，因为它需要业务层的操作并接收来自业务层的结果。在此阶段，我们可以看到表示层的一个额外责任，即定位服务并发出请求。如果有一个将请求委托给真实服务的机制将会很有趣。这正是业务代表模式的作用，它防止业务层服务的细节暴露给表示层。因此，表示层和业务层之间的耦合减少，并且因此业务层的修改对表示层的影响最小。
- en: The Business Delegate pattern acts as an input door for the client. It is responsible
    for receiving the request, identifying or locating the real business service,
    and calling the service sending the request. After that, the delegate receives
    the service response and then sends the response back to the client.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 业务代表模式充当客户端的输入门。它负责接收请求，识别或定位真实的企业服务，并调用发送请求的服务。之后，代表接收服务响应，然后将响应发送回客户端。
- en: The classic Business Delegate pattern scenario
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典的业务代表模式场景
- en: In a classic Business Delegate pattern scenario, the implementation of the Business
    Delegate pattern receives a request from a Java client and sends the response
    back to it. In addition, to minimize the coupling between the presentation tier
    and the business tier, it was the responsibility of a delegate to locate remote
    services (in most cases, a remote EJB service) and provide a caching mechanism
    for accessing business services to reduce the network traffic.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的业务代表模式场景中，业务代表模式的实现从Java客户端接收请求，并将响应发送回客户端。此外，为了最小化表示层和业务层之间的耦合，代表负责定位远程服务（在大多数情况下，是远程EJB服务）并为访问业务服务提供缓存机制以减少网络流量。
- en: So, when EJB was used as a remote service in the past, Business Delegate patterns
    were used with another pattern, the Service Locator Pattern, which is responsible
    for locating the remote (and local) EJB. Also, the stub (a kind of EJB reference
    based on the **RMI** (**Remote Method Invocation**) protocol) of the remote EJB
    is cached by the delegate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当过去使用EJB作为远程服务时，业务代表模式与另一个模式（服务定位器模式）一起使用，该模式负责定位远程（和本地）EJB。此外，远程EJB的存根（基于RMI（远程方法调用）协议的一种EJB引用）被代表缓存。
- en: 'The following diagram shows the class diagram for the Business Delegate pattern.
    This represents the basic structure of this pattern. The client sends requests
    to the **Business Delegate**, which in turn accesses the correct business service.
    The **Business Delegate** can use a service locator in the case of a remote service
    lookup:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图展示了业务代表模式的类图。这代表了该模式的基本结构。客户端向**业务代表**发送请求，而**业务代表**则访问正确的企业服务。在远程服务查找的情况下，**业务代表**可以使用服务定位器：
- en: '![](img/460cf5b5-4878-40d4-a4ad-a4c8e8becdb6.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/460cf5b5-4878-40d4-a4ad-a4c8e8becdb6.png)'
- en: As the **Business Delegate** re-passes the business request to the **Business
    Service**, one natural approach in code development is to make both classes (**Business
    Delegate** and **Business Service**) implement the same business interface.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当**业务代表**将业务请求重新传递给**业务服务**时，在代码开发中的一种自然方法是让两个类（**业务代表**和**业务服务**）实现相同的企业接口。
- en: 'This is shown in the following diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的图中展示：
- en: '![](img/b33e8b74-438a-4b44-adc3-4dbd551678dc.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b33e8b74-438a-4b44-adc3-4dbd551678dc.png)'
- en: 'In the following diagram, we show the sequence diagram for the Business Delegate
    pattern:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们展示了业务代表模式的序列图：
- en: '![](img/1db85698-a1ad-44ee-9d45-263217219320.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1db85698-a1ad-44ee-9d45-263217219320.png)'
- en: The benefits of the Business Delegate pattern
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务代表模式的好处
- en: 'According to the old J2EE architecture, the benefits of a Business Delegate
    included:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据旧的J2EE架构，商业代表者的好处包括：
- en: Hiding the details of the underlying business service. In the case of remote
    services, using the Business Delegate makes naming and looking up services transparent
    to the presentation tier.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏底层业务服务的细节。在远程服务的情况下，使用商业代表者使得命名和查找服务对表示层来说是透明的。
- en: Handling business-service exceptions. The Business Delegate can catch service
    exceptions that have a technical meaning and translate them into a more friendly
    exception, generating application exception level to the client. For instance,
    Business Delegate could translate the eventual remote exceptions generated by
    a business service into a specific application exception.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理业务服务异常。商业代表者可以捕获具有技术意义的服务异常，并将它们转换为更友好的异常，向客户端生成应用程序异常级别。例如，商业代表者可以将业务服务产生的最终远程异常转换为特定的应用程序异常。
- en: A Business Delegate can transparently carry out a new retry of a failed service
    execution and hide the problem from the client.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业代表者可以透明地执行失败的服务执行的重新尝试，并从客户端隐藏问题。
- en: In addition, a Business Delegate can cache references to remote business services
    in order to improve performance. Calling a remote service is a costly operation,
    and the repetition of remote service calls can greatly increase network traffic.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，商业代表者可以缓存远程业务服务的引用以提高性能。调用远程服务是一个昂贵的操作，重复远程服务调用会大大增加网络流量。
- en: However, as new scenarios have arisen, things have evolved in the world of distributed
    application development. The JEE architecture has been changing in accordance
    with this. As modern mobile applications and web clients developed, new client
    applications, with rich JavaScript frameworks, have been emerging. As a consequence,
    the Business Delegate is seen as a bridge or door between the presentation tier
    (where technologies such as Servlet, JSP, and the JSF mechanism reside) and the
    business tier (where technologies such as EJB reside).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着新场景的出现，分布式应用程序开发的世界也在不断发展。JEE架构也随之变化。随着现代移动应用程序和Web客户端的发展，新的客户端应用程序，带有丰富的JavaScript框架，正在涌现。因此，商业代表者被视为表示层（其中驻有Servlet、JSP和JSF机制等技术）和业务层（其中驻有EJB等技术）之间的桥梁或门户。
- en: Business Delegate – obsolete or not
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 商业代表者 – 已过时还是未过时
- en: In the old J2EE architecture, both remote and local business services, such
    as EJB, use a service locator mechanism. However, dependency injection is now
    used to access local EJBs (and the option for local services is increasingly being
    used). In many cases, using a Business Delegate to look for local services has
    become somewhat obsolete for this reason. Consequently, someone could question
    the use of a pattern, such as Business Delegate, only to handle remote communications.
    This is because, since JEE5, we have begun to use DI annotations to reference
    local EJB with ease. However, if we think of a Business Delegate as a bridge for
    Session Bean EJBs, for example, then we can change these EJBs (when necessary)
    without having to worry about whether or not the presentation tier will be broken.
    If something changes in the session EJB, it is the Business Delegate's job to
    handle this change and keep the presentation tier intact.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的J2EE架构中，远程和本地业务服务，如EJB，使用服务定位器机制。然而，现在使用依赖注入来访问本地EJB（并且本地服务的选项越来越被使用）。在许多情况下，由于这个原因，使用商业代表者查找本地服务已经变得有些过时。因此，有人可能会质疑仅为了处理远程通信而使用模式，如商业代表者。这是因为，自从JEE5以来，我们已经开始使用DI注解轻松引用本地EJB。然而，如果我们把商业代表者视为Session
    Bean EJB的桥梁，例如，那么我们可以在必要时更改这些EJB，而无需担心表示层是否会损坏。如果会话EJB发生变化，那么商业代表者的职责就是处理这种变化，并保持表示层的完整性。
- en: 'The following diagram shows the classic architecture of an application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了应用程序的经典架构：
- en: '![](img/38a77928-6931-4aa1-8b50-e65896a7c33d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38a77928-6931-4aa1-8b50-e65896a7c33d.png)'
- en: 'In some situations, this architecture was replaced by others, as shown in the
    following diagrams:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这种架构被其他架构所取代，如下面的图所示：
- en: '![](img/5670e52a-7936-4664-937f-6b46d7607ba3.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5670e52a-7936-4664-937f-6b46d7607ba3.png)'
- en: '![](img/100aa4e6-665d-46fe-b1e4-4851991e037f.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/100aa4e6-665d-46fe-b1e4-4851991e037f.png)'
- en: Looking at the two previous alternatives, we can see the way in which Business
    Delegate can be used when there is a need to change the business service layer.
    This can be done without impacting the presentation layer. In addition, when we
    need to handle business-service exceptions and we have a client other than a web
    browser, we can use a Business Delegate with a lookup mechanism (JNDI) for the
    business services (EJBs).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前两种替代方案，我们可以看到在需要更改业务服务层时，如何使用业务代表（Business Delegate）。这可以在不影响表示层的情况下完成。此外，当我们需要处理业务服务异常并且有一个非网页浏览器的客户端时，我们可以使用带有查找机制（JNDI）的业务服务（EJBs）的业务代表。
- en: There are several other architectures that can be used in application building.
    We will see that the use of the Business Delegate pattern occurs along with some
    other patterns, especially the Session Façade pattern, as shown in the diagrams.
    Another common pattern is the business-object pattern, which represents a real-world
    business object with properties and methods, not necessarily getter and setter
    methods.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用构建中可以使用几种其他架构。我们将看到业务代表模式的使用与一些其他模式一起发生，特别是在图示中显示的会话外观模式。另一个常见的模式是业务对象模式，它使用属性和方法表示现实世界的业务对象，不一定包括getter和setter方法。
- en: Explaining the Session Façade pattern
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释会话外观模式
- en: Before we introduce the Session Façade pattern, it is important to cover the
    façade patterns, which are one of the structural design patterns mentioned in the
    **Gang of Four** (**GoF**) book.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍会话外观模式之前，重要的是要介绍外观模式，这些模式是《设计模式：可复用面向对象软件的基础》（**Gang of Four**，**GoF**）一书中提到的结构型设计模式之一。
- en: The main goal is to encapsulate the complexity of business logic in a business
    interface. Broadly speaking, this interface only exposes a small number of coarse-grained
    methods to the client. Each of these interface methods is responsible for controlling
    the underlying complexity of business logic. In this way, the internal services
    of finer granularity can be combined into a set of services that are exposed by
    the interface method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目标是封装业务逻辑的复杂性到一个业务接口中。从广义上讲，这个接口仅向客户端暴露少量粗粒度方法。这些接口方法中的每一个都负责控制底层业务逻辑的复杂性。通过这种方式，更细粒度的内部服务可以被组合成接口方法暴露的一组服务。
- en: 'The benefits of using a façade pattern are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外观模式的优点如下：
- en: It provides coarse‐grained methods for available services.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为可用服务提供粗粒度方法。
- en: It reduces remote calls. A remote client does not need to call many fine-grained
    business objects. Instead, it executes a remote call to the exposed interface
    method, which is responsible for making local calls to the fine-grained objects.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了远程调用。远程客户端不需要调用许多细粒度业务对象。相反，它执行对暴露接口方法的远程调用，该方法负责对细粒度对象进行本地调用。
- en: It can create a single channel to a legacy backend system.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以创建一个到遗留后端系统的单一通道。
- en: It decreases the coupling between the client and the fine‐grained objects.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了客户端和细粒度对象之间的耦合。
- en: Let's say, for example, that there is a system for checking vacancies in hotels
    in a city. The hotels offer web services to be consulted about the vacancies.
    A client application that wants to know how many vacancies are available will
    have to make a call to each web service. But if we make a call to a façade layer,
    this façade could take responsibility for searching the web services. In addition
    to reducing calls, the façade removes the high coupling that would exist between
    the client and web services.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有一个城市酒店空位检查的系统。酒店提供关于空位的咨询服务。一个想要知道有多少空位可用的客户端应用程序必须对每个网络服务进行调用。但如果我们调用外观层，这个外观可以负责搜索网络服务。除了减少调用外，外观还消除了客户端和网络服务之间可能存在的高度耦合。
- en: By understanding the problem for which the GoF façade pattern is the solution,
    we can then see a similar problem with JEE. In this case, server-side components
    are implemented as **Business Objects** (**BOs**) or POJOs. Almost every request
    coming from the client needs a BO interaction, and each BO involved in the request
    process may have a relationship with other BOs. In addition, the BO might have
    accessed an integration tier using a DAO pattern. We do not want to expose the
    complexity of the business components and their internal relationships to clients—especially
    to remote clients. We then have a Session Façade pattern as a solution to this
    problem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解 GoF 外观模式作为解决方案的问题，我们可以看到 JEE 中存在一个类似的问题。在这种情况下，服务器端组件被实现为 **业务对象**（**BOs**）或
    POJOs。几乎每个来自客户端的请求都需要与 BO 交互，并且每个参与请求过程的 BO 可能与其他 BO 有关系。此外，BO 可能使用 DAO 模式访问了集成层。我们不希望向客户端暴露业务组件及其内部关系的复杂性——尤其是远程客户端。因此，会话外观模式作为解决这个问题的方案。
- en: Benefits of Session Façade
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话外观的好处
- en: It is important not to expose the client to the complexity of using these fine-grained
    BOs. Frequent access to a large set of fine‐grained components greatly increases
    the complexity of BOs control. Transaction-control, security-management, and service-lookup
    are all examples of this complexity.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要让客户端接触到使用这些细粒度 BOs 的复杂性。频繁访问大量细粒度组件会大大增加 BOs 控制的复杂性。事务控制、安全管理和服务查找都是这种复杂性的例子。
- en: 'Like the GoF façade pattern, the use of a coarse-grained layer in JEE decreases
    the coupling between the client and the business components represented by BOs
    of fine granularity (and we can think of a Session Façade as an extension of the
    GoF façade pattern in JEE). The Session Façade pattern represents this coarse-grained
    layer. An architecture built with the Session Façade provides a facade of more
    generic (or coarse-grained) methods for clients. The two biggest benefits of using
    the Session Façade pattern are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 GoF 外观模式，在 JEE 中使用粗粒度层减少了客户端与由细粒度 BOs（业务对象）表示的业务组件之间的耦合（我们可以将会话外观视为 JEE
    中 GoF 外观模式的扩展）。会话外观模式代表了这一粗粒度层。使用会话外观模式构建的架构为客户端提供了更通用的（或粗粒度）方法的外观。使用会话外观模式的两个最大好处如下：
- en: It does not expose the high complexity of the business objects (BOs) and their
    relationships.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会暴露业务对象（BOs）及其关系的复杂性。
- en: It decreases network traffic. This occurs because remote calls are limited to
    coarse-grained methods exposed by Session Façade instead of the fine-grained business
    objects.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了网络流量。这是因为远程调用仅限于会话外观暴露的粗粒度方法，而不是细粒度业务对象。
- en: Of course, EJB remote calling was used much more in the old JEE scenario in
    comparison to current architectures. It is important that this is taken into consideration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与当前架构相比，在旧的 JEE 场景中，EJB 远程调用使用得更多。这一点需要考虑。
- en: Implementing the Session Façade pattern in JEE
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 JEE 中实现会话外观模式
- en: In the JEE architecture, Session Façade is implemented by a stateless or stateful
    EJB. An EJB object can use or combine other POJOs, business objects, and EJBs.
    At this point, we must be careful not to accumulate too many unnecessary layers,
    as we run the risk of having a chain of EJBs where one EJB calls another more
    internal EJB, and so on. The services must be mapped and designed well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JEE 架构中，会话外观是由无状态或有状态的 EJB 实现的。EJB 对象可以使用或组合其他 POJOs、业务对象和 EJBs。在这个阶段，我们必须小心不要积累过多的不必要的层，因为我们面临着一个
    EJB 链的风险，其中一个 EJB 调用另一个更内部的 EJB，依此类推。服务必须得到良好的映射和设计。
- en: Because the Session Façade is primarily implemented by EJBs, services such as
    transaction-control and security-management come naturally to this technology.
    It is in this layer that we usually have the transaction-control of most internal
    objects, such as the POJOs, which represent entities within the JPA technology.
    For an EJB, JPA entity transaction control is native, meaning that it is supplied
    by the JEE container. This provides a large increase in productivity during development.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于会话外观主要是由 EJBs 实现的，因此事务控制和安全管理等服务自然地适用于这项技术。通常在这个层面，我们会处理大多数内部对象的事务控制，例如 POJOs，它们代表了
    JPA 技术中的实体。对于 EJB 来说，JPA 实体事务控制是原生的，这意味着它是由 JEE 容器提供的。这为开发过程提供了大幅的生产力提升。
- en: The classic Session Façade pattern scenario
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典的会话外观模式场景
- en: 'The Session Façade pattern can be used in several architectures. The following
    diagram shows a classic model of **Session Façade** usage:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 会话外观模式可以在几种架构中使用。以下图表显示了**会话外观**使用的经典模型：
- en: '![](img/2d1ecf38-09bd-48e3-88b7-7938a01ec71a.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d1ecf38-09bd-48e3-88b7-7938a01ec71a.png)'
- en: Looking at the preceding diagram, we can see that a client (typically a web
    component or a Business Delegate implementation) accesses the facade layer. In
    this architecture, we find some options that depict the use of the **Session Façade**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的图表，我们可以看到客户端（通常是Web组件或业务代表实现）访问外观层。在这个架构中，我们发现了一些描述**会话外观**使用的选项。
- en: The Façade can handle different business objects (BO). Later in this chapter,
    we will see a better description of a BO and the business-object pattern. A business
    object is the representation of a conceptual model, which is a real-world object.
    A BO may have methods that describe its behavior. In this case, we will say that
    this BO reflects a non-anemic model (an anemic domain object contains a few business
    methods, such as validation and calculation). Here, the BO can use a **Data-Access
    Object** (**DAO**) pattern as a strategy for executing CRUD operations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 外观可以处理不同的业务对象（BO）。在本章的后面部分，我们将看到对BO和业务对象模式的更好描述。业务对象是概念模型的表示，这是一个现实世界中的对象。BO可能有描述其行为的方法。在这种情况下，我们将说这个BO反映了一个非贫血模型（贫血领域对象包含一些业务方法，如验证和计算）。在这里，BO可以使用**数据访问对象**（**DAO**）模式作为执行CRUD操作的策略。
- en: 'The Façade can directly access a POJO JPA (Java Persistence API) entity. If
    the conceptual model of the business object is very close to the data model, we
    can fully represent this business object (an actor of a use case of the application)
    as a persistence entity. Most of the time, a Session Façade is implemented as
    an EJB session. Although a JPA entity does not require an EJB container to run
    because it runs in both JSE and JEE environments, the EJB and JPA technologies
    make a very successful combination. Since the JEE 5.0 platform, JPA has been the
    default specification for object-relational mapping (OR mapping) and persistence-management.
    JPA version 1.0 is part of the JSR 220 specification (EJB 3.0). The final result
    of the EJB 3.0 specification is that three separate documents were produced, the
    third being the Java Persistence API. This described the persistence model for
    the JSE and JEE environments. More internal services are offered naturally by
    the implementation of the EJB technology, such as transaction and security control:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 外观可以直接访问POJO JPA（Java持久化API）实体。如果业务对象的概念模型与数据模型非常接近，我们可以完全表示这个业务对象（应用用例的一个参与者）作为一个持久化实体。大多数情况下，会话外观被实现为一个EJB会话。尽管JPA实体不需要EJB容器来运行，因为它可以在JSE和JEE环境中运行，但EJB和JPA技术组合非常成功。自从JEE
    5.0平台以来，JPA已经成为对象关系映射（OR映射）和持久化管理默认规范。JPA 1.0是JSR 220规范（EJB 3.0）的一部分。EJB 3.0规范的最终结果是产生了三个独立的文档，第三个是Java持久化API。它描述了JSE和JEE环境的持久化模型。EJB技术的实现自然提供了更多内部服务，如事务和安全控制：
- en: In most applications, the Session Façade uses a DAO implementation to perform
    the crud operations with the persistence layer. We will see later that the DAO
    pattern encapsulates the details related to crud, and can directly use a JDBC
    implementation or a JPA implementation to perform the crud work.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数应用中，会话外观使用DAO实现来与持久化层执行CRUD操作。我们稍后会看到DAO模式封装了与CRUD相关的细节，可以直接使用JDBC实现或JPA实现来执行CRUD工作。
- en: 'The following is an activity diagram with the component tiers involved in the
    **Session** **Façade** pattern:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与**会话外观**模式相关的组件层活动图：
- en: '![](img/9a5ee493-d9b5-40ce-9aef-80e85316d155.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a5ee493-d9b5-40ce-9aef-80e85316d155.png)'
- en: 'The following shows the **Session Façade** pattern-sequence diagram:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了**会话外观**模式的序列图：
- en: '![](img/04597fcd-fb3b-41e8-b8d3-ba0ae4de29e4.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04597fcd-fb3b-41e8-b8d3-ba0ae4de29e4.png)'
- en: Implementing the Session Façade pattern
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现会话外观模式
- en: 'Let''s make a small application related to the academic world. We will make
    two façades—one façade to manage the financial part of the application, and one
    to manage the academic part of the application. We will also construct some other
    classes, such as DAO classes and classes of the domain model. There is no database;
    all the data is kept in memory through the DAO classes. Consequently, the methods
    designed for finding information are built into the DAO classes. Let''s create
    the following domain model classes: `Discipline`, `Course`, `Member` (`Member`
    is an abstract class that represents a member of a college), `Professor`, and
    `Student`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个与学术世界相关的小型应用程序。我们将创建两个门面——一个门面来管理应用程序的财务部分，另一个来管理应用程序的学术部分。我们还将构建一些其他类，例如DAO类和领域模型类。没有数据库；所有数据都通过DAO类保存在内存中。因此，用于查找信息的方法被构建到DAO类中。让我们创建以下领域模型类：`Discipline`、`Course`、`Member`（`Member`是一个抽象类，代表学院的成员）、`Professor`和`Student`：
- en: '[PRE0]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the `Course` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Course`类：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the `Member` class which like the previous classes, implements the
    `Serializable` package:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是像之前的类一样实现`Serializable`包的`Member`类：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, the `Professor` class inherits the `Member` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Professor`类继承自`Member`类：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the `Student` class, which inherits the `Member` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是继承自`Member`类的`Student`类：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We could make these application entities with an `id` integer type property
    that would represent a unique entity. It is common to extend an abstract entity
    class that contains this ID. However, for the college members, we simplified it
    and used the `name` property for the identification job. In the `Discipline` and
    `Member` classes, we implemented the equals method to check for equal objects
    within a collection.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个表示唯一实体的`id`整数类型属性来创建这些应用程序实体。通常，会扩展一个包含此ID的抽象实体类。然而，对于学院成员，我们简化了它，并使用`name`属性来执行标识任务。在`Discipline`和`Member`类中，我们实现了equals方法来检查集合内的相等对象。
- en: 'Let''s make some DAO classes. There is no POJO JPA entity in these examples.
    The relationships between the model objects are inserted in the DAO classes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些DAO类。在这些示例中没有POJO JPA实体。模型对象之间的关系被插入到DAO类中：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the `DisciplineDAO` class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`DisciplineDAO`类：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, you will make the `StudentDAO` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将创建`StudentDAO`类：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s look at the `ProfessorDAO` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ProfessorDAO`类：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We put a lot of responsibility in `DisciplineDAO` for simplicity. We could have
    increased the scope of the `CourseDAO` or `ProfessorDAO` class for access to data
    related to the `Professor` entity.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们在`DisciplineDAO`中赋予了它很多责任。我们本可以增加`CourseDAO`或`ProfessorDAO`类的访问范围，以便访问与`Professor`实体相关的数据。
- en: 'Now, the following classes are the two Session Façade implementations: `AcademicFacadeImpl`
    and `FinancialFacadeImpl`. It is important to note that this is only one of several
    ways to build this kind of application. The next part of this chapter will cover
    the business-object pattern, and here we will create a business object that centralizes
    the application''s business rules instead of the Session Façade:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下类是两个会话门面实现：`AcademicFacadeImpl`和`FinancialFacadeImpl`。重要的是要注意，这仅仅是构建此类应用程序的几种方法之一。本章的下一部分将介绍业务对象模式，在这里我们将创建一个业务对象，它集中了应用程序的业务规则，而不是会话门面：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s look at the `FinancialFacadeImpl` class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`FinancialFacadeImpl`类：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can observe the `@LocalBean` annotation in the EJB Session Façade. This means
    that the bean has a no-interface view. This is just a simplification because there
    is no need to apply local or remote interfaces for the explanation of the Session
    Façade. Just remember, the requirement for local interfaces has been dropped since EJB
    3.1.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在EJB会话门面中观察到`@LocalBean`注解。这意味着该bean有一个无接口视图。这只是一个简化，因为没有必要为会话门面的解释应用本地或远程接口。只需记住，自EJB
    3.1以来，已经取消了本地接口的要求。
- en: 'The `AcademicFacadeImpl` Session Façade has an asynchronous method with an
    event listener parameter. This method is responsible for providing the date and
    time for a test revision when requested by a student. For example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`AcademicFacadeImpl`会话门面有一个带有事件监听器参数的异步方法。此方法负责在学生请求时提供测试复习的日期和时间。例如：'
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This event can be fired from a façade client, typically a delegate or a web
    component (a servlet or a JSF-managed bean, for example). The event is injected
    into the client and fired according to the request. It is then fired together
    with a `TestRevisionTO` object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件可以从一个门面客户端触发，通常是代表者或Web组件（例如servlet或JSF管理的bean）。事件被注入到客户端并根据请求触发。然后它与`TestRevisionTO`对象一起触发：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `TestRevisionTO` class is fired as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestRevisionTO`类如下触发：'
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Explaining the business-object pattern
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释业务对象模式
- en: As the name suggests, a business object represents something in the real world
    and something associated with the business of the application. A business object
    is like an actor in an application use case. Examples of business objects include
    bank accounts, car insurance, college professors, students, employees, purchase
    orders, and payable or receivable accounts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，业务对象代表现实世界中的某些事物以及与应用程序业务相关的事物。业务对象就像应用程序用例中的参与者。业务对象的例子包括银行账户、汽车保险、大学教授、学生、员工、采购订单以及应付或应收账款。
- en: When it comes to simple applications with very little business complexity, that
    is, with few (or no) business rules, there may not be a need for a BO in the system.
    Better yet, a POJO entity that represents a database entity can be considered
    a BO. It is important to see the difference here. An entity or a POJO representative
    of an entity (such as a JPA POJO ) is closer to the technology and structure than
    to a business-model object. So, for this example, an entity such as a college
    student can also be considered a BO or an actor of a *college student* use case.
    In fact, in these simpler cases where the data model is sufficient for the business,
    there is no need to define a business object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到具有非常少业务复杂性的简单应用程序时，也就是说，具有很少（或没有）业务规则时，系统中可能不需要BO。更好的是，可以认为代表数据库实体的POJO实体就是一个BO。在这里看到区别很重要。一个实体或实体的POJO代表（如JPA
    POJO）比业务模型对象更接近技术和结构。因此，在这个例子中，一个如大学生这样的实体也可以被认为是一个BO或*大学生*用例的参与者。实际上，在这些更简单的案例中，数据模型足以满足业务需求，因此不需要定义业务对象。
- en: In this case, we say that the data model related to the college student closely
    represents the conceptual domain model related to the student.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们说与大学生相关的数据模型紧密代表了与学生相关的概念域模型。
- en: The application is often so simple that business-tier clients, such as a Session Façade
    (or even presentation-tier clients), can directly access the data model through
    DAO. There is no need for a model object to handle greater complexity for the
    application business.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常非常简单，以至于业务层客户端，如Session Façade（甚至表示层客户端），可以直接通过DAO访问数据模型。不需要模型对象来处理应用程序业务中的更大复杂性。
- en: Applications with complex business rules
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有复杂业务规则的程序
- en: Let's say that we want to increase the complexity of the system (let's say the
    system needs to contain more functions, for example). Let's also imagine that
    a college has members that consist of professors, employees, and students. Suppose
    there is a `member` entity that almost matches the `member` table in the related
    database. In addition, we know that professors, students, and employees are members
    of the college, and for that reason, they have common characteristics that every
    member should have. However, the professor, student, and employee also have their
    own characteristics. A professor's main characteristics are that they are a member
    who teaches and has a Masters or PhD qualification.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要增加系统的复杂性（比如说系统需要包含更多功能）。让我们再想象一下，一个大学有由教授、员工和学生组成的成员。假设有一个`member`实体，它几乎与相关数据库中的`member`表相匹配。此外，我们知道教授、学生和员工都是大学的成员，因此他们具有每个成员都应该拥有的共同特征。然而，教授、学生和员工也有他们自己的特征。教授的主要特征是他们是一位教授并拥有硕士或博士学位的成员。
- en: Similarly, a student has their own characteristics, such as enrollment in college
    and the number of courses they are enrolled in. Professors and students will both also have
    relationships with other entities. For this, we can architect the application
    in terms of the database and create four tables—`Member`, `Student`, `Employee`,
    and `Professor`. We can establish a one-to-one relationship between `Student`
    and `Member`, `Professor` and `Member`, and also `Employee` and `Member`. In any
    implementation, we can have four JPA entities related to these tables.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，学生也有他们自己的特征，例如大学入学和注册的课程数量。教授和学生都将与其它实体有联系。为此，我们可以从数据库的角度来架构应用程序，创建四个表——`Member`、`Student`、`Employee`
    和 `Professor`。我们可以在 `Student` 和 `Member`、`Professor` 和 `Member` 以及 `Employee`
    和 `Member` 之间建立一对一的关系。在任何实现中，我们都可以有与这些表相关的四个 JPA 实体。
- en: 'However, a professor is an actor of the *teaches discipline* use case with
    some business rules. This more complex `professor` object combines the `Member`
    and `Professor` entities. We can then define a `ProfessorBO` (business object)
    object, which is the combination of the `Member` with `Professor`. In addition,
    `ProfessorBO` may have methods that provide a richer behavioral value for the
    object because these methods are used in the use case. Without such methods, the
    object becomes an anemic object. However, it could be said that this is still
    a relatively low complexity. Consequently, we can think of a use case that shows
    all the disciplines taught by a professor, or a professor''s skills that are necessary
    to teach particular disciplines. Here, we have another table and entity: `Discipline`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，教授是具有一些业务规则的 *teaches discipline* 用例的演员。这个更复杂的 `professor` 对象结合了 `Member`
    和 `Professor` 实体。然后我们可以定义一个 `ProfessorBO`（业务对象）对象，它是 `Member` 与 `Professor` 的结合。此外，`ProfessorBO`
    可能具有提供更丰富行为价值的方法，因为这些方法在用例中使用。没有这些方法，对象就变成了贫血对象。然而，可以说这仍然是一个相对较低复杂度的。因此，我们可以考虑一个用例，展示教授教授的所有学科，或者教授教授特定学科所需的技能。在这里，我们还有一个表和实体：`Discipline`。
- en: 'In addition, a student is related to a particular course. This is another use
    case with one more entity: `Course`. The possibilities conceived for an academic
    system are innumerable and are far from being a simple data-model system. Business
    objects can be used for complex use cases.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，学生与特定的课程有关联。这是一个具有一个更多实体的用例：`Course`。学术系统的可能性是无限的，并且远远不是一个简单的数据模型系统。业务对象可以用于复杂用例。
- en: 'The following diagram shows the **Professor**, **Student**, and **Employee**
    as more complex objects:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了 **Professor**、**Student** 和 **Employee** 作为更复杂的对象：
- en: '![](img/ab30f7bb-1fe2-4e90-809e-3b72e9b34786.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab30f7bb-1fe2-4e90-809e-3b72e9b34786.png)'
- en: This scenario is just one of several possible implementations. In our small
    example, we consider the existence of an object called `ProfessorBO`, which uses
    three entities (**Professor**, **Member**, and **Discipline**) and has associated
    business methods.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景只是几种可能的实现方式之一。在我们的小型示例中，我们考虑了存在一个名为 `ProfessorBO` 的对象，它使用三个实体（**Professor**、**Member**
    和 **Discipline**）并且具有相关的业务方法。
- en: One could argue that there would be no need to have `ProfessorBO`. We could
    have a Professor Facade that could implement the Session Façade pattern with business
    methods and would also manipulate the different combined entities using a DAO
    (for the execution of CRUD operations).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争论说，没有必要有 `ProfessorBO`。我们可以有一个教授外观（Professor Facade），它可以实现会话外观（Session
    Façade）模式，使用业务方法，并且还会使用 DAO（用于执行 CRUD 操作）来操作不同的组合实体。
- en: We can agree with this architecture and, depending on the complexity of the
    system, it may even be the best alternative. However, we chose this architecture,
    which clearly illustrates the definition and use of the BO pattern, so let's continue
    with our example.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同意这种架构，并且根据系统的复杂性，它甚至可能是最佳选择。然而，我们选择了这种架构，它清楚地说明了 BO 模式的定义和使用，所以让我们继续我们的例子。
- en: Therefore, a `ProfessorBO` object represents a professor who is an actor for
    one or more use cases related to the conceptual professor model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个 `ProfessorBO` 对象代表了一位教授，这位教授是针对与概念教授模型相关的一个或多个用例的演员。
- en: Motivation for using the business-object pattern
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用业务对象模式的动机
- en: Whenever the conceptual model involves a greater complexity, we use the business-object
    pattern. This high complexity may be because the BO uses a combination of other
    objects and has complex business logic, such as validation rules. So, separating
    this business logic from the rest of the application is required (data persistence
    would be an example of this).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当概念模型涉及更大的复杂性时，我们使用业务对象模式。这种高复杂性可能是因为 BO 使用了其他对象的组合，并且具有复杂的业务逻辑，例如验证规则。因此，需要将此业务逻辑从应用程序的其他部分分离出来（数据持久性就是一个例子）。
- en: Not implementing this pattern can lead to problems, such as reducing code reusability.
    As a consequence of this, there are several possible solutions that make code
    maintenance time-consuming, as it would lose the uniformity that comes with using
    design patterns.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 不实现此模式可能导致问题，例如降低代码的可重用性。因此，有几种可能的解决方案，这些解决方案会使代码维护变得耗时，因为它会失去使用设计模式带来的统一性。
- en: Benefits of business-object pattern usage
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务对象模式使用的优点
- en: 'Here is a summary of the benefits of the business-object pattern:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是业务对象模式的优点总结：
- en: BOs are responsible for managing their business rules and persistence. This
    leads to a more reusable code. Clients access BOs that are fully responsible for
    the behavior of the application. In our example, `ProfessorBO` can be called from
    several points. As well as being reusable, there is a uniformity of behavior.
    As a consequence, another benefit is faster and more efficient maintenance.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BOs 负责管理其业务规则和持久性。这导致代码更具可重用性。客户端访问完全负责应用程序行为的 BOs。在我们的例子中，`ProfessorBO` 可以从多个点调用。除了可重用性之外，还有行为的一致性。因此，另一个好处是更快、更高效的维护。
- en: BOs are responsible for separating the business logic from the rest of the application,
    which increases the cohesion of the code (separation of responsibilities).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BOs 负责将业务逻辑与应用程序的其他部分分离，这增加了代码的凝聚力（责任分离）。
- en: BOs help separate business logic from data persistence.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BOs 有助于将业务逻辑与数据持久性分离。
- en: 'The following is the class diagram for the business-object pattern:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是业务对象模式的类图：
- en: '![](img/04bf7e64-db2a-4c58-963f-5f34010a467e.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04bf7e64-db2a-4c58-963f-5f34010a467e.png)'
- en: For more complex applications, we typically have a Session Façade that represents
    a set of related use cases. As we have already seen, the Session Façade offers
    high-level methods for clients. For its part, the Session Façade can manage and
    combine BOs that act as real agents or representatives of real-world objects.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的应用，我们通常有一个表示一组相关用例的 Session Façade。正如我们已经看到的，Session Façade 为客户端提供了高级方法。对于其本身，Session
    Façade 可以管理和组合充当真实代理或真实世界对象代表的 BOs。
- en: 'The following is the **Business Object** sequence diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 **业务对象** 的序列图：
- en: '![](img/26873cb7-12a5-45dc-8bca-7244e8cbe5db.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26873cb7-12a5-45dc-8bca-7244e8cbe5db.png)'
- en: Implementing the business-object pattern
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现业务对象模式
- en: We are now going to input some code in order to illustrate the business-object
    pattern. However, we must again pay attention to the fact that there is likely another
    approach to getting the results. For instance, we could use an O-R Mapping (JPA
    or Hibernate technology) to map the entities.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将输入一些代码来展示业务对象模式。然而，我们必须再次注意，可能还有其他方法可以得到结果。例如，我们可以使用 O-R 映射（JPA 或 Hibernate
    技术）来映射实体。
- en: As an example, the `Professor` entity has an *n*-to-*n* relationship with the
    `Discipline` entity, which is done with a JPA annotation. However, we know that
    there are many more use cases here than simply mapping entities.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Professor` 实体与 `Discipline` 实体之间存在 *n*-to-*n* 的关系，这是通过 JPA 注解实现的。然而，我们知道这里的使用案例远不止映射实体那么简单。
- en: We will use `ProfessorBO`, `Professor`, `Discipline`, `ProfessorDAO`, and `DisciplineDAO`.
    Let's take advantage of the classes shown in the Session Façade example. We made
    a small change in the `AcademicFacadeImpl` class. Now, this Session Façade uses
    a BO called `ProfessorBO` to handle the business related to `Professor`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `ProfessorBO`、`Professor`、`Discipline`、`ProfessorDAO` 和 `DisciplineDAO`。让我们利用
    Session Façade 示例中展示的类。我们在 `AcademicFacadeImpl` 类中做了一些小的改动。现在，这个 Session Façade
    使用一个名为 `ProfessorBO` 的 BO 来处理与 `Professor` 相关的业务。
- en: 'Let''s review the `ProfessorBO` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 `ProfessorBO` 类：
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s also have a look at the `AcademicFacadeImpl` class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看 `AcademicFacadeImpl` 类：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we can see in the preceding code block, the `AcademicFacadeImpl` Session
    Façade calls the `canTeachDiscipline` method from the `ProfessorBO` injected bean. `ProfessorBO`
    then uses `ProfessorDAO` and `DisciplineDAO`. Next, we will see the part of the
    `DisciplineDAO` code that is used by the `ProfessorBO` bean:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码块所示，`AcademicFacadeImpl`会话外观从注入的`ProfessorBO`豆中调用`canTeachDiscipline`方法。然后`ProfessorBO`使用`ProfessorDAO`和`DisciplineDAO`。接下来，我们将看到`ProfessorBO`豆使用的`DisciplineDAO`代码部分：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s see the code used by the `ProfessorDAO` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ProfessorDAO`类使用的代码：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, let''s see the `ProfessorBO` class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`ProfessorBO`类：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the fact that the main objective of the Business
    Delegate is to hide the details of service implementations from the presentation
    tier. We have also seen that, in some situations, its use has been replaced by
    CDI technology (this technology is responsible for injecting components into a
    typesafe way application, such as injecting an EJB component), but we believe
    that this is not enough. The Business Delegate is still widely used in the treatment
    of more technical exceptions—for example, when it has remote EJB calls. In addition,
    the delegate protects the presentation tier from possible changes in the service
    layer, and conversely, when there are types of clients other than a web browser,
    using a delegate makes it easier for these new clients to access services.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了业务代表的主要目标是隐藏服务实现的细节，以避免展示层。我们还看到，在某些情况下，其使用已被CDI技术（这种技术负责以类型安全的方式将组件注入到应用程序中，例如注入EJB组件）所取代，但我们认为这还不够。业务代表在处理更技术性的异常方面仍然被广泛使用——例如，当有远程EJB调用时。此外，代表保护展示层免受服务层可能的变化的影响，反之亦然，当有除网页浏览器之外的其他类型客户端时，使用代表使这些新客户端访问服务变得更加容易。
- en: Session Façade centralizes business logic without exposing complex interactions
    that involve business objects to the client side. In addition, Session Façade
    encapsulates business-tier components and exposes coarse-grained services to both
    local and remote clients. Consequently, the clients access a Session Façade instead
    of directly accessing the business components. Some services, such as transaction-control
    or security-management, are addressed using Session Façade implementations, such
    as EJBs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 会话外观集中了业务逻辑，同时不向客户端暴露涉及业务对象的复杂交互。此外，会话外观封装了业务层组件，并向本地和远程客户端暴露粗粒度服务。因此，客户端访问会话外观而不是直接访问业务组件。一些服务，如事务控制或安全管理，使用会话外观实现，例如EJB。
- en: The business-object pattern must be used whenever an application presents a
    high level of complexity. This may include when the representation of real-world
    objects cannot be translated merely as a data-model object, and there is, therefore,
    a need for reusability and uniformity in business solutions. Aside from reusability,
    the immediate benefit of this includes efficient code maintenance and a rich cohesion
    between layers caused by the separation of responsibilities. This is because the
    business objects separate business logic and persistence from the rest of the
    application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序呈现高度复杂性时，必须使用业务对象模式。这可能包括当现实世界对象的表示不能仅仅作为数据模型对象来翻译，因此需要业务解决方案的可重用性和一致性时。除了可重用性之外，这种模式的直接好处包括高效的代码维护以及由于职责分离而产生的层之间的丰富凝聚力。这是因为业务对象将业务逻辑和持久性从应用程序的其他部分分离出来。
