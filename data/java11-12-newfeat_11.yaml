- en: Flight Recorder and Mission Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞行记录器和任务控制
- en: '**Java Flight Recorder** (**JFR**) is a high-performance, low-overhead profiler
    that is built into the JVM. It is a data collection framework that records events
    that you can use to troubleshoot your Java applications and HotSpot JVM.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java Flight Recorder**（**JFR**）是一个内置在JVM中的高性能、低开销的剖析器。它是一个数据收集框架，可以记录你可以用来调试你的Java应用程序和HotSpot
    JVM的事件。'
- en: JFR records the events from OS, HotSpot JVM, and JDK binary events as **binary
    data**. This essentially means that you need a parser, such as **Mission Control**
    (**MC**), to make sense of this binary data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JFR记录来自操作系统、HotSpot JVM和JDK二进制事件的**二进制数据**。这本质上意味着你需要一个解析器，例如**Mission Control**（**MC**），来理解这些二进制数据。
- en: MC is an advanced tool for program developers and administrators to analyze
    the data collected by the JFR profiler in detail. It can be used to analyze the
    data collected for applications running in local or remote environments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: MC是一个高级工具，用于程序开发人员和管理员详细分析JFR剖析器收集的数据。它可以用来分析在本地或远程环境中运行的应用程序收集的数据。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The need for JFR and MC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要JFR和MC的原因
- en: Features of JFR and MC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JFR和MC的特点
- en: Usage of JFR and MC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JFR和MC的使用
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: JFR is included in the OpenJDK distributions from Java 11\. Depending on which
    JDK distribution you are using, you might need to download and install MC separately.
    **Java Mission Control** (**JMC**) is not part of the OpenJDK distribution. It
    has been a part of OracleJDK since JDK version 7, update 40.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 11开始，JFR包含在OpenJDK发行版中。根据你使用的JDK发行版，你可能需要单独下载和安装MC。**Java Mission Control**（**JMC**）不是OpenJDK发行版的一部分。它自JDK版本7更新40以来一直是OracleJDK的一部分。
- en: If JMC is not included in your JDK, you can download it from [https://jdk.java.net/jmc/](https://jdk.java.net/jmc/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JMC没有包含在你的JDK中，你可以从[https://jdk.java.net/jmc/](https://jdk.java.net/jmc/)下载它。
- en: All code in this chapter can be accessed from [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码都可以从[https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)访问。
- en: Let's get started with exploring why we need JFR.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索为什么我们需要JFR。
- en: The motivation behind JFR
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JFR背后的动机
- en: Vaults at banks are created with near zero defects, but they aren't invincible.
    Imagine what happens after the vault of a bank is broken. One of the steps might
    include scanning the security camera footage—to check *when* and *how* the theft
    happened. This can lead to varied results—from determining the cause of fixing
    the issues and formulating measures to prevent it from happening in the future.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 银行的保险库几乎零缺陷地创建，但它们并不是不可战胜的。想象一下银行保险库被破坏后会发生什么。可能的一个步骤包括扫描安全摄像头录像——以检查盗窃发生的时间和方式。这可能导致各种结果——从确定问题的原因和制定预防措施以防止其再次发生。
- en: Similarly, you can never foresee all the challenges with your application in
    production. A profiler, such as JFR, helps you to record the events when your
    application is executing. When your application crashes or doesn't perform as
    expected, you can monitor or troubleshoot it, using the data collected by the
    profiler. This data can provide you with the feedback loop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你永远无法预见你的应用程序在生产中可能遇到的所有挑战。一个剖析器，如JFR，可以帮助你在应用程序执行时记录事件。当你的应用程序崩溃或未按预期执行时，你可以使用剖析器收集的数据来监控或调试它。这些数据可以为你提供反馈循环。
- en: MC reads the application profiling data recorded by JFR and displays it *visually*,
    on varied values (hence saving you from wading through piles of text).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: MC读取由JFR记录的应用程序分析数据，并以**视觉化**的方式显示，在多个值上（因此可以节省你从大量文本中筛选信息）。
- en: Features
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特点
- en: JFR can record a whole lot of events—from your applications to your JVM to the
    OS. It is a high performance, but low overhead profiler.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JFR可以记录大量事件——从你的应用程序到你的JVM到操作系统。它是一个高性能但低开销的剖析器。
- en: JFR extends the capabilities of **event-based JVM tracing** (JEP 167), which
    adds an initial set of events to HotSpot, to create events in Java. It also provides
    a high-performance backend to write data from the events to a binary format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: JFR扩展了基于事件的JVM跟踪（JEP 167）的功能，为HotSpot添加了一组初始事件以在Java中创建事件。它还提供了一个高性能的后端，将事件数据写入二进制格式。
- en: MC displays the application profiling data collected by JFR in a visual environment.
    You can select the category you want to analyze—from class loading to JVM internals
    (such as garbage collection), application threads, memory allocation, to complete
    application data analysis. We'll work with some of the MC features in this chapter
    (complete coverage of all of its features is beyond the scope of this book).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MC 在可视化环境中显示由 JFR 收集的应用程序分析数据。您可以选择您想要分析的分类——从类加载到 JVM 内部（如垃圾回收），应用程序线程，内存分配，到完整的应用程序数据分析。我们将在本章中介绍一些
    MC 功能（对所有功能的完整覆盖超出了本书的范围）。
- en: Modules
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: 'JFR defines the following modules:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JFR 定义了以下模块：
- en: '`jdk.jfr`: This defines the API and internals for the JFR profiler. You can
    use it to profile your applications that run on resource-constrained devices such
    as the **IoT** (short for **Internet of Things**) or mobile devices. `Jdk.jfr`
    only needs the `java.base` module.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.jfr`：这定义了 JFR 分析器的 API 和内部结构。您可以使用它来分析在资源受限设备上运行的应用程序，例如 **IoT**（物联网的简称）或移动设备。`Jdk.jfr`
    只需要 `java.base` 模块。'
- en: '`jdk.management.jfr`: To use flight recording remotely over **Java Management
    Extensions** (**JMX**), you can use this module. It requires the `jdk.jfr` and
    `jdk.management` modules.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdk.management.jfr`：要使用 **Java 管理扩展（JMX**）远程使用飞行记录，您可以使用此模块。它需要 `jdk.jfr`
    和 `jdk.management` 模块。'
- en: We won't cover the code of JMC, just its features and how to use them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会介绍 JMC 的代码，只会介绍其功能和如何使用它们。
- en: Getting started with JFR
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 JFR
- en: 'Let''s get started with a simple `HelloWorld` example, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的 `HelloWorld` 示例开始，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To start flight recording for the preceding application, execute the following
    command on your console:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要为前面的应用程序启动飞行记录，请在您的控制台执行以下命令：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line instructs the Java Runtime to start flight recording for your
    `HelloWorld` application and save it to the `HelloWorldRecording.jfr` file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行指示 Java 运行时为您的 `HelloWorld` 应用程序启动飞行记录并将其保存到 `HelloWorldRecording.jfr` 文件。
- en: 'There are three parts to the previous command, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令有三个部分，如下所示：
- en: Starting JFR with the `-XX:StartFlightRecording` JVM option
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-XX:StartFlightRecording` JVM 选项启动 JFR
- en: Specifying the target file to save the recording to `hello.jfr`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定要保存记录的目标文件 `hello.jfr`
- en: Specifying the application to run `HelloWorld`
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定要运行的 `HelloWorld`
- en: 'Let''s start MC to view the profiling data stored in `hello.jfr`. Use the `jmc.exe`
    file to start JMC. You''ll see a window similar to the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动 MC 来查看存储在 `hello.jfr` 中的分析数据。使用 `jmc.exe` 文件启动 JMC。您将看到一个类似于以下屏幕截图的窗口：
- en: '![](img/b06ed055-bc05-4aa2-af2b-759c0bea5d06.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b06ed055-bc05-4aa2-af2b-759c0bea5d06.png)'
- en: 'Click on the Click here to start using JDK Mission Control option at the bottom.
    Using the File | Open menu options, open the `hello.jfr` file you previously created.
    Here''s what it displays at the Automated Analysis Results landing page:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 点击底部的“点击此处开始使用 JDK Mission Control”选项。使用文件 | 打开菜单选项，打开您之前创建的 `hello.jfr` 文件。以下是它在“自动分析结果”登录页面上的显示内容：
- en: '![](img/c7413d7b-d5b6-446a-b412-8d95df0103d0.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7413d7b-d5b6-446a-b412-8d95df0103d0.png)'
- en: Processes are not the only category on which MC analyzes your application. Depending
    on your application and how it is profiled, additional categories are included
    (you can see a few of them in the preceding screenshot).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: MC 分析应用程序的类别不仅限于进程。根据您的应用程序及其分析方式，还包括其他类别（您可以在前面的屏幕截图中看到其中的一些）。
- en: Exploring further
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索
- en: 'Let''s profile another application that creates a lot of (`500`) threads; each
    thread creates `ArrayList` of 1,000,000 `Double` values, populating it with random
    numbers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析另一个创建大量（500）线程的应用程序；每个线程创建一个包含 1,000,000 个 `Double` 值的 `ArrayList`，并用随机数填充它：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s execute the preceding `TestFlightRecorder` application, profiling it
    with JFR using Epsilon GC (to check whether we also get any data on the memory
    allocation) for 10 seconds:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行前面的 `TestFlightRecorder` 应用程序，使用 Epsilon GC（以检查我们是否也能获得有关内存分配的数据）进行 10
    秒的配置文件分析：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s the landing page when you open `Epsilon.jfr` in MC:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 MC 中打开 `Epsilon.jfr` 时，这是登录页面：
- en: '![](img/0dcd6516-9ee2-4eec-b9ea-14c8c2d2c0b9.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0dcd6516-9ee2-4eec-b9ea-14c8c2d2c0b9.png)'
- en: Before we discuss the results shown by MC in detail, let's quickly revisit the
    `TestFlightRecorder` application that was profiled. `TestFlightRecorder` creates
    500 instances of the `AThread` class. The `AThread` class implements `Runnable`.
    On starting, each `AThread` instance creates `ArrayList` of 1,000,000 `Double`
    values, populates them with random values and outputs them to the console.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细讨论MC显示的结果之前，让我们快速回顾一下被性能分析的`TestFlightRecorder`应用程序。`TestFlightRecorder`创建了500个`AThread`类的实例。`AThread`类实现了`Runnable`接口。在启动时，每个`AThread`实例创建了一个包含1,000,000个`Double`值的`ArrayList`，用随机值填充它们并将它们输出到控制台。
- en: 'Let''s visit the preceding screenshot now—MC displays a consolidated report
    on how your application fares overall. It includes the environment of the machine
    that is executing your Java application, the JVM internals, and blocking of threads
    on locks in your application. Here''s a quick listing of these categories:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看前面的截图——MC显示了关于您的应用程序整体表现的汇总报告。它包括执行Java应用程序的机器的环境、JVM内部信息以及应用程序中线程在锁上的阻塞情况。以下是这些类别的快速列表：
- en: Java Application
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java应用程序
- en: Context Switches (indent)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文切换（缩进）
- en: Java Blocking (indent)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java阻塞（缩进）
- en: JVM Internals
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM内部
- en: Environment
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境
- en: 'Since MC reports that this application is performing poorly on the Context
    Switches and thread blocking categories, let''s browse through the options under
    the Java Application category on the left-side panel menu in MC and figure out
    which option will include the relevant information. As you will notice, the Lock
    Instances option displays an exclamation mark right next to it. The following
    screenshot indicates what you will see when you click on it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MC报告称此应用程序在上下文切换和线程阻塞类别中表现不佳，让我们浏览MC左侧面板菜单中Java应用程序类别下的选项，找出哪个选项将包含相关信息。正如您将注意到的，锁实例选项旁边显示了一个感叹号。以下截图显示了您点击它时将看到的内容：
- en: '![](img/bd8022f4-20c7-4fee-a25b-fdf927d52134.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd8022f4-20c7-4fee-a25b-fdf927d52134.png)'
- en: The preceding screenshot shows that all 500 threads that you created in the
    `TestFlightRecorder` application were blocking on `PrintStream` and `Object`.
    It even displays the total blocked time, that is, 2 hours and 40 minutes (calculated
    collectively for all blocked threads—for 20 seconds of application profiling).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示，在`TestFlightRecorder`应用程序中创建的所有500个线程都在`PrintStream`和`Object`上阻塞。它甚至显示了总的阻塞时间，即2小时40分钟（为所有阻塞线程共同计算，针对20秒的应用程序性能分析）。
- en: Since the JFR profiler records the profiled data in a binary format to a file,
    you can view this data with MC at a later time and figure out a whole lot of other
    issues. For instance, if you click on Processes, you'll know that your CPU is
    being used by a lot of other processes that are being executed on your host machine,
    which can also include auto software updates. Make sure you switch all of these
    off. Let's say you are tuning the performance of your application on the server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JFR分析器将性能分析数据以二进制格式记录到文件中，您可以在以后使用MC查看这些数据，并找出许多其他问题。例如，如果您点击进程，您将知道您的CPU被许多在您的宿主机器上执行的其他进程所使用，这也可以包括自动软件更新。确保您关闭所有这些。假设您正在服务器上调整应用程序的性能。
- en: 'Here''s what you see if you click on Processes in MC (of course, the results
    will vary across systems):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在MC中点击进程（当然，结果将因系统而异）：
- en: '![](img/9d816b66-3332-4b5f-87a1-fdbc9e91850b.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d816b66-3332-4b5f-87a1-fdbc9e91850b.png)'
- en: Working with custom events
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义事件
- en: 'As a developer, you can also create your own custom events using the JFR API
    and view and analyze them using MC. Here''s an example; let''s define a custom
    event:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，您也可以使用JFR API创建自己的自定义事件，并使用MC查看和分析它们。以下是一个示例；让我们定义一个自定义事件：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s modify the `AThread` class to use events, instead of printing to
    console:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改`AThread`类以使用事件，而不是打印到控制台：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can use the same command line options to execute your application, profiling
    it with JFR:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的命令行选项来执行应用程序，并使用JFR进行性能分析：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, instead of using MC to view these events, you can create another application
    that reads the logged events from `CustomEvents.jfr`, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您不再使用MC来查看这些事件，而是可以创建另一个应用程序，读取从`CustomEvents.jfr`记录的事件，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Summary
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the JFR profiler. With JFR, a high performance,
    low overhead profiler, built into the JVM, you won't need to rely on third-party
    profilers to troubleshoot your Java applications and HotSpot JVM.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了JFR分析器。使用内置在JVM中的高性能、低开销的JFR分析器，你无需依赖第三方分析器来调试你的Java应用程序和HotSpot JVM。
- en: We also covered MC—an advanced tool for developers and administrators to analyze
    the data collected by JFR in detail—visually, in local and remote environments.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了MC——一个高级工具，供开发人员和管理员详细分析JFR收集的数据——在本地和远程环境中进行可视化分析。
- en: In the next chapter, we'll cover multiple improvements and additions in JDK
    11.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍JDK 11中的多个改进和新增功能。
