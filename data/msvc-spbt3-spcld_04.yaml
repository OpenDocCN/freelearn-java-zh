- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Deploying Our Microservices Using Docker
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 部署我们的微服务
- en: In this chapter, we will start using Docker and put our microservices into containers!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用 Docker 并将我们的微服务放入容器中！
- en: By the end of this chapter, we will have run fully automated tests of our microservice
    landscape that start all our microservices as Docker containers, requiring no
    infrastructure other than Docker Engine. We will also have run a number of tests
    to verify that the microservices work together as expected, and finally, shut
    down all the microservices, leaving no traces of the tests we executed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将运行完全自动化的微服务测试，这些测试将启动所有微服务作为 Docker 容器，除了 Docker 引擎外不需要任何基础设施。我们还将运行一系列测试以验证微服务按预期协同工作，最后关闭所有微服务，不留任何我们执行的测试痕迹。
- en: Being able to test a number of cooperating microservices in this way is very
    useful. As developers, we can verify that the microservices work on our local
    developer machines. We can also run exactly the same tests in a build server to
    automatically verify that changes to the source code won’t break the tests at
    a system level. Additionally, we don’t need to have a dedicated infrastructure
    allocated to run these types of tests. In the upcoming chapters, we will see how
    we can add databases and queue managers to our test landscape, all of which will
    run as Docker containers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 能够以这种方式测试多个协作的微服务非常有用。作为开发者，我们可以验证微服务在我们本地的开发者机器上是否正常工作。我们还可以在构建服务器上运行完全相同的测试，以自动验证源代码的更改不会在系统级别破坏测试。此外，我们不需要为运行这些类型的测试分配专门的基础设施。在接下来的章节中，我们将看到如何将数据库和队列管理器添加到我们的测试环境中，所有这些都将作为
    Docker 容器运行。
- en: This does not, however, replace the need for automated unit and integration
    tests, which test individual microservices in isolation. They are as important
    as ever.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不能取代自动单元和集成测试的需求，这些测试在隔离的情况下测试单个微服务。它们和以前一样重要。
- en: For production usage, as we mentioned earlier in this book, we need a container
    orchestrator such as Kubernetes. We will get back to container orchestrators and
    Kubernetes later in this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产使用，正如我们在本书中之前提到的，我们需要一个容器编排器，如 Kubernetes。我们将在本书的后面部分回到容器编排器和 Kubernetes。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to Docker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 简介
- en: Docker and Java – Java hasn’t been very friendly to containers historically,
    but that changed with Java 10, so let’s see how Docker and Java fit together
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 和 Java – 历史上，Java 对容器的友好度并不高，但这种情况在 Java 10 中发生了变化，因此让我们看看 Docker 和 Java
    如何结合在一起
- en: Using Docker with one microservice
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 与单个微服务
- en: Managing a landscape of microservices using Docker Compose
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 管理微服务景观
- en: Automating tests of cooperating microservices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化协作微服务的测试
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 21 章*，*macOS 安装说明*'
- en: '*Chapter 22,* *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 22 章*，*使用 WSL 2 和 Ubuntu 的 Microsoft Windows 安装说明*'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter04`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例全部来自 `$BOOK_HOME/Chapter04` 的源代码。
- en: If you want to see the changes that were applied to the source code in this
    chapter, that is, see what it took to add support for Docker, you can compare
    it with the source code for *Chapter 3*, *Creating a Set of Cooperating Microservices*.
    You can use your favorite `diff` tool and compare the two folders, `$BOOK_HOME/Chapter03/2-basic-rest-services`
    and `$BOOK_HOME/Chapter04`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章源代码中应用的变化，即查看添加 Docker 支持所需的工作，你可以将其与 *第 3 章*，*创建一组协作微服务* 的源代码进行比较。你可以使用你喜欢的
    `diff` 工具比较两个文件夹，`$BOOK_HOME/Chapter03/2-basic-rest-services` 和 `$BOOK_HOME/Chapter04`。
- en: Introduction to Docker
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 简介
- en: 'As we already mentioned in *Chapter 2*, *Introduction to Spring Boot*, Docker
    made the concept of containers as a lightweight alternative to virtual machines
    very popular in 2013\. To quickly recap: containers are actually processed in
    a Linux host that uses **Linux namespaces** to provide isolation between containers,
    and **Linux Control Groups** (**cgroups**) are used to limit the amount of CPU
    and memory that a container is allowed to consume.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第 2 章*，*Spring Boot 简介* 中已经提到的，Docker 在 2013 年使容器作为轻量级虚拟机的替代方案的概念变得非常流行。为了快速回顾：容器实际上是在使用
    **Linux 命名空间**提供容器之间隔离的 Linux 主机上处理的，并且使用 **Linux 控制组**（**cgroups**）来限制容器可以消耗的
    CPU 和内存量。
- en: 'Compared to a virtual machine that uses a hypervisor to run a complete copy
    of an operating system in each virtual machine, the overhead in a container is
    a fraction of the overhead in a virtual machine. This leads to much faster startup
    times and a significantly lower footprint. Containers are, however, not considered
    to be as secure as virtual machines. Take a look at the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用虚拟机管理程序在每个虚拟机中运行操作系统的完整副本的虚拟机相比，容器中的开销只是虚拟机开销的一小部分。这导致启动时间更快，占用空间显著降低。然而，容器并不被认为像虚拟机那样安全。看看下面的图示：
- en: '![](img/B19825_04_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19825_04_01.png)'
- en: 'Figure 4.1: Virtual machines versus containers'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：虚拟机与容器对比
- en: The diagram illustrates the difference between the resource usage of virtual
    machines and containers, demonstrating that the same type of server can run significantly
    more containers than virtual machines. The main gain is that a container doesn’t
    need to run its own instance of an operating system as a virtual machine does.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该图说明了虚拟机和容器之间的资源使用差异，表明同一类型的服务器可以运行比虚拟机多得多的容器。主要的好处是容器不需要像虚拟机那样运行自己的操作系统实例。
- en: Running our first Docker commands
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的第一个 Docker 命令
- en: 'Let’s try to start a container by launching an Ubuntu server using Docker’s
    `run` command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过使用 Docker 的 `run` 命令启动 Ubuntu 服务器来启动一个容器：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the preceding command, we ask Docker to create a container that runs Ubuntu,
    based on the latest version that’s available of the official Docker image for
    Ubuntu. The `-it` option is used so that we can interact with the container using
    Terminal, and the `--rm` option tells Docker to remove the container once we exit
    the Terminal session; otherwise, the container will remain in Docker Engine with
    an `Exited` state.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们要求 Docker 创建一个运行 Ubuntu 的容器，基于官方 Docker 镜像中可用的最新版本。使用 `-it` 选项是为了我们可以使用终端与容器进行交互，而
    `--rm` 选项告诉 Docker 在我们退出终端会话后删除容器；否则，容器将保持 Docker 引擎中的 `Exited` 状态。
- en: The first time we use a Docker image that we haven’t built ourselves, Docker
    will download it from a Docker registry, which is Docker Hub by default ([https://hub.docker.com](https://hub.docker.com)).
    This will take some time, but for subsequent usage of that Docker image, the container
    will start in just a few seconds!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用我们未自行构建的 Docker 镜像时，Docker 将从默认的 Docker 仓库（Docker Hub）下载它（[https://hub.docker.com](https://hub.docker.com)）。这需要一些时间，但后续使用该
    Docker 镜像时，容器只需几秒钟就能启动！
- en: 'Once the Docker image has been downloaded and the container has been started
    up, the Ubuntu server should respond with a prompt such as the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载了 Docker 镜像并启动了容器，Ubuntu 服务器应该会响应如下提示：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_04_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_04_02.png)'
- en: 'Figure 4.2: Ubuntu server response'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：Ubuntu 服务器响应
- en: 'We can try out the container by, for example, asking what version of Ubuntu
    it runs:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过例如询问它运行的是哪个版本的 Ubuntu 来尝试容器：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It should respond with something like the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会响应如下：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_04_03.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B19825_04_03.png)'
- en: 'Figure 4.3: Ubuntu version response'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：Ubuntu 版本响应
- en: We can leave the container with an `exit` command and verify that the Ubuntu
    container no longer exits with the `docker ps -a` command. We need to use the
    `-a` option to see stopped containers; otherwise, only running containers are
    displayed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `exit` 命令退出容器，并使用 `docker ps -a` 命令验证 Ubuntu 容器不再退出。我们需要使用 `-a` 选项来查看已停止的容器；否则，只会显示正在运行的容器。
- en: If you favor CentOS over Ubuntu, feel free to try the same with the `docker
    run --rm -it centos` command.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢 CentOS 而不是 Ubuntu，你可以尝试使用 `docker run --rm -it centos` 命令。
- en: 'Once the CentOS server has started running in its container, you can, for example,
    ask what version of CentOS is running with the `cat /etc/redhat-release` command.
    It should respond with something like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 CentOS 服务器在其容器中开始运行，例如，你可以使用 `cat /etc/redhat-release` 命令来询问正在运行哪个版本的 CentOS。它应该会响应如下：
- en: '![Text  Description automatically generated](img/B19825_04_04.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_04_04.png)'
- en: 'Figure 4.4: CentOS version response'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：CentOS 版本响应
- en: Leave the container with the `exit` command to remove it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `exit` 命令离开容器以删除它。
- en: 'If, at some point, you find that you have a lot of unwanted containers in Docker
    Engine and you want to get a clean sheet, that is, get rid of them all, you can
    run the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个时候，你发现 Docker Engine 中有很多不想要的容器，并且你想从零开始，也就是说，删除它们所有，你可以运行以下命令：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `docker rm -f` command stops and removes the containers whose container
    IDs are specified by the command. The `docker ps -aq` command lists the container
    IDs of all the running and stopped containers in Docker Engine. The `-q` option
    reduces the output from the `docker ps` command so that it only lists the container
    IDs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker rm -f` 命令停止并删除由命令指定的容器 ID 的容器。`docker ps -aq` 命令列出 Docker Engine 中所有运行和停止的容器的容器
    ID。`-q` 选项减少了 `docker ps` 命令的输出，使其只列出容器 ID。'
- en: Now we’ve understood what Docker is, we can move on to learn how to run Java
    in Docker.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Docker 是什么，我们可以继续学习如何在 Docker 中运行 Java。
- en: Running Java in Docker
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Docker 中运行 Java
- en: Over the past few years, there have been a number of attempts to get Java working
    in Docker in a good way. Most importantly, Java hasn’t historically been very
    good at respecting limits set for Docker containers when it comes to the use of
    memory and CPU.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，已经尝试了多种方法来在 Docker 中以良好的方式运行 Java。最重要的是，Java 在历史上并不擅长尊重 Docker 容器中为内存和
    CPU 设置的限制。
- en: 'Currently, the official Docker image for Java comes from the **OpenJDK** project:
    [https://hub.docker.com/_/openjdk/](https://hub.docker.com/_/openjdk/). We will
    use an alternative Docker image from the **Eclipse** **Temurin** project. It contains
    the same binaries from the OpenJDK project but provides variants of the Docker
    images that meet our needs better than the Docker images from the OpenJDK project.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，官方的 Java Docker 镜像来自 **OpenJDK** 项目：[https://hub.docker.com/_/openjdk/](https://hub.docker.com/_/openjdk/)。我们将使用来自
    **Eclipse** **Temurin** 项目的替代 Docker 镜像。它包含来自 OpenJDK 项目的相同二进制文件，但提供了比 OpenJDK
    项目的 Docker 镜像更好地满足我们需求的变体。
- en: In this section, we will use a Docker image that contains the full **JDK** (**Java
    Development Kit**) with all its tools. When we start to package our microservices
    in Docker images in the *Using Docker with one microservice* section, we will
    use a more compact Docker image that is based on the **JRE** (**Java Runtime Environment**),
    only containing the Java tools required at runtime.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用包含完整 **JDK**（**Java 开发工具包**）及其所有工具的 Docker 镜像。当我们开始在“使用 Docker 与单个微服务”部分中打包我们的微服务到
    Docker 镜像时，我们将使用一个更紧凑的基于 **JRE**（**Java 运行时环境**）的 Docker 镜像，它只包含运行时所需的 Java 工具。
- en: As already mentioned, earlier versions of Java have not been very good at honoring
    the quotas specified for a Docker container using Linux cgroups; they simply ignored
    these settings.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Java 的早期版本并不擅长遵守使用 Linux cgroups 为 Docker 容器指定的配额；它们只是简单地忽略了这些设置。
- en: So, instead of allocating memory inside the JVM in relation to the memory available
    in the container, Java allocated memory as if it had access to all the memory
    in the Docker host. When trying to allocate more memory than allowed, the Java
    container was killed by the host with an “out of memory” error message. In the
    same way, Java allocated CPU-related resources such as thread pools in relation
    to the total number of available CPU cores in the Docker host, instead of the
    number of CPU cores that were made available for the container JVM was running
    in.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Java 不是根据容器中可用的内存来在 JVM 内部分配内存，而是像它有权访问 Docker 主机上的所有内存一样分配内存。当尝试分配比允许的更多的内存时，Java
    容器会被主机以“内存不足”的错误消息杀死。同样，Java 根据 Docker 主机上的总可用 CPU 核心数来分配与 CPU 相关的资源，如线程池，而不是根据为容器
    JVM 运行提供的 CPU 核心数。
- en: In Java SE 9, initial support for container-based CPU and memory constraints
    was provided, much improved in Java SE 10.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java SE 9中，提供了基于容器的CPU和内存限制的初始支持，在Java SE 10中得到了很大改进。
- en: Let’s look at how Java SE 17 responds to limits we set on a container it runs
    in!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Java SE 17对其运行的容器中设置的限制如何响应！
- en: In the following tests, we will run Docker Engine inside a virtual machine on
    a MacBook Pro, acting as the Docker host. The Docker host is configured to use
    **8 CPU** cores and **16 GB of memory**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的测试中，我们将在MacBook Pro上的虚拟机内部运行Docker引擎，充当Docker主机。Docker主机被配置为使用**8个CPU**核心和**16
    GB的内存**。
- en: We will start by seeing how we can limit the number of available CPUs to a container
    that runs Java. After that, we will do the same with limiting memory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看如何将可用的CPU数量限制在运行Java的容器中。之后，我们将对内存进行同样的限制。
- en: Limiting available CPUs
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制可用CPU
- en: 'Let’s start by finding out how many available processors (that is, CPU cores)
    Java sees without applying any constraints. We can do this by sending the Java
    statement `Runtime.getRuntime().availableprocessors()` to the Java CLI tool `jshell`.
    We will run `jshell` in a container using the Docker image that contains the full
    Java 17 JDK. The Docker tag for this image is `eclipse-temurin:17`. The command
    looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先找出Java在没有应用任何限制的情况下看到多少可用处理器（即CPU核心）。我们可以通过将Java语句`Runtime.getRuntime().availableprocessors()`发送到Java
    CLI工具`jshell`来实现。我们将使用包含完整Java 17 JDK的Docker镜像在容器中运行`jshell`。此镜像的Docker标签是`eclipse-temurin:17`。命令如下所示：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will send the string `Runtime.getRuntime().availableProcessors()`
    to the Docker container, which will process the string using `jshell`. We will
    get the following response:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将字符串`Runtime.getRuntime().availableProcessors()`发送到Docker容器，该容器将使用`jshell`处理该字符串。我们将得到以下响应：
- en: '![Text  Description automatically generated](img/B19825_04_05.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_04_05.png)'
- en: 'Figure 4.5: Response showing the number of CPU cores available'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：显示可用CPU核心数量的响应
- en: 'The response of `8` cores is as expected since the Docker host was configured
    to use 8 CPU cores. Let’s move on and restrict the Docker container to only be
    allowed to use three CPU cores using the `--cpus 3` Docker option, then ask the
    JVM about how many available processors it sees:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`8`核心的响应符合预期，因为Docker主机被配置为使用`8`个CPU核心。让我们继续，并使用`--cpus 3` Docker选项将Docker容器限制为只能使用三个CPU核心，然后询问JVM它看到了多少可用处理器：'
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The JVM now responds with `Runtime.getRuntime().availableProcessors()$1 ==>
    3`; that is, Java SE 17 honors the settings in the container and will, therefore,
    be able to configure CPU-related resources such as thread pools correctly!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JVM现在响应为`Runtime.getRuntime().availableProcessors()$1 ==> 3`；这意味着Java SE 17尊重容器中的设置，因此能够正确配置如线程池等CPU相关资源！
- en: Limiting available memory
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制可用内存
- en: 'In terms of the amount of available memory, let’s ask the JVM for the maximum
    size that it thinks it can allocate for the heap. We can achieve this by asking
    the JVM for extra runtime information using the `-XX:+PrintFlagsFinal` Java option
    and then using the `grep` command to filter out the `MaxHeapSize` parameter, like
    so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在可用内存的数量方面，让我们询问JVM它认为可以为堆分配的最大大小。我们可以通过使用`-XX:+PrintFlagsFinal` Java选项请求JVM额外的运行时信息，然后使用`grep`命令过滤出`MaxHeapSize`参数，如下所示：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With 16 GB of memory allocated to the Docker host, we will get the following
    response:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Docker主机分配了16 GB的内存后，我们将得到以下响应：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_04_06.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B19825_04_06.png)'
- en: 'Figure 4.6: Response showing MaxHeapSize'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：显示MaxHeapSize的响应
- en: With no JVM memory constraints (that is, not using the JVM parameter `-Xmx`),
    Java will allocate one-quarter of the memory available to the container for its
    heap. So, we expect it to allocate up to 4 GB to its heap. From the preceding
    screenshot, we can see that the response was 4,188,012,544 bytes. That equals
    *4,188,012,544 / 1024 / 1024* = 3,994 MB, which is close to the expected 4 GB.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有JVM内存限制（即不使用JVM参数`-Xmx`）的情况下，Java将为它的堆分配容器可用内存的四分之一。因此，我们预计它将为堆分配多达4 GB。从前面的屏幕截图可以看出，响应为4,188,012,544字节。这等于*4,188,012,544
    / 1024 / 1024* = 3,994 MB，接近预期的4 GB。
- en: 'If we constrain the Docker container to only use up to 1 GB of memory using
    the Docker option `-m=1024M`, we expect to see a lower max memory allocation.
    Running the command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Docker选项`-m=1024M`将Docker容器限制为只能使用最多1 GB的内存，我们预计会看到更低的内存最大分配。运行以下命令：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: will result in the response 268,435,456 bytes, which equals *268,435,456 / 1024
    / 1024*= 256 MB. 256 MB is one-quarter of 1 GB, so again, this is as expected.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将导致响应268,435,456字节，这等于 *268,435,456 / 1024 / 1024*= 256 MB。256 MB是1 GB的四分之一，所以，这正如预期的那样。
- en: 'We can, as usual, set the max heap size on the JVM ourselves. For example,
    if we want to allow the JVM to use 600 MB of the total 1 GB we have for its heap,
    we can specify that using the JVM option `-Xmx600m` like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像往常一样，自己设置JVM的最大堆大小。例如，如果我们想允许JVM使用我们为其堆预留的1 GB中的600 MB，我们可以使用JVM选项`-Xmx600m`来指定，如下所示：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The JVM will respond with 629,145,600 bytes = *629,145,600 / 1024 / 1024*= 600
    MB, again as expected.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JVM将响应629,145,600字节 = *629,145,600 / 1024 / 1024*= 600 MB，再次符合预期。
- en: Let’s conclude with an “out of memory” test to ensure that this really works!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个“内存不足”的测试来结束，以确保这真的有效！
- en: We’ll allocate some memory using `jshell` in a JVM that runs in a container
    that has been given 1 GB of memory; that is, it has a max heap size of 256 MB.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个已经分配了1 GB内存的容器中运行的JVM中使用`jshell`分配一些内存；也就是说，它有一个256 MB的最大堆大小。
- en: 'First, try to allocate a byte array of 100 MB:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试分配一个100 MB的字节数组：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The command will respond with `$1 ==>`, meaning that it worked fine!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将响应 `$1 ==>`，这意味着它工作得很好！
- en: Normally, `jshell` will print out the value resulting from the command, but
    100 MB of bytes all set to zero is a bit too much to print, so we get nothing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`jshell`会打印出命令的结果值，但100 MB的字节全部设置为0有点太多，所以什么也没有打印出来。
- en: 'Now, let’s try to allocate a byte array that is larger than the max heap size,
    for example, 500 MB:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试分配一个大于最大堆大小的字节数组，例如，500 MB：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The JVM sees that it can’t perform the action since it honors the container
    settings of max memory and responds immediately with `Exception java.lang.OutOfMemoryError:
    Java heap space`. Great!'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'JVM看到它无法执行该操作，因为它尊重容器的最大内存设置，并立即响应`Exception java.lang.OutOfMemoryError: Java
    heap space`。太好了！'
- en: So, to summarize, we have now seen how Java honors the settings of available
    CPUs and the memory of its container. Let’s move on and build our first Docker
    images for one of the microservices!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，我们现在已经看到了Java如何尊重其容器中可用的CPU和内存设置。让我们继续前进，为我们的一个微服务构建第一个Docker镜像！
- en: Using Docker with one microservice
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker与一个微服务
- en: Now that we understand how Java works in a container, we can start using Docker
    with one of our microservices. Before we can run our microservice as a Docker
    container, we need to package it in a Docker image. To build a Docker image, we
    need a Dockerfile, so we will start with that. Next, we need a Docker-specific
    configuration for our microservice. Since a microservice that runs in a container
    is isolated from other microservices – it has its own IP address, hostname, and
    ports – it needs a different configuration compared to when it’s running on the
    same host with other microservices.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Java在容器中的工作方式，我们可以开始使用Docker与我们的一个微服务一起使用。在我们能够将我们的微服务作为Docker容器运行之前，我们需要将其打包到一个Docker镜像中。要构建一个Docker镜像，我们需要一个Dockerfile，所以我们将从那里开始。接下来，我们需要为我们的微服务配置一个Docker特定的配置。由于在容器中运行的微服务与其他微服务是隔离的——它有自己的IP地址、主机名和端口——它需要与在相同主机上与其他微服务一起运行时不同的配置。
- en: For example, since the other microservices no longer run on the same host, no
    port conflicts will occur. When running in Docker, we can use the default port
    `8080` for all our microservices without any risk of port conflicts. On the other
    hand, if we need to talk to the other microservices, we can no longer use `localhost`
    like we could when we ran them on the same host.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于其他微服务不再运行在相同的主机上，所以不会发生端口冲突。在Docker中运行时，我们可以为所有微服务使用默认端口`8080`，而没有任何端口冲突的风险。另一方面，如果我们需要与其他微服务通信，我们就不能再像在相同主机上运行它们时那样使用`localhost`了。
- en: The source code in the microservices will not be affected by running the microservices
    in containers, only their configuration!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务中的源代码不会因为将微服务在容器中运行而受到影响，只有它们的配置！
- en: To handle the different configurations that are required when running locally
    without Docker and when running the microservices as Docker containers, we will
    use Spring profiles. Since *Chapter 3*, *Creating a Set of Cooperating Microservices*,
    we have been using the default Spring profile for running locally without Docker.
    Now, we will create a new Spring profile named `docker` to be used when we run
    our microservices as containers in Docker.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理在本地运行时（没有 Docker）和作为 Docker 容器运行微服务时所需的不同的配置，我们将使用 Spring 配置文件。自 *第 3 章*，*创建一组协作微服务*
    以来，我们一直在使用默认的 Spring 配置文件在本地运行时（没有 Docker）。现在，我们将创建一个新的名为 `docker` 的 Spring 配置文件，用于我们在
    Docker 中以容器形式运行微服务时使用。
- en: Changes in source code
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码中的更改
- en: We will start with the `product` microservice, which can be found in the source
    code at `$BOOK_HOME/Chapter04/microservices/product-service/`. In the next section,
    we will apply this to the other microservices as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `product` 微服务开始，该微服务可以在源代码的 `$BOOK_HOME/Chapter04/microservices/product-service/`
    中找到。在下一节中，我们将将其应用于其他微服务。
- en: 'First, we add the Spring profile for Docker at the end of the property file
    `application.yml`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在属性文件 `application.yml` 的末尾添加 Spring 配置文件：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Spring profiles can be used to specify the environment-specific configuration,
    which, in this case, is a configuration that is only to be used when running the
    microservice in a Docker container. Other examples are configurations that are
    specific to `dev`, `test`, and `production` environments. Values in a profile
    override values from the default profile. By using YAML files, multiple Spring
    profiles can be placed in the same file, separated by `---`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 配置文件可以用来指定特定环境的配置，在这种情况下，这是一个仅在运行微服务时在 Docker 容器中使用的配置。其他例子包括特定于 `dev`、`test`
    和 `production` 环境的配置。配置文件中的值会覆盖默认配置文件中的值。通过使用 YAML 文件，可以在同一个文件中放置多个 Spring 配置文件，它们之间用
    `---` 分隔。
- en: The only parameter we change for now is the port that’s being used; we will
    use the default port `8080` when running the microservice in a container.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在唯一更改的参数是正在使用的端口；当在容器中运行微服务时，我们将使用默认端口 `8080`。
- en: 'Next, we will create the Dockerfile that we will use to build the Docker image.
    As mentioned in *Chapter 2*, *Introduction to Spring Boot*, a Dockerfile can be
    as straightforward as:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建用于构建 Docker 镜像的 Dockerfile。如 *第 2 章*，*Spring Boot 简介* 中所述，Dockerfile
    可以非常简单：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Some things to take note of are:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些事项包括：
- en: The Docker images will be based on the official Docker image for OpenJDK and
    use version 17.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 镜像将基于官方的 OpenJDK Docker 镜像，并使用版本 17。
- en: Port `8080` will be exposed to other Docker containers.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口 `8080` 将暴露给其他 Docker 容器。
- en: The fat JAR file will be added to the Docker image from the Gradle build library,
    `build/libs`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重量级 JAR 文件将被添加到 Docker 镜像中，来自 Gradle 构建库的 `build/libs`。
- en: The command used by Docker to start a container based on this Docker image is
    `java -jar /app.jar`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 用于启动基于此 Docker 镜像的容器的命令是 `java -jar /app.jar`。
- en: 'This simple approach has a few disadvantages:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的方法有几个缺点：
- en: We are using the full JDK of Java SE 17, including compilers and other development
    tools. That makes the Docker images unnecessarily large and, from a security perspective,
    we don’t want to bring more tools into the image than necessary.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用 Java SE 17 的完整 JDK，包括编译器和其他开发工具。这使得 Docker 镜像变得不必要地大，并且从安全角度来看，我们不想将不必要的工具带入镜像中。
- en: Therefore, we would prefer to use a base image for the Java SE 17 JRE that only
    contains programs and libraries required to run a Java program. Unfortunately,
    the OpenJDK project does not provide a Docker image for Java SE 17 JRE.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们更愿意使用一个仅包含运行 Java 程序所需的程序和库的基础镜像来构建 Java SE 17 JRE。不幸的是，OpenJDK 项目没有为 Java
    SE 17 JRE 提供一个 Docker 镜像。
- en: The fat JAR file takes time to unpackage when the Docker container starts up.
    A better approach is to instead unpackage the fat JAR when the Docker image is
    built.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重量级 JAR 文件在 Docker 容器启动时需要时间来解包。更好的方法是，在构建 Docker 镜像时解包重量级 JAR 文件。
- en: The fat JAR file is very big, as we will see below, some 20 MB. If we want to
    make repeatable changes to the application code in the Docker images during development,
    this will result in suboptimal usage of the Docker `build` command. Since Docker
    images are built in layers, we will get one very big layer that needs to be replaced
    each time, even in the case where only a single Java class is changed in the application
    code.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fat JAR 文件非常大，如下所示，大约有 20 MB。如果我们想在开发过程中对 Docker 镜像中的应用程序代码进行可重复更改，这将导致 Docker
    `build` 命令的使用次优。由于 Docker 镜像是按层构建的，我们将得到一个非常大的层，每次都需要替换，即使在应用程序代码中只更改了一个 Java
    类的情况下也是如此。
- en: A better approach is to divide the content into different layers, where files
    that do not change so frequently are added in the first layer, and files that
    change the most are placed in the last layer. This will result in good use of
    Docker’s caching mechanism for layers. For the first stable layers that are not
    changed when some application code is changed, Docker will simply use the cache
    instead of rebuilding them. This will result in faster builds of the microservices’
    Docker images.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更好的方法是按不同的层划分内容，其中不经常更改的文件添加到第一层，而更改最频繁的文件放置在最后一层。这将导致 Docker 层缓存机制的良好使用。对于在更改某些应用程序代码时不会更改的第一稳定层，Docker
    将直接使用缓存而不是重建它们。这将导致微服务 Docker 镜像构建更快。
- en: Regarding the lack of a Docker image for Java SE 17 JRE from the OpenJDK project,
    there are other open source projects that package the OpenJDK binaries into Docker
    images. One of the most widely used projects is **Eclipse Temurin** ([https://adoptium.net/temurin/](https://adoptium.net/temurin/)).
    The Temurin project provides both full JDK editions and minimized JRE editions
    of their Docker images.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 OpenJDK 项目缺少 Java SE 17 JRE Docker 镜像的问题，还有其他开源项目将 OpenJDK 二进制文件打包到 Docker
    镜像中。其中最广泛使用的一个项目是 **Eclipse Temurin** ([https://adoptium.net/temurin/](https://adoptium.net/temurin/))。Temurin
    项目提供了他们 Docker 镜像的全 JDK 版本和最小化 JRE 版本。
- en: 'When it comes to handling the suboptimal packaging of fat JAR files in Docker
    images, Spring Boot addressed this issue in v2.3.0, making it possible to extract
    the content of a fat JAR file into a number of folders. By default, Spring Boot
    creates the following folders after extracting a fat JAR file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在 Docker 镜像中处理 fat JAR 文件的次优打包时，Spring Boot 在 v2.3.0 版本中解决了这个问题，使得将 fat
    JAR 文件的内容提取到多个文件夹中成为可能。默认情况下，Spring Boot 在提取 fat JAR 文件后会创建以下文件夹：
- en: '`dependencies`, containing all dependencies as JAR files'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`，包含所有依赖项作为 JAR 文件'
- en: '`spring-boot-loader`, containing Spring Boot classes that know how to start
    a Spring Boot application'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-loader`，包含知道如何启动 Spring Boot 应用程序的 Spring Boot 类'
- en: '`snapshot-dependencies`, containing snapshot dependencies, if any'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot-dependencies`，包含任何快照依赖项'
- en: '`application`, containing application class files and resources'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application`，包含应用程序类文件和资源'
- en: 'The Spring Boot documentation recommends creating one Docker layer for each
    folder in the order listed above. After replacing the JDK-based Docker image with
    a JRE-based image and adding instructions for exploding the fat JAR file into
    proper layers in the Docker image, the Dockerfile looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 文档建议为上述列出的每个文件夹创建一个 Docker 层。在用基于 JRE 的镜像替换基于 JDK 的 Docker 镜像并添加将
    fat JAR 文件展开到 Docker 镜像中适当层的指令后，Dockerfile 看起来是这样的：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To handle the extraction of the fat JAR file in the Dockerfile we use a **multi-stage
    build**, meaning that there is a first step, named `builder`, that handles the
    extraction. The second stage builds the actual Docker image that will be used
    at runtime, picking the files as required from the first stage. Using this technique,
    we can handle all packaging logic in the Dockerfile but, at the same time, keep
    the size of the final Docker image to a minimum:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Dockerfile 中处理 fat JAR 文件的提取，我们使用 **多阶段构建**，这意味着有一个名为 `builder` 的第一步，用于处理提取。第二个阶段构建实际用于运行时的
    Docker 镜像，从第一阶段按需选择文件。使用这种技术，我们可以在 Dockerfile 中处理所有打包逻辑，同时将最终 Docker 镜像的大小保持在最小：
- en: 'The first stage starts with the line:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个阶段从以下行开始：
- en: '[PRE13]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From this line, we can see that a Docker image from the Temurin project is used
    and that it contains Java SE JRE for v17.0.5_8\. We can also see that the stage
    is named `builder`.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从这一行开始，我们可以看到使用了来自 Temurin 项目的 Docker 镜像，并且它包含 Java SE JRE for v17.0.5_8。我们还可以看到该阶段被命名为
    `builder`。
- en: The `builder` stage sets the working directory to `extracted` and adds the fat
    JAR file from the Gradle build library, `build/libs`, to that folder.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`builder` 阶段将工作目录设置为 `extracted` 并将来自 Gradle 构建库 `build/libs` 的胖 JAR 文件添加到该文件夹中。'
- en: The `builder` stage then runs the command `java -Djarmode=layertools -jar app.jar
    extract`, which will perform the extraction of the fat JAR file into its working
    directory, the `extracted` folder.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`builder` 阶段接着运行命令 `java -Djarmode=layertools -jar app.jar extract`，这将执行将胖
    JAR 文件提取到其工作目录，即 `extracted` 文件夹中的操作。'
- en: 'The next and final stage starts with the line:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个和最后一个阶段从以下行开始：
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It uses the same base Docker image as in the first stage, and the `application`
    folder as its working directory. It copies the exploded files from the `builder`
    stage, folder by folder, into the `application` folder. This creates one layer
    per folder, as described above. The parameter `--from=builder` is used to instruct
    Docker to pick the files from the file system in the `builder` stage.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它使用与第一阶段相同的基 Docker 镜像，并将 `application` 文件夹作为其工作目录。它将 `builder` 阶段的展开文件按文件夹逐个复制到
    `application` 文件夹中。这样，每个文件夹创建一个层，如上所述。参数 `--from=builder` 用于指示 Docker 从 `builder`
    阶段的文件系统中选择文件。
- en: After exposing the proper ports, `8080` in this case, the Dockerfile wraps up
    by telling Docker what Java class to run to start the microservice in the exploded
    format, that is, `org.springframework.boot.loader.JarLauncher`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公开适当的端口后，在这个例子中是 `8080`，Dockerfile 通过告诉 Docker 运行哪个 Java 类来启动微服务，即 `org.springframework.boot.loader.JarLauncher`，来完成封装。
- en: After learning about the required changes in the source code, we are ready to
    build our first Docker image.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解源代码中所需更改后，我们准备好构建我们的第一个 Docker 镜像。
- en: Building a Docker image
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: 'To build the Docker image, we first need to build our deployment artifact (that
    is, the fat JAR file) for `product-service`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建 Docker 镜像，我们首先需要为 `product-service` 构建我们的部署工件（即胖 JAR 文件）：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since we only want to build `product-service` and the projects it depends on
    (the `api` and `util projects`), we don’t use the normal `build` command, which
    builds all the microservices. Instead, we use a variant that tells Gradle to only
    build the `product-service` project: `:microservices:product-service:build`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只想构建 `product-service` 以及它所依赖的项目（即 `api` 和 `util` 项目），我们不使用正常的 `build` 命令，该命令构建所有微服务。相反，我们使用一个变体，告诉
    Gradle 只构建 `product-service` 项目：`:microservices:product-service:build`。
- en: 'We can find the fat JAR file in the Gradle build library, `build/libs`. The
    `ls -l microservices/product-service/build/libs` command will report something
    like the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Gradle 构建库中找到胖 JAR 文件，位于 `build/libs`。`ls -l microservices/product-service/build/libs`
    命令将报告如下：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_04_07.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本描述自动生成](img/B19825_04_07.png)'
- en: 'Figure 4.7: Viewing the fat JAR file details'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：查看胖 JAR 文件详情
- en: As you can see, the JAR file is close to 20 MB in size – no wonder they are
    called fat JAR files!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，JAR 文件的大小接近 20 MB – 没有 wonder 他们被称为胖 JAR 文件！
- en: If you are curious about its actual content, you can view it by using the `unzip
    -l microservices/product-service/build/libs/product-service-1.0.0-SNAPSHOT.jar`
    command.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对其实际内容感到好奇，你可以使用 `unzip -l microservices/product-service/build/libs/product-service-1.0.0-SNAPSHOT.jar`
    命令来查看。
- en: 'Next, we will build the Docker image and name it `product-service`, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建 Docker 镜像并将其命名为 `product-service`，如下所示：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Docker will use the Dockerfile in the current directory to build Docker Engine.
    The image will be tagged with the name `product-service` and stored locally inside
    the Docker engine.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 将使用当前目录中的 Dockerfile 来构建 Docker 引擎。镜像将被标记为 `product-service` 并存储在 Docker
    引擎的本地。
- en: 'Verify that we got a Docker image, as expected, by using the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证我们得到了预期的 Docker 镜像：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The expected output is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_04_08.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面、文本、应用程序描述自动生成](img/B19825_04_08.png)'
- en: 'Figure 4.8: Verifying that we built our Docker image'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：验证我们构建了 Docker 镜像
- en: So now that we have built the image, let’s see how we can start the service.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经构建了镜像，让我们看看我们如何启动服务。
- en: Starting up the service
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动服务
- en: 'Let’s start up the `product` microservice as a container by using the following
    command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令启动 `product` 微服务作为容器：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is what we can infer from the command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以从命令中推断出的内容：
- en: '`docker run`: The `docker run` command will start the container and display
    log output in the Terminal. The Terminal will be locked as long as the container
    runs.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker run`：`docker run` 命令将启动容器并在终端显示日志输出。只要容器运行，终端就会锁定。'
- en: We have seen the `--rm` option already; it will tell Docker to clean up the
    container once we stop the execution from the Terminal using *Ctrl* + *C*.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到了 `--rm` 选项；它将告诉 Docker 在我们从终端使用 *Ctrl* + *C* 停止执行后清理容器。
- en: The `-p8080:8080` option maps port `8080` in the container to port `8080` in
    the Docker host, which makes it possible to call it from the outside. In the case
    of Docker Desktop for Mac, which runs Docker in a local Linux virtual machine,
    the port will also be port-forwarded to macOS, which is made available on `localhost`.
    Remember that we can only have one container mapping to a specific port in the
    Docker host!
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-p8080:8080` 选项将容器中的端口 `8080` 映射到 Docker 主机的端口 `8080`，这使得从外部调用它成为可能。在 Docker
    Desktop for Mac 的情况下，它在一个本地的 Linux 虚拟机中运行 Docker，端口也将被转发到 macOS，并在 `localhost`
    上提供。记住，我们只能有一个容器映射到 Docker 主机上的特定端口！'
- en: With the `-e` option, we can specify environment variables for the container,
    which, in this case, is `SPRING_PROFILES_ACTIVE=docker`. The `SPRING_PROFILES_ACTIVE`
    environment variable is used to tell Spring what profiles to use. In our case,
    we want Spring to use the `docker` profile.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `-e` 选项，我们可以为容器指定环境变量，在这个例子中，是 `SPRING_PROFILES_ACTIVE=docker`。`SPRING_PROFILES_ACTIVE`
    环境变量用于告诉 Spring 使用哪个配置文件。在我们的例子中，我们希望 Spring 使用 `docker` 配置文件。
- en: Finally, we have `product-service`, which is the name of the Docker image we
    built above and which Docker will use to start the container.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有 `product-service`，这是我们上面构建的 Docker 镜像的名称，Docker 将使用它来启动容器。
- en: 'The expected output is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Text  Description automatically generated](img/B19825_04_09.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![文本  自动生成的描述](img/B19825_04_09.png)'
- en: 'Figure 4.9: Output after starting up the product microservice'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：启动产品微服务后的输出
- en: 'From the preceding screenshot we can see:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图我们可以看到：
- en: 'The profile that’s used by Spring is `docker`. Look for `The following profiles
    are active: docker` in the output to verify this.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Spring 使用的配置文件是 `docker`。在输出中查找 `The following profiles are active: docker`
    以验证这一点。'
- en: The port that’s allocated by the container is `8080`. Look for `Netty started
    on port8080` in the output to verify this.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器分配的端口是 `8080`。在输出中查找 `Netty started on port8080` 以验证这一点。
- en: The microservice is ready to accept requests once the log message `Started ProductServiceApplication`
    has been written!
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦写入日志消息 `Started ProductServiceApplication`，微服务就准备好接受请求了！
- en: 'We can use port `8080` on `localhost` to communicate with the microservice,
    as explained previously. Try out the following command in another Terminal window:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `localhost` 上的 `8080` 端口与微服务进行通信，如前所述。在另一个终端窗口中尝试以下命令：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the expected output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们预期的输出：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_04_10.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本  自动生成的描述](img/B19825_04_10.png)'
- en: 'Figure 4.10: Requesting information on product 3'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：请求产品 3 的信息
- en: 'This is similar to the output we received from the previous chapter, but with
    one major difference: we now have the content of `"service Address":"9dc086e4a88b/172.17.0.2:8080"`,
    the port is `8080`, as expected, and the IP address, `172.17.0.2`, is the IP address
    that’s been allocated to the container from an internal network in Docker – but
    where did the hostname, `9dc086e4a88b`, come from?'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在上一章中收到的输出类似，但有一个主要区别：我们现在有了 `"service Address":"9dc086e4a88b/172.17.0.2:8080"`
    的内容，端口是 `8080`，正如预期的那样，IP 地址 `172.17.0.2` 是 Docker 内部网络分配给容器的 IP 地址——但主机名 `9dc086e4a88b`
    是从哪里来的？
- en: 'Ask Docker for all the running containers:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Docker 请求所有正在运行的容器：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will see something like the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下内容：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_04_11.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本  自动生成的描述](img/B19825_04_11.png)'
- en: 'Figure 4.11: All running containers'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：所有正在运行的容器
- en: As we can see from the preceding output, the hostname is equivalent to the ID
    of the container, which is good to know if you want to understand which container
    actually responded to your request!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以看到主机名等同于容器的 ID，如果你想知道哪个容器实际响应了你的请求，这是很好的信息！
- en: Wrap this up by stopping the container in the Terminal with the *Ctrl* + *C*
    command. With this done, we can now move on to running the container detached
    from the terminal.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用终端中的 *Ctrl* + *C* 命令停止容器，完成这个步骤后，我们现在可以继续在终端中分离运行容器。
- en: Running the container in detached mode
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以分离模式运行容器
- en: Okay, that was great, but what if we don’t want to lock the Terminal from where
    we started the container? In most cases, it is inconvenient to have a Terminal
    session locked for each running container. It’s time to learn how to start the
    container as **detached** – running the container without locking the Terminal!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那很棒，但如果我们不想从启动容器的终端锁定它怎么办？在大多数情况下，对于每个正在运行的容器，有一个锁定的终端会感到不方便。是时候学习如何以 **分离**
    的方式启动容器——在不锁定终端的情况下运行容器了！
- en: 'We can do this by adding the `-d` option and, at the same time, giving it a
    name using the `--name` option. Giving it a name is optional, and Docker will
    generate a name if we don’t, but it makes it easier to send commands to the detached
    container using a name that we have decided. The `--rm` option is no longer required
    since we will stop and remove the container explicitly when we are done with it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加 `-d` 选项，同时使用 `--name` 选项给它起一个名字来实现这一点。给容器起名字是可选的，如果我们不指定，Docker 会自动生成一个名字，但使用我们指定的名字可以更方便地向分离的容器发送命令。由于我们将在完成容器操作后显式地停止和删除容器，所以不再需要
    `--rm` 选项：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run the `docker ps` command again, we will see our new container, called
    `my-prd-srv`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行 `docker ps` 命令，我们将看到我们的新容器，名为 `my-prd-srv`：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_04_12.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，自动生成文本描述](img/B19825_04_12.png)'
- en: 'Figure 4.12: Starting the container as detached'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：以分离模式启动容器
- en: But how do we get the log output from our container?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何从我们的容器中获取日志输出？
- en: 'Meet the `docker` `logs` command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 认识 `docker` `logs` 命令：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `-f` option tells the command to follow the log output, that is, not end
    the command when all the current log output has been written to the Terminal,
    but also wait for more output. If you expect a lot of old log messages that you
    don’t want to see, you can also add the `--tail 0` option so that you only see
    new log messages. Alternatively, you can use the `--since` option and specify
    either an absolute timestamp or a relative time, for example, `--since 5m`, to
    see log messages that are, at most, five minutes old.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f` 选项指示命令跟随日志输出，也就是说，当所有当前日志输出都写入终端时，命令不会结束，而是等待更多输出。如果你期望看到很多你不想看到的旧日志消息，你也可以添加
    `--tail 0` 选项，这样你只能看到新的日志消息。或者，你可以使用 `--since` 选项并指定一个绝对时间戳或相对时间，例如，`--since 5m`，以查看最多五分钟前的日志消息。'
- en: Try this out with a new `curl` request. You should see that a new log message
    has been written to the log output in the Terminal.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个新的 `curl` 请求来尝试一下。你应该会看到一个新的日志消息已经写入终端的日志输出中。
- en: 'Wrap this up by stopping and removing the container:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过停止和删除容器来完成这个步骤：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `-f` option forces Docker to remove the container, even if it is running.
    Docker will automatically stop the container before it removes it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f` 选项强制 Docker 删除容器，即使它正在运行。在删除容器之前，Docker 会自动停止容器。'
- en: Now that we know how to use Docker with a microservice, we can see how to manage
    a microservice landscape with the help of Docker Compose.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用 Docker 与微服务一起使用，我们可以看看如何借助 Docker Compose 来管理微服务景观。
- en: Managing a landscape of microservices using Docker Compose
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 管理微服务景观
- en: We’ve already seen how we can run a single microservice as a Docker container,
    but what about managing a whole system landscape of microservices?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何将单个微服务作为 Docker 容器运行，但关于如何管理整个微服务系统景观呢？
- en: As we mentioned earlier, this is the purpose of `docker-compose`. By using single
    commands, we can build, start, log, and stop a group of cooperating microservices
    running as Docker containers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这就是 `docker-compose` 的目的。通过使用单个命令，我们可以构建、启动、记录和停止作为 Docker 容器运行的多个协作微服务。
- en: Changes in the source code
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码的更改
- en: To be able to use Docker Compose, we need to create a configuration file, `docker-compose.yml`,
    that describes the microservices Docker Compose will manage for us. We also need
    to set up Dockerfiles for the remaining microservices and add a Docker-specific
    Spring profile to each of them. All four microservices have their own Dockerfile,
    but they all look the same as the preceding one.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Docker Compose，我们需要创建一个配置文件，`docker-compose.yml`，该文件描述了Docker Compose将为我们管理的微服务。我们还需要为剩余的微服务设置Dockerfile，并为每个微服务添加一个特定的Docker
    Spring配置文件。所有四个微服务都有自己的Dockerfile，但它们看起来都与前面的相同。
- en: When it comes to the Spring profiles, the three core services, `product-`, `recommendation-`,
    and `review-service`, have the same `docker` profile, which only specifies that
    the default port `8080` should be used when running as a container.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到Spring配置文件时，三个核心服务`product-`、`recommendation-`和`review-service`具有相同的`docker`配置文件，它只指定在作为容器运行时应该使用默认端口`8080`。
- en: 'For the `product-composite-service`, things are a bit more complicated since
    it needs to know where to find the core services. When we ran all the services
    on localhost, it was configured to use localhost and individual port numbers,
    `7001`-`7003`, for each core service. When running in Docker, each service will
    have its own hostname but will be accessible on the same port number, `8080`.
    Here, the `docker` profile for `product-composite-service` looks as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`product-composite-service`，事情要复杂一些，因为它需要知道核心服务在哪里。当我们在本地上运行所有服务时，它被配置为使用localhost和每个核心服务的单独端口号，`7001`-`7003`。当在Docker中运行时，每个服务将有自己的主机名，但可以在相同的端口号`8080`上访问。在这里，`product-composite-service`的`docker`配置文件如下所示：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This configuration is stored in the property file, `application.yml`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置存储在属性文件`application.yml`中。
- en: Where did the hostnames `product`, `recommendation`, and `review` come from?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`、`recommendation`和`review`主机名是从哪里来的？'
- en: 'These are specified in the `docker-compose.yml` file, which is located in the
    `$BOOK_HOME/Chapter04` folder. It looks like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置在`docker-compose.yml`文件中指定，该文件位于`$BOOK_HOME/Chapter04`文件夹中。它看起来是这样的：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For each microservice, we specify the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个微服务，我们指定以下内容：
- en: The name of the microservice. This will also be the hostname of the container
    in the internal Docker network.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的名称。这也将是内部Docker网络中容器的主机名。
- en: A `build` directive that specifies where to find the Dockerfile that was used
    to build the Docker image.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`build`指令，指定用于构建Docker镜像的Dockerfile的位置。
- en: A memory limit of 512 MB. 512 MB should be sufficient for all our microservices
    for the scope of this book. For this chapter, it could be set to a lower value,
    but as we add more capabilities in the microservices in the coming chapters, their
    memory requirements will increase.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 512 MB的内存限制。对于本书的范围，512 MB应该足够所有我们的微服务使用。对于本章，它可以设置为更低的值，但随着我们在接下来的章节中添加更多功能到微服务中，它们的内存需求将会增加。
- en: The environment variables that will be set up for the container. In our case,
    we used these to specify which Spring profile to use.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将为容器设置的环境变量。在我们的情况下，我们使用这些来指定要使用哪个Spring配置文件。
- en: For the `product-composite` service, we will also specify port mappings – we
    will expose its port so it can be reached from outside Docker. The other microservices
    will not be accessible from the outside. Next, we will see how to start up a microservice
    landscape.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`product-composite`服务，我们还将指定端口映射 - 我们将公开其端口，以便可以从Docker外部访问。其他微服务将无法从外部访问。接下来，我们将看到如何启动微服务景观。
- en: In *Chapter 10*, *Using Spring Cloud Gateway to Hide Microservices behind an
    Edge Server*, and *Chapter 11*, *Securing Access to APIs*, we will learn more
    about how to lock down and secure external access to a system landscape of microservices.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在第*10章*，*使用Spring Cloud Gateway隐藏微服务背后的边缘服务器*，以及第*11章*，*保护API访问*，我们将学习更多关于如何锁定和确保外部访问微服务系统的方法。
- en: Starting up the microservice landscape
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动微服务景观
- en: 'With all the necessary code changes in place, we can build our Docker images,
    start up the microservice landscape, and run some tests to verify that it works
    as expected. For this, we need to do the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有必要的代码更改到位后，我们可以构建我们的Docker镜像，启动微服务景观，并运行一些测试以验证其按预期工作。为此，我们需要执行以下操作：
- en: 'First, we build our deployment artifacts with Gradle and then the Docker images
    with Docker Compose:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用Gradle构建我们的部署工件，然后使用Docker Compose构建Docker镜像：
- en: '[PRE26]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we need to verify that we can see our Docker images, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要验证我们是否可以看到我们的Docker镜像，如下所示：
- en: '[PRE27]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We should see the following output:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该看到以下输出：
- en: '![Text  Description automatically generated with low confidence](img/B19825_04_13.png)Figure
    4.13: Verifying our Docker images'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![文本描述由低置信度自动生成](img/B19825_04_13.png)图4.13：验证我们的Docker镜像'
- en: 'Start up the microservices landscape with the following command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动微服务环境：
- en: '[PRE28]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-d` option will make Docker Compose run the containers in detached mode,
    the same as for Docker.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`选项将使Docker Compose以分离模式运行容器，与Docker相同。'
- en: 'We can follow the startup by monitoring the output that’s written to each container
    log with the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令监控每个容器日志的输出，以跟踪启动过程：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `docker-compose logs` command supports the same `-f` and `--tail` options
    as `docker logs`, as described earlier.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose logs`命令支持与前面描述的`docker logs`相同的`-f`和`--tail`选项。'
- en: The `dockter-composelogs` command also supports restricting the log output to
    a group of containers. Simply add the names of the containers you want to see
    the log output of after the `logs` command. For example, to only see log output
    from the `product` and `review` services, use `docker-compose logs -f product
    review`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose logs`命令也支持将日志输出限制为容器组。只需在`logs`命令后添加您想查看日志输出的容器的名称。例如，要仅查看`product`和`review`服务的日志输出，请使用`docker-compose
    logs -f product review`。'
- en: 'When all four microservices have reported that they have started up, we are
    ready to try out the microservices landscape. Look for the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有四个微服务都报告它们已启动时，我们就准备好尝试微服务环境了。寻找以下内容：
- en: '![Text  Description automatically generated](img/B19825_04_14.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述由中等置信度自动生成](img/B19825_04_14.png)'
- en: 'Figure 4.14: Starting up all four microservices'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：启动所有四个微服务
- en: Note that each log message is prefixed with the name of the container that produced
    the output!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个日志消息都带有产生输出的容器的名称作为前缀！
- en: 'Now, we are ready to run some tests to verify that this works as expected.
    The port number is the only change we need to make when calling the composite
    service in Docker compared to when we ran it directly on the localhost, as we
    did in the previous chapter. We now use port `8080`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好运行一些测试来验证这是否按预期工作。与我们在上一章中直接在本地主机上运行相比，当我们调用Docker中的组合服务时，需要更改的唯一端口是端口号。我们现在使用端口`8080`：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will get the same type of response:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到相同类型的响应：
- en: '![Text  Description automatically generated](img/B19825_04_15.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述由中等置信度自动生成](img/B19825_04_15.png)'
- en: 'Figure 4.15: Calling the composite service'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：调用组合服务
- en: 'However, there’s one big difference – the hostnames and ports reported by `serviceAddresses`
    in the response:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个很大的不同之处——响应中`serviceAddresses`报告的主机名和端口：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B19825_04_16.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述由中等置信度自动生成](img/B19825_04_16.png)'
- en: 'Figure 4.16: Viewing the serviceAddresses'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：查看服务地址
- en: Here, we can see the hostnames and IP addresses that have been allocated to
    each of the Docker containers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到分配给每个Docker容器的主机名和IP地址。
- en: 'We’re done; now only one step is left:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了；现在只剩下一步了：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding command will shut down the microservices landscape. So far, we
    have seen how we can test the cooperating microservices running **Bash** commands
    by hand. In the next section, we will see how we can enhance our test script to
    automate these manual steps.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将关闭微服务环境。到目前为止，我们已经看到如何通过手动执行Bash命令来测试协作微服务。在下一节中，我们将看到如何增强我们的测试脚本来自动化这些手动步骤。
- en: Automating tests of cooperating microservices
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化协作微服务的测试
- en: Docker Compose is really helpful when it comes to manually managing a group
    of microservices. In this section, we will take this one step further and integrate
    Docker Compose into our test script, `test-em-all.bash`. The test script will
    automatically start up the microservice landscape, run all the required tests
    to verify that the microservice landscape works as expected, and finally, tear
    it down, leaving no traces behind.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当手动管理一组微服务时，Docker Compose非常有帮助。在本节中，我们将更进一步，将Docker Compose集成到我们的测试脚本`test-em-all.bash`中。测试脚本将自动启动微服务环境，运行所有必要的测试以验证微服务环境按预期工作，最后将其关闭，不留任何痕迹。
- en: The test script can be found at `$BOOK_HOME/Chapter04/test-em-all.bash`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本位于`$BOOK_HOME/Chapter04/test-em-all.bash`。
- en: 'Before the test script runs the test suite, it will check for the presence
    of a `start` argument in the invocation of the test script. If found, it will
    restart the containers with the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试脚本运行测试套件之前，它将检查测试脚本调用中是否存在 `start` 参数。如果找到，它将使用以下代码重新启动容器：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After that, the test script will wait for the `product-composite` service to
    respond with `OK`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，测试脚本将等待 `product-composite` 服务响应 `OK`：
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `waitForService` Bash function is implemented as:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForService` Bash 函数的实现如下：'
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `waitForService` function sends HTTP requests to the supplied URL using
    `curl`. Requests are sent repeatedly until `curl` responds that it got a successful
    response back from the request. The function waits `3` seconds between each attempt
    and gives up after `100` attempts, stopping the script with a failure.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForService` 函数使用 `curl` 向提供的 URL 发送 HTTP 请求。请求会重复发送，直到 `curl` 响应表示它从请求中收到了成功的响应。函数在每次尝试之间等待
    `3` 秒，并在 `100` 次尝试后放弃，停止脚本并失败。'
- en: 'Next, all the tests are executed as they were previously. Afterward, the script
    will tear down the landscape if it finds the `stop` argument in the invocation
    parameters:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，所有测试都像之前一样执行。之后，如果脚本在调用参数中找到 `stop` 参数，它将拆除场景：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the test script will not tear down the landscape if some tests fail;
    it will simply stop, leaving the landscape up for error analysis!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果某些测试失败，测试脚本不会拆除场景；它将简单地停止，留下场景以供错误分析！
- en: The test script has also changed the default port from `7000`, which we used
    when we ran the microservices without Docker, to `8080`, which is used by our
    Docker containers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本还更改了默认端口，从我们在不使用 Docker 运行微服务时使用的 `7000`，更改为 Docker 容器使用的 `8080`。
- en: 'Let’s try it out! To start the landscape, run the tests, and tear it down afterward,
    run the command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看！为了启动场景，运行测试，然后运行以下命令来拆除：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is some sample output from a test run focusing on the startup
    and shutdown phases. Output from the actual tests have been removed (they are
    the same as in the previous chapter):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关注启动和关闭阶段的测试运行示例输出。实际测试的输出已被移除（它们与上一章相同）：
- en: '![Text  Description automatically generated](img/B19825_04_17.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_04_17.png)'
- en: 'Figure 4.17: Sample output from a test run'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17：测试运行示例输出
- en: After running these tests, we can move on to see how to troubleshoot tests that
    fail.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些测试后，我们可以继续了解如何排除失败的测试。
- en: Troubleshooting a test run
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除测试运行
- en: 'If the tests that were running `./test-em-all.bash start stop` fail, following
    these steps can help you identify the problem and resume the tests once the problem
    has been fixed:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行 `./test-em-all.bash start stop` 的测试失败，以下步骤可以帮助您识别问题，并在问题解决后重新启动测试：
- en: 'First, check the status of the running microservices with the following command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令检查运行中的微服务状态：
- en: '[PRE37]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If all the microservices are up and running and healthy, you will receive the
    following output:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果所有微服务都正常运行且状态良好，您将收到以下输出：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_04_18.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本描述自动生成](img/B19825_04_18.png)'
- en: 'Figure 4.18: Checking the status of running microservices'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18：检查运行中的微服务状态
- en: 'If any of the microservices do not have a status of `Up`, check their log output
    for any errors by using the `docker-compose logs` command. For example, you would
    use the following command if you wanted to check the log output for the `product`
    service:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何微服务没有 `Up` 的状态，请使用 `docker-compose logs` 命令检查它们的日志输出中的任何错误。例如，如果您想检查 `product`
    服务的日志输出，您将使用以下命令：
- en: '[PRE38]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At this stage, it is not easy to cause an error to be logged, since the microservices
    are so simple. Instead, here is a sample error log from the `product` microservice
    in *Chapter 6*, *Adding Persistence*. Assume that the following is found in its
    log output:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，由于微服务非常简单，因此不容易记录错误。相反，这里提供了一个来自 *第 6 章*，*添加持久性* 中 *product* 微服务的示例错误日志。假设以下内容出现在其日志输出中：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_04_19.png)Figure
    4.19: Sample error information in the log output'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图形用户界面，文本描述自动生成](img/B19825_04_19.png)图 4.19：日志输出中的示例错误信息'
- en: From reading the above log output, it is quite clear that the `product` microservice
    can’t reach its MongoDB database. Given that the database also runs as a Docker
    container managed by the same Docker Compose file, the `docker-compose logs` command
    can be used to see what’s wrong with the database.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从上面的日志输出中可以看出，`product`微服务无法连接到其MongoDB数据库。鉴于数据库也作为由同一Docker Compose文件管理的Docker容器运行，可以使用`docker-compose
    logs`命令查看数据库的问题。
- en: 'If required, you can restart a failed container with the `docker-compose restart`
    command. For example, you would use the following command if you wanted to restart
    the `product` microservice:'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果需要，可以使用`docker-compose restart`命令重新启动失败的容器。例如，如果你想重新启动`product`微服务，可以使用以下命令：
- en: '[PRE39]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If a container is missing, for example, due to a crash, you start it up with
    the `docker-compose up -d --scale` command. For example, you would use the following
    command for the `product` microservice:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果容器丢失，例如由于崩溃，可以使用`docker-compose up -d --scale`命令启动它。例如，对于`product`微服务，你会使用以下命令：
- en: '[PRE40]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If errors in the log output indicate that Docker is running out of disk space,
    parts of it can be reclaimed with the following command:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果日志输出中的错误表明Docker正在耗尽磁盘空间，可以使用以下命令回收部分空间：
- en: '[PRE41]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once all the microservices are up and running and healthy, run the test script
    again, but without starting the microservices:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有微服务都已启动、运行且状态良好，再次运行测试脚本，但不要启动微服务：
- en: '[PRE42]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The tests should now run fine!
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在测试应该可以顺利运行了！
- en: 'When you are done with the testing, remember to tear down the system landscape:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试完成后，记得拆除系统环境：
- en: '[PRE43]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, a tip about a combined command that builds runtime artifacts and Docker
    images from the source and then executes all tests in Docker:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于一个组合命令的提示，该命令从源代码构建运行时工件和Docker镜像，然后执行Docker中的所有测试：
- en: '[PRE44]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is perfect if you want to check that everything works before you push new
    code to your Git repository or as part of a build pipeline in your build server!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常适合在将新代码推送到Git仓库或作为构建服务器构建管道的一部分之前检查一切是否正常工作！
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how Docker can be used to simplify testing a landscape
    of cooperating microservices.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用Docker简化一组协作微服务的测试。
- en: We learned how Java SE, since v10, honors constraints that we put on containers
    regarding how much CPU and memory they are allowed to use. We have also seen how
    little it takes to make it possible to run a Java-based microservice as a Docker
    container. Thanks to Spring profiles, we can run the microservice in Docker without
    having to make any code changes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，自Java SE v10以来，Java SE会尊重我们对容器施加的限制，即它们可以使用多少CPU和内存。我们还看到了将基于Java的微服务作为Docker容器运行所需的最小步骤。多亏了Spring配置文件，我们可以在Docker中运行微服务而无需对代码进行任何修改。
- en: Finally, we have seen how Docker Compose can help us manage a landscape of cooperating
    microservices with single commands, either manually or, even better, automatically,
    when integrated with a test script such as `test-em-all.bash`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了Docker Compose如何通过单条命令帮助我们管理一组协作的微服务，无论是手动操作，还是与测试脚本（如`test-em-all.bash`）集成时的自动操作。
- en: In the next chapter, we will study how we can add some documentation of the
    API using OpenAPI/Swagger descriptions.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究如何使用OpenAPI/Swagger描述添加API的一些文档。
- en: Questions
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the major differences between a virtual machine and a Docker container?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟机和Docker容器之间有哪些主要区别？
- en: What is the purpose of namespaces and cgroups in Docker?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker中的命名空间和cgroups的目的是什么？
- en: What happens with a Java application that doesn’t honor the max memory settings
    in a container and allocates more memory than it is allowed to?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个Java应用程序不遵守容器中的最大内存设置并分配了超出允许范围的内存，会发生什么？
- en: How can we make a Spring-based application run as a Docker container without
    requiring modifications of its source code?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使基于Spring的应用程序作为Docker容器运行，而无需修改其源代码？
- en: Why will the following Docker Compose code snippet not work?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下Docker Compose代码片段无法工作？
- en: '[PRE45]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
