- en: Testing Your Services with Arquillian
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Arquillian测试你的服务
- en: In this chapter, you will learn how to test your microservices. For this purpose,
    we will use Arquillian, a test framework designed to test software components
    using their dedicated runtime, instead of creating mock-based unit tests. This
    is the framework developer to work seamlessly WildFly Swarm and, effectively,
    a framework of choice for it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何测试你的微服务。为此，我们将使用Arquillian，这是一个专为使用其专用运行时测试软件组件而设计的测试框架，而不是创建基于模拟的单元测试。这是开发人员无缝工作于WildFly
    Swarm的框架，实际上也是WildFly Swarm的首选框架。
- en: We will introduce Arquillian and present the purpose of the project and its
    main features. Later, you will learn how to develop, write, and configure tests
    for your services based on practical examples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍Arquillian，并展示项目目的及其主要特性。稍后，你将基于实际示例学习如何为你的服务开发、编写和配置测试。
- en: Introducing Arquillian
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Arquillian
- en: We all know the benefits of unit testing. They are simple and run immediately.
    They isolate the components of your application and allow you to test them one
    by one, providing the coverage of each component's usage scenarios.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道单元测试的好处。它们简单且可以立即运行。它们隔离了应用程序的组件，并允许你逐个测试它们，从而提供每个组件的使用场景覆盖率。
- en: Unfortunately, unit tests have their shortcomings too. When you cover your application
    with unit tests, they will confirm that each component of your application works
    correctly. Obviously, based only on that information, you cannot deduce that your
    whole application works correctly—that is a reason to have integration tests.
    You have to test your components inside the environment in which they will operate
    to ensure that the application works correctly as a whole.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，单元测试也有其不足之处。当你用单元测试覆盖你的应用程序时，它们将确认应用程序的每个组件都正常工作。显然，仅基于这些信息，你不能推断出整个应用程序都正常工作——这就是需要集成测试的原因。你必须测试你的组件在其将运行的环境中，以确保应用程序作为一个整体正常工作。
- en: The problem with integration tests so far has been that they tend to be complicated
    to configure and took a long time to execute. Here is where Arquillian steps in.
    The aim of the project is to make integration tests as fast and simple to configure
    as unit tests.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，集成测试的问题在于它们往往难以配置，执行时间也很长。这就是Arquillian介入的地方。项目的目标是使集成测试与单元测试一样快且易于配置。
- en: As you may recall, in [Chapter 2](c00cfc93-f395-446e-9132-242f02216783.xhtml),
    *Getting Familiar with WildFly Swarm*, we emphasized how fast modern runtimes
    are. Arquillian takes advantage of that and lets you easily configure the tests
    that run on the same runtime your application will run. If, for example, you are
    developing a Java EE application, you can configure Arquillian to run the test
    on the application server of your choice. Since modern applications servers are
    very fast, the test will run immediately. On the other hand, you will be able
    to test your application in its real environment with all its dependencies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的，在第2章*Getting Familiar with WildFly Swarm*中，我们强调了现代运行时的速度有多快。Arquillian利用这一点，让你能够轻松配置在应用程序将运行的相同运行时上运行的测试。例如，如果你正在开发一个Java
    EE应用程序，你可以配置Arquillian在所选的应用服务器上运行测试。由于现代应用服务器非常快，测试将立即运行。另一方面，你将能够在包含所有依赖项的真实环境中测试你的应用程序。
- en: In our case, a runtime for each service is assembled by WildFly Swarm (as described
    in [Chapter 3](dd01a81c-3ad7-4b3b-80fa-a8af1b89581c.xhtml), *Right-Sizing Your
    Applications*). Arquillian allows you to configure the tests for such cases too.
    Let's find out how.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，每个服务的运行时是由WildFly Swarm组装的（如第3章所述，*Right-Sizing Your Applications*）。Arquillian还允许你为这类情况配置测试。让我们来看看如何操作。
- en: Testing Swarm microservices with Arquillian
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Arquillian测试Swarm微服务
- en: In this section, you will learn how Arquillian can be used to test microservices
    created with Swarm. As you learned in previous chapters, Swarm builds a runtime
    containing only fractions needed by a given service, starts it, and then deploys
    an archive on it, creating the microservice.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用Arquillian测试使用Swarm创建的微服务。正如你在前面的章节中学到的，Swarm构建一个只包含特定服务所需部分的运行时，启动它，然后在上面部署一个存档，创建微服务。
- en: Arquillian, as we have just learned, tests an application on its dedicated runtime.
    It starts the runtime, deploys the tested code on it, and performs the test. Let's
    configure such a test for our JAX-RS and the CDI catalog service example, and
    explain what we are doing step by step.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚学到的，Arquillian 在其专用运行时上测试应用程序。它启动运行时，在它上面部署测试代码，并执行测试。让我们为我们的 JAX-RS 和
    CDI 目录服务示例配置这样的测试，并逐步解释我们在做什么。
- en: 'For examples: refer to `chapter 5/catalog-service-simple-test`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：参考 `第 5 章/catalog-service-simple-test`。
- en: 'First of all, we have to provide all the necessary dependencies:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须提供所有必要的依赖：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Firstly, we added Arquillian to `dependencyManagement` (1).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将 Arquillian 添加到 `dependencyManagement`（1）。
- en: Secondly, Arquillian can be integrated with various testing libraries. As we
    are going to use JUnit, we have to provide the dependency to it (2).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，Arquillian 可以与各种测试库集成。由于我们将使用 JUnit，我们必须提供对其的依赖（2）。
- en: To run the Arquillian test with JUnit, we have to provide JUnit integration
    artifact (3).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 JUnit 运行 Arquillian 测试，我们必须提供 JUnit 集成工件（3）。
- en: Thirdly, we have to tell Arquillian which runtime to use—we are doing this by
    providing a dependency to an adapter library. In our case, this obviously is a
    Swarm adapter (3).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三，我们必须告诉 Arquillian 使用哪个运行时——我们通过提供一个适配器库的依赖来实现这一点。在我们的例子中，这显然是一个 Swarm 适配器（3）。
- en: 'Now we are ready to take a look at the code. To recall, the service in this
    example contains only one item, which is added manually:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好查看代码了。为了回忆，这个例子中的服务只包含一个项目，该项目是手动添加的：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now it is time to write a `test` class. An Arquillian-based test runs in the
    following way: Arquillian looks for the static method annotated with the `org.jboss.arquillian.container.test.api.Deployment`
    annotation. The method has to return the `ShrinkWrap` archive.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写一个 `test` 类了。基于 Arquillian 的测试以以下方式运行：Arquillian 寻找带有 `org.jboss.arquillian.container.test.api.Deployment`
    注解的静态方法。该方法必须返回 `ShrinkWrap` 存档。
- en: 'Arquillian will start the container and deploy the returned archive on it.
    After that, the methods are annotated with `org.junit`. A test runs inside the
    container. Let''s look at all this in our sample test:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian 将启动容器并在其上部署返回的存档。之后，方法被 `org.junit` 注解。测试在容器内运行。让我们在我们的示例测试中查看所有这些：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the beginning, we told JUnit to run the test using Arquillian test controller.
    To do that, we annotated the test with the `@RunWith` annotation, specifying `Arquillian.class`
    as the test runner (1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们告诉 JUnit 使用 Arquillian 测试控制器来运行测试。为此，我们使用 `@RunWith` 注解来标记测试，指定 `Arquillian.class`
    作为测试运行器（1）。
- en: The `createDeployment` (2) method, as its name suggests, is responsible for
    creating the deployment archive, which will be deployed on the configured container.
    To inform Arquillian about it, we have to annotate this method with the `@Deployment`
    annotation. The method is static and returns the `ShrinkWrap` archive. As the
    test method is being run inside the container, we are able to inject its resources.
    In our example, we have to inject the `CatalogService` class that we are going
    to test (3) and the `Item` class on which it depends.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`createDeployment`（2）方法，正如其名称所暗示的，负责创建部署存档，该存档将在配置的容器上部署。为了通知 Arquillian，我们必须使用
    `@Deployment` 注解来标记此方法。该方法为静态，并返回 `ShrinkWrap` 存档。由于测试方法是在容器内运行的，我们能够注入其资源。在我们的例子中，我们必须注入我们即将测试的
    `CatalogService` 类以及它所依赖的 `Item` 类（3）。'
- en: Finally, the `Test` method checks whether the `searchById` method works correctly
    (4).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Test` 方法检查 `searchById` 方法是否正确工作（4）。
- en: 'Let''s run the test now:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行测试：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will note that the test has been deployed inside the Swarm container:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到测试已部署在 Swarm 容器内：
- en: '![](img/727118a6-1419-4f5c-bdcd-f7c758baad20.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/727118a6-1419-4f5c-bdcd-f7c758baad20.png)'
- en: 'It finishes successfully:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功完成：
- en: '![](img/f9321cdb-a3c4-4d01-934e-35c20afb1006.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9321cdb-a3c4-4d01-934e-35c20afb1006.png)'
- en: 'Finally, the Swarm microservice starts (because we used the `wildfly-swarm:run`
    command):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Swarm 微服务启动（因为我们使用了 `wildfly-swarm:run` 命令）：
- en: '![](img/d03f92fc-a1b1-436f-8982-d1585fc913bf.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d03f92fc-a1b1-436f-8982-d1585fc913bf.png)'
- en: Note that Swarm, as in examples from the previous chapters, used the when-missing
    discovery mechanism and created the container with all the necessary fractions.
    That container was used for both testing and running the resulting microservices.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Swarm，如前几章的示例中所示，使用了 when-missing 发现机制，并创建了一个包含所有必要分片的容器。该容器用于测试和运行生成的微服务。
- en: 'As you could notice in the preceding screenshot, the only file that we changed
    was the `pom.xml` file, so the switch from AS to Swarm was again very simple.
    However, this had drawbacks too: not changing the `CatalogTest` class meant that
    we were again creating the archive manually—Swarm can do it for us when the service
    is created so can''t it create the deployment test too? It can—let''s learn how.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中所注意到的，我们唯一更改的文件是`pom.xml`文件，因此从AS切换到Swarm的过程再次非常简单。然而，这也存在一些缺点：没有更改`CatalogTest`类意味着我们再次手动创建存档——当服务创建时Swarm可以为我们创建它，那么它为什么不能创建部署测试呢？它可以——让我们来学习如何做。
- en: The default deployment
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认部署
- en: As we have just hinted, Swarm can create the default test deployment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚暗示的，Swarm可以创建默认的测试部署。
- en: For example, refer to `chapter 5/catalog-service-test-default-deployment`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，请参考`chapter 5/catalog-service-test-default-deployment`。
- en: 'We will modify the `Test` class so that the archive is created automatically:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`Test`类，以便自动创建存档：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to tell Swarm to create the test deployment automatically, we have
    to annotate the class with the `org.wildfly.swarm.arquillian.DefaultDeployment`
    annotation (1). That's just it. If you run the test now, you will see the same
    result as in the preceding paragraph. Note that we didn't use the `@Deployment`
    annotated static method as we did in the preceding example.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉Swarm自动创建测试部署，我们必须使用`org.wildfly.swarm.arquillian.DefaultDeployment`注解来注解类（1）。就是这样。如果你现在运行测试，你将看到与上一段相同的输出。请注意，我们没有像上一个例子那样使用带有`@Deployment`注解的静态方法。
- en: Swarm configuration
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swarm配置
- en: In the preceding chapter, we showed you how to modify the Swarm configuration.
    The example that we used to present that was a database configuration. In this
    section, we will show you how to provide analogous configuration for a Swarm test
    using the same example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向您展示了如何修改Swarm配置。我们用来展示的例子是一个数据库配置。在本节中，我们将向您展示如何使用相同的例子为Swarm测试提供类似的配置。
- en: For examples, refer to `chapter 5/catalog-service-database-test`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，请参考`chapter 5/catalog-service-database-test`。
- en: 'If you would like to create the Swarm container manually, you have to implement
    the static method annotated with the `org.wildfly.swarm.arquillian.CreateSwarm`
    annotation and return the instance of the `org.wildfly.swarm.Swarm` class from
    it. As you probably recall, we have already created a lot of Swarm containers
    inside the `main` functions that we created in [Chapter 4](d76eaa85-5053-41f6-bcd1-307db5a17f60.xhtml),
    *Tuning the Configuration of Your Services*. Swarm-creating methods that we will
    use in the tests work the same way. Let''s take a look at the code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要手动创建Swarm容器，你必须实现一个带有`org.wildfly.swarm.arquillian.CreateSwarm`注解的静态方法，并从其中返回`org.wildfly.swarm.Swarm`类的实例。你可能还记得，我们在[第4章](d76eaa85-5053-41f6-bcd1-307db5a17f60.xhtml)“调整服务配置”中创建的`main`函数内部已经创建了很多Swarm容器。我们将要使用的测试中的Swarm创建方法也是同样的工作方式。让我们看看代码：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the beginning, we created the deployment with all the necessary classes and
    configurations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们创建了包含所有必要类和配置的部署。
- en: We have to add the datasource configuration, the persistence configuration,
    and the load file (1) so that they can be read from within the test.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加数据源配置、持久化配置和加载文件（1），以便它们可以在测试中读取。
- en: The key part is the `createSwarm` method (2) mentioned previously. It creates
    the Swarm instance, reads the datasources configuration (3), and configures Swarm
    with it (4).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分是之前提到的`createSwarm`方法（2）。它创建Swarm实例，读取数据源配置（3），并使用它配置Swarm（4）。
- en: When the container and deployment are ready, we can start writing the test logic.
    We start by injecting the `CatalogService` to the test (4). Recall that this test
    runs inside the Swarm container, and as a result, the service can be injected
    into it. Finally, to ensure that our service indeed works correctly, we check
    whether the returned data is correct (5).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器和部署就绪时，我们可以开始编写测试逻辑。我们首先将`CatalogService`注入到测试中（4）。回想一下，这个测试是在Swarm容器中运行的，因此服务可以被注入其中。最后，为了确保我们的服务确实工作正确，我们检查返回的数据是否正确（5）。
- en: If you run the test now, you will see that it passes correctly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行测试，你会看到它正确通过。
- en: However, currently, we are creating the microservices without any endpoints
    and testing them from inside the container. That's OK, but we would also like
    to test the whole microservice, using its external interface. Let's take a look
    at how to do it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前我们正在创建没有端点的微服务，并在容器内部对其进行测试。这没问题，但我们还想测试整个微服务，使用其外部接口。让我们看看如何做到这一点。
- en: Testing from a standalone client
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从独立客户端进行测试
- en: This time, we would like to test the application from a standalone client. Let's
    learn how to do it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们希望从独立客户端测试应用程序。让我们学习如何做到这一点。
- en: For examples, refer to `chapter 5/catalog-service-database-test-standalone`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，请参考`第5章/catalog-service-database-test-standalone`。
- en: 'First of all, we have to add a bunch of dependencies to the `pom.xml` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须向`pom.xml`文件中添加一些依赖项：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have to add a dependency to the JAX-RS client that we will use to make REST
    invocations on our service. As we will use the `resteasy` implementation, we will
    add its client (1). We would also need a library to parse the JSON response, hence
    the `resteasy-jackson-provider` is added (2).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加一个依赖项到我们将用于对服务进行REST调用的JAX-RS客户端。由于我们将使用`resteasy`实现，我们将添加其客户端（1）。我们还需要一个库来解析JSON响应，因此添加了`resteasy-jackson-provider`（2）。
- en: 'Let''s take a look at the code of the test that does it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现这一功能的代码：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is quite a bit of stuff that we had to implement. Let's analyze it one
    by one.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不实现很多东西。让我们逐一分析。
- en: As we are going to test the REST endpoint, we have to add classes that will
    expose it, that is, `CatalogResource` and `CatalogApplication` (1).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将测试REST端点，我们必须添加将暴露它的类，即`CatalogResource`和`CatalogApplication`（1）。
- en: Arquillian is able to find out the URL of a created service and inject it into
    the test. To obtain such an object, we have to annotate the URL field with the
    `org.jboss.arquillian.test.api.ArquillianResource` annotation (4).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian能够找出创建的服务URL并将其注入到测试中。为了获取这样的对象，我们必须使用`org.jboss.arquillian.test.api.ArquillianResource`注解来注解URL字段（4）。
- en: We have implemented the convenience test method, which makes invocations to
    the service and obtains item instances, based on the ID (5).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了便利的测试方法，该方法根据ID调用服务并获取项目实例（5）。
- en: The most important addition to the test is annotating the `test` methods with
    the `org.jboss.arquillian.container.test.api.RunAsClient`annotation. As a result,
    the test will run from Maven's JVM as a standalone client. We are using the test
    annotated in this way in order to create a test that will assert the correct behavior
    of our service, based on invocations from the test JVM (6).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中最重要的新增是使用`org.jboss.arquillian.container.test.api.RunAsClient`注解来注解`test`方法。结果，测试将在Maven的JVM中以独立客户端的方式运行。我们使用这种方式注解的测试是为了创建一个测试，该测试将基于从测试JVM的调用来断言我们服务的正确行为（6）。
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what Arquillian is and how you can use it to test
    Swarm microservices. You also learned how to configure Arquillian to automatically
    create a Swarm container, how to modify the container configuration, and how to
    test the created microservice from within the container and from a standalone
    client.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Arquillian是什么以及如何使用它来测试Swarm微服务。你还学习了如何配置Arquillian以自动创建Swarm容器，如何修改容器配置，以及如何从容器内部和从独立客户端测试创建的微服务。
- en: Further reading
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[http://arquillian.org/](http://arquillian.org/)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://arquillian.org/](http://arquillian.org/)'
