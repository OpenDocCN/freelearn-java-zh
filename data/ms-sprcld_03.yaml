- en: Spring Cloud Overview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud概览
- en: 'In [Chapter 1](33ddbb93-e658-4d91-97f5-06d6167ef89e.xhtml), *Introduction to
    Microservices*, I mentioned the cloud-native development style and also that Spring
    Cloud helps you in the easy adoption of the best practices associated with this
    concept. The most commonly used best practices have been collected together in
    an interesting initiative called **The Twelve-Factor App**. As you might read
    on their website ([https://12factor.net/](https://12factor.net/)), this is a methodology
    for building **Software as a Service** (**SaaS**) modern applications, which must
    be scalable, easily deployable on cloud platforms, and delivered in the continuous
    deployment process. It is worth being familiar with these principles, especially
    if you are a developer who builds applications running as a service. Spring Boot
    and Spring Cloud provide features and components that make your application compliant
    with *Twelve-Factor rules*. We can distinguish some typical features that the
    most modern distributed systems usually use. Every opinionated framework should
    provide them and there is no difference for Spring Cloud. Those features are as
    follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](33ddbb93-e658-4d91-97f5-06d6167ef89e.xhtml)，*微服务介绍*中，我提到了基于云的开发风格，以及Spring
    Cloud如何帮助你轻松采用与这种概念相关的最佳实践。最常用的最佳实践已经被收集在一个有趣的倡议中，称为**The Twelve-Factor App**。正如你可能会在他们网站上读到的（[https://12factor.net/](https://12factor.net/)），这是一种构建**软件即服务**（**SaaS**）现代应用程序的方法，这种应用程序必须是可扩展的，容易在云平台上部署，并以持续部署过程提供。熟悉这些原则尤其值得，特别是如果你是一个构建作为服务运行的应用程序的开发者。Spring
    Boot和Spring Cloud提供了使你的应用程序符合*Twelve-Factor规则*的特性和组件。我们可以区分出一些最现代分布式系统通常使用的典型特性。每个有见地的框架都应该提供它们，Spring
    Cloud也不例外。这些特性如下：
- en: Distributed/versioned configuration
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式/版本化配置
- en: Service registration and discovery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册与发现
- en: Routing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Service-to-service calls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务间调用
- en: Load balancing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Circuit breakers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器
- en: Distributed messaging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式消息传递
- en: Beginning with the basics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从基础开始
- en: 'Let''s go back to the previous chapter for a moment. There I have already described
    in detail the structure of a Spring Boot project. Configuration should be provided
    in YAML or a properties file with the application or the `application-{profile}`
    name. In contrast to a standard Spring Boot application, Spring Cloud is based
    on the configuration taken from a remote server. However, minimal settings are
    needed inside the application; for example, its name and config server address.
    That''s why a Spring Cloud application creates a bootstrap context, which is responsible
    for loading properties from the external sources. Bootstrap properties are added
    with the highest priority and they cannot be overridden by local configuration.
    Bootstrap context, which is a parent for the main application context, uses `bootstrap.yml`
    instead of `application.yml`. Usually, we put the application name and Spring
    Cloud Config settings, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回到上一章的内容。在那儿，我已经详细介绍了Spring Boot项目的结构。配置应该提供在YAML文件或以应用程序或`application-{profile}`命名的属性文件中。与标准的Spring
    Boot应用程序相比，Spring Cloud是基于从远程服务器获取的配置。然而，在应用程序内部只需要最少的设置；例如，其名称和配置服务器地址。这就是为什么Spring
    Cloud应用程序创建了一个引导上下文，负责从外部来源加载属性。引导属性具有最高优先级，它们不能被本地配置覆盖。引导上下文是主应用程序上下文的父级，它使用`bootstrap.yml`而不是`application.yml`。通常，我们将应用程序名称和Spring
    Cloud Config设置放在下面这样：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Bootstrap context startup can be easily disabled by setting the `spring.cloud.bootstrap.enabled` property
    to `false`. We can also change the name of the bootstrap configuration file using
    the `spring.cloud.bootstrap.name` property or even changing the location by setting
    `spring.cloud.bootstrap.location`. The profile mechanisms are also available here,
    so we are allowed to create, for example, `bootstrap-development.yml`, which is
    loaded on an active development profile. This and some other features are available
    in the Spring Cloud Context library, which is added as a parent dependency to
    the project classpath together with any other Spring Cloud library. One of these
    features is some additional management endpoints included with the Spring Boot
    Actuator:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`spring.cloud.bootstrap.enabled`属性设置为`false`，可以轻松禁用Bootstrap上下文的启动。我们还可以使用`spring.cloud.bootstrap.name`属性更改引导配置文件的名称，或者通过设置`spring.cloud.bootstrap.location`来更改其位置。在这里也可以使用配置文件机制，因此我们可以创建例如`bootstrap-development.yml`的文件，在激活的开发配置文件上进行加载。Spring
    Cloud Context库中提供了这些以及其他一些特性，该库作为项目类路径的父依赖与其他任何Spring Cloud库一起添加。其中一些特性包括与Spring
    Boot Actuator一起提供的附加管理端点：
- en: '`env`: A new `POST` method for `Environment`, log levels update, and `@ConfigurationProperties`
    rebind'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`：新的`POST`方法用于`Environment`，日志级别更新和`@ConfigurationProperties`重新绑定'
- en: '`refresh`: This reloads bootstrap context and refreshes all beans annotated
    with `@RefreshScope`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`refresh`：重新加载引导上下文并刷新所有带有`@RefreshScope`注解的bean'
- en: '`restart`: This restarts Spring `ApplicationContext`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：重新启动Spring `ApplicationContext`'
- en: '`pause`: This stops Spring `ApplicationContext`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause`：停止Spring `ApplicationContext`'
- en: '`resume`: This starts Spring `ApplicationContext`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resume`：启动Spring `ApplicationContext`'
- en: The next library together with Spring Cloud Context, which is included as a
    parent dependency with Spring Cloud projects, is Spring Cloud Commons. It provides
    a common abstraction layer for mechanisms such as service discovery, load balancing, and
    circuit breakers. These include, among other things, frequently used annotations
    such as `@EnableDiscoveryClient` or `@LoadBalanced`. I'll present more details
    about them in the following chapters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与Spring Cloud Context一起作为Spring Cloud项目的父依赖包含在项目中的下一个库是Spring Cloud Commons。它为诸如服务发现、负载均衡和断路器等机制提供了一个共同的抽象层。这些包括其他常用注解，如`@EnableDiscoveryClient`或`@LoadBalanced`。关于它们的详细信息，我将在接下来的章节中介绍。
- en: Netflix OSS
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix OSS
- en: On reading the first two chapters, you have probably noticed the appearance
    of many keywords related to microservice architecture. For some of you, it might
    be a new term, for others, it is well known. But so far, one important word to
    the microservices community has not been mentioned yet. It is definitely known
    by most of you, this word is *Netflix*. Well, I also like their TV shows and other
    productions, but for developers, they are famous for another reason. This reason
    is microservices. Netflix is one of the earliest pioneers of migration from a
    traditional development model where we created monolithic applications for a cloud-native
    microservices development approach. This company shares their expertise with the
    community by pushing a great part of the source code into the public repository,
    speaking in conference presentations, and publishing blog posts. Netflix has been
    so successful with its architecture concept that they became a role model for
    other large organizations and their IT architects such as Adrian Cockcroft are
    now prominent evangelists for microservices. In turn, many open source frameworks
    based their libraries on the solutions available under the code shared by Netflix.
    It is no different for Spring Cloud, which provides integrations with the most
    popular Netflix OSS features such as Eureka, Hystrix, Ribbon, or Zuul.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读前两章之后，你们可能已经注意到了许多与微服务架构相关的关键词。对于一些人来说，这可能是一个新术语，对于其他人来说，它可能是众所周知的。但到目前为止，对微服务社区来说还有一个重要的词还没有提到。大多数你们肯定都知道，这个词是*Netflix*。嗯，我也喜欢他们的电视剧和其他制作，但对我来说，他们因为另一个原因而出名。这个原因就是微服务。Netflix是最早从传统的开发模式迁移到基于云的微服务开发方法的先驱之一。这家公司通过将大部分源代码推送到公共仓库、在会议演讲中发言以及发布博客文章，与社区分享他们的专业知识。Netflix在其架构概念上的成功是如此之大，以至于它们成为了其他大型组织和他们的IT架构师（如Adrian
    Cockcroft）的榜样，这些人现在是微服务的突出倡导者。作为回报，许多开源框架将它们的库基于Netflix共享的代码下的解决方案。对于Spring Cloud来说也不例外，它提供了与最流行的Netflix
    OSS特性（如Eureka、Hystrix、Ribbon或Zuul）的集成。
- en: 'By the way, I don''t know if you have been following Netflix, but they shed
    some light on the reasons why they decided to open source much of their code. I
    think it is worth quoting because that partly explains the success and unwaning
    popularity of their solutions in the IT world:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我不知道你是否一直在关注Netflix，但他们透露了他们决定开源大部分代码的原因。我认为值得引用，因为这部分解释了他们在IT世界中成功和持续受欢迎的原因：
- en: '"When we said we were going to move all of Netflix to the cloud everyone said
    we were completely crazy. They didn''t believe we were actually doing that, they
    thought we were just making stuff up."'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “当我们说我们要将整个Netflix搬到云端时，每个人都认为我们完全疯了。他们不相信我们真的在做这件事，他们认为我们只是在编造故事。”
- en: Service discovery with Eureka
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Eureka进行服务发现
- en: The first pattern provided by Spring Cloud Netflix is the service discovery
    with Eureka. This package is divided into client and server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由Spring Cloud Netflix提供的第一个模式是使用Eureka进行服务发现。这个包分为客户端和服务器端。
- en: To include a Eureka Client in your project you should use the `spring-cloud-starter-eureka` starter.
    The client is always a part of an application and is responsible for connecting
    to a remote discovery server. Once the connection is established it should send
    a registration message with a service name and network location. In case the current
    microservice has to call an endpoint from another microservice, the client should
    retrieve the newest configuration with a list of registered services from the server.
    The server can be configured and run as an independent Spring Boot application
    and it is supposed to be highly available with each server replicating its state
    to other nodes. To include a Eureka Server in your project you need to use the
    `spring-cloud-starter-eureka-server` starter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中包含Eureka客户端，你应该使用`spring-cloud-starter-eureka`启动器。客户端总是应用程序的一部分，负责连接远程发现服务器。一旦建立连接，它应该发送一个包含服务名称和网络位置的注册消息。如果当前微服务需要调用另一个微服务的端点，客户端应该从服务器检索带有已注册服务列表的最新配置。服务器可以作为独立的Spring
    Boot应用程序进行配置和运行，并且每个服务器都应该将其状态复制到其他节点以实现高可用性。要在项目中包含Eureka服务器，你需要使用`spring-cloud-starter-eureka-server`启动器。
- en: Routing with Zuul
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Zuul进行路由
- en: The next popular pattern available under the Spring Cloud Netflix project is
    intelligent routing with Zuul. It is not only a JVM-based router but it also acts
    as a server-side load balancer and/or performs some filtering. It can also have
    a wide variety of applications. Netflix uses it for cases such as authentication,
    load shedding, static response handling, or stress testing. It is the same as
    Eureka Server in that it can be configured and run as an independent Spring Boot
    application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud Netflix项目中可用的下一个流行模式是使用Zuul进行智能路由。它不仅仅是一个基于JVM的路由器，还充当服务器端负载均衡器，执行某些过滤操作。它还有各种各样的应用。Netflix用它来处理诸如认证、负载均衡、静态响应处理或压力测试等情况。它与Eureka
    Server相同，可以作为独立的Spring Boot应用程序进行配置和运行。
- en: To include Zuul in your project use the `spring-cloud-starter-zuul` starter.
    In the microservices architecture, Zuul has a vital role of the API gateway, which
    is an entry point to the whole system. It needs to have knowledge of the network
    location of each service, so it is able to interact with the Eureka Server by
    including the discovery client to the classpath.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中包含Zuul，请使用`spring-cloud-starter-zuul`启动器。在微服务架构中，Zuul作为API网关扮演着至关重要的角色，它是整个系统的入口点。它需要了解每个服务的网络位置，因此通过将发现客户端包含在类路径中与Eureka
    Server进行交互。
- en: Load balancing with Ribbon
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ribbon进行负载均衡
- en: We cannot ignore the next Spring Cloud Netflix feature used for client-side
    load balancing—Ribbon. It supports the most popular protocols such as TCP, UDP,
    and HTTP. It can be used not only for synchronous REST calls, but also in asynchronous
    and reactive models. In addition to load balancing, it provides integration with
    service discovery, caching, batching, and fault tolerance. Ribbon is the next
    abstraction level over basic HTTP and TCP clients.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忽视用于客户端负载均衡的下一个Spring Cloud Netflix功能——Ribbon。它支持最流行的协议，如TCP、UDP和HTTP。它不仅可以用于同步REST调用，还可以用于异步和反应式模型。除了负载均衡外，它还提供与服务发现、缓存、批处理和容错集成的功能。Ribbon是基本HTTP和TCP客户端的下一个抽象级别。
- en: To include it in your project use the `spring-cloud-starter-ribbon` starter. Ribbon
    supports round robin, availability filtering, and weighted response time load
    balancing rules out-of-the-box and can be easily extended with custom defined
    rules. It is based on the *named client* concept, where servers included for the
    load balancing should be provided with a name.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其纳入您的项目，请使用`spring-cloud-starter-ribbon`启动器。Ribbon支持循环冗余、可用性过滤和加权响应时间负载均衡规则，并且可以很容易地通过自定义规则进行扩展。它基于*命名客户端*概念，其中用于负载均衡的服务应提供名称。
- en: Writing Java HTTP clients
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Java HTTP客户端
- en: Feign is a slightly less popular Netflix OSS package. It is a declarative REST
    client, which helps us in writing web service clients more easily. With Feign,
    a developer only needs to declare and annotate an interface while the actual implementation
    will be generated at runtime.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Feign是Netflix OSS包中稍微不太流行的一个。它是一个声明性的REST客户端，可以帮助我们更容易地编写Web服务客户端。使用Feign，开发者只需声明和注解一个接口，而实际实现将在运行时生成。
- en: To include Feign in your project you need to use the `spring-cloud-starter-feign` starter.
    It integrates with the Ribbon client, so it supports, by default, load balancing
    and other Ribbon features including communication with the discovery service.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的项目中包含Feign，您需要使用`spring-cloud-starter-feign`启动器。它与Ribbon客户端集成，因此默认支持负载均衡和其他Ribbon功能，包括与发现服务的通信。
- en: Latency and fault tolerance with Hystrix
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hystrix实现延迟和容错
- en: I have already mentioned the circuit breaker pattern in [Chapter 1](33ddbb93-e658-4d91-97f5-06d6167ef89e.xhtml),
    *Introduction to Microservices*, and Spring Cloud provides a library that implements
    this pattern. It is based on the Hystrix package created by Netflix as a circuit
    breaker implementation. Hystrix is by default integrated with the Ribbon and Feign
    clients. Fallback is closely related to the circuit breaker concept. With Spring
    Cloud libraries you can easily configure fallback logic, which should be performed
    if there is a read or circuit breaker timeout. To include Hystrix in your project
    you should use the `spring-cloud-starter-hystrix` starter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在[第1章](33ddbb93-e658-4d91-97f5-06d6167ef89e.xhtml)，*微服务简介*中提到了断路器模式，Spring
    Cloud提供了一个实现此模式的库。它基于Netflix创建的Hystrix包，作为断路器实现。Hystrix默认与Ribbon和Feign客户端集成。回退与断路器概念紧密相关。使用Spring
    Cloud库，您可以轻松配置回退逻辑，如果存在读取或断路器超时，应执行此逻辑。您应该使用`spring-cloud-starter-hystrix`启动器将Hystrix纳入您的项目。
- en: Configuration management with Archaius
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Archaius进行配置管理
- en: The last important feature provided under the Spring Cloud Netflix project is
    Archaius. Personally, I haven't touched this library, but it might be useful in
    some cases. The Spring Cloud reference Archaius is an extension of the Apache
    Commons Configuration project. It allows updating the configuration by either
    polling a source for changes or pushing changes to the client.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud Netflix项目中提供的最后一个重要功能是Archaius。我个人没有接触过这个库，但在某些情况下可能很有用。Spring
    Cloud参考Archaius是Apache Commons Configuration项目的扩展。它允许通过轮询源进行配置更新或将更改推送到客户端。
- en: Discovery and distributed configuration
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现与分布式配置
- en: Service discovery and distributed configuration management are vital parts of
    the microservices architecture. The technical implementation of these two different
    mechanisms is pretty similar. It comes down to storing parameters under specific
    keys in a flexible key-value storage. Actually, there are several interesting
    solutions available on the market which provide both of these functionalities.
    Spring Cloud integrates with the most popular of them. But there is also one exception
    where Spring Cloud has its own implementation created only for distributed configuration.
    This feature is available under the Spring Cloud Config project. In contrast,
    Spring Cloud does not provide its own implementation for service registration
    and discovery.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现和分布式配置管理是微服务架构的两个重要部分。这两种不同机制的技术实现非常相似。它归结为在灵活的键值存储中存储特定键下的参数。实际上，市场上有一些有趣的解决方案可以提供这两种功能。Spring
    Cloud与其中最受欢迎的解决方案集成。但是，还有一个例外，Spring Cloud有自己的实现，仅用于分布式配置。此功能在Spring Cloud Config项目中提供。相比之下，Spring
    Cloud不提供其自己的服务注册和发现实现。
- en: As usual, we can divide this project into the server and client-side support. The
    server is the one, central place where all of the external properties for applications
    are managed across all of the environments. Configuration can be maintained simultaneously
    in several versions and profiles. This is achieved by using Git as a storage backend.
    The mechanism is really smart and we will discuss it in detail in [Chapter 5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), *Distributed
    Configuration with Spring Cloud Config*. The Git backend is not the only one option
    for storing properties. The config files could also be located on a file system
    or server classpath. The next option is to use Vault as a backend. Vault is an
    open source tool for managing secrets such as tokens, passwords, or certificates
    released by HashiCorp. I know that many organizations pay particular attention
    to security issues such as storing credentials in a secure place, so it could
    be the right solution for them. Generally, we can also manage security on the
    configuration server access level. No matter which backend is used for storing
    properties, Spring Cloud Config Server exposes an HTTP, resource-based API which
    provides easy access to them. By default, this API is secured with basic authentication,
    but it is also available to set an SSL connection with private/public key authentication.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们可以将这个项目分为服务器和客户端支持两部分。服务器是所有外部属性的集中管理的地方，跨所有环境管理应用程序的属性。配置可以同时维护几个版本和配置文件。这是通过使用Git作为存储后端来实现的。这个机制非常智能，我们将在[第5章](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml)，*Spring
    Cloud Config的分布式配置*中详细讨论它。Git后端不是存储属性的唯一选项。配置文件也可以位于文件系统或服务器类路径上。下一个选项是使用Vault作为后端。Vault是HashiCorp发布的一个开源工具，用于管理令牌、密码或证书等秘密。我知道许多组织特别关注诸如将凭据存储在安全地方等安全问题，所以这可能是他们的正确解决方案。通常，我们也可以在配置服务器访问级别管理安全。无论使用哪种后端存储属性，Spring
    Cloud Config Server都暴露了一个基于HTTP的API，提供轻松访问它们。默认情况下，这个API通过基本身份验证保护，但也可以设置使用私钥/公钥身份验证的SSL连接。
- en: A server can be run as an independent Spring Boot application with properties
    exposed over the REST API. To enable it for our project we should add the `spring-cloud-config-server`
    dependency. There is also support on the client-side. Every microservice that
    uses a configuration server as a properties source needs to connect to it just
    after startup, before creating any Spring beans. Interestingly, the Spring Cloud
    Config Server can be used by non Spring applications. There are some popular microservice
    frameworks that integrate with it on the client side. To enable Spring Cloud Config
    Client for your application you need to include the `spring-cloud-config-starter`
    dependency.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务器可以作为一个独立的Spring Boot应用程序运行，并通过REST API暴露属性。为了在我们的项目中启用它，我们应该添加`spring-cloud-config-server`依赖。在客户端也有支持。每个使用配置服务器作为属性源的微服务在启动后都需要连接到它，在创建任何Spring
    bean之前。有趣的是，Spring Cloud Config Server可以被非Spring应用程序使用。有一些流行的微服务框架在客户端与之集成。为了在你的应用程序中启用Spring
    Cloud Config Client，你需要包含`spring-cloud-config-starter`依赖。
- en: An alternative – Consul
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个替代方案——Consul
- en: An interesting alternative for Netflix discovery and Spring distributed configuration seems
    to be Consul created by Hashicorp. Spring Cloud provides integrations with this
    popular tool for discovering and configuring services in your infrastructure.
    As usual, this integration can be enabled using a few simple common annotations
    and the only difference in comparison with an earlier presented solution is in
    configuration settings. In order to establish communication with a Consul server,
    its agent needs to be available for the application. It has to be able to run
    as a separated process, which is available by default at the `http://localhost:8500`
    address. Consul also provides REST API, which can be directly used for registration,
    collecting a list of services, or configuration of properties.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Netflix发现和Spring分布式配置，Consul（由Hashicorp创建）似乎是一个有趣的选择。Spring Cloud为与这个流行的工具集成提供了发现和配置服务器的整合。像往常一样，这个集成可以通过一些简单的公共注解启用，与之前介绍的解决方案相比，唯一的区别在于配置设置。为了与Consul服务器建立通信，应用程序需要有一个可用的Consul代理。它必须能够作为一个分离的进程运行，默认情况下可以通过`http://localhost:8500`地址访问。Consul还提供了REST
    API，可以直接用于注册、收集服务列表或配置属性。
- en: To activate Consul Service Discovery we need to use the `spring-cloud-starter-consul-discovery` starter.
    After application startup and registration, a client would query Consul in order
    to locate other services. It supports both the client-side load balancer with
    Netflix Ribbon and dynamic router and filter with Netflix Zuul.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活Consul服务发现，我们需要使用`spring-cloud-starter-consul-discovery`启动器。在应用程序启动和注册后，客户端将查询Consul以定位其他服务。它支持使用Netflix
    Ribbon的客户端负载均衡器以及使用Netflix Zuul的动态路由和过滤器。
- en: Apache Zookeeper
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Zookeeper
- en: The next popular solution within this area supported by Spring Cloud is Apache
    Zookeeper. Following its documentation, it is a centralized service for maintaining
    configuration, naming, which also provides distributed synchronization, and is
    able to group services. Everything that has previously applied to Consul regarding
    support in Spring Cloud is also true for Zookeeper. I'm thinking here about simple
    common annotations, which have to be used to enable integration, configuration
    though properties inside settings files and auto-configuration for interacting
    with Ribbon or Zuul. To enable service discovery with Zookeeper on the client
    side we need not only include `spring-cloud-starter-zookeeper-discovery`, but
    also Apache Curator. It provides an API framework and utilities to make integration
    easy and more reliable. It is not needed for distributed configuration clients
    where we only have to include the `spring-cloud-starter-zookeeper-config` for
    our project dependencies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域内，Spring Cloud支持的下一个流行解决方案是Apache Zookeeper。按照其文档，它是一个维护配置、命名的中间服务，也提供分布式同步，并能够分组服务。之前应用于Consul的支持在Spring
    Cloud中也是一样的。我想在这里提到的是简单的通用注解，它们必须用于启用集成、配置，通过设置文件中的属性以及与Ribbon或Zuul交互的自动配置。要在客户端方面启用与Zookeeper的服务发现，我们不仅需要包括`spring-cloud-starter-zookeeper-discovery`，还需要Apache
    Curator。它提供了一个API框架和工具，使集成更加容易和可靠。在分布式配置客户端方面，我们只需要在项目依赖中包含`spring-cloud-starter-zookeeper-config`。
- en: Miscellaneous projects
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他各种项目
- en: It is worth mentioning two other projects, which are now in the incubation stage.
    All such projects are available in the GitHub repository, [https://github.com/spring-cloud-incubator](https://github.com/spring-cloud-incubator).
    Some of them will probably be officially attached to the Spring Cloud package
    in the short term. The first of them is Spring Cloud Kubernetes, which provides
    integration with this very popular tool. We could talk about it for a long time,
    but let's try to introduce it in a few words. It is a system for automating deployment,
    scaling, and management of containerized applications originally designed by Google.
    It is used for container orchestration and has many interesting features including
    service discovery, configuration management, and load balancing. In some cases,
    it might be treated as Spring Cloud's competition. The configuration is provided
    with the usage of YAML files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 值得提到的是另外两个现在处于孵化阶段的项目。所有这些项目都可以在GitHub仓库中找到，[https://github.com/spring-cloud-incubator](https://github.com/spring-cloud-incubator)。其中一些可能会很快正式加入Spring
    Cloud包。第一个是Spring Cloud Kubernetes，它提供了与这个非常受欢迎的工具的集成。我们可以谈论它很长时间，但让我们尝试用几句话来介绍它。它是一个自动化部署、扩展和管理容器化应用程序的系统，最初由Google设计。它用于容器编排，并具有许多有趣的功能，包括服务发现、配置管理和负载均衡。在某些情况下，它可能会被视为Spring
    Cloud的竞争对手。配置是通过使用YAML文件来提供的。
- en: Important features from the Spring Cloud point of view are service discovery
    and distributed configuration mechanisms, which are available on the Kubernetes
    platform. To use them in your application you should include `spring-cloud-starter-kubernetes`
    starter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud的角度来看，重要的功能包括服务发现和分布式配置机制，这些机制在Kubernetes平台上可用。要使用它们，你应该包括`spring-cloud-starter-kubernetes`启动器。
- en: The second interesting project at the incubation stage is Spring Cloud Etcd.
    Exactly the same as before, its main features are distributed configuration, service
    registration, and discovery. Etcd is not a powerful tool like Kubernetes. It just
    provides a distributed key-value store with a reliable way to store data in a
    clustered environment. And a little trivia—Etcd is the backend for service discovery,
    cluster state, and configuration management in Kubernetes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在孵化阶段的第二个有趣项目是Spring Cloud Etcd。与之前完全一样，它的主要特点包括分布式配置、服务注册和发现。Etcd并不是像Kubernetes那样的强大工具。它只是为集群环境提供了一个可靠的键值存储的分布式键值存储，以及一点小八卦——Etcd是Kubernetes中服务发现、集群状态和配置管理的后端。
- en: Distributed tracing with Sleuth
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sleuth 的分布式追踪
- en: Another one of Spring Cloud's essential functionalities is distributed tracing.
    It is implemented in the Spring Cloud Sleuth library. Its primary purpose is to
    associate subsequent requests dispatched between different microservices under
    processing single input request. As in most cases, these are HTTP requests that
    implement tracing mechanisms based on HTTP headers. The implementation is built
    over Slf4j and MDC. Slf4j provides facade and abstraction for specific logging
    frameworks such as logback, log4j, or `java.util.logging`. **MDC** or **mapped
    diagnostic context** in full, is a solution for distinguishing log output from
    different sources and enriching them with additional information that could be
    not available in the actual scope.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud 的另一个关键功能是分布式追踪，它是在 Spring Cloud Sleuth 库中实现的。其主要目的是将处理单个输入请求的不同微服务之间传递的后续请求相关联。在大多数情况下，这些都是基于
    HTTP 头实现追踪机制的 HTTP 请求。该实现基于 Slf4j 和 MDC。Slf4j 为特定的日志框架（如 logback、log4j 或 `java.util.logging`）提供外观和抽象。**MDC**
    或者 **映射诊断上下文**，全称是解决方案，用于区分来自不同来源的日志输出，并丰富它们附加在实际作用域中不可用的信息。
- en: Spring Cloud Sleuth adds trace and span IDs to the Slf4J MDC, so that we are
    able to extract all of the logs with a given trace or span. It also adds some
    other entries such as application name or exportable flag. It integrates with
    the most popular messaging solutions such as Spring REST template, Feign client,
    Zuul filters, Hystrix, or Spring Integration message channels. It can also be
    used together with RxJava or scheduled tasks. To enable it in your project you
    should add the `spring-cloud-starter-sleuth` dependency. The usage of basic span
    and trace IDs mechanisms is completely transparent for a developer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Sleuth 在 Slf4J MDC 中添加了追踪和跨度 ID，这样我们就能提取具有给定追踪或跨度所有的日志。它还添加了一些其他条目，如应用程序名称或可导出标志。它与最受欢迎的消息解决方案集成，如
    Spring REST 模板、Feign 客户端、Zuul 过滤器、Hystrix 或 Spring Integration 消息通道。它还可以与 RxJava
    或计划任务一起使用。为了在您的项目中启用它，您应该添加`spring-cloud-starter-sleuth`依赖。对于基本跨度 ID 和追踪 ID 机制的使用对开发者是完全透明的。
- en: Adding tracing headers is not the only feature of Spring Cloud Sleuth. It is
    also responsible for recording timing information, which is useful in latency
    analysis. Such statistics can be exported to Zipkin, a tool that can be used for
    querying and visualization timing data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 添加追踪头并不是 Spring Cloud Sleuth 的唯一功能。它还负责记录时间信息，这在延迟分析中非常有用。这些统计信息可以导出到 Zipkin，这是一个用于查询和可视化时间数据的工具。
- en: Zipkin is a distributing tracing system specially designed for analyzing latency
    problems inside microservices architecture. It exposes HTTP endpoints used for
    collecting input data. To enable generating and sending traces to Zipkin we should
    include the `spring-cloud-starter-zipkin` dependency to the project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin 是一个为分析微服务架构内部延迟问题而特别设计的分布式追踪系统。它暴露了用于收集输入数据的 HTTP 端点。为了启用生成并将追踪数据发送到
    Zipkin，我们应该在项目中包含`spring-cloud-starter-zipkin`依赖。
- en: Frequently, there is no need to analyze everything; the input traffic volume
    is so high that we would need to collect only a certain percentage of data. For
    that purpose, Spring Cloud Sleuth provides a sampling policy, where we can decide
    how much input traffic is sent to Zipkin. The second smart solution to the big
    data problem is to send statistics using the message broker instead of the default
    HTTP endpoint. To enable this feature we have to include the `spring-cloud-sleuth-stream` dependency,
    which allows your application to become a producer of messages sent to Apache
    Kafka or RabbitMQ.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，没有必要分析所有内容；输入流量如此之大，我们只需要收集一定比例的数据。为此，Spring Cloud Sleuth 提供了一个采样策略，我们可以决定发送多少输入流量到
    Zipkin。解决大数据问题的第二个智能方案是使用消息代理发送统计数据，而不是默认的 HTTP 端点。为了启用这个特性，我们必须包含`spring-cloud-sleuth-stream`依赖，它允许您的应用程序成为发送到
    Apache Kafka 或 RabbitMQ 的消息的生产者。
- en: Messaging and integration
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息和集成
- en: I have already mentioned messaging brokers and their usage for communication
    between your application and Zipkin server. Generally, Spring Cloud supports two
    types of communications via synchronous/asynchronous HTTP and with messaging brokers.
    The first project from this area is Spring Cloud Bus. It allows you to send broadcast
    events to applications informing them about state changes such as configuration
    property updates or other management commands. Actually, we might want to use
    starters for AMQP with a RabbitMQ broker or for Apache Kafka. As usual, we only
    need to include `spring-cloud-starter-bus-amqp` or `spring-cloud-starter-bus-kafka`
    to the dependency management and all other necessary operations are performed
    through auto-configuration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了消息代理以及它们用于应用程序和Zipkin服务器之间通信的用法。通常，Spring Cloud支持两种类型的通信，即通过同步/异步HTTP和消息代理。这一领域的第一个项目是Spring
    Cloud Bus。它允许你向应用程序发送广播事件，通知它们关于状态变化的信息，例如配置属性更新或其他管理命令。实际上，我们可能想使用带有RabbitMQ代理或Apache
    Kafka的AMQP启动器。像往常一样，我们只需要将`spring-cloud-starter-bus-amqp`或`spring-cloud-starter-bus-kafka`包含在依赖管理中，其他所有必要操作都通过自动配置完成。
- en: Spring Cloud Bus is a rather small project allowing you to use distributed messaging
    features for common operations such as broadcasting configuration change events.
    The right framework for building a system consisting of message-driven microservices
    is the Spring Cloud Stream. This is a really powerful framework and one of the
    biggest Spring Cloud projects, to which I have dedicated an entire chapter, [Chapter
    11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message Driven Microservices*,
    of the book. The same as for Spring Cloud Bus, there are two binders available,
    first for AMQP with RabbitMQ, and second for Apache Kafka. Spring Cloud Stream
    is based on Spring Integration, which is another large project part of Spring.
    It provides a programming model, supporting most Enterprise Integration Patterns
    such as endpoint, channel, aggregator, or transformer. The applications included
    in the whole microservice system communicate with each other through the Spring
    Cloud Stream input and output channels. The main communication model between them
    is Publish/Subscribe, where messages are broadcast through shared topics. Additionally,
    it is important to support multi instances of every microservice. In most cases,
    a message should be processed only by a single instance, which is not supported
    in a Publish/Subscribe model. That's why Spring Cloud Stream introduces grouping
    mechanisms where only one member of the group receives a message from a destination.
    The same as earlier, these are two starters that can include a project depending
    on the binder type `spring-cloud-starter-stream-kafka` or `spring-cloud-starter-stream-rabbit`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Bus是一个较小的项目，允许你为诸如广播配置变更事件等常见操作使用分布式消息功能。构建由消息驱动的微服务系统所需的正确框架是Spring
    Cloud Stream。这是一个非常强大的框架，也是Spring Cloud项目中最大的一个，我为此专门写了一整章——书籍的第11章，《[消息驱动的微服务](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml)》*Message
    Driven Microservices*。与Spring Cloud Bus相同，这里也有两个绑定器可供选择，第一个是用于RabbitMQ的AMQP，第二个是用于Apache
    Kafka的。Spring Cloud Stream基于Spring Integration，这是Spring的另一个大型项目。它提供了一个编程模型，支持大多数企业集成模式，如端点、通道、聚合器或转换器。整个微服务系统中的应用程序通过Spring
    Cloud Stream的输入和输出通道相互通信。它们之间的主要通信模型是发布/订阅，其中消息通过共享主题进行广播。此外，支持每个微服务的多实例也很重要。在大多数情况下，消息应仅由单个实例处理，而发布/订阅模型不支持这一点。这就是Spring
    Cloud Stream引入分组机制的原因，其中仅组中的一个成员从目的地接收消息。与之前一样，这两个启动器可以根据绑定的类型包括一个项目——`spring-cloud-starter-stream-kafka`或`spring-cloud-starter-stream-rabbit`。
- en: There are two more projects related to Spring Cloud Stream. First, Spring Cloud
    Stream App Starters defines a set of Spring Cloud Stream applications that can
    be run independently or using the second project, Spring Cloud Data Flow. Among
    these applications, we can distinguish connectors, adapters for network protocols,
    and generic protocols. Spring Cloud Data Flow is another extensive and powerful
    Spring Cloud toolkit. It simplifies development and deployment by providing a
    smart solution for building data integration and real-time data processing pipelines.
    The orchestration of microservice-based data pipelines is achieved with simple
    DSL, a drag-and-drop UI dashboard, and REST APIs together.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个与Spring Cloud Stream相关的项目。首先，Spring Cloud Stream App Starters定义了一系列可以独立运行或使用第二个项目Spring
    Cloud Data Flow运行的Spring Cloud Stream应用程序。在这些应用程序中，我们可以区分出连接器、网络协议适配器和通用协议。Spring
    Cloud Data Flow是另一个广泛且强大的Spring Cloud工具集。它通过提供构建数据集成和实时数据处理管道的智能解决方案，简化了开发和部署。使用简单的DSL、拖放式UI仪表板和REST
    API共同实现了基于微服务的数据管道的编排。
- en: Cloud platform support
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云平台支持
- en: 'Pivotal Cloud Foundry is a cloud-native platform for deploying and managing
    modern applications. Pivotal Software, as some of you probably already know, is
    an owner of the Spring framework trademark. The patronage of a large, commercial
    platform is one of the important reasons for Spring''s growing popularity. What
    is obvious is that PCF fully supports both Spring Boot''s executable JAR files,
    and all of Spring Cloud microservices patterns such as Config Server, service
    registry, and circuit breaker. These types of tools can be easily run and configured
    using the marketplace available on the UI dashboard or client command line. Development
    for PCF is even simpler than with standard Spring Cloud application. The only
    thing we have to do is to include the right starters to project dependencies:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Pivotal Cloud Foundry是一个用于部署和管理现代应用程序的云原生平台。Pivotal Software，正如你们中的一些人可能已经知道的那样，是Spring框架商标的拥有者。大型商业平台的支持是Spring日益受欢迎的重要原因之一。显而易见的是，PCF完全支持Spring
    Boot的可执行JAR文件以及所有Spring Cloud微服务模式，如Config Server、服务注册表和断路器。这些类型的工具可以通过UI仪表板或客户端命令行上可用的市场轻松运行和配置。对于PCF的开发甚至比标准的Spring
    Cloud应用程序还要简单。我们唯一要做的就是在项目依赖项中包含正确的启动器：
- en: '`spring-cloud-services-starter-circuit-breaker`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-services-starter-circuit-breaker`'
- en: '`spring-cloud-services-starter-config-client`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-services-starter-config-client`'
- en: '`spring-cloud-services-starter-service-registry`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud-services-starter-service-registry`'
- en: 'It''s difficult to find an opinionated cloud framework that does not have support
    for AWS. The same is true for Spring Cloud. Spring Cloud for Amazon Web Services
    provides integration with the most popular web tools available there. This includes
    modules for communication with **Simple Queueing Service** (**SQS**),  **Simple
    Notification Service** (**SNS**), **ElasticCache**, and **Relational Database
    Service** (**RDS**) that offer engines such as Aurora, MySQL, or Oracle. The remote
    resources can be accessed using their name defined in the CloudFormation stack.
    Everything is opaque in well-known Spring convention and patterns. There are four
    main modules available:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一个没有支持AWS的观点明确的云框架很难。对于Spring Cloud来说也是如此。Spring Cloud for Amazon Web Services提供了与那里最流行的网络工具的集成。这包括与**简单队列服务**（**SQS**）、**简单通知服务**（**SNS**）、**ElasticCache**和**关系数据库服务**（**RDS**）通信的模块，后者提供如Aurora、MySQL或Oracle等引擎。可以使用在CloudFormation堆栈中定义的名称访问远程资源。一切都是按照众所周知的Spring约定和模式进行操作的。有四个主要模块可供使用：
- en: '**Spring Cloud AWS Core**: Included using the `spring-cloud-starter-aws` starter,
    provides core components enabling direct access to the EC2 instance'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud AWS Core**：通过使用`spring-cloud-starter-aws`启动器包含，提供核心组件，实现对EC2实例的直接访问'
- en: '**Spring Cloud AWS Context**: Delivers access to the Simple Storage Service,
    Simple E-mail Service, and caching service'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud AWS Context**：提供对简单存储服务、简单电子邮件服务和缓存服务的访问'
- en: '**Spring Cloud AWS JDBC**: Included using starter `spring-cloud-starter-aws-jdbc` starter, provides data
    source lookup and configuration, which can be used with any data access technology
    supported by Spring'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud AWS JDBC**：通过使用启动器`spring-cloud-starter-aws-jdbc`，提供数据源查找和配置，可以与Spring支持的任何数据访问技术一起使用'
- en: '**Spring Cloud AWS Messaging**: Included using `starter spring-cloud-starter-aws-messaging`
    starter, allows an application to send and receive messages with SQS (point-to-point)
    or SNS (Publish/Subscribe)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Cloud AWS 消息**：包含使用`starter spring-cloud-starter-aws-messaging`启动器，允许应用程序使用SQS（点对点）或SNS（发布/订阅）发送和接收消息。'
- en: There is another project that is worth mentioning although it is still at an
    early stage of development. That is Spring Cloud Function, which offers support
    for serverless architecture. Serverless is also known as **FaaS** (**Function-as-a-Service**),
    where a developer creates only very small modules that are deployed on containers fully
    managed by a third-party provider. Actually, Spring Cloud Functions implemented
    adapters for AWS Lambda and Apache OpenWhisk, the most popular FaaS providers.
    I will be following the development of this project designed for supporting a
    serverless approach.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个值得提及的项目，尽管它仍然处于开发的早期阶段。那是Spring Cloud Function，它提供了无服务器架构的支持。无服务器也被称为**FaaS**（**Function-as-a-Service**），在其中开发者只创建非常小的模块，这些模块完全由第三方提供商托管在容器上。实际上，Spring
    Cloud Functions为最流行的FaaS提供商AWS Lambda和Apache OpenWhisk实现了适配器。我将关注这个旨在支持无服务器方法的项目的开发。
- en: In this section, we should not forget about the Spring Cloud Connectors project, formerly
    known as **Spring Cloud**. It provides an abstraction for JVM-based applications
    deployed on a cloud platform. Actually, it has support for Heroku and Cloud Foundry,
    where our application could connect SMTP, RabbitMQ, Redis, or one of the available
    relational databases using one of the Spring Cloud Heroku Connectors and Spring
    Cloud Foundry Connector modules.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们不应该忘记Spring Cloud Connectors项目，原名**Spring Cloud**。它为部署在云平台上的JVM基础应用程序提供了抽象。实际上，它支持Heroku和Cloud
    Foundry，我们的应用程序可以使用Spring Cloud Heroku Connectors和Spring Cloud Foundry Connector模块连接SMTP、RabbitMQ、Redis或可用的关系型数据库。
- en: Other useful libraries
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有用的库
- en: There are some important aspects surrounding microservices architecture, which
    can't be considered its core features, but are also very important. The first
    of them is security.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构周围有一些重要的方面，这些不能算作其核心特性，但也非常重要。其中第一个是安全性。
- en: Security
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: The big part of standard implementation for securing APIs with mechanisms such
    as OAuth2, JWT, or basic authentication is available in Spring Security and Spring
    Web projects. Spring Cloud Security uses those libraries to allow us to easily
    create systems that implement common patterns such as single sign-on and token
    relay. To enable security management for our application we should include the `spring-cloud-starter-security`
    starter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 标准实现用于保护API的绝大多数机制，如OAuth2、JWT或基本认证，都可在Spring Security和Spring Web项目中找到。Spring
    Cloud Security使用这些库，使我们能够轻松创建实现常见模式的系统，如单点登录和令牌传递。为了为我们的应用程序启用安全管理，我们应该包含`spring-cloud-starter-security`启动器。
- en: Automated testing
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: 'The next important area in microservices development is automated testing.
    For microservices architecture, contact tests are growing in importance. Martin
    Fowler gave the following definition:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务开发中的下一个重要领域是自动化测试。对于微服务架构，接触测试变得越来越重要。马丁·福勒给出了以下定义：
- en: '"An integration contract test is a test at the boundary of an external service
    verifying that it meets the contract expected by a consuming service."'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: “集成合同测试是在外部服务边界上进行的测试，验证它满足消费服务期望的合同。”
- en: Spring Cloud has a very interesting implementation for that approach to unit
    testing, Spring Cloud Contract. It uses WireMock for traffic recording and Maven
    plugin for generating stubs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud针对这种单元测试方法有一个非常有趣的实现，即Spring Cloud Contract。它使用WireMock进行流量记录和Maven插件生成存根。
- en: It is also possible that you get the opportunity to use Spring Cloud Task. It
    helps a developer to create short lived microservices using Spring Cloud, and
    run them locally or in the cloud environment. To enable it in the project we should
    include the `spring-cloud-starter-task` starter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可能有机会使用Spring Cloud Task。它帮助开发者使用Spring Cloud创建短暂存在的微服务，并本地运行或在云环境中运行。为了在项目中启用它，我们应该包含`spring-cloud-starter-task`启动器。
- en: Cluster features
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群特性
- en: Finally, the last project, Spring Cloud Cluster. It provides a solution for
    the leadership election and common stateful patterns with an abstraction and implementation
    for Zookeeper, Redis, Hazelcast, and Consul.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个项目，Spring Cloud Cluster。它提供了一个解决方案，用于领导选举和常见有状态模式，以及Zookeeper、Redis、Hazelcast和Consul的抽象和实现。
- en: Projects overview
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概览
- en: 'As you can see, Spring Cloud contains many subprojects providing integration
    with lots of different tools and solutions. I think it is easy to lose track,
    especially if you are using Spring Cloud for the first time. In accordance with
    the principle that one diagram might express things better than a thousand words,
    I''m presenting the most important projects divided into categories as shown in
    the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Spring Cloud包含许多子项目，提供与许多不同工具和解决方案的集成。我认为如果你是第一次使用Spring Cloud，很容易迷失方向。根据一图千言的原则，我呈现了最重要的项目，按类别划分，如下面的图表所示：
- en: '![](img/b90c6536-0be0-4d4c-89ea-0aabea5a5eec.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b90c6536-0be0-4d4c-89ea-0aabea5a5eec.png)'
- en: Release trains
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布列车
- en: 'As we can see in the preceding diagram, there are many projects inside Spring
    Cloud and there are many relationships between them. By definition, these are
    all independent projects with different release cascades and version numbers.
    In a situation like this, dependency management in our application might be problematic
    and that will require knowledge about relationships between versions of all projects.
    To help make it easier, Spring Cloud introduced the starter mechanism, which we
    have already discussed, and release trains. The release trains are identified
    by names, not versions, to avoid confusion with the subprojects. What is interesting
    is that they are named after London tube stations and they are alphabetically
    ordered. The first release was Angel,  the second was Brixton, and so on. The
    whole mechanism of dependency management is based on **BOM** (**bill of materials**),
    which is a standard Maven concept for managing artifacts versioned independently.
    Here''s an actual table with Spring Cloud project versions assigned to release
    trains. Names with the suffix M[*X*], where [*X*] is the version number, means
    **milestone**, SR[*X*] means **service release**, which refers to changes that
    fix critical bugs. As you can see in the following table, Spring Cloud Stream
    has it own release trains, which groups its subprojects using the same rules as
    Spring Cloud project:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前的图表所示，Spring Cloud内部有许多项目，它们之间存在许多关系。定义上，这些都是具有不同发布级联和版本号的独立项目。在这种情况下，我们应用中的依赖管理可能会出现问题，这需要了解所有项目版本之间的关系。为了使事情变得容易，Spring
    Cloud引入了启动机制，我们已经在前面讨论过，还有发布列车。发布列车通过名称而不是版本来标识，以避免与子项目混淆。有趣的是，它们以伦敦地铁站的名称命名，并且按字母顺序排列。第一个发布版是Angel，第二个是Brixton，依此类推。整个依赖管理机制基于**BOM**（**物料清单**），这是一个用于独立版本管理工件的标准Maven概念。下面是一个实际的表格，其中分配了Spring
    Cloud项目版本到发布列车。带有后缀M[*X*]的名称，其中[*X*]是版本号，意味着**里程碑**，SR[*X*]意味着**服务发布**，指的是修复关键bug的变化。正如您在下面的表格中看到的，Spring
    Cloud Stream有自己的发布列车，它使用与Spring Cloud项目相同的规则来分组其子项目：
- en: '| **Component** | **Camden.SR7** | **Dalston.SR4** | **Edgware.M1** | **Finchley.M2**
    | **Finchley.BUILD-SNAPSHOT** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **组件** | **Camden.SR7** | **Dalston.SR4** | **Edgware.M1** | **Finchley.M2**
    | **Finchley.BUILD-SNAPSHOT** |'
- en: '| `spring-cloud-aws` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `spring-cloud-aws` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SN'
- en: '| `spring-cloud-bus` | 1.2.2.RELEASE | 1.3.1.RELEASE | 1.3.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `spring-cloud-bus` | 1.2.2.RELEASE | 1.3.1.RELEASE | 1.3.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-cli` | 1.2.4.RELEASE | 1.3.4.RELEASE | 1.4.0.M1 | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `spring-cloud-cli` | 1.2.4.RELEASE | 1.3.4.RELEASE | 1.4.0.M1 | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-commons` | 1.1.9.RELEASE | 1.2.4.RELEASE | 1.3.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `spring-cloud-commons` | 1.1.9.RELEASE | 1.2.4.RELEASE | 1.3.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-contract` | 1.0.5.RELEASE | 1.1.4.RELEASE | 1.2.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `spring-cloud-contract` | 1.0.5.RELEASE | 1.1.4.RELEASE | 1.2.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-config` | 1.2.3.RELEASE | 1.3.3.RELEASE | 1.4.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `spring-cloud-config` | 1.2.3.RELEASE | 1.3.3.RELEASE | 1.4.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-netflix` | 1.2.7.RELEASE | 1.3.5.RELEASE | 1.4.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `spring-cloud-netflix` | 1.2.7.RELEASE | 1.3.5.RELEASE | 1.4.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-security` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE |
    2.0.0.M1 | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `spring-cloud-security` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE |
    2.0.0.M1 | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-cloudfoundry` | 1.0.1.RELEASE | 1.1.0.RELEASE | 1.1.0.RELEASE
    | 2.0.0.M1 | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `spring-cloud-cloudfoundry` | 1.0.1.RELEASE | 1.1.0.RELEASE | 1.1.0.RELEASE
    | 2.0.0.M1 | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-consul` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '```spring-cloud-consul``` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE |
    2.0.0.M1 | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-sleuth` | 1.1.3.RELEASE | 1.2.5.RELEASE | 1.3.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '```spring-cloud-sleuth``` | 1.1.3.RELEASE | 1.2.5.RELEASE | 1.3.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-stream` | Brooklyn.SR3 | Chelsea.SR2 | Ditmars.M2 | Elmhurst.M1
    | Elmhurst.BUILD-SNAPSHOT |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '```spring-cloud-stream``` | Brooklyn.SR3 | Chelsea.SR2 | Ditmars.M2 | Elmhurst.M1
    | Elmhurst.BUILD-SNAPSHOT |'
- en: '| `spring-cloud-zookeeper` | 1.0.4.RELEASE | 1.1.2.RELEASE | 1.2.0.M1 | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '```spring-cloud-zookeeper``` | 1.0.4.RELEASE | 1.1.2.RELEASE | 1.2.0.M1 | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
- en: '| `spring-boot` | 1.4.5.RELEASE | 1.5.4.RELEASE | 1.5.6.RELEASE | 2.0.0.M3
    | 2.0.0.M3 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '```spring-boot``` | 1.4.5.RELEASE | 1.5.4.RELEASE | 1.5.6.RELEASE | 2.0.0.M3
    | 2.0.0.M3 |'
- en: '| `spring-cloud-task` | 1.0.3.RELEASE | 1.1.2.RELEASE | 1.2.0.RELEASE | 2.0.0.M1
    | 2.0.0.RELEASE |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '```spring-cloud-task``` | 1.0.3.RELEASE | 1.1.2.RELEASE | 1.2.0.RELEASE | 2.0.0.M1
    | 2.0.0.RELEASE |'
- en: 'Now, all we need to do is provide the right release train name in the dependency
    management section in the Maven `pom.xml` and then include projects using starters:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在Maven `pom.xml`的依赖管理部分提供正确的发行版名称，然后使用启动器包含项目：
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s the same sample for Gradle:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Gradle的相同示例：
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I have introduced the most important projects that are part
    of Spring Cloud. I have pointed out several areas to which I assigned each of
    those projects. After reading this chapter, you should be able to recognize which
    library has to be included in your application to able to implement patterns such
    as service discovery, distributed configuration, circuit breaker, or load balancer.
    You should also recognize the differences between application context, and bootstrap
    context and understand how to include dependencies in the project using dependency
    management based on the release trains concept. The last thing I wanted to draw
    your attention to in this chapter were some tools integrated with Spring Cloud
    such as Consul, Zookeeper, RabbitMQ, or Zipkin. I described all of them in some
    details. I also pointed out the projects responsible for interaction with those
    tools.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了属于Spring Cloud的最重要的项目。我指出了几个区域，并为每个项目分配了这些区域。阅读完本章后，你应该能够识别出在你的应用程序中需要包含哪个库，以实现在服务发现、分布式配置、断路器或负载均衡器等模式。你也应该能够识别出应用上下文和引导上下文之间的差异，并理解如何使用基于发行版概念的依赖管理来在项目中包含依赖项。在本章的最后，我想引起你们注意的一些与Spring
    Cloud集成的工具，例如Consul、Zookeeper、RabbitMQ或Zipkin。我详细描述了它们的所有内容。我还指出了与这些工具交互的项目。
- en: This chapter completes the first part of the book. In this part, the main goal
    was to get you into the basics related to Spring Cloud project. After reading
    it you should be able to recognize the most important elements of microservices-based
    architecture, effectively use Spring Boot to create simple and more advanced microservices,
    and finally, you should also be able to list all of the most popular subprojects
    being that are a part of Spring Cloud. Now, we may proceed to the next part of
    the book and discuss in detail those subprojects, which are responsible for implementing
    common patterns of distributed systems in Spring Cloud. Most of them are based
    on Netflix OSS libraries. We will begin with the solution providing service registry,
    Eureka discovery server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成了本书的第一部分。在这一部分中，主要目标是让你了解Spring Cloud项目的基本知识。阅读完它后，你应该能够识别出基于微服务架构的最重要元素，有效地使用Spring
    Boot创建简单和更高级的微服务，最后，你也应该能够列出所有最流行的子项目，这些子项目是Spring Cloud的一部分。现在，我们可以继续下一部分的书，并详细讨论那些负责在Spring
    Cloud中实现分布式系统常见模式的子项目。其中大多数是基于Netflix OSS库的。我们将从提供服务注册、Eureka发现服务器的解决方案开始。
