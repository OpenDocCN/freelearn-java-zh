- en: Chapter 9. Polyglot Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：多语言项目
- en: We are living in an era where one language is not enough. Developers are expected
    to be polyglot programmers and choose the right tool for a job. While it is always
    a subjective decision, we try to select languages and ecosystems based on various
    parameters such as execution speed, developer productivity, available libraries
    and resources, a team's comfort level with the language, and many more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个一个语言不足以应对的时代。开发者们被期望成为多语言程序员，并为工作选择合适的工具。虽然这始终是一个主观的决定，但我们尝试根据各种参数来选择语言和生态系统，例如执行速度、开发者生产力、可用的库和资源、团队对语言的舒适度等等。
- en: When we are already carrying the cognitive load of working with different languages,
    Gradle turns out to be our good friend, as we don't have to change our build tool
    even if we are building projects in other languages. We can even use multiple
    languages in the same project and Gradle orchestrating the build for the entire
    project. Apart from the array of JVM-based languages, Gradle also supports C,
    C++, Objective C and others to produce native applications as well. Gradle is
    also an official build tool for the Android platform. The list of supported languages
    is on the rise. Apart from official plugins, there are many community-supported
    language plugins.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们已经在处理不同语言时承受着认知负荷，Gradle 便成了我们的好朋友，因为我们不需要改变我们的构建工具，即使我们在用其他语言构建项目。我们甚至可以在同一个项目中使用多种语言，由
    Gradle 来协调整个项目的构建。除了 JVM 基础语言之外，Gradle 还支持 C、C++、Objective C 等其他语言，以生成原生应用程序。Gradle
    也是 Android 平台的官方构建工具。支持的语言列表正在不断增加。除了官方插件之外，还有许多社区支持的编程语言插件。
- en: Although throughout the book we have focused primarily on Java as the language,
    we could have very well used Groovy or Scala to write the examples. The `java`
    plugin (along with the `java-base` plugin, which is applied by the `java` plugin
    to the project) provides the basic functionality for the JVM-based projects. Language
    specific plugins such as `scala` and `groovy` extend the `java` plugin to support
    common idioms in a consistent manner. So, once we have used the `java` plugin,
    we are already familiar with what `sourceSet` is, how `configuration` works, how
    to add library dependencies, and so on, and this knowledge is readily useful when
    we use these language plugins. In this chapter, we will see how we can easily
    add more spice to Java projects by adding Groovy or Scala to the mix.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在整个书中我们主要关注 Java 语言，但我们完全可以使用 Groovy 或 Scala 来编写示例。`java` 插件（以及由 `java` 插件应用于项目的
    `java-base` 插件）为 JVM 基础项目提供了基本功能。特定语言的插件，如 `scala` 和 `groovy`，以一致的方式扩展了 `java`
    插件以支持常见的编程习惯。因此，一旦我们使用了 `java` 插件，我们就已经熟悉了 `sourceSet` 是什么，`configuration` 如何工作，如何添加库依赖等等，这些知识在我们使用这些语言插件时非常有用。在本章中，我们将看到如何通过添加
    Groovy 或 Scala 来轻松地为 Java 项目增添更多色彩。
- en: The polyglot application
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多语言应用程序
- en: For the code example, in this chapter, let's build a simple **Quote of the Day**
    service that returns a quote based on the day of the year. Since we might have
    fewer quotes in our store, the service should repeat the quotes in a cyclic fashion.
    Again, as usual, we will try to keep it as simple as possible to focus more on
    build aspects rather than the application logic. We will create two separate Gradle
    projects to implement the exact same functionality, once in Groovy then in Scala.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码示例，在本章中，让我们构建一个简单的“每日名言”服务，该服务根据年份的某一天返回一个名言。由于我们存储的名言可能较少，该服务应以循环方式重复名言。再次强调，我们将尽量保持简单，以便更多地关注构建方面而不是应用逻辑。我们将创建两个独立的
    Gradle 项目来实现完全相同的功能，一次使用 Groovy，然后使用 Scala。
- en: 'Before going into language-specific details, let''s start with defining the
    `QotdService` interface, which just declares only one method, `getQuote`. The
    contract is, as long as we pass the same date, we should get the same quote back:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨特定语言细节之前，让我们先定义 `QotdService` 接口，它仅声明了一个方法，即 `getQuote`。合同规定，只要我们传递相同的日期，就应该返回相同的名言：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The logic to implement `getQuote` can use the `Date` object in any manner, such
    as using the entire date including the time for determining the quote. However,
    for the sake of simplicity, we will use only the day component of the `Date` object
    in our implementations. Also, because we want our interface to be open for future
    implementations, we let `getQuote` take a `Date` object as the parameter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`getQuote`的逻辑可以使用`Date`对象以任何方式，例如使用包括时间在内的整个日期来确定引语。然而，为了简单起见，我们将在我们的实现中仅使用`Date`对象的日期部分。此外，因为我们想让我们的接口对未来的实现开放，所以我们让`getQuote`接受一个`Date`对象作为参数。
- en: This interface is a Java file that we will have in both projects. This is just
    to demonstrate the integration of Java and Groovy/Scala sources in one project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口是一个Java文件，我们将在两个项目中都有。这只是为了演示在一个项目中集成Java和Groovy/Scala源。
- en: Building Groovy projects
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Groovy项目
- en: 'Let''s first implement the `QotdService` interface in Groovy. Also, we will
    write some unit tests to make sure that the functionality works as expected. To
    start the project, let''s create the directory structure as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在Groovy中实现`QotdService`接口。此外，我们还将编写一些单元测试以确保功能按预期工作。为了启动项目，让我们创建以下目录结构：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `src/main/java` directory is the default directory for Java sources. Similarly,
    `src/main/groovy` is used by default to compile Groovy source files. Again, it
    is just a convention, and the source directories' path and name can be easily
    configured via `sourceSets`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/main/java`目录是Java源文件的默认目录。同样，`src/main/groovy`默认用于编译Groovy源文件。再次强调，这只是一种约定，源目录的路径和名称可以通过`sourceSets`轻松配置。'
- en: 'Let''s first write the build script for our Groovy project. Create a `build.gradle`
    file in the project root with the following content:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的Groovy项目编写构建脚本。在项目根目录中创建一个`build.gradle`文件，内容如下：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Building Groovy project is as simple as building a Java project. Instead of
    applying the `java` plugin, we apply the `groovy` plugin, which automatically
    applies the `java` plugin for us. Apart from applying the plugin, we also need
    to add Groovy as a library dependency so that it is available for compilation
    and is also available at runtime. We also add `junit` in the `testCompile` configuration
    so it is available for unit tests. We declare Maven central as the repository
    to be used, but this can be changed to any valid repository configuration that
    can serve our project's dependencies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Groovy项目就像构建Java项目一样简单。我们不是应用`java`插件，而是应用`groovy`插件，它会自动为我们应用`java`插件。除了应用插件之外，我们还需要将Groovy添加为库依赖项，以便它在编译时可用，并在运行时也可用。我们还在`testCompile`配置中添加了`junit`，以便它可用于单元测试。我们声明Maven
    central作为要使用的仓库，但这也可能被更改为任何可以为我们项目依赖项服务的有效仓库配置。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Gradle build script is a Groovy DSL, and parts of Gradle are written in Groovy.
    However, like any other library that Gradle itself depends on at runtime, Groovy
    is not implicitly available to the project that we are building. Hence, we must
    explicitly declare Groovy as a project dependency, depending on whether we are
    using Groovy in production or test sources.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle构建脚本是一个Groovy DSL，Gradle的部分是用Groovy编写的。然而，就像Gradle在运行时依赖的任何其他库一样，Groovy并不是隐式地对我们正在构建的项目可用。因此，我们必须显式地将Groovy声明为项目依赖项，具体取决于我们是否在生产或测试源中使用Groovy。
- en: 'Groovy plugin takes care of compiling Java source files in the project as well.
    Let''s implement the `QotdService` interface in Groovy:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy插件负责编译项目中的Java源文件。让我们用Groovy实现`QotdService`接口：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The implementation of service accepts a list of quotes in a constructor. The
    `getQuote` method gets quote by the index in the list. To ensure that the computed
    index always stays within the range of the quote's size, we get the modulus of
    the day of the year and the list's size.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的实现接受一个包含引语的构造函数中的列表。`getQuote`方法通过列表中的索引获取引语。为了确保计算出的索引始终保持在引语大小的范围内，我们获取了年份和列表大小的余数。
- en: 'To test the service, let''s write very basic JUnit test cases in Groovy:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试服务，让我们用Groovy编写非常基本的JUnit测试用例：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We prepare the test data in setup, and each test case makes sure the contract
    of the quote service is maintained. As the quote's list contains only two quotes,
    they should repeat every alternate day.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设置中准备测试数据，每个测试用例都确保引语服务的契约得到维护。由于引语列表中只有两个引语，它们应该每隔一天重复一次。
- en: 'We can run the tests from the command line using the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码从命令行运行测试：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building Scala projects
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Scala项目
- en: 'Following the last section, most of this section would be very predictable
    from the application build''s standpoint. So let''s quickly go through the gist
    of it. The directory structure is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节之后，本节的大部分内容从应用程序构建的角度来看应该是可预测的。所以让我们快速浏览一下要点。目录结构如下：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'All Scala source files are read from `src/main/scala` `and src/test/scala`,
    unless configured using `sourceSets`. This time, the only plugin that we need
    to apply is the `scala` plugin, which just like the `groovy` plugin, implicitly
    applies the `java` plugin to our project. Let''s write the `build.gradle` file
    for this project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Scala 源文件都从 `src/main/scala` 和 `src/test/scala` 读取，除非使用 `sourceSets` 进行配置。这次，我们只需要应用
    `scala` 插件，就像 `groovy` 插件一样，它隐式地将 `java` 插件应用到我们的项目中。让我们为这个项目编写 `build.gradle`
    文件：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have to provide `scala-library` as a dependency. We also added `specs2`
    as a dependency for the test configuration. We are using JUnit runner for the
    tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们必须提供 `scala-library` 作为依赖项。我们还为测试配置添加了 `specs2` 作为依赖项。我们正在使用 JUnit 运行器进行测试。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `specs2` is a popular Scala testing library, which supports both unit and
    acceptance testing and the BDD/TDD style of writing tests. More information is
    available at [http://etorreborre.github.io/specs2/](http://etorreborre.github.io/specs2/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`specs2` 是一个流行的 Scala 测试库，它支持单元测试和验收测试，以及 BDD/TDD 风格的测试编写。更多信息可以在 [http://etorreborre.github.io/specs2/](http://etorreborre.github.io/specs2/)
    找到。'
- en: 'Moving on to the service''s Scala implementation, we can implement it as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现服务的 Scala 版本，可以按照以下方式实现：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The implementation is not very idiomatic Scala, but that's out of scope of this
    book. The class takes the quotes `Seq` in the constructor and implements the `getQuote`
    method in a similar fashion to the Groovy counterpart.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并不是非常符合 Scala 的习惯用法，但这本书的范围之外。该类在构造函数中接受 `Seq` 引用，并以类似 Groovy 对应方式实现 `getQuote`
    方法。
- en: 'Now that the service is implemented, let''s verify that it honors the semantics
    of `QotdService` by writing unit tests. For brevity, we will cover only the important
    test cases:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务已经实现，让我们通过编写单元测试来验证它是否遵循 `QotdService` 的语义。为了简洁，我们将只涵盖重要的测试用例：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The task to run test cases is just the same as the Groovy counterpart. We can
    run tests using the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试用例的任务与 Groovy 对应的任务相同。我们可以使用以下代码来运行测试：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Joint compilation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合编译
- en: In the preceding examples in this chapter, we declared an interface in Java
    and implemented it in Groovy and Scala respectively. It was possible because the
    classes compiled by the `java` plugin are available to Groovy and Scala classes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的示例中，我们分别在 Java 中声明了一个接口，并在 Groovy 和 Scala 中分别实现了它。这是可能的，因为由 `java` 插件编译的类对
    Groovy 和 Scala 类是可用的。
- en: If we want a Java class to have access to Groovy or Scala classes for its compilation,
    then we must compile the Java source file using the **joint compilation** supported
    by the respective plugin. Both the `groovy` and `scala` plugins support joint
    compilation and can compile Java sources.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让 Java 类在编译时能够访问 Groovy 或 Scala 类，那么我们必须使用相应插件支持的 **联合编译** 来编译 Java 源文件。`groovy`
    和 `scala` 插件都支持联合编译，并且可以编译 Java 源代码。
- en: For referencing Groovy classes in a Java class, the easiest way is to move the
    corresponding Java source file into `src/main/groovy` (or in any of the Groovy
    `srcDirs` configured for `sourceSets`), and the Groovy compiler makes Groovy classes
    available to the Java class while compilation. The same goes for Scala joint compilation.
    We can put the Java files, which need Scala classes for their compilation, in
    any of the Scala `srcDirs` (`src/main/scala` by default).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 类中引用 Groovy 类的最简单方法是，将相应的 Java 源文件移动到 `src/main/groovy`（或为 `sourceSets`
    配置的任何 Groovy `srcDirs`），Groovy 编译器在编译时使 Groovy 类对 Java 类可用。Scala 联合编译也是如此。我们可以将需要
    Scala 类进行编译的 Java 文件放在 Scala 的任何 `srcDirs` 中（默认为 `src/main/scala`）。
- en: References
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考
- en: 'The detailed official documentation for language plugins, discussed in this
    chapter, can be found at the following URLs:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的语言插件的详细官方文档可以在以下 URL 中找到：
- en: '**Java plugin**: [https://docs.gradle.org/current/userguide/java_plugin.html](https://docs.gradle.org/current/userguide/java_plugin.html)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 插件**：[https://docs.gradle.org/current/userguide/java_plugin.html](https://docs.gradle.org/current/userguide/java_plugin.html)'
- en: '**Groovy plugin**: [https://docs.gradle.org/current/userguide/groovy_plugin.html](https://docs.gradle.org/current/userguide/groovy_plugin.html)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Groovy 插件**：[https://docs.gradle.org/current/userguide/groovy_plugin.html](https://docs.gradle.org/current/userguide/groovy_plugin.html)'
- en: '**Scala plugin**: [https://docs.gradle.org/current/userguide/scala_plugin.html](https://docs.gradle.org/current/userguide/scala_plugin.html)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scala 插件**: [https://docs.gradle.org/current/userguide/scala_plugin.html](https://docs.gradle.org/current/userguide/scala_plugin.html)'
- en: 'The links to the official documentation for various languages and other plugins
    shipped with Gradle can be found at the following URL:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下网址找到各种语言和 Gradle 一起提供的其他插件的官方文档链接：
- en: '[https://docs.gradle.org/current/userguide/standard_plugins.html](https://docs.gradle.org/current/userguide/standard_plugins.html)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.gradle.org/current/userguide/standard_plugins.html](https://docs.gradle.org/current/userguide/standard_plugins.html)'
- en: Summary
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We took a simple example problem and implemented a solution in Groovy and Scala
    to demonstrate how Gradle makes polyglot project development easy. Instead of
    going into language and plugin-specific details and differences, we tried to focus
    on the commonality and consistency that Gradle brings to the table.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选取了一个简单的示例问题，并在 Groovy 和 Scala 中实现了解决方案，以展示 Gradle 如何使多语言项目开发变得简单。我们试图专注于
    Gradle 带来的共性和一致性，而不是深入到语言和插件特定的细节和差异。
