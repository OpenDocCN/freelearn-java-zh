- en: Chapter 4. Creating and Using Web APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章. 创建和使用 Web API
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a `POST` API endpoint
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `POST` API 端点
- en: Creating a `GET` API endpoint
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `GET` API 端点
- en: Creating a `PUT` API endpoint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `PUT` API 端点
- en: Creating a `DELETE` API endpoint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `DELETE` API 端点
- en: Securing API endpoints with HTTP basic authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 基本身份验证保护 API 端点
- en: Consuming external web APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费外部 Web API
- en: Using the Twitter API with OAuth
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OAuth 通过 Twitter API
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will look into creating REST APIs and interfacing with other
    external web-based APIs, in our case, the Twitter API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用 Play 2.0 创建 REST API 并与其他外部基于 Web 的 API 进行交互，在我们的例子中，是 Twitter
    API。
- en: With the increasing popularity of data exchanges between independent web services,
    REST APIs have become a popular approach not only to consume external data, but
    also to receive incoming data for further processing and persistence as well as
    exposing data to authorized clients. Based on the RESTful API spec, the HTTP method
    `POST` is used to insert new records and the HTTP method `GET` is used to retrieve
    data. The HTTP method `PUT` is used to update existing records and lastly, the
    HTTP method `DELETE` is used to remove records.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着独立 Web 服务之间数据交换的日益流行，REST API 已经成为了一种流行的方法，不仅用于消费外部数据，还用于接收传入数据以进行进一步处理和持久化，以及向授权客户端公开数据。基于
    RESTful API 规范，HTTP 方法 `POST` 用于插入新记录，HTTP 方法 `GET` 用于检索数据。HTTP 方法 `PUT` 用于更新现有记录，最后，HTTP
    方法 `DELETE` 用于删除记录。
- en: We will see how we can utilize different Play 2.0 libraries to build our own
    REST API endpoints and access other web-based APIs using the new Play WS library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何利用不同的 Play 2.0 库来构建我们自己的 REST API 端点，并使用新的 Play WS 库访问其他基于 Web 的 API。
- en: Creating a POST API endpoint
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 `POST` API 端点
- en: In this recipe, we will explore how to use Play 2.0 to create a RESTful `POST`
    endpoint to add new records to our API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探索如何使用 Play 2.0 创建一个 RESTful `POST` 端点来向我们的 API 添加新记录。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For Java, we need to perform the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java，我们需要执行以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载功能运行`foo_java`应用程序：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new products controller in `foo_java/app/controllers/Products.java`
    with the following content:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/controllers/Products.java`中创建一个新的产品控制器，内容如下：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a product model class in `foo_java/app/models/Product.java`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/models/Product.java`中创建一个产品模型类：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a new route entry for the newly added action in `foo_java/conf/routes`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Request the new route and examine the response body to confirm:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求新的路由并检查响应体以确认：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For Scala, we need to perform the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Scala，我们需要执行以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载功能运行`foo_scala`应用程序：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a new products controller in `foo_scala/app/controllers/Products.scala`
    with the following content:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/controllers/Products.scala`中创建一个新的产品控制器，内容如下：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a product model class in `foo_scala/app/models/Product.scala`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/models/Product.scala`中创建一个产品模型类：
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a new route entry for the newly added action in `foo_scala/conf/routes`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Request the new route and examine the response body to confirm:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求新的路由并检查响应体以确认：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we implemented a RESTful `POST` request using Play 2.0\. The
    first step was to create our controller and model classes. For the model class,
    we declared two basic fields for a product. We annotated them as required fields.
    This allows Play to validate these two fields when a product is bound to a request
    body.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们使用 Play 2.0 实现了一个 RESTful `POST` 请求。第一步是创建我们的控制器和模型类。对于模型类，我们声明了两个基本的产品字段。我们将它们标注为必填字段。这允许
    Play 在产品绑定到请求体时验证这两个字段。
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As for a Scala equivalent of enforcing required request parameters, we declare
    optional parameters using the `scala.Option` class. In this recipe though, to
    keep the Java and Scala recipes consistent, it will be unnecessary to use `scala.Option`
    and we will enforce required fields in our case class like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于强制执行必需请求参数的 Scala 等价物，我们使用 `scala.Option` 类声明可选参数。然而，在本食谱中，为了保持 Java 和 Scala
    食谱的一致性，将不需要使用 `scala.Option`，我们将在我们的案例类中强制执行必需字段，如下所示：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then created an action method that will handle the product `POST` request
    in the controller class. We ensure that there aren''t any validation errors encountered
    by the `play.data.Form` object during data binding; however, if it does encounter
    an issue, it will return an HTTP Status 400 wrapped by the `badRequest()` helper:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制器类中创建了一个动作方法，该方法将处理产品的`POST`请求。我们确保在数据绑定过程中`play.data.Form`对象没有遇到任何验证错误；然而，如果遇到问题，它将通过`badRequest()`辅助函数返回HTTP状态码400：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If no errors are encountered, we proceed to persisting our new product and
    returning an HTTP Status 201 wrapped by the `created()` helper:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有遇到错误，我们继续持久化我们的新产品并返回由`created()`辅助函数包装的HTTP状态码201：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then declared our new `POST` route in the `conf/routes` file. Finally, we
    used the command-line tool, `curl`, to simulate the HTTP `POST` request to test
    our route. To verify that our endpoint does execute the `POST` form field validations,
    omit the title parameter from the previous `curl` command and you will see the
    appropriate error message:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在`conf/routes`文件中声明了我们的新`POST`路由。最后，我们使用命令行工具`curl`模拟HTTP `POST`请求来测试我们的路由。要验证我们的端点是否执行了`POST`表单字段的验证，请从之前的`curl`命令中省略标题参数，您将看到适当的错误消息：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating a GET API endpoint
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个GET API端点
- en: For this recipe, we will create the RESTful `GET` endpoint, which will return
    a collection of JSON objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将创建一个RESTful的`GET`端点，它将返回一个JSON对象的集合。
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'For Java, we need to perform the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要执行以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_java`应用程序：
- en: '[PRE15]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Modify the products controller in `foo_java/app/controllers/Products.java`
    by adding the following action method:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下动作方法来修改`foo_java/app/controllers/Products.java`中的产品控制器：
- en: '[PRE16]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a new route entry for the newly added action in `foo_java/conf/routes`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE17]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Request the new route and examine the response headers to confirm our modifications
    to the HTTP response header:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求新路由并检查响应头以确认我们对HTTP响应头的修改：
- en: '[PRE18]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For Scala, we need to perform the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要执行以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_scala`应用程序：
- en: '[PRE19]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Modify the product controller in `foo_scala/app/controllers/Products.scala`
    by adding the following action method:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`foo_scala/app/controllers/Products.scala`中添加以下动作方法来修改产品控制器：
- en: '[PRE20]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a new route entry for the newly added action in `foo_scala/conf/routes`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE21]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Request our new route and examine the response headers to confirm our modifications
    to the HTTP response header:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求我们的新路由并检查响应头以确认我们对HTTP响应头的修改：
- en: '[PRE22]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'In this recipe, we implemented an API endpoint that returns a listing of product
    records. We were able to implement this by declaring a new action method that
    retrieves records from our data store, converts objects to JSON, and returns a
    JSON collection:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们实现了一个返回产品记录列表的API端点。我们通过声明一个新的动作方法来实现这一点，该方法从我们的数据存储中检索记录，将对象转换为JSON，并返回一个JSON集合：
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We then declared a new route entry for the `GET` endpoint and used `curl` to
    verify the endpoints' functionality.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`GET`端点声明了一个新的路由条目，并使用`curl`验证端点的功能。
- en: 'The endpoint will return an empty JSON array in the case of an empty data store:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据存储为空，端点将返回一个空的JSON数组：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating a PUT API endpoint
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个PUT API端点
- en: In this recipe, we will implement a RESTful `PUT` API endpoint using Play 2.0
    to update an existing record in our data store.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用Play 2.0实现一个RESTful的`PUT` API端点，以更新我们数据存储中的一个现有记录。
- en: How to do it…
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'For Java, we need to perform the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要执行以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_java`应用程序：
- en: '[PRE25]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify `foo_java/app/controllers/Products.java` by adding the following action:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下动作来修改`foo_java/app/controllers/Products.java`：
- en: '[PRE26]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a new route for the newly added action in `foo_java/conf/routes`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新增的操作添加一个新的路由：
- en: '[PRE27]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using `curl`, we will update an existing product in our data store:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`，我们将更新我们数据存储中的一个现有产品：
- en: '[PRE28]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For Scala, we need to perform the following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要执行以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_scala`应用程序：
- en: '[PRE29]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Modify `foo_scala/app/controllers/Products.scala` by adding the following action:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下动作来修改`foo_scala/app/controllers/Products.scala`：
- en: '[PRE30]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add a new route for the newly added action in `foo_scala/conf/routes`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_scala/conf/routes` 中为新增的动作添加一个新的路由：
- en: '[PRE31]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using `curl`, we will update an existing product in our data store:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `curl`，我们将更新我们数据存储中的现有产品：
- en: '[PRE32]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we created a new URL route and action that will update an existing
    record in our data store. We added a new action to the products controller class
    and declared a new route for it in `conf/routes`. In our `edit` action, we declared
    that the action is to expect a request body in JSON format:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们创建了一个新的 URL 路由和动作，该动作将更新我们数据存储中的现有记录。我们在产品控制器类中添加了一个新的动作，并在 `conf/routes`
    中为它声明了一个新的路由。在我们的 `edit` 动作中，我们声明该动作期望请求体为 JSON 格式：
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We check whether the ID value that is passed is valid by doing a lookup in
    our data store. We send an HTTP status 404 for invalid IDs:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在我们的数据存储中进行查找来检查传入的 ID 值是否有效。对于无效的 ID，我们发送 HTTP 状态码 404：
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also check for any form validation errors and will return the appropriate
    status code in the event of errors:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查任何表单验证错误，并在出现错误时返回适当的状态码：
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we used `curl` to test the new product `PUT` action. We can further
    validate the `PUT` endpoint by testing how it handles invalid IDs and and invalid
    request bodies:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `curl` 测试了新的产品 `PUT` 动作。我们可以进一步通过测试它如何处理无效的 ID 和无效的请求体来验证 `PUT` 端点：
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating a DELETE API endpoint
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 DELETE API 端点
- en: In this recipe, we will implement a RESTful `DELETE` API endpoint to remove
    a record from our data store.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将实现一个 RESTful `DELETE` API 端点，从我们的数据存储中删除记录。
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'For Java, we need to perform the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java，我们需要执行以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行 `foo_java` 应用程序：
- en: '[PRE37]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Modify `foo_java/app/controllers/Products.java` by adding the following action:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下动作修改 `foo_java/app/controllers/Products.java`：
- en: '[PRE38]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add a new route for the newly added action in `foo_java/conf/routes`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/conf/routes` 中为新增的动作添加一个新的路由：
- en: '[PRE39]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using `curl`, remove an existing record, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `curl`，按照以下方式删除现有记录：
- en: '[PRE40]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For Scala, we need to perform the following steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Scala，我们需要执行以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行 `foo_scala` 应用程序：
- en: '[PRE41]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Modify `foo_scala/app/controllers/Products.scala` by adding the following action:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下动作修改 `foo_scala/app/controllers/Products.scala`：
- en: '[PRE42]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add a new route for the newly added action in `foo_scala/conf/routes`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_scala/conf/routes` 中为新增的动作添加一个新的路由：
- en: '[PRE43]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Using `curl`, remove an existing record as shown here:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `curl`，按照以下方式删除现有记录：
- en: '[PRE44]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we created a new URL route and action that is used to remove
    an existing product record. We declared the `delete` action to look up the record
    by the ID parameter passed in. We ensure that the the appropriate HTTP status
    code is returned in the event of an invalid ID, in this case, HTTP status code
    404:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们创建了一个新的 URL 路由和动作，用于删除现有的产品记录。我们声明了 `delete` 动作通过传入的 ID 参数来查找记录。我们确保在无效
    ID 的情况下返回适当的 HTTP 状态码，在这种情况下，HTTP 状态码 404：
- en: '[PRE45]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We then ensure that the appropriate HTTP status code for successful record
    removal is returned, in this case, HTTP status code 204:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保返回适当的 HTTP 状态码以表示记录删除成功，在这种情况下，HTTP 状态码 204：
- en: '[PRE46]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can also test the `DELETE` endpoint and verify that it handles invalid IDs
    correctly:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试 `DELETE` 端点并验证它是否正确处理无效的 ID：
- en: '[PRE47]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Securing API endpoints with HTTP basic authentication
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HTTP 基本认证保护 API 端点
- en: In this recipe, we will explore how to secure API endpoints using the HTTP basic
    authentication scheme with Play 2.0\. We will use the Apache Commons Codec library
    for Base64 encoding and decoding for this recipe. This dependency is implicitly
    imported by Play and we will not need to explicitly declare it to our library
    dependencies in `build.sbt`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将探讨如何使用 Play 2.0 的 HTTP 基本认证方案来保护 API 端点。我们将使用 Apache Commons Codec
    库进行 Base64 编码和解码。这个依赖项被 Play 隐式导入，我们不需要在 `build.sbt` 的库依赖中显式声明它。
- en: How to do it…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'For Java, we need to perform the following steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java，我们需要执行以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行 `foo_java` 应用程序：
- en: '[PRE48]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a new `play.mvc.Security.Authenticator` implementation class in `foo_java/app/controllers/BasicAuthenticator.java`
    with the following content:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/app/controllers/BasicAuthenticator.java` 中创建一个新的 `play.mvc.Security.Authenticator`
    实现类，内容如下：
- en: '[PRE49]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Modify `foo_java/app/controllers/Products.java` by adding the following annotation
    to the API actions:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向API操作添加以下注解来修改`foo_java/app/controllers/Products.java`：
- en: '[PRE50]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Using `curl`, send a request to the existing RESTful `GET` endpoint as we did
    earlier; you will now see an unauthorized response:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`，发送一个请求到我们之前所做的现有RESTful `GET`端点；你现在将看到一个未授权的响应：
- en: '[PRE51]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using `curl` again, send another request to the existing RESTful `GET` endpoint,
    this time with the user credentials, `ned` (username) and `flanders` (password):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`curl`，发送另一个请求到现有的RESTful `GET`端点，这次带有用户凭据，`ned`（用户名）和`flanders`（密码）：
- en: '[PRE52]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For Scala, we need to perform the following steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要执行以下步骤：
- en: 'Run `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载功能运行`foo_scala`应用程序：
- en: '[PRE53]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a new `ActionBuilder` class in `foo_scala/app/controllers/BasicAuthAction.scala`
    with the following content:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/controllers/BasicAuthAction.scala`中创建一个新的`ActionBuilder`类，并添加以下内容：
- en: '[PRE54]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Modify `foo_scala/app/controllers/Products.scala` by adding the newly created
    `ActionBuilder` class with the API actions instead:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加新创建的`ActionBuilder`类和API操作来修改`foo_scala/app/controllers/Products.scala`：
- en: '[PRE55]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Using `curl`, send a request to the existing RESTful `GET` endpoint as we did
    earlier; you will now see an unauthorized response:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`，发送一个请求到我们之前所做的现有RESTful `GET`端点；你现在将看到一个未授权的响应：
- en: '[PRE56]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Using `curl` again, send another request to the existing RESTful `GET` endpoint,
    this time with the user credentials, `ned` (username) and `flanders` (password):'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`curl`，发送另一个请求到现有的RESTful `GET`端点，这次带有用户凭据，`ned`（用户名）和`flanders`（密码）：
- en: '[PRE57]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we secured the RESTful API endpoints using the HTTP basic authentication
    scheme with Play 2.0\. We created the respective security implementation class
    for both Java and Scala. For each security implementation class, `BasicAuthenticator.java`
    and `BasicAuthAction.scala`, we retrieved the authorization header and decoded
    the value string to decrypt the user credentials that we passed in:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用Play 2.0的HTTP基本认证方案对RESTful API端点进行了安全保护。我们为Java和Scala创建了相应的安全实现类。对于每个安全实现类，`BasicAuthenticator.java`和`BasicAuthAction.scala`，我们检索了授权头并解码了值字符串以解密我们传递的用户凭据：
- en: '[PRE58]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Once we got the username and password, we invoked the `isAuthenticated` function
    to check the validity of the user credentials:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了用户名和密码，我们就调用了`isAuthenticated`函数来检查用户凭据的有效性：
- en: '[PRE59]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We then utilized the security implementation classes by annotating the Java
    API actions and declaring it as the API action class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过注解Java API操作并声明为API操作类来利用安全实现类：
- en: '[PRE60]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Using `curl`, we can also check whether our secure API actions handle unauthenticated
    requests:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl`，我们还可以检查我们的安全API操作是否处理未认证的请求：
- en: '[PRE61]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Consuming external web APIs
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费外部Web API
- en: In this recipe, we will explore the Play WS API to consume external web services
    from a Play 2 web application. As web application requirements evolve, we become
    more dependent on external data services for data such as foreign exchange rates,
    real-time weather data, and so on. The Play WS library provides us with APIs to
    be able to interface with external web services.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索Play WS API，从Play 2 Web应用程序中消费外部Web服务。随着Web应用程序需求的发展，我们对外部数据服务的依赖性越来越大，例如外汇汇率、实时天气数据等。Play
    WS库为我们提供了与外部Web服务接口的API。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For Java, we need to perform the following steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要执行以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载功能运行`foo_java`应用程序：
- en: '[PRE62]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Declare `playWs` as a project dependency in `build.sbt`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将`playWs`声明为项目依赖项：
- en: '[PRE63]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a new controller in `foo_java/app/controllers/WebClient.java` and add
    the following content:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/controllers/WebClient.java`中创建一个新的控制器并添加以下内容：
- en: '[PRE64]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add a new route entry for the newly added action in `foo_java/conf/routes`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE65]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Using `curl`, we will be able to test how our new action is able to consume
    an external web API:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`，我们将能够测试我们的新操作如何消费外部Web API：
- en: '[PRE66]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For Scala, we need to perform the following steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要执行以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用热重载功能运行`foo_scala`应用程序：
- en: '[PRE67]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Declare `playWs` as a project dependency in `build.sbt`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中将`playWs`声明为项目依赖项：
- en: '[PRE68]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create a new controller in `foo_scala/app/controllers/WebClient.scala` and
    add the following content:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/controllers/WebClient.scala`中创建一个新的控制器并添加以下内容：
- en: '[PRE69]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add a new route entry for the newly added action in `foo_scala/conf/routes`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/routes`中为新增的操作添加一个新的路由条目：
- en: '[PRE70]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Using `curl`, we will be able to test how our new action is able to consume
    an external web API:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`，我们将能够测试我们的新操作如何消费外部Web API：
- en: '[PRE71]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we utilized the Play 2.0 plugin, WS, to consume an external
    web API. We created a new route and `AsynchronousAction` method. In the action,
    we passed the external API''s URL into the WS api and specified that it will be
    a `GET` operation:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们利用了Play 2.0插件WS来消费外部Web API。我们创建了一个新的路由和`AsynchronousAction`方法。在操作中，我们将外部API的URL传递给WS
    api，并指定它将是一个`GET`操作：
- en: '[PRE72]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We then parsed the JSON response and piped it into the resulting response of
    the newly created route, `/client/get_todos`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后解析了JSON响应，并将其管道输入到新创建的路由`/client/get_todos`的结果响应中：
- en: '[PRE73]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Using the Twitter API and OAuth
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Twitter API和OAuth
- en: In this recipe, we will explore how we can use the built-in support of Play
    2.0 for OAuth to retrieve tweets from the Twitter API.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将探讨如何使用Play 2.0的内置OAuth支持从Twitter API检索推文。
- en: How to do it…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For Java, we need to perform the following steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要执行以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_java`应用程序：
- en: '[PRE74]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Specify your Twitter API information in `foo_java/conf/application.conf`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/conf/application.conf`中指定您的Twitter API信息：
- en: '[PRE75]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Modify the `WebClient` controller in `foo_java/app/controllers/WebClient.java`
    with the following action:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/controllers/WebClient.java`中修改`WebClient`控制器，按照以下操作：
- en: '[PRE76]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Add the new route for the `getTweets(hashtag: String)` action to `foo_java/conf/routes`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`foo_java/conf/routes`中为`getTweets(hashtag: String)`操作添加新的路由：'
- en: '[PRE77]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Add a new view template in `foo_java/app/views/tweets.scala.html` with the
    following content:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_java/app/views/tweets.scala.html`中添加一个新的视图模板，内容如下：
- en: '[PRE78]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Using a web browser, access the `/client/get_tweets/:hashtag` route to view
    tweets retrieved from the Twitter API:![](img/gqMspVre.jpg)
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问`/client/get_tweets/:hashtag`路由以查看从Twitter API检索的推文：![](img/gqMspVre.jpg)
- en: 'For Scala, we need to perform the following steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要执行以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Hot-Reloading运行`foo_scala`应用程序：
- en: '[PRE79]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Specify your Twitter API information in `foo_scala/conf/application.conf`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/conf/application.conf`中指定您的Twitter API信息：
- en: '[PRE80]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Modify the `WebClient` controller in `foo_scala/app/controllers/WebClient.scala`
    with the following action:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/controllers/WebClient.scala`中修改`WebClient`控制器，按照以下操作：
- en: '[PRE81]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Add the new routes for the `getTweets(hashtag: String)` action in `foo_scala/conf/routes`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`foo_scala/conf/routes`中为`getTweets(hashtag: String)`操作添加新的路由：'
- en: '[PRE82]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Add a new view template in `foo_scala/app/views/tweets.scala.html` with the
    following content:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foo_scala/app/views/tweets.scala.html`中添加一个新的视图模板，内容如下：
- en: '[PRE83]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Using a web browser, access the `/client/get_tweets/:hashtag` route to view
    tweets retrieved from the Twitter API, as shown in the following screenshot:![](img/FmkrgheD.jpg)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器访问`/client/get_tweets/:hashtag`路由以查看从Twitter API检索的推文，如下截图所示：![](img/FmkrgheD.jpg)
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we created a new URL route and action to retrieve and display
    Tweets by the hashtag specified in the request route, `/client/get_tweets/:hashtag`.
    We implemented the action method by retrieving the required Twitter API consumer
    and access token keys from `conf/application.conf` (remember to register for a
    Twitter Dev account at [http://dev.twitter.com](http://dev.twitter.com) and generate
    your consumer and access tokens for this recipe):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们创建了一个新的URL路由和操作来检索和显示由请求路由`/client/get_tweets/:hashtag`中指定的hashtag标记的推文。我们通过从`conf/application.conf`（记得在[http://dev.twitter.com](http://dev.twitter.com)注册Twitter开发者账户并为本菜谱生成消费者和访问令牌）检索所需的Twitter
    API消费者和访问令牌密钥来实现操作方法：
- en: '[PRE84]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We then passed these credentials to the Play class `OAuthCalculator` as we
    accessed the Twitter search API endpoint:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些凭证传递给Play类`OAuthCalculator`，当我们访问Twitter搜索API端点时：
- en: '[PRE85]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Once the Twitter API response returns, we parse the response JSON and push
    it to a intermediate collection object, which we then passed on to our view template:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Twitter API响应返回，我们解析响应的JSON并将其推送到一个中间集合对象，然后将其传递给我们的视图模板：
- en: '[PRE86]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
