- en: A Three-Tier Web Application Using REST
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 REST 的三层网络应用
- en: 'It should be safe to say that the vast majority of developers know what REST
    is. A three-tier web application consists of the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应该可以说，绝大多数开发者都知道什么是 REST。一个三层网络应用由以下组成：
- en: Presentation layer (HTML and CSS)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示层（HTML 和 CSS）
- en: Business logic layer (application code)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务逻辑层（应用代码）
- en: Data layer (Relational Database Management System or another type of data store)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据层（关系数据库管理系统或另一种类型的数据存储）
- en: The three-tier web application is extremely well known and one of the most common
    designs on the web today. Readers are likely familiar with this design when thinking
    about a web application's static content (that is, HTML, JavaScript, and CSS)
    which are served from a **content delivery network** (**CDN**), which talks to
    a RESTful API hosted on a web server, which, in turn, talks to a database.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 三层网络应用非常知名，并且是目前网络中最常见的架构之一。当考虑网络应用的静态内容（即 HTML、JavaScript 和 CSS）时，读者可能会熟悉这种设计，这些内容是从
    **内容分发网络**（**CDN**）提供的，该网络与托管在 Web 服务器上的 RESTful API 通信，而该服务器反过来又与数据库通信。
- en: In this chapter, we will go through the process of building a three-tier web
    application using HTML, JavaScript, and CSS for our presentation layer, a REST
    API for our business logic, and a Postgres database for our data tier. Most importantly,
    and keeping in line with this book, this will all be accomplished using serverless
    technologies or services where you do not need to manage servers yourself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过使用 HTML、JavaScript 和 CSS 构建展示层，REST API 构建业务逻辑，以及 Postgres 数据库构建数据层的过程来构建一个三层网络应用。最重要的是，并且与本书保持一致，这一切都将使用无服务器技术或服务来完成，你不需要自己管理服务器。
- en: 'By the end of this chapter, you can expect to know the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你可以期待了解以下内容：
- en: How to author a REST API using **Amazon Web Services** (**AWS**) Lambda and
    Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 **Amazon Web Services**（**AWS**）Lambda 和 Python 编写 REST API
- en: How to build, manage, and deploy static assets to a CDN
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建、管理和部署静态资产到 CDN
- en: How to create and maintain an RDS Postgres database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和维护 RDS Postgres 数据库
- en: Options for designing RESTful APIs, including different languages, frameworks,
    and layouts of functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 RESTful API 的选项，包括不同的语言、框架和函数布局
- en: Static asset life cycle management and caching for optimal performance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态资产生命周期管理和缓存以实现最佳性能
- en: Serverless tooling
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器工具
- en: 'Since this is the very first chapter that has application code and working
    examples, it''s important to talk through some of the tooling and systems to set
    the stage for this and subsequent chapters. In this and the following chapters
    on web applications, our toolchain will consist of services from AWS:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是第一个包含应用代码和工作示例的章节，因此讨论一些工具和系统对于本章节和后续章节的设置非常重要。在本章和以下关于网络应用的章节中，我们的工具链将包括来自
    AWS 的服务：
- en: AWS API Gateway as the HTTP proxy
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS API Gateway 作为 HTTP 代理
- en: AWS Lambda for computing
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda 用于计算
- en: AWS S3 for static file serving
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS S3 用于静态文件服务
- en: AWS CloudFront for the CDN
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CloudFront 用于 CDN
- en: AWS RDS for RDBMS management
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS RDS 用于 RDBMS 管理
- en: '**AWS Certificate Manager** (**ACM**) for free certificate management'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Certificate Manager**（**ACM**）用于免费证书管理'
- en: While AWS is the dominant player in the Platform as a service (PaaS) ecosystem,
    it is by no means the only choice. While reading this chapter and others in this
    book, remember that the patterns presented should apply to any cloud provider,
    albeit sometimes with a certain degree of adaptation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 AWS 是平台即服务（PaaS）生态系统中的主导者，但绝对不是唯一的选择。在阅读本章和其他章节时，请记住，这里提出的模式应该适用于任何云提供商，尽管有时需要一定程度的调整。
- en: You may be questioning the reasoning behind discussing other services such as
    S3 and RDS. Very often, perhaps usually, when people say *serverless* they are
    talking about functions as a service with AWS Lambda, or equivalent services from
    different cloud providers. This question is a valid one, but it's also critical
    to remember that our definition for serverless architectures in this book is complete
    systems where you don't need to manage any operating systems yourself. Your goal
    is not to maintain a single real or virtual server and push the hard work to your
    favorite cloud provider, allowing you to focus on your application. Admittedly,
    not all cloud providers have the vast number of services at our disposal as in
    the AWS ecosystem. Take this into consideration when choosing a PaaS upon which
    to build your serverless applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在质疑讨论其他服务，如S3和RDS的理由。非常常见，也许通常是，当人们说“无服务器”时，他们是在谈论AWS Lambda或不同云提供商的等效服务中的函数即服务(FaaS)。这个问题是合理的，但也要记住，本书中我们对无服务器架构的定义是完整的系统，你不需要自己管理任何操作系统。你的目标不是维护单个真实或虚拟服务器，并将艰苦的工作推给最喜欢的云提供商，让你能够专注于应用程序。诚然，并非所有云提供商都像AWS生态系统那样拥有大量可供我们使用的服务。在选择构建无服务器应用程序的PaaS时，请考虑这一点。
- en: Building a system with a Function as a service (FaaS) backbone for the business
    logic is a step in the right direction; however, if you are still managing a database,
    are you serverless? Managing your own RDBMS or web server for the serving of static
    assets puts you outside of the serverless architecture box, even if your compute
    layer is serverless.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用作为服务(FaaS)作为业务逻辑骨干构建系统是一个正确的步骤；然而，如果你仍在管理数据库，你算无服务器吗？管理自己的RDBMS或用于提供静态资产的Web服务器会使你脱离无服务器架构的范畴，即使你的计算层是无服务器的。
- en: In [Chapter 1](svrls-dsnptn-bstprac_ch01.html), *Introduction*, I listed a few
    of the popular frameworks that allow us to manage, deploy, and maintain serverless
    applications. All of our sample applications in this book will use the Serverless
    Framework ([https://serverless.com/](https://serverless.com/)), which will help
    us glue various services and systems together, allow us to deploy code, and provide
    much more functionality to make the development process faster and more straightforward. Just
    as with cloud providers, you have multiple choices for frameworks and utilities.
    Covering all of the options is outside the scope of this book and, for simplicity,
    we will stick with the Serverless Framework, which is mature, well used, and frequently
    updated.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](svrls-dsnptn-bstprac_ch01.html)“引言”中，我列出了一些流行的框架，这些框架允许我们管理、部署和维护无服务器应用程序。本书中的所有示例应用程序都将使用Serverless
    Framework([https://serverless.com/](https://serverless.com/))，这将帮助我们连接各种服务和系统，使我们能够部署代码，并提供更多功能，使开发过程更快、更直接。就像云服务提供商一样，你有很多框架和工具的选择。涵盖所有选项超出了本书的范围，为了简单起见，我们将坚持使用Serverless
    Framework，这是一个成熟、广泛使用且经常更新的框架。
- en: From this point on, I will refer to the Serverless Framework when talking about
    the framework itself to differentiate it from the general serverless topic. Due
    to the name *Serverless*, the Serverless Framework can be a bit confusing in the
    context of a book about serverless design patterns. From here on, simply be on
    the lookout for the Serverless Framework if we're discussing details of how to
    deploy, manage, or otherwise control resources on our cloud provider, AWS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，当谈到框架本身时，我将使用“Serverless Framework”来区分它和一般无服务器主题。由于名称“无服务器”，在关于无服务器设计模式的书籍中，Serverless
    Framework可能会有些令人困惑。从现在起，如果我们讨论的是如何在云服务提供商上部署、管理或以其他方式控制资源的细节，请留意Serverless Framework。
- en: Our example project will be a REST API for professional coffee evaluation, called
    cupping in the coffee realm. Coffee cupping at its core is nothing more than a
    fancy spreadsheet of scores for individual coffees, where scores are applied to
    one or more criteria, such as acidity, body, uniformity, and so on. If you enjoy
    coffee and APIs as I do, you should enjoy this and subsequent chapters.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例项目将是一个用于专业咖啡评价的REST API，在咖啡领域被称为“品鉴”。咖啡品鉴在本质上不过是针对单个咖啡的评分的复杂电子表格，评分应用于一个或多个标准，例如酸度、口感、一致性等等。如果你像我一样喜欢咖啡和API，你应该会喜欢这一章以及随后的章节。
- en: System architecture
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统架构
- en: At first glance, a three-tier web application using a REST API can be an easy
    topic and pattern. After all, there are only three layers, which are responsible
    for very discrete tasks, and the final result is just a web application after
    all. However, there are many nuances and areas for tweaking with any web application.
    Serverless web applications are no different. This chapter will attempt to cover
    as many areas as possible, but it's impossible to include every possible configuration
    or design option.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，使用 REST API 的三层网络应用程序可能是一个简单的话题和模式。毕竟，只有三层，每层都负责非常具体的工作，最终结果只是一个网络应用程序。然而，任何网络应用程序都有许多细微之处和可以调整的区域。无服务器网络应用程序也不例外。本章将尽可能涵盖更多区域，但不可能包括每个可能的配置或设计选项。
- en: 'Seeing as we are responsible software designers, let''s sketch out our architecture
    at a high level and drill down into more detail as we work through the different
    layers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是负责的软件设计师，让我们从高层次上勾勒出我们的架构，并在处理不同层时深入更多细节：
- en: '![](img/d8fc4399-0f77-4b6a-b771-4090fdf6daa5.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8fc4399-0f77-4b6a-b771-4090fdf6daa5.png)'
- en: This diagram should look familiar as it's the backbone of many client-server
    web applications out there today. Let's walk through the different layers, going
    from the top down. After discussing these layers at a high level, we'll get into
    the implementation details with a real-world example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图应该看起来很熟悉，因为它是当今许多客户端-服务器网络应用程序的骨干。让我们从上到下浏览不同的层，在讨论这些层的高层次概念后，我们将通过一个真实世界的示例深入了解实现细节。
- en: 'You can find all of the code in this chapter in the following repository:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下存储库中找到本章的所有代码：
- en: '[https://github.com/brianz/serverless-design-patterns/tree/master/ch2](https://github.com/brianz/serverless-design-patterns/tree/master/ch2)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/brianz/serverless-design-patterns/tree/master/ch2](https://github.com/brianz/serverless-design-patterns/tree/master/ch2)'
- en: Even though a common and arguably simple pattern, there are many possible complexities
    when deploying a stack like this on AWS with a serverless architecture. While
    AWS is the PaaS of choice for this and subsequent chapters, there are many topics
    that cannot be covered in great depth due to the size of AWS as a topic by itself.
    If you get stuck or are confused by any missing content, feel free to open a GitHub
    issue at the preceding repository to begin a dialog and I'll do my best to help.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个常见且可以说是简单的模式，但在 AWS 上部署这种具有无服务器架构的堆栈时，存在许多可能的复杂性。虽然 AWS 是本章和后续章节的首选 PaaS，但由于
    AWS 本身作为一个主题的规模，有许多主题无法深入探讨。如果你在之前的存储库中遇到困难或对任何缺失的内容感到困惑，请随时在 GitHub 上创建一个 issue
    以开始对话，我会尽我所能帮助你。
- en: Presentation layer
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示层
- en: Static files may be served from numerous places. In our case, we will use two
    different AWS services which will provide respectable performance shipping assets
    down to the client, as well as fault tolerance and caching, among other things.
    Our HTML, CSS, and JavaScript files will all live in an S3 bucket. We will then
    create a CDN using CloudFront, AWS's CDN offering. CloudFront will not only give
    us better performance than S3 by itself; we will gain the ability to globally
    distribute and cache our content, in addition to serving files from our very own
    custom domain using a free TLS certificate from AWS Certificate Manager.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件可以从多个地方提供。在我们的案例中，我们将使用两个不同的 AWS 服务，这些服务将提供良好的性能，将资产传输到客户端，并提供容错和缓存等功能。我们的
    HTML、CSS 和 JavaScript 文件都将存储在 S3 桶中。然后我们将使用 CloudFront 创建一个 CDN，这是 AWS 的 CDN 服务。CloudFront
    不仅比 S3 本身提供更好的性能；我们还将获得全球分发和缓存我们内容的能力，同时还可以使用 AWS 证书管理器提供的免费 TLS 证书从我们自己的自定义域名提供服务。
- en: Logic layer
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑层
- en: The logical layer is the guts of our application, our code. In this and other
    examples, we'll use Python as our programming language and deploy our functions
    as isolated compute units in AWS Lambda. The Serverless Framework will make this
    quite painless, and this will be the foundation for moving fast and iterating
    on our code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑层是我们应用程序的核心，也就是我们的代码。在这个和其他示例中，我们将使用 Python 作为我们的编程语言，并将我们的函数作为独立的计算单元部署到
    AWS Lambda。Serverless Framework 将使这个过程变得非常简单，这将是快速迭代代码的基础。
- en: Data layer
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据层
- en: While not the core focus of this book, running databases is an integral part
    of modern-day web applications. In this pattern, we'll use a hosted PostgreSQL,
    which the AWS **Relational Data Store** (**RDS**) service will manage for us.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书的核心焦点不是运行数据库，但管理数据库是现代网络应用程序的一个基本组成部分。在这个模式中，我们将使用托管 PostgreSQL，AWS 的 **关系数据存储**（**RDS**）服务将为我们管理它。
- en: Logic layer
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑层
- en: Application code is likely the area of most interest and the layer that has
    the most changes from a traditional web application hosted on a managed server,
    so let's start with that.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码可能是最感兴趣的领域，也是与传统托管在管理服务器上的 Web 应用程序相比变化最大的层次，所以让我们从那里开始。
- en: Application code and function layout
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序代码和函数布局
- en: 'Let''s differentiate two classifications of our organization for the logical
    layer:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们区分我们组织逻辑层的两种分类：
- en: Organization of the Lambda functions themselves, within AWS
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 函数在 AWS 中的组织
- en: Organization of the application code
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序代码的组织
- en: Lambda functions are the unit of work in Lambda and other FaaS providers (for
    simplicity and clarity, I will refer to these as Lambda functions from here on
    out). A single Lambda function may be updated or deployed in isolation without
    affecting other Lambda functions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数是 Lambda 和其他 FaaS 提供商中的工作单元（为了简洁和清晰，我将从此处开始将这些称为 Lambda 函数）。单个 Lambda
    函数可以独立更新或部署，而不会影响其他 Lambda 函数。
- en: Organization of the Lambda functions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 函数的组织
- en: 'With a REST API, there are a few options you have as to how each API endpoint
    maps to a function. The primary options in this design are whether to have a single
    Lambda function handle a single HTTP verb/resource combination, or whether to
    have a single lambda function handle all HTTP verbs for a particular resource.
    It should become more evident as we work through this chapter that Lambda function
    organization and application code organization are related, but not the same:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST API 中，关于每个 API 端点如何映射到函数，你有几种选择。在这个设计中，主要选项是是否让单个 Lambda 函数处理单个 HTTP
    动词/资源组合，或者是否让单个 Lambda 函数处理特定资源的所有 HTTP 动词。随着我们通过本章的学习，Lambda 函数的组织和应用程序代码的组织将是相关的，但并不相同：
- en: '![](img/b20d300f-52c8-4424-984b-d03a3cda4ab6.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b20d300f-52c8-4424-984b-d03a3cda4ab6.jpg)'
- en: In the preceding diagram, we see a possible Lambda function layout for a REST
    API. On the left, unique functions handle a unique CRUD event and resource combination.
    On the right, Lambda functions perform actions on a single resource but with different
    actions (create, read, update, or delete).With the first model (left side of the
    diagram), each REST endpoint is mapped to a single Lambda function. This design
    provides fine-grained control for updating functions, allowing for the deployment
    of a single API endpoint without the danger of inadvertently affecting other APIs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到一个可能的 REST API 的 Lambda 函数布局。在左侧，独特的函数处理独特的 CRUD 事件和资源组合。在右侧，Lambda
    函数对单个资源执行不同的操作（创建、读取、更新或删除）。在第一个模型（图的左侧）中，每个 REST 端点都映射到一个单独的 Lambda 函数。这种设计提供了对函数更新的精细控制，允许在不影响其他
    API 的情况下部署单个 API 端点。
- en: The major downside is that this may quickly become unwieldy as the API grows.
    Imagine the case of an API with 20 resources (`session`, `user`, and so on), each
    with three to four actions `/` HTTP verbs. If you follow this scenario through
    with some basic multiplication, the quick growth of the Lambda functions that
    you'll need to manage and navigate will become obvious.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 主要缺点是，随着 API 的增长，这可能会很快变得难以控制。想象一下，一个有 20 个资源（`session`、`user` 等等）的 API，每个资源有
    3 到 4 个操作 `/` HTTP 动词。如果你用一些基本的乘法来跟进这个场景，你需要管理和导航的 Lambda 函数的快速增长将变得明显。
- en: With the next design, logical groups of REST endpoints are grouped and triggered,
    in effect the main function that routes the request to the appropriate handler.
    If you imagine the simple case of listing `sessions` from this API, an HTTP `GET`
    would come into the `/session` endpoint, which would trigger the `handle_sessions()`
    function. As a part of this payload, our application code would know that a `GET`
    method was invoked and would then invoke a `get_sessions()` function, perhaps
    the same as in the previous design. The significant benefit of this architecture
    is that the number of Lambda functions is drastically reduced over the previous
    design. The downside is that deploying updates affects all REST endpoints, which
    are handled by a single function. However, this may also be a benefit. If there
    were a bug in some shared code that affected all `/session/{id}` endpoints (`GET`,
    `PUT`, and `DELETE`), we'd only need to update a single function to fix them all.
    With the previous design, we would need to update three functions individually.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个设计中，逻辑分组将 REST 端点进行分组和触发，实际上这是将请求路由到相应处理程序的主要功能。如果你想象一下这个 API 中列出 `sessions`
    的简单情况，一个 HTTP `GET` 请求会进入 `/session` 端点，这将触发 `handle_sessions()` 函数。作为此有效负载的一部分，我们的应用程序代码将知道调用了
    `GET` 方法，然后调用 `get_sessions()` 函数，可能和之前的设计相同。这种架构的显著优势是，与之前的设计相比，Lambda 函数的数量大幅减少。缺点是部署更新会影响所有
    REST 端点，这些端点由单个函数处理。然而，这也可能是一个优势。如果有共享代码中的错误影响了所有 `/session/{id}` 端点（`GET`、`PUT`
    和 `DELETE`），我们只需要更新一个函数来修复所有问题。在之前的设计中，我们需要分别更新三个函数。
- en: For this chapter, we will use the grouped design so that we have a single Lambda
    function for groups of REST endpoints. Each group will share a common URL pattern,
    and the HTTP verb will be used to trigger different functions within the application
    code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用分组设计，以便我们有一个用于 REST 端点分组的单个 Lambda 函数。每个组将共享一个公共 URL 模式，HTTP 动词将用于触发应用程序代码中的不同函数。
- en: Organization of the application code
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序代码的组织
- en: Organization of our application code is entirely different than our prior discussion,
    although there is a bit of overlap.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序代码的组织方式与之前的讨论完全不同，尽管有一些重叠。
- en: Laying out application code in a serverless project is slightly different than
    in a traditional web application. While the differences aren't that drastic, I
    find serverless projects a bit more susceptible and intolerant of designs or layouts
    that are not thought through in detail. Because it's so easy to get started, it's
    also easy to start moving in the wrong direction before thinking through and answering
    essential design decisions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在无服务器项目中布局应用程序代码与传统的 Web 应用程序略有不同。虽然这些差异并不那么剧烈，但我发现无服务器项目对没有详细思考的设计或布局更为敏感和难以容忍。因为它启动起来非常容易，所以在思考并回答基本设计决策之前，很容易开始走错方向。
- en: 'Over the years, these are a few of the big lessons I''ve learned when writing
    serverless application code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，我在编写无服务器应用程序代码时学到了一些重要的教训：
- en: Configuration should be done with environment variables, rather than different
    configuration files
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用环境变量进行配置，而不是不同的配置文件
- en: Application code should be well structured, highly modular, and namespaced
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序代码应该具有良好的结构，高度模块化，并且具有命名空间
- en: Think through how many functions you need before coding begins
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编码开始之前，仔细考虑你需要多少个函数
- en: Configuration with environment variables
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境变量进行配置
- en: If you're familiar with the Twelve-Factor App or have worked with Docker much,
    you'll know that configuration may be done using environment variables rather
    than managing multiple disparate configuration files. According to The Twelve-Factor
    App ([https://12factor.net/config](https://12factor.net/config)):[](https://12factor.net/config))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉十二要素应用或与 Docker 有过合作，你会知道配置可以使用环境变量来完成，而不是管理多个不同的配置文件。根据十二要素应用([https://12factor.net/config](https://12factor.net/config))：[链接](https://12factor.net/config))
- en: '"Env vars are easy to change between deploys without changing any code; unlike
    config files, there is little chance of them being checked into the code repo
    accidentally; and unlike custom config files, or other config mechanisms such
    as Java System Properties, they are a language- and OS-agnostic standard."'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: “环境变量易于在部署之间更改，而无需更改任何代码；与配置文件不同，它们被意外检查到代码库中的可能性很小；与自定义配置文件或其他配置机制（如 Java 系统属性）不同，它们是语言和操作系统无关的标准。”
- en: Using environment variables for FaaS enables code deployments to different systems
    (dev, QA, production, and so on). Changing configuration can be as simple as updating
    a variable in your function's config. However, for safety and repeatability, environment
    variable changes should go through some process such as CI/CD to minimize the
    chance of errors.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环境变量为 FaaS 代码部署到不同的系统（开发、QA、生产等）提供了便利。更改配置可能只需更新函数配置中的变量即可。然而，为了安全和可重复性，环境变量更改应通过某些过程（如
    CI/CD）进行，以最大限度地减少错误的机会。
- en: On the flip side, if using file-based configuration, updating the application
    typically requires updating a file, possibly checking into source control and
    redeploying the entire application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果使用基于文件的配置，更新应用程序通常需要更新一个文件，可能还需要提交到源代码控制并重新部署整个应用程序。
- en: In my opinion, there is an enormous increase in productivity using environment
    variables when creating new systems or deploying between different systems. To
    perform a new stack deployment or update of an existing stack, you merely load
    up new environment variables and executes a standard set of steps that don't change
    between stacks. Due to the ease and speed with which you can do this, it encourages
    separation of stacks for different purposes (development, testing, production,
    and much more).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，使用环境变量在创建新系统或在不同系统之间部署时，生产力有巨大的提升。要执行新的堆栈部署或现有堆栈的更新，你只需加载新的环境变量并执行一系列标准步骤，这些步骤在堆栈之间不会改变。由于你可以轻松快速地完成这些操作，这鼓励了为不同的目的（开发、测试、生产等）分离堆栈。
- en: Code structure
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码结构
- en: 'With any new application, there are many ways to organize code on disk. The
    following structure has worked very well for my colleagues and me across multiple
    projects. I encourage readers to use this as a starting point and adapt as needed.
    If using Node.js or another supported language for your FaaS provider, this may
    look slightly different. Throughout this chapter, we will fill in our example
    coffee `cupping` API and will add more files as we build the application:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何新的应用程序，都有许多方法可以在磁盘上组织代码。以下结构在我的多个项目中都取得了很好的效果。我鼓励读者将其作为起点，并根据需要调整。如果你使用
    Node.js 或其他支持的语言作为你的 FaaS 提供商，这可能会略有不同。在本章中，我们将填充我们的示例咖啡 `cupping` API，并在构建应用程序时添加更多文件：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A `Makefile` may be something you skip. I use Docker as a host for application
    development since it's a reasonably easy way to manage environment variables during
    deployment and testing. A simple `Makefile` can make tedious tasks much less verbose
    by hiding the complexity behind a make target.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Makefile` 可能是你可以跳过的部分。我使用 Docker 作为应用程序开发的宿主环境，因为这是一种在部署和测试期间管理环境变量的相对简单的方法。一个简单的
    `Makefile` 可以通过隐藏在 make 目标背后的复杂性，使繁琐的任务变得不那么冗长。'
- en: For details on this Docker methodology, I'll point you to a detailed blog post
    at [http://blog.brianz.bz/post/structuring-serverless-applications-with-python/](http://blog.brianz.bz/post/structuring-serverless-applications-with-python/).
    It'd be perfectly acceptable to run your serverless application development on
    your primary computer without any extra virtualization (Docker, VirtualBox, and
    so on). This Docker/Makefile pattern has worked quite well for me recently across
    multiple projects. I still edit files using my host system, but all runtime work
    (testing, deployment, building packages, and so on) is done from within a Docker
    container.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种 Docker 方法论的详细信息，我将指向一篇详细的博客文章 [http://blog.brianz.bz/post/structuring-serverless-applications-with-python/](http://blog.brianz.bz/post/structuring-serverless-applications-with-python/)。在主计算机上运行无服务器应用程序开发，而不需要任何额外的虚拟化（Docker、VirtualBox
    等）是完全可行的。最近，这种 Docker/Makefile 模式在我的多个项目中都取得了很好的效果。我仍然使用宿主系统编辑文件，但所有运行时工作（测试、部署、构建包等）都是在
    Docker 容器内完成的。
- en: The `envs` directory holds environment variable files, which are simple `key=value`
    pairs. Each environment has a corresponding file of the same name. Looking at
    preceding the example, it should be clear where the configuration resides for
    each environment and what you'd need to do when creating a new environment.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`envs` 目录包含环境变量文件，它们是简单的 `key=value` 对。每个环境都有一个同名的文件。查看前面的示例，应该很清楚每个环境的配置在哪里，以及创建新环境时你需要做什么。'
- en: We place all the code into the `serverless` directory, including application
    code we write, as well as its dependencies. Our application code is namespaced
    into the `cupping` directory. We will install third-party libraries into `lib`.
    Of course, as you write your application, your application code will be namespaced
    to something that is appropriate for your project. I recommend using a meaningful
    name rather than something generic such as `code` or `app`, just to aid new developers
    who come after you in navigating the source tree and for general clarity and explicitness.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有代码放入`serverless`目录中，包括我们编写的应用程序代码以及其依赖项。我们的应用程序代码被命名空间到`cupping`目录中。我们将第三方库安装到`lib`目录。当然，随着你编写应用程序，你的应用程序代码将被命名空间到适合你项目的某个名称。我建议使用有意义的名称，而不是像`code`或`app`这样的通用名称，这样可以帮助在你之后加入的新开发者导航源代码树，并且对于一般的清晰度和明确性也是有益的。
- en: Alongside the application code live two files—`serverless.yml`, which defines
    and controls the Serverless Framework, and `handler.py`, which is the main entry
    point for any API calls. In the preceding diagram, we discussed how logical groupings
    of API endpoints would be handled by a common function within a given file, `handler.py`,
    which will be the entry point for these API calls and delegate the hard to work
    to other functions. In some ways, `handler.py` has a straightforward job, which
    will become apparent.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序代码并列存在两个文件——`serverless.yml`，它定义并控制Serverless框架，以及`handler.py`，它是任何API调用的主要入口点。在前面的图中，我们讨论了API端点的逻辑分组将由给定文件中的公共函数处理，该文件是`handler.py`，它将是这些API调用的入口点并将困难的工作委托给其他函数。在某种程度上，`handler.py`的工作非常直接，这一点将很快变得明显。
- en: As responsible developers, we will make sure our code is well tested. With `pytest`
    as our testing framework of choice in this project, all unit test files live in
    a single `test` folder with some additional helpers and configuration utilities.
    In the preceding example, there are only two test files; more will be added to
    the final project. Your exact testing strategy isn't as important as the simple
    fact of having well-written tests. Serverless projects are incredibly fast to
    deploy, and there may be an inclination to forego tests. Why write unit tests
    when you can just deploy it for real and test it manually? One cannot overstate
    the benefit of having robust unit tests. Regardless of your tooling or language,
    all serverless projects of any decent size or complexity will benefit from tests,
    which you may run locally or on a continuous integration platform or system. Tests
    give us the confidence to deploy quickly and often and also set us up for continuous
    delivery moving forward, allowing a CD system to deploy our code automatically
    only after our tests have passed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为有责任心的开发者，我们将确保我们的代码经过良好的测试。在这个项目中，我们选择`pytest`作为测试框架，所有单元测试文件都位于单个`test`文件夹中，还有一些额外的辅助工具和配置实用程序。在前面的示例中，只有两个测试文件；最终项目中将添加更多。你的具体测试策略并不那么重要，重要的是拥有编写良好的测试。无服务器项目部署速度极快，可能会倾向于省略测试。当你可以直接部署并手动测试时，为什么还要编写单元测试呢？拥有健壮的单元测试的好处是无法言喻的。无论你的工具或语言如何，任何大小或复杂度适度的无服务器项目都将从测试中受益，你可以本地运行或在持续集成平台或系统上运行。测试让我们有信心快速频繁地部署，并为我们未来的持续交付做好准备，允许CD系统仅在测试通过后自动部署我们的代码。
- en: Function layout
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数布局
- en: 'In our example, we will implement a pattern where a single Lambda function
    will handle a single grouping of URL endpoints. The initial set of endpoints that
    we will implement will be the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将实现一个模式，其中单个Lambda函数将处理单个URL端点分组。我们将实现的第一组端点如下：
- en: 'List coffee `cupping` sessions: `GET /session`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出咖啡`cupping`会话：`GET /session`
- en: 'Create a coffee `cupping` session: `POST /session`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建咖啡`cupping`会话：`POST /session`
- en: 'Get coffee `cupping` session details: `GET /session/{id}`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取咖啡`cupping`会话详情：`GET /session/{id}`
- en: 'Delete a coffee `cupping` session: `DELETE /session/{id}`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除咖啡`cupping`会话：`DELETE /session/{id}`
- en: 'Two unique URLs will map to two Lambda functions. These lambda functions will
    be responsible for inspecting the HTTP request passed in from API Gateway, determining
    what HTTP method is being called, and invoking the appropriate application code
    to fulfill the request:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 两个独特的URL将映射到两个Lambda函数。这些Lambda函数将负责检查从API Gateway传入的HTTP请求，确定正在调用哪个HTTP方法，并调用适当的应用程序代码以满足请求：
- en: '![](img/8fb9edd0-ed99-4fa7-abdb-36d005f70c56.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fb9edd0-ed99-4fa7-abdb-36d005f70c56.png)'
- en: Request routing for a `/session` endpoint. The application code will inspect
    the HTTP method and route to the appropriate application code for execution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`/session`端点的请求路由。应用程序代码将检查HTTP方法并将路由到适当的执行应用程序代码。
- en: Presentation layer
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示层
- en: Presentation layers are not necessarily the most exciting area but, in reality,
    they are the entry point for your entire web application, and you should think
    through the details carefully. Naive deployments of HTML, CSS, and JavaScript
    files may result in slow load times, which has a noticeable impact on user experience.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 展示层不一定是最令人兴奋的领域，但事实上，它是整个网络应用的入口点，你应该仔细考虑细节。HTML、CSS和JavaScript文件的简单部署可能会导致加载时间变慢，这对用户体验有显著影响。
- en: When building serverless systems on top of AWS, there are a few different services
    that enable us to host static assets quite easily. Other PaaS systems have similar
    offerings, although there may not be a one-to-one comparison with all of the AWS
    services.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当在AWS上构建无服务器系统时，有几个不同的服务使我们能够轻松托管静态资产。其他PaaS系统也有类似的提供，尽管可能没有与所有AWS服务一一对应。
- en: File storage with S3
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用S3的文件存储
- en: Any frontend assets need a filesystem as a home. In this case, the natural choice
    is AWS **Simple Storage Service** (**S3**), which is Amazon's high durability
    object storage service. S3 advertises 99.999999999% durability, so it's safe to
    say our files will be available when we need them. While it's possible to serve
    content from S3 as a website on a custom domain, it's not the best choice for
    this scenario. AWS CloudFront will aid us in distributing files to end users quickly
    and efficiently.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 任何前端资产都需要一个文件系统作为家。在这种情况下，自然的选择是AWS**简单存储服务**（**S3**），这是亚马逊的高耐用性对象存储服务。S3宣称99.999999999%的耐用性，所以可以说我们的文件在我们需要的时候都会可用。虽然可以从S3作为自定义域上的网站提供内容，但这并不是这种场景的最佳选择。AWS
    CloudFront将帮助我们快速有效地将文件分发给最终用户。
- en: CDN with CloudFront
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CloudFront的CDN
- en: CloudFront is Amazon's CDN service. A CDN's primary focus is to improve the
    delivery of static assets to the end user. This task is typically accomplished
    by running multiple **points of presence** (**POPs**) around the globe and distributing
    your contents in those various geographic locations. When a user somewhere on
    the planet requests one or more of your files, the CDN can fetch the content that
    is closest to the user to minimize latency. Of course, this is only one small
    and dumbed-down explanation of a single CDN feature. The bottom line is that CDNs
    help us to speed up delivery of our content and should be used in any web application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFront是亚马逊的CDN服务。CDN的主要关注点是提高对最终用户的静态资产交付。这项任务通常是通过在全球范围内运行多个**存在点**（**POPs**）并将内容分布在这些不同的地理位置来完成的。当地球上某个地方的用户请求一个或多个文件时，CDN可以获取最接近用户的文件以最小化延迟。当然，这只是一个对单个CDN功能的简单和简化的解释。总之，CDNs帮助我们加快内容的交付，并且应该在任何网络应用中使用。
- en: CloudFront has some very nice features that will allow us to integrate with
    other AWS services. We will create a CloudFront distribution that will pull our
    content from S3\. In this way, CloudFront is a layer that aids in the acceleration
    of content delivery but does not own any content itself. We'll be able to configure
    caching controls to suit our needs and will also be able to serve our content
    over a custom domain with a free TLS certificate from AWS Certificate Manager.
    All of this is possible thanks to CloudFront.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFront有一些非常不错的功能，将允许我们与其他AWS服务集成。我们将创建一个CloudFront分发，它将从S3中提取我们的内容。这样，CloudFront是一个帮助加速内容交付的层，但它本身并不拥有任何内容。我们将能够配置缓存控制以满足我们的需求，并且还可以通过AWS证书管理器提供的免费TLS证书在自定义域上提供我们的内容。所有这一切都得益于CloudFront。
- en: Data layer
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据层
- en: It's safe to say that most web applications today have some data store, whether
    it's a relational database (PostgreSQL, MySQL, SQLServer, and so on), a non-relational
    database (MongoDB, Redis, Cassandra, and so on), or even static file storage (S3,
    OS filesystem, and so on).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，现在的大多数网络应用都拥有某种数据存储，无论是关系型数据库（PostgreSQL、MySQL、SQLServer等等），非关系型数据库（MongoDB、Redis、Cassandra等等），甚至是静态文件存储（S3、OS文件系统等等）。
- en: AWS RDS service will manage a PostgreSQL database for our coffee `cupping` application.
    RDS offers different RDBMS choices, most notably PostgreSQL, MySQL, Oracle, and
    SQLServer. There are other choices, and I encourage you to take a look at the
    various offerings. For this exercise, we'll be using a standard PostgreSQL database
    hosted on RDS. Many configuration options come with RDS, which we won't cover.
    Just know that it's possible and quite simple to run, configure, and manage a
    high-availability RDBMS instance using RDS. Other PaaS providers offer similar
    services for relational databases.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: AWS RDS 服务将为我们咖啡“品鉴”应用程序管理一个 PostgreSQL 数据库。RDS 提供了不同的 RDBMS 选项，最显著的是 PostgreSQL、MySQL、Oracle
    和 SQLServer。还有其他选择，我鼓励您查看各种服务。在这个练习中，我们将使用 RDS 上托管的标准 PostgreSQL 数据库。RDS 提供了许多配置选项，我们不会涉及。只需知道，使用
    RDS 运行、配置和管理高可用性 RDBMS 实例是可能的，并且相当简单。其他 PaaS 提供商也提供类似的服务用于关系数据库。
- en: Writing our logic layer
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的逻辑层
- en: Since we've covered the overall design and different layers, let's get down
    to the implementation of our application code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经涵盖了整体设计和不同层级，让我们着手实现我们的应用程序代码。
- en: Application entrypoint
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序入口点
- en: 'Every application, web or otherwise, needs a primary entry point. In our case,
    we''ll use `handler.py` to begin application execution when a Lambda function
    is invoked. Serverless Framework applications will generate a `handler.py` file
    when you bootstrap a new project, so this pattern should be familiar to anyone
    who has used Serverless before. If you''ve never worked with the Serverless Framework,
    what follows will be a thorough introduction:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序，无论是网络应用程序还是其他类型的，都需要一个主要的入口点。在我们的案例中，当 Lambda 函数被调用时，我们将使用 `handler.py`
    来开始应用程序的执行。Serverless Framework 应用程序在您初始化一个新项目时会生成一个 `handler.py` 文件，因此这种模式应该对任何之前使用过
    Serverless 的人来说都很熟悉。如果您从未使用过 Serverless Framework，以下将是一个全面的介绍：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `handler.py` code isn't very complicated and delegates most application
    logic to different parts of our application code (namespaced into the `cupping`
    package). This pattern of having a single entry point for all Lambda functions
    is advantageous for a few reasons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `handler.py` 代码并不复杂，并将大部分应用程序逻辑委托给应用程序代码的不同部分（命名空间在 `cupping` 包中）。这种为所有
    Lambda 函数拥有单个入口点的模式有几个优点。
- en: When Lambda functions execute, they only know what they know. That is, we as
    application developers are used to installing extra packages in some known location
    (which is the default system package location) or perhaps creating a Python `virtualenv`
    and configuring our server to look there during the import cycle. During a Lambda,
    we are responsible for managing this ourselves. Application code has no idea where
    to look for packages beyond the built-in libraries without being told where to
    look. The code block below shows how to manipulate Python's `path` so that it
    can find any extra packages we wish to use.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Lambda 函数执行时，它们只知道它们所知道的内容。也就是说，我们作为应用程序开发者习惯于在某个已知位置（默认的系统包位置）安装额外的包，或者可能创建一个
    Python `virtualenv` 并配置服务器在导入周期中查找那里。在 Lambda 中，我们负责自己管理这一点。应用程序代码不知道在没有被告知要查找的地方之外如何查找包。下面的代码块显示了如何操作
    Python 的 `path`，以便它可以找到我们希望使用的任何额外包。
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These four lines of code accomplish the task of resolving the current directory
    of our `handler.py` file and appending a `/lib` onto it. The result is the absolute
    path of the `lib` directory where we've installed all of our system packages.
    During the deployment step, the Serverless Framework will package all directories
    and files that reside at or below the same directory level as the `serverless.yml`
    file, resulting in our `lib` being available to our application code during runtime.
    Any import statement for a third-party library will work as expected, only after
    the addition of the full path to `lib` being manually added to the system path.
    In the preceding example, there is an import for the third-party `simplejson`
    module. Had this import been placed above the `sys.path.insert` call, it would
    have failed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这四行代码完成了解析 `handler.py` 文件当前目录并在其上附加 `/lib` 的任务。结果是我们在其中安装了所有系统包的 `lib` 目录的绝对路径。在部署步骤中，Serverless
    Framework 将打包所有位于或低于 `serverless.yml` 文件同一目录级别的目录和文件，从而使我们的 `lib` 在运行时可供应用程序代码使用。任何第三方库的导入语句都将按预期工作，只需手动将
    `lib` 的完整路径添加到系统路径中即可。在上面的示例中，有一个对第三方 `simplejson` 模块的导入。如果这个导入放在 `sys.path.insert`
    调用之上，它将会失败。
- en: When this path manipulation occurs as soon as possible (that is, as soon as
    `handler.py` is invoked), other parts of our application code can import packages
    without the danger of the import failing. If this path manipulation is done across
    different files only when a particular package is needed, errors will be inevitable
    as you will at some point forget to include this logic. Additionally, doing this
    work in a single place means there is no duplication of logic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当路径操作尽可能快地发生时（即，在 `handler.py` 被调用时立即发生），我们的应用代码的其他部分可以导入包，而不会出现导入失败的风险。如果仅在需要特定包时在不同文件中执行此路径操作，那么错误是不可避免的，因为你可能会在某处忘记包含此逻辑。此外，在单个位置完成这项工作意味着没有逻辑重复。
- en: Application logic
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用逻辑
- en: 'Since our handler function is so simple, let''s take a look at the application
    code to see what exactly is going on. Our coffee cupping API is fairly simple
    and only handles a single resource type at this point, a coffee `cupping` session
    object. Before moving forward, it''s helpful to take a look at the shape of this
    resource type:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的处理函数非常简单，让我们来看看应用代码，看看具体发生了什么。我们的咖啡品鉴 API 相对简单，目前只处理一种资源类型，即咖啡 `cupping`
    会话对象。在继续之前，查看此资源类型的形状是有帮助的：
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Much of the logic of this application is simply the transformation back and
    forth between JSON and database records. The actual application code isn't that
    important in the context of this book. If you'd like to learn more about the actual
    implementation, I encourage you to view the source code at [https://github.com/brianz/serverless-design-patterns](https://github.com/brianz/serverless-design-patterns).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的大部分逻辑仅仅是 JSON 和数据库记录之间的转换。在本书的上下文中，实际的应用代码并不重要。如果你想了解更多关于实际实现的信息，我鼓励你查看
    [https://github.com/brianz/serverless-design-patterns](https://github.com/brianz/serverless-design-patterns)
    的源代码。
- en: 'The logic in `handler.py` will delegate the API requests to the `cupping/handlers/session.py`
    file, which you can see in the following code. The purpose here is to service
    requests for a particular URL pattern (which is `/session`, `/session/{id}`) and
    particular HTTP verb (that is, `GET`, `POST`, `DELETE`) and execute the appropriate
    application code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`handler.py` 中的逻辑将把 API 请求委派给 `cupping/handlers/session.py` 文件，你可以在下面的代码中看到。这里的目的是为特定的
    URL 模式（即 `/session`，`/session/{id}`）和特定的 HTTP 动词（即 `GET`，`POST`，`DELETE`）提供服务，并执行相应的应用代码：'
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The final two functions are the gateway into this part of our application, where
    HTTP verbs are mapped to different functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个函数是进入我们应用这一部分的入口，其中 HTTP 动词映射到不同的函数。
- en: Wiring handler.py to Lambda via API Gateway
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 handler.py 通过 API Gateway 连接到 Lambda
- en: 'Next, we need to wire up our API endpoints to Lambda and our `handler.py` entry
    point. This wiring looks like this in a `serverless.yml` configuration file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的 API 端点连接到 Lambda 和 `handler.py` 入口点。在 `serverless.yml` 配置文件中，这种连接看起来是这样的：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We define two Lambda functions that have different configuration options, `HandleSession`
    and `HandleSessionDetail`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个具有不同配置选项的 Lambda 函数，`HandleSession` 和 `HandleSessionDetail`。
- en: Under each function's name, there are multiple statements that control configuration.
    Look at both sections and you'll notice the `handler:` statement, which instructs
    Lambda what code to call when the Lambda function is executed. For both, we'll
    be running one of the Python functions in `handler.py` that we covered in the
    preceding code snippet.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个函数名称下，有多个语句控制配置。查看这两个部分，你会注意到 `handler:` 语句，它指示 Lambda 在 Lambda 函数执行时调用哪个代码。对于两者，我们都会运行在前面代码片段中提到的
    `handler.py` 中的一个 Python 函数。
- en: But what calls these Lambda functions in the first place? The `events:` section
    is responsible for setting up invocation points and making the connection between
    a particular event and our Lambda function. Across the FaaS landscape, functions
    are invoked in response to an event. In the AWS landscape, the number of events
    that can trigger a Lambda function is quite large. In this scenario, we are configuring
    events to be HTTP endpoints with a particular path and HTTP method. API Gateway
    is the proxy that will provide us with unique HTTPS URLs, which get wired up to
    our Lambda functions according to our configuration. As you read through the configuration,
    our design and intent should be apparent. Again, there are a seemingly infinite
    number of ways to set up an API with these technologies and this example just
    scratches the surface to discuss the overall pattern.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么调用这些 Lambda 函数的呢？`events:` 部分负责设置调用点和建立特定事件与我们的 Lambda 函数之间的连接。在 FaaS 生态系统中，函数是在响应事件时被调用的。在
    AWS 生态系统中，可以触发 Lambda 函数的事件数量相当庞大。在这种情况下，我们正在配置事件以成为具有特定路径和 HTTP 方法的 HTTP 端点。API
    Gateway 是一个代理，它将为我们提供独特的 HTTPS URL，这些 URL 将根据我们的配置连接到我们的 Lambda 函数。随着你阅读配置，我们的设计和意图应该很清楚。再次强调，使用这些技术设置
    API 的方法似乎无穷无尽，而这个例子只是触及了讨论整体模式的一角。
- en: 'Because the frontend JavaScript code will be making HTTP requests to the serverless
    backend, which is hosted on a different domain, CORS will need to be set up for
    each API endpoint. Controlling CORS is simple to do by adding `cors: true` for
    each endpoint in `serverless.yml`. In addition to this setting, the application
    code will explicitly need to return the proper headers in the responses.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '由于前端 JavaScript 代码将向托管在不同域上的无服务器后端发送 HTTP 请求，因此需要为每个 API 端点设置 CORS。通过在 `serverless.yml`
    中为每个端点添加 `cors: true` 来控制 CORS 非常简单。除了这个设置之外，应用程序代码还必须明确地在响应中返回正确的头信息。'
- en: Deploying the REST API
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 REST API
- en: Now the fun part, we'll deploy our REST API using the Serverless Framework.
    At this point, we have not discussed the various configuration options when implementing
    serverless architectures on AWS. I'll cover different possibilities, and our particular
    configuration, later on in this chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是更有趣的部分，我们将使用 Serverless Framework 来部署我们的 REST API。到目前为止，我们还没有讨论在 AWS 上实现无服务器架构时的各种配置选项。我将在本章后面部分介绍不同的可能性，以及我们的特定配置。
- en: My pattern of using Docker as a build and deployment tool makes this process
    a bit easier. You are not required to do this, and there are likely other ways
    to make the process even simpler.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 Docker 作为构建和部署工具的模式使这个过程变得稍微容易一些。你不需要这样做，可能还有其他方法可以使这个过程更加简单。
- en: 'We will do all package building and deployment from inside a running Docker
    container, which I start and enter with the following `Makefile` target:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在运行中的 Docker 容器内部进行所有打包构建和部署，我使用以下 `Makefile` 目标来启动并进入该容器：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This equates to the following Docker command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下 Docker 命令：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is nothing magical here. We're starting up a Docker container from an
    image that contains the Serverless Framework as well as some other Python packages
    for a Python 3 runtime. The main trick is that, based on the `ENV` setting upon
    creation of the container, we pull environment variables from the desired `envs`
    files and load them into the running container. Those environment variables can
    then be referenced from within `serverless.yml` and injected into the Lambda functions,
    hence controlling configuration of the final application by starting from files
    on our local system. Full details are out of scope, but can be reviewed at [http://blog.brianz.bz/post/structuring-serverless-applications-with-python/](http://blog.brianz.bz/post/structuring-serverless-applications-with-python/).[](http://blog.brianz.bz/post/structuring-serverless-applications-with-python/)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么神奇的地方。我们正在从一个包含 Serverless Framework 以及一些其他 Python 包（用于 Python 3 运行时）的镜像启动
    Docker 容器。主要的技巧是，根据容器创建时的 `ENV` 设置，我们从所需的 `envs` 文件中提取环境变量，并将它们加载到正在运行的容器中。然后可以从
    `serverless.yml` 中引用这些环境变量，并将它们注入到 Lambda 函数中，从而通过从本地系统上的文件开始来控制最终应用程序的配置。详细的说明超出了本文的范围，但可以在
    [http://blog.brianz.bz/post/structuring-serverless-applications-with-python/](http://blog.brianz.bz/post/structuring-serverless-applications-with-python/)
    上查看。
- en: The `Makefile` and commands I'm running here are not very sophisticated; however,
    they may appear to be so if you are unfamiliar with Docker or make. I encourage
    those unfamiliar with them to read through the `Makefile` targets and do a bit
    of exploration on their own at [https://github.com/brianz/serverless-design-patterns/blob/master/ch2/Makefile](https://github.com/brianz/serverless-design-patterns/blob/master/ch2/Makefile).
    Feel free to open a GitHub issue if you get stuck or need more clarity.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里运行的`Makefile`和命令并不复杂；然而，如果你不熟悉Docker或make，它们可能看起来很复杂。我鼓励那些不熟悉它们的人阅读`Makefile`目标，并在自己的环境中进行一些探索。[https://github.com/brianz/serverless-design-patterns/blob/master/ch2/Makefile](https://github.com/brianz/serverless-design-patterns/blob/master/ch2/Makefile)。如果你遇到困难或需要更多澄清，请随时在GitHub上提交问题。
- en: 'Now that we''re inside a container with all of our configuration set from environment
    variables, we can deploy the entire stack. Our first step is to ensure we have
    our libraries built and installed into the `lib` directory. In the Python world,
    the `pip` command can help us. Take a look at the `Makefile` in the repository
    for details. Our steps for doing the initial deployment are, therefore, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在一个容器内，所有的配置都通过环境变量设置好了，我们可以部署整个栈。我们的第一步是确保我们的库已经构建并安装到`lib`目录中。在Python世界中，`pip`命令可以帮助我们。有关详细信息，请查看存储库中的`Makefile`。因此，我们进行初始部署的步骤如下：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Deploying the Postgres database
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Postgres数据库
- en: Many frameworks for working with AWS serverless architectures expose access
    to `CloudFormation`, AWS's tool for managing multiple related resources as a single
    entity. The Serverless Framework is no different and, in fact, the `CloudFormation`
    interface is verbatim `CloudFormation` templating with a few nice add-ons specifically
    for variables, environment variables included. A common theme here is that this
    is a huge topic and the details are out of the scope of this book.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用于处理AWS无服务器架构的框架都公开了访问`CloudFormation`的权限，这是AWS用于将多个相关资源作为一个单一实体进行管理的工具。Serverless
    Framework也不例外，实际上，`CloudFormation`接口是直接使用`CloudFormation`模板，并添加了一些针对变量（包括环境变量）的便捷功能。这里的一个共同主题是，这是一个非常大的主题，细节超出了本书的范围。
- en: '`CloudFormation` creates the RDS instance on our behalf with several lines
    of setup in `serverless.yml`. Details aside, note how there are multiple references
    to `${env:VPC_ID}` and other calls to `${env:}`. The `${env}` syntax is a method
    for pulling variables from the environment that exists in the Docker container
    from our process of starting up the container. You may accomplish the same thing
    on your host system provided you have a way of managing environment variables.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`CloudFormation`通过在`serverless.yml`中设置几行配置，代表我们创建RDS实例。细节不在此处，注意如何多次引用`${env:VPC_ID}`和其他对`${env:}`的调用。`${env}`语法是从存在于我们的容器启动过程中的Docker容器中的环境中提取变量的方法。如果你有管理环境变量的方法，你可以在主机系统上完成相同的事情。'
- en: 'Much of the complexity of this setup comes from the fact that Lambda functions
    by default will not have network access to AWS resources inside a **virtual private
    cloud** (**VPC**). Since RDS instances need to run inside a VPC, the Lambda functions
    need to be configured to run inside the same VPC and permissions set up accordingly:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置的复杂性很大程度上源于Lambda函数默认情况下无法访问**虚拟私有云**（**VPC**）内的AWS资源。由于RDS实例需要在VPC内运行，Lambda函数需要配置为在同一个VPC内运行，并相应地设置权限：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: During deployment, the Serverless Framework will add any defined `Resources`
    into the default `CloudFormation` template and deploy them together. Having our
    database described, we can perform a `make deploy` and see our dedicated PostgreSQL
    resource.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署过程中，Serverless Framework会将任何定义的`Resources`添加到默认的`CloudFormation`模板中，并将它们一起部署。我们的数据库描述完成后，我们可以执行`make
    deploy`来查看我们的专用PostgreSQL资源。
- en: RDS and other hosted data stores are not silver bullets. These systems can still
    go down, and there are real constraints concerning computing power. However, a
    significant benefit of using a hosted data store is the hard work of managing,
    monitoring, and configuring is delegated to someone else. Serverless is not accurate
    in this case for a variety of reasons. I will assert that a hosted database eases
    much of the burden of managing your system and is an excellent fit in a truly
    serverless architecture.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: RDS和其他托管数据存储并非万能的解决方案。这些系统仍然可能崩溃，并且在计算能力方面存在实际限制。然而，使用托管数据存储的一个显著好处是将管理、监控和配置的辛勤工作委托给其他人。由于各种原因，无服务器架构在这里并不准确。我将断言，托管数据库可以减轻管理系统的许多负担，并且非常适合真正的无服务器架构。
- en: Setting up static assets
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置静态资源
- en: Setting up an S3 bucket and CloudFront distribution to host static media isn't
    complicated and, in theory, we could add this to the `Resources` section of our
    `serverless.yml` file. The ability of Serverless to manage so many resources via
    `CloudFormation` is a slippery slope, since setting up systems can quickly become
    an exercise in learning and debugging `CloudFormation`. Another downside of a
    growing `Resources` section in the `serverless.yml` file is that deployments will
    take longer and longer. It's possible to only deploy application code during development,
    which results in single-digit second deployments; but when some system resource
    is updated, including environment variables, the entire `CloudFormation` stack
    needs to updated.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 S3 存储桶和 CloudFront 分发以托管静态媒体并不复杂，从理论上讲，我们可以将此添加到 `serverless.yml` 文件的 `Resources`
    部分中。Serverless 能够通过 `CloudFormation` 管理如此多的资源是一个滑梯，因为设置系统可以迅速变成学习和调试 `CloudFormation`
    的练习。`serverless.yml` 文件中不断增长的 `Resources` 部分的另一个缺点是部署将变得越来越长。在开发期间，只部署应用程序代码是可能的，这会导致部署时间以秒计算；但每当更新某些系统资源，包括环境变量时，整个
    `CloudFormation` 堆栈都需要更新。
- en: Rather than creating the S3 bucket and CloudFront distribution via `serverless.yml`,
    we can use a separate `CloudFormation` template designed just for this purpose.
    Another reason for splitting this out into a separate step is that this layer
    rarely changes. Once the CloudFront distribution is set up, there is a good chance
    you won't need to change anything for a very long time, if ever.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是通过 `serverless.yml` 创建 S3 存储桶和 CloudFront 分发，而是可以使用专为这个目的设计的单独的 `CloudFormation`
    模板。将这一步骤拆分出来的另一个原因是这个层很少改变。一旦 CloudFront 分发设置完成，有很大可能性你很长时间内甚至永远都不需要更改任何东西。
- en: 'The following repository contains a `CloudFormation` template, a helper script,
    and documentation to set up a single - page web application on AWS:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下存储库包含一个 `CloudFormation` 模板、一个辅助脚本和文档，用于在 AWS 上设置单页网络应用程序：
- en: '[https://github.com/verypossible/cloudfront-single-page-app](https://github.com/verypossible/cloudfront-single-page-app)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/verypossible/cloudfront-single-page-app](https://github.com/verypossible/cloudfront-single-page-app)'
- en: 'Again, you may read the details of this stack creation in the GitHub repository.
    After we choose one this stack with the necessary variables, we will end up with
    the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你可以通过 GitHub 存储库阅读此堆栈创建的详细信息。在选择包含必要变量的此堆栈后，我们将得到以下结果：
- en: An S3 bucket, which will host all of our static content
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 S3 存储桶，将托管我们所有的静态内容
- en: A CloudFront distribution, which will pull and cache content from S3
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 CloudFront 分发，将从 S3 拉取并缓存内容
- en: A free TLS certificate for `*.cupperslog.com`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `*.cupperslog.com` 提供免费的 TLS 证书
- en: 'A Route53 record, which does the following:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Route53 记录，执行以下操作：
- en: Points [https://cupperslog.com](https://cupperslog.com) to the CloudFront distribution
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 [https://cupperslog.com](https://cupperslog.com) 指向 CloudFront 分发
- en: Redirects any `http://` traffic to `https://`
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有 `http://` 流量重定向到 `https://`
- en: 'Caches static assets for 10 minutes:'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存静态资源10分钟：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'CloudFront distributions can take from several minutes to a couple of hours
    to be created, which is another good reason that we''re doing this separate from
    our application code and database. Once finished, all that is required is uploading
    static assets to the S3 bucket that `CloudFormation` created for you. Ensure that
    the access control policy is set to `public-read` since this is a publicly accessible
    website. Uploading is accomplished via many tools, the AWS CLI tool being one
    of them:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFront 分发的创建可能需要几分钟到几个小时，这也是我们将此与我们的应用程序代码和数据库分开的另一个好理由。一旦完成，所需做的就是将静态资源上传到
    `CloudFormation` 为你创建的 S3 存储桶。请确保访问控制策略设置为 `public-read`，因为这是一个公开可访问的网站。上传可以通过许多工具完成，AWS
    CLI 工具就是其中之一：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Other tools I've used for S3 file management are Cyberduck for OS X, S3 Organizer
    for Firefox, and the regular AWS web interface. They all do more or less the same
    thing, so pick what works for you.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我用于 S3 文件管理的其他工具包括 OS X 的 Cyberduck、Firefox 的 S3 Organizer 和常规的 AWS 网页界面。它们都或多或少地做同样的事情，所以选择适合你的工具。
- en: 'For our example application, the frontend will consist of a simple React application
    that allows users to do the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例应用程序，前端将包括一个简单的 React 应用程序，允许用户执行以下操作：
- en: List coffee `cupping` sessions
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出咖啡 `杯测` 会话
- en: View coffee `cupping` session details
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看咖啡 `杯测` 会话详情
- en: Create a new coffee `cupping` session
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的咖啡 `杯测` 会话
- en: Delete a coffee `cupping` session
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个咖啡 `杯测` 会话
- en: It should be clear that there is no authentication and no notion of a user in
    these examples. This application was built to demonstrate a serverless pattern,
    and even critical details such as user authentication and authorization wouldn't
    fit in this single chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，这些示例中没有认证和用户的概念。这个应用程序是为了演示无服务器模式而构建的，即使是用户认证和授权这样的关键细节也不适合放在这一章中。
- en: Viewing the deployed web application
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看已部署的Web应用程序
- en: With everything in place, we can now upload our frontend assets to S3\. We won't
    review the actual frontend React code, but if you're curious, you can take a look
    at that UI code in the GitHub repository at [https://github.com/brianz/serverless-design-patterns/tree/master/ch2/ui](https://github.com/brianz/serverless-design-patterns/tree/master/ch2/ui).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，我们现在可以将前端资源上传到S3。我们不会审查实际的React前端代码，但如果您感兴趣，可以在GitHub仓库的[https://github.com/brianz/serverless-design-patterns/tree/master/ch2/ui](https://github.com/brianz/serverless-design-patterns/tree/master/ch2/ui)中查看该UI代码。
- en: 'Using the preceding `aws s3 cp` command, a final production build of the frontend
    code is uploaded to S3 and ultimately serves the content as requested by the CloudFront
    CDN. When the first page is rendered, a request is made to our serverless backend
    to get a listing of all coffee `cupping` sessions:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的`aws s3 cp`命令，前端代码的最终生产构建被上传到S3，并最终由CloudFront CDN提供所需的内容。当第一页渲染时，会向我们的无服务器后端发送请求，以获取所有咖啡`cupping`会话的列表：
- en: '![](img/db072595-3241-419d-b12f-177f5ac01c14.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db072595-3241-419d-b12f-177f5ac01c14.png)'
- en: A very common issue, and one that people often forget about, is cross-origin
    resource sharing, which is a security measure put in place by browsers. Our serverless
    backend was set up to sidestep this issue, making development much quicker. For
    a real production system, it's best to only allow CORS for your own domain or,
    better yet, run the serverless backend on your own domain rather than the autogenerated
    domain from API Gateway. Running the serverless API on your own custom domain
    is possible using AWS API Gateway, but this is out of the scope of this chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的问题，但人们常常会忘记的是跨源资源共享（CORS），这是浏览器实施的一项安全措施。我们的无服务器后端被设置来规避这个问题，使得开发过程变得更快。对于真正的生产系统，最好只允许您自己的域进行CORS，或者更好的做法是将无服务器后端运行在您自己的域上，而不是API
    Gateway自动生成的域。使用AWS API Gateway可以在自定义域上运行无服务器API，但这超出了本章的范围。
- en: 'Clicking on a single row, the detail page for the particular session is loaded:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 点击单行，将加载特定会话的详细信息页面：
- en: '![](img/1cd15c11-60e5-4801-a0b6-a04b4d10a84c.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1cd15c11-60e5-4801-a0b6-a04b4d10a84c.png)'
- en: Running tests
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: Since we're responsible developers, we have written a full suite of unit tests
    for our application. For now, tests are run manually inside our Docker container.
    The Docker image used has `py.test` installed, as well as some coverage tools.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 作为负责任的开发者，我们已经为我们的应用程序编写了一套完整的单元测试。目前，测试是在我们的Docker容器内手动运行的。所使用的Docker镜像已安装`py.test`和一些覆盖率工具。
- en: The only dependency to running tests is PostgreSQL. Docker again makes it very
    simple to run a PostgreSQL container and hook it up to our application container.
    Multiple strategies exist for this, from running Docker Compose to merely starting
    up a container with `docker run` and linking the containers manually. For simplicity,
    I use the latter option. See the targets in the repository `Makefile` for details.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试的唯一依赖是PostgreSQL。Docker再次使得运行PostgreSQL容器并将其连接到我们的应用程序容器变得非常简单。有多种策略可以实现这一点，从运行Docker
    Compose到仅使用`docker run`启动容器并手动连接容器。为了简单起见，我使用了后者。有关详细信息，请参阅仓库`Makefile`中的目标。
- en: 'To run tests, inside the container, we execute `make tests`. I have trimmed
    much of the output for brevity and clarity:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，在容器内执行`make tests`。为了简洁和清晰，我已经删除了大部分输出：
- en: '[PRE12]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result is an `htmlcov/index.html` file that visually shows test coverage
    throughout the application and highlights lines that were not executed during
    the test run:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个`htmlcov/index.html`文件，它以可视化的方式显示了应用程序中的测试覆盖率，并突出显示了在测试运行期间未执行的行：
- en: '![](img/fbbfa9ba-735f-4f9c-8f35-3133b08bd294.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbbfa9ba-735f-4f9c-8f35-3133b08bd294.png)'
- en: The preceding image is a test coverage report from the `pytest` and coverage
    libraries
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图是`pytest`和覆盖率库的测试覆盖率报告
- en: 'Coverage may also be displayed on the console if we ask for it specifically:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们特别要求，覆盖率也可以在控制台上显示：
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Iteration and deployment
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代和部署
- en: Inevitably, there will be multiple deployments when developing an application
    such as this, and even once the first production version has shipped. Serverless
    speeds up this process dramatically, and once you experience the increased velocity,
    you may have a hard time going back to your old ways.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发此类应用程序时，不可避免地会有多次部署，甚至在第一个生产版本发布后也是如此。无服务器架构显著加快了这一过程，一旦你体验到了速度的提升，你可能很难回到以前的方式。
- en: A deployment with the Serverless Framework consists of one command with a couple
    of variations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Serverless Framework进行部署包括一条命令和一些变体。
- en: Deploying the entire stack
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署整个堆栈
- en: 'To deploy everything in the `serverless.yml` file, the `deploy` command is
    used, specifying the `stage (-s)` variable (which defaults to `dev`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署`serverless.yml`文件中的所有内容，使用`deploy`命令并指定`stage (-s)`变量（默认为`dev`）：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `make deploy` target in use for this chapter's example executes this exact
    command.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例中使用的`make deploy`目标执行了此确切命令。
- en: When doing a full deployment like this, Serverless will upload your Lambda resources
    and execute the entire `CloudFormation` template. Even with a simple `CloudFormation`
    template, this can take several seconds. With bigger stacks, it can be even longer.
    It's unfortunate that some people believe this is the only method of deploying
    application code with this framework. To make application code deployments even
    faster, we can specify precisely which functions to deploy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行此类完整部署时，Serverless会将你的Lambda资源上传并执行整个`CloudFormation`模板。即使是一个简单的`CloudFormation`模板，这也可能需要几秒钟。对于更大的堆栈，可能需要更长的时间。遗憾的是，有些人认为这是使用此框架部署应用程序代码的唯一方法。为了使应用程序代码部署更快，我们可以精确指定要部署的函数。
- en: Deploying the application code
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序代码的部署
- en: 'Once you are in the state of code iteration and redeployment, you''ll want
    to make that loop as short as possible. To accomplish this, specifying the function
    name when doing the deployment step goes through the process of uploading your
    Lambda function, but skips the `CloudFormation` update. In my experience, this
    results in deployments that are typically low single-digit seconds:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你处于代码迭代和重新部署的状态，你会希望使这个循环尽可能短。为了实现这一点，在部署步骤中指定函数名称会通过上传你的Lambda函数的过程，但会跳过`CloudFormation`更新。根据我的经验，这会导致部署时间通常是低单数秒：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I can hear you thinking, what about doing deployments to a production system
    that is serving live traffic? Behind the scenes, AWS Lambda is using container
    technology to respond to events. During a deployment, any Lambda invocations continue
    doing their jobs as instructed. At a certain point, a new Lambda function will
    complete its upload and configuration process. Only at that time will the new
    function begin serving traffic. In short, the tricky dance of draining active
    connections and handing off new connections to new application state is handled
    for you. This behavior should be a standard feature among other FaaS providers.
    Users of other platforms should verify this on their own.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我能听到你在想，关于将部署到正在处理实时流量的生产系统怎么办？在幕后，AWS Lambda正在使用容器技术来响应事件。在部署期间，任何Lambda调用都会继续按照指示执行其工作。在某个时刻，一个新的Lambda函数将完成其上传和配置过程。只有在那时，新函数才会开始处理流量。简而言之，处理活跃连接和将新连接传递给新应用程序状态的复杂操作由你负责。这种行为应该是其他FaaS提供商的标准功能。其他平台的使用者应该自行验证这一点。
- en: The `Makefile` used in this chapter's example has a target which helps speed
    up the deployment process even more. `make deploy function=FunctionName` may be
    used to deploy a single Lambda function, where `FunctionName` should be a name
    listed in the `serverless.yml` file (for example, `make deploy function=HandleSesion`).
    This works by skipping the `CloudFormation` update and only packaging and uploading
    a single function. `CloudFormation` updates will take a few to many seconds, whereas
    a single function deployment or update is typically low single-digit.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例中使用的`Makefile`有一个目标，可以帮助进一步加快部署过程。可以使用`make deploy function=FunctionName`来部署单个Lambda函数，其中`FunctionName`应该是`serverless.yml`文件中列出的名称（例如，`make
    deploy function=HandleSesion`）。这是通过跳过`CloudFormation`更新，仅打包和上传单个函数来实现的。`CloudFormation`更新可能需要几秒到很多秒，而单个函数的部署或更新通常是低单数秒。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked through the entire process of creating a three-tier
    web application with a serverless architecture consisting of a view layer, data
    layer, and application layer and which is powered by AWS Lambda. All services
    employed in the example web application are from AWS, and none require managing
    a virtual machine or operating system directly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了使用 AWS Lambda 构建的三层无服务器 Web 应用程序的整个过程，该应用程序由视图层、数据层和应用层组成。示例 Web
    应用程序中使用的所有服务均来自 AWS，且无需直接管理虚拟机或操作系统。
- en: Readers should have a good understanding of the advantages of such a system
    and how to start the process of structuring their application using this pattern.
    I presented several helpers and shortcuts that should aid readers in speeding
    up their development.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该充分理解这种系统的优势以及如何使用这种模式开始构建他们应用程序的过程。我介绍了几个辅助工具和快捷方式，这些工具应该有助于读者加快他们的开发速度。
- en: In [Chapter 3](svrls-dsnptn-bstprac_ch03.html), *A* *Three-Tier Web Application
    Pattern with GraphQL*, we will work through a similar pattern by porting the example
    application from a RESTful interface to a GraphQL interface.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](svrls-dsnptn-bstprac_ch03.html)，“使用 GraphQL 的三层 Web 应用程序模式”，我们将通过将示例应用程序从
    RESTful 接口迁移到 GraphQL 接口来处理一个类似的模式。
