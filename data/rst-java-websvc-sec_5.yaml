- en: Chapter 5. Digital Signatures and Encryption of Messages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。消息的数字签名和加密
- en: Since many systems interact with each other to achieve their business goals,
    we often feel the obligation to interact with services exposed by others. Also,
    when security needs play an important role, we must verify that the information
    we receive has been sent from whom we expected, and it has come without being
    altered. It is here where digital signatures will play an important role and help
    us meet this need.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多系统相互交互以实现其业务目标，我们经常感到有义务与他人提供的服务进行交互。此外，当安全需求起着重要作用时，我们必须验证我们收到的信息是否来自我们预期的发送者，并且没有被篡改。数字签名将在这里发挥重要作用，并帮助我们满足这种需求。
- en: Also, we may sometimes need to encrypt the message body to prevent it from being
    read if intercepted by unwanted persons. It is here where we can make use of Secure/Multipurpose
    Internet Mail Extensions, or the S/MIME standard, which is commonly used in the
    world of e-mail for public keys ([http://en.wikipedia.org/wiki/Public_key](http://en.wikipedia.org/wiki/Public_key)),
    encryption ([http://en.wikipedia.org/wiki/Encryption](http://en.wikipedia.org/wiki/Encryption)),
    and signing ([http://en.wikipedia.org/wiki/Digital_signature](http://en.wikipedia.org/wiki/Digital_signature))
    of MIME data ([http://en.wikipedia.org/wiki/MIME](http://en.wikipedia.org/wiki/MIME)),
    and which also offers the ability to adapt the HTTP protocol and allows us to
    use it on RESTful web services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有时我们可能需要加密消息正文，以防止被未经授权的人拦截后阅读。在这里，我们可以利用安全/多用途互联网邮件扩展，或者S/MIME标准，它在电子邮件世界中常用于公钥([http://en.wikipedia.org/wiki/Public_key](http://en.wikipedia.org/wiki/Public_key))、加密([http://en.wikipedia.org/wiki/Encryption](http://en.wikipedia.org/wiki/Encryption))和MIME数据([http://en.wikipedia.org/wiki/MIME](http://en.wikipedia.org/wiki/MIME))的签名([http://en.wikipedia.org/wiki/Digital_signature](http://en.wikipedia.org/wiki/Digital_signature))，并且还提供了适应HTTP协议的能力，允许我们在RESTful
    Web服务上使用它。
- en: 'In this chapter, we are going to learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习以下内容：
- en: Signing messages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签署消息
- en: Verifying signatures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证签名
- en: Encrypting message bodies with S/MIME
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用S/MIME加密消息正文
- en: Digital signatures
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字签名
- en: Digital signatures, nowadays, are a widely used mechanism. They are mainly used
    to sign digital documents and issue electronic invoices, among other things.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名，如今，是一种广泛使用的机制。它们主要用于签署数字文件和发布电子发票等用途。
- en: 'Among the benefits of using them are the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们的好处包括以下内容：
- en: They allow the receiver to obtain the identity of whoever has made the signature.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许接收者获取签名者的身份。
- en: They provide the ability to verify that the information sent has not been altered
    since it has been signed by the issuer.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供了验证发送的信息是否自签名者签名以来未被篡改的能力。
- en: In order to electronically sign the information that we will exchange through
    RESTful web services, we will use the authentication mechanism known as **DomainKeys
    Identified Mail** (**DKIM**), which allows us to decorate messages with headers
    using the rules dictated by the DOSETA specification. This authentication mechanism
    is mainly used for e-mail identity verification; however, it also works over other
    protocols such as HTTP, and it is because of this fact we can integrate it with
    RESTful web services. Thus, we will inject metadata into our messages with the
    purpose of signing, and these signatures can be verified by those who wish to
    consume.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过RESTful Web服务电子签署我们将交换的信息，我们将使用已知的身份验证机制**DomainKeys Identified Mail**（**DKIM**），它允许我们使用DOSETA规范规定的规则对消息进行标头装饰。这种身份验证机制主要用于电子邮件身份验证；然而，它也适用于其他协议，如HTTP，正因为这个事实，我们可以将其与RESTful
    Web服务集成。因此，我们将向我们的消息中注入元数据以进行签名，这些签名可以被希望消费的人验证。
- en: At this time, we will build an example that shows how to sign a message, and
    then dissect each part of it to understand its operation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们将构建一个示例，展示如何签署一条消息，然后分解其每个部分以了解其操作。
- en: 'If you want, you can download the source code using the following link on GitHub:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以使用以下GitHub链接下载源代码：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures)'
- en: 'Otherwise, we will explain it in the following pages. Let''s start by creating
    a new project. Open the terminal and type the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们将在接下来的页面中进行解释。让我们从创建一个新项目开始。打开终端并输入以下内容：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When it asks you for the version, change the default value `1.0-SNAPSHOT` to
    `1.0`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当它要求您输入版本时，请将默认值`1.0-SNAPSHOT`更改为`1.0`
- en: Now, we will generate the keys that allow us to encrypt messages and place them
    in the classpath of our application. For this, we will first import the project
    into Eclipse IDE and then create a folder within the project in which we place
    the keys that we want to generate. In Eclipse, right-click on the new project
    named `signatures` and select the option **New** | **Source folder**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将生成允许我们加密消息并将其放置在应用程序类路径中的密钥。为此，我们将首先将项目导入Eclipse IDE，然后在项目中创建一个文件夹，将我们想要生成的密钥放入其中。在Eclipse中，右键单击名为`signatures`的新项目，然后选择**New**
    | **Source folder**选项。
- en: In the field **Folder name**, we will enter `src/main/resources`, and then we
    press the **Finish** button.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Folder name**字段中，我们将输入`src/main/resources`，然后按**Finish**按钮。
- en: 'Now, let''s go to this directory from the command line and execute the following
    instruction:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从命令行进入此目录并执行以下指令：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we should enter a password for both the KeyStore and the keys with which
    we will sign the message. When it asks you for a password, type `changeit`, which
    is the same password we have been using so far in our examples in this book. Then,
    we enter the requested information as shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该为KeyStore和用于签署消息的密钥输入密码。当它要求您输入密码时，请输入`changeit`，这是我们在本书的示例中一直在使用的相同密码。然后，我们输入如下屏幕截图中显示的请求信息：
- en: '![Digital signatures](img/0109OS_05_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![数字签名](img/0109OS_05_01.jpg)'
- en: Now, we will implement some source code to sign a message. We first need to
    add the required dependencies to the `pom.xml` file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现一些源代码来签署消息。我们首先需要向`pom.xml`文件添加所需的依赖项。
- en: 'First, add the JBoss repository from which we get the artifacts, as shown in
    the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加我们获取构件的JBoss存储库，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s add all the dependencies we need to sign our message, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加所有需要签署消息的依赖项，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the purpose of avoiding duplicated classes in the classpath, we should
    delete the following dependency:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免类路径中的重复类，我们应该删除以下依赖项：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Updating RESTEasy JAR files
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新RESTEasy JAR文件
- en: As we are using the 3.0.6.Final Version to compile the project, it is necessary
    to update the existing versions in JBoss. So, we will go to the URL [http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/](http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/)
    and download the version we just described.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用3.0.6.Final版本来编译项目，需要更新JBoss中的现有版本。因此，我们将转到URL [http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/](http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/)
    并下载我们刚刚描述的版本。
- en: 'When we unzip the `.zip` file, we will find a file named `resteasy-jboss-modules-3.0.6.Final.zip`.
    Let''s unzip this file too, and then paste all its content in our directory `JBOSS_HOME/modules`.
    Given RESTEasy modules have dependencies, we have to update them too. So, after
    we update the RESTEasy modules, we should update the module `org.apache.httpcomponents`.
    Let''s go to the directory `JBOSS_HOME/modules/org/apache/httpcomponents` and
    update the following artifacts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解压`.zip`文件时，我们会找到一个名为`resteasy-jboss-modules-3.0.6.Final.zip`的文件。让我们也解压这个文件，然后将其所有内容粘贴到我们的目录`JBOSS_HOME/modules`中。鉴于RESTEasy模块具有依赖关系，我们也必须更新它们。因此，在更新RESTEasy模块之后，我们应该更新模块`org.apache.httpcomponents`。让我们转到目录`JBOSS_HOME/modules/org/apache/httpcomponents`并更新以下构件：
- en: '`httpclient-4.1.2.jar` to `httpclient-4.2.1.jar`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpclient-4.1.2.jar` 到 `httpclient-4.2.1.jar`'
- en: '`httpcore-4.1.4.jar` to `httpcore-4.2.1.jar`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpcore-4.1.4.jar` 到 `httpcore-4.2.1.jar`'
- en: 'Also, we modify the `module.xml` file because the names of the JAR files are
    different, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们修改`module.xml`文件，因为JAR文件的名称不同，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Applying digital signatures
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用数字签名
- en: 'Now that we have everything we need to compile our project, we will create
    a very simple operation and apply a signature. In order to achieve this, let''s
    create a class called `SignedService` in the source code package called `com.packtpub.resteasy.services`,
    as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有编译项目所需的一切，我们将创建一个非常简单的操作并应用签名。为了实现这一点，让我们在源代码包`com.packtpub.resteasy.services`中创建一个名为`SignedService`的类，如下面的屏幕截图所示：
- en: '![Applying digital signatures](img/0109OS_05_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![应用数字签名](img/0109OS_05_02.jpg)'
- en: To sign a message, we take a key from the KeyStore and use it. We can identify
    the keys in a unique way through their alias and the domain they belong to. For
    example, for the key `demo._domainKey.packtpub.com`, the alias is `demo` and the
    domain it belongs to is the key `packtpub.com`. Given that we can find several
    keys in a KeyStore, RESTEasy offers the capability to select the one we want by
    using the annotation `@Signed`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要签署消息，我们从KeyStore中取出一个密钥并使用它。我们可以通过它们的别名和它们所属的域以唯一的方式标识密钥。例如，对于密钥`demo._domainKey.packtpub.com`，别名是`demo`，它所属的域是密钥`packtpub.com`。鉴于我们可以在KeyStore中找到几个密钥，RESTEasy提供了使用注解`@Signed`来选择我们想要的密钥的能力。
- en: 'Let''s add the method highlighted in the following code to the class and watch
    how the annotation works:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向类添加下面突出显示的方法，并观察注解的工作方式：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following figure shows us in a better way how the key is selected to sign
    the message:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图更好地展示了如何选择密钥来签署消息：
- en: '![Applying digital signatures](img/0109OS_05_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![应用数字签名](img/0109OS_05_03.jpg)'
- en: 'Now, we will define the path under our signed resources will be available,
    so let''s annotate the class as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义我们的签名资源将可用的路径，因此让我们如下注释类：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In order to make the application work properly, we will give it information
    so that it can apply the appropriate signatures.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序正常工作，我们将提供信息，以便它可以应用适当的签名。
- en: First, in the folder `src/main/webapp`, we will create the `WEB-INF` folder
    with an empty `web.xml` file inside.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在文件夹`src/main/webapp`中，我们将创建一个带有空`web.xml`文件的`WEB-INF`文件夹。
- en: 'Let''s start with the `web.xml` file, which should look like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`web.xml`文件开始，它应该如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, the first thing we will do is tell our application what resource we want
    to sign, which is the class that contains the method that we are signing. For
    this, let''s configure the parameter `resteasy.resources` with the corresponding
    full class name, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要做的第一件事是告诉我们的应用程序我们要签名的资源是什么，即包含我们要签名的方法的类。为此，让我们使用参数`resteasy.resources`配置相应的完整类名，如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we will inform our application of the location of the key with which
    we apply the signature (the `.jks` file we created earlier). For this, we have
    two context parameters available, `resteasy.doseta.keystore.classpath` and `resteasy.keystore.filename`.
    Let''s use the first parameter so that our file looks like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将告知我们的应用程序我们应用签名的密钥的位置（我们之前创建的`.jks`文件）。为此，我们有两个可用的上下文参数，`resteasy.doseta.keystore.classpath`和`resteasy.keystore.filename`。让我们使用第一个参数，使我们的文件看起来像下面这样：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you remember, we were asked for a password for the KeyStore when creating
    the key. We will tell our application what this is using the parameter `resteasy.doseta.keystore.password`.
    Let''s add the following content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您记得，当创建密钥时，我们被要求为KeyStore设置密码。我们将使用参数`resteasy.doseta.keystore.password`告诉我们的应用程序这是什么。让我们添加以下内容：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To create the KeyStore from which we will extract the key that will allow us
    to sign the message, we must add the following parameter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建KeyStore，我们将从中提取允许我们签署消息的密钥，我们必须添加以下参数：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we should add the RESTEasy servlet, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该添加RESTEasy servlet，如下所示：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we show how the `web.xml` file should look once you have finished adding
    all the required information:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了一旦您添加了所有必需的信息后，`web.xml`文件应该是什么样子：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s generate the WAR file by executing the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过执行以下命令生成WAR文件：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After this, we will copy the generated artifact in to the JBoss deploy directory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将复制生成的构件到JBoss部署目录中。
- en: Testing the functionality
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试功能
- en: 'Now, open SoapUI and test whether the web service is running as expected, as
    shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开SoapUI并测试Web服务是否按预期运行，如下截图所示：
- en: '![Testing the functionality](img/0109OS_05_04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_04.jpg)'
- en: 'As you can see in the response, we obtain the `DKIM-Signature` header used
    to sign the message. The full content of this header is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在响应中所见，我们获得了用于签署消息的`DKIM-Signature`头。此头的完整内容如下：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From this whole string, what is important for us are the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，从整个字符串中重要的是以下内容：
- en: '`d=`: This is the domain, the value which is indicated at the time we implement
    the method.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d=`：这是域，是我们实现方法时指定的值。'
- en: '`a=`: This is the algorithm used by RESTEasy to sign the message. In this case,
    we use RSA because it is the only algorithm that is supported to date by the framework.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a=`：这是RESTEasy用于签署消息的算法。在这种情况下，我们使用RSA，因为这是到目前为止框架支持的唯一算法。'
- en: The other parameters are not very important, and they are only necessary for
    a signed message.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其他参数并不是很重要，它们只是对签名消息的必要性。
- en: Now, in order to validate the authenticity of the signature, we will create
    a class from which we will make the verification.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了验证签名的真实性，我们将创建一个类，从中进行验证。
- en: 'We will use JUnit; so, first add the corresponding dependency in the `pom.xml`
    file, as shown in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JUnit；因此，首先在`pom.xml`文件中添加相应的依赖项，如下代码片段所示：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s create a new source folder named `scr/test/java` and a package
    named `com.packtpub.resteasy.services.test` inside it. Inside the package, let''s
    create the class `SignedServiceTest` using the following content:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`scr/test/java`的新源文件夹，并在其中创建一个名为`com.packtpub.resteasy.services.test`的包。在该包中，让我们使用以下内容创建`SignedServiceTest`类：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If everything goes well, we will see a green bar as a result of our test, as
    shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将看到一个绿色的条作为我们测试的结果，如下截图所示：
- en: '![Testing the functionality](img/0109OS_05_05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_05.jpg)'
- en: Validating signatures with annotations
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注释验证签名
- en: A simpler way to validate whether a resource is signed is to use annotations.
    This solution can be used mainly when you have a flow of signatures that must
    be met.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 验证资源是否签名的更简单方法是使用注释。当您有必须满足的签名流程时，可以主要使用此解决方案。
- en: 'For example, imagine that employees of the company Packt Publishing have a
    system through which they can apply to increase the RAM of their computers. To
    treat such requests as valid, they must be signed by the person making the request.
    We mean that we only need that the request be signed to be considered valid, as
    shown in the following figure:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设Packt Publishing公司的员工有一个系统，他们可以通过该系统申请增加计算机的RAM。为了将这些请求视为有效，它们必须由提出请求的人签名。我们的意思是，我们只需要请求被签名才能被视为有效，如下图所示：
- en: '![Validating signatures with annotations](img/0109OS_05_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_06.jpg)'
- en: 'For this example, we will add two methods to our `SignedService` class; the
    first method will allow us to send the requests, as shown:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将在我们的`SignedService`类中添加两个方法；第一个方法将允许我们发送请求，如下所示：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To meet the business requirements, we will use the `@Verify` annotation in which
    we can add restrictions on signatures. For now, we only need to verify that the
    request is signed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足业务需求，我们将使用`@Verify`注释，在其中我们可以对签名添加限制。目前，我们只需要验证请求是否已签名。
- en: 'The following is the method that shows all the complicated logic used by the
    boss to approve or deny memory increases to employee PCs:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是老板用来批准或拒绝向员工PC增加内存的所有复杂逻辑的方法：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s deploy the application on JBoss and test it with SoapUI. As we
    have mentioned, the requests must be signed in order to be processed. So, first
    make a request to the method `processRequestRam` without a signature, as shown
    in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在JBoss上部署应用程序，并使用SoapUI进行测试。正如我们已经提到的，请求必须签名才能被处理。因此，首先向`processRequestRam`方法发出未签名的请求，如下截图所示：
- en: '![Validating signatures with annotations](img/0109OS_05_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_07.jpg)'
- en: What is essential for the application to be processed is that it comes from
    the company domain, in this case, `packtpub.com`. Later, the boss conducts a rigorous
    analysis of the application and issues a judgment to determine whether the application
    is approved or rejected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序被处理的关键是它来自公司域，即`packtpub.com`。随后，老板对申请进行严格分析，并作出裁决，确定申请是否被批准或拒绝。
- en: 'For this example, we will remove the method that we created earlier and add
    two methods to our `SignedService` class; the first method will allow us to send
    the requests, as shown:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将删除之前创建的方法，并在我们的`SignedService`类中添加两个方法；第一个方法将允许我们发送请求，如下所示：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The output shows us the error very clearly. The request couldn't be processed
    because there is no `DKIM-Signature` header that contains the information to verify
    the signature. This means that the headers aren't there because they weren't signed
    earlier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示了错误。请求无法处理，因为没有包含用于验证签名的`DKIM-Signature`头信息。这意味着头信息不在那里，因为它们之前没有被签名。
- en: In order to get the request successfully processed, we will call a web service
    that signs the request. We will add the headers with the signature information
    and call the `processRequestRam` method again.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功处理请求，我们将调用一个签署请求的Web服务。我们将添加带有签名信息的头信息，并再次调用`processRequestRam`方法。
- en: 'Let'' start by calling the `requestRam` operation, as shown in the following
    screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从调用`requestRam`操作开始，如下截图所示：
- en: '![Validating signatures with annotations](img/0109OS_05_08.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_08.jpg)'
- en: 'As a result of this callback, we will obtain the following values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此回调的结果，我们将获得以下值：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s keep moving! Now, we will use these values to make a request. From SoapUI,
    let''s invoke the `processRequestRam` operation and focus on the bottom-left area
    of our request editor; there is an option that says **Header**. Let''s select
    this option and click on the **+** symbol. Now, we have to enter the `DKIM-Signature`
    header and place the corresponding value. Also, don''t forget to send the request
    parameter `8-GB` that was the response of the invocation of the `requestRam` operation,
    as highlighted in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进！现在，我们将使用这些值来发出请求。从SoapUI，让我们调用`processRequestRam`操作，并关注请求编辑器的左下角区域；有一个选项说**头信息**。让我们选择这个选项，然后点击**+**符号。现在，我们必须输入`DKIM-Signature`头信息，并放入相应的值。还要记得发送`8-GB`请求参数，这是在调用`requestRam`操作后得到的响应，如下截图所示：
- en: '![Validating signatures with annotations](img/0109OS_05_09.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_09.jpg)'
- en: 'As we can see, the request was successfully processed, but the boss denied
    the increase of memory. Now, we indicate that digital signatures allow us to validate
    that the information is not altered once it has been signed. Suppose malicious
    software intercepted the response, and instead of `8-GB`, it delivered the value
    `12-GB`. Let''s make this request in SoapUI following the theory of digital signatures.
    This request should not be valid; however, we must check:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，请求已成功处理，但老板拒绝了内存增加。现在，我们指出数字签名允许我们验证信息在签名后未被更改。假设恶意软件拦截了响应，而不是`8-GB`，它提供了值`12-GB`。让我们根据数字签名的理论在SoapUI中发出此请求。这个请求不应该有效；然而，我们必须检查：
- en: '![Validating signatures with annotations](img/0109OS_05_10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_10.jpg)'
- en: The error message clearly indicates that the message body was altered, so the
    request is not processed and we get the `HTTP 401 Unauthorized` message. This
    corroborates the statement made before regarding the integrity of the signed messages.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息清楚地指示消息主体已被更改，因此请求未被处理，并且我们收到了`HTTP 401 未经授权`的消息。这证实了之前关于签名消息完整性的说法。
- en: 'RESTEasy allows us, however, to do more than just validate that a message has
    been signed. We can verify that the signer belongs to a specific domain. In our
    example, a firm would be considered valid only when it comes under the `packtpub.com`
    domain. To perform this type of control, we will make the following change:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，RESTEasy允许我们做的不仅仅是验证消息是否已被签名。我们可以验证签名者是否属于特定域。在我们的示例中，只有来自`packtpub.com`域的签名才被视为有效。为了执行这种类型的控制，我们将进行以下更改：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s deploy the application in JBoss and execute the request again from SoapUI:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在JBoss中部署应用程序，并再次从SoapUI执行请求：
- en: '![Validating signatures with annotations](img/0109OS_05_11.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_11.jpg)'
- en: 'Now, let''s force a fault. We will assume that valid messages are only those
    that are signed from the domain `itpacktpub.com`. So, let''s apply the following
    change:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们强制出现故障。我们将假设有效消息只有那些来自`itpacktpub.com`域的签名。因此，让我们应用以下更改：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s deploy the application in JBoss again, and execute the request from
    SoapUI:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次在JBoss中部署应用程序，并从SoapUI执行请求：
- en: '![Validating signatures with annotations](img/0109OS_05_12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用注释验证签名](img/0109OS_05_12.jpg)'
- en: As we expected, the request failed this time. Obviously, this happened because
    the signatures could not be verified as the message was signed with the `packtpub.com`
    domain and not with the `itpacktpub.com` domain as we set in the operation `processRequestRam`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，这次请求失败了。显然，这是因为无法验证签名，因为消息是用`packtpub.com`域而不是我们在`processRequestRam`操作中设置的`itpacktpub.com`域签名的。
- en: 'Suddenly, you wonder why the value of the identified name is `d`. As we mentioned
    before, the letter `d` represents the domain. The RESTEasy documentation explains
    a little more about each of the parameters in the header. Here, we show you an
    example from the documentation about JBoss related to this topic:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 突然间，你想知道为什么标识名称的值是`d`。正如我们之前提到的，字母`d`代表域。RESTEasy文档对头信息中的每个参数进行了更详细的解释。在这里，我们向您展示了与此主题相关的JBoss文档的一个示例：
- en: '*Here''s what an example DKIM-Signature header might look like:*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*以下是一个示例DKIM-Signature头信息可能看起来像的样子：*'
- en: '*DKIM-Signature: v=1;*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*DKIM-Signature: v=1;*'
- en: '*a=rsa-sha256;*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*a=rsa-sha256;*'
- en: '*d=example.com;*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*d=example.com;*'
- en: '*s=burke;*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*s=burke;*'
- en: '*c=simple/simple;*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*c=simple/simple;*'
- en: '*h=Content-Type;*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*h=Content-Type;*'
- en: '*x=0023423111111;*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*x=0023423111111;*'
- en: '*bh=2342322111;*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*bh=2342322111;*'
- en: '*b=M232234=*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*b=M232234=*'
- en: '*As you can see, it is a set of name value pairs delimited by a '';''. While
    it''s not THAT important to know the structure of the header, here''s an explanation
    of each parameter:*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*如您所见，它是一组由`;`分隔的名称值对。虽然了解头信息的结构并不是非常重要，但这里解释了每个参数：*'
- en: '*v: Protocol version. Always 1.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*v: 协议版本。始终为1。*'
- en: '*a: Algorithm used to hash and sign the message. RSA signing and SHA256 hashing
    is the only supported algorithm at the moment by RESTEasy.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*a: 用于哈希和签署消息的算法。目前，RESTEasy仅支持RSA签名和SHA256哈希算法。*'
- en: '*d: Domain of the signer. This is used to identify the signer as well as discover
    the public key to use to verify the signature.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*d: 签名者的域。这用于识别签名者以及发现用于验证签名的公钥。*'
- en: '*s: Selector of the domain. Also used to identify the signer and discover the
    public key.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*s: 域的选择器。也用于识别签名者和发现公钥。*'
- en: '*c: Canonical algorithm. Only simple/simple is supported at the moment. Basically,
    this allows you to transform the message body before calculating the hash.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*c: 规范算法。目前只支持simple/simple。基本上，这允许你在计算哈希之前转换消息正文。*'
- en: '*h: Semi-colon delimited list of headers that are included in the signature
    calculation.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*h: 分号分隔的标题列表，包括在签名计算中。*'
- en: '*x: When the signature expires. This is a numeric long value of the time in
    seconds since epoch. Allows signer to control when a signed message''s signature
    expires.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*x: 签名何时过期。这是自纪元以来以秒为单位的时间的数字长值。允许签名者控制已签名消息的签名何时过期。*'
- en: '*t: Timestamp of signature. Numeric long value of the time in seconds since
    epoch. Allows the verifier to control when a signature expires.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*t: 签名的时间戳。自纪元以来以秒为单位的数字长值。允许验证器控制签名何时过期。*'
- en: '*bh: Base 64 encoded hash of the message body.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*bh: 消息正文的Base64编码哈希。*'
- en: '*b: Base 64 encoded signature.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*b: Base64编码的签名。*'
- en: 'Now that we have this information, it is clear to assume that if you want to
    check the signer, instead of using the letter `d`, we must use the letter `s`,
    and instead of `packtpub.com`, we will use `demo`. Once you apply these changes,
    our code should look like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些信息，很明显可以假设，如果你想检查签名者，而不是使用字母`d`，我们必须使用字母`s`，而不是`packtpub.com`，我们将使用`demo`。一旦你应用了这些更改，我们的代码应该如下所示：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In addition, if you want to verify the signer''s name and domain, you must
    apply a slight change. This time, we will use the `@Verifications` annotation;
    this annotation receives an array of `@Verify` annotations as a parameter, which
    allows us to perform what we described earlier. In this case, we should add two
    controls using the `@Verify` annotation, and our code should look like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想验证签名者的名称和域，你必须进行轻微的更改。这次，我们将使用`@Verifications`注解；这个注解接收一个`@Verify`注解的数组作为参数，这允许我们执行我们之前描述的操作。在这种情况下，我们应该使用`@Verify`注解添加两个控件，我们的代码应该如下所示：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we have applied the changes, we can perform a request using SoapUI. We
    should get a successful execution as the result, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们应用了这些更改，我们可以使用SoapUI执行一个请求。我们应该得到一个成功的执行结果，如下面的截图所示：
- en: '![Validating signatures with annotations](img/0109OS_05_13.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![使用注解验证签名](img/0109OS_05_13.jpg)'
- en: Message body encryption
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息正文加密
- en: In the previous chapter, we saw how to encrypt a complete HTTP message using
    HTTPS. Now, we will explain how we can encrypt just the message body and the differences
    between each process. We start by constructing a simple example, and then, as
    we perform the respective tests of our implementation, we'll understand how it
    works.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用HTTPS加密完整的HTTP消息。现在，我们将解释如何只加密消息正文以及每个过程之间的区别。我们首先构建一个简单的例子，然后，当我们执行我们实现的相应测试时，我们将了解它是如何工作的。
- en: 'In order not to spoil our previous project, we will build a new one. For this,
    we will execute the following commands in the terminal:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不破坏我们之前的项目，我们将构建一个新的项目。为此，我们将在终端中执行以下命令：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As seen earlier in this chapter, when you get asked for a version, change the
    default value of `1.0-SNAPSHOT` to `1.0`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在本章前面所看到的，当你被要求一个版本时，将`1.0-SNAPSHOT`的默认值更改为`1.0`。
- en: 'Of course, if you want, you can download all the source code from GitHub from
    the following URL:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你愿意，你可以从以下URL从GitHub下载所有源代码：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption)'
- en: Now, let's import the project into Eclipse, delete the existing default dependence
    in the `pom.xml` file, and add dependencies on the artifacts `resteasy-jaxrs`
    and `resteasy-crypto`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将项目导入Eclipse，在`pom.xml`文件中删除现有的默认依赖，并添加依赖于`resteasy-jaxrs`和`resteasy-crypto`的构件。
- en: 'The `dependencies` section should look like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies`部分应该如下所示：'
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s create the class `EncryptedService` inside the package `com.packtpub`.
    In this class, we will create a very simple operation, as shown:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`com.packtpub`包内创建`EncryptedService`类。在这个类中，我们将创建一个非常简单的操作，如下所示：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To register the services of our application, let''s create the class `EncryptedApplication`,
    as shown:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注册我们应用程序的服务，让我们创建`EncryptedApplication`类，如下所示：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing the functionality
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试功能
- en: 'After this, our application should be ready. So, let''s execute a test from
    SoapUI to watch the traffic using Wireshark, as shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们的应用程序应该准备就绪。所以，让我们从SoapUI执行一个测试，使用Wireshark观察流量，如下面的截图所示：
- en: '![Testing the functionality](img/0109OS_05_14.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_14.jpg)'
- en: 'Wireshark shows us the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark向我们展示了以下内容：
- en: '![Testing the functionality](img/0109OS_05_15.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_15.jpg)'
- en: As we can see, the traffic analyzer shows how all the information is traveling
    straight and how easily it is interpreted. Now, let's enable HTTPS on JBoss to
    show how the whole message is encrypted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，流量分析器显示了所有信息是如何直接传输的，以及它是如何轻松解释的。现在，让我们在JBoss上启用HTTPS，以展示整个消息是如何加密的。
- en: Enabling the server with HTTPS
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTTPS启用服务器
- en: 'So, first we have to create a certificate KeyStore. We can achieve this by
    executing the following command on the terminal:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，首先我们必须创建一个证书KeyStore。我们可以通过在终端上执行以下命令来实现这一点：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When it asks you for a password, you should use `changeit` as we have already
    used it in this book.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当它要求你输入密码时，你应该使用`changeit`，因为我们已经在本书中使用过它。
- en: 'Now, we look at the `JBOSS_HOME/standalone/configuration/standalone.xml` file,
    at the line containing `<connector name="http"`, and add the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们查看`JBOSS_HOME/standalone/configuration/standalone.xml`文件，找到包含`<connector
    name="http"`的行，并添加以下内容：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once you''ve made this change, we will restart the application server, deploy
    the application, and edit the request. This time, we''ll use port 8443 and the
    HTTPS protocol. So, the URL should look like the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进行了这些更改，我们将重新启动应用服务器，部署应用程序并编辑请求。这一次，我们将使用端口8443和HTTPS协议。因此，URL应该如下所示：
- en: '`https://localhost:8443/encryption-1.0/services/encrypted`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://localhost:8443/encryption-1.0/services/encrypted`'
- en: 'Let''s execute the request using SoapUI; our traffic analyzer will now show
    us the following result:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用SoapUI执行请求；我们的流量分析器现在将向我们显示以下结果：
- en: '![Enabling the server with HTTPS](img/0109OS_05_16.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用HTTPS启用服务器](img/0109OS_05_16.jpg)'
- en: As we expected, this time, the analyzer shows us very clearly that all the information
    has been encrypted.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的那样，这一次，分析器非常清楚地显示出所有信息都已加密。
- en: Moving forward with our example, we will now disable HTTPS in JBoss. For this,
    we have to remove the connector we added before. Now, we will use S/MIME in order
    to encrypt only the message body of the response. First, let's check some concepts
    that will help us understand how it works.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们现在将在JBoss中禁用HTTPS。为此，我们必须删除之前添加的连接器。现在，我们将使用S/MIME来仅加密响应的消息体。首先，让我们检查一些概念，这些概念将帮助我们理解它是如何工作的。
- en: 'S/MIME comes from Secure MIME. MIME stands for Multipurpose Internet Mail Extension,
    which helps us to not only send messages such as "Hello world", but also to send
    more interesting content such as videos, audio, and so on. MIME works with e-mail
    protocols such as SMTP and HTTP. This helps us to work with RESTful S/MIME web
    services. On the other hand, MIME offers us the following features:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: S/MIME来源于安全MIME。MIME代表多用途互联网邮件扩展，它不仅帮助我们发送诸如“Hello world”之类的消息，还可以发送更有趣的内容，如视频、音频等。MIME与SMTP和HTTP等电子邮件协议一起工作。这有助于我们处理RESTful
    S/MIME网络服务。另一方面，MIME为我们提供以下功能：
- en: Message encryption
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息加密
- en: Validating the identity of the user who sends the message
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证发送消息的用户的身份
- en: The capability to verify the information integrity of the message
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证消息的信息完整性的能力
- en: Given that S/MIME works with certifications, this is where the information of
    the message sender is saved. When the receiver gets the message, they observe
    all the public part of the message. The message can then be deciphered using a
    key. Also, the receiver can access its content. If you want to proceed further
    with S/MIME, we recommend you visit the link [http://datatracker.ietf.org/wg/smime/charter/](http://datatracker.ietf.org/wg/smime/charter/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于S/MIME与证书一起工作，这是保存消息发送者信息的地方。当接收者收到消息时，他们观察消息的所有公共部分。然后可以使用密钥解密消息，并访问其内容。如果您想进一步了解S/MIME，我们建议您访问链接[http://datatracker.ietf.org/wg/smime/charter/](http://datatracker.ietf.org/wg/smime/charter/)。
- en: Let's start by making some changes. First, we will create the source folder
    `src/main/resources` in the application; in this directory, we will place the
    resources necessary to encrypt the message.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先进行一些更改。首先，我们将在应用程序中创建源文件夹`src/main/resources`；在此目录中，我们将放置加密消息所需的资源。
- en: 'Then, we generate a certificate using `openssl`, go to the directory we just
    created from the console, and run the following at the command line on a terminal:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`openssl`生成证书，转到我们刚刚从控制台创建的目录，并在终端上的命令行中运行以下命令：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we have to enter the requested information as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须输入如下截图中显示的请求信息：
- en: '![Enabling the server with HTTPS](img/0109OS_05_17.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![使用HTTPS启用服务器](img/0109OS_05_17.jpg)'
- en: 'This will generate two files: `demokey.pem`, which is a private key, and `democert.pem`,
    which is a certificate we will use to encrypt the message body. To represent a
    signed response, RESTEasy uses the `EnvelopedOutput` object. In the following
    figure, we show you how RESTEasy encrypts messages:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个文件：`demokey.pem`是私钥，`democert.pem`是我们将用于加密消息体的证书。为了表示已签名的响应，RESTEasy使用`EnvelopedOutput`对象。在下图中，我们向您展示了RESTEasy如何加密消息：
- en: '![Enabling the server with HTTPS](img/0109OS_05_18.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![使用HTTPS启用服务器](img/0109OS_05_18.jpg)'
- en: 'Therefore, we must replace the return type of the method `gretting()` in the
    `EncryptedService` class. Let''s change the string to `EnvelopedOutput` and encrypt
    the message body using the certificate we generated before. Applying these changes,
    our method should look like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须替换`EncryptedService`类中`gretting()`方法的返回类型。让我们将字符串更改为`EnvelopedOutput`，并使用我们之前生成的证书加密消息体。应用这些更改后，我们的方法应该如下所示：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s make a change in the `pom.xml` file. We will modify the `dependencies`
    section in the following way:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`pom.xml`文件中进行一些更改。我们将以以下方式修改`dependencies`部分：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Notice how we changed the scope of the `resteasy-jaxrs` and `resteasy-jaxb-provider`
    artifacts; this is necessary to avoid duplicate classes when we encrypt the message.
    Since these artifacts are modules within the application server, you need to indicate
    that we want to load them. For this, we will modify the `pom.xml` file in the
    plugin section of `maven-war-plugin`, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何更改了`resteasy-jaxrs`和`resteasy-jaxb-provider`构件的范围；这是为了在加密消息时避免重复类。由于这些构件是应用服务器内的模块，因此需要指示我们要加载它们。为此，我们将修改`pom.xml`文件中`maven-war-plugin`插件部分，如下所示：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since JBoss Version 7 is a module-based application server, by default, only
    a few modules are activated when it starts. If you want to access other modules,
    it is necessary to indicate these dependencies explicitly. This can be done through
    the `MANIFEST.MF` file or by creating a file called `jboss-deployment-structure.xml`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JBoss版本7是基于模块的应用服务器，默认情况下在启动时只激活了少数模块。如果要访问其他模块，则需要明确指出这些依赖关系。这可以通过`MANIFEST.MF`文件或创建一个名为`jboss-deployment-structure.xml`的文件来完成。
- en: In this case, we will choose the first file by using `maven-war-`plugin to indicate
    the required dependencies.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用`maven-war-`插件选择第一个文件，以指示所需的依赖关系。
- en: Testing the functionality
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试功能
- en: Now, let's make the request again from SoapUI to the URL `http://localhost:8080/encryption-1.0/services/encrypted`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次从SoapUI向URL `http://localhost:8080/encryption-1.0/services/encrypted`
    发送请求。
- en: 'This time, the response we will get is shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将得到以下截图中显示的响应：
- en: '![Testing the functionality](img/0109OS_05_19.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_19.jpg)'
- en: 'The following is what we will see from the traffic analyzer:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从流量分析器中看到以下内容：
- en: '![Testing the functionality](img/0109OS_05_20.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_20.jpg)'
- en: 'As we can see, it shows us something very similar to the response from SoapUI.
    To decrypt the content, it is necessary that we have the private key and certificate.
    Through these two resources, we can obtain the object `EnvelopedInput` and get
    the message from it, as shown in the following figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，它向我们展示了与SoapUI响应非常相似的内容。要解密内容，需要我们拥有私钥和证书。通过这两个资源，我们可以获得`EnvelopedInput`对象，并从中获取消息，如下图所示：
- en: '![Testing the functionality](img/0109OS_05_21.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![测试功能](img/0109OS_05_21.jpg)'
- en: This will be demonstrated in the following code through a unit test. However,
    before going forward, we want to show that when encrypting messages with S/MIME,
    headers remain readable but the message body is fully encrypted. So, if we do
    not have the resources, the information is outdated and cannot be interpreted.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过单元测试中的以下代码进行演示。然而，在继续之前，我们想要展示，当使用S/MIME加密消息时，头部仍然可读，但消息正文完全加密。因此，如果我们没有资源，信息就会过时，无法被解释。
- en: Now, we will write a class that allows us to read the message body. For this,
    we will create a new source folder called `src/main/test`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个允许我们读取消息正文的类。为此，我们将创建一个名为`src/main/test`的新源文件夹。
- en: 'Within this folder, let''s create the class `com.packtpub.EncryptedServiceTest`
    with the following content:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，让我们创建名为`com.packtpub.EncryptedServiceTest`的类，内容如下：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how we need both the private key and the certificate to decrypt the message
    to obtain the entity formed from a string containing the message `Hello world`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要私钥和证书来解密消息，以获取包含消息`Hello world`的字符串形成的实体。
- en: When we run this unit test, we should get a green bar if all goes well. This
    indicates that to decrypt the message, using the previous resources (private key
    and certificate) has obtained the expected message.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个单元测试时，如果一切顺利，我们应该会得到一个绿色的条形图。这表明，使用之前的资源（私钥和证书）解密消息后，得到了预期的消息。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we worked with digital signatures and learned how to use them
    in RESTful web services. These days, digital signatures are often used because
    they guarantee message integrity, and information cannot be compromised while
    it is traveling from the sender to the receptor. We already know that information
    can be modified in transit, but when you're verifying the signed information,
    the receiver can notice it and take the actions that he/she believes are appropriate.
    For example, they can send another request to avoid working with corrupt information.
    At the end of this chapter, we worked with message body encryption, and we saw
    the difference between using these encryptions and HTTPS. Finally, we saw how
    the receiver, using the key, figured out the message body to make use of the information
    according to their needs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用数字签名，并学习了如何在RESTful web服务中使用它们。如今，数字签名经常被使用，因为它们保证了消息的完整性，信息在从发送者到接收者的传输过程中不会被
    compromise。我们已经知道信息在传输过程中可能会被修改，但当您验证签名的信息时，接收者可以注意到并采取他/她认为合适的行动。例如，他们可以发送另一个请求，以避免使用损坏的信息。在本章末尾，我们使用了消息正文加密，并看到了使用这些加密和HTTPS之间的区别。最后，我们看到了接收者如何使用密钥来解密消息正文，以根据他们的需求使用信息。
