- en: Chapter 6. Working with Tabular Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 处理表格数据
- en: 'Data that makes sense when displayed in a spreadsheet (or a tabular structure)
    is known as **tabular data**. In web applications, tabular data is commonly obtained
    from databases, where the data is natively represented in relational tables. The
    main JSF component for displaying tabular data is represented by the `<h:dataTable>`
    tag, which is capable of producing HTML classical tables. This chapter is a tribute
    to this tag, since tabular data is very commonly used and can be manipulated in
    many ways. Therefore, in this chapter, you will learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当以电子表格（或表格结构）显示时具有意义的**表格数据**。在Web应用程序中，表格数据通常从数据库中获取，其中数据以关系表的形式本地表示。用于显示表格数据的JSF主要组件由`<h:dataTable>`标签表示，该标签能够生成HTML经典表格。本章是对这个标签的致敬，因为表格数据非常常用，并且可以以多种方式操作。因此，在本章中，你将学习以下主题：
- en: Creating a simple JSF table
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单的JSF表格
- en: The `CollectionDataModel` class of JSF 2.2
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF 2.2的`CollectionDataModel`类
- en: Sorting tables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序表格
- en: Deleting a table row
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除表格行
- en: Editing/updating a table row
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑/更新表格行
- en: Adding a new row
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新行
- en: Displaying a row number
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示行号
- en: Selecting a single row
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择单行
- en: Selecting multiple rows
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择多行
- en: Nesting tables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套表格
- en: Paginating tables
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页表格
- en: Generating tables with the JSF API
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSF API生成表格
- en: Filtering tables
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤表格
- en: Styling tables
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格样式
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter focuses more on the tables that are populated with data that comes
    from collections (databases). But, you can include in and manipulate the content
    in the table with almost any JSF UI component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章更侧重于填充来自集合（数据库）数据的表格。但是，你可以使用几乎任何JSF UI组件在表格中包含和操作内容。
- en: Creating a simple JSF table
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建简单的JSF表格
- en: 'Most commonly, everything starts from a POJO class (or a EJB entity class),
    as shown in the following code—note that tables with hardcoded information were
    skipped:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是，一切从一个POJO类（或EJB实体类）开始，如下面的代码所示——请注意，跳过了包含硬编码信息的表格：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each instance of this POJO class is actually a row in the table displayed to
    the user (it''s not mandatory, but usually this is how things work). Next, a JSF
    bean (or CDI bean) will provide a collection of POJO''s instances. (The `List`,
    `Map`, and `Set` instances are the ones that are most commonly used.) In the following
    code, the `List` instance is shown:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个POJO类的每个实例实际上是用户显示的表格中的一行（这不是强制性的，但通常就是这样）。接下来，一个JSF bean（或CDI bean）将提供一个POJO实例的集合。（`List`、`Map`和`Set`实例是最常用的。）在下面的代码中，显示了`List`实例：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that, usually, data is queried from a database, but this is not quite relevant
    here.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通常数据是从数据库中查询的，但这里并不完全相关。
- en: 'This common scenario ends with a piece of code that displays the data on the
    screen. The code is shown as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个常见场景以一段显示屏幕上数据的代码结束。代码如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了输出：
- en: '![Creating a simple JSF table](img/6466EN_06_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![创建简单的JSF表格](img/6466EN_06_01.jpg)'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_1`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在本章的代码包中找到，命名为`ch6_1`。
- en: The CollectionDataModel class of JSF 2.2
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 2.2的CollectionDataModel类
- en: Until JSF 2.2, the supported types for the `<h:dataTable>` tag contains `java.util.List`,
    arrays, `java.sql.ResultSet`, `javax.servlet.jsp.jstl.sql.Result`, `javax.faces.model.DataModel`,
    null (or empty list), and types used as scalar values.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 直到JSF 2.2版本，`<h:dataTable>`标签支持的类型包括`java.util.List`、数组、`java.sql.ResultSet`、`javax.servlet.jsp.jstl.sql.Result`、`javax.faces.model.DataModel`、null（或空列表）以及用作标量值的类型。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with JSF 2.2, we can also use `java.util.Collection`. This is especially
    useful to Hibernate/JPA users, who are usually using the `Set` collections for
    entity relationships. Therefore, nothing can stop us from using a `HashSet`, `TreeSet`,
    or `LinkedHashSet` set for feeding our JSF tables.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF 2.2版本开始，我们也可以使用`java.util.Collection`。这对于Hibernate/JPA用户来说特别有用，因为他们通常使用`Set`集合来处理实体关系。因此，没有什么可以阻止我们使用`HashSet`、`TreeSet`或`LinkedHashSet`集合来为我们的JSF表格提供数据。
- en: 'The next example is like a test case for the most-used Java collections. First,
    let''s declare some collections of `Players` as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例类似于最常用Java集合的测试用例。首先，让我们声明一些`Players`集合，如下所示：
- en: '`java.util.ArrayList`: This library implements `java.util.Collection`. The
    `java.util.ArrayList` collection is declared as follows:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.ArrayList`：这个库实现了`java.util.Collection`。`java.util.ArrayList`集合的声明如下：'
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`java.util.LinkedList`: This library implements `java.util.Collection`. The
    `java.util.LinkedList` collection is declared as follows:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.LinkedList`：此库实现了 `java.util.Collection`。`java.util.LinkedList`
    集合声明如下：'
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`java.util.HashSet`: This library implements `java.util.Collection`. The `java.util.HashSet`
    collection is declared as follows:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.HashSet`：此库实现了 `java.util.Collection`。以下为 `java.util.HashSet` 集合的代码：'
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`java.util.TreeSet`: This library implements `java.util.Collection`. The `java.util.TreeSet`
    collection is declared as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.TreeSet`：此库实现了 `java.util.Collection`。`java.util.TreeSet` 集合声明如下：'
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the `TreeSet` collection, you have to use `Comparable` elements, or provide
    `Comparator`. Otherwise, the `TreeSet` collection can't do its job since it wouldn't
    know how to order the elements. This means that the `Players` class should implement
    `Comparable<Players>`.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 `TreeSet` 集合，你必须使用 `Comparable` 元素，或者提供 `Comparator`。否则，由于不知道如何排序元素，`TreeSet`
    集合将无法完成其工作。这意味着 `Players` 类应该实现 `Comparable<Players>`。
- en: '`java.util.LinkedHashSet`: This library implements `java.util.Collection`.
    The `java.util.LinkedHashSet` collection is declared as follows:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.LinkedHashSet`：此库实现了 `java.util.Collection`。`java.util.LinkedHashSet`
    集合声明如下：'
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`java.util.HashMap`: This library doesn''t implement `java.util.Collection`.
    The `java.util.HashMap` collection is declared as follows:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.HashMap`：此库没有实现 `java.util.Collection`。`java.util.HashMap` 集合声明如下：'
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`java.util.TreeMap`: This library doesn''t implement `java.util.Collection`.
    The `java.util.TreeMap` collection is declared as follows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.TreeMap`：此库没有实现 `java.util.Collection`。`java.util.TreeMap` 集合声明如下：'
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`java.util.LinkedHashMap`: This library doesn''t implement `java.util.Collection`.
    The `java.util.LinkedHashMap` collection is declared as follows:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.LinkedHashMap`：此库没有实现 `java.util.Collection`。以下为 `java.util.LinkedHashMap`
    集合的代码：'
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Supposing that these collections are populated and the getters are available;
    they are used to display their content in a table in the following ways:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这些集合已填充且获取器可用；它们将以以下方式在表中显示其内容：
- en: '`java.util.ArrayList`: This library implements `java.util.Collection`.. The
    following is the code of the `java.util.ArrayList` collection:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.ArrayList`：此库实现了 `java.util.Collection`。以下为 `java.util.ArrayList`
    集合的代码：'
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the same manner, we can display in a table the `LinkedList`, `HashSet`, `TreeSet`,
    and `LinkedHashSet` collection classes.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以同样的方式，我们可以在表中显示 `LinkedList`、`HashSet`、`TreeSet` 和 `LinkedHashSet` 集合类。
- en: '`java.util.LinkedList`: This library implements `java.util.Collection`. The
    following is the code of the `java.util.LinkedList` collection:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.LinkedList`：此库实现了 `java.util.Collection`。以下为 `java.util.LinkedList`
    集合的代码：'
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`java.util.HashSet`: This library implements `java.util.Collection`. The following
    is the code of the `java.util.HashSet` collection:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.HashSet`：此库实现了 `java.util.Collection`。以下为 `java.util.HashSet` 集合的代码：'
- en: '[PRE13]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`java.util.TreeSet`: This library implements `java.util.Collection`. The following
    is the code of the `java.util.TreeSet` collection:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.TreeSet`：此库实现了 `java.util.Collection`。以下为 `java.util.TreeSet` 集合的代码：'
- en: '[PRE14]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`java.util.LinkedHashSet`: This library implements `java.util.Collection`.
    The following is the code of the `java.util.LinkedHashSet` collection:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.LinkedHashSet`：此库实现了 `java.util.Collection`。以下为 `java.util.LinkedHashSet`
    集合的代码：'
- en: '[PRE15]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use the following examples to display a `Map` collection in a table. (`HashMap`,
    `TreeMap`, and `LinkedHashMap` are displayed in the same way.)
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下示例在表中显示一个 `Map` 集合。(`HashMap`, `TreeMap`, 和 `LinkedHashMap` 以相同的方式显示。)
- en: '`java.util.HashMap`: This library doesn''t implement `java.util.Collection`.
    The following is the code of the `java.util.HashMap` collection:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.HashMap`：此库没有实现 `java.util.Collection`。以下为 `java.util.HashMap` 集合的代码：'
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`java.util.TreeMap`: This library doesn''t implement `java.util.Collection`.
    The following is the code of the `java.util.TreeMap` collection:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.TreeMap`：此库没有实现 `java.util.Collection`。以下为 `java.util.TreeMap` 集合的代码：'
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`java.util.LinkedHashMap`: This library doesn''t implement `java.util.Collection`.
    The following is the code of the `java.util.LinkedHashMap` collection:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.LinkedHashMap`：此库没有实现 `java.util.Collection`。以下为 `java.util.LinkedHashMap`
    集合的代码：'
- en: '[PRE18]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For a `Map` collection, you can have a getter method, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Map` 集合，你可以有一个获取方法，如下所示：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, the code of the table will be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，表的代码将如下所示：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `CollectionDataModel` class is an extension of the `DataModel` class that
    wraps a `Collection` class of Java objects. Furthermore, in this chapter, you
    will see some examples that will alter this new class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionDataModel`类是`DataModel`类的扩展，它包装了一个Java对象的`Collection`类。此外，在本章中，你将看到一些示例，这些示例将改变这个新类。'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_2`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，命名为`ch6_2`。
- en: Sorting tables
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序表格
- en: 'In the previous examples, the data is arbitrarily displayed. Sorting the data
    provides more clarity and accuracy in reading and using the information; for example,
    see the screenshot of the *Creating a simple JSF table* section. You can try to
    visually localize the number 1 in the ATP ranking, and number 2 and number 3,
    and so on, but it is much more useful to have the option of sorting the table
    by the **Ranking** column. This is a pretty simple task to implement, especially
    if you are familiar with Java''s `List`, `Comparator`, and `Comparable` features.
    It is beyond the scope of this book to present these features, but you can accomplish
    most of the sorting tasks by overriding the `compare` method, which has a straightforward
    flow: it compares both of its arguments for order and returns a negative integer,
    zero, or a positive integer, as the first argument is less than, equal to, or
    greater than the second. For example, let''s see some common sortings:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，数据是任意显示的。对数据进行排序可以提供在读取和使用信息时的更多清晰度和准确性；例如，请参阅*创建简单的JSF表格*部分的截图。你可以尝试在ATP排名中视觉定位数字1，以及数字2和数字3等，但更有用的是有按**排名**列排序表格的选项。这是一个相对简单的实现任务，尤其是如果你熟悉Java的`List`、`Comparator`和`Comparable`功能。本书的范围不涉及这些功能，但你可以通过重写`compare`方法来完成大多数排序任务，该方法的流程简单明了：它比较两个参数的顺序，并返回一个负整数、零或正整数，表示第一个参数小于、等于或大于第二个参数。例如，让我们看看一些常见的排序：
- en: 'Sort the list of strings, such as player''s names. To do this sorting, the
    code of the `compare` method is as follows:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对字符串列表进行排序，例如球员的姓名。为此排序，`compare`方法的代码如下：
- en: '[PRE21]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Sort the list of numbers, such as the player''s rankings. To do this sorting,
    the code of the `compare` method is as follows:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数字列表进行排序，例如球员排名。为此排序，`compare`方法的代码如下：
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Sort the list of dates, such as player''s birthdays (this works as in the case
    of strings). To do this sorting, the code of the `compare` method is as follows:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对日期列表进行排序，例如球员的生日（这与字符串的情况相同）。为此排序，`compare`方法的代码如下：
- en: '[PRE23]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `data` argument stands for a `List` collection type because not all types
    of collections can take the place of this one. For example, `List` will work perfectly,
    while `HashSet` won't. There are different workarounds to sort collections that
    are not `List` collections. You have to ensure that you choose the right collection
    for your case.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`参数代表`List`集合类型，因为并非所有类型的集合都可以替代这个类型。例如，`List`将完美工作，而`HashSet`则不会。对于不是`List`集合的集合，有不同的解决方案来进行排序。你必须确保为你的情况选择正确的集合。'
- en: 'If you know how to write comparators for the selected collection, then everything
    else is simple. You can encapsulate the comparators in managed beans methods and
    attach buttons, links, or anything else that calls those methods. For example,
    you can add these comparators to the `PlayersBean` backing bean, as shown in the
    following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道如何为所选集合编写比较器，那么其他一切都很简单。你可以将这些比较器封装在托管Bean的方法中，并附加按钮、链接或其他调用这些方法的任何东西。例如，你可以将这些比较器添加到`PlayersBean`后端Bean中，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, you can easily modify the code of the `index.xhtml` page to provide access
    to the sorting feature as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以轻松修改`index.xhtml`页面的代码，以提供访问排序功能，如下所示：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在下述屏幕截图中：
- en: '![Sorting tables](img/6466EN_06_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![排序表格](img/6466EN_06_02.jpg)'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_3_1`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，命名为`ch6_3_1`。
- en: 'As you can see, each sorting provides two links: one for ascending and one
    for descending. We can easily glue these links in a switch-link, by using an extra
    property in our view scoped bean. For example, we can declare a property named
    `sortType`, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个排序都提供了两个链接：一个用于升序，一个用于降序。我们可以通过在我们的视图作用域Bean中使用一个额外的属性轻松地将这些链接粘合在一起。例如，我们可以声明一个名为`sortType`的属性，如下所示：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a simple condition to make it act as a switch between ascending and descending
    sort as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个简单的条件，使其在升序和降序排序之间切换，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, the `index.xhtml` page contains a single link per sort, as shown in the
    following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`index.xhtml`页面包含每个排序的单个链接，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of this trick can be seen in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧的输出可以在下面的屏幕截图中看到：
- en: '![Sorting tables](img/6466EN_06_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![排序表格](img/6466EN_06_03.jpg)'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_3_2`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，命名为`ch6_3_2`。
- en: Sorting and DataModel – CollectionDataModel
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序和数据模型 – 集合数据模型
- en: 'A more complex sorting example involves a decorator class that extends the
    `javax.faces.model.DataModel` class. JSF uses a `DataModel` class even if we are
    not aware of it, because each collection (`List`, array, `HashMap` and so on)
    is wrapped by JSF in a `DataModel` class (or, in a subclass, as `ArrayDataModel`,
    `CollectionDataModel`, `ListDataModel`, `ResultDataModel`, `ResultSetDataModel`,
    or `ScalarDataModel`). JSF will call the table `DataModel` class''s methods when
    it renders/decodes table data. In the following screenshot, you can see all directly
    known subclasses of the `DataModel` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的排序示例涉及一个扩展了`javax.faces.model.DataModel`类的装饰器类。即使我们没有意识到，JSF也会使用`DataModel`类，因为每个集合（`List`、数组、`HashMap`等等）都被JSF包装在一个`DataModel`类中（或者，在子类中，如`ArrayDataModel`、`CollectionDataModel`、`ListDataModel`、`ResultDataModel`、`ResultSetDataModel`或`ScalarDataModel`）。当JSF渲染/解码表格数据时，它会调用`DataModel`类的方法。在下面的屏幕截图中，你可以看到`DataModel`类的所有直接已知的子类：
- en: '![Sorting and DataModel – CollectionDataModel](img/6466EN_06_04.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![排序和数据模型 – 集合数据模型](img/6466EN_06_04.jpg)'
- en: As you will see in this chapter, sometimes you need to be aware of the `DataModel`
    class because you need to alter its default behavior. (It is recommended that
    you take a quick look at the official documentation of this class's section at
    [https://javaserverfaces.java.net/nonav/docs/2.2/javadocs/](https://javaserverfaces.java.net/nonav/docs/2.2/javadocs/)
    to obtain a better understanding.) The most common cases involve the rendering
    row numbers, sorting, and altering the row count of a table. When you do this,
    you will expose the `DataModel` class instead of the underlying collection.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本章中看到的，有时你需要了解`DataModel`类，因为你需要改变其默认行为。（建议你快速查看该类官方文档的[https://javaserverfaces.java.net/nonav/docs/2.2/javadocs/](https://javaserverfaces.java.net/nonav/docs/2.2/javadocs/)部分，以获得更好的理解。）最常见的情况涉及渲染行号、排序和改变表格的行数。当你这样做时，你会暴露`DataModel`类而不是底层的集合。
- en: For example, let's suppose that we need to use a collection, such as `HashSet`.
    This collection doesn't guarantee that the iteration order will remain constant
    over time, which can be a problem if we want to sort it. Of course, there are
    a few workarounds, such as converting it to `List` or using `TreeSet` instead,
    but we can alter the `DataModel` class that wraps the `HashSet` collection, which
    is the new JSF 2.2 class, `CollectionDataModel`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要使用一个集合，如`HashSet`。这个集合不保证迭代顺序在时间上保持不变，如果我们想对其进行排序，这可能会成为一个问题。当然，有一些解决方案，比如将其转换为`List`或使用`TreeSet`代替，但我们可以改变包装`HashSet`集合的`DataModel`类，这是新的JSF
    2.2类`CollectionDataModel`。
- en: 'We can accomplish this in a few steps, which are listed as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤实现这一点，如下所示：
- en: 'Extend the `CollectionDataModel` class for overriding the default behavior
    of its methods, as shown in the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展`CollectionDataModel`类以覆盖其方法的默认行为，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Provide a constructor and use it for passing the original model (in this case,
    `CollectionDataModel`). Besides the original model, we need an array of integers
    representing the indexes of rows (For example, `rows[0]=0`, `rows[1]=1`, ... `rows[n]=
    model.getRowCount()`). Sorting the row indexes will actually sort the `HashSet`
    collection, as shown in the following code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个构造函数并使用它来传递原始模型（在这种情况下，`CollectionDataModel`）。除了原始模型外，我们还需要一个表示行索引的整数数组（例如，`rows[0]=0`、`rows[1]=1`、...
    `rows[n]= model.getRowCount()`）。实际上，排序行索引将排序`HashSet`集合，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we need to override the `setRowIndex` method to replace the default row
    index, as shown in the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要覆盖`setRowIndex`方法来替换默认的行索引，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, provide a comparator as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，提供以下比较器：
- en: '[PRE32]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, our custom `CollectionDataModel` class with sorting capabilities is ready.
    We can test it by declaring and populating `HashSet`, wrapping it in the original
    `CollectionDataModel` class, and passing it to the custom `SortDataModel` class,
    as shown in the following code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的具有排序功能的自定义 `CollectionDataModel` 类已经准备好了。我们可以通过声明和填充 `HashSet`，将其包装在原始的
    `CollectionDataModel` 类中，并将其传递给自定义的 `SortDataModel` 类来测试它，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since we are the caller, we need to provide a comparator. The complete example
    is available in the code bundle of this chapter, and is named `ch6_3_3`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们是调用者，我们需要提供一个比较器。完整的示例可以在本章的代码包中找到，命名为 `ch6_3_3`。
- en: Deleting a table row
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除表格行
- en: 'Deleting a table row can be easily implemented by performing the following
    steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 删除表格行可以通过执行以下步骤轻松实现：
- en: Define a method in the managed bean that receives information about the row
    that should be deleted, and remove it from the collection that feeds the table.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在管理 Bean 中定义一个方法，该方法接收有关要删除的行的信息，并将其从为表格提供数据的集合中删除。
- en: 'For example, for a `Set` collection, the code will be as follows (`HashSet<Players>`):'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '例如，对于 `Set` 集合，代码将如下所示 (`HashSet<Players>`):'
- en: '[PRE34]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For `Map<String, Players>`, the code will be as follows:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 `Map<String, Players>`，代码将如下所示：
- en: '[PRE35]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Besides columns containing data, add a new column in the table named **Delete**.
    Each row can be a link to the `delete`*XXX* method.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了包含数据的列之外，在表格中添加一个名为 **删除** 的新列。每一行都可以是一个指向 `delete`*XXX* 方法的链接。
- en: 'For example, we can delete a value from `Set` (`HashSet<Players>`), as shown
    in the following code:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，我们可以从 `Set` (`HashSet<Players>`) 中删除一个值，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And from `Map<String, Players>`, as follows:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且从 `Map<String, Players>`，如下所示：
- en: '[PRE37]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the following screenshot, you can see a possible output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图，你可以看到一个可能的输出：
- en: '![Deleting a table row](img/6466EN_06_05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![删除表格行](img/6466EN_06_05.jpg)'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_4`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，命名为 `ch6_4`。
- en: Editing/updating a table row
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑/更新表格行
- en: 'One of the most convenient approaches for editing/updating a table row consists
    of using a special property to track the row edit status. This property can be
    named `edited` and it should be of the type `boolean` (default `false`). Define
    it in the POJO class, as shown in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑/更新表格行最方便的方法之一是使用一个特殊属性来跟踪行编辑状态。这个属性可以命名为 `edited`，它应该是 `boolean` 类型（默认 `false`）。在
    POJO 类中定义它，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your POJO class is an entity class, then define this new property as transient,
    using the `@Transient` annotation or transient modifier. This annotation will
    tell JPA that this property doesn't participate in persistence and that its values
    are never stored in the database.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 POJO 类是一个实体类，那么使用 `@Transient` 注解或 `transient` 修饰符将这个新属性定义为 `transient`。这个注解将告诉
    JPA 这个属性不参与持久化，并且其值永远不会存储在数据库中。
- en: 'Next, assign an **Edit** link to each row. Using the `rendered` attribute,
    you can easily show/hide the link using a simple EL condition; initially, the
    link is visible for each row. For example, take a look at the following use cases:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将一个 **编辑** 链接分配给每一行。使用 `rendered` 属性，你可以通过简单的 EL 条件轻松显示/隐藏链接；最初，链接对每一行都是可见的。例如，看看以下用例：
- en: 'For a `Set` collection, the code is as follows:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Set` 集合，代码如下：
- en: '[PRE39]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For a `Map` collection, the code is as follows:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Map` 集合，代码如下：
- en: '[PRE40]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When the link is clicked, the `edited` property will be switched from `false`
    to `true` and the table will be re-rendered as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当链接被点击时，`edited` 属性将从 `false` 切换到 `true`，表格将按如下方式重新渲染：
- en: 'For a `Set` collection, the code of the `editRowHashSet` method is as follows:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Set` 集合，`editRowHashSet` 方法的代码如下：
- en: '[PRE41]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For a `Map` collection, the code of the `editRowHashSet` method is as follows:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Map` 集合，`editRowHashSet` 方法的代码如下：
- en: '[PRE42]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This means that the link is not rendered anymore and the user should be able
    to edit that table row. You need to switch between the `<h:outputText>` tag, used
    to display data (visible when the `edited` property is `false`), and the `<h:inputText>`
    tag, which is used to collect data (visible when the `edited` property is `true`).
    Using the `rendered` attribute again will do the trick, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着链接不再渲染，用户应该能够编辑该表格行。你需要使用 `rendered` 属性在 `<h:outputText>` 标签（用于显示数据，当 `edited`
    属性为 `false` 时可见）和 `<h:inputText>` 标签（用于收集数据，当 `edited` 属性为 `true` 时可见）之间切换。再次使用
    `rendered` 属性将起到作用，如下所示：
- en: 'For a `Set` collection, the code is modified as follows:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Set` 集合，代码修改如下：
- en: '[PRE43]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For a `Map` collection, the code is modified as follows:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Map`集合，代码修改如下：
- en: '[PRE44]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, you need a button to save changes; this button will set the `edited`
    property back to `false`, preparing the table for more edits, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要一个按钮来保存更改；此按钮将`edited`属性重置为`false`，为更多编辑准备表格，如下所示：
- en: 'For a `Set` collection, the code for the button is as follows:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Set`集合，按钮的代码如下：
- en: '[PRE45]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For a `Map` collection, the code for the button is as follows:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Map`集合，按钮的代码如下：
- en: '[PRE46]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is a straightforward action, as you can see in the following points—values
    inserted in the input textbox are automatically saved in the collection:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个直接的动作，如以下要点所示——输入文本框中插入的值会自动保存到集合中：
- en: 'For a `Set` collection, the code is as follows:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Set`集合，代码如下：
- en: '[PRE47]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For a `Map` collection, the code is as follows:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Map`集合，代码如下：
- en: '[PRE48]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Done! In the following screenshot, you can see a possible output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！在以下截图中，您可以看到可能的输出：
- en: '![Editing/updating a table row](img/6466EN_06_06.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![编辑/更新表格行](img/6466EN_06_06.jpg)'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_5`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，命名为`ch6_5`。
- en: Adding a new row
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新行
- en: 'Adding a new row is also a simple task. First, you need to provide a form that
    reflects a table row content, as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新行也是一个简单的任务。首先，你需要提供一个表行内容的表单，如下面的截图所示：
- en: '![Adding a new row](img/6466EN_06_07.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![添加新行](img/6466EN_06_07.jpg)'
- en: 'This form can be easily implemented using the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码轻松实现此表单：
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The button labeled **Add Player** will call a managed bean method that creates
    a new `Players` instance and adds it in the collection that feeds the table, as
    shown in the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 标有**添加玩家**的按钮将调用一个托管Bean方法，创建一个新的`Players`实例并将其添加到为表格提供数据的集合中，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the following screenshot, you can see the newly added row from the data
    shown in the preceding screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，您可以看到从前面截图中的数据中添加的新行：
- en: '![Adding a new row](img/6466EN_06_08.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![添加新行](img/6466EN_06_08.jpg)'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_6_1`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，命名为`ch6_6_1`。
- en: 'A more elegant approach is to add a row directly in the table and eliminate
    this user form. This can be easily accomplished by following these simple steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更优雅的方法是直接在表格中添加行并消除此用户表单。可以通过以下简单步骤轻松实现：
- en: 'Use linked collections (for example, use `LinkedHashSet` instead of `HashSet`
    or `LinkedHashMap` instead of `HashMap`). A table is populated by iterating the
    corresponding collection, but some collections, such as `HashSet` or `HashMap`,
    do not provide an iteration order, which means that the iteration order is unpredictable.
    This is important because we want to add a row at the end of the table, but this
    is hard to achieve with an unpredictable iteration order. But a linked collection
    would fix this issue, which is shown in the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用链接集合（例如，使用`LinkedHashSet`代替`HashSet`或`LinkedHashMap`代替`HashMap`）。表格通过迭代相应的集合来填充，但某些集合，如`HashSet`或`HashMap`，不提供迭代顺序，这意味着迭代顺序是不可预测的。这很重要，因为我们想在表格末尾添加一行，但使用不可预测的迭代顺序很难实现。但是，链接集合可以解决这个问题，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add a new row by creating a new item in the corresponding collection and activate
    the editable mode using the `Set` and `Map` collections as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在相应的集合中创建新项并使用`Set`和`Map`集合激活可编辑模式来添加新行：
- en: 'The following is the code for a linked `Set` collection:'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个链接`Set`集合的代码：
- en: '[PRE52]'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following is the code for a linked `Map` collection:'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个链接`Map`集合的代码：
- en: '[PRE53]'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Check out the following screenshot for a possible output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图以查看可能的输出：
- en: '![Adding a new row](img/6466EN_06_09.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![添加新行](img/6466EN_06_09.jpg)'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_6_2`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，命名为`ch6_6_2`。
- en: Displaying row numbers
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示行号
- en: 'By default, JSF doesn''t provide a method for displaying row numbers. But as
    you can see in the screenshot depicting the output in the *Editing/updating a
    table row* section, there is a column named **No** that displays row numbers.
    You can obtain this column in at least two ways. The simplest workaround consists
    of binding the table to the current view, as shown in the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JSF不提供显示行号的方法。但正如你在*编辑/更新表行*部分的输出截图中所见，有一个名为**No**的列显示行号。你可以通过至少两种方式获得此列。最简单的解决方案是将表绑定到当前视图，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Another approach is to obtain it using the `DataModel` class, which has the
    `getRowIndex` method to return the currently selected row number. In order to
    do that, you need to wrap the collection in a `DataModel` class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`DataModel`类来获取它，该类具有`getRowIndex`方法来返回当前选中的行号。为了做到这一点，你需要将集合包装在`DataModel`类中。
- en: The example named `ch6_7` contains the first approach of this task.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为`ch6_7`的示例包含了这个任务的第一个方法。
- en: Selecting a single row
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择单行
- en: 'The easiest implementation of such a task is to provide a button for each row
    in the table. When a button is clicked, it can pass the selected row, as shown
    in the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此类任务的最简单方法是为表中的每一行提供一个按钮。当按钮被点击时，它可以传递所选行，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since the `showSelectedPlayer` method receives the selected row, it can process
    it further with no other requirements. The complete example is available in the
    code bundle of this chapter, and is named `ch6_8_1`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`showSelectedPlayer`方法接收所选行，它可以进一步处理它，没有其他要求。完整的示例可在本章的代码包中找到，命名为`ch6_8_1`。
- en: 'Generally speaking, selecting one item from a bunch of items is a job for a
    group of radio buttons. In a JSF table, items are rows, and adding a radio button
    per row will result in a column as shown in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，从一堆项目中选择一个项目是单选按钮组的工作。在JSF表中，项目是行，为每一行添加一个单选按钮将导致如下截图所示的列：
- en: '![Selecting a single row](img/6466EN_06_10.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![选择单行](img/6466EN_06_10.jpg)'
- en: 'However, adding radio buttons in the `<h:column>` tag using the `<h:selectOneRadio>`
    tag doesn''t behave as expected. The main functionality of radio buttons doesn''t
    work; selecting one radio will not deselect the rest of radios in the group. It
    is now acting more like a group of checkboxes. You can fix this issue by implementing
    a deselection mechanism through JavaScript. Moreover, at this point, you can set
    a JSF hidden field with the value of the selected row. For example, if the table
    is populated by `Map`, you use the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`<h:column>`标签中使用`<h:selectOneRadio>`标签添加单选按钮并不像预期的那样表现。单选按钮的主要功能不起作用；选择一个单选按钮不会取消选择组中的其他单选按钮。现在它更像是一组复选框。你可以通过实现一个取消选择机制来修复这个问题，通过JavaScript。此外，在这个阶段，你可以设置一个JSF隐藏字段，其值为所选行的值。例如，如果表是通过`Map`填充的，你将使用以下代码：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'First, you need to find the form containing the radios by the ID. Afterwards,
    iterate through the form''s children, and identify each radio by a fixed part
    of its ID. Check only the radio that was selected by the user, and uncheck the
    rest of them. Next, populate a hidden field with the value of the selected row.
    The ID of the selected radio and the row value are provided as arguments, as follows
    (in this case, the table is populated from `Map`):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要通过ID找到包含单选按钮的表单。然后，遍历表单的子元素，并通过其ID的固定部分识别每个单选按钮。只检查用户选择的单选按钮，并取消选择其余的单选按钮。接下来，使用所选行的值填充一个隐藏字段。所选单选按钮的ID和行值作为参数提供，如下（在这种情况下，表是从`Map`中填充的）：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Besides the hidden field for storing the selected row information, you need
    a button labeled **Show Hash Map Selection**, as shown in the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于存储所选行信息的隐藏字段外，你还需要一个标签为**显示哈希映射选择**的按钮，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following `showSelectedPlayer` method is ready to process the selected
    row:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`showSelectedPlayer`方法已准备好处理所选行：
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Done! The complete example is available in the code bundle of this chapter and
    is named `ch6_8_2`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的示例可在本章的代码包中找到，命名为`ch6_8_2`。
- en: If you feel that using a hidden field is not a very elegant approach, then you
    can replace its role by using the `valueChangeListener` attribute of the `<h:selectOneRadio>`
    tag.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为使用隐藏字段不是一个非常优雅的方法，那么你可以通过使用`<h:selectOneRadio>`标签的`valueChangeListener`属性来替换其角色。
- en: In the code bundle of this chapter, you can find an example that uses the `valueChangeListener`
    attribute named `ch6_8_3`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的代码包中，你可以找到一个使用名为`ch6_8_3`的`valueChangeListener`属性的示例。
- en: Selecting multiple rows
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择多行
- en: 'Multiple selection is commonly achieved using groups of checkboxes. One of
    the most convenient approaches for multiple selections consists of using a special
    property for tracking the row selection status. This property can be named `selected`
    and it should be of type `boolean` (default `false`). You can define it in the
    POJO class as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 多选通常通过复选框组来实现。实现多选的最方便方法之一是使用一个特殊属性来跟踪行选择状态。这个属性可以命名为`selected`，它应该是`boolean`类型（默认`false`）。你可以在POJO类中如下定义它：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your POJO class is an entity class, then define this new property as transient,
    using the `@Transient` annotation or transient modifier. This annotation will
    tell JPA that this property doesn't participate in persistence and his values
    are never stored in the database.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的POJO类是一个实体类，那么请将这个新属性定义为transient，使用`@Transient`注解或transient修饰符。这个注解将告诉JPA这个属性不参与持久化，其值永远不会存储在数据库中。
- en: 'Next, assign a checkbox to each row (`<h:selectBooleanCheckbox>`). Using the
    `value` attribute and the `selected` property, you can easily track the selection
    status, as shown in the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为每一行分配一个复选框（`<h:selectBooleanCheckbox>`）。使用`value`属性和`selected`属性，你可以轻松跟踪选择状态，如下所示：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'So the `<h:selectBooleanCheckbox>` tag will do the hard work for us (we just
    exploit its natural behavior), therefore, all you need is a button labeled **Show
    Selected Players**, as shown in the following line:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`<h:selectBooleanCheckbox>`标签将为我们完成艰苦的工作（我们只是利用其自然行为），因此，你所需要的只是一个标记为**显示选中玩家**的按钮，如下所示：
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `showSelectedPlayers` method has an easy task. It can iterate the collection
    and check the status of the `selected` property for each item; this is a good
    chance to reset the selected items as well. For example, you can extract the selected
    items in a separate list, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`showSelectedPlayers`方法有一个简单的任务。它可以遍历集合并检查每个项目的`selected`属性状态；这是一个重置选中项的好机会。例如，你可以将选中的项提取到一个单独的列表中，如下所示：'
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_8_4`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例包含在本章的代码包中，命名为`ch6_8_4`。
- en: If you don't want to use an extra property, such as `selected`, you can use
    a `Map <String, Boolean>` map. The code is pretty straightforward; therefore,
    a quick look over the complete code, `ch6_8_5`, will clarify things instantly.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用额外的属性，如`selected`，你可以使用一个`Map <String, Boolean>`映射。代码相当简单；因此，快速查看完整的代码`ch6_8_5`将立即阐明问题。
- en: Nesting tables
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套表格
- en: 'It''s most likely that you won''t need to display a table inside another table,
    but there are cases when this workaround can be useful in obtaining a clear presentation
    of the data. For example, nested collections can be presented as nested tables
    as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你不需要在表格内部显示另一个表格，但有时这个解决方案在获得清晰的数据展示方面很有用。例如，嵌套集合可以表示为嵌套表格，如下所示：
- en: '[PRE64]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, players are stored in `HashMap` as keys, and each player has a collection
    (`HashSet`) of trophies. Each `HashSet` value is a value in `HashMap`. Therefore,
    you need to display the table of players; however, you need to display each player''s
    trophies. This can be achieved as shown in the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，玩家以`HashMap`作为键存储，每个玩家都有一个奖杯集合（`HashSet`）。每个`HashSet`值是`HashMap`中的一个值。因此，你需要显示玩家的表格；然而，你还需要显示每个玩家的奖杯。这可以通过以下代码实现：
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A possible output for the preceding code can be seen in the following screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的可能输出可以在以下屏幕截图中看到：
- en: '![Nesting tables](img/6466EN_06_11.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![嵌套表格](img/6466EN_06_11.jpg)'
- en: The complete application is named `ch6_9`, and is available in the code bundle
    of this chapter.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为`ch6_9`，并包含在本章的代码包中。
- en: Paginating tables
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页表格
- en: When you need to display large tables (with many rows), it can be useful to
    implement a pagination mechanism. There are many advantages, such as its fancy
    look, the clear presentation of data, saving space in web pages, and lazy loading.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要显示大型表格（包含许多行）时，实现分页机制可能很有用。它有许多优点，例如外观精美、数据展示清晰、节省网页空间和延迟加载。
- en: In a standard version of such a table, we should be able to navigate to the
    first page, last page, next page, previous page, and in some tables, to select
    the number of rows displayed on one page.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类表格的标准版本中，我们应该能够导航到第一页、最后一页、下一页、上一页，在某些表格中，还可以选择每页显示的行数。
- en: 'When you bind a table to its backing bean, you have access to three handy properties,
    which are listed as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将表格绑定到其后端Bean时，您可以访问三个方便的属性，如下所示：
- en: '`first`: This property represents the first row number that is displayed in
    the current table page (it starts from the default value `0`). The value for this
    property can be specified using the `first` attribute of the `<h:dataTable>` tag.
    In the JSF API, this is accessible through the `HtmlDataTable.getFirst` and `HtmlDataTable.setFirst`
    methods.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`：此属性表示当前表格页面中显示的第一行行号（它从默认值`0`开始）。此属性的值可以使用`<h:dataTable>`标签的`first`属性指定。在JSF
    API中，可以通过`HtmlDataTable.getFirst`和`HtmlDataTable.setFirst`方法访问。'
- en: '`rows`: This property represents the number of rows displayed in a single page,
    starting from `first`. The value for this property can be specified using the
    `rows` attribute of the `<h:dataTable>` tag. In the JSF API, this is accessible
    through the `HtmlDataTable.getRows` and `HtmlDataTable.setRows` methods.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rows`：此属性表示从`first`开始显示的单页中的行数。此属性的值可以使用`<h:dataTable>`标签的`rows`属性指定。在JSF
    API中，可以通过`HtmlDataTable.getRows`和`HtmlDataTable.setRows`方法访问。'
- en: '`rowCount`: This property represents the total number of rows, from all pages,
    starting from row 0\. There is no attribute for this property. In the JSF API,
    this is accessible through the `HtmlDataTable.getRowCount` method. Setting the
    row count can be accomplished through the data model, as you will see later. By
    default, is determined by JSF.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rowCount`：此属性表示从所有页面中开始于行0的总行数。此属性没有对应的属性。在JSF API中，可以通过`HtmlDataTable.getRowCount`方法访问。可以通过数据模型设置行数，如后文所示。默认值由JSF确定。'
- en: 'In the following screenshot, these properties can be seen in detail:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，可以详细看到这些属性：
- en: '![Paginating tables](img/6466EN_06_12.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![分页表格](img/6466EN_06_12.jpg)'
- en: 'The preceding information is very useful for to implementing the pagination
    mechanism. First, we bind the table, and set the first row number and the number
    of rows per page, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的信息对于实现分页机制非常有用。首先，我们绑定表格，并设置第一行行号和每页行数，如下所示：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Based on some arithmetic and EL condition''s support, we can conclude the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 基于一些算术和EL条件支持，我们可以得出以下结论：
- en: 'The first row number, the row number per page, and the total row count are
    accessible via the following code:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行行号、每页行数和总行数可以通过以下代码访问：
- en: '[PRE67]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Navigate to the first page by using the following code:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码导航到第一页：
- en: '[PRE68]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A button that accomplishes this navigation can be disabled by an EL condition,
    as shown in the following code:'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过EL条件禁用实现此导航的按钮，如下所示：
- en: '[PRE69]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Navigate to the next page by using the following code:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码导航到下一页：
- en: '[PRE70]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A button that accomplishes this navigation can be disabled by an EL condition,
    as shown in the following code:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过EL条件禁用实现此导航的按钮，如下所示：
- en: '[PRE71]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Navigate to the previous page by using the following code:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码导航到上一页：
- en: '[PRE72]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A button that accomplishes this navigation can be disabled by an EL condition,
    as shown in the following code:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过EL条件禁用实现此导航的按钮，如下所示：
- en: '[PRE73]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Navigate to the last page by using the following code:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码导航到最后页：
- en: '[PRE74]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'A button that accomplishes this navigation can be disabled by an EL condition,
    as shown in the following code:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过EL条件禁用实现此导航的按钮，如下所示：
- en: '[PRE75]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Display the **current page** of the **total pages** message by using the following
    code:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码显示**当前页**和**总页数**的信息：
- en: '[PRE76]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Merging all these chunks of code in a sample application (see the application
    `ch6_10_1`), will result in something like the following screenshot:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例应用程序（见应用程序`ch6_10_1`）中将所有这些代码块合并，将得到如下截图：
- en: '![Paginating tables](img/6466EN_06_13.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![分页表格](img/6466EN_06_13.jpg)'
- en: The biggest issue here is that even if the data is displayed in pages, they
    are still loaded in the memory as a bulk. In this case, pagination is just a *slicer*
    of the collection, which has only visual effect. In reality, the pagination is
    the effect of **lazy loading**, which represents a technique for querying only
    a portion of data from a database (instead of slicing the data in memory, you
    slice it from the database directly). There are many kinds of querying in a database,
    but in Java web/enterprise applications, EJB/JPA is the most used. EJB and JPA
    are large technologies that can't be covered here, but with some assumptions it
    will be very easy to understand the upcoming example.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的问题是，即使数据以分页的形式显示，它们仍然以批量形式加载到内存中。在这种情况下，分页只是集合的*切片*，它只有视觉效果。实际上，分页是**延迟加载**的效果，它代表了一种从数据库中查询部分数据的技术（而不是在内存中切片数据，直接从数据库中切片）。数据库中有许多种查询方式，但在Java
    Web/企业应用程序中，EJB/JPA是最常用的。EJB和JPA是大型技术，这里不能全部涵盖，但通过一些假设，理解即将到来的示例将会非常容易。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you feel that EJB/JPA are not good choices, you should can take into account
    the fact that the `<h:dataTable>` tag also supports `java.sql.ResultSet`, `javax.servlet.jsp.jstl.Result`,
    and `javax.sql.CachedRowSet`. So, for tests, you can use plain JDBC as well.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为EJB/JPA不是好的选择，你应该考虑这样一个事实，即`<h:dataTable>`标签也支持`java.sql.ResultSet`、`javax.servlet.jsp.jstl.Result`和`javax.sql.CachedRowSet`。因此，对于测试，你也可以使用普通的JDBC。
- en: 'Instead of the `Players` POJO class, this time you will use a `Players` JPA
    entity that is bounded to a table named `PLAYERS`. This table contains the data
    that should be displayed in the JSF table and it was created in Apache Derby RDBMS,
    in the `APP` database (if you have NetBeans 8.0 with GlassFish 4.0, then this
    RDBMS and the `APP` database are out of the box). The idea is to query this table
    to obtain only the rows from `first` to `first` + `rows`, which is exactly the
    amount of rows displayed per page. This can be easily accomplished by JPA using
    the `setFirstResult` and `setMaxResults` methods of a query (the `loadPlayersAction`
    method was defined in a EJB component, named `PlayersSessionBean`), as shown in
    the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，你将使用一个与名为`PLAYERS`的表绑定的`Players` JPA实体，而不是`Players` POJO类。这个表包含应在JSF表格中显示的数据，它是在Apache
    Derby RDBMS的`APP`数据库中创建的（如果你有NetBeans 8.0和GlassFish 4.0，那么这个RDBMS和`APP`数据库是开箱即用的）。想法是查询这个表以获取从`first`到`first`
    + `rows`的行，这正好是每页显示的行数。这可以通过JPA使用查询的`setFirstResult`和`setMaxResults`方法轻松实现（`loadPlayersAction`方法定义在一个名为`PlayersSessionBean`的EJB组件中），如下面的代码所示：
- en: '[PRE77]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: So, passing the right `first` and `max` arguments will return the needed rows!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，传递正确的`first`和`max`参数将返回所需的行！
- en: 'But pagination works if we know the total number of rows, since without this
    we can''t calculate the number of pages, or the last page, and so on. In JPA,
    we can do this easily (the `countPlayersAction` method was defined in a EJB component,
    named `PlayersSessionBean`) by using the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们知道总行数，分页就会工作，因为没有这个信息，我们无法计算页数，或者最后一页，等等。在JPA中，我们可以通过以下代码轻松实现（`countPlayersAction`方法定义在一个名为`PlayersSessionBean`的EJB组件中）：
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Knowing the total number of rows (without actually extracting the data from
    the database) is great, but we need to tell JSF that number! Since `HtmlDataTable`
    doesn''t provide a `setRowCount` method, we have to take another approach into
    account. One solution is to extend the `DataModel` class (or one of its subclasses)
    and provide the row count explicitly; since we are using `HashSet`, we can extend
    the `CollectionDataModel` class of JSF 2.2 as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 知道总行数（实际上并没有从数据库中提取数据）是很好的，但我们需要告诉JSF那个数字！由于`HtmlDataTable`没有提供`setRowCount`方法，我们必须考虑另一种方法。一个解决方案是扩展`DataModel`类（或其子类之一）并显式提供行数；由于我们使用`HashSet`，我们可以扩展JSF
    2.2的`CollectionDataModel`类，如下所示：
- en: '[PRE79]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'So, creating a `PlayersDataModel` class can be accomplished in the following
    manner:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个`PlayersDataModel`类可以通过以下方式完成：
- en: '[PRE80]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, each time a page navigation is detected in the table, we just need
    to call the following method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每次在表格中检测到页面导航时，我们只需要调用以下方法：
- en: '[PRE81]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch6_10_2`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，名称为`ch6_10_2`。
- en: Generating tables with the JSF API
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSF API生成表格
- en: 'JSF tables can be programmatically generated as well. The JSF API provides
    comprehensive support to accomplish such tasks. First, you *prepare* the place
    where the generated table will be added, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 表格也可以程序化生成。JSF API 提供了全面的支持来完成此类任务。首先，你需要*准备*生成表格的位置，如下所示：
- en: '[PRE82]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The idea is simple: when the button labeled **Add Table** is clicked, the generated
    table should be attached in the `<h:panelGrid>` tag identified by the `myTable`
    ID.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说：当点击标有**添加表格**的按钮时，生成的表格应该附加到 ID 为`myTable`的`<h:panelGrid>`标签中。
- en: 'Before creating a JSF table in a programmatic fashion, you need to know how
    to create a table, a header/footer, a column, and so on. Let''s have a short overview
    as follows—the code is self-explanatory and straightforward, since JSF provides
    very intuitive methods:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序化创建 JSF 表格之前，你需要知道如何创建表格、标题/页脚、列等。以下是一个简要概述——代码是自我解释的，因为 JSF 提供了非常直观的方法：
- en: 'Let''s create the simplest table, `<h:dataTable value="..." var="t" border="1">`
    using the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建最简单的表格`<h:dataTable value="..." var="t" border="1">`，如下面的代码所示：
- en: '[PRE83]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, we will create a column with a header, a footer, and a possible converter,
    as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个带有标题、页脚和可能的转换器的列，如下所示：
- en: '[PRE84]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, attach the table in DOM (in order to do that, you need to find the desired
    parent component) using the following code:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码将表格附加到 DOM 中（为了做到这一点，你需要找到所需的父组件）：
- en: '[PRE85]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `findComponent` method uses the JSF `visit` method, which is very useful
    for traversing a tree of components, which is shown in the following code:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`findComponent`方法使用 JSF 的`visit`方法，这对于遍历组件树非常有用，如下面的代码所示：'
- en: '[PRE86]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Mojarra, the `FullVisitContext` method comes from the `com.sun.faces.component.visit`
    package. In MyFaces, this class comes from the `org.apache.myfaces.test.mock.visit`
    package. Both the implementations extend `javax.faces.component.visit.VisitContext`.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Mojarra 中，`FullVisitContext`方法来自`com.sun.faces.component.visit`包。在 MyFaces
    中，这个类来自`org.apache.myfaces.test.mock.visit`包。这两个实现都扩展了`javax.faces.component.visit.VisitContext`。
- en: 'The necessary expressions are then added as shown in the following code (you
    saw another example of this in [Chapter 2](ch02.html "Chapter 2. Communication
    in JSF"), *Communication in JSF*):'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加必要的表达式，如下面的代码所示（你曾在[第 2 章](ch02.html "第 2 章。JSF 中的通信")中看到另一个例子，*JSF 中的通信*）：
- en: '[PRE87]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Finally, merge these methods in a helper class, `TableHelper`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将这些方法合并到一个辅助类`TableHelper`中。
- en: 'Remember the button labeled **Add Table**? Well, when that button is clicked,
    the `addTable` method is called. This method exploits the `TableHelper` class
    for programmatically creating a table, as shown in the following code:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得那个标有**添加表格**的按钮吗？当点击该按钮时，会调用`addTable`方法。此方法利用`TableHelper`类来程序化创建表格，如下面的代码所示：
- en: '[PRE88]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Done! The complete application is available in the code bundle of this chapter,
    and is named `ch6_11`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的应用程序可在本章的代码包中找到，命名为`ch6_11`。
- en: A programmatically generated table would be an apt approach for generating tables
    with variable number of columns, or dynamic columns. Let's suppose that we have
    two JPA entities, `Players` and `Trophies`. The first entity should produce a
    table with nine columns, while `Trophies` should produce a table with three columns.
    Moreover, the column names (headers) differ. It may sound complicated, but actually
    is more simple than you would have expected.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化生成的表格非常适合生成具有可变列数或动态列的表格。假设我们有两个 JPA 实体，`Players`和`Trophies`。第一个实体应该生成一个包含九列的表格，而`Trophies`应该生成一个包含三列的表格。此外，列名（标题）不同。这听起来可能很复杂，但实际上比你想象的要简单。
- en: 'Think that each table is mapped by a JPA entity, which means that we can write
    specific queries by indicating the entity name. Moreover, each entity can be passed
    through Java''s reflection mechanism to extract the field''s names (we are focusing
    on the `private` fields), which gave us the column headers. (If you alter the
    column names using `@Column(name="alias_name")`, then the process will be a little
    tricky to reflect the alias names.) So, we can use the following code (the package
    name is fixed):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，每个表格都由一个 JPA 实体映射，这意味着我们可以通过指定实体名称来编写特定的查询。此外，每个实体都可以通过 Java 的反射机制来提取字段名称（我们专注于`private`字段），这为我们提供了列标题。（如果你使用`@Column(name="alias_name")`来更改列名，那么这个过程将稍微复杂一些，需要反射别名。）因此，我们可以使用以下代码（包名是固定的）：
- en: '[PRE89]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: So, as long as we pass the table name (entity name) to this method, it will
    return the corresponding data. For the complete example, check the application
    named `ch6_12` in the code bundle of this chapter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只要我们将表名（实体名）传递给此方法，它就会返回相应的数据。对于完整的示例，请查看本章代码包中名为`ch6_12`的应用程序。
- en: Filtering tables
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤表格
- en: Filtering data is a very useful facility in a table. It allows the user to *see*
    only the set of data that matches a certain set of rules (criteria); most commonly,
    filter by column(s). For example, the user may need to see all players younger
    than 26 years, which is a filter applied in the column labeled **Age**.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格中，过滤数据是一个非常实用的功能。它允许用户只看到符合一定规则（标准）的数据集；最常见的是按列（多列）过滤。例如，用户可能需要查看所有26岁以下的所有球员，这是在标记为**年龄**的列中应用的过滤。
- en: Basically, a filter can have only visual effect, without modifying the filtered
    data (using some CSS, JS code, or duplicating the filter results in a separate
    collection and displaying that collection), or by removing the unnecessary items
    for the initial collection (which requires restoring its content when the filter
    is removed).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，过滤器可以只有视觉效果，而不会修改过滤后的数据（使用一些CSS、JS代码，或在单独的集合中复制过滤结果并显示该集合），或者通过移除初始集合中的不必要的项目（当过滤器移除时需要恢复其内容）。
- en: In JSF, we can write a nice filter by playing with some CSS code, which can
    be used to hide/show rows of a table; this is not a recommended approach in production,
    since all the data is still available in the source page, but it might be useful
    when you don't need anything fancy. The idea is to hide all of the table's rows
    that do not match the filter criteria, and for this, we can exploit the `rowClasses`
    attribute of the `<h:dataTable>` tag. This attribute's value is represented by
    a string of CSS classes separated by a comma; JSF iterates the CSS classes and
    applies them sequentially and repeatedly over rows.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF中，我们可以通过玩一些CSS代码来编写一个不错的过滤器，这些代码可以用来隐藏/显示表格的行；这并不是在生产环境中推荐的方法，因为所有数据仍然在源页面中可用，但它可能在不需要任何花哨功能时很有用。想法是隐藏所有不符合过滤器标准的表格行，为此，我们可以利用`<h:dataTable>`标签的`rowClasses`属性。此属性的值由逗号分隔的CSS类字符串表示；JSF遍历CSS类，并按顺序反复应用于行。
- en: 'Consider the following two CSS classes:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下两个CSS类：
- en: '[PRE90]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, a filter can use the `rowshow` CSS class to display a row containing valid
    data, and the `rowhide` CSS class to hide the rest of the rows. For example, iterating
    over a collection of five elements can reveal the following string of CSS classes:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，过滤器可以使用`rowshow` CSS类来显示包含有效数据的行，以及使用`rowhide` CSS类来隐藏其余的行。例如，遍历一个包含五个元素的集合可以揭示以下字符串形式的CSS类：
- en: '[PRE91]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: So, only the first and the third row will be visible.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有第一行和第三行将是可见的。
- en: 'Let''s have a look at the steps involved in the writing of such a filter:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编写此类过滤器所涉及的步骤：
- en: 'A convenient way to add a filter selection per column consists of using the
    `<h:selectOneMenu>` tag. For example, we add a filter selection in the **Age**
    column, as follows:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每列添加过滤器选择的一个方便方法是使用`<h:selectOneMenu>`标签。例如，我们在**年龄**列中添加一个过滤器选择，如下所示：
- en: '[PRE92]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `addTableFilter` method is called when the button labeled **Go!** is clicked.
    It checks the value of the `criteria` property, and if the value equals `<26`
    or `>=26`, then it iterates over the table rows and builds the corresponding string
    of CSS classes. Otherwise, if the `criteria` property is equal to `all`, the filter
    is removed, as shown in the following code:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击标记为**Go!**的按钮时，会调用`addTableFilter`方法。它检查`criteria`属性的值，如果值等于`<26`或`>=26`，则遍历表格行并构建相应的CSS类字符串。否则，如果`criteria`属性等于`all`，则移除过滤器，如下面的代码所示：
- en: '[PRE93]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The following `removeTableFilter` method will restore the CSS class; therefore,
    all data will be visible again:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下`removeTableFilter`方法将恢复CSS类；因此，所有数据将再次可见：
- en: '[PRE94]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: For the complete example, check the application named `ch6_13_1` in the code
    bundle of this chapter.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的示例，请查看本章代码包中名为`ch6_13_1`的应用程序。
- en: It's important to notice that the number of rows per page is modified when the
    filter is applied. Actually, when the filter results are displayed, the rows per
    page become equal to table row count, and when the filter is removed, they take
    a value anything from 1 to row count. The conclusion is that the filtered data
    is displayed in a table without pagination.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当应用过滤器时，每页的行数会发生变化。实际上，当过滤器结果显示时，每页的行数等于表行数，而当过滤器被移除时，它们可以取从1到行数的任何值。结论是，过滤后的数据在无分页的表格中显示。
- en: In some cases, like filtering by age, you can apply a sort before generating
    the string of CSS classes. This will help you to display the filter results, without
    affecting data, and with pagination available. A complete example can be found
    in the code bundle of this chapter, named `ch6_13_2`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，例如按年龄过滤，您可以在生成CSS类字符串之前应用排序。这将帮助您显示过滤结果，而不会影响数据，并且可以提供分页。一个完整的示例可以在本章代码包中找到，名称为`ch6_13_2`。
- en: 'You can obtain the same results by removing from the initial collection the
    items that do not match the filter criteria. For example, notice that before applying
    a filter, you need to restore the initial data of the collection—the `initHashSet`
    method can do that:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从初始集合中移除不符合过滤条件的项目来获得相同的结果。例如，请注意，在应用过滤器之前，您需要恢复集合的初始数据——`initHashSet`方法可以完成这个任务：
- en: '[PRE95]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: If you want to apply a chain of filters, then restore the data before entering
    in the chain. A complete example can be found in the code bundle of this chapter
    named `ch6_13_3`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想应用一系列过滤器，那么在进入链之前恢复数据。一个完整的示例可以在本章代码包中找到，名称为`ch6_13_3`。
- en: 'Since collections that feed tables are usually populated from databases, you
    can apply filters directly on databases. A common case is represented by tables
    with a lazy loading mechanism; since you have only a slice of data in memory,
    you need to apply the filter on the database instead of filtering the collection
    that populates the table. This means that the filtration process is accomplished
    through SQL queries. For example, our filter can be modeled through SQL queries,
    by performing the following steps (this example is based on the lazy loading application
    presented earlier in this chapter):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于为表格提供数据的集合通常是从数据库中填充的，因此您可以直接在数据库上应用过滤器。一个常见的例子是具有懒加载机制的表格；由于您在内存中只有数据的一部分，您需要在数据库上应用过滤器，而不是过滤填充表格的集合。这意味着过滤过程是通过SQL查询完成的。例如，我们的过滤器可以通过以下步骤通过SQL查询建模（此示例基于本章前面介绍的懒加载应用）：
- en: 'You pass the filter criteria to the EJB component (`copy_criteria` acts as
    a flag—you don''t want to count the number of rows each time the user navigates
    through table pages using the same filter), as shown in the following code:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将过滤条件传递给EJB组件（`copy_criteria`充当标志——您不希望在用户使用相同的过滤器通过表格页面导航时每次都计算行数），如下面的代码所示：
- en: '[PRE96]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Count the number of rows returned by the filter as follows:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式计算过滤器返回的行数：
- en: '[PRE97]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Finally, round off by applying the filter criteria using SQL queries as follows:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过以下方式应用过滤条件：
- en: '[PRE98]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Done! The complete example is available in the code bundle of this chapter and
    it is named `ch6_13_4`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的示例可在本章代码包中找到，名称为`ch6_13_4`。
- en: Styling tables
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格样式
- en: Almost all JSF UI components support the `style` and `styleClass` attributes
    for creating custom designs using CSS. But the `<h:dataTable>` tag supports attributes,
    such as `captionClass`, `captionStyle`, `columnClasses`, `rowClasses`, `headerClass`,
    and `footerClass`. Therefore, we should have no problem in adding a CSS style
    to every single part of a table (header, footer, caption, and so on). Obviously,
    there are plenty of examples that can be built, but let's see three of the most
    impressive and used ones.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的JSF UI组件都支持`style`和`styleClass`属性，用于使用CSS创建自定义设计。但是`<h:dataTable>`标签支持如`captionClass`、`captionStyle`、`columnClasses`、`rowClasses`、`headerClass`和`footerClass`等属性。因此，我们应该没有问题为表格的每个部分（标题、页脚、标题等）添加CSS样式。显然，可以构建很多示例，但让我们看看三个最令人印象深刻且常用的示例。
- en: Alternate row colors with the rowclasses attribute
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用rowclasses属性交替行颜色
- en: 'The `rowClasses` attribute is used to indicate a string of CSS classes separated
    by a comma. The string is parsed by JSF, and the styles are applied sequentially
    and repeatedly to rows. For example, you can color the even rows with one color,
    and the odd rows with some other color, as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`rowClasses` 属性用于指示由逗号分隔的 CSS 类字符串。该字符串由 JSF 解析，并将样式依次且重复地应用到行上。例如，你可以用一种颜色为偶数行着色，用另一种颜色为奇数行着色，如下所示：'
- en: '[PRE99]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Here, `even` and `odd` are the following CSS classes:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`even` 和 `odd` 是以下 CSS 类：
- en: '[PRE100]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'A possible output can be seen in the following screenshot:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了可能的输出：
- en: '![Alternate row colors with the rowclasses attribute](img/6466EN_06_14.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![使用 rowclasses 属性实现交替行颜色](img/6466EN_06_14.jpg)'
- en: Note
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can obtain the same effect for columns, by using the `columnClasses` attribute
    instead of the `rowClasses` attribute.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `columnClasses` 属性而不是 `rowClasses` 属性来获得相同的效果。
- en: The complete example is named `ch6_14_1`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在本书的代码包中命名为 `ch6_14_1`。
- en: Highlighting rows on mouse hover
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标悬停时高亮显示行
- en: 'Highlighting rows on mouse hover is a nice effect that can be accomplished
    with a piece of JavaScript. The idea is to set the `onmouseover` and `onmouseout`
    attributes, as shown in the following self-explanatory code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标悬停时高亮显示行是一个可以通过一小段 JavaScript 实现的不错的效果。思路是设置 `onmouseover` 和 `onmouseout`
    属性，如下面的自解释代码所示：
- en: '[PRE101]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The complete example is named `ch6_14_2`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在本书的代码包中命名为 `ch6_14_2`。
- en: 'Another approach does not involve using the JavaScript code. In this case,
    you can try CSS pseudo-classes, as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法不涉及使用 JavaScript 代码。在这种情况下，你可以尝试使用 CSS 伪类，如下所示：
- en: '[PRE102]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Done! The complete application is named `ch6_14_3`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！完整的应用程序在本书的代码包中命名为 `ch6_14_3`。
- en: Highlighting rows on mouse click
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标点击时高亮显示行
- en: 'Highlighting rows with a mouse click can be done with another piece of JavaScript
    code. You have to add the `onclick` attribute to each row and control the color
    alternation when the user clicks repeatedly on the same row, as shown in the following
    code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标点击来高亮显示行可以通过另一段 JavaScript 代码实现。你必须给每一行添加 `onclick` 属性，并在用户反复点击同一行时控制颜色交替，如下面的代码所示：
- en: '[PRE103]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The complete example is named `ch6_14_4` in the code bundle of this chapter.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在本书的代码包中命名为 `ch6_14_4`。
- en: Summary
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Tabular data is very commonly used in web applications, and this chapter is
    a tribute to the powerful JSF DataTable component (`<h:dataTable>`). JSF 2.2 brought
    even more power by allowing developers to render more collections than before,
    by adding the new `CollectionDataModel` class. This chapter covers the most common
    tasks that a table should accomplish, such as sorting, filtering, lazy loading,
    and CSS support. Notice that a cool and comprehensive extension of the `<h:dataTable>`
    tag is provided by PrimeFaces ([http://primefaces.org/](http://primefaces.org/))
    under the tag named `<p:dataTable>` ([http://www.primefaces.org/showcase/ui/datatableHome.jsf](http://www.primefaces.org/showcase/ui/datatableHome.jsf)).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 表格数据在 Web 应用程序中非常常用，本章是对强大的 JSF DataTable 组件（`<h:dataTable>`）的致敬。JSF 2.2 通过允许开发者渲染比以前更多的集合，通过添加新的
    `CollectionDataModel` 类，带来了更多的功能。本章涵盖了表格应完成的常见任务，例如排序、过滤、懒加载和 CSS 支持。请注意，PrimeFaces（[http://primefaces.org/](http://primefaces.org/））在
    `<p:dataTable>` 标签（[http://www.primefaces.org/showcase/ui/datatableHome.jsf](http://www.primefaces.org/showcase/ui/datatableHome.jsf)）下提供了一个酷炫且全面的
    `<h:dataTable>` 标签扩展。
- en: In the next chapter, we will be covering the AJAX technique for JSF applications.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 JSF 应用程序的 AJAX 技术。
