- en: Lazy Loading
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载
- en: '*Lazy loading* is a technique for lowering memory consumption and, possibly,
    processing time. This technique delays the loading of data until the moment when
    it''s actually needed in the UI. For example, if you have a `Grid` component with,
    say 10,000 rows, only a bunch of them are visible at a given time. Loading the
    full set of 10,000 rows might be a waste of resources. The idea behind lazy loading
    is the same as the behavior of a lazy person: if you delay doing something until
    the last moment, you will end up saving time if, for some reason, it turns out
    that you don''t have to do the task anymore. It''s the same in a web application.
    For example, if a user leaves certain views without scrolling through the data,
    the application won''t need to load anything other than a few visible items, saving
    it from having to load potentially thousands or millions of items from the data
    source; something that could become a serious problem when many users are on the
    same view at the same time.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*懒加载*是一种降低内存消耗（可能还有处理时间）的技术。这种技术将数据的加载延迟到实际需要在UI中使用的时刻。例如，如果你有一个`Grid`组件，有10,000行数据，但在任何给定时间只有其中一部分可见，那么加载全部10,000行可能是一种资源浪费。懒加载背后的理念与懒人的行为相同：如果你将做某事推迟到最后一刻，如果因为某些原因你最终不需要完成这项任务，你将节省时间。在Web应用中也是如此。例如，如果一个用户在未滚动数据的情况下离开某些视图，应用程序就不需要加载除了几个可见项目之外的其他任何内容，从而节省了从数据源加载可能成千上万或数百万项内容的需要；当许多用户同时查看同一视图时，这可能会成为一个严重的问题。'
- en: In this chapter, we will discuss how to implement lazy loading with the `Grid`
    component. However, the same principles apply to any other kind of UI components
    that show data from large datasets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何使用`Grid`组件实现懒加载。然而，同样的原则也适用于任何其他显示来自大型数据集数据的UI组件。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Adding lazy loading capabilities to backend services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为后端服务添加懒加载功能
- en: Implementing a `DataProvider` with lambda expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda表达式实现`DataProvider`
- en: Filtering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤
- en: Ordering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序
- en: Infinite lazy loading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限懒加载
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装Java SE开发工具包和Java EE SDK版本8或更高版本。你还需要Maven版本3或更高版本。建议使用具有Maven支持的Java IDE，例如IntelliJ
    IDEA、Eclipse或NetBeans。最后，为了使用本书的Git仓库，你需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-09](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-09)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-09](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-09)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：
- en: '[https://goo.gl/GLTkjq](https://goo.gl/GLTkjq)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/GLTkjq](https://goo.gl/GLTkjq)'
- en: The example application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例应用程序
- en: 'We will develop a simple application to test Vaadin''s capability to show hundreds
    of thousands of rows in a `Grid` component. The users can filter the data in the
    `Grid` by typing a filter text that the application matches against three of the
    columns (Client, Phone Number, and City). The users can also change the position
    of the columns (by dragging them from the header) and order the rows (by clicking
    on the column headers). The following is a screenshot of the example application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个简单的应用程序来测试Vaadin在`Grid`组件中显示数十万行数据的能力。用户可以通过输入一个过滤文本来在`Grid`中过滤数据，应用程序将此文本与三列（客户端、电话号码和城市）进行匹配。用户还可以通过拖动标题来更改列的位置，并通过点击列标题来排序行。以下是一个示例应用程序的截图：
- en: '![](img/0c0c951c-db66-4037-a125-96b6890bf1bf.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c0c951c-db66-4037-a125-96b6890bf1bf.png)'
- en: The data model
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据模型
- en: This chapter uses the same data model used in [Chapter 8](245d238e-02e9-4888-a0c7-37aa3f4cc536.xhtml),
    *Adding Reporting Capabilities*. The data model is based on a simple SQL table,
    `Call`. We'll use JPA to connect to a file-based H2 database. The JPA logic is
    encapsulated in a `CallRepository` class. For more details about the data model,
    please refer to [Chapter 8](245d238e-02e9-4888-a0c7-37aa3f4cc536.xhtml), *Adding
    Reporting Capabilities*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用与[第8章](245d238e-02e9-4888-a0c7-37aa3f4cc536.xhtml)中相同的**添加报告功能**所使用的数据模型。数据模型基于一个简单的SQL表，`Call`。我们将使用JPA连接到基于文件的H2数据库。JPA逻辑封装在`CallRepository`类中。有关数据模型的更多详细信息，请参阅[第8章](245d238e-02e9-4888-a0c7-37aa3f4cc536.xhtml)，**添加报告功能**。
- en: You can find the complete source code of this chapter's example in the `Data-centric-Applications-with-Vaadin-8\chapter-09`
    Maven project of the source code that accompanies this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书附带源代码的`Data-centric-Applications-with-Vaadin-8\chapter-09` Maven项目中找到本章示例的完整源代码。
- en: The Vaadin UI
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vaadin UI
- en: '`VaadinServlet` is configured in the `WebConfig` class. The `UI` implementation
    is realized in the `VaadinUI` class. For reference, the following is the implementation
    of the `VaadinUI` class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`VaadinServlet`在`WebConfig`类中进行配置。`UI`实现由`VaadinUI`类实现。为了参考，以下为`VaadinUI`类的实现：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice how the UI consists of a `VerticalLayout` that contains only a `CallsBrowser`
    component. We''ll start with the following implementation of the `CallsBrowser`
    custom component:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意UI由一个只包含`CallsBrowser`组件的`VerticalLayout`组成。我们将从以下`CallsBrowser`自定义组件的实现开始：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous class can be used as a starting point if you want to implement
    the concepts of this chapter yourself. At this point, the UI doesn't show any
    data in the `Grid` and it has no behavior.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想自己实现本章的概念，这个类可以用作起点。在这个阶段，UI在`Grid`中不显示任何数据，并且没有行为。
- en: Preparing the backend for lazy loading
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为懒加载准备后端
- en: Lazy loading (and filtering) capabilities should be delegated to the backend
    as much as possible. Although the `Grid` class itself is able to cache some of
    the data and send it to the client only when needed, it cannot prevent you from
    querying the whole database, for example. In order to support lazy loading, backend
    services should provide the means to lazily load the data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载（和过滤）功能应尽可能委托给后端。尽管`Grid`类本身能够缓存一些数据，并且仅在需要时将其发送到客户端，但它无法阻止你查询整个数据库，例如。为了支持懒加载，后端服务应提供懒加载数据的手段。
- en: 'Typically, the UI gets the data from a service or repository class. Let''s
    see an example of how a repository class can provide methods with lazy loading
    capabilities. The `CallRepository` class could define a `findAll` method that
    queries a *slice* of the rows in the `Call` table, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，UI从服务或仓库类获取数据。让我们看看一个仓库类如何提供具有懒加载功能的方法的示例。`CallRepository`类可以定义一个`findAll`方法，查询`Call`表中的*部分*行，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code, `limit` is used to *limit* the number of rows (actually,
    instances of `User`) that should be returned. When using SQL, this can be used
    as the `LIMIT` clause in a SQL query. `offset` is used to *skip* a number of rows,
    which is equivalent to the starting row number. For example, if the SQL table
    has 100 rows, and we use `offset=10` and `limit=5`, the method should return only
    the rows 10 to 15\. If we use `offset=98` and `limit=5`, the method should return
    rows 98 to 100 (there are not enough rows left after 98 to complete a set of five
    rows).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`limit`用于**限制**应返回的行数（实际上是`User`实例的实例）的数量。当使用SQL时，这可以用作SQL查询中的`LIMIT`子句。`offset`用于**跳过**一定数量的行，这相当于起始行号。例如，如果SQL表有100行，我们使用`offset=10`和`limit=5`，则该方法应仅返回第10到15行。如果我们使用`offset=98`和`limit=5`，则该方法应返回第98到100行（在98之后没有足够的行来完成一组五行）。
- en: 'For reference, here''s what a JPA implementation of these methods could look
    like:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参考，以下是一个JPA实现这些方法的示例：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice how we included a `count` method in the previous snippet of code. This
    is required in some situations, such as when using lazy loading with the `Grid`
    component.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在之前的代码片段中包含了`count`方法。在某些情况下，例如在使用`Grid`组件的懒加载时，这是必需的。
- en: Lazy loading with the Grid component
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Grid组件进行懒加载
- en: 'A `Grid` component can take advantage of the `offset` and `limit` parameters
    described in the previous section by using the `setDataProvider` method, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`组件可以通过使用`setDataProvider`方法利用之前章节中描述的`offset`和`limit`参数，如下所示：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous code defines two lambda expressions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码定义了两个 lambda 表达式：
- en: '`(sortOrders, offset, limit) -> service.find(...)`: This lambda expression
    should return all the items used in *slice* defined by the `offset` and `limit`
    parameters (we will see how to use the `sortOrders` parameters later)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(sortOrders, offset, limit) -> service.find(...)`: 这个 lambda 表达式应该返回由 `offset`
    和 `limit` 参数定义的 *slice* 中使用的所有项目（我们稍后会看到如何使用 `sortOrders` 参数）'
- en: '`() -> service.count()`: This lambda expression should return the total count
    of items available with no *slices*'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`() -> service.count()`: 这个 lambda 表达式应该返回没有 *slices* 的可用项目总数'
- en: 'The `setDataProvider` method we used in the previous example receives an instance
    of `FetchItemsCallback`, a functional interface that defines a method to fetch
    the items (or rows):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中我们使用的 `setDataProvider` 方法接收一个 `FetchItemsCallback` 的实例，这是一个定义了获取项目（或行）的方法的功能接口：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also use another version of the `setDataProvider` method that accepts
    an instance of `DataProvider`. There''s a static helper method in the `DataProvider`
    interface that allows you to implement it from lambda expressions similar to the
    ones we used before:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用另一个版本的 `setDataProvider` 方法，该方法接受 `DataProvider` 的实例。在 `DataProvider`
    接口中有一个静态辅助方法，允许您使用类似于我们之前使用的 lambda 表达式来实现它：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The difference with the previous version is that we get the `offset` and `limit`
    values from a `Query` instance, so we need to use the corresponding getters.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个版本的不同之处在于，我们从 `Query` 实例中获取 `offset` 和 `limit` 值，因此我们需要使用相应的获取器。
- en: Adding filters
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加过滤器
- en: 'Filtering should be done with the help of backend services as well. We can
    implement this in the same way as we did in [Chapter 7](8981e1f2-5502-4d2f-b0c6-c1116d23f0bc.xhtml),
    *Implementing CRUD User Interfaces*. First, the backend service method should
    accept the filter input. In the example application, the filter value is a `String`,
    but in other situations, you may need a custom object containing all the values
    that can be used for filtering. Here is the new `find` method, which accepts a
    filter `String`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤也应该在后台服务的帮助下进行。我们可以以与我们在第 7 章[实现 CRUD 用户界面](8981e1f2-5502-4d2f-b0c6-c1116d23f0bc.xhtml)中相同的方式实现它。首先，后台服务方法应该接受过滤输入。在示例应用程序中，过滤值是一个
    `String`，但在其他情况下，您可能需要一个包含所有可用于过滤的值的自定义对象。以下是新的 `find` 方法，它接受一个过滤 `String`：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice how we make the filter case-insensitive by using the `lower` JPQL function
    and converting the filter value to lowercase using the `toLowerCase` method. We
    are also using the `%` operator to allow matches in the middle of the values in
    the database. We have to do something similar with the `count` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何通过使用 `lower` JPQL 函数和 `toLowerCase` 方法将过滤值转换为小写来使过滤不区分大小写。我们还在数据库值中间使用
    `%` 运算符来允许匹配。我们必须对 `count` 方法做类似的事情：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the UI side of the implementation, we need to send the filter value to the
    service method. This value comes from the `filter` text field:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现的用户界面方面，我们需要将过滤值发送到服务方法。这个值来自 `filter` 文本字段：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also need to refresh the `DataProvider` when the Search button is clicked.
    This can be done using a `ClickListener` and the `refreshAll` method of the `DataProvider`
    interface:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击搜索按钮时，我们还需要刷新 `DataProvider`。这可以通过使用 `ClickListener` 和 `DataProvider` 接口的
    `refreshAll` 方法来实现：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Something similar can be done for the `clear` button, which removes the filter
    introduced by the user:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `clear` 按钮，也可以执行类似的操作，该按钮用于移除用户引入的过滤器：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the `refreshAll` method is invoked, the lambda expressions we previously
    defined are called again and the new data is fetched from the service class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `refreshAll` 方法时，我们之前定义的 lambda 表达式将被再次调用，并从服务类中获取新的数据。
- en: 'It''s generally a good idea to add database indexes to the columns the application
    uses to filter data. In the example application, we allow filtering on the `client`,
    `phoneNumber`, and `city` columns. You can let JPA create these indexes by using
    the `@Index` annotation, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在应用程序用于过滤数据的列上添加数据库索引是一个好主意。在示例应用程序中，我们允许对 `client`、`phoneNumber` 和 `city`
    列进行过滤。您可以通过使用 `@Index` 注解让 JPA 创建这些索引，如下所示：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By default, the example application generates around 500,000 rows in the `Call`
    table. Unfortunately, the `Grid` class cannot handle this amount of rows. See
    the following issues on GitHub for more information about these limitations: [https://github.com/vaadin/framework/issues/6290](https://github.com/vaadin/framework/issues/6290),
    and [https://github.com/vaadin/framework/issues/9751](https://github.com/vaadin/framework/issues/9751).
    One way to overcome these issues is by making the filter show results in the `Grid`
    only when the number of rows the query returns is less than an established threshold.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，示例应用程序在`Call`表中生成大约500,000行。不幸的是，`Grid`类无法处理这么多的行。有关这些限制的更多信息，请参阅以下GitHub上的问题：[https://github.com/vaadin/framework/issues/6290](https://github.com/vaadin/framework/issues/6290)，以及[https://github.com/vaadin/framework/issues/9751](https://github.com/vaadin/framework/issues/9751)。克服这些问题的方法之一是在查询返回的行数少于一个设定的阈值时，仅在`Grid`中显示过滤结果。
- en: Ordering rows in Grid components
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网格组件中排序行
- en: As you can guess, ordering (or sorting) is another task that should be delegated
    to the backend services when possible. Moreover, it is most likely required when
    you are implementing pagination (that is, lazy loading using `limit` and `offset`
    parameters) in the backend service as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，排序（或排序）是另一个应该尽可能委托给后端服务的任务。此外，当你正在后端服务中实现分页（即使用`limit`和`offset`参数的懒加载）时，这可能是必需的。
- en: The service method should include a parameter that specifies how to perform
    the ordering. The `Grid` component allows users to click on the column headers
    to activate ordering by that column. These columns that need ordering are passed
    to the `DataProvider` in a `Query` object. You can get these by calling the `Query.getSortOrders()`
    method, which returns a `List` of `QuerySortOrder` objects. You could pass this
    `List` to the service method, but it's always a good idea to avoid coupling the
    backend services with frontend technologies. `QuerySortOrder` is a class included
    in Vaadin Framework, so you would need to include Vaadin dependencies in your
    backend services if they are deployed in a separate artifact, for example. To
    avoid this coupling, we can implement a utility method that converts between `QuerySortOrder`
    objects to framework-independent objects. In the backend services, we can use
    a `Map<String, Boolean>`, where the key is a `String` containing the name of the
    property, and the value is a `Boolean` that tells the method whether to order
    in an ascending mode or not.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 服务方法应包含一个指定如何执行排序的参数。`Grid`组件允许用户点击列标题以激活按该列排序。需要排序的这些列通过一个`Query`对象传递给`DataProvider`。你可以通过调用`Query.getSortOrders()`方法来获取这些列，该方法返回一个`QuerySortOrder`对象的`List`。你可以将这个`List`传递给服务方法，但总是避免将后端服务与前端技术耦合是一个好主意。`QuerySortOrder`是Vaadin框架中的一个类，所以如果你将它们部署在单独的组件中，你将需要在后端服务中包含Vaadin依赖。为了避免这种耦合，我们可以实现一个将`QuerySortOrder`对象转换为框架无关对象的实用方法。在后端服务中，我们可以使用一个`Map<String,
    Boolean>`，其中键是一个包含属性名称的`String`，值是一个`Boolean`，它告诉方法是否按升序排序。
- en: Preparing the backend services
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备后端服务
- en: 'Let''s start, then, by adding a parameter for the ordering configuration to
    the `find` method of the `CallRepository` in the example application:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们先从向示例应用程序中`CallRepository`的`find`方法添加一个排序配置参数开始：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `order` parameter contains the name of the properties we need to sort by.
    We need to convert this `Map` to an `order by` clause (in a `String` form) in
    JPQL. This is done in the `buildOrderByClause` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`order`参数包含我们需要按其排序的属性名称。我们需要将这个`Map`转换为JPQL中的`order by`子句（以字符串形式）。这是在`buildOrderByClause`方法中完成的：'
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the user clicks the Client header in the `Grid`, the `buildOrderByClause`
    method will return the following string:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在`Grid`中点击客户端标题，`buildOrderByClause`方法将返回以下字符串：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This string would be concatenated to the end of the JPQL query, which in turn
    would be executed in the `find` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串将被连接到JPQL查询的末尾，然后在该`find`方法中执行。
- en: 'The `Grid` component also supports ordering by multiple columns. To add a column
    to the order configuration, users have to press and hold the *Shift* key down
    while clicking the column header. For example, if the user clicks the Client header
    and presses and holds the *Shift* key down while clicking the City header, the
    `buildOrderByClause` method would return the following string:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid` 组件还支持按多列排序。要向排序配置中添加列，用户必须按住 *Shift* 键不放，然后点击列头。例如，如果用户点击 Client 表头，并在点击
    City 表头时按住 *Shift* 键不放，则 `buildOrderByClause` 方法将返回以下字符串：'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Enabling ordering in the UI
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在UI中启用排序
- en: 'As we have previously discussed, the `DataProvider` interface uses an object
    of type `List<QuerySortOrder>` to provide the ordering configuration. However,
    the backend service requires an object of type `Map<String, Boolean>`. We have
    to implement a helper method that translates between these two types. We can add
    this method to a separate `DataUtils` class and implement it as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，`DataProvider` 接口使用类型为 `List<QuerySortOrder>` 的对象来提供排序配置。然而，后端服务需要一个类型为
    `Map<String, Boolean>` 的对象。我们必须实现一个帮助方法来在这两种类型之间进行转换。我们可以将此方法添加到单独的 `DataUtils`
    类中，并按如下方式实现：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `getOrderMap` method iterates over the `QuerySortOrder` objects returned
    by the `query.getSortOrders()` method and maps them to entries in a map of type
    `Map<String, Boolean>`. Notice how we used the `LinkedHasMap` type. This allows
    us to keep the entries in the map in the same order in which they come from the
    `List` provided by the `query` object, something we need if we want to support
    multiple-column ordering in the `Grid` (the `order by` clause should reflect the
    sequence used when the user clicked the headers in the browser).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOrderMap` 方法遍历由 `query.getSortOrders()` 方法返回的 `QuerySortOrder` 对象，并将它们映射到类型为
    `Map<String, Boolean>` 的映射中的条目。注意我们使用了 `LinkedHasMap` 类型。这允许我们按照从 `query` 对象提供的
    `List` 中来的顺序保持映射中的条目，如果我们想支持 `Grid` 中的多列排序（`order by` 子句应反映用户在浏览器中点击表头时使用的顺序），这是我们所需要的。'
- en: 'We can use this utility method in the `DataProvider`, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `DataProvider` 中使用此实用方法，如下所示：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The final result is illustrated in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果如下截图所示：
- en: '![](img/273da231-c17c-4128-b7fe-f409ae9d35ec.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/273da231-c17c-4128-b7fe-f409ae9d35ec.png)'
- en: 'To complete this chapter''s example, we can enable column reordering (the users
    can drag the columns in the browser to reposition them) as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的示例，我们可以启用列排序（用户可以在浏览器中拖动列以重新定位它们），如下所示：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: UX and large datasets
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户体验与大数据集
- en: To close this chapter, let me share some thoughts about the convenience (or
    inconvenience) of having a `Grid` with 10,000 (or more) rows in it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，让我分享一下拥有10,000行（或更多）的 `Grid` 的便利性（或不便之处）的一些想法。
- en: Lazy loading Grid versus direct search
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载网格与直接搜索
- en: In the screen I'm using to develop the examples of this chapter, I can see around
    15 rows at a time in a `Grid` component. If I want to see the row 5,390, for example,
    I have to scroll down and try to find the rows around 5,390\. That takes me 1
    or 2 seconds if I'm lucky. After this, I have to do some fine-tuned scrolling
    to get to the exact row. Something that can take 1 or 2 seconds again. This scrolling-through
    to search data is possible with this example application because the demo data
    is generated with consecutive numbers for the values in the fields. There are
    no missing numbers. In other situations, this might not be possible at all. Even
    in the cases where this is possible, scrolling through thousands of rows is not
    a good user experience.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我用来开发本章示例的屏幕上，我可以在 `Grid` 组件中一次看到大约15行。如果我想看到第5,390行，例如，我必须向下滚动并尝试找到大约5,390行的行。如果幸运的话，这需要1或2秒钟。之后，我必须进行一些精细的滚动才能到达确切的行。这又可能需要1或2秒钟。在这个示例应用程序中，通过搜索数据来实现这种滚动查找是可能的，因为演示数据是用连续数字为字段中的值生成的。没有缺失的数字。在其他情况下，这可能根本不可能。即使在可能的情况下，滚动数千行也不是一个好的用户体验。
- en: Filters aim to help; clicking on a `TextField` and typing 5,390 is faster than
    scrolling through the data. However, if the user is supposed to type 5,390, we
    could argue that rendering thousands of rows is not even required. The whole UI
    could potentially be redesigned to better fit the use case. When you encounter
    this kind of `Grid` with thousands of rows in it, put yourself in others' shoes;
    in the users' shoes. Consider wizard-like interfaces, infinite lazy loading on
    scroll (like Facebook or Twitter), or any other event, and splitting the view
    into several views, each one for a more specific use case.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器旨在提供帮助；点击`TextField`并输入5,390比滚动浏览数据要快。然而，如果用户需要输入5,390，我们可以争论渲染数千行甚至不是必需的。整个UI可能需要重新设计以更好地适应用例。当你遇到这种包含数千行`Grid`的界面时，换位思考；站在用户的角度。考虑类似向导的界面、滚动时的无限懒加载（如Facebook或Twitter），或任何其他事件，并将视图分割成几个视图，每个视图针对更具体的用例。
- en: Infinite lazy loading
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限懒加载
- en: Even though we have explained lazy loading by using the `Grid` component, we
    can use the same backend service method to implement custom UI components that
    support lazy loading. For example, you can use a `VerticalLayout` to add sets
    of, say, 10 components any time the user clicks a *load more* button at the bottom
    of the layout. In this case, you would need to keep track of the current offset
    and keep incrementing it until the service method returns less than 10 items.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经通过使用`Grid`组件解释了懒加载，但我们也可以使用相同的后端服务方法来实现支持懒加载的自定义UI组件。例如，你可以在用户点击布局底部的“加载更多”按钮时，使用`VerticalLayout`来添加一组，比如10个组件。在这种情况下，你需要跟踪当前偏移量并持续增加它，直到服务方法返回少于10个项目。
- en: 'The following is a simple UI component that shows how to implement this type
    of infinite lazy loading:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的UI组件，展示了如何实现这种类型的无限懒加载：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how the `loadMore` method keeps adding components to the `content` layout
    until there are no more results to add, at which point the Load more... button
    is hidden from the UI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`loadMore`方法如何持续向`content`布局添加组件，直到没有更多结果可以添加，此时“加载更多...”按钮从UI中隐藏。
- en: 'The following screenshot shows this component in action:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此组件的实际应用：
- en: '![](img/9d7a1acd-a0cd-4ff7-ae4f-29be424ec488.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d7a1acd-a0cd-4ff7-ae4f-29be424ec488.png)'
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we learned how to implement lazy loading by enhancing the
    backend service methods to support it. We learned how to use a lazy-loaded `Grid`
    component with filtering and ordering capabilities. We implemented a `DataProvider`
    by providing two lambda expressions: one for getting slices of data and one for
    counting the total number of items. We also discussed UX aspects to take into
    consideration when dealing with large datasets and learned how to implement infinite
    lazy loading as an alternative to having a `Grid` with thousands of rows.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过增强后端服务方法以支持它来实现懒加载。我们学习了如何使用具有过滤和排序功能的懒加载`Grid`组件。我们通过提供两个lambda表达式来实现`DataProvider`：一个用于获取数据切片，另一个用于计算项目总数。我们还讨论了处理大型数据集时需要考虑的UX方面，并学习了如何实现无限懒加载，作为拥有数千行`Grid`的替代方案。
- en: This chapter closes the journey through many interesting topics related to modularization,
    API design, UI design, and data management in applications developed with Vaadin.
    There is much more to this subjects that we cannot cover in this book. Hopefully,
    this book inspired you to find good solutions to some of the challenges you may
    encounter when developing data-centric web applications with Vaadin. Happy coding!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了通过许多与模块化、API设计、UI设计和在Vaadin开发的应用程序中的数据管理相关有趣主题的旅程。关于这个主题，我们在这本书中无法涵盖的内容还有很多。希望这本书能激发你找到解决在用Vaadin开发以数据为中心的Web应用程序时可能遇到的某些挑战的好方法。编码愉快！
