- en: Schema Registry
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Schema Registry
- en: In the previous chapter, we saw how to produce and consume data in JSON format.
    In this chapter, we will see how to serialize the same messages with Apache Avro.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何以 JSON 格式生产和消费数据。在本章中，我们将了解如何使用 Apache Avro 序列化相同的消息。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Avro in a nutshell
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Avro 简要介绍
- en: Defining the schema
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模式
- en: Starting the Schema Registry
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 Schema Registry
- en: Using the Schema Registry
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Schema Registry
- en: How to build a Java `AvroProducer`, a consumer, and a processor
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建 Java `AvroProducer`、消费者和处理器
- en: How to run the Java `AvroProducer` and the processor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何运行 Java `AvroProducer` 和处理器
- en: Avro in a nutshell
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Avro 简要介绍
- en: Apache Avro is a binary serialization format. The format is schema-based so,
    it depends on the definition of schemas in JSON format. These schemas define which
    fields are mandatory and their types. Avro also supports arrays, enums, and nested
    fields.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Avro 是一种二进制序列化格式。该格式基于模式，因此它依赖于 JSON 格式中的模式定义。这些模式定义了哪些字段是必需的以及它们的类型。Avro
    还支持数组、枚举和嵌套字段。
- en: One major advantage of Avro is that it supports schema evolution. In this way,
    we can have several historical versions of the schema.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Avro 的一个主要优点是它支持模式演进。这样，我们可以拥有几个模式的历史版本。
- en: Normally, the system must adapt to the changing needs of the business. For this
    reason, we can add or remove fields from our entities, and even change the data
    types. To support forward or backward compatibility, we must consider which fields
    are indicated as optional.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，系统必须适应业务的变化需求。因此，我们可以向我们的实体添加或删除字段，甚至更改数据类型。为了支持向前或向后兼容性，我们必须考虑哪些字段被标记为可选的。
- en: Because Avro converts the data into arrays of bytes (serialization), and Kafka's
    messages are also sent in binary data format, with Apache Kafka, we can send messages
    in Avro format. The real question is, where do we store the schemas for Apache
    Avro to work?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Avro 将数据转换为字节数组（序列化），而 Kafka 的消息也是以二进制数据格式发送的，所以使用 Apache Kafka，我们可以以 Avro
    格式发送消息。真正的问题是，我们将在哪里存储 Apache Avro 的工作模式？
- en: Recall that one of the main functions of an enterprise service bus is the format
    validation of the messages it processes, and what better if it has a historical
    record of these formats?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，企业服务总线的主要功能之一是验证它所处理的消息的格式，如果它有这些格式的历史记录会更好。
- en: The Kafka Schema Registry is the module responsible for performing important
    functions. The first is to validate that the messages are in the appropriate format,
    the second is to have a repository of these schemas, and the third is to have
    a historical version format of these schemas.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka Schema Registry 是负责执行重要功能的模块。第一个功能是验证消息是否处于适当的格式，第二个功能是拥有这些模式的存储库，第三个功能是拥有这些模式的历史版本格式。
- en: The Schema Registry is a server that runs in the same place as our Kafka brokers.
    It runs and stores the schemas, including the schema versions. When messages are
    sent to Kafka in Avro format, the messages contain an identifier of a schema stored
    in the Schema Registry.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Schema Registry 是一个与我们的 Kafka 代理在同一位置运行的服务器。它运行并存储模式，包括模式版本。当以 Avro 格式将消息发送到
    Kafka 时，消息包含一个存储在 Schema Registry 中的模式标识符。
- en: There is a library that allows for message serialization and deserialization
    in Avro format. This library works transparently and naturally with the Schema
    Registry.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个库允许在 Avro 格式中进行消息序列化和反序列化。这个库与 Schema Registry 透明且自然地协同工作。
- en: When a message is sent in Avro format, the serializer ensures that the schema
    is registered and obtains the schema ID. If we send an Avro message that is not
    in the Schema Registry, the current version of the schema is registered automatically
    in the Registry. If you do not want the Schema Registry to behave in this way,
    you can disable it by setting the `auto.register.schemas` flag to `false`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当以 Avro 格式发送消息时，序列化器确保已注册模式并获取模式 ID。如果我们发送一个不在 Schema Registry 中的 Avro 消息，当前版本的模式将自动在注册表中注册。如果您不希望
    Schema Registry 以这种方式操作，可以通过将 `auto.register.schemas` 标志设置为 `false` 来禁用它。
- en: When a message is received in Avro format, the deserializer tries to find the
    schema ID in the Registry and fetch the schema to deserialize the message in Avro
    format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到 Avro 格式的消息时，反序列化器试图在注册表中找到模式 ID 并获取模式以反序列化 Avro 格式的消息。
- en: Both the Schema Registry and the library for the serialization and deserialization
    of messages in Avro format are under the Confluent Platform. It is important to
    mention that when you need to use the Schema Registry, you must use the Confluent
    Platform.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 模式注册表以及用于Avro格式消息序列化和反序列化的库都在Confluent平台下。重要的是要提到，当您需要使用模式注册表时，您必须使用Confluent平台。
- en: It is also important to mention that with the Schema Registry, the Confluent
    library should be used for serialization in Avro format, as the Apache Avro library
    doesn't work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还很重要的一点是，使用模式注册表时，应该使用Confluent库进行Avro格式的序列化，因为Apache Avro库不起作用。
- en: Defining the schema
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模式
- en: 'The first step is to define the Avro schema. As a reminder, our `HealthCheck`
    class looks like *Listing 5.1*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义Avro模式。作为提醒，我们的`HealthCheck`类看起来像*列表5.1*：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 5.1: HealthCheck.java'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '列表5.1: HealthCheck.java'
- en: 'Now, with the representation of this message in Avro format, the schema (that
    is, the template) of all the messages of this type in Avro would be *Listing 5.2*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个消息的Avro格式表示，所有此类消息的Avro模式（即模板）将是*列表5.2*：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 5.2: healthcheck.avsc'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '列表5.2: healthcheck.avsc'
- en: This file must be saved in the `kioto` project in the `src/main/resources` directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件必须保存在`kioto`项目的`src/main/resources`目录下。
- en: It is important to note that there are the types `string`, `float`, and `double`.
    But, in the case of `Date`, it can be stored as a `long` or as a `string`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，有`string`、`float`和`double`这些类型。但是，对于`Date`，它可以存储为`long`或`string`。
- en: For this example, we will serialize `Date` as a `long`. Avro doesn't have a
    dedicated `Date` type; we have to choose between a `long` and a `string` (an ISO-8601
    `string` is usually better), but the point with this example is to show how to
    use different data types.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将`Date`序列化为`long`。Avro没有专门的`Date`类型；我们必须在`long`和`string`（通常是ISO-8601的`string`）之间选择，但这个例子中的重点是展示如何使用不同的数据类型。
- en: 'For more information about Avro schemas and how to map the types, check the
    Apache Avro specification at the following URL:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Avro模式和如何映射类型的信息，请查看以下URL的Apache Avro规范：
- en: '[http://avro.apache.org/docs/current/spec.html](http://avro.apache.org/docs/current/spec.html)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://avro.apache.org/docs/current/spec.html](http://avro.apache.org/docs/current/spec.html)'
- en: Starting the Schema Registry
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动模式注册表
- en: Well, we have our Avro schema; now, we need to register it in the Schema Registry.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经有了我们的Avro模式；现在，我们需要在模式注册表中注册它。
- en: 'When we start the Confluent Platform, the Schema Registry is started, as shown
    in the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动Confluent平台时，模式注册表也会启动，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we want just to start the Schema Registry, we need to run the following
    command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想启动模式注册表，我们需要运行以下命令：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is similar to the one shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输出类似于这里所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the Schema Registry
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模式注册表
- en: 'Now, the Schema Registry is running on port `8081`. To interact with the Schema
    Registry, there is a REST API. We can access it with `curl`. The first step is
    to register a schema in the Schema Registry. To do so, we have to embed our JSON
    schema in another JSON object, and we have to escape some special characters and
    add a payload:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，模式注册表正在端口`8081`上运行。要与模式注册表交互，有一个REST API。我们可以使用`curl`来访问它。第一步是在模式注册表中注册一个模式。为此，我们必须将我们的JSON模式嵌入到另一个JSON对象中，并且必须转义一些特殊字符并添加一个有效负载：
- en: 'At the beginning, we have to add `{ \"schema\": \"`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在开始时，我们必须添加`{ \"schema\": \"`'
- en: All the double quotation marks (`"`) should be escaped with a backslash (`\"`)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有双引号（`"`）都应该用反斜杠（`\"`）转义
- en: At the end, we have to add `\" }`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们必须添加`\" }`
- en: Yes, as you can guess, the API has several commands to query the Schema Registry.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，正如你可以猜到的，API有几个命令来查询模式注册表。
- en: Registering a new version of a schema under a – value subject
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一个值主题下注册模式的新版本
- en: 'To register the Avro schema `healthcheck.avsc`, located in the `src/main/resources/`
    path listed in *Listing 5.2*, using the `curl` command, we use the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`curl`命令注册位于`src/main/resources/`路径中，如*列表5.2*中列出的`healthcheck.avsc`Avro模式，我们使用以下命令：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should be something like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This means that we have registered the `HealthChecks` schema with the version
    `"id":1` (congratulations, your first version).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经将`HealthChecks`模式注册为版本`"id":1`（恭喜，这是您的第一个版本）。
- en: Note that the command registers the schema on a subject called `healthchecks-avro-value`.
    The Schema Registry doesn't have information about topics (we still haven't created
    the `healthchecks-avro` topic). It is a convention, followed by the serializers/deserializers,
    to register schemas under a name following the <topic>-value format. In this case,
    since the schema is used for the message values, we use the suffix-value. If we
    wanted to use Avro to identify our messages keys, we would use the <topic>-key
    format.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该命令在名为`healthchecks-avro-value`的主题上注册模式。Schema Registry没有关于主题的信息（我们还没有创建`healthchecks-avro`主题）。序列化器/反序列化器遵循一个惯例，即在遵循<主题>-value格式的名称下注册模式。在这种情况下，由于该模式用于消息值，我们使用后缀-value。如果我们想使用Avro来标识我们的消息键，我们将使用<主题>-key格式。
- en: 'For example, to obtain the ID of our schema, we use the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获取我们模式的ID，我们使用以下命令：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following output is the schema ID:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出是模式ID：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With the schema ID, to check the value of our schema, we use the following
    command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式ID，为了检查我们模式的值，我们使用以下命令：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is the schema value shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是这里显示的模式值：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Registering a new version of a schema under a – key subject
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在–key主题下注册模式的新的版本
- en: 'As an example, to register a new version of our schema under the `healthchecks-avro-key`
    subject, we would execute the following command (don''t run it; it is just to
    exemplify):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将我们模式的新的版本注册到`healthchecks-avro-key`主题下，我们将执行以下命令（不要运行它；这只是为了举例）：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output should be something like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Registering an existing schema into a new subject
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将现有模式注册到新主题
- en: Let's suppose that there is an existing schema registered on a subject called
    `healthchecks-value1`, and we need this schema available on a subject called `healthchecks-value2`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个名为`healthchecks-value1`的主题上已注册的模式，我们需要这个模式在名为`healthchecks-value2`的主题上可用。
- en: 'The following command reads the existing schema from `healthchecks-value1`
    and registers it to `healthchecks-value2` (assuming that the `jq` tool is already
    installed):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令从`healthchecks-value1`读取现有模式并将其注册到`healthchecks-value2`（假设`jq`工具已经安装）：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output should be something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing all subjects
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出所有主题
- en: 'To list all the subjects, you can use the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有主题，你可以使用以下命令：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output should be something like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Fetching a schema by its global unique ID
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过其全局唯一ID获取模式
- en: 'To fetch a schema, you can use the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 获取模式，你可以使用以下命令：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output should be something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Listing all schema versions registered under the healthchecks–value subject
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出在`healthchecks–value`主题下注册的所有模式版本
- en: 'To list all schema versions registered under the `healthchecks-value` subject,
    you can use the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出在`healthchecks-value`主题下注册的所有模式版本，你可以使用以下命令：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output should be something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Fetching version 1 of the schema registered under the healthchecks-value subject
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取在`healthchecks-value`主题下注册的模式的版本1
- en: 'To fetch version 1 of the schema registered under the `healthchecks-value`
    subject, you can use the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取在`healthchecks-value`主题下注册的模式的版本1，你可以使用以下命令：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output should be something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Deleting version 1 of the schema registered under the healthchecks-value subject
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除在`healthchecks-value`主题下注册的模式的版本1
- en: 'To delete version 1 of the schema registered under the `healthchecks-value`
    subject, you can use the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除在`healthchecks-value`主题下注册的模式的版本1，你可以使用以下命令：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output should be something like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Deleting the most recently registered schema under the healthchecks-value subject
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除在`healthchecks-value`主题下最近注册的模式
- en: 'To delete the most recently registered schema under the `healthchecks-value`
    subject, you can use the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除在`healthchecks-value`主题下最近注册的模式，你可以使用以下命令：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output should be something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Deleting all the schema versions registered under the healthchecks–value subject
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除在`healthchecks–value`主题下注册的所有模式版本
- en: 'To delete all the schema versions registered under the `healthchecks-value`
    subject, you can use the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除在`healthchecks-value`主题下注册的所有模式版本，你可以使用以下命令：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output should be something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Checking whether a schema is already registered under the healthchecks–key subject
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查是否在`healthchecks-key`主题下已注册该模式
- en: 'To check whether a schema is already registered under the `healthchecks-key`
    subject, you can use the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否在`healthchecks-key`主题下已注册该模式，可以使用以下命令：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output should be something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing schema compatibility against the latest schema under the healthchecks–value
    subject
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对`healthchecks-value`主题下的最新模式进行模式兼容性测试
- en: 'To test the schema compatibility against the latest schema under the `healthchecks-value`
    subject, you can use the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要对`healthchecks-value`主题下的最新模式进行模式兼容性测试，可以使用以下命令：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output should be something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Getting the top-level compatibility configuration
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取顶级兼容性配置
- en: 'To get the top level compatibility configuration, you can use the following
    command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取顶级兼容性配置，可以使用以下命令：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output should be something like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Globally updating the compatibility requirements
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局更新兼容性要求
- en: 'To globally update the compatibility requirements, you can use the following
    command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局更新兼容性要求，可以使用以下命令：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output should be something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Updating the compatibility requirements under the healthchecks–value subject
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新`healthchecks-value`主题下的兼容性要求
- en: 'To update the compatibility requirements under the `healthchecks-value` subject,
    you can use the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新`healthchecks-value`主题下的兼容性要求，可以使用以下命令：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output should be something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Java AvroProducer
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java AvroProducer
- en: 'Now, we should modify our Java Producer to send messages in Avro format. First,
    it is important to mention that in Avro there are two types of messages:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该修改我们的Java生产者以发送Avro格式的消息。首先，重要的是要提到，在Avro中有两种类型的消息：
- en: '**Specific records**: The file with the Avro schema (avsc) is sent to a specific
    Avro command to generate the corresponding Java classes.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定记录**：包含Avro模式（avsc）的文件被发送到特定的Avro命令以生成相应的Java类。'
- en: '**Generic records**: In this approach, a data structure similar to a map dictionary
    is used. This means that you set and get the fields by their names and you must
    know their corresponding types. This option is not type-safe, but it offers much
    more flexibility than the other, and here the versions are much easier to manage
    over time. In this example, we will use this approach.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用记录**：在此方法中，使用类似于映射字典的数据结构。这意味着您可以通过名称设置和获取字段，并且您必须知道它们对应的类型。此选项不是类型安全的，但它比其他选项提供了更多的灵活性，并且在这里，版本随着时间的推移更容易管理。在这个例子中，我们将使用这种方法。'
- en: Before we start with the code, remember that in the last chapter we added the
    library to support Avro to our Kafka client. If you recall, the `build.gradle`
    file has a special repository with all this libraries.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，请记住，在上一章中，我们向Kafka客户端添加了支持Avro的库。如果您还记得，`build.gradle`文件有一个特殊的仓库，其中包含所有这些库。
- en: 'Confluent''s repository is specified in the following line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Confluent的仓库在以下行指定：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the dependencies section, we should add the specific Avro libraries:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖关系部分，我们应该添加特定的Avro库：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Do not use the libraries provided by Apache Avro, because they will not work.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用Apache Avro提供的库，因为它们将不起作用。
- en: 'As we already know, to build a Kafka message producer, we use the Java client
    library; in particular, the producer API. As we already know, there are two requisites
    that all the Kafka producers should have: to be a `KafkaProducer` and to set the
    specific `Properties`, such as *Listing 5.3*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，要构建Kafka消息生产者，我们使用Java客户端库；特别是生产者API。如我们所知，所有Kafka生产者都应该有两个必备条件：成为一个`KafkaProducer`并设置特定的`Properties`，例如*列表5.3*：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 5.3: AvroProducer Constructor'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3：AvroProducer构造函数
- en: 'An analysis of the `AvroProducer` constructor shows the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 分析`AvroProducer`构造函数显示以下内容：
- en: In line `//1`, the values now are of type `org.apache.avro.generic.GenericRecord`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//1`中，现在的值是`org.apache.avro.generic.GenericRecord`类型
- en: In line `//2`, the constructor now receives the Schema Registry URL
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//2`中，构造函数现在接收模式注册表URL
- en: In line `//3`, the Serializer type for the messages' keys remains as `StringSerializer`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//3`中，消息键的序列化器类型仍然是`StringSerializer`
- en: In line `//4`, the Serializer type for the messages' values now is a `KafkaAvroSerializer`
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//4`中，消息值的序列化器类型现在是`KafkaAvroSerializer`
- en: In line `//5`, the Schema Registry URL is added to the Producer properties
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//5`中，将Schema Registry URL添加到生产者属性中
- en: In line `//6`, the avsc file with the schema definition is parsed with a Schema
    Parser
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//6`中，使用Schema Parser解析包含模式定义的avsc文件
- en: Because we have chosen the use of generic records, we have to load the schema.
    Note that we could have obtained the schema from the Schema Registry, but this
    is not safe because we do not know which version of the schema is registered.
    Instead of this, it is a smart and safe practice to store the schema along with
    the code. In this way, our code will always produce the correct data types, even
    when someone else changes the schema registered in the Schema Registry.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们选择了使用通用记录，我们必须加载模式。请注意，我们本可以从Schema Registry获取模式，但这并不安全，因为我们不知道哪个版本的模式已注册。相反，将模式与代码一起存储是一种聪明且安全的做法。这样，即使有人更改Schema
    Registry中注册的模式，我们的代码也会始终产生正确的数据类型。
- en: 'Now, in the `src/main/java/kioto/avro` directory, create a file called `AvroProducer.java`
    with the contents of *Listing 5.4*:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`src/main/java/kioto/avro`目录下，创建一个名为`AvroProducer.java`的文件，内容为*列表5.4*：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 5.4: AvroProducer.java'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4：AvroProducer.java
- en: 'An analysis of the `AvroProducer` class shows the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对`AvroProducer`类的分析显示以下内容：
- en: In line `//1`, `ratePerSecond` is the number of messages to send in a 1-second
    period
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//1`中，`ratePerSecond`是1秒内要发送的消息数量
- en: In line `//2`, to simulate repetition, we use an infinite loop (try to avoid
    this in production)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//2`中，为了模拟重复，我们使用了一个无限循环（在生产环境中尽量避免这样做）
- en: In line `//3`, now we can create `GenericRecord` objects using `GenericRecordBuilder`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//3`中，现在我们可以使用`GenericRecordBuilder`创建`GenericRecord`对象
- en: In line `//4`, we use a Java Future to send the record to the `healthchecks-avro`
    topic
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//4`中，我们使用Java Future将记录发送到`healthchecks-avro`主题
- en: In line `//5`, we wait this time to send messages again
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//5`中，我们这次等待再次发送消息
- en: In line `//6`, we read the result of the Future
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//6`中，我们读取Future的结果
- en: In line `//7`, everything runs on the broker on the localhost in port `9092`,
    and with the Schema Registry running on the localhost in port `8081`, sending
    two messages in an interval of 1 second
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//7`中，一切都在本地的9092端口上的代理上运行，Schema Registry也在本地的8081端口上运行，以1秒的间隔发送两条消息
- en: Running the AvroProducer
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行AvroProducer
- en: 'To build the project, run the following command from the `kioto` directory:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建项目，请在`kioto`目录下运行以下命令：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If everything is OK, the output is something like the one shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，输出将类似于这里所示：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If it is not running yet, go to Confluent''s directory and start it:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它还没有运行，请转到Confluent目录并启动它：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The broker is running on port `9092`. To create the `healthchecks-avro` topic,
    execute the following command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理正在9092端口上运行。要创建`healthchecks-avro`主题，执行以下命令：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that we are just creating a normal topic and nothing indicates the messages'
    format.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们只是创建了一个普通主题，没有指示消息的格式。
- en: 'Run a console consumer for the `healthchecks-avro` topic:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`healthchecks-avro`主题运行控制台消费者：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: From our IDE, run the main method of the `AvroProducer`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的IDE中运行`AvroProducer`的main方法。
- en: 'The output on the console consumer should be similar to the one shown here:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台消费者的输出应该类似于这里所示：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Binary is a horrible format for humans to read, isn't it? We can just read the
    strings but not the rest of the record.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制格式对人类来说难以阅读，不是吗？我们只能读取字符串，但不能读取记录的其余部分。
- en: To solve our readability problem, we should use `kafka-avro-console-consumer`
    instead. This fancy consumer deserializes the Avro records and prints them as
    human-readable JSON objects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的可读性问题，我们应该使用`kafka-avro-console-consumer`。这个花哨的消费者将Avro记录反序列化并打印成人类可读的JSON对象。
- en: 'From the command line, run an Avro console consumer for the `healthchecks-avro`
    topic:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行运行一个`healthchecks-avro`主题的Avro控制台消费者：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output on the console consumer should be similar to this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台消费者的输出应该类似于以下内容：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, we are finally producing Kafka messages in Avro format. With the help of
    the Schema Registry and the Confluent library, this task is quite simple. As described,
    after much frustration in productive environments, the generic records scheme
    is better than the specific records scheme, because it is better to know specifically
    with which schema we are producing data. Keeping a copy of the schema along with
    the code gives you that guarantee.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于开始以Avro格式生产Kafka消息。在Schema Registry和Confluent库的帮助下，这个任务相当简单。正如描述的那样，在生产环境中经过许多挫折后，通用记录模式比特定记录模式更好，因为知道我们正在使用哪个模式来生产数据更好。将模式代码与代码一起保存可以给你这个保证。
- en: What happens if we fetch the schema from the Schema Registry before producing
    the data? The correct answer is it depends, and it depends on the
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在生产数据之前从Schema Registry获取模式会发生什么？正确的答案是这取决于，这取决于
- en: '`auto.register.schemas` property. If this property is set to true, when you
    request a schema that is not in the Schema Registry, it will automatically be
    registered as a new schema (this option in production environments is not recommended,
    as it is prone to error). If the property is set to false, the schema will not
    be stored and, since the schema will not match, we will have a nice exception
    (do not believe me, reader; go and get proof of this).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto.register.schemas`属性。如果此属性设置为true，当您请求Schema Registry中不存在的模式时，它将自动注册为新的模式（在生产环境中不建议使用此选项，因为它容易出错）。如果属性设置为false，则不会存储模式，并且由于模式不匹配，我们将得到一个漂亮的异常（不要相信我，读者；去获取这个证明）'
- en: Java AvroConsumer
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java AvroConsumer
- en: 'Let''s create a Kafka `AvroConsumer` that we will use to receive the input
    records. As we already know, there are two prerequisites that all the Kafka Consumers
    should have: to be a `KafkaConsumer` and to set specific properties, such as in
    *Listing 5.5*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个Kafka `AvroConsumer`，我们将使用它来接收输入记录。正如我们已经知道的，所有的Kafka Consumers都应该有两个前提条件：成为一个`KafkaConsumer`并设置特定的属性，如*列表5.5*所示：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 5.5: AvroConsumer constructor'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5：AvroConsumer构造函数
- en: 'An analysis of the changes in the `AvroConsumer` constructor shows the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 分析`AvroConsumer`构造函数的变化，我们可以看到以下内容：
- en: In line `//1`, the values now are of type `org.apache.avro.generic.GenericRecord`
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//1`中，值现在是`org.apache.avro.generic.GenericRecord`类型
- en: In line `//2`, the constructor now receives the Schema Registry URL
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//2`中，构造函数现在接收Schema Registry URL
- en: In line `//3`, the deserializer type for the messages' keys remains as `StringDeserializer`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//3`中，消息键的反序列化类型仍然是`StringDeserializer`
- en: In line `//4`, the deserializer type for the values is now `KafkaAvroDeserializer`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//4`中，值的反序列化类型现在是`KafkaAvroDeserializer`
- en: In line `//5`, the Schema Registry URL is added to the consumer properties
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//5`中，将Schema Registry URL添加到消费者属性中
- en: 'In line `//6`, with these `Properties`, we build a `KafkaConsumer` with string
    keys and `GenericRecord` values: `<String, GenericRecord>`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//6`中，使用这些`Properties`，我们构建了一个具有字符串键和`GenericRecord`值的`KafkaConsumer`：`<String,
    GenericRecord>`
- en: It is important to note that when defining the Schema Registry URL for the deserializer
    to fetch schemas, the messages only contain the schema ID and not the schema itself.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当为反序列化器定义Schema Registry URL以获取模式时，消息只包含模式ID而不是模式本身。
- en: Java AvroProcessor
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java AvroProcessor
- en: 'Now, in the `src/main/java/kioto/avro` directory, create a file called `AvroProcessor.java`
    with the contents of *Listing 5.6*:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`src/main/java/kioto/avro`目录下，创建一个名为`AvroProcessor.java`的文件，其内容为*列表5.6*：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 5.6: AvroProcessor.java (part 1)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6：AvroProcessor.java（第一部分）
- en: 'An analysis of the first part of the `AvroProcessor` class shows the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 分析`AvroProcessor`类的前一部分，我们可以看到以下内容：
- en: In the first section, we declare an `AvroConsumer`, as in *Listing 5.5*
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一部分，我们声明了一个`AvroConsumer`，如*列表5.5*所示
- en: In the second section, we declare an `AvroProducer`, as in *Listing 5.4*
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二部分，我们声明了一个`AvroProducer`，如*列表5.4*所示
- en: 'Now, in the `src/main/java/kioto/avro` directory, let''s complete the `AvroProcessor.java`
    file with the contents of *Listing 5.7*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`src/main/java/kioto/avro`目录下，让我们用*列表5.7*的内容来完成`AvroProcessor.java`文件：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 5.7: AvroProcessor.java (part 2)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7：AvroProcessor.java（第二部分）
- en: 'An analysis of the `AvroProcessor` shows the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 分析`AvroProcessor`，我们可以看到以下内容：
- en: In line `//1`, the consumer is subscribed to the new Avro topic.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//1`中，消费者订阅了新的Avro主题。
- en: In line `//2`, we are consuming messages of type `GenericRecord`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//2`中，我们正在消费类型为`GenericRecord`的消息。
- en: In line `//3`, the Avro record is deserialized to extract the `HealthCheck`
    object.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//3`中，将Avro记录反序列化以提取`HealthCheck`对象。
- en: In line `//4`, the start time is transformed into the format in the current
    time zone.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//4`中，将开始时间转换为当前时区的格式。
- en: In line `//5`, the uptime is calculated.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//5`中，计算了运行时间。
- en: In line `//6`, the uptime is written to the `uptimes` topic, using the serial
    number as the key and the uptime as the value. Both values are written as normal
    strings.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//6`中，将运行时间写入`uptimes`主题，使用序列号作为键，运行时间作为值。两个值都作为普通字符串写入。
- en: In line `//7`, everything runs on the broker on the localhost in port `9092`
    and with the Schema Registry running on the localhost in port `8081`.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在行`//7`中，所有操作都在本地的`9092`端口上的代理上运行，并且模式注册表在本地的`8081`端口上运行。
- en: As mentioned previously, the code is not type-safe; all the types are checked
    at runtime. So, be extremely careful with that. For example, the strings are not
    `java.lang.String`; they are of type `org.apache.avro.util.Utf8`. Note that we
    avoid the cast by calling the `toString()` method directly on the objects. The
    rest of the code remains equal.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，代码不是类型安全的；所有类型都在运行时进行检查。因此，请对此格外小心。例如，字符串不是`java.lang.String`；它们是`org.apache.avro.util.Utf8`类型。请注意，我们通过直接在对象上调用`toString()`方法来避免类型转换。其余的代码保持不变。
- en: Running the AvroProcessor
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行AvroProcessor
- en: 'To build the project, run the following command from the `kioto` directory:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建项目，请从`kioto`目录中运行以下命令：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If everything is correct, the output will be something like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，输出将类似于以下内容：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run a console consumer for the `uptimes` topic, as shown here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`uptimes`主题的控制台消费者，如下所示：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: From the IDE, run the main method of the `AvroProcessor`
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从IDE中运行`AvroProcessor`的主方法
- en: From the IDE, run the main method of the `AvroProducer`
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从IDE中运行`AvroProducer`的主方法
- en: 'The output on the console consumer for the `uptimes` topic should be similar
    to this:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台消费者对于`uptimes`主题的输出应类似于以下内容：
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we showed, instead of sending data in JSON format, how to use
    AVRO as the serialization format. The main benefit of AVRO (over JSON, for example)
    is that the data must conform to the schema. Another advantage of AVRO over JSON
    is that the messages are more compact when sent in binary format, although JSON
    is human readable.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了，而不是以JSON格式发送数据，如何使用AVRO作为序列化格式。AVRO（例如，相对于JSON）的主要好处是数据必须符合模式。AVRO相对于JSON的另一个优点是，以二进制格式发送时，消息更加紧凑，尽管JSON是可读的。
- en: The schemas are stored in the Schema Registry, so that all users can consult
    the schema version history, even when the code of the producers and consumers
    for those messages is no longer available.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 模式存储在模式注册表中，这样所有用户都可以咨询模式版本历史，即使那些消息的生产者和消费者的代码不再可用。
- en: Apache Avro also guarantees backward and forward compatibility of all messages
    in this format. Forward compatibility is achieved following some basic rules,
    such as when adding a new field, declaring its value as optional.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Avro还保证了此格式中所有消息的向前和向后兼容性。通过遵循一些基本规则实现向前兼容性，例如，当添加新字段时，将其值声明为可选的。
- en: Apache Kafka encourages the use of Apache Avro and the Schema Registry for the
    storage of all data and schemas in Kafka systems, instead of using only plain
    text or JSON. Using that winning combination, you guarantee that your system can
    evolve.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Kafka鼓励在Kafka系统中使用Apache Avro和模式注册表来存储所有数据和模式，而不是仅使用纯文本或JSON。使用这个成功的组合，你可以保证你的系统可以进化。
