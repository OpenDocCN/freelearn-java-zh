- en: Inside JVM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM内部
- en: The previous chapter gave us knowledge on how to tune an application's performance
    by understanding the symptoms of the performance issues. We walked through the
    performance tuning life cycle, learning at what stages of the application performance
    can be tuned and how. We also learned how to connect JMX to the Spring application,
    observed the application's bottleneck, and tuned it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章让我们了解了如何通过理解性能问题的症状来调整应用程序的性能。我们走过了性能调整生命周期，学习了在应用程序性能的哪些阶段可以进行调整以及如何进行调整。我们还学会了如何将JMX连接到Spring应用程序，观察应用程序的瓶颈并进行调整。
- en: In this chapter, we will walk through the insides of **Java Virtual Machine** (**JVM**)
    and tuning JVM to achieve high performance. JVM performs two primary jobs—executing
    code and managing memory. JVM allocates memory from OS, manages to do heap compaction,
    and performs **garbage collection** (**GC**) of unreferenced objects. GC is important
    because proper GC improves the memory management of the application and the performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解**Java虚拟机**（**JVM**）的内部和调整JVM以实现高性能。JVM执行两项主要工作——执行代码和管理内存。JVM从操作系统分配内存，管理堆压缩，并对未引用的对象执行**垃圾回收**（**GC**）。GC很重要，因为适当的GC可以改善应用程序的内存管理和性能。
- en: 'The following are the topics we will go through in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习以下主题：
- en: Understanding JVM internals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解JVM内部
- en: Understanding memory leak
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内存泄漏
- en: Common pitfalls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: GC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC
- en: GC methods and policies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC方法和策略
- en: Tools to analyze GC logs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析GC日志的工具
- en: Understanding JVM internals
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JVM内部
- en: Being a Java developer, we know that Java bytecode runs in a **Java Runtime
    Environment** (**JRE**) and the most important part of the JRE is JVM, which analyzes
    and executes the Java bytecode. When we create a Java program and compile it,
    the result is a file with the `.class` extension. It contains Java bytecode. JVM
    converts Java bytecode into machine instructions that are executed on the hardware
    platform where we run our application. When a JVM runs a program, it needs memory
    to store bytecodes and other information it extracts from loaded class files,
    instantiated objects, method parameters, return values, local variables, and intermediate
    results of computations. The JVM organizes the memory it needs into several runtime
    data areas.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java开发人员，我们知道Java字节码在**Java运行环境**（**JRE**）中运行，而JRE最重要的部分是JVM，它分析并执行Java字节码。当我们创建一个Java程序并编译它时，结果是一个扩展名为`.class`的文件。它包含Java字节码。JVM将Java字节码转换为在我们运行应用程序的硬件平台上执行的机器指令。当JVM运行程序时，它需要内存来存储来自加载的类文件、实例化对象、方法参数、返回值、局部变量和计算的中间结果的字节码和其他信息。JVM将它需要的内存组织成几个运行时数据区域。
- en: 'JVM consist of three parts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JVM由三部分组成：
- en: Class loader subsystem
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器子系统
- en: Memory areas
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存区域
- en: Execution engine
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行引擎
- en: 'The following diagram illustrates the high-level JVM architecture:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了高级JVM架构：
- en: '![](img/cfada67e-a629-4d24-a687-572f75805824.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfada67e-a629-4d24-a687-572f75805824.jpg)'
- en: JVM architecture
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JVM架构
- en: Let's briefly understand the three different parts of JVM we saw in the diagram.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要了解一下图表中我们看到的JVM的三个不同部分。
- en: Class loader subsystem
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类加载器子系统
- en: 'The class loader subsystem''s responsibilities are not limited to just locating
    and importing the binary data for classes. It also verifies that the imported
    classes are correct, allocates and initializes memory for class variables, and
    assists in resolving symbolic references. These activities are performed in a
    strict order:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器子系统的责任不仅仅是定位和导入类的二进制数据。它还验证导入的类是否正确，为类变量分配和初始化内存，并协助解析符号引用。这些活动按严格顺序执行：
- en: '**Loading**: The class loader reads the `.class` file and finds and imports
    binary data for a type.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**加载**：类加载器读取`.class`文件并查找和导入类型的二进制数据。'
- en: '**Linking**: It performs verification, preparation, and (optionally) resolution:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链接**：它执行验证、准备和（可选）解析：'
- en: '**Verification**: Ensures the correctness of the imported type'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：确保导入类型的正确性'
- en: '**Preparation**: Allocates memory to class variables and initializes the memory
    to default values'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**：为类变量分配内存并将内存初始化为默认值'
- en: '**Resolution**: Transforms symbolic references from the type into direct references'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析**：将类型的符号引用转换为直接引用'
- en: '**Initialization**: Assigns values to all static variables defined in the code
    and executes static block (if any). Execution occurs from top to bottom in a class,
    and from parent to child in a class hierarchy.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化**：为代码中定义的所有静态变量分配值并执行静态块（如果有）。执行顺序是从类的顶部到底部，从类层次结构的父类到子类。'
- en: 'In general, there are three class loaders:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有三个类加载器：
- en: '**Bootstrap class loader**: This loads core-trusted Java API classes located
    in the `JAVA_HOME/jre/lib` directory. These Java APIs are implemented in native
    languages, such as C or C++.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导类加载器**：这加载位于`JAVA_HOME/jre/lib`目录中的核心可信Java API类。这些Java API是用本地语言（如C或C++）实现的。'
- en: '**Extension class loader**: This inherits the Bootstrap class loader. It loads
    the classes from extension directories located at `JAVA_HOME/jre/lib/ext`, or
    any other directory specified by the `java.ext.dirs` system property. It is implemented
    in Java by the `sun.misc.Launcher$ExtClassLoader` class.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展类加载器**：这继承自引导类加载器。它从`JAVA_HOME/jre/lib/ext`目录或`java.ext.dirs`系统属性指定的任何其他目录加载类。它是由`sun.misc.Launcher$ExtClassLoader`类以Java实现的。'
- en: '**System class loader**: This inherits the extension class loader. It loads
    classes from our application classpath. It uses the `java.class.path` environment
    variable.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统类加载器**：这继承自扩展类加载器。它从我们应用程序的类路径加载类。它使用`java.class.path`环境变量。'
- en: To load classes, JVM follows the delegation hierarchy principle. The system
    class loader delegates a request to the extension class loader, and the extension
    class loader delegates the request to the Bootstrap class loader. If a class is
    found in the Bootstrap path, the class is loaded, otherwise, the request will
    be transferred to the extension class loader and then to the system class loader.
    At the end, if the system class loader fails to load the class, then a `java.lang.ClassNotFoundException`
    exception is generated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载类，JVM遵循委托层次原则。系统类加载器将请求委托给扩展类加载器，扩展类加载器将请求委托给引导类加载器。如果在引导路径中找到类，则加载该类，否则将请求转移到扩展类加载器，然后再转移到系统类加载器。最后，如果系统类加载器无法加载类，则会生成`java.lang.ClassNotFoundException`异常。
- en: 'The following diagram illustrates the delegation hierarchy principle:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了委托层次原则：
- en: '![](img/a69d9611-b82a-41b5-a33b-4395f6b52766.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a69d9611-b82a-41b5-a33b-4395f6b52766.jpg)'
- en: Delegation hierarchy principle
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 委托层次原则
- en: Memory areas
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存区域
- en: 'Java runtime memory is divided into five different areas, as shown in the following
    diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java运行时内存分为五个不同的区域，如下图所示：
- en: '![](img/0e01a252-cd4f-468e-af57-7d81a78d933a.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e01a252-cd4f-468e-af57-7d81a78d933a.jpg)'
- en: Memory areas
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 内存区域
- en: 'Let''s look into a brief description of each component:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要描述每个组件：
- en: '**Method Area**: This contains all the class-level information, such as class
    name, parent class, methods, instance, and static variables. There is only one
    method area per JVM, and it is a shared resource.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法区**：这包含所有类级别的信息，如类名、父类、方法、实例和静态变量。每个JVM只有一个方法区，它是一个共享资源。'
- en: '**Heap Area**: This contains the information of all the objects. There is one
    **Heap Area** per JVM. It is also a shared resource. As **Method Area** and **Heap
    Area** are shared memory between multiple threads, the data stored is not thread-safe.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆区**：这包含所有对象的信息。每个JVM有一个**堆区**。它也是一个共享资源。由于**方法区**和**堆区**是多个线程之间的共享内存，所以存储的数据不是线程安全的。'
- en: '**Stack Memory**: JVM creates one runtime stack for every thread in execution
    and stores it in the stack area. Every block of this stack is called an **activation
    record** that stores methods call. All local variables of that method are stored
    in their corresponding frame. The stack area is thread-safe since it is not a
    shared resource. The runtime stack will be destroyed by the JVM up on termination
    of the thread. So, in the case of infinite loops of method calls, we might see
    `StackOverFlowError`, which is due to no memory in the stack for storing method
    calls.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈内存**：JVM为每个正在执行的线程创建一个运行时栈，并将其存储在栈区。这个栈的每个块被称为一个**激活记录**，用于存储方法调用。该方法的所有局部变量都存储在相应的帧中。栈区是线程安全的，因为它不是共享资源。运行时栈将在线程终止时由JVM销毁。因此，在方法调用的无限循环中，我们可能会看到`StackOverFlowError`，这是由于栈中没有足够的内存来存储方法调用。'
- en: '**PC Registers**: These hold the addresses of current instructions under execution.
    Once the instruction is executed, the **PC Registers** will be updated with the
    next instruction. Each thread has a separate **PC Registers**.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PC寄存器**：这些保存正在执行的当前指令的地址。一旦指令执行完毕，**PC寄存器**将被更新为下一条指令。每个线程有一个单独的**PC寄存器**。'
- en: '**Native Method Stacks**: For every thread, a separate native stack is created.
    It stores the native method information. Native information is nothing but native
    method calls.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地方法栈**：为每个线程创建一个单独的本地栈。它存储本地方法信息。本地信息就是本地方法调用。'
- en: Execution engine
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行引擎
- en: 'The execution engine executes bytecode in runtime data areas. It executes bytecode
    by each line and uses the information available in runtime data areas. The execution
    engine can be classified into three parts:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引擎在运行时数据区域执行字节码。它逐行执行字节码，并使用运行时数据区域中可用的信息。执行引擎可以分为三部分：
- en: '**Interpreter**: This reads, interprets, and executes bytecode by each line.
    It interprets and executes bytecode quickly; however, it can be very slow in executing
    interpreted results.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释器**：这逐行读取、解释和执行字节码。它快速解释和执行字节码；然而，在执行解释结果时可能非常缓慢。'
- en: '**Just-In-Time (JIT)**: In order to overcome the interpreter''s slowness in
    executing interpreted results, the JIT compiler converts the bytecode to native
    code once the interpreter interprets the code the first time. Execution happens
    fast with native code; it executes instructions one by one.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时（JIT）**：为了克服解释器在执行解释结果时的缓慢，即时编译器在解释器第一次解释代码后将字节码转换为本机代码。使用本机代码执行速度快；它逐条执行指令。'
- en: '**Garbage collector**: This destroys anything that is not referenced. This
    is very important, so anything not required will be destroyed to create room for
    new execution.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集器：这会销毁任何没有被引用的东西。这非常重要，因此任何不需要的东西都将被销毁，以便为新的执行腾出空间。
- en: Understanding memory leak
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内存泄漏
- en: Java's best benefit is the JVM, which offers memory management out of the box.
    We can create objects and Java's garbage collector takes care of freeing up memory
    for us. Still, memory leaks occur in Java applications. In the following section,
    we will see some common causes of memory leaks and walk through a few solutions
    to detect/avoid them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Java的最大好处是JVM，它提供了开箱即用的内存管理。我们可以创建对象，Java的垃圾收集器会帮我们释放内存。然而，在Java应用程序中会发生内存泄漏。在接下来的部分中，我们将看到一些内存泄漏的常见原因，并介绍一些检测/避免它们的解决方案。
- en: Memory leak in Java
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的内存泄漏
- en: A memory leak occurs when the garbage collector could not collect the objects
    any longer being used/referenced by an application. If the objects are not garbage
    collected, the application uses more memory and, once the entire heap is full,
    the object cannot be allocated, which leads to `OutOfMemoryError`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当垃圾收集器无法收集应用程序不再使用/引用的对象时，就会发生内存泄漏。如果对象没有被垃圾收集，应用程序将使用更多内存，一旦整个堆区满了，对象就无法分配，导致`OutOfMemoryError`。
- en: Heap memory has two types of objects—referenced objects and unreferenced objects.
    The garbage collector will remove all unreferenced objects. However, the garbage
    collector would not be able to remove referenced objects even though they aren't
    used by the application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存有两种对象——被引用的对象和未被引用的对象。垃圾回收器会移除所有未被引用的对象。然而，垃圾回收器无法移除被引用的对象，即使它们没有被应用程序使用。
- en: Common reasons for memory leaks
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存泄漏的常见原因
- en: 'The following are the most common reasons for memory leaks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内存泄漏的最常见原因：
- en: '**Open streams**: While working on streams and readers, we often forget to
    close the streams, which eventually results in the memory leak. There are two
    types of leaks that result from unclosed streams—low-level resource leak and memory
    leak. Low-level resource leak includes OS-level resources, such as file descriptor
    and open connection. As JVM consumes memory to track these resources, it leads
    to memory leak. To avoid leaks, use the `finally` block to close the stream or
    use the autoclose feature of Java 8.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开流：在处理流和读取器时，我们经常忘记关闭流，最终导致内存泄漏。未关闭流导致两种类型的泄漏——低级资源泄漏和内存泄漏。低级资源泄漏包括操作系统级资源，如文件描述符和打开连接。由于JVM消耗内存来跟踪这些资源，这导致内存泄漏。为了避免泄漏，使用`finally`块关闭流，或者使用Java
    8的自动关闭功能。
- en: '**Open connections**: We often forget to close opened HTTP, database, or FTP
    connections, which results in the memory leak. Similar to closing streams, close
    the connections.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开的连接：我们经常忘记关闭已打开的HTTP、数据库或FTP连接，这会导致内存泄漏。与关闭流类似，要关闭连接。
- en: '**Static variables referencing instance objects**: Any static variable referencing
    a heavy object could lead to memory leak because even if the variable is not in
    use, it won''t be garbage collected. To prevent this, try not to have heavy static
    variables; use local variables instead.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态变量引用实例对象：任何引用重对象的静态变量都可能导致内存泄漏，因为即使变量没有被使用，它也不会被垃圾回收。为了防止这种情况发生，尽量不要使用重的静态变量，而是使用局部变量。
- en: '**Missing methods for objects in collection**: Adding objects having no implementation
    of the `equals` and `hashcode` methods to `HashSet` will add the number of duplicate
    objects in `HashSet` and we would not be able to remove these objects once added.
    To prevent this, implement the `equals` and `hashcode` methods in the object added
    to `HashSet`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合中对象缺少方法：向`HashSet`中添加没有实现`equals`和`hashcode`方法的对象会增加`HashSet`中重复对象的数量，一旦添加就无法移除这些对象。为了避免这种情况，在添加到`HashSet`中的对象中实现`equals`和`hashcode`方法。
- en: 'Diagnosing memory leaks is a lengthy process that requires a lot of practical
    experience, debugging skills, and detailed knowledge of the application. The following
    are the ways to diagnose memory leaks:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断内存泄漏是一个需要大量实际经验、调试技能和对应用程序的详细了解的漫长过程。以下是诊断内存泄漏的方法：
- en: Enable GC logs and fine-tune GC parameters
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用GC日志并调整GC参数
- en: Profiling
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Code review
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: In the following sections, we will see GC's common pitfalls, GC methods, and
    tools to analyze GC logs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到GC的常见陷阱、GC方法和分析GC日志的工具。
- en: Common pitfalls
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: Performance tuning is critical, and things can start getting hairy with one
    small JVM flag. JVM is subject to GC pauses, which vary in frequency and duration.
    During a pause, everything stops and all kinds of unexpected behaviors start. During
    pauses and unstable behavior where JVM gets stuck, performance is impacted. We
    can see the symptoms of slow response times, high CPU, and memory utilization,
    or the system acts normally most of the time but behaves weirdly, such as performing
    extremely slow transactions and disconnections.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 性能调优至关重要，只需一个小的JVM标志，事情就可能变得复杂。JVM会出现GC暂停，频率和持续时间各不相同。在暂停期间，一切都会停止，各种意外行为开始出现。在暂停和不稳定行为的情况下，JVM被卡住，性能受到影响。我们可以看到响应时间变慢、CPU和内存利用率高，或者系统大部分时间表现正常，但偶尔出现异常行为，比如执行极慢的事务和断开连接。
- en: The majority of the time, we measure the average transaction time and ignore
    the outliers that cause unstable behavior. Most of the time a system behaves normally,
    however at certain points, system responsiveness degrades. The majority of the
    time, the reason for this low performance is due to low awareness of GC overhead
    and focusing on only average response times.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分时间我们测量平均事务时间，忽略导致不稳定行为的异常值。大部分时间系统表现正常，但在某些时刻，系统响应性下降。这种低性能的原因大部分是由于对GC开销的低意识和只关注平均响应时间。
- en: 'When defining performance requirements, an important question we need to answer
    is: What are the acceptable criteria for our application related to GC pause frequency
    and duration? Requirements vary from application to application, so based on our
    application and user experience, we need to first define these criteria.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义性能要求时，我们需要回答一个重要问题：与GC暂停频率和持续时间相关的应用程序的可接受标准是什么？要求因应用程序而异，因此根据我们的应用程序和用户体验，我们需要首先定义这些标准。
- en: A few common misunderstandings we usually have are as follows.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常存在一些常见的误解。
- en: Number of garbage collectors
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收器的数量
- en: Most of the time, people are not aware that there isn't only one, but four,
    garbage collectors. The four garbage collectors are—**Serial**, **Parallel**,
    **Concurrent**, and **Garbage First** (**G1**). We will see them in the following
    section. There are some third-party garbage collectors, such as **Shenandoah**.
    JVM HotSpot's default garbage collector is Parallel up to Java 8, while from Java
    9, the default collector is **Garbage First Garbage Collector** (**G1 GC**). A
    Parallel garbage collector isn't best most of the time; however, it depends on
    our application requirements. For example, the **Concurrent Mark Sweep** (**CMS**)
    and G1 collectors cause less frequent GC pauses. But when they do cause a pause,
    the pause duration will most likely be longer than a pause caused by the Parallel
    collector. On the other hand, the Parallel collector usually achieves higher throughput
    for the same heap size.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，人们并不知道不只有一个，而是四个垃圾收集器。这四个垃圾收集器是——**串行**，**并行**，**并发**和**垃圾优先**（**G1**）。我们将在下一节中看到它们。还有一些第三方垃圾收集器，比如**Shenandoah**。JVM
    HotSpot的默认垃圾收集器在Java 8之前是并行的，而从Java 9开始，默认收集器是**垃圾优先垃圾收集器**（**G1 GC**）。并行垃圾收集器并不总是最好的；然而，这取决于我们的应用程序需求。例如，**并发标记清除**（**CMS**）和G1收集器导致GC暂停的频率较低。但是当它们导致暂停时，暂停持续时间很可能比并行收集器导致的暂停时间长。另一方面，对于相同的堆大小，并行收集器通常能实现更高的吞吐量。
- en: Wrong garbage collector
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误的垃圾收集器
- en: A common reason for the GC issue is the wrong choice of garbage collector for
    the type of application. Each collector has their own significance and benefits.
    We need to find our application's behavior and priorities and based on which we
    need to choose right garbage collector. The default garbage collector of HotSpot's is
    Parallel/Throughput and, most of time, it hasn't proven to be a good choice. The
    CMS and G1 collector are concurrent and cause less frequent pauses, but when a
    pause does come, its duration is longer than the Parallel collector. So the choice
    of the collector is a common mistake we often make.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: GC问题的一个常见原因是选择了错误的垃圾收集器。每个收集器都有其自己的重要性和好处。我们需要找出我们应用程序的行为和优先级，然后根据这些来选择正确的垃圾收集器。HotSpot的默认垃圾收集器是并行/吞吐量，大多数情况下并不是一个好选择。CMS和G1收集器是并发的，导致暂停的频率较低，但当暂停发生时，其持续时间比并行收集器长。因此，选择收集器是我们经常犯的一个常见错误。
- en: Parallel / Concurrent keywords
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行/并发关键字
- en: A GC can either cause a **s****top-the-world** (**STW**) situation, or objects
    can be collected concurrently without stopping the application. The GC algorithm
    can be executed in a single thread or in multithread. So, Concurrent GC does not
    mean it executes in parallel, whereas Serial GC doesn't mean it causes more pauses
    due to serial execution. Concurrent and Parallel are different, where Concurrent
    means the GC cycle, and Parallel means the GC algorithm.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GC可能会导致**全局停顿**（**STW**）的情况，或者对象可以在不停止应用程序的情况下并发收集。GC算法可以在单线程或多线程中执行。因此，并发GC并不意味着它是并行执行的，而串行GC并不意味着它由于串行执行而导致更多的暂停。并发和并行是不同的，其中并发表示GC周期，而并行表示GC算法。
- en: G1 is a problem solver
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G1是一个问题解决者
- en: With the introduction of the new garbage collector in Java 7, many people think
    that it is the problem solver to all previous garbage collectors. An important
    problem solved by G1 GC is the fragmentation problem, which is common to the CMS
    collector. However, in many cases other collectors can outperform G1 GC. So it
    all depends on our application's behavior and requirements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 7引入新的垃圾收集器，许多人认为它是解决以前所有垃圾收集器问题的问题解决者。G1 GC解决的一个重要问题是碎片问题，这是CMS收集器常见的问题。然而，在许多情况下，其他收集器可能会胜过G1
    GC。因此，一切取决于我们应用程序的行为和需求。
- en: Average transaction time
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平均事务时间
- en: Mostly, while testing performance, we tend to measure average transaction time
    and, by only doing that, we miss the outliers. At some point, when GC causes pauses
    for a long duration, the application's response time increases drastically, which
    affects users accessing the application. This can go unnoticed, as we are only
    looking at the average transaction time. When the GC pause frequency increases,
    response time becomes a serious problem that we might have ignored by just measuring
    the average response time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，在测试性能时，我们倾向于测量平均事务时间，但仅这样做会忽略异常值。当GC导致长时间暂停时，应用程序的响应时间会急剧增加，影响用户访问应用程序。这可能会被忽视，因为我们只关注平均事务时间。当GC暂停频率增加时，响应时间成为一个严重的问题，我们可能会忽略只测量平均响应时间而忽略的问题。
- en: Reducing new object allocation rates improves GC behavior
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少新对象分配率可以改善GC行为
- en: 'Instead of focusing or reducing the new object allocation rate, we should focus
    on the life of objects. There are three different types of objects lives: long-lived
    objects, we cannot do much about them; mid-lived objects, these cause the biggest
    issues; and short-lived objects, which usually get freed and allocated quickly
    so they are collected by the next GC cycle. So instead of concentrating on long-lived
    and short-lived objects, focusing on the mid-lived objects allocation rate could
    bring positive results. It''s not the object allocation rate alone; it''s the
    type of objects in play that causes all the trouble.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与其专注于减少新对象分配率，我们应该专注于对象的生命周期。有三种不同类型的对象生命周期：长期对象，我们对它们无能为力；中期对象，这些会导致最大的问题；和短期对象，通常会被快速释放和分配，因此它们会在下一个GC周期中被收集。因此，与其专注于长期和短期对象，专注于中期对象的分配率可能会带来积极的结果。问题不仅仅在于对象分配率，而是在于所涉及的对象类型。
- en: GC logs cause overhead
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC日志会导致开销
- en: 'It is not true that GC logs cause overhead, especially in the default log settings.
    The data is extremely valuable and Java 7 introduced hooks to control the size
    of their log files. If we don''t collect GC logs with timestamps, then we are
    missing out on a critical source of data to analyze and solve pausing issues.
    GC logs are the richest source of data for the state of GC in a system. We can
    get data about all GC events in our application; say, it is completed concurrently
    or caused an STW pause: how long did it take, how much CPU it consumed, and how
    much memory was freed. From this data, we would be able to understand the frequency
    and duration of pauses, their overhead, and move on to take action to reduce them.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: GC日志并不会导致开销，尤其是在默认日志设置中。这些数据非常有价值，Java 7引入了控制日志文件大小的钩子。如果我们不收集带有时间戳的GC日志，那么我们就错过了分析和解决暂停问题的关键数据来源。GC日志是系统中GC状态的最丰富的数据来源。我们可以获得关于应用程序中所有GC事件的数据；比如，它是并发完成的还是导致了STW暂停：花了多长时间，消耗了多少CPU，释放了多少内存。通过这些数据，我们将能够了解暂停的频率和持续时间，它们的开销，并采取行动来减少它们。
- en: 'Enable GC by adding following arguments:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下参数启用GC：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: GC
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC
- en: One of Java's best achievements is GC. The GC process automatically manages
    memory and heap allocation that tracks down dead objects, removes them, and reallocates
    memory to a new object. Theoretically, as garbage collector automatically manages
    memory, it makes developers create new objects without thinking about the allocation
    and deallocation of memory to eliminate memory leaks and other problems related
    to memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Java最大的成就之一就是GC。GC进程自动管理内存和堆分配，跟踪死对象，删除它们，并将内存重新分配给新对象。理论上，由于垃圾收集器自动管理内存，开发人员可以创建新对象而不必考虑内存的分配和释放，以消除内存泄漏和其他与内存相关的问题。
- en: How GC works
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC的工作原理
- en: We usually think that GC collects and removes the unreferenced objects. Instead,
    GC in Java tracks live objects and marks all unreferenced objects as garbage.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们认为GC收集并删除未引用的对象。相反，Java中的GC跟踪活动对象，并将所有未引用的对象标记为垃圾。
- en: 'The heap area of the memory is where objects are allocated dynamically. We
    should allocate heap memory to JVM before running the application. Allocating
    heap to JVM in advance has a couple of consequences:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 内存的堆区是动态分配对象的地方。在运行应用程序之前，我们应该为JVM分配堆内存。提前为JVM分配堆会产生一些后果：
- en: Improves object creation rate because JVM doesn't need to communicate with the
    OS to get memory for each new object. Once the JVM allocates memory to an object,
    JVM moves the pointer toward the next available memory.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高对象创建速率，因为JVM不需要与操作系统通信为每个新对象获取内存。一旦JVM为对象分配了内存，JVM就会将指针移向下一个可用内存。
- en: Garbage collectors collect the object when there is no object reference and
    reuse its memory for new object allocation. As the garbage collector doesn't delete
    the object, no memory is returned to the OS.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有对象引用时，垃圾收集器收集对象并重用其内存以分配新对象。由于垃圾收集器不删除对象，因此不会将内存返回给操作系统。
- en: Until the objects are being referenced, JVM considers them live objects. When
    an object is no longer referenced and is not reachable by the application code,
    the garbage collector removes it and reclaims its memory. We get a question in
    our mind, who is the first reference in the tree of objects, right? Let's see
    the object tree and its roots.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 直到对象被引用，JVM认为它们是活动对象。当一个对象不再被引用并且不可被应用程序代码访问时，垃圾收集器将其删除并回收其内存。我们会想到一个问题，对象树中的第一个引用是谁？让我们看看对象树及其根。
- en: GC roots
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC根
- en: Each tree of an object has one or more objects at the root. If the garbage collector
    can reach the root, the tree is reachable. Any object that is not reached by,
    or referenced by, GC roots is considered dead and the garbage collector removes
    it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的每个树都有一个或多个对象作为根。如果垃圾收集器可以到达根，那么该树是可达的。任何未被GC根引用或引用的对象都被视为死对象，垃圾收集器将其删除。
- en: 'Here are the different kinds of GC roots in Java:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java中不同类型的GC根：
- en: '**Local variables: **Variables or parameters of a Java method.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量：**Java方法的变量或参数。'
- en: '**Active threads:** A running thread is a live object.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动线程：**正在运行的线程是一个活动对象。'
- en: '**Static variables:** Classes referencing static variables. When the garbage
    collector collects classes, it removes references to static variables.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态变量：**引用静态变量的类。当垃圾收集器收集类时，它会删除对静态变量的引用。'
- en: '**JNI references:** Object reference created during the JNI call. They are
    kept alive because JVM is unaware that the native code has references of it.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JNI引用：**在JNI调用期间创建的对象引用。它们保持活动状态，因为JVM不知道本地代码对它的引用。'
- en: 'Please have a look at the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请看下面的图表：
- en: '![](img/659a24ab-1fe8-43dd-a409-8b29f771150d.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/659a24ab-1fe8-43dd-a409-8b29f771150d.jpg)'
- en: GC roots
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: GC根
- en: GC methods and policies
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC方法和策略
- en: As we learned in the preceding section, there isn't one but four different garbage
    collectors. Each one has its own advantages and disadvantages. The one thing these
    collectors have in common is that they split the managed heap into different segments
    with the assumption that objects are short-lived and should be removed shortly.
    Let's see four different algorithms of GC.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分中学到的，不只有一个，而是四种不同的垃圾收集器。每种都有其自己的优点和缺点。这些收集器共同的一点是它们将托管堆分成不同的段，假设对象的寿命很短，应该很快被移除。让我们看看GC的四种不同算法。
- en: Serial collector
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 串行收集器
- en: The Serial collector is the simplest GC implementation, mainly designed for
    single-threaded environments and small heaps. This GC implementation freezes all
    application threads whenever it's working. Hence, it's not a good idea to use
    it in multithreaded applications, such as server environments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 串行收集器是最简单的GC实现，主要设计用于单线程环境和小堆。这种GC实现在工作时会冻结所有应用程序线程。因此，在多线程应用程序中使用它并不是一个好主意，比如服务器环境。
- en: To enable the Serial garbage collector, set `-XX:+UseSerialGC` to VM arguments
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用串行垃圾收集器，请将`-XX:+UseSerialGC`设置为VM参数
- en: Parallel/Throughput collector
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行/吞吐量收集器
- en: The Parallel collector is the JVM's default collector and is also known as the
    Throughput collector. As the name suggests, this collector, unlike the Serial
    collector, uses multithread to manage the heap memory. The Parallel garbage collector
    still freezes all the application threads when performing either minor or full
    GC. If we want to use the Parallel garbage collector, we should specify the tuning
    parameters, such as threads, pause time, throughput, and footprints.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 并行收集器是JVM的默认收集器，也被称为吞吐量收集器。顾名思义，这个收集器与串行收集器不同，它使用多线程来管理堆内存。并行垃圾收集器在执行部分或完整的GC时仍会冻结所有应用程序线程。如果我们想使用并行垃圾收集器，我们应该指定调优参数，如线程、暂停时间、吞吐量和占用空间。
- en: 'The following are the arguments to specify the tuning parameters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是指定调优参数的参数：
- en: Threads: `-XX:ParallelGCThreads=<N>`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程：`-XX:ParallelGCThreads=<N>`
- en: Pause time: `-XX:MaxGCPauseMillis=<N>`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停时间：`-XX:MaxGCPauseMillis=<N>`
- en: 'Throughput: `-XX:GCTimeRatio=<N>`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吞吐量：`-XX:GCTimeRatio=<N>`
- en: Footprint (maximum heap size): `-Xmx<N>`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 占用空间（最大堆大小）：`-Xmx<N>`
- en: To enable the Parallel garbage collector in our application, set the `-XX:+UseParallelGC`
    option.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中启用并行垃圾收集器，请设置`-XX:+UseParallelGC`选项。
- en: CMS garbage collector
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMS垃圾收集器
- en: The CMS implementation uses multiple garbage collector threads to scan (mark)
    the unused objects that can be removed (sweep). This garbage collector is preferable
    for applications that require short GC pauses, and who can share processor resources
    with the garbage collector while the application is running.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CMS实现使用多个垃圾收集器线程来扫描（标记）可以被移除的未使用对象（清除）。这种垃圾收集器适用于需要短暂GC暂停的应用程序，并且在应用程序运行时可以与垃圾收集器共享处理器资源。
- en: 'The CMS algorithm enters into STW mode in only two cases: when objects in Old
    Generations are still referenced from the thread entry point or static variables,
    and when the application changed the state of the heap while CMS is running which
    makes the algorithm go back and reiterate the object tree to validate that it
    had marked the correct objects.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CMS算法只在两种情况下进入STW模式：当Old Generations中的对象仍然被线程入口点或静态变量引用时，以及当应用程序在CMS运行时改变了堆的状态，使算法返回并重新迭代对象树以验证它已标记正确的对象。
- en: With this collector, promotion failure is the greatest cause for concern. Promotion
    failure occurs when a race condition occurs between a collection of objects from
    the Young and Old Generations. If the collector needs to promote objects from
    the Young Generation to the Old Generation and there is not enough space, it has
    to first STW to create the space. In order to make sure this doesn't happen in
    the case of the CMS collector, increase the size of the Old Generation or allocate
    more background thread to the collector to compete with the allocation rate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个收集器，晋升失败是最大的担忧。晋升失败发生在Young和Old Generations的对象收集之间发生竞争条件时。如果收集器需要将对象从Young
    Generation晋升到Old Generation，而没有足够的空间，它必须首先STW来创建空间。为了确保在CMS收集器的情况下不会发生这种情况，增加Old
    Generation的大小或为收集器分配更多的后台线程来与分配速率竞争。
- en: In order to provide high throughput, CMS uses more CPU to scan and collect objects.
    It is good for long-running server applications, which are adverse to application
    freezes. So, if we can allocate more CPU to avoid application pauses, we can choose
    the CMS collector for GC in our application. To enable the CMS collector, set
    the -`XX:+UseConcMarkSweepGC` option.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供高吞吐量，CMS使用更多的CPU来扫描和收集对象。这对于长时间运行的服务器应用程序是有利的，这些应用程序不希望应用程序冻结。因此，如果我们可以分配更多的CPU来避免应用程序暂停，我们可以选择CMS收集器作为应用程序中的GC。要启用CMS收集器，请设置`-XX:+UseConcMarkSweepGC`选项。
- en: G1 collector
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G1收集器
- en: This is the new collector, introduced in JDK 7 update 4\. The G1 collector is
    designed for an application willing to allocate heap memory of more than 4 GB.
    G1 divides the heap into multiple regions, spanning from 1 MB to 32 MB, depending
    on the heap we configure and uses multiple background threads to scan through
    the heap regions. The benefit of dividing the heap into multiple regions is that
    G1 will scan through regions where there is plenty of garbage first in order to
    meet a given pause time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在JDK 7更新4中引入的新收集器。G1收集器设计用于愿意分配超过4GB堆内存的应用程序。G1将堆分成多个区域，跨越从1MB到32MB的范围，取决于我们配置的堆，并使用多个后台线程来扫描堆区域。将堆分成多个区域的好处是，G1将首先扫描有大量垃圾的区域，以满足给定的暂停时间。
- en: G1 reduces the change of low-heap availability before the background threads
    have finished scanning for unused objects. This reduced the chances to STW. G1
    compacts the heap on-the-go, unlike CMS, which does this during STW.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: G1减少了后台线程完成未使用对象扫描之前低堆可用性的机会。这减少了STW的机会。G1在进行堆压缩时是动态的，而CMS是在STW期间进行的。
- en: In order to enable the G1 garbage collector in our application, we need to set
    the `-XX:+UseG1GC` option in the JVM parameters.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中启用G1垃圾收集器，我们需要在JVM参数中设置`-XX:+UseG1GC`选项。
- en: Java 8 update 20 introduced a new JVM argument, `-XX:+UseStringDeduplication`,
    for the G1 collector. With this argument, G1 identifies duplicate strings and
    creates the pointer to the same integral `char[]` array to avoid multiple copies
    of the same string.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8更新20引入了一个新的JVM参数，`-XX:+UseStringDeduplication`，用于G1收集器。通过这个参数，G1识别重复的字符串，并创建指向相同的`char[]`数组的指针，以避免多个相同字符串的副本。
- en: From Java 8 `PermGen`, part of the heap is removed. This was the part that was
    allocated for class metadata, static variables, and interned strings. This parameter-tuning
    caused many `OutOfMemory` exceptions, which would be fine from Java 8 onward,
    where JVM would take care of it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 8开始，PermGen的一部分堆被移除。这部分堆是为类元数据、静态变量和interned字符串分配的。这种参数调优导致了许多`OutOfMemory`异常，在Java
    8之后，JVM会处理这些异常。
- en: Heap memory
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆内存
- en: 'Heap memory is divided into primarily two generations: Young Generation and
    Old Generation. There is a **PERM GENERATION** that is a part of heap memory until
    Java 7, while from Java 8, the **PERM GENERATION** is replaced by **METASPACE**.
    **METASPACE** is not part of the heap memory but is part of the **Native Memory**.
    Set size of **METASPACE** using the `-XX:MaxMetaspaceSize` option. It is critical
    to consider this setting when going to production since if **METASPACE** takes
    up excessive memory, it affects the application''s performance:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存主要分为两代：年轻代和老年代。在Java 7之前，堆内存中有一个**PERM GENERATION**，而从Java 8开始，**PERM GENERATION**被**METASPACE**取代。**METASPACE**不是堆内存的一部分，而是**本地内存**的一部分。使用`-XX:MaxMetaspaceSize`选项设置**METASPACE**的大小。在投入生产时，考虑此设置至关重要，因为如果**METASPACE**占用过多内存，会影响应用程序的性能：
- en: '![](img/3c93fe61-8690-43ce-9362-ff57c083d627.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c93fe61-8690-43ce-9362-ff57c083d627.png)'
- en: Java 8 memory management
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8内存管理
- en: 'The **Young Generation** is where objects are created and allocated; it''s
    for young objects. The **Young Generation** is further divided into **Survivor
    Space**. The following is the **Hotspot Heap Structure**:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**年轻代**是对象创建和分配的地方；它是为年轻对象而设的。**年轻代**进一步分为**幸存者空间**。以下是**Hotspot堆结构**：'
- en: '![](img/f239e0c8-d541-4a54-9646-068d5a38f0ec.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f239e0c8-d541-4a54-9646-068d5a38f0ec.jpg)'
- en: 'The **eden** area is, by default, bigger than **Survivor Space**. All the objects
    are created first in the **eden** area. When **eden** is full, minor GC is triggered,
    which will quickly scan the object''s references, and unreferenced objects are
    marked dead and collected. The **Survivor Space** area in either of them would
    always be empty. Objects that survived in **eden** during minor GC will be moved
    to the empty **Survivor Space**. We might wonder why there are two **Survivor
    Space **areas and not one. The reason is to avoid memory fragmentation. When the
    **Young Generation** runs through and removes dead objects from the **Survivor
    Space**, it leaves holes in the memory and needs compaction. To avoid compaction,
    JVM moves surviving objects from one **Survivor Space** to another. This ping-pong
    of live objects from **eden** and one **Survivor Space** to another happens until
    the following conditions occur:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**伊甸园**区域默认比**幸存者空间**大。所有对象首先都是在**伊甸园**区域中创建的。当**伊甸园**满时，将触发小型GC，它将快速扫描对象的引用，并标记未引用的对象为死亡并进行收集。**幸存者空间**中的任何一个区域始终为空。在小型GC期间在**伊甸园**中幸存的对象将被移至空的**幸存者空间**。我们可能会想为什么有两个**幸存者空间**而不是一个。原因是为了避免内存碎片化。当**年轻代**运行并从**幸存者空间**中删除死对象时，会在内存中留下空洞并需要压缩。为了避免压缩，JVM将幸存对象从一个**幸存者空间**移至另一个。这种从**伊甸园**和一个**幸存者空间**到另一个的活对象的乒乓运动会持续，直到出现以下条件：'
- en: Objects reach maximum tenuring threshold. This means objects are no longer young.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象达到最大tenuring阈值。这意味着对象不再年轻。
- en: '**Survivor Space** is full and cannot accommodate any new objects.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幸存者空间**已满，无法容纳任何新对象。'
- en: When the preceding conditions happen, objects are moved to the **Old Generation**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现上述条件时，对象将被移至**老年代**。
- en: JVM flags
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM标志
- en: The following are the JVM parameters/flags commonly used in applications to
    tune the JVM for better performance. Tuning values depend on our application's
    behavior and the rate at which it is generated. So there is no defined guideline
    to use specific values for JVM flags in order to achieve better performance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用程序中常用的用于调整JVM以获得更好性能的JVM参数/标志。调整值取决于我们应用程序的行为以及生成速率。因此，没有明确定义的指南来使用特定值的JVM标志以实现更好的性能。
- en: -Xms and -Xmx
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -Xms和-Xmx
- en: The `-Xms` and `-Xmx` are known as the minimum and maximum heap size. Setting `-Xms` equal
    to `-Xmx` prevents GC pauses during heap expansion and improves performance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Xms`和`-Xmx`被称为最小和最大堆大小。将`-Xms`设置为等于`-Xmx`可以防止堆扩展时的GC暂停，并提高性能。'
- en: -XX:NewSize and -XX:MaxNewSize
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -XX:NewSize和-XX:MaxNewSize
- en: We can set the size of the Young Generation using `-XX:MaxNewSize`. The Young
    Generation resides under the total heap memory and the Old Generation size will
    be smaller if we set the size of the Young Generation as large. The Young Generation
    size should never be larger than the Old Generation for stability reasons. Thus, `-Xmx/2`
    is the maximum size we can set for `-XX:MaxNewSize`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-XX:MaxNewSize`设置年轻代的大小。如果我们将年轻代的大小设置得很大，那么老年代的大小将会较小。出于稳定性的原因，年轻代的大小不应该大于老年代。因此，`-Xmx/2`是我们可以为`-XX:MaxNewSize`设置的最大大小。
- en: To achieve better performance, set the initial size of the Young Generation
    by setting the `-XX:NewSize` flag. This saves some costs in terms of the Young
    Generation growing to that size over time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更好的性能，通过设置`-XX:NewSize`标志来设置年轻代的初始大小。这样可以节省一些成本，因为年轻代随着时间的推移会增长到该大小。
- en: -XX:NewRatio
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -XX:NewRatio
- en: We can set the size of the Young Generation as a ratio of the Old Generation
    using the `-XX:NewRatio` option. The benefit we can get with this option could
    be that the Young Generation can grow and shrink when JVM adjusts the total heap
    size during execution. `-XX:NewRatio` means the ratio of Old Generation is larger
    than the Young Generation. `-XX:NewRatio=2` means the size of the Old Generation
    is twice that of the Young Generation, which further means that the Young Generation
    is 1/3 of the total heap.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-XX:NewRatio`选项将年轻代的大小设置为老年代的比例。使用此选项的好处可能是，当JVM在执行过程中调整总堆大小时，年轻代可以增长和收缩。`-XX:NewRatio`表示老年代的比例大于年轻代。`-XX:NewRatio=2`表示老年代的大小是年轻代的两倍，这进一步意味着年轻代是总堆的1/3。
- en: If we specify ratio and a fixed size for the Young Generation, then the fixed
    size will take precedence. There is no generation rule regarding which method
    of specifying the size of the Young Generation is preferable. The rule of thumb
    here is that if you know the size of the objects generated by our application,
    then specify the fixed size, otherwise, specify the ratio.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定了Young Generation的比例和固定大小，那么固定大小将优先。关于指定Young Generation大小的方法没有一定的规则。这里的经验法则是，如果我们知道应用程序生成的对象的大小，那么指定固定大小，否则指定比例。
- en: -XX:SurvivorRatio
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -XX:SurvivorRatio
- en: The `-XX:SurvivorRatio` value is the ratio of eden relative to Survivor Spaces.
    There will be two Survivor Spaces and each one would be equal to the other. If `-XX:SurvivorRatio=8`,
    then eden occupies 3/4 and each Survivor Spaces occupies 1/4 of the total Old
    Generation size.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`-XX:SurvivorRatio`值是Eden相对于Survivor Spaces的比例。将有两个Survivor Spaces，每个都相等。如果`-XX:SurvivorRatio=8`，那么Eden占3/4，每个Survivor
    Spaces占老年代总大小的1/4。'
- en: If we set a ratio such that Survivor Spaces are small, then eden will make more
    space for new objects. During minor GC, unreferenced objects will be collected
    and eden will be empty for new objects, however, if the object still has references,
    then the garbage collector moves them to the Survivor Space. If the Survivor Space
    is small and cannot accommodate the new object, then the objects will be moved
    to the Old Generation. Objects in the Old Generation can only be collected during
    full GC, which creates long pauses in the application. And if the Survivor Space
    is large enough, then more objects can live in the Survivor Space but die young.
    If the Survivor Spaces are large, eden would be small, and a small eden would
    cause frequent young GC.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置了Survivor Spaces很小的比例，那么Eden将为新对象腾出更多空间。在Minor GC期间，未引用的对象将被收集，Eden将为空出来给新对象，但是如果对象仍然有引用，垃圾收集器会将它们移动到Survivor
    Space。如果Survivor Space很小，无法容纳新对象，那么对象将被移动到老年代。老年代中的对象只能在Full GC期间被收集，这会导致应用程序长时间暂停。如果Survivor
    Space足够大，那么更多的对象可以存活在Survivor Space中，但会死得很快。如果Survivor Spaces很大，Eden将会很小，而小的Eden会导致频繁的Young
    GC。
- en: -XX:InitialTenuringThreshold, -XX:MaxTenuringThreshold, and -XX:TargetSurvivorRatio
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -XX:InitialTenuringThreshold、-XX:MaxTenuringThreshold和-XX:TargetSurvivorRatio
- en: The tenuring threshold decides when an object can be promoted/moved from the
    Young Generation to the Old Generation. We can set the initial and maximum value
    of the tenuring threshold using the `-XX:InitialTenuringThreshold` and `-XX:MaxTenuringThreshold` JVM
    flags. We can also use `-XX:TargetSurvivorRatio` to specify the target utilization
    (as a percentage) of the Survivor Space at the end of a Young Generation GC.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Tenuring阈值决定了对象何时可以从Young Generation晋升/移动到Old Generation。我们可以使用`-XX:InitialTenuringThreshold`和`-XX:MaxTenuringThreshold`
    JVM标志来设置tenuring阈值的初始值和最大值。我们还可以使用`-XX:TargetSurvivorRatio`来指定Young Generation
    GC结束时Survivor Space的目标利用率（以百分比表示）。
- en: -XX:CMSInitiatingOccupancyFraction
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -XX:CMSInitiatingOccupancyFraction
- en: Use the `-XX:CMSInitiatingOccupancyFraction=85` option when using the CMS collector
    (`-XX:+UseConcMarkSweepGC`). If the flag is set and the Old Generation is 85%
    full, the CMS collector starts collecting unreferenced objects. It is not necessary
    that CMS will start collection only after the Old Generation 85% occupied. If
    we want CMS to start only at 85%, then we need to set `-XX:+UseCMSInitiatingOccupancyOnly`.
    The default value of the `-XX:CMSInitiatingOccupancyFraction` flag is 65%.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用CMS收集器（-XX:+UseConcMarkSweepGC）时，使用`-XX:CMSInitiatingOccupancyFraction=85`选项。如果设置了该标志，并且老年代占用了85%，CMS收集器将开始收集未引用的对象。并不是必须老年代占用了85%
    CMS才开始收集。如果我们希望CMS只在85%时开始收集，那么需要设置`-XX:+UseCMSInitiatingOccupancyOnly`。`-XX:CMSInitiatingOccupancyFraction`标志的默认值为65%。
- en: -XX:+PrintGCDetails, -XX:+PrintGCDateStamps, and -XX:+PrintTenuringDistribution
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -XX:+PrintGCDetails、-XX:+PrintGCDateStamps和-XX:+PrintTenuringDistribution
- en: Flags are set to generate GC logs. In order to fine-tune JVM parameters to achieve
    better performance, it is important to understand GC logs and the behavior of
    the application. `-XX:+PrintTenuringDistribution` reports the statistics of an
    object (how old they are) and the desired threshold of objects when they are promoted.
    This is very important to understand how our application is holding the objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 设置标志以生成GC日志。为了微调JVM参数以实现更好的性能，了解GC日志和应用程序的行为非常重要。`-XX:+PrintTenuringDistribution`报告对象的统计信息（它们的年龄）以及它们晋升时的期望阈值。这对于了解我们的应用程序如何持有对象非常重要。
- en: Tools to analyze GC logs
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析GC日志的工具
- en: 'The Java GC logs are one of the places where we can start debugging an application
    in the event of a performance issue. The GC logs provide important information,
    such as:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Java GC日志是我们在性能问题发生时可以开始调试应用程序的地方之一。GC日志提供重要信息，例如：
- en: The last time the GC ran
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC上次运行的时间
- en: The number of GC cycles run
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC循环运行的次数
- en: The interval at which the GC ran
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC运行的间隔
- en: The amount of memory freed up after the GC ran
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC运行后释放的内存量
- en: The time the GC took to run
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC运行的时间
- en: The amount of time for which the JVM paused when the garbage collector ran
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集器运行时JVM暂停的时间
- en: The amount of memory allocated to each generation
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给每个代的内存量
- en: 'The following is the sample GC logs:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是样本GC日志：
- en: '[PRE1]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These logs are very difficult to interpret quickly. If we have a tool that can
    render these logs in a visual interface, it would be easy and quick to understand
    what is going on with the GC. We will take a look at one such tool to interpret
    the GC logs in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志很难快速解释。如果有一个工具可以将这些日志呈现在可视化界面中，那么就可以轻松快速地理解GC的情况。我们将在下一节中看一下这样的工具来解释GC日志。
- en: GCeasy
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCeasy
- en: GCeasy is one of the most popular garbage collection log analysis tools. GCeasy
    is developed to identify problems from the GC logs automatically. It is intelligent
    enough to provide alternative ways to solve problems.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GCeasy是最受欢迎的垃圾收集日志分析工具之一。GCeasy被开发出来自动从GC日志中识别问题。它足够智能，可以提供解决问题的替代方法。
- en: 'The following are the important basic features provided by GCeasy:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GCeasy提供的重要基本功能：
- en: Uses machine learning algorithms to analyze the logs
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用机器学习算法分析日志
- en: Quickly detects memory leaks, premature object promotions, long JVM pauses,
    and many other performance issues
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速检测内存泄漏、过早对象晋升、长时间的JVM暂停以及许多其他性能问题
- en: Powerful and informative visual analyzer
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能强大且信息丰富的可视化分析工具
- en: Provides the REST API for proactive log analysis
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供用于主动日志分析的REST API
- en: Free cloud-based tool for log analysis
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费的基于云的日志分析工具
- en: Provides suggestions on the JVM heap size
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供有关JVM堆大小的建议
- en: Equipped to analyze all formats of GC logs
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够分析所有格式的GC日志
- en: GCeasy.io ([http://www.gceasy.io/](http://www.gceasy.io/)) is the online garbage
    collection log analysis tool. It requires the log files to be uploaded on the
    GCeasy public cloud.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: GCeasy.io ([http://www.gceasy.io/](http://www.gceasy.io/))是在线垃圾收集日志分析工具。它需要将日志文件上传到GCeasy公共云。
- en: 'The following are the steps to gather detailed log analysis using the online
    tool:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在线工具收集详细的日志分析的步骤如下：
- en: Enable GC logs in the application by adding `XX:+PrintGCDetails -XX:+PrintGCDateStamps
    -Xloggc:<GC-log-file-path>` in the JVM parameters on the server.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在服务器的JVM参数中添加`XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:<GC-log-file-path>`来在应用程序中启用GC日志。
- en: Once the GC log file is generated at a specified location, upload the file to
    the GCeasy cloud by navigating to [http://gceasy.io/](http://gceasy.io/). It is
    also possible to upload a compressed ZIP file in case there are multiple log files
    to be analyzed.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在指定位置生成了GC日志文件，通过导航到[http://gceasy.io/](http://gceasy.io/)将文件上传到GCeasy云。如果有多个日志文件需要分析，也可以上传压缩的ZIP文件。
- en: Once the log files are processed, the detailed analysis report will be generated.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理日志文件后，将生成详细的分析报告。
- en: The report is properly organized and detailed enough to highlight every possible
    problem causing the performance hit. The following section explains the important
    sections in the report generated by GCeasy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 报告组织得当且详细到足以突出每一个可能导致性能下降的问题。以下部分解释了GCeasy生成的报告中的重要部分。
- en: Tips on JVM tuning
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM调优提示
- en: 'The top section in the report provides suggestions based on the garbage-collection-log
    analysis. The suggestions are generated dynamically by machine learning algorithms
    after a thorough analysis of the log files. The details in the suggestion also
    include the probable cause of the issue. The following is an example suggestion
    provided by GCeasy after GC log analysis:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 报告中的顶部部分根据垃圾收集日志分析提供建议。这些建议是通过机器学习算法动态生成的，经过对日志文件的彻底分析。建议中的细节还包括问题的可能原因。以下是GCeasy在GC日志分析后提供的一个示例建议：
- en: '![](img/a9d60f2f-d1d0-4b46-9d97-627b209fc693.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9d60f2f-d1d0-4b46-9d97-627b209fc693.jpg)'
- en: JVM Heap Size
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM堆大小
- en: 'This section in the report provides information on the heap allocation and
    peak memory usage for each memory generation. It is possible that the allocated
    heap size may not match the one defined in the JVM parameters. This is because
    the GCeasy tool obtains the allocated memory information from the logs. It is
    possible that we have allocated 2 GB of heap memory, but at runtime, JVM could
    allocate only 1 GB of heap memory. In such a case, the report will show the allocated
    memory as 1 GB. The report shows the heap allocation in tabular and graphical
    formats. The following is an example heap size section from the report:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 报告中的这一部分提供了每个内存代的堆分配和峰值内存使用情况的信息。可能分配的堆大小可能与JVM参数中定义的大小不匹配。这是因为GCeasy工具从日志中获取了分配的内存信息。可能我们分配了2GB的堆内存，但在运行时，JVM只分配了1GB的堆内存。在这种情况下，报告将显示分配的内存为1GB。报告以表格和图形格式显示堆分配。以下是报告中堆大小部分的示例：
- en: '![](img/760de75d-71b3-44b7-84b9-9583efa5af91.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/760de75d-71b3-44b7-84b9-9583efa5af91.png)'
- en: Key Performance Indicators
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键绩效指标
- en: '**Key Performance Indicators** (**KPIs**) help make profound decisions for
    improving the application''s performance. Throughput, latency, and footprint are
    a few of the important KPIs. The KPIs in the report include Throughput and Latency.
    The footprint basically describes the amount of time CPU was occupied. It can
    be obtained from a performance-monitoring tool, such as JVisualVM.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键绩效指标**（**KPIs**）有助于做出改善应用程序性能的深刻决策。吞吐量、延迟和占用空间是一些重要的KPIs。报告中的KPIs包括吞吐量和延迟。占用空间基本上描述了CPU占用的时间。它可以从性能监控工具（如JVisualVM）中获取。'
- en: The Throughput option indicates the amount of productive work done by the application
    during a specified time period. The Latency option indicates the average time
    taken by the GC to run.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量选项表示在指定时间段内应用程序完成的有效工作量。延迟选项表示GC运行所花费的平均时间。
- en: 'The following is an example of KPIs from the report:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是报告中KPIs的示例：
- en: '![](img/6d375ac5-b067-44c4-8efe-98a2a8498c14.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d375ac5-b067-44c4-8efe-98a2a8498c14.jpg)'
- en: GC Statistics
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC统计
- en: The GC statistics section provides information on the behavior of the garbage
    collector over a period of time. The period is the time duration for which the
    logs are analyzed. The GC statistics are provided based on real-time analysis.
    The statistics include the bytes reclaimed after the garbage collector ran, the
    cumulative GC time in seconds, and the average GC time in seconds. This section
    also provides information on total GC statistics, minor and full GC statistics,
    and GC pause statistics in a tabular format.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: GC统计部分提供了一段时间内垃圾收集器的行为信息。这段时间是分析日志的时间段。GC统计是基于实时分析提供的。统计数据包括垃圾收集器运行后回收的字节数、累积GC时间（以秒为单位）和平均GC时间（以秒为单位）。该部分还以表格格式提供了有关总GC统计、小型GC统计和完整GC统计以及GC暂停统计的信息。
- en: GC Causes
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC原因
- en: 'The GC Causes section provides information on what caused the garbage collector
    to run. The information is provided in tabular as well as graphical format. Along
    with the reasons, it also provides information on the time it took for the garbage
    collector to execute. The following is an example from the report:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: GC Causes部分提供了有关垃圾收集器运行原因的信息。该信息以表格和图形格式提供。除了原因，它还提供了垃圾收集器执行所需的时间信息。以下是报告中的一个示例：
- en: '![](img/1f5ee498-4526-4f89-a07b-3d56e0863889.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f5ee498-4526-4f89-a07b-3d56e0863889.png)'
- en: Based on the preceding details, GCeasy is an important tool in helping developers
    to interpret GC logs in a visual manner.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上述细节，GCeasy是一个帮助开发人员以可视化方式解释GC日志的重要工具。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about JVM and its parameters. We learned about memory
    leaks and common misunderstandings related to GC. We learned about different GC
    methods and their importance. We learned about import JVM flags, which are tuned
    to achieve better performance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了JVM及其参数。我们了解了内存泄漏以及与GC相关的常见误解。我们了解了不同的GC方法及其重要性。我们了解了重要的JVM标志，这些标志被调整以实现更好的性能。
- en: In the next chapter, we will learn about Spring Boot microservices and its performance
    tuning. Microservice is an architecture of an application with loosely coupled
    services that implements business capabilities. Spring Boot enables us to build
    production-ready applications.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于Spring Boot微服务及其性能调优。微服务是一种应用架构，它由松散耦合的服务实现业务功能。Spring Boot使我们能够构建生产就绪的应用程序。
