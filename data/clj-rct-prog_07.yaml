- en: Chapter 7. The UI as a Function
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。UI作为函数
- en: So far we have taken a journey through managing complexity by efficiently handling
    and modeling asynchronous workflows in terms of streams of data. In particular,
    [Chapter 4](part0033_split_000.html#page "Chapter 4. Introduction to core.async"),
    *Introduction to core.async* and [Chapter 5](part0040_split_000.html#page "Chapter 5. Creating
    Your Own CES Framework with core.async"), *Creating Your Own CES Framework with
    core.async* explored what's involved in libraries that provide primitives and
    combinators for **Compositional Event Systems**. We also built a simple ClojureScript
    application that made use of our framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过有效地处理和建模数据流来管理异步工作流，从而通过管理复杂性进行了一次旅行。特别是[第4章](part0033_split_000.html#page
    "第4章。core.async简介")，“core.async简介”和[第5章](part0040_split_000.html#page "第5章。使用core.async创建自己的CES框架")，“使用core.async创建自己的CES框架”探讨了提供**组合事件系统**原语和组合子的库所涉及的内容。我们还构建了一个简单的ClojureScript应用程序，该应用程序使用了我们的框架。
- en: One thing you might have noticed is that none of the examples so far have dealt
    with what happens to the data once we are ready to present it to our users. It's
    still an open question that we, as application developers, need to answer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，到目前为止的示例都没有处理我们准备好向用户展示数据后会发生什么。作为应用程序开发者，我们需要回答的仍然是一个悬而未决的问题。
- en: 'In this chapter, we will look at one way to handle Reactive User Interfaces
    in web applications using React (see [http://facebook.github.io/react/](http://facebook.github.io/react/)),
    a modern JavaScript framework developed by Facebook, as well as:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一种在Web应用程序中使用React（见[http://facebook.github.io/react/](http://facebook.github.io/react/)）处理反应式用户界面的方法，React是由Facebook开发的一个现代JavaScript框架，以及：
- en: Learn how React renders user interfaces efficiently
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习React如何高效地渲染用户界面
- en: Be introduced to Om, a ClojureScript interface to React
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Om，它是React的ClojureScript接口
- en: Learn how Om leverages persistent data structures for performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Om如何利用持久数据结构来提高性能
- en: Develop two fully working ClojureScript applications with Om, including the
    use of `core.async` for intercomponent communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Om开发两个完全工作的ClojureScript应用程序，包括使用`core.async`进行组件间通信
- en: The problem with complex web UIs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂Web UI的问题
- en: With the rise of single-page web applications, it became a must to be able to
    manage the growth and complexity of a JavaScript codebase. The same applies to
    ClojureScript.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着单页Web应用程序的兴起，能够管理JavaScript代码库的增长和复杂性变得至关重要。ClojureScript也是如此。
- en: In an effort to manage this complexity, a plethora of JavaScript MVC frameworks
    have emerged such as AngularJS, Backbone.js, Ember.js, and KnockoutJS to name
    a few.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理这种复杂性，出现了大量的JavaScript MVC框架，例如AngularJS、Backbone.js、Ember.js和KnockoutJS等。
- en: 'They are very different, but share a few common features:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它们非常不同，但有一些共同的特点：
- en: Give single-page applications more structure by providing models, views, controllers,
    templates, and so on
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供模型、视图、控制器、模板等来为单页应用程序提供更多结构
- en: Provide client-side routing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供客户端路由
- en: Two-way data binding
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向数据绑定
- en: In this chapter, we'll be focusing on the last goal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于最后一个目标。
- en: Two-way data binding is absolutely crucial if we are to develop even a moderately
    complex single-page web application. Here's how it works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要开发一个中等复杂程度的单页Web应用程序，双向数据绑定绝对是至关重要的。以下是它是如何工作的。
- en: Suppose we're developing a phone book application. More than likely, we will
    have a model—or entity, map, what have you—that represents a contact. The contact
    model might have attributes such as name, phone number, and e-mail address.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在开发一个电话簿应用程序。更有可能的是，我们将有一个模型——或者实体、映射等——来表示联系人。联系人模型可能有姓名、电话号码和电子邮件地址等属性。
- en: Of course, this application would not be all that useful if users couldn't update
    contact information, so we will need a form which displays the current details
    for a contact and lets you update the contact's information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果用户无法更新联系信息，那么这个应用程序将不会很有用，因此我们需要一个表单来显示当前的联系详细信息，并允许您更新联系人的信息。
- en: 'The contact model might have been loaded via an AJAX request and then might
    have used explicit DOM manipulation code to display the form. This would look
    something like the following pseudo-code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 联系模型可能通过AJAX请求加载，然后可能使用显式的DOM操作代码来显示表单。这看起来可能像以下伪代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But what happens when the user updates someone''s information? We need to store
    it somehow. On clicking on save, a function such as the following would do the
    trick, assuming you''re using jQuery:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当用户更新某人的信息时会发生什么？我们需要以某种方式存储它。在点击保存时，以下函数可以解决问题，假设你正在使用jQuery：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This seemingly harmless code poses a big problem. The contact model for this
    particular person is now out of date. If we were still developing web applications
    the old way, where we reload the page at every update, this wouldn't be a problem.
    However, the whole point of single-page web applications is to be responsive,
    so it keeps a lot of state on the client, and it is important to keep our models
    synced with our views.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这看似无害的代码带来了一个大问题。这个特定的人的联系模型现在过时了。如果我们还在使用旧的方式开发Web应用，即每次更新都重新加载页面，这不会是问题。然而，单页Web应用的全部要点是响应性，所以它在客户端保持大量状态，并且保持我们的模型与视图同步非常重要。
- en: 'This is where two-way data binding comes in. An example from AngularJS would
    look like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是双向数据绑定发挥作用的地方。以下是一个AngularJS的示例：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Angular isn't the target of this chapter, so I won't dig into the details. All
    we need to know from this example is that `$scope` is how we tell Angular to make
    our contact model available to our views. In the view, the custom attribute `ng-model`
    tells Angular to look up that property in the scope. This establishes a two-way
    relationship in such a way that when your model data changes in the scope, Angular
    refreshes the UI. Similarly, if the user edits the form, Angular updates the model,
    keeping everything in sync.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是Angular，所以我就不深入细节了。我们只需要从这个例子中知道的是，`$scope`是我们告诉Angular使我们的联系模型对视图可用的方式。在视图中，自定义属性`ng-model`告诉Angular在作用域中查找该属性。这样建立了一种双向关系，当作用域中的模型数据发生变化时，Angular刷新UI。同样，如果用户编辑表单，Angular更新模型，保持一切同步。
- en: 'There are, however, two main problems with this approach:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的两个主要问题是：
- en: It can be slow. The way Angular and friends implement two-way data binding is,
    roughly speaking, by attaching event handlers and watchers to view both custom-
    attributes and model attributes. For complex enough user interfaces, you will
    start noticing that the UI becomes slower to render, diminishing the user experience.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能很慢。Angular及其朋友实现双向数据绑定的方式，大致来说，是通过为视图中的自定义属性和模型属性附加事件处理程序和观察者。对于足够复杂的用户界面，你将开始注意到UI渲染速度变慢，从而降低了用户体验。
- en: It relies heavily on mutation. As functional programmers, we strive to limit
    side effects to a minimum.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它严重依赖于突变。作为函数式程序员，我们努力将副作用限制到最小。
- en: 'The slowness that comes with this and similar approaches is two-fold: firstly,
    AngularJS and friends have to "watch" all properties of every model in the scope
    in order to track updates. Once the framework determines that data has changed
    in the model, it then looks up parts of the UI, which depend on that information—such
    as the fragments using `ng-model` above—and then it re-renders them.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法及其类似方法带来的缓慢有两方面：首先，AngularJS及其朋友必须“观察”作用域中每个模型的每个属性以跟踪更新。一旦框架确定模型中的数据已更改，它就会查找依赖于该信息的UI部分——例如上面的使用`ng-model`的片段——然后重新渲染它们。
- en: Secondly, the DOM is the slowest part of most single-page web applications.
    If we think about it for a moment, these frameworks are triggering dozens or perhaps
    hundreds of DOM event handlers in order to keep the data in sync, each of which
    ends up updating a node—or several—in the DOM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，DOM是大多数单页Web应用中最慢的部分。如果我们稍微思考一下，这些框架正在触发数十或数百个DOM事件处理程序以保持数据同步，每个处理程序最终都会更新DOM中的节点——或多个节点。
- en: 'Don''t take my word for it though. I ran a simple benchmark to compare a pure
    calculation versus locating a DOM element and updating its value to the result
    of the said calculation. Here are the results—I''ve used JSPerf to run the benchmark,
    and these results are for Chrome 37.0.2062.94 on Mac OS X Mavericks (see [http://jsperf.com/purefunctions-vs-dom](http://jsperf.com/purefunctions-vs-dom)):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不要只听我的话。我运行了一个简单的基准测试来比较纯计算与定位DOM元素并更新其值为计算结果的差异。以下是结果——我使用了JSPerf来运行基准测试，这些结果是在Chrome
    37.0.2062.94上Mac OS X Mavericks上获得的（见[http://jsperf.com/purefunctions-vs-dom](http://jsperf.com/purefunctions-vs-dom)）：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Updating the DOM is orders of magnitude slower than performing a simple calculation.
    It seems logical that we would want to do this in the most efficient manner possible.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更新DOM比执行简单的计算慢得多。从逻辑上讲，我们希望以尽可能高效的方式完成这项工作。
- en: However, if we don't keep our data in sync, we're back at square one. There
    should be a way by which we can drastically reduce the amount of rendering being
    done, while retaining the convenience of two-way data binding. Can we have our
    cake and eat it too?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们不保持数据同步，我们就会回到起点。应该有一种方法可以大幅减少渲染量，同时保留双向数据绑定的便利性。我们能否既吃蛋糕又吃蛋糕？
- en: Enter React.js
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入React.js
- en: As we'll see in this chapter, the answer to the question posed in the previous
    section is a resounding yes and, as you might have guessed, it involves React.js.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章中看到的，对上一节提出的问题的答案是响亮的肯定，正如你可能已经猜到的，它涉及到React.js。
- en: But what makes it special?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么让它变得特殊？
- en: It's wise to start with what React is not. It is not an MVC framework and as
    such it is not a replacement for the likes of AngularJS, Backbone.js, and so on.
    React focuses solely on the V in MVC, and presents a refreshingly different way
    to think about user interfaces. We must take a slight detour in order to explore
    how it does that.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 智慧的做法是从React不是什么开始。它不是一个MVC框架，因此它不是AngularJS、Backbone.js等类似框架的替代品。React专注于MVC中的V，并以一种令人耳目一新的方式来思考用户界面。我们必须稍微偏离一下，以便探索它是如何做到这一点的。
- en: Lessons from functional programming
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程的经验教训
- en: As functional programmers, we don't need to be convinced of the benefits of
    immutability. We bought into the premise long ago. However, should we not be able
    to use immutability efficiently, it would not have become commonplace in functional
    programming languages.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数式程序员，我们不需要被不可变性的好处所说服。我们很久以前就接受了这个前提。然而，如果我们不能有效地使用不可变性，它就不会在函数式编程语言中变得普遍。
- en: We owe it to the huge amount of research that went into **Purely Functional
    Data Structures**—first by Okasaki in his book of the same title (see [http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&qid=1409550695&sr=8-1&keywords=purely+functional+data+structures](http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&qid=1409550695&sr=8-1&keywords=purely+functional+data+structures))
    and then improved by others.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该感谢投入大量研究**纯函数数据结构**的巨大努力——首先是Okasaki在他的同名书中（见[http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&qid=1409550695&sr=8-1&keywords=purely+functional+data+structures](http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=sr_1_1?ie=UTF8&qid=1409550695&sr=8-1&keywords=purely+functional+data+structures)），然后其他人对其进行了改进。
- en: Without it, our programs would be ballooning, both in space and runtime complexity.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 没有它，我们的程序在空间和运行时复杂度上都会膨胀。
- en: 'The general idea is that given a data structure, the only way to update it
    is by creating a copy of it with the desired delta applied:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通用思路是，给定一个数据结构，唯一更新它的方式是通过创建一个带有所需增量（delta）的它的副本：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Lessons from functional programming](img/00022.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![函数式编程的经验教训](img/00022.jpeg)'
- en: In the preceding image, we have a simplistic view of how `conj` operates. On
    the left, you have the underlying data structure representing the vector we wish
    to update. On the right, we have the newly created vector, which, as we can see,
    shares some structure with the previous vector, as well as containing our new
    item.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们有一个关于`conj`如何操作的简单看法。在左边，我们有代表我们希望更新的向量的底层数据结构。在右边，我们有新创建的向量，正如我们所看到的，它与之前的向量共享一些结构，同时包含我们的新项目。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In reality, the underlying data structure is a tree and the representation was
    simplified for the purposes of this book. I highly recommend referring to Okasaki's
    book should the reader want more details on how purely functional data structures
    work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，底层数据结构是一个树，而表示是为了本书的目的而简化的。我强烈建议读者参考Okasaki的书，以了解更多关于纯函数数据结构如何工作的细节。
- en: Additionally, these functions are considered pure. That is, it relates every
    input to a single output and does nothing else. This is, in fact, remarkably similar
    to how React handles user interfaces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些函数被认为是纯函数。也就是说，它将每个输入关联到单个输出，并不做其他任何事情。实际上，这与React处理用户界面的方式非常相似。
- en: If we think of a UI as a visual representation of a data structure, which reflects
    the current state of our application, we can, without too much effort, think of
    UI updates as a simple function whose input is the application state and the output
    is a DOM representation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将UI视为数据结构的视觉表示，它反映了我们应用程序的当前状态，那么我们可以毫不费力地认为UI更新是一个简单的函数，其输入是应用程序状态，输出是DOM表示。
- en: You'll have noticed I didn't say the output is rendering to the DOM—that would
    make the function impure as rendering is clearly a side effect. It would also
    make it just as slow as the alternatives.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我没有说输出是渲染到 DOM 的——那样会使函数变得不纯，因为渲染显然是一个副作用。这也会使它和替代方案一样慢。
- en: This DOM representation is essentially a tree of DOM nodes that model how your
    UI should look, and nothing else.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 DOM 表示基本上是一个 DOM 节点的树，它模拟了你的 UI 应该看起来是什么样子，没有其他内容。
- en: React calls this representation a **Virtual DOM** *,* and roughly speaking,
    instead of watching individual bits and pieces of application state that trigger
    a DOM re-render upon change, React turns your UI into a function to which you
    give the whole application state.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: React 将这种表示称为 **虚拟 DOM**，粗略地说，React 不是通过监视触发 DOM 重新渲染的应用程序状态的单个部分和片段，而是将你的 UI
    转换为一个函数，你可以向它提供整个应用程序状态。
- en: 'When you give this function the new updated state, React renders that state
    to the Virtual DOM. Remember the Virtual DOM is simply a data structure, so the
    rendering is extremely fast. Once it''s done, React does one of two things:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向这个函数提供新的更新状态时，React 将该状态渲染到虚拟 DOM。记住，虚拟 DOM 只是一个数据结构，所以渲染非常快。一旦完成，React 会做两件事之一：
- en: It commits the Virtual DOM to the actual DOM if this is the first render.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这是第一次渲染，它会将虚拟 DOM 提交到实际 DOM。
- en: Otherwise, it compares the new Virtual DOM with the current Virtual DOM, cached
    from the previous render of the application. It then uses an efficient diff algorithm
    to compute the minimum set of changes required to update the real DOM. Finally,
    it commits this delta to the DOM.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它会将新的虚拟 DOM 与从应用程序上一次渲染缓存的当前虚拟 DOM 进行比较。然后，它使用一个高效的差异算法来计算更新真实 DOM 所需的最小更改集。最后，它将这个差异提交到
    DOM。
- en: Without digging into the nuts and bolts of React, this is essentially how it
    is implemented and the reason it is faster than the alternatives. Conceptually,
    React hits the "refresh" button whenever your application state changes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入 React 的细节，这基本上就是它的实现方式，也是它比其他替代方案更快的原因。从概念上讲，每当应用程序状态发生变化时，React 就会点击“刷新”按钮。
- en: Another great benefit is that by thinking of your UI as a function from application
    state to a Virtual DOM, we recover some of the reasoning we're able to do when
    working with immutable data structures in functional languages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个巨大的好处是，通过将你的 UI 视为一个从应用程序状态到虚拟 DOM 的函数，我们恢复了一些在函数式语言中处理不可变数据结构时能够进行的推理。
- en: In the upcoming sections, we will understand why this is a big win for us Clojure
    developers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将了解为什么这对我们 Clojure 开发者来说是一个巨大的胜利。
- en: ClojureScript and Om
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClojureScript 和 Om
- en: Why have I spent six pages talking about JavaScript and React in a Clojure book?
    I promise I'm not trying to waste your precious time; we simply needed some context
    to understand what's to come.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我在 Clojure 书中花了六页的篇幅来谈论 JavaScript 和 React？我保证我不是在浪费你宝贵的时间；我们只是需要一些背景知识来理解接下来要讲的内容。
- en: Om is a ClojureScript interface to React.js developed by the prolific and amazing
    individual David Nolen, from Cognitect. Yes, he has also developed `core.logic`,
    `core.match`, and the ClojureScript compiler. That's how prolific. But I digress.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Om 是由 Cognitect 的多产且杰出的个人 David Nolen 开发的 ClojureScript 接口到 React.js。是的，他还开发了
    `core.logic`、`core.match` 以及 ClojureScript 编译器。这就是他的多产。但我在这里跑题了。
- en: When Facebook released React, David immediately saw the potential and, more
    importantly, how to take advantage of the assumptions we are able to make when
    programming in Clojure, the most important of which is that data structures don't
    change.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Facebook 发布 React 时，David 立即看到了其潜力，更重要的是，如何利用我们在 Clojure 中编程时能够做出的假设，其中最重要的是数据结构不会改变。
- en: React provides several component life-cycle functions that allow developers
    to control various properties and behaviors. One in particular, `shouldComponentUpdate`,
    is used to decide whether a component needs to be re-rendered.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了几个组件生命周期函数，允许开发者控制各种属性和行为。特别是 `shouldComponentUpdate`，它用于决定组件是否需要重新渲染。
- en: React has a big challenge here. JavaScript is inherently mutable, so it is extremely
    hard, when comparing Virtual DOM Trees, to identify which nodes have changed in
    an efficient way. React employs a few heuristics in order to avoid *O(n* *3* *)*
    worst-case performance and is able to do it in *O(n)* most of the time. Since
    heuristics aren't perfect, we can choose to provide our own implementation of
    `shouldComponentUpdate` and take advantage of the knowledge we possess when rendering
    a component.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: React 在这里面临着一个巨大的挑战。JavaScript 本质上是可变的，所以在比较虚拟 DOM 树时，要高效地识别哪些节点已更改是非常困难的。React
    采用了一些启发式方法来避免 *O(n* *3* *)* 最坏情况性能，并且大多数时候能够在 *O(n)* 内完成。由于启发式方法并不完美，我们可以选择提供自己的
    `shouldComponentUpdate` 实现，并在渲染组件时利用我们所拥有的知识。
- en: 'ClojureScript, on the other hand, uses immutable data structures. As such,
    Om provides the simplest and most efficient implementation possible for `shouldComponentUpdate`:
    a simple reference equality check.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，ClojureScript 使用不可变数据结构。因此，Om 提供了最简单和最有效的 `shouldComponentUpdate` 实现：简单的引用等价性检查。
- en: Because we're always dealing with immutable data structures, in order to know
    whether two trees are the same, all we need to do is compare whether their roots
    are the same. If they are, we're done. Otherwise, descend and repeat the process.
    This is guaranteed to yield *O(log n)* runtime complexity and allows Om to always
    render the UI from the root efficiently.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们总是处理不可变的数据结构，为了知道两棵树是否相同，我们只需要比较它们的根是否相同。如果它们相同，我们就完成了。否则，向下递归并重复此过程。这保证了产生
    *O(log n)* 的运行时间复杂度，并允许 Om 总是从根高效地渲染 UI。
- en: Of course, performance isn't the only thing that's good about Om—we will now
    explore what makes an Om application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，性能并不是 Om 的唯一优点——我们现在将探讨是什么让 Om 应用程序变得出色。
- en: Building a simple Contacts application with Om
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Om 构建简单的联系人应用程序
- en: This chapter has been very text heavy so far. It's time we get our hands dirty
    and build a simple Om application. Since we talked about contacts before, that's
    what we will start with.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这一章已经非常注重文本了。是我们动手构建一个简单的 Om 应用程序的时候了。既然我们之前已经讨论了联系人，那么我们就从联系人开始。
- en: The main driver behind React and Om is the ability to build highly reusable,
    self-contained components and, as such, even in a simple *Contacts* application,
    we will have multiple components working in concert to achieve a common goal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: React 和 Om 的主要驱动因素是构建高度可重用、自包含组件的能力，因此，即使在简单的 *Contacts* 应用程序中，我们也将有多个组件协同工作以实现共同目标。
- en: 'This is what our users should be able to do in the application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的用户应该在应用程序中能够做到的：
- en: Display a list of contacts currently in storage
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示当前存储中的联系人列表
- en: Display the details of a given contact
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示给定联系人的详细信息
- en: Edit the details of a specific contact
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑特定联系人的详细信息
- en: 'And once we''re done, it will look like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成，它将看起来像以下这样：
- en: '![Building a simple Contacts application with Om](img/00023.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Om 构建简单的联系人应用程序](img/00023.jpeg)'
- en: The Contacts application state
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联系人应用程序状态
- en: 'As mentioned previously, Om/React will eventually render the DOM based on our
    application state. We''ll be using data that''s in memory to keep the example
    simple. Here''s what our application state will look like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Om/React 最终将根据我们的应用程序状态渲染 DOM。我们将使用内存中的数据来简化示例。以下是我们的应用程序状态将看起来像这样：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The reason we keep the state in an atom is that Om uses that to re-render the
    application if we `swap!` or `reset!` it, for instance, if we load some data from
    the server after the application has been rendered for the first time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将状态保存在原子中的原因是因为 Om 使用它来重新渲染应用程序，如果我们进行 `swap!` 或 `reset!` 操作，例如，如果我们首次渲染应用程序后从服务器加载数据。
- en: The data in the state itself should be mostly self-explanatory. We have a map
    containing all contacts, a key representing whether there is currently a contact
    selected, and a flag that indicates whether we are currently editing the selected
    contact. What might look odd is that both`:selected-contact-id` and `:editing
    keys` point to a vector. Just bear with me for a moment; the reason for this will
    become clear shortly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 国家本身的数据应该大部分是自我解释的。我们有一个包含所有联系人的地图，一个表示当前是否有联系人被选中的键，以及一个表示我们是否正在编辑所选联系人的标志。可能看起来有些奇怪的是，`:selected-contact-id`
    和 `:editing keys` 都指向一个向量。请稍等片刻；这个原因很快就会变得清晰。
- en: 'Now that we have a draft of our application state, it''s time we think about
    how the state will flow through the different components in our app. A picture
    is worth a thousand words, so the following diagram shows the high-level architecture
    through which our data will flow:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的应用程序状态草稿，是时候考虑状态如何在我们的应用程序的不同组件中流动了。一图胜千言，所以下面的图展示了我们的数据将通过的高层架构：
- en: '![The Contacts application state](img/00024.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![联系人应用程序状态](img/00024.jpeg)'
- en: In the preceding image, each function corresponds to an Om component. At the
    very least, they take some piece of data as their initial state. What is interesting
    in this image is that as we descend into our more specialized components, they
    request less state than the main component, `contacts-app`. For instance, the
    `contacts-view` component needs all contacts as well as the ID of the selected
    contact. The `details-panel-view` component, on the other hand, only needs the
    currently selected contact, and whether it's being edited or not. This is a common
    pattern in Om and we usually want to avoid over-sharing the application state.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，每个函数都对应一个Om组件。至少，它们以一些数据作为它们的初始状态。在这张图中有趣的是，当我们深入到更专业的组件时，它们请求的状态比主组件`contacts-app`少。例如，`contacts-view`组件需要所有联系人以及选中联系人的ID。另一方面，`details-panel-view`组件只需要当前选中的联系人，以及它是否正在被编辑。这是Om中的一种常见模式，我们通常希望避免过度共享应用程序状态。
- en: With a rough understanding of our high-level architecture, we are ready to start
    building our Contacts application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在对高层架构有一个粗略的了解后，我们就可以开始构建我们的联系人应用程序了。
- en: Setting up the Contacts project
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置联系人项目
- en: 'Once again, we will use a leiningen template to help us get started. This time
    we''ll be using `om-start` (see [https://github.com/magomimmo/om-start-template](https://github.com/magomimmo/om-start-template)),
    also by Mimmo Cosenza (see [https://github.com/magomimmo](https://github.com/magomimmo)).
    Type this in the terminal to create a base project using this template:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将使用Leiningen模板来帮助我们开始。这次我们将使用`om-start`（见[https://github.com/magomimmo/om-start-template](https://github.com/magomimmo/om-start-template)），也是由Mimmo
    Cosenza（见[https://github.com/magomimmo](https://github.com/magomimmo)）提供的。在终端中键入以下内容以使用此模板创建基础项目：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let''s open the `project.clj` file and make sure we have the same versions
    for the various different dependencies the template pulls in. This is just so
    that we don''t have any surprises with incompatible versions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们打开`project.clj`文件，确保我们有模板拉入的各种不同依赖项的相同版本。这样我们就不必担心不兼容的版本：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To validate the new project skeleton, still in the terminal, type the following
    to auto-compile your ClojureScript source files:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证新的项目骨架，仍然在终端中，键入以下内容来自动编译你的ClojureScript源文件：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we should see the template default "Hello World" page if we open the `dev-resources/public/index.html`
    file in the browser.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开浏览器中的`dev-resources/public/index.html`文件，我们应该能看到模板默认的“Hello World”页面。
- en: Application components
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序组件
- en: 'The next thing we''ll do is open the `src/cljs/contacts/core.cljs` file, which
    is where our application code will go, and make sure it looks like the following
    so that we have a clean slate with the appropriate namespace declaration:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们将打开`src/cljs/contacts/core.cljs`文件，这是我们的应用程序代码将放置的地方，并确保它看起来像以下内容，以便我们有适当的命名空间声明的一个干净的起点：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Every Om application starts with a root component created by the `om/root` function.
    It takes as arguments a function representing a component—`contacts-app`—the initial
    state of the application—`app-state`—and a map of options of which the only one
    we care about is `:target`, which tells Om where to mount our root component on
    the DOM.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Om应用程序都是以`om/root`函数创建的根组件开始的。它接受一个表示组件的函数——`contacts-app`——应用程序的初始状态——`app-state`——以及一个选项映射，其中我们唯一关心的是`:target`，它告诉Om在哪里将根组件挂载到DOM上。
- en: In this instance, it will mount on a DOM element whose ID is `app`. This element
    was given to us by the `om-start` template and is located in the `dev-resources/public/index.html`
    file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它将挂载到一个ID为`app`的DOM元素上。这个元素是由`om-start`模板给出的，位于`dev-resources/public/index.html`文件中。
- en: 'Of course, this code won''t compile yet, as we don''t have the `contacts-app`
    template. Let''s solve that and create it above the preceding declaration—we''re
    implementing the components bottom-up:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码现在还不能编译，因为我们还没有`contacts-app`模板。让我们解决这个问题，并在前面的声明上方创建它——我们是自下而上实现组件的：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Clojure uses reify to implement protocols or Java interfaces on the fly, without
    the need to create a new type. You can read more about this on the data types
    page of the Clojure documentation at [http://clojure.org/datatypes](http://clojure.org/datatypes).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure使用reify动态实现协议或Java接口，而不需要创建一个新的类型。你可以在Clojure文档的数据类型页面了解更多信息，请访问[http://clojure.org/datatypes](http://clojure.org/datatypes)。
- en: 'The `render` function must return an `Om/React` component or something React
    knows how to render—such as a DOM representation of the component. The arguments
    to `contacts-app` are straightforward: `data` is the component state and `owner`
    is the backing React component.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`函数必须返回一个`Om/React`组件或React知道如何渲染的内容——例如组件的DOM表示。`contacts-app`的参数很简单：`data`是组件状态，`owner`是后端的React组件。'
- en: 'Moving down the source file, in the implementation of `render`, we have the
    following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件向下移动，在`render`的实现中，我们有以下内容：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we recall from our application state, the value of `:selected-contact-id`
    is, at this stage, an empty vector. Here, then, we are destructuring this vector
    and giving it a name. What you might be wondering now is why we bound the vector
    to a variable named `selected-id-cursor`. This is to reflect the fact that at
    this point in the life cycle of a component, `selected-id-cursor` isn't a vector
    any longer but rather it is a cursor.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从应用程序状态中回忆起来，`:selected-contact-id`的值在这个阶段是一个空向量。因此，在这里，我们正在对这个向量进行解构并给它命名。你现在可能想知道为什么我们将向量绑定到一个名为`selected-id-cursor`的变量上。这是因为在这个组件生命周期的这个点上，`selected-id-cursor`不再是一个向量，而是一个光标。
- en: Om cursors
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Om光标
- en: Once `om/root` creates our root component, sub-components don't have direct
    access to the state atom any longer. Instead, components receive a cursor created
    from the application state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`om/root`创建了我们的根组件，子组件就不再直接访问状态原子了。相反，组件接收一个从应用程序状态创建的光标。
- en: 'Cursors are data structures that represent a place in the original state atom.
    You can use cursors to read, delete, update, or create a value with no knowledge
    of the original data structure. Let''s take the `selected-id-cursor` cursor as
    an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 光标是表示原始状态原子中位置的数结构。你可以使用光标来读取、删除、更新或创建一个值，而无需了解原始数据结构。让我们以`selected-id-cursor`光标为例：
- en: '![Om cursors](img/00025.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Om光标](img/00025.jpeg)'
- en: At the top, we have our original application state, which Om turns into a cursor.
    When we request the `:selected-contact-id` key from it, Om gives us another cursor
    representing that particular place in the data structure. It just so happens that
    its value is the empty vector.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们有原始的应用程序状态，Om将其转换为光标。当我们从这个状态中请求`:selected-contact-id`键时，Om给我们另一个光标，代表数据结构中的那个特定位置。碰巧的是，它的值是一个空向量。
- en: What is interesting about this cursor is that if we update its value using one
    of Om's state transition functions such as `om/transact!` and `om/update!`—we
    will explain these shortly—it knows how to propagate the change up the tree and
    all the way back to the application state atom.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个光标有趣的地方在于，如果我们使用Om的状态转换函数（如`om/transact!`和`om/update!`）之一来更新它的值——我们很快就会解释这些函数——它知道如何将更改传播到树的上层，并最终回到应用程序状态原子。
- en: This is important because as we have briefly stated before, it is common practice
    to have our more specialized components depend on specific parts of the application
    state required for its correct operation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为我们之前简要提到过，让我们的更专业化的组件依赖于其正确操作所需的应用程序状态的具体部分是一种常见的做法。
- en: By using cursors, we can easily propagate changes without knowing what the application
    state looks like, thus avoiding the need to access the global state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用光标，我们可以轻松地传播变化，而无需了解应用程序状态的外观，从而避免访问全局状态的需求。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can think of cursors as zippers. Conceptually, they serve a similar purpose
    but have different APIs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将光标想象成zipper。从概念上讲，它们服务于类似的目的，但具有不同的API。
- en: Filling in the blanks
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填补空白
- en: 'Moving down the `contacts-app` component, we now have the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`contacts-app`组件向下移动，我们现在有以下内容：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `dom` namespace contains thin wrappers around React's DOM classes. It's
    essentially the data structure representing what the application will look like.
    Next, we see two examples of how we can create Om components inside another Om
    component. We use the `om/build` function for that and create the `contacts-view`
    and `details-panel-view` components. The `om/build` function takes as arguments
    the component function, the component state, and, optionally, a map of options
    which aren't important for this example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`dom` 命名空间包含 React DOM 类的薄包装。它本质上代表应用程序将呈现的数据结构。接下来，我们看到两个示例，说明我们如何在另一个 Om
    组件内部创建 Om 组件。我们使用 `om/build` 函数来做这件事，并创建了 `contacts-view` 和 `details-panel-view`
    组件。`om/build` 函数接受组件函数、组件状态以及可选的选项映射作为参数，这些选项在这个例子中并不重要。'
- en: At this point, we have already started to limit the state we will pass into
    the sub-components by creating sub-cursors.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过创建子游标开始限制传递给子组件的状态。
- en: 'According to the source code, the next component we should look at is `contacts-view`.
    Here it is in full:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据源代码，我们应该查看的下一个组件是 `contacts-view`。下面是它的完整代码：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Hopefully, the source of this component looks a little more familiar now. As
    before, we reify `om/IRender` to provide a DOM representation of our component.
    It comprises a single `div` element. This time we give as the second argument
    to `dom/div` a hash-map representing HTML attributes. We are using some inline
    styles, but ideally we would use an external style sheet.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在这个组件的源代码看起来更熟悉一些。和之前一样，我们重新实现 `om/IRender` 以提供我们组件的 DOM 表示。它由一个单一的 `div`
    元素组成。这次我们将一个表示 HTML 属性的哈希表作为 `dom/div` 的第二个参数。我们使用了一些内联样式，但理想情况下我们会使用外部样式表。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are not familiar with the `#js {…}` syntax, it's simply a reader macro
    that expands to (`clj->js {…}`) in order to convert a ClojureScript hash-map into
    a JavaScript object. The only thing to watch for is that it is not recursive,
    as evidenced by the nested use of `#js`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 `#js {…}` 语法，它只是一个扩展到 (`clj->js {…}`) 的读取宏，目的是将 ClojureScript 的哈希表转换为
    JavaScript 对象。需要注意的是，它不是递归的，正如 `#js` 的嵌套使用所证明的那样。
- en: 'The third argument to `dom/div` is slightly more complex than what we have
    seen so far:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`dom/div` 的第三个参数比我们之前看到的要稍微复杂一些：'
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each contact will be represented by a `li` (list item) HTML node, so we start
    by wrapping the result into a `dom/ul` element. Then, we use `om/build-all` to
    build a list of contact-`summary-view` components. Om will, in turn, call `om/build`
    for each contact in `vals contacts`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个联系人将由一个 `li`（列表项）HTML 节点表示，因此我们首先将结果包装到一个 `dom/ul` 元素中。然后，我们使用 `om/build-all`
    来构建一个联系人 `summary-view` 组件的列表。Om 将依次调用 `om/build` 来处理 `vals contacts` 中的每个联系人。
- en: 'Lastly, we use the third argument to `om/build-all`—the options map—to demonstrate
    how we can share state between components without the use of global state. We''ll
    see how that''s used in the next component, `contact-summary-view`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `om/build-all` 的第三个参数——选项映射——来演示我们如何在组件之间共享状态而不使用全局状态。我们将在下一个组件 `contact-summary-view`
    中看到它是如何使用的：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we think of our application as a tree of components, we have now reached
    one of its leaves. This component simply returns a `dom/li` node with the contact's
    name and phone in it, wrapped in `dom/span` nodes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将应用程序视为一个组件树，我们现在已经到达了其中的一片叶子。这个组件简单地返回一个包含联系人的姓名和电话的 `dom/li` 节点，并用 `dom/span`
    节点包装。
- en: It also installs a handler to the `dom/li onClick` event, which we can use to
    update the state cursor.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它还安装了一个处理 `dom/li onClick` 事件的处理器，我们可以用它来更新状态游标。
- en: 'We use `om/get-shared` to access the shared state we installed earlier and
    pass the resulting cursor into `select-contact!` We also pass the current contact,
    but, if you look closely, we have to `deref` it first:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `om/get-shared` 来访问我们之前安装的共享状态，并将结果游标传递给 `select-contact!`。我们还传递了当前联系人，但如果你仔细看，我们必须首先
    `deref` 它：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The reason for this is that Om doesn''t allow us to manipulate cursors outside
    of the render phase. By derefing the cursor, we have its most recent underlying
    value. Now `select-contact`! has all it needs to perform the update:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 Om 不允许我们在渲染阶段之外操作游标。通过解引用游标，我们得到其最新的底层值。现在 `select-contact`! 有它需要执行更新的所有内容：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We simply use `om/update!` to set the value of the `selected-id-cursor` cursor
    at index `0` to the `id` of the contact. As mentioned previously, the cursor takes
    care of propagating the change.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地使用 `om/update!` 将索引 `0` 处的 `selected-id-cursor` 游标值设置为联系人的 `id`。如前所述，游标负责传播更改。
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can think of `om/update!` as the cursors version of `clojure.core/reset!`
    used in atoms. Conversely, the same applies to `om/transact!` and `clojure.core/swap!`,
    respectively.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 `om/update!` 视为在原子中使用 `clojure.core/reset!` 的光标版本。相反，同样适用于 `om/transact!`
    和 `clojure.core/swap!`。
- en: 'We are moving at a good pace. It''s time we look at the next component, `details-panel-view`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在以良好的速度前进。是时候看看下一个组件 `details-panel-view` 了：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This component should now look fairly familiar. All it does is build two other
    components, `contact-details-view` and `contact-details-form-view`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件现在看起来应该相当熟悉。它所做的只是构建两个其他组件，`contact-details-view` 和 `contact-details-form-view`：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `contact-details-view` component receives two pieces of state: the contact
    and the editing flag. If we have a contact, we simply render the component. However,
    we use the editing flag to hide it, if we are editing it. This is so that we can
    show the edit form in the next component. We also install an `onClick` handler
    to the Edit button so that we can update the editing cursor.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`contact-details-view` 组件接收两份数据状态：联系人和编辑标志。如果我们有一个联系人，我们只需渲染该组件。然而，我们使用编辑标志来隐藏它，如果我们正在编辑它。这样我们就可以在下一个组件中显示编辑表单。我们还为编辑按钮安装了一个
    `onClick` 处理器，以便我们可以更新编辑光标。'
- en: 'The `contact-details-form-view` component receives the same arguments but renders
    the following form instead:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`contact-details-form-view` 组件接收相同的参数，但渲染以下表单：'
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the component responsible for actually updating the contact information
    based on the form. It does so by calling `update-contact!` with the JavaScript
    event, the contact cursor, and the key representing the attribute to be updated:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件负责根据表单更新联系人信息。它是通过调用 `update-contact!` 并传递 JavaScript 事件、联系人光标和表示要更新的属性的键来实现的：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As before, we simply use `om/update!` instead of `om/transact!` as we are simply
    replacing the value of the cursor attribute with the current value of the form
    field which triggered the event `e`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们只是使用 `om/update!` 而不是 `om/transact!`，因为我们只是用触发事件的表单字段的当前值替换光标属性的值 `e`。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you''re not familiar with the `..` syntax, it''s simply a convenience macro
    for Java and JavaScript interoperability. The previous example expands to:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 `..` 语法，它只是一个方便的宏，用于 Java 和 JavaScript 的互操作性。前面的例子展开为：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This and other interoperability operators are described in the Java Interop
    page of the Clojure website (see [http://clojure.org/java_interop](http://clojure.org/java_interop)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这和其他互操作性操作符在 Clojure 网站的 Java Interop 页面上有描述（见 [http://clojure.org/java_interop](http://clojure.org/java_interop)）。
- en: 'This is it. Make sure your code is still compiling—or if you haven''t yet,
    start the auto-compilation by typing the following in the terminal:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。确保您的代码仍在编译——或者如果您还没有开始，请在终端中键入以下内容以启动自动编译：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then, open up `dev-resources/public/index.html` again in your browser and take
    our Contacts app for a spin! Note in particular how the application state is always
    in sync while you edit the contact attributes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次在您的浏览器中打开 `dev-resources/public/index.html`，并尝试我们的联系人应用程序！特别注意，当您编辑联系人属性时，应用程序状态始终处于同步状态。
- en: If there are any issues at this stage, make sure the `src/cljs/contacts/core.cljs`
    file matches the companion code for this book.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此阶段有任何问题，请确保 `src/cljs/contacts/core.cljs` 文件与本书的配套代码匹配。
- en: Intercomponent communication
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件间通信
- en: In our previous example, the components we built communicated with each other
    exclusively through the application state, both for reading and transacting data.
    While this approach works, it is not always the best except for very simple use
    cases. In this section, we will learn an alternate way of performing this communication
    using `core.async` channels.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们构建的组件通过应用程序状态相互通信，无论是读取还是交易数据。虽然这种方法可行，但除了非常简单的用例外，它并不总是最佳选择。在本节中，我们将学习使用
    `core.async` 通道执行这种通信的另一种方式。
- en: The application we will build is a super simple virtual agile board. If you've
    heard of it, it's similar to Trello (see [https://trello.com/](https://trello.com/)).
    If you haven't, fear not, it's essentially a task management web application in
    which you have cards that represent tasks and you move them between columns such
    as **Backlog**, **In Progress**, and **Done**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的应用程序是一个非常简单的虚拟敏捷看板。如果您听说过，它类似于 Trello（见 [https://trello.com/](https://trello.com/)）。如果您没有听说过，不用担心，它本质上是一个任务管理网络应用程序，其中您有代表任务的卡片，并且您可以在例如
    **待办事项**、**进行中** 和 **完成** 等列之间移动它们。
- en: 'By the end of this section, the application will look like the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，应用程序将看起来如下：
- en: '![Intercomponent communication](img/00026.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![组件间通信](img/00026.jpeg)'
- en: 'We''ll limit ourselves to a single feature: moving cards between columns by
    dragging and dropping them. Let''s get started.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将限制自己只实现一个功能：通过拖放卡片在列之间移动。让我们开始吧。
- en: Creating an agile board with Om
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Om 创建敏捷看板
- en: 'We''re already familiar with the `om-start` (see [https://github.com/magomimmo/om-start-template](https://github.com/magomimmo/om-start-template))
    leiningen template, and since there is no reason to change it, that''s what we
    will use to create our project—which I called `om-pm` for **Om Project Management**:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了 `om-start`（见 [https://github.com/magomimmo/om-start-template](https://github.com/magomimmo/om-start-template)）的
    leiningen 模板，并且没有理由去改变它，所以我们将使用它来创建我们的项目——我将其命名为 `om-pm` 以代表**Om 项目管理**：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As before, we should ensure we have the right dependencies in our `project.clj`
    file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们应该确保我们的 `project.clj` 文件中有正确的依赖项：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now validate that we are in good shape by making sure the project compiles
    properly:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确保项目正确编译，以验证我们处于良好状态：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, open the `src/cljs/om_pm/core.cljs` file and add the namespaces that
    we will be using to build the application:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `src/cljs/om_pm/core.cljs` 文件，并添加我们将用于构建应用程序的命名空间：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The main difference this time is that we are requiring `core.async` functions
    and macros. We don't yet have an `om-pm.util` namespace, but we'll get to that
    at the end.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的主要区别是我们正在要求 `core.async` 函数和宏。我们还没有 `om-pm.util` 命名空间，但我们会在这个结尾处解决这个问题。
- en: The board state
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桌板状态
- en: 'It''s time we think what our application state will look like. Our main entity
    in this application is the **card**, which represents a task and has the attributes
    `id`, `title`, and `description`. We will start by defining a couple of cards:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候考虑我们的应用程序状态将是什么样子了。在这个应用程序中，我们的主要实体是**卡片**，它代表一个任务，并具有 `id`、`title` 和 `description`
    属性。我们将首先定义几个卡片：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This isn''t our application state yet, but rather a part of it. Another important
    piece of state is a way to track which cards are on which columns. To keep things
    simple, we will work with only three columns: **Backlog**, **In Progress**, and
    **Done**. By default, all cards start out in the backlog:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是我们的应用程序状态，而是它的一部分。另一个重要的状态部分是跟踪哪些卡片在哪些列上的方式。为了简化问题，我们将只处理三个列：**待办事项**、**进行中**和**完成**。默认情况下，所有卡片都从待办事项开始：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is all the state we need. Columns have a `:title` and a `:cards` attribute,
    which contains the IDs of all cards in that column.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所需要的所有状态。列具有 `:title` 和 `:cards` 属性，其中包含该列中所有卡片的所有 ID。
- en: 'Additionally, we will have a helper function to make finding cards more convenient:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将有一个辅助函数来使查找卡片更加方便：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Beware of lazy sequences**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**小心懒序列**'
- en: 'You might have noticed the use of `mapv` instead of `map` for retrieving the
    cards IDs. This is a subtle but important difference: `map` is lazy by default,
    but Om can only create cursors for maps and vectors. Using `mapv` gives us a vector
    back, avoiding laziness altogether.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了在检索卡片 ID 时使用 `mapv` 而不是 `map`。这是一个微妙但重要的区别：`map` 默认是懒的，但 Om 只能创建 maps
    和 vectors 的 cursors。使用 `mapv` 给我们一个 vector，避免了懒加载。
- en: Had we not done that, Om would consider the list of IDs as a normal value and
    we would not be able to transact it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有做那件事，Om 会将 ID 列表视为一个普通值，我们就无法进行交易。
- en: Components overview
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件概述
- en: There are many ways to slice up an Om application into components, and in this
    section, we will present one way as we walk through each component's implementation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Om 应用程序分割成组件的方法有很多，在本节中，我们将通过遍历每个组件的实现来展示一种方法。
- en: The approach we will follow is similar to our previous application in that from
    this point on, we present the components bottom-up.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循的方法与我们之前的应用程序类似，即从这一点开始，我们将自下而上地展示组件。
- en: 'Before we see our first component, however, we should start with Om''s own
    `root` component:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到第一个组件之前，我们应从 Om 的自身 `root` 组件开始：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This gives us a hint as to what our next component will be, `project-view`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了关于下一个组件的线索，`project-view`：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Lifecycle and component local state
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期和组件本地状态
- en: 'The previous component is fairly different from the ones we have seen so far.
    More specifically, it implements two new protocols: `om/IInitState` and `om/IWillMount`.
    Additionally, we dropped `om/IRender` altogether in favor of `om/IRenderState`.
    Before we explain what these new protocols are good for, we need to discuss our
    high-level design.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的组件与我们之前看到的组件相当不同。更具体地说，它实现了两个新的协议：`om/IInitState` 和 `om/IWillMount`。此外，我们完全放弃了
    `om/IRender`，转而使用 `om/IRenderState`。在我们解释这些新协议有什么好处之前，我们需要讨论我们的高级设计。
- en: The `project-view` component is our application's main entry point and receives
    the whole application state as its first argument. As in our earlier *Contacts*
    application, it then instantiates the remaining components with the data they
    need.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`project-view` 组件是应用程序的主要入口点，它将整个应用程序状态作为其第一个参数。正如我们早期的 *Contacts* 应用程序一样，然后它使用所需的数据实例化剩余的组件。'
- en: Different from the *Contacts* example, however, it creates a `core.async` channel—`transfer-chan`—which
    works as a message bus. The idea is that when we drag a card from one column and
    drop it on another, one of our components will put a transfer event in this channel
    and let someone else—most likely a `go` block—perform the actual move operation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与 *Contacts* 示例不同的是，它创建了一个 `core.async` 通道——`transfer-chan`——它作为一个消息总线工作。想法是，当我们从一个列拖动卡片并将其拖放到另一个列时，我们的一个组件将把一个传输事件放入这个通道，并让其他人——很可能是
    `go` 块——执行实际的移动操作。
- en: 'This is done in the following snippet taken from the component shown earlier:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在之前显示的组件中取出的以下片段中完成的：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This creates what Om calls the component local state. It uses a different lifecycle
    protocol, `om/IInitState`, which is guaranteed to be called only once. After all,
    we need a single channel for this component. `init-state` should return a map
    representing the local state.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就创建了 Om 所说的组件本地状态。它使用不同的生命周期协议，`om/IInitState`，它保证只被调用一次。毕竟，我们需要为这个组件提供一个单独的通道。`init-state`
    应该返回一个表示本地状态的映射。
- en: 'Now that we have the channel, we need to install a `go-loop` to handle messages
    sent to it. For this purpose, we use a different protocol:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了通道，我们需要安装一个 `go-loop` 来处理发送给它的消息。为此，我们使用不同的协议：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Like the previous protocol, `om/IWillMount` is also guaranteed to be called
    once in the component life cycle. It is called when it is about to be mounted
    into the DOM and is the perfect place to install the `go-loop` into our channel.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的协议一样，`om/IWillMount` 在组件生命周期中也会被调用一次。它在即将被挂载到 DOM 中的时候被调用，是安装 `go-loop`
    到我们通道中的完美位置。
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When creating `core.async` channels in Om applications, it is important to avoid
    creating them inside life-cycle functions that are called multiple times. Besides
    non-deterministic behavior, this is a source of memory leaks.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Om 应用程序中创建 `core.async` 通道时，避免在多次被调用的生命周期函数内部创建它们非常重要。除了非确定性行为之外，这还是内存泄漏的来源。
- en: We get hold of it from the component local state using the `om/get-state` function.
    Once we get a message, we transact the state. We will see what `transfer-data`
    looks like very shortly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `om/get-state` 函数从组件本地状态中获取它。一旦我们收到消息，我们就进行状态交易。我们很快就会看到 `transfer-data`
    的样子。
- en: 'We complete the component by implementing its render function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现其渲染函数来完成组件：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `om/IRenderState` function serves the same purpose of `om/IRender`, that
    is, it should return the DOM representation of what the component should look
    like. However, it defines a different function, `render-state`, which receives
    the component local state as its second argument. This state contains the map
    we created during the `init-state` phase.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`om/IRenderState` 函数与 `om/IRender` 具有相同的目的，即它应该返回组件应该看起来像的 DOM 表示。然而，它定义了一个不同的函数，`render-state`，它将组件本地状态作为其第二个参数。这个状态包含我们在
    `init-state` 阶段创建的映射。'
- en: Remaining components
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剩余组件
- en: Next, we will build multiple `column-view` components, one per column. Each
    of them receives the list of cards from the application state as their shared
    state. We will use that to retrieve the card details from the IDs we store in
    each column.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建多个 `column-view` 组件，每个列一个。它们接收来自应用程序状态中的卡片列表作为它们的共享状态。我们将使用它来从每个列中存储的
    ID 中检索卡片详情。
- en: 'We also use the `:init-state` key to initialize the local state of each column
    view with our channel, since all columns need a reference to it. Here''s what
    the component looks like:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `:init-state` 键用我们的通道初始化每个列视图的本地状态，因为所有列都需要对其有一个引用。以下是组件的外观：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code should look fairly familiar at this point. We used inline CSS in the
    example to keep it simple, but in a real application, we would probably have used
    an external style sheet.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，代码看起来相当熟悉。我们在示例中使用了内联 CSS 以保持简单，但在实际应用中，我们可能会使用外部样式表。
- en: 'We implement `render-state` once more to retrieve the transfer channel, which
    will be used when handling the `onDrop` JavaScript event. This event is fired
    by the browser when a user drops a draggable DOM element onto this component.
    `handle-drop` takes care of that like so:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次实现 `render-state` 以检索传输通道，该通道将在处理 `onDrop` JavaScript 事件时使用。当用户将可拖动的 DOM
    元素拖放到此组件上时，浏览器将触发此事件。`handle-drop` 如此处理：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This function creates the transfer data—a map with the keys `:card-id`, `:source-column`,
    and `:destination-column`—which is everything we need to move the cards between
    columns. Finally, we `put!` it into the transfer channel.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建传输数据——一个包含键 `:card-id`、`:source-column` 和 `:destination-column` 的映射，这是我们移动卡片在列之间所需的一切。最后，我们将它
    `put!` 到传输通道中。
- en: 'Next, we build a number or `card-view` components. As mentioned previously,
    Om can''t create cursors from lazy sequences, so we use `filterv` to give each
    `card-view` a vector containing their respective cards. Let''s see its source:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建一个或多个 `card-view` 组件。如前所述，Om 不能从懒序列创建游标，所以我们使用 `filterv` 给每个 `card-view`
    提供一个包含它们各自卡片的向量。让我们看看它的源代码：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As this component doesn't need any local state, we go back to using the `IRender`
    protocol. Additionally, we make it draggable and install an event handler on the
    `onDragStart` event, which will be triggered when the user starts dragging the
    card.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个组件不需要任何本地状态，我们回归使用 `IRender` 协议。此外，我们使其可拖动，并在 `onDragStart` 事件上安装事件处理器，该事件将在用户开始拖动卡片时触发。
- en: This event handler sets the transfer data, which we use from `handle-drop`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件处理器设置传输数据，我们从 `handle-drop` 中使用。
- en: We have glossed over the fact that these components use a few utility functions.
    That's OK, as we will now define them in a new namespace.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经忽略了这些组件使用了一些实用函数的事实。没关系，因为我们现在将在新的命名空间中定义它们。
- en: Utility functions
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用函数
- en: 'Go ahead and create a new file under `src/cljs/om_pm/` called `util.cljs` and
    add the following namespace declaration:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/cljs/om_pm/` 下创建一个名为 `util.cljs` 的新文件，并添加以下命名空间声明：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For consistency, we will look at the functions bottom-up, starting with `move-card!`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，我们将从 `move-card!` 函数开始，自下而上查看函数：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `move-card!` function receives a cursor for the columns in our application
    state and simply moves `card-id` between the source and destination. You will
    notice we didn't need any access to `core.async` or Om specific functions, which
    means this function is pure and therefore easy to test.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`move-card!` 函数接收我们应用程序状态中列的游标，并简单地移动 `card-id` 在源和目标之间。你会注意到我们不需要访问 `core.async`
    或 Om 特定函数，这意味着这个函数是纯的，因此很容易测试。'
- en: 'Next, we have the functions that handle transfer data:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有处理传输数据的函数：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These functions use JavaScript interoperability to interact with HTML's `DataTransfer`
    (see [https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer))
    object. This is how browsers share data related to drag and drop events.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数使用 JavaScript 互操作性来与 HTML 的 `DataTransfer`（见 [https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer)）对象交互。这是浏览器共享与拖放事件相关的数据的方式。
- en: Now, let's simply save the file and make sure the code compiles properly. We
    can finally open `dev-resources/public/index.html` in the browser and play around
    with the product of our work!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简单地保存文件并确保代码正确编译。我们最终可以在浏览器中打开 `dev-resources/public/index.html` 并对我们的工作成果进行尝试！
- en: Exercises
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In this exercise, we will modify the `om-pm` project we created in the previous
    section. The objective is to add keyboard shortcuts so that power users can operate
    the agile board more efficiently.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将修改上一节中创建的 `om-pm` 项目。目标是添加键盘快捷键，以便高级用户可以更高效地操作敏捷看板。
- en: 'The shortcuts to be supported are:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持的快捷键：
- en: 'The `up`, `down`, `left`, and `right` arrow keys: These allow the user to navigate
    through the cards, highlighting the current one'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`上`、`下`、`左` 和 `右` 方向键：这些允许用户在卡片之间导航，突出显示当前卡片'
- en: 'The `n` and `p` keys: These are used to move the current card to the next (right)
    or previous (left) column, respectively'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n` 和 `p` 键：这些用于将当前卡片移动到下一个（右）或上一个（左）列，分别'
- en: 'The key insight here is to create a new `core.async` channel, which will contain
    key press events. These events will then trigger the actions outlined previously.
    We can use the Google closure library to listen for events. Just add the following
    `require` to the application namespace:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键洞察是创建一个新的`core.async`通道，该通道将包含按键事件。然后，这些事件将触发之前概述的操作。我们可以使用Google closure库来监听事件。只需将以下`require`添加到应用程序命名空间中：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, use this function to create a channel from DOM events:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用此函数从DOM事件创建通道：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The actual logic of moving the cards around based on keyboard shortcuts can
    be implemented in a number of ways, so don't forget to compare your solution with
    the answers provided in this book's companion code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 基于键盘快捷键移动卡片的具体逻辑可以通过多种方式实现，所以不要忘记将你的解决方案与本书配套代码中提供的答案进行比较。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw a different approach on how to handle reactive web interfaces
    by Om and React. In turn, these frameworks make this possible and painless by
    applying functional programming principles such as immutability and persistent
    data structures for efficient rendering.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Om和React处理响应式Web界面的不同方法。反过来，这些框架通过应用函数式编程原则，如不可变性和持久数据结构，使得这一过程变得可能且无痛苦。
- en: We also learned to think the Om way by structuring our applications as a series
    of functions, which receive state and output a DOM representation of state changes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了以Om的方式思考，通过将应用程序结构化为一系列函数，这些函数接收状态并输出状态变化的DOM表示。
- en: Additionally, we saw that by structuring application state transitions through
    `core.async` channels, we separate the presentation logic from the code, which
    will actually perform the work, making our components even easier to reason about.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还看到通过通过`core.async`通道来结构化应用程序状态转换，我们可以将展示逻辑与实际执行工作的代码分离，这使得我们的组件更加易于推理。
- en: 'In the next chapter, we will turn to an often overlooked yet useful tool for
    creating reactive applications: **Futures**.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转向创建响应式应用程序的一个经常被忽视但很有用的工具：**Futures**。
