- en: Chapter 5. Working with Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 与数据工作
- en: The MVC approach talks about the model, view, and controller. We have seen views
    and controllers in detail in the previous chapters and neglected models to quite
    an extent. Models are an important part of MVC; the changes made to a model are
    reflected in the views and controllers using them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MVC方法讨论模型、视图和控制器。我们在前面的章节中详细介绍了视图和控制器，而相当程度上忽略了模型。模型是MVC的重要组成部分；对模型所做的更改将反映在使用它们的视图和控制器中。
- en: Web applications are incomplete without data transactions. This chapter is about
    designing models and handling DB transactions in Play.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没有数据事务的Web应用是不完整的。本章是关于设计模型和在Play中处理数据库事务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: JDBC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC
- en: Anorm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anorm
- en: Slick
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Slick
- en: ReactiveMongo
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReactiveMongo
- en: A Cache API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个缓存API
- en: Introducing models
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍模型
- en: 'A **model** is a domain object, which maps to database entities. For example,
    a social networking application has users. The users can register, update their
    profile, add friends, post links, and so on. Here, the user is a domain object
    and each user will have corresponding entries in the database. Therefore, we could
    define a user model in the following way:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**是一个领域对象，它映射到数据库实体。例如，一个社交网络应用有用户。用户可以注册、更新个人资料、添加朋友、发布链接等。在这里，用户是一个领域对象，每个用户在数据库中都将有相应的条目。因此，我们可以以下这种方式定义一个用户模型：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Earlier, we defined a model without using a database:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们定义了一个没有使用数据库的模型：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The task list example had a `Task` model but it was not bound to a database,
    keeping things simpler. At the end of this chapter, we will be able to back it
    up with a database.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表示例有一个`Task`模型，但它没有绑定到数据库，以保持事情简单。在本章结束时，我们将能够使用数据库来支持它。
- en: JDBC
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDBC
- en: Accessing the DB using **Java Database Connectivity** (**JDBC**) is common in
    applications using relational DBs. Play provides a plugin to manage the JDBC connection
    pool. The plugin internally uses BoneCP ([http://jolbox.com/](http://jolbox.com/)),
    a fast **Java Database Connection pool** (**JDBC pool**) library.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用关系型数据库的应用中，使用**Java数据库连接**（**JDBC**）访问数据库是很常见的。Play提供了一个插件来管理JDBC连接池。该插件内部使用BoneCP
    ([http://jolbox.com/](http://jolbox.com/))，一个快速的**Java数据库连接池**（**JDBC pool**）库。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To use the plugin, a dependency in the build file should be added:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该插件，应在构建文件中添加一个依赖项：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The plugin supports H2, SQLite, PostgreSQL, MySQL, and SQL. Play is bundled
    with an H2 database driver, but to use any of the other databases we should add
    a dependency on its corresponding driver:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 插件支持H2、SQLite、PostgreSQL、MySQL和SQL。Play附带了一个H2数据库驱动程序，但为了使用其他数据库，我们应该添加相应的驱动程序的依赖项：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The plugin exposes the following methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 插件公开以下方法：
- en: '`getConnection`: It accepts the name of the database it should get the connection
    for and whether any statement executed using this connection should commit automatically
    or not. If a name is not provided, it fetches the connection for database with
    the default name.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getConnection`：它接受数据库的名称，以及使用此连接执行任何语句时是否应该自动提交。如果没有提供名称，它将获取默认名称的数据库连接。'
- en: '`withConnection`: It accepts a block of code that should be executed using
    a JDBC connection. Once the block is executed, the connection is released. Alternatively,
    it accepts the name of the database.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withConnection`：它接受一个应该使用JDBC连接执行的代码块。一旦代码块执行完毕，连接将被释放。或者，它接受数据库的名称。'
- en: '`withTransaction`: It accepts a block of code that should be executed using
    a JDBC transaction. Once the block is executed, the connection and all its created
    statements are released.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withTransaction`：它接受一个应该使用JDBC事务执行的代码块。一旦代码块执行完毕，连接及其创建的所有语句都将被释放。'
- en: 'How does the plugin know the details of the database? The details of the database
    can be set in `conf/application.` `conf`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 插件如何知道数据库的详细信息？数据库的详细信息可以在`conf/application.` `conf`中设置：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first part, `db`, is a set of properties, which are used by the DBPlugin.
    The second part is the name of the database, `default` in the example, and the
    last part is the name of the property.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分，`db`，是一组属性，这些属性由DBPlugin使用。第二部分是数据库的名称，例如示例中的`default`，最后一部分是属性的名称。
- en: 'For MySQL and PostgreSQL, we could include the user and password in the URL:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MySQL和PostgreSQL，我们可以在URL中包含用户名和密码：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For additional JDBC configurations, refer to [https://www.playframework.com/documentation/2.3.x/SettingsJDBC](https://www.playframework.com/documentation/2.3.x/SettingsJDBC).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于额外的 JDBC 配置，请参阅 [https://www.playframework.com/documentation/2.3.x/SettingsJDBC](https://www.playframework.com/documentation/2.3.x/SettingsJDBC)。
- en: 'Now that we''ve enabled and configured the the JDBC plugin, we can connect
    to a SQL-like database and execute queries:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启用并配置了 JDBC 插件，我们可以连接到类似 SQL 的数据库并执行查询：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, we can use the `DB.withConnection` helper, which manages the
    DB connection:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `DB.withConnection` 辅助函数，它管理 DB 连接：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Anorm
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Anorm
- en: '**Anorm** is a module in Play that supports interactions with the database
    using a plain SQL.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Anorm** 是 Play 中一个支持使用纯 SQL 与数据库交互的模块。'
- en: Anorm exposes methods to query the SQL database and parse the result as Scala
    objects, built in as well as custom.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Anorm 提供了查询 SQL 数据库并将结果解析为 Scala 对象的方法，包括内置和自定义的。
- en: 'The objective behind Anorm as stated on the Play website ([https://www.playframework.com/documentation/2.3.x/ScalaAnorm](https://www.playframework.com/documentation/2.3.x/ScalaAnorm))
    is:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Anorm 的目标，如 Play 网站上所述（[https://www.playframework.com/documentation/2.3.x/ScalaAnorm](https://www.playframework.com/documentation/2.3.x/ScalaAnorm)）是：
- en: '**Using JDBC is a pain, but we provide a better API**'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**使用 JDBC 是一件痛苦的事情，但我们提供了一个更好的 API**'
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We agree that using the JDBC API directly is tedious, particularly in Java.
    You have to deal with checked exceptions everywhere and iterate over and over
    around the ResultSet to transform this raw dataset into your own data structure.*'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们同意直接使用 JDBC API 是繁琐的，尤其是在 Java 中。你必须处理检查异常，并且反复迭代 ResultSet 以将原始数据集转换为你的数据结构。*'
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We provide a simpler API for JDBC; using Scala you don''t need to bother with
    exceptions, and transforming data is really easy with a functional language. In
    fact, the goal of the Play Scala SQL access layer is to provide several APIs to
    effectively transform JDBC data into other Scala structures.*'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我们提供了一个更简单的 JDBC API；使用 Scala，你不需要担心异常，并且使用函数式语言转换数据非常容易。实际上，Play Scala SQL
    访问层的目的是提供几个 API，以有效地将 JDBC 数据转换为其他 Scala 结构。*'
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**You don''t need another DSL to access relational databases**'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**你不需要另一个 DSL 来访问关系数据库**'
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*SQL is already the best DSL for accessing relational databases. We don''t
    need to invent something new. Moreover the SQL syntax and features can differ
    from one database vendor to another.*'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*SQL 已经是访问关系数据库的最佳 DSL，我们不需要发明新的东西。此外，SQL 语法和功能可能因数据库供应商而异。*'
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you try to abstract this point with another proprietary SQL like DSL you
    will have to deal with several dialects dedicated for each vendor (like Hibernate
    ones), and limit yourself by not using a particular database''s interesting features.*'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果你尝试使用另一个专有 SQL DSL 抽象这个点，你将不得不处理针对每个供应商的几个方言（如 Hibernate 的），并且限制自己不使用特定数据库的有趣功能。*'
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Play will sometimes provide you with pre-filled SQL statements, but the idea
    is not to hide the fact that we use SQL under the hood. Play just saves typing
    a bunch of characters for trivial queries, and you can always fall back to plain
    old SQL.*'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Play 有时会为你提供预填充的 SQL 语句，但我们的想法不是隐藏我们底层使用 SQL 的事实。Play 只是为了在简单查询中节省输入大量字符，你总是可以回退到普通的
    SQL。*'
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**A typesafe DSL to generate SQL is a mistake**'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**生成 SQL 的类型安全 DSL 是一个错误**'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Some argue that a type safe DSL is better since all your queries are checked
    by the compiler. Unfortunately the compiler checks your queries based on a meta-model
    definition that you often write yourself by mapping your data structure to the
    database schema.*'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*有些人认为类型安全的 DSL 更好，因为所有查询都由编译器检查。不幸的是，编译器根据你通常通过将数据结构映射到数据库模式而编写的元模型定义来检查你的查询。*'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*There are no guarantees that this meta-model is correct. Even if the compiler
    says that your code and your queries are correctly typed, it can still miserably
    fail at runtime because of a mismatch in your actual database definition.*'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*没有保证这个元模型是正确的。即使编译器说你的代码和查询类型正确，它仍然可能在运行时因为实际数据库定义的不匹配而悲惨地失败。*'
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Take control of your SQL code**'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**掌握你的 SQL 代码**'
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Object Relational Mapping works well for trivial cases, but when you have
    to deal with complex schemas or existing databases, you will spend most of your
    time fighting with your ORM to make it generate the SQL queries you want.*'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*对象关系映射在简单情况下工作得很好，但当你必须处理复杂的模式或现有数据库时，你将花费大部分时间与你的 ORM 作战，以使其生成你想要的 SQL 查询。*'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Writing SQL queries yourself can be tedious for a simple ''Hello World'' application,
    but for any real-life application, you will eventually save time and simplify
    your code by taking full control of your SQL code.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*自己编写 SQL 查询对于简单的 ''Hello World'' 应用程序来说可能是繁琐的，但对于任何实际应用，您最终将通过完全控制您的 SQL 代码来节省时间和简化代码。*'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When developing an application using Anorm, its dependency should be specified
    explicitly, since it is a separate module in Play (starting from Play 2.1):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Anorm 开发应用程序时，应明确指定其依赖项，因为它在 Play 中是一个独立的模块（从 Play 2.1 开始）：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s picture our user model in MySQL. The table can be defined as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 MySQL 中想象我们的用户模型。表可以定义如下：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now let''s look at the different queries we will make in this table. The queries
    will be as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们将在这个表中进行的不同查询。查询如下所示：
- en: '`Insert`: This query includes adding a new user'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Insert`：此查询包括添加新用户'
- en: '`Update`: This query includes updating the profile, password, and so on'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update`：此查询包括更新配置文件、密码等'
- en: '`Select`: This query includes fetching one or more user''s details, based on
    particular criteria'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select`：此查询包括根据特定标准检索一个或多个用户的详细信息'
- en: Assume that when a user requests to delete his account from our application,
    we do not delete the user from the database, but instead mark the user's status
    as inactive. Therefore, we will not use any delete queries.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当用户请求从我们的应用程序中删除其账户时，我们不会从数据库中删除用户，而是将用户的状态标记为不活跃。因此，我们不会使用任何删除查询。
- en: 'Using Anorm, we could have the `userId` autogenerated as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Anorm，我们可以自动生成 `userId` 如下：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `loginId`, `password`, `name`, and `dob` are variables that are replaced
    in the query at runtime. Anorm builds only `java.sql.PreparedStatements`, which
    prevents SQL injection.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`loginId`、`password`、`name` 和 `dob` 是在运行时替换查询的变量。Anorm 只构建 `java.sql.PreparedStatements`，这可以防止
    SQL 注入。
- en: 'The SQL method returns an object of the `SimpleSql` type and is defined as
    follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 方法返回 `SimpleSql` 类型的对象，并定义如下：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`SimpleSql` is used to represent a query in an intermediate format. Its constructor
    is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleSql` 用于表示查询的中间格式。其构造函数如下：'
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `executeInsert` method fetches `PreparedStatement` from the `SimpleSql`
    object using its `getFilledStatement` method. Then the `getGeneratedKeys()` method
    of `PreparedStatement` is executed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`executeInsert` 方法使用 `SimpleSql` 对象的 `getFilledStatement` 方法获取 `PreparedStatement`。然后执行
    `PreparedStatement` 的 `getGeneratedKeys()` 方法。'
- en: The `getGeneratedKeys` method results in an autogenerated key, created as a
    result of executing the statement in which it is called. If no key is created,
    it returns an empty object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGeneratedKeys` 方法产生一个自动生成的键，它是调用它的语句执行的结果。如果没有创建键，它返回一个空对象。'
- en: 'Now let''s use Anorm to update a user''s password:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 Anorm 更新用户的密码：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `executeUpdate` method works similar to `executeInsert`. The difference
    is that it calls the `executeUpdate` method of the `PreparedStatement`, instead
    of `getGeneratedKeys`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`executeUpdate` 方法的工作方式与 `executeInsert` 类似。区别在于它调用 `PreparedStatement` 的 `executeUpdate`
    方法，而不是 `getGeneratedKeys`。'
- en: The `executeUpdate` method returns a count of affected rows for the **Data Manipulation
    Language** (**DML**) statements. If the SQL statement is of the other types, such
    as **Data Definition Language** (**DDL**), it returns `0`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`executeUpdate` 方法返回受影响的行数，对于 **数据操纵语言**（**DML**）语句。如果 SQL 语句是其他类型，例如 **数据定义语言**（**DDL**），则返回
    `0`。'
- en: 'Now let''s try to fetch the details of all registered users. If we want the
    resulting rows to be parsed as user objects, we should define a parser. The parser
    for a user will be as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试获取所有注册用户的详细信息。如果我们希望结果行被解析为用户对象，我们应该定义一个解析器。用户的解析器如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In most queries, we will not need the password and date of birth, so we can
    exclude them from the user `RowParser` default.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数查询中，我们不需要密码和出生日期，因此我们可以从用户 `RowParser` 默认中排除它们。
- en: 'A query using this parser can be shown in this way:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此解析器的查询可以表示如下：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `.*` symbol indicates that the result should have one or more rows similar
    to its common interpretation in regular expressions. Similarly, the `.+` symbol
    can be used when we expect the result to consist of zero or more rows.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`.*` 符号表示结果应有一行或多行，类似于正则表达式中的常见解释。同样，当预期结果由零行或多行组成时，可以使用 `.+` 符号。'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you''re using an older version of Scala where string interpolations are
    not supported, the queries would be written in this way:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是不支持字符串插值的较旧版本的 Scala，查询将按如下方式编写：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `on` method updates the query with the parameter map passed to it. It is
    defined for `SimpleSql` in the following way:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`on`方法通过传递给它的参数映射更新查询。它是在以下方式中为`SimpleSql`定义的：'
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please refer to the Play documentation ([http://www.playframework.com/documentation/2.3.x/ScalaAnorm](http://www.playframework.com/documentation/2.3.x/ScalaAnorm))
    and the Anorm API documentation ([http://www.playframework.com/documentation/2.3.x/api/scala/index.html#anorm.package](http://www.playframework.com/documentation/2.3.x/api/scala/index.html#anorm.package))
    for more use casess and details.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅Play文档（[http://www.playframework.com/documentation/2.3.x/ScalaAnorm](http://www.playframework.com/documentation/2.3.x/ScalaAnorm)）和Anorm
    API文档（[http://www.playframework.com/documentation/2.3.x/api/scala/index.html#anorm.package](http://www.playframework.com/documentation/2.3.x/api/scala/index.html#anorm.package)）以获取更多用例和详细信息。
- en: Slick
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slick
- en: 'According to Slick''s website ([http://slick.typesafe.com/doc/2.1.0/introduction.html#what-is-slick](http://slick.typesafe.com/doc/2.1.0/introduction.html#what-is-slick)):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Slick网站（[http://slick.typesafe.com/doc/2.1.0/introduction.html#what-is-slick](http://slick.typesafe.com/doc/2.1.0/introduction.html#what-is-slick)）：
- en: '*Slick is Typesafe''s modern database query and access library for Scala. It
    allows you to work with stored data almost as if you were using Scala collections
    while at the same time giving you full control over when a database access happens
    and which data is transferred. You can also use SQL directly.*'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Slick是Typesafe为Scala提供的现代数据库查询和访问库。它允许您以使用Scala集合的方式处理存储数据，同时同时让您完全控制数据库访问发生的时间和传输的数据。您还可以直接使用SQL。*'
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*When using Scala instead of raw SQL for your queries you benefit from compile-time
    safety and compositionality. Slick can generate queries for different backend
    databases including your own, using its extensible query compiler.*'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*当使用Scala而不是原始SQL进行查询时，您将受益于编译时安全性和组合性。Slick可以使用其可扩展的查询编译器为不同的后端数据库生成查询，包括您自己的数据库。*'
- en: 'We can use Slick in our Play application through the play-slick plugin. The
    plugin provides some additional features for the use of Slick in a Play application.
    According to [https://github.com/playframework/](https://github.com/playframework/),
    play-slick consists of three features:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过play-slick插件在我们的Play应用程序中使用Slick。该插件为Slick在Play应用程序中的使用提供了额外的功能。根据[https://github.com/playframework/](https://github.com/playframework/)，play-slick包括以下三个特性：
- en: A wrapper DB object that uses the datasources defined in the Play config files,
    and pulls them from a connection pool. It is there so it is possible to use Slick
    sessions in the same fashion as you would Anorm JDBC connections. There are some
    smart caching and load balancing that make your connections to your DB perform
    better.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包装器DB对象，它使用Play配置文件中定义的数据源，并从连接池中提取它们。它存在是为了能够以与Anorm JDBC连接相同的方式使用Slick会话。有一些智能缓存和负载均衡，可以使您的数据库连接性能更佳。
- en: A DDL plugin that reads Slick tables and automatically creates schema updates
    on reload. This is useful in particular for demos and to get started.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个DDL插件，它读取Slick表并在重新加载时自动创建模式更新。这在演示和入门时特别有用。
- en: A wrapper to use play Enumeratees together with Slick
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包装器，用于与Slick一起使用play Enumeratees
- en: 'To use it, we need to add the following library dependency in the build file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们需要在构建文件中添加以下库依赖项：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'First, we need to define the schema in Scala. This can be done by mapping the
    required tables to case classes. For our user table, the schema can be defined
    as:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在Scala中定义模式。这可以通过将所需的表映射到case类来完成。对于我们的用户表，模式可以定义为：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Table` is a Slick trait and its columns are specified through the `column`
    method. The following types are supported for a column:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table`是Slick的一个特质，其列通过`column`方法指定。以下类型适用于列：'
- en: '**Numeric types**: These include `Byte`, `Short`, `Int`, `Long`, `BigDecimal`,
    `Float`, and `Double`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数值类型**：包括`Byte`、`Short`、`Int`、`Long`、`BigDecimal`、`Float`和`Double`'
- en: '**Date types**: These include `java.sql.Date`, `java.sql.Time`, and `java.sql.Timestamp`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期类型**：包括`java.sql.Date`、`java.sql.Time`和`java.sql.Timestamp`'
- en: '**UUID type:** `This includes java.util.UUID`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UUID类型**：包括`java.util.UUID`'
- en: '**LOB types**: These include `java.sql.Blob`, `java.sql.Clob`, and `Array[Byte]`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LOB类型**：包括`java.sql.Blob`、`java.sql.Clob`和`Array[Byte]`'
- en: '**Other types**: These include `Boolean`, `String`, and `Unit`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他类型**：包括`Boolean`、`String`和`Unit`'
- en: The `column` method accepts column constraints, such as `PrimaryKey`, `Default`,
    `AutoInc`, `NotNull`, and `Nullable`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`column`方法接受列约束，如`PrimaryKey`、`Default`、`AutoInc`、`NotNull`和`Nullable`。'
- en: The `*` method is mandatory for every table and is similar to `RowParser`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个表，`*`方法是强制性的，类似于`RowParser`。
- en: 'Now we can define a `TableQuery` Slick using this and use it to query a database.
    There are simple methods available for performing equivalent DB operations. We
    can define the methods in the Anorm object using the play-slick wrapper along
    with the Slick API:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个定义一个`TableQuery` Slick，并使用它来查询数据库。有简单的方法可以执行等效的DB操作。我们可以使用play-slick包装器和Slick
    API在Anorm对象中定义这些方法：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `run` method is equivalent to calling `SELECT *`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`方法等同于调用`SELECT *`。'
- en: For more details on this, refer to the Slick ([http://slick.typesafe.com/doc/2.1.0/](http://slick.typesafe.com/doc/2.1.0/))
    and the play-slick documentation ([https://github.com/playframework/play-slick](https://github.com/playframework/play-slick)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情请参阅Slick([http://slick.typesafe.com/doc/2.1.0/](http://slick.typesafe.com/doc/2.1.0/))和play-slick文档([https://github.com/playframework/play-slick](https://github.com/playframework/play-slick))。
- en: ReactiveMongo
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactiveMongo
- en: 'A lot of applications these days use a NoSQL database as a result of unstructured
    data, write scalability, and so on. MongoDB is one such database. According to
    its website ([http://docs.mongodb.org/manual/core/introduction/](http://docs.mongodb.org/manual/core/introduction/)):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非结构化数据、写入可扩展性等原因，现在许多应用程序使用NoSQL数据库。MongoDB就是其中之一。根据其网站([http://docs.mongodb.org/manual/core/introduction/](http://docs.mongodb.org/manual/core/introduction/))：
- en: '*MongoDB is an open source document database that provides high performance,
    high availability, and automatic scaling.*'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*MongoDB是一个提供高性能、高可用性和自动扩展的开源文档数据库。*'
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Key features of MongoDB are:'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MongoDB的关键特性包括：
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: High performance
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 高性能
- en: ''
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: High availability (automatic failover, data redundancy)
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 高可用性（自动故障转移、数据冗余）
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Automatic scaling (horizontal scalability)
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自动扩展（水平扩展）
- en: ReactiveMongo is a Scala driver for MongoDB that supports non-blocking and asynchronous
    I/O operations. There is a plugin for the Play Framework called Play-ReactiveMongo.
    It is not a Play plugin but it's supported and maintained by the team of ReactiveMongo.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveMongo是MongoDB的Scala驱动程序，支持非阻塞和异步I/O操作。有一个名为Play-ReactiveMongo的Play Framework插件。它不是一个Play插件，但它由ReactiveMongo团队支持和维护。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This section requires prior knowledge of MongoDB, so please refer to [https://www.mongodb.org/](https://www.mongodb.org/).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节需要具备MongoDB的相关知识，请参阅[https://www.mongodb.org/](https://www.mongodb.org/)。
- en: 'To use it, we need to do the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们需要做以下操作：
- en: 'Include it as a dependency in the build file:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建文件中将它作为依赖项包含：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Include the plugin in `conf/play.plugins`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`conf/play.plugins`中包含插件：
- en: '[PRE22]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the MongoDB server details in `conf/application.conf`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`conf/application.conf`中添加MongoDB服务器详情：
- en: '[PRE23]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, use the following:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用以下方法：
- en: '[PRE24]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's see usage of the plugin with a sample application. We may come across
    an instance in our application where we allow users to monitor activities on their
    devices in the form of heat sensors, smoke detectors, and so on.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例应用程序来看看这个插件的用法。在我们的应用程序中，我们可能会遇到允许用户以热传感器、烟雾探测器等形式监控其设备活动的情况。
- en: 'Before using the device with our application installed on it, the device should
    be registered with this application. Each device has `ownerId`, `deviceId`, its
    configuration, and product information. So, let''s assume that, on registration,
    we get a JSON in this format:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在将设备与安装了我们的应用程序的设备一起使用之前，该设备应注册到这个应用程序中。每个设备都有一个`ownerId`、`deviceId`、其配置和产品信息。因此，让我们假设在注册时，我们以以下格式获得一个JSON：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once a device is registered, the owner can update the configuration or agree
    to update the product's software. Updating software is handled by the device company,
    and we only need to update the details in our application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设备注册，所有者可以更新配置或同意更新产品的软件。软件更新由设备公司处理，我们只需要在我们的应用程序中更新详细信息。
- en: 'The queries to the database will be:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据库的查询将是：
- en: '`Insert`: This query includes registering a device'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Insert`：此查询包括注册设备'
- en: '`Update`: This query includes updating device configuration or information'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update`：此查询包括更新设备配置或信息'
- en: '`Delete`: This query occurs when a device is unregistered'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delete`：此查询发生在设备注销时'
- en: '`Select`: This query occurs when an owner wishes to view the details of the
    device'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select`：此查询发生在所有者希望查看设备详情时'
- en: 'Using Reactive Mongo, the device registration will be:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Reactive Mongo，设备注册将是：
- en: '[PRE26]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this snippet, we''ve built a JSON object from the available device details
    and inserted it in `devices`. Here, the collection is defined as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们已从可用的设备详细信息中构建了一个JSON对象，并将其插入到`devices`中。在这里，集合定义如下：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The insert command accepts the data and its type:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 插入命令接受数据和其类型：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This leaves us with just the update query. An update is triggered for a single
    property of configuration or information, that is, the request has just one field
    and its new value is this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了更新查询。更新是针对配置或信息的单个属性触发的，也就是说，请求只有一个字段，其新值如下：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, a query to update this would be:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新此内容的查询将是：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we wish to update a field for a given document in MongoDB, we should add
    the updated data to the `$set` field in the query. For example, an equivalent
    MongoDB query would be as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望更新MongoDB中给定文档的字段时，我们应该将更新后的数据添加到查询中的`$set`字段。例如，等效的MongoDB查询如下所示：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The Cache API
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存API
- en: Caching in a web application is the process of storing dynamically generated
    items, whether these are data objects, pages, or parts of a page, in memory at
    the initial time they are requested. This can later be reused if subsequent requests
    for the same data are made, thereby reducing response time and enhancing user
    experience. One can cache or store these items on the web server or other software
    in the request stream, such as the proxy server or browser.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，缓存是将动态生成的内容（无论是数据对象、页面还是页面的一部分）在首次请求时存储在内存中的过程。如果后续请求相同的数据，则可以稍后重用，从而减少响应时间并提高用户体验。这些项目可以存储在Web服务器或其他软件中，例如代理服务器或浏览器。
- en: 'Play has a minimal cache API, which uses EHCache. As stated on its website
    ([http://ehcache.org/](http://ehcache.org/)):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Play有一个最小的缓存API，它使用EHCache。如其在网站([http://ehcache.org/](http://ehcache.org/))上所述：
- en: '**Ehcache** *is an open source, standards-based cache for boosting performance,
    offloading your database, and simplifying scalability. It''s the most widely-used
    Java-based cache because it''s robust, proven, and full-featured. Ehcache scales
    from in-process, with one or more nodes, all the way to mixed in-process/out-of-process
    configurations with terabyte-sized caches.*'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Ehcache**是一个开源、基于标准的缓存，用于提升性能、减轻数据库负担并简化可伸缩性。由于它稳健、经过验证且功能全面，因此它是使用最广泛的基于Java的缓存。Ehcache可从进程内、一个或多个节点扩展到混合进程内/进程外配置，缓存大小可达数TB。'
- en: It provides caching for presentation layers as well as application-specific
    objects. It is easy to use, maintain, and extend.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它为表示层以及特定于应用程序的对象提供缓存。它易于使用、维护和扩展。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To use the default cache API within a Play application, we should declare it
    as a dependency as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Play应用程序中使用默认的缓存API，我们应该如下声明它作为依赖项：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the default cache API is similar to using a mutable `Map[String, Any]`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的缓存API类似于使用可变的`Map[String, Any]`：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This API is made available through `EHCachePlugin`. The plugin is responsible
    for creating an instance of EHCache CacheManager with an available configuration
    on starting the application, and shutting it down when the application is stopped.
    We will discuss Play plugins in detail in [Chapter 13](ch13.html "Chapter 13. Writing
    Play Plugins"), *Writing Play Plugins*. Basically, `EHCachePlugin` handles all
    the boilerplate required to use EHCache in an application and `EhCacheImpl` provides
    the methods to do so, such as `get`, `set`, and `remove`. It is defined as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此API通过`EHCachePlugin`提供。该插件负责在启动应用程序时创建一个具有可用配置的EHCache CacheManager实例，并在应用程序停止时关闭它。我们将在[第13章](ch13.html
    "第13章。编写Play插件")中详细讨论Play插件，*编写Play插件*。基本上，`EHCachePlugin`处理使用EHCache在应用程序中所需的所有样板代码，而`EhCacheImpl`提供执行这些操作的方法，例如`get`、`set`和`remove`。它定义如下：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the plugin looks for `ehcache.xml` in the `conf` directory and,
    if the file does not exist, the default configuration provided by the `ehcache-default.xml`
    framework is loaded.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，插件在`conf`目录中查找`ehcache.xml`文件，如果该文件不存在，则加载`ehcache-default.xml`框架提供的默认配置。
- en: It is also possible to specify the location of the `ehcache` configuration when
    starting the application using the `ehcache.configResource` argument.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在启动应用程序时使用`ehcache.configResource`参数指定`ehcache`配置的位置。
- en: The Cache API also simplifies handling a cache for results from requests on
    both the client and server side of the application. Adding `EXPIRES` and `etag`
    headers can be used to manipulate the client-side cache, while on the server side
    the results are cached so that its corresponding action is not computed for each
    call.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存API还简化了处理应用程序客户端和服务器端请求结果的缓存。添加`EXPIRES`和`etag`头可以用来操作客户端缓存，而在服务器端，结果被缓存，因此对应的操作不会在每次调用时计算。
- en: 'For example, we can cache the result of the request used to fetch details of
    inactive users:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以缓存用于获取不活跃用户详细信息的请求的结果：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, what if we want this to get updated every hour? We just need to specify
    the duration explicitly:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想每小时更新一次，我们只需明确指定持续时间即可：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'All of this is handled by the `Cached` case class and its companion object.
    The case class is defined as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都被`Cached`案例类及其伴随对象处理。案例类定义如下：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The companion object provides commonly required methods to generate cached instances,
    such as cache action based on its status, and so on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象提供了生成缓存实例的常用方法，例如根据其状态缓存操作等。
- en: 'The `apply` method in cached calls the `build` method, which is defined as
    follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存调用中的`apply`方法调用定义如下：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It simply checks if the result was modified or not. If it hasn''t been, it
    tries to get the result from the `Cache`. If the result does not exist in the
    cache, it fetches it from the action and adds it to the `Cache` using the `handleResult`
    method. The `handleResult` method is defined as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是简单地检查结果是否已被修改。如果没有被修改，它尝试从`Cache`中获取结果。如果结果不在缓存中，它将从操作中获取它，并使用`handleResult`方法将其添加到`Cache`中。`handleResult`方法定义如下：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If a duration is specified, it returns that else it returns the default duration
    of one year.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了持续时间，它将返回该值，否则它将返回默认的一年持续时间。
- en: The `handleResult` method simply takes the result, adds `etag`, expires headers,
    and then adds the result with the given key to `Cache`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleResult`方法简单地接受结果，添加`etag`、过期头信息，然后将带有给定键的结果添加到`Cache`中。'
- en: Troubleshooting
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'The following section covers some common scenarios:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分涵盖了某些常见场景：
- en: Anorm throws an error at the `SqlMappingError` runtime (too many rows when you're
    expecting a single one), even though the query resulted in expected behavior.
    It is an insert query using "on duplicate key update".
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使查询产生了预期的行为，Anorm也会在`SqlMappingError`运行时抛出错误（当你期望一行时却有多行），这是一个使用“on duplicate
    key update”的插入查询。
- en: 'This can happen when such a query is being executed using `executeInsert`.
    The `executeInsert` method should be used when we need to return an autogenerated
    key. If we are updating some fields through a duplicate key, it means that we
    do not actually need the key. We could use `executeUpdate` to add a check if one
    row has been updated. For example, we may want to update the wishlist table, which
    tracks what a user has wished for:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可能发生在使用`executeInsert`执行此类查询时。当我们需要返回自动生成的键时，应使用`executeInsert`方法。如果我们通过重复键更新某些字段，这意味着我们实际上不需要键。我们可以使用`executeUpdate`来添加一个检查，看是否有一行已被更新。例如，我们可能想更新跟踪用户愿望清单的表：
- en: '[PRE40]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Can we use multiple databases for a single application?
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能否为单个应用程序使用多个数据库？
- en: Yes, it is possible to use a different database of the same as well as a different
    kind. If an application requires this, we can use two or more different relational
    or NoSQL databases or a combination of both. For example, the application may
    store its user data in SQL (as we already know the format of the user data) and
    the information about THE user's devices in MongoDB (since the devices are from
    different vendors, the format of their data can change).
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的，可以使用不同类型的数据库，包括相同类型和不同类型。如果一个应用程序需要这样做，我们可以使用两个或更多不同的关系型数据库或NoSQL数据库，或者两者的组合。例如，应用程序可能将其用户数据存储在SQL数据库中（因为我们已经知道用户数据的格式），而将用户设备的信息存储在MongoDB中（因为设备来自不同的供应商，它们的数据格式可能会变化）。
- en: Anorm does not throw a compilation error when a query has an incorrect syntax.
    Is there a configuration to enable this?
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当查询有错误的语法时，Anorm不会抛出编译错误。是否有配置可以启用此功能？
- en: It has been developed with the aim of using SQL queries in the code without
    any hassle. The developers are expected to pass correct queries to Anorm methods.
    To ensure that such errors do not occur at runtime, developers can execute the
    query locally and use it in the code if it succeeds. Alternatively, there are
    some third-party plugins that provide a typesafe DSL and can be used instead of
    Anorm if they meet the requirement, such as play-slick or scalikejdbc-play-support
    ([https://github.com/scalikejdbc/scalikejdbc-play-support](https://github.com/scalikejdbc/scalikejdbc-play-support))
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它的开发目的是在代码中使用 SQL 查询而无需任何麻烦。开发者预计会将正确的查询传递给 Anorm 方法。为了确保在运行时不会发生此类错误，开发者可以在本地执行查询并在成功后将其用于代码中。或者，还有一些第三方插件提供了类型安全的
    DSL，如果它们满足要求，可以替代 Anorm 使用，例如 play-slick 或 scalikejdbc-play-support ([https://github.com/scalikejdbc/scalikejdbc-play-support](https://github.com/scalikejdbc/scalikejdbc-play-support))。
- en: Is it possible to use another caching mechanism?
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以使用其他的缓存机制？
- en: Yes, it is possible to extend support for any other cache, such as OSCache,
    SwarmCache, MemCached, and so on, or a custom one by writing a plugin similar
    to EHCachePlugin. Some of the popular caching mechanisms already have Play plugins
    developed by individuals and/or other organizations. For example, play2-memcached
    ([https://github.com/mumoshu/play2-memcached](https://github.com/mumoshu/play2-memcached))
    and Redis plugin ([https://github.com/typesafehub/play-plugins/tree/master/redis](https://github.com/typesafehub/play-plugins/tree/master/redis)).
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的，可以扩展对任何其他缓存的支持，例如 OSCache、SwarmCache、MemCached 等等，或者通过编写类似于 EHCachePlugin
    的插件来实现自定义缓存。一些流行的缓存机制已经由个人和/或其他组织开发了 Play 插件。例如，play2-memcached ([https://github.com/mumoshu/play2-memcached](https://github.com/mumoshu/play2-memcached))
    和 Redis 插件 ([https://github.com/typesafehub/play-plugins/tree/master/redis](https://github.com/typesafehub/play-plugins/tree/master/redis))。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we saw different ways of persisting application data in an
    application built using the Play Framework. In doing so, we have seen two contrasting
    approaches: one using a relational DB and the other using a NoSQL DB. To persist
    in a relational DB, we looked at how the Anorm module and the JDBC plugin work.
    To use a NoSQL database (MongoDB) for our application''s backend, we used the
    Play plugin for ReactiveMongo. In addition to this, we saw how the Play Cache
    API can be used and how it works.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了在用 Play 框架构建的应用程序中持久化应用程序数据的不同方法。在这个过程中，我们看到了两种截然不同的方法：一种使用关系型数据库，另一种使用
    NoSQL 数据库。为了在关系型数据库中持久化，我们研究了 Anorm 模块和 JDBC 插件的工作方式。为了将 NoSQL 数据库（MongoDB）用于我们应用程序的后端，我们使用了
    Play 的 ReactiveMongo 插件。除此之外，我们还看到了如何使用 Play 缓存 API 以及它是如何工作的。
- en: In the next chapter, we will be learning all about handling data streams in
    Play.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在 Play 中处理数据流。
