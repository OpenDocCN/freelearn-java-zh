- en: Chapter 7. Annotations and CDI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章 注解和 CDI
- en: 'Right up to this moment, we had to use annotations and dependency injections
    without trying to understand how they work. This chapter therefore aims to present
    and highlight improvements in the relevant APIs. The APIs concerned are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 直至此刻，我们不得不使用注解和依赖注入，而不去尝试理解它们是如何工作的。因此，本章旨在介绍和强调相关 API 的改进。相关的 API 包括：
- en: Common annotations for the Java Platform 1.2
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 平台通用注解 1.2
- en: Contexts and Dependency Injection 1.1
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文和依赖注入 1.1
- en: Common annotations for the Java platform
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 平台的通用注解
- en: The common annotations for the Java platform 1.2 Specification was developed
    under JSR 250\. This section just gives you an overview of improvements in the
    API. The complete document specification (for more information) can be downloaded
    from [http://jcp.org/aboutJava/communityprocess/mrel/jsr250/index.html](http://jcp.org/aboutJava/communityprocess/mrel/jsr250/index.html).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Java 平台通用注解 1.2 规范是在 JSR 250 下开发的。本节仅为您概述 API 的改进。完整的文档规范（更多信息）可以从 [http://jcp.org/aboutJava/communityprocess/mrel/jsr250/index.html](http://jcp.org/aboutJava/communityprocess/mrel/jsr250/index.html)
    下载。
- en: The goal of this specification
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本规范的目标
- en: Annotations are a form of metadata that are generally used to describe, configure,
    or mark elements (such as class, method, and attribute) of Java code. In the following
    code, we use the `@Stateless` annotation to configure `MySessionBean` class as
    a stateless session bean, we use the `@Deprecated` annotation to mark `oldMethod()`
    method as obsolete, and finally we set the `save()` method with the `@TransactionAttribute`
    annotation so that it will always use a dedicated transaction.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是一种元数据，通常用于描述、配置或标记 Java 代码中的元素（如类、方法和属性）。在以下代码中，我们使用 `@Stateless` 注解将 `MySessionBean`
    类配置为无状态会话 Bean，我们使用 `@Deprecated` 注解标记 `oldMethod()` 方法为过时，最后我们使用 `@TransactionAttribute`
    注解设置 `save()` 方法，使其始终使用专用事务。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The annotations have been integrated into the Java language since JDK 5 and
    they are now widely used in many APIs. To avoid redefining some annotations in
    several APIs, the JCP developed the common annotations for the Java platform specification
    with the goal of regrouping annotations that are common to different Java EE APIs,
    which avoids redundancy and facilitates the maintenance of regrouped annotations.
    In the following code, we have the example of the `@Resource` annotation from
    the common annotations for the Java platform API , which permits us to access
    an object of type `SessionContext` in a web container and in an EJB container.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自 JDK 5 以来，注解已经集成到 Java 语言中，并且现在在许多 API 中被广泛使用。为了避免在多个 API 中重新定义一些注解，JCP 开发了
    Java 平台规范的通用注解，目的是将不同 Java EE API 中的通用注解重新分组，从而避免冗余并简化重新分组注解的维护。以下代码展示了来自 Java
    平台 API 的通用注解 `@Resource` 的示例，它允许我们在 Web 容器和 EJB 容器中访问 `SessionContext` 类型的对象。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Building your own annotation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自己的注解
- en: Although there are already several annotations, Java offers the opportunity
    to create new custom annotations if you need. To do this, you should know that
    an annotation is declared as a Java interface. The only difference is that, in
    the case of the annotation the keyword `interface` must be preceded by the character
    `@`. The following code shows the declaration of the custom annotation `Unfinished`.
    This annotation contains a parameter named `message` whose default value is `Nothing
    has been done`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经存在几个注解，但如果需要，Java 提供了创建自定义注解的机会。为此，你应该知道注解被声明为 Java 接口。唯一的区别是，在注解的情况下，关键字
    `interface` 必须由字符 `@` 预先指定。以下代码展示了自定义注解 `Unfinished` 的声明。这个注解包含一个名为 `message`
    的参数，其默认值为 `Nothing has been done`。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you declare your annotation, you must now define its characteristics.
    The basic characteristics of an annotation are defined through dedicated annotations
    contained in the `java.lang.annotation` package. These annotations are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了你的注解，现在你必须定义其特性。注解的基本特性是通过包含在 `java.lang.annotation` 包中的专用注解来定义的。这些注解如下：
- en: '`@Target`: This is used to define the element types that can be annotated (such
    as class, method, and attribute), for example `@Target({ElementType.METHOD, ElementType.TYPE})`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Target`：用于定义可以注解的元素类型（如类、方法和属性），例如 `@Target({ElementType.METHOD, ElementType.TYPE})`'
- en: '`@Retention`: This is used to define the retention level (such as `RUNTIME`,
    `CLASS`, or `SOURCE`) of your annotation, for example `@Retention(RetentionPolicy.RUNTIME)`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Retention`：这是用来定义你的注解的保留级别（例如`RUNTIME`、`CLASS`或`SOURCE`），例如`@Retention(RetentionPolicy.RUNTIME)`'
- en: '`@Inherited`: This is used to say that the annotation will be automatically
    applied to classes that inherit from the class that has the annotation'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Inherited`：这是用来表示该注解将自动应用于继承具有该注解的类的类'
- en: '`@Documented`: This is used to make your annotation appear in the **Javadoc**
    of the code that contains it'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Documented`：这是用来使你的注解出现在包含它的代码的**Javadoc**中'
- en: It is important to note that there are other characteristics such as the scope
    (set using the `@ScopeType`) in the case of custom CDI scope annotations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，对于自定义CDI作用域注解，还有其他特性，如作用域（使用`@ScopeType`设置）。
- en: After all changes, our annotation takes the form shown in the following code.
    According to the settings, this annotation can decorate methods, types of objects
    (such as `class`, `interface`, or `enum`) and attributes. It will be removed at
    the compile time (because the retention level is `SOURCE`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有更改完成后，我们的注解形式如下所示。根据设置，此注解可以装饰方法、对象类型（如`class`、`interface`或`enum`）和属性。它将在编译时被移除（因为保留级别是`SOURCE`）。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following code demonstrates the usage of the `Unfinished` annotation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了`Unfinished`注解的使用：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although our annotation already looks like a standard annotation, it is not
    yet operational. For this, a class called `processor` must be available to the
    compiler. This class will describe the action to take when an item is annotated
    with our custom annotation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的注解看起来像是一个标准的注解，但它还没有生效。为此，必须有一个名为`processor`的类可供编译器使用。这个类将描述当项目被我们的自定义注解标注时应采取的操作。
- en: To achieve a custom processor for Java 6 annotation, we mainly need to implement
    the `process()` method of the `javax.annotation.processing.Processor` interface
    and define the annotations supported by this processor with the `@SupportedAnnotationTypes`
    annotation. The following code shows the processor of our custom `Unfinished`
    annotation. As you can see, for the implementation of the `process()` method,
    we used the abstract class `AbstractProcessor` that implements the `Processor`
    interface. (This prevents us from having to implement all the methods defined
    in this interface.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Java 6注解实现自定义处理器，我们主要需要实现`javax.annotation.processing.Processor`接口的`process()`方法，并使用`@SupportedAnnotationTypes`注解定义此处理器支持的注解。以下代码展示了我们自定义的`Unfinished`注解的处理器。如您所见，在实现`process()`方法时，我们使用了实现`Processor`接口的抽象类`AbstractProcessor`。（这防止了我们不得不实现该接口中定义的所有方法。）
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the processor is realized, we must now declare it so that it can be found
    by the compiler. The simplest way to do this is to use the Java mechanism for
    services declarations using the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了处理器，我们现在必须声明它，以便编译器可以找到它。最简单的方法是使用以下步骤通过Java机制进行服务声明：
- en: Package your annotation in a `JAR` file.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的注解打包在一个`JAR`文件中。
- en: Include a `META-INF/services` directory in this `JAR` file.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此`JAR`文件中包含一个`META-INF/services`目录。
- en: Include a file named `javax.annotation.processing.Processor` in the `META-INF/services`
    directory.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`META-INF/services`目录中包含一个名为`javax.annotation.processing.Processor`的文件。
- en: Specify in this file the fully qualified names of the processors contained in
    the `JAR` file (one processor per line).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中指定包含在`JAR`文件中的处理器的完全限定名称（每行一个处理器）。
- en: The following screenshot shows the structure of the project that contains the
    `Unfinished` annotation. Failing to put the annotation and the processor in the
    same project as is the case of our example, you can use one project for annotations
    and another for processors. But whatever your option, do not forget to define
    the service in the `META-INF/services` project directory that contains the processor.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了包含`Unfinished`注解的项目结构。如果像我们的示例那样，没有将注解和处理器放在同一个项目中，你可以为注解和处理器使用一个项目。但无论你的选择如何，都不要忘记在包含处理器的`META-INF/services`项目目录中定义服务。
- en: '![Building your own annotation](img/9235OT_07_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![构建自己的注解](img/9235OT_07_01.jpg)'
- en: 'The following screenshot shows the contents of the file `javax.annotation.processing.Processor`.
    As the package contains only a single processor, then it is obvious that we will
    have a single line in this file as shown in the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了文件 `javax.annotation.processing.Processor` 的内容。由于该包只包含一个处理器，因此很明显，在这个文件中我们将只有一行，如下面的截图所示：
- en: '![Building your own annotation](img/9235OT_07_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![构建自己的注解](img/9235OT_07_02.jpg)'
- en: For those using **Maven v2.3.2**, to achieve the project that contains the processors,
    they must set the option `<compilerArgument>-proc:none</compilerArgument>` in
    the configuration of the plugin `maven-compiler-plugin` so that the code is properly
    compiled.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 **Maven v2.3.2** 的用户，为了实现包含处理器的项目，他们必须在 `maven-compiler-plugin` 插件的配置中设置选项
    `<compilerArgument>-proc:none</compilerArgument>`，以确保代码被正确编译。
- en: 'Now you can import the package that contains the annotation in another project
    and use it at your convenience. When compiling our preceding `App` class, we have
    the following result:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将包含注解的包导入到另一个项目中，并按需使用它。在编译我们前面的 `App` 类时，我们得到以下结果：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Latest improvements in action
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最新改进措施
- en: Affected by maintenance release, the common annotation specification has not
    greatly changed. We have in all, the addition of a new annotation and update of
    some sections of the specification document.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 受维护版本的影响，通用注解规范没有发生很大变化。总的来说，我们增加了一个新的注解并更新了规范文档的一些部分。
- en: The new annotation
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的注解
- en: The new annotation that was added to the specification concerns the management
    of priorities when using a series of classes in a given order. This is the `javax.annotation.priority`
    annotation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 新增到规范中的注解涉及在使用一系列类时管理优先级。这是 `javax.annotation.priority` 注解。
- en: The exact role and the ranges of acceptable values for this annotation are defined
    by each specification that uses it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解的确切角色和可接受的值范围由使用它的每个规范定义。
- en: For example, this annotation could be used to manage the execution order of
    interceptors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个注解可以用来管理拦截器的执行顺序。
- en: Contexts and Dependency Injection
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文和依赖注入
- en: The Contexts and Dependency Injection(CDI) for Java EE 1.1 Specification was
    developed under JSR 346\. This section just gives you an overview of improvements
    in the API. The complete document specification (for more information) can be
    downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr346/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr346/index.html).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 1.1 规范中的上下文和依赖注入（CDI）是在JSR 346下开发的。本节仅为您概述API的改进。完整的规范文档（更多信息）可以从 [http://jcp.org/aboutJava/communityprocess/final/jsr346/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr346/index.html)
    下载。
- en: What is CDI ?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是CDI？
- en: 'Introduced in the Java EE platform from Version 6, Contexts and Dependency
    Injection for Java EE (CDI) is a specification that has brought to the platform
    a set of services that simplify the management of the lifecycle of objects, and
    standardize and encourage the use of dependency injection in the Java EE environment.
    In concrete terms, this specification gives us the ability to easily link in a
    loosely coupled and type-safe way the different layers (presentation, business
    and data access) of n-tier architectures. In order to do this, the CDI primarily
    relies on two services that are:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java EE平台6.0版本引入的上下文和依赖注入（CDI）是一个规范，它为平台带来了一组简化对象生命周期管理、标准化并鼓励在Java EE环境中使用依赖注入的服务。具体来说，这个规范使我们能够以松散耦合和类型安全的方式轻松地将不同层（表示层、业务层和数据访问层）连接起来。为了做到这一点，CDI主要依赖于两个服务，它们是：
- en: '**Context**: This is used for the management of the lifecycle of the objects
    (the time of creation and destruction) based on their scope.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：这是基于它们的范围来管理对象的生命周期（创建和销毁的时间）。'
- en: '**Dependency Injection**: This includes a number of elements such as the injection
    of a component into another, the choice of implementation to be injected for a
    given interface and the type of object provided to access the injected dependence:
    a proxy or a reference that gives direct access to the instance.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**：这包括将一个组件注入到另一个组件中、为给定接口选择要注入的实现以及提供用于访问注入依赖的对象类型：一个代理或直接访问实例的引用。'
- en: To get a better idea of the power of CDI, let us take some examples.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解CDI的强大功能，让我们举一些例子。
- en: Example 1 – instantiation of a POJO
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 1 – POJO 的实例化
- en: 'Suppose we have a JSF managed bean that wants to access an instance of a POJO
    that implements an interface. The basic approach is to create an instance of the
    POJO in the managed bean by using the `new` keyword as is the case in the following
    code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个JSF管理Bean，它想要访问实现接口的POJO的一个实例。基本方法是使用`new`关键字在管理Bean中创建POJO的实例，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The drawback with this approach is that the instance of the `HelloWorld` class
    is created in hard code, which causes a very strong coupling between the managed
    bean and implementation of `IHeloWorld` interface. Therefore, to change `IHelloWorld`
    implementation, you must have an access to the managed bean and modify it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是`HelloWorld`类的实例是在硬编码中创建的，这导致管理Bean与`IHeloWorld`接口的实现之间有很强的耦合。因此，要更改`IHelloWorld`实现，你必须能够访问管理Bean并修改它。
- en: 'With the CDI, the managed bean will just declare a dependency on an `IHelloWorld`
    instance and inject it. This gives us the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CDI，管理Bean只需声明对`IHelloWorld`实例的依赖并注入它。这给我们以下代码：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The CDI will look for the implementation of the `IHelloWorld` interface, instantiate
    and inject it. Better still, the CDI will take care of managing the lifecycle
    of the bean that will be injected. Thus, to change the implementation of `IHelloWorld`
    interface, we just have to change the class `HelloWorld`. We will complete our
    code by specifying the scope of the POJO with `@RequestScoped` annotation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CDI将查找`IHelloWorld`接口的实现，实例化并注入它。更好的是，CDI将负责管理将被注入的Bean的生命周期。因此，要更改`IHelloWorld`接口的实现，我们只需更改`HelloWorld`类。我们将通过使用`@RequestScoped`注解指定POJO的作用域来完成我们的代码。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 2 – accessing an EJB from a JSF page
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例2 – 从JSF页面访问EJB
- en: Suppose we have a JSF page where we want to access a method of an EJB component.
    The typical scenario requires you to first access an instance of the EJB from
    the managed bean associated with the JSF page and then call the EJB method in
    a managed bean method that will be called in the JSF page. In terms of code that
    can be translated as shown in the following code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个JSF页面，我们想要访问一个EJB组件的方法。典型的场景需要你首先从与JSF页面关联的管理Bean中访问EJB的一个实例，然后在JSF页面将要调用的管理Bean方法中调用EJB方法。以下代码展示了如何进行转换。
- en: 'The following code is an example of an EJB component:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个EJB组件的示例：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code is an example of a JSF-managed bean:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个JSF管理Bean的示例：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From a JSF page, we can call the method `myEjbHelloWorld`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF页面，我们可以调用`myEjbHelloWorld`方法。
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With CDI, we do not necessarily need to go through a managed bean to access
    the methods of an EJB. In fact, we only need to add the `@Named` annotation to
    our EJB component and it will be accessed from our JSF page like a simple JSF-managed
    bean. The difference between the two annotations (`@Named` and `@ManagedBean`)
    is visible in at least two points: the first point concerns the scope. Indeed,
    the `@ManagedBean` annotation is specific to the JSF Specification while the `@Named`
    annotation can create managed beans accessible to a greater number of specifications
    (including JSF) and provides more flexibility in the handling of JavaBean components.
    The second point relates to the features available to the component. The `@Named`
    annotation allows you to create CDI beans, which gives you the opportunity to
    use features that you will not have access to in a JSF bean, such as: interceptors,
    `Producer`, and `Disposer`. As a general rule, it is advisable to use CDI beans
    whenever possible.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CDI，我们不一定需要通过管理Bean来访问EJB的方法。实际上，我们只需在我们的EJB组件上添加`@Named`注解，它就可以像简单的JSF管理Bean一样从我们的JSF页面访问。这两个注解（`@Named`和`@ManagedBean`）之间的区别至少在两个点上很明显：第一个点是关于作用域的。确实，`@ManagedBean`注解是特定于JSF规范的，而`@Named`注解可以创建对更多规范（包括JSF）可访问的管理Bean，并在处理JavaBean组件方面提供更多灵活性。第二个点与组件可用的功能相关。`@Named`注解允许你创建CDI
    Bean，这给你提供了使用你将无法在JSF Bean中访问的功能的机会，例如：拦截器、`Producer`和`Disposer`。一般来说，建议尽可能使用CDI
    Bean。
- en: 'The following code shows an EJB component annotated with CDI `@Named` annotation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了带有CDI `@Named`注解的EJB组件：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following code shows the access to an EJB from a JSF page:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了从JSF页面访问EJB的方法：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 3 – setting a bean with a specific scope for simple operations
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例3 – 为简单操作设置具有特定作用域的Bean
- en: For one reason or another you may want to implement the singleton pattern. In
    the traditional approach, you will implement a singleton EJB type even if you
    do not necessarily need all of the services that such a component offers (scalability,
    roles-based security, concurrency management, transaction management, and others).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种原因，你可能想实现单例模式。在传统方法中，即使你并不一定需要此类组件提供的服务（可伸缩性、基于角色的安全性、并发管理、事务管理等），你也将实现单例
    EJB 类型。
- en: 'With CDI, you can create your bean with the desired scope without the obligation
    of implementing heavy components for marginal processing. In fact, CDI offers
    several types of scope that can be defined using annotations (`@ApplicationScoped`,
    `@RequestScoped`, and `@SessionScoped`). Thus, to implement the singleton pattern
    without cluttering the services offered by the EJB components, we can simply use
    the application scope annotation of the CDI as shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CDI，你可以创建具有所需作用域的 bean，而无需实现用于边际处理的重量级组件。实际上，CDI 提供了多种作用域类型，可以使用注解（`@ApplicationScoped`、`@RequestScoped`
    和 `@SessionScoped`）来定义。因此，为了在不使 EJB 组件提供的服务杂乱无章的情况下实现单例模式，我们可以简单地使用 CDI 的应用程序作用域注解，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Example 4 – use of objects usually created by a factory
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 4 – 使用通常由工厂创建的对象
- en: 'You want to send an asynchronous message via JMS from EJB. The classical approach
    will require you to instantiate many objects as is the case in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你想通过 JMS 从 EJB 发送异步消息。经典方法将需要你实例化许多对象，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With CDI, all this mass of code is reduced to a line, as shown in the following
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CDI，所有这些代码量可以缩减到一行，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Latest improvements in action
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CDI 规范的最新改进
- en: 'Having been introduced to the platform from Java EE 6, CDI has become an important
    solution for component oriented programming in the Java EE platform. Now it only
    has to spread its tentacles into almost all specifications of the platform so
    that it can link seamlessly more components and integrate more APIs. In the long
    list of improvements that have been made, we will present a few including: the
    possibility of avoiding a bean being processed by the CDI, access to the current
    CDI container, access to the non contexual instances of a bean, and finally the
    ability to explicitly destroy bean instances. The improvement of CDI relating
    to interceptors and decorators will be presented in the next chapter when we will
    discuss the relevant specification.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java EE 6 平台引入以来，CDI 已成为 Java EE 平台中面向组件编程的重要解决方案。现在它只需将其触角扩展到平台几乎所有的规范中，以便能够无缝地连接更多组件和集成更多
    API。在已经做出的众多改进中，我们将介绍其中的一些，包括：避免 bean 被 CDI 处理的可能性、访问当前 CDI 容器、访问 bean 的非上下文实例，以及最终能够显式销毁
    bean 实例的能力。关于拦截器和装饰器的 CDI 改进将在下一章中介绍，届时我们将讨论相关规范。
- en: Avoiding CDI processing on a bean
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免在 bean 上进行 CDI 处理
- en: Version 1.1 of the CDI Specification came with the annotation `@vetoed` that
    prevents an object being considered as a CDI bean. However, a bean decorated with
    this annotation cannot have a lifecycle similar to the contextual instance. So,
    it cannot be injected.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 规范的 1.1 版本引入了 `@vetoed` 注解，该注解防止对象被视为 CDI bean。然而，带有此注解的 bean 不能拥有与上下文实例类似的生命周期。因此，它不能被注入。
- en: 'By looking at this annotation, some might wonder about its usefulness. To preserve
    the integrity of some data, it may happen that you need to control the use of
    some components. But, by using CDI, your components can be manipulated from any
    other component. Hence the role of the `@vetoed` annotation. The following code
    shows us the use of the `@vetoed` annotation on the `Student` entity in order
    to avoid unknown manipulations that can lead to inconsistencies:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这个注解，有些人可能会对其有用性感到疑惑。为了保持某些数据的一致性，可能需要控制某些组件的使用。但是，通过使用 CDI，你的组件可以从任何其他组件中被操作。因此，`@vetoed`
    注解的作用。以下代码展示了在 `Student` 实体上使用 `@vetoed` 注解，以避免可能导致不一致的未知操作：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Accessing the non contexual instance of a bean
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问 bean 的非上下文实例
- en: 'This version also added the ability to inject and execute lifecycle callbacks
    of unmanaged instances of beans. The following code demonstrates how to inject
    and execute lifecycle callbacks of non contexual instances of the bean `Student`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本还增加了注入和执行未管理 bean 实例的生命周期回调的能力。以下代码演示了如何注入和执行 `Student` bean 非上下文实例的生命周期回调：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Accessing the current CDI container
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问当前 CDI 容器
- en: 'The CDI Specification 1.1 has added the ability to access the current CDI container
    programmatically and perform some operations. The following code demonstrates
    how to access a CDI container to explicitly destroy a context object:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CDI规范1.1增加了通过程序访问当前CDI容器并执行一些操作的能力。以下代码演示了如何访问CDI容器以显式销毁上下文对象：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Destroying CDI bean instances explicitly
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式销毁CDI bean实例
- en: To allow explicit destruction of bean instances in applications, CDI 1.1 has
    introduced the `AlterableContext` interface, which contains the `void destroy`(`Contextual<?>
    contextual`) method. Extensions should implement this interface instead of the
    `Context` interface.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许在应用程序中显式销毁bean实例，CDI 1.1引入了`AlterableContext`接口，该接口包含`void destroy(Contextual<?>
    contextual)`方法。扩展应该实现此接口而不是`Context`接口。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After several chapters focused on the realization of a complete system using
    the Java EE 7 platform, this chapter has allowed us to take a break and try to
    review some key concepts that we were using. Thus, we learned to make our own
    annotations and link layers of n-tier applications. In the next chapter, we will
    continue with the implementation of our application by integrating, this time,
    the validation of data exchanged between the different layers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在专注于使用Java EE 7平台实现完整系统的几个章节之后，本章让我们有机会休息一下，尝试回顾一些我们正在使用的关键概念。因此，我们学会了创建自己的注解并链接多层应用层。在下一章中，我们将继续通过集成来实施我们的应用程序，这次是集成不同层之间交换数据的验证。
