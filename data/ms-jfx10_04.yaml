- en: Exploring the Features of WebDriver
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 WebDriver 的功能
- en: 'So far, we have looked at various basic and advanced interactions that a user
    can perform on a web page using WebDriver. In this chapter, we will discuss the
    different capabilities and features of WebDriver that enable test script developers
    to have better control over WebDriver, and consequently of the web application
    that is being tested. The features that we are going to cover in this chapter
    are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了用户可以使用 WebDriver 在网页上执行的各种基本和高级交互。在本章中，我们将讨论 WebDriver 的不同功能和特性，这些功能和特性使测试脚本开发者能够更好地控制
    WebDriver，从而更好地控制正在测试的 Web 应用程序。本章将要涵盖的功能如下：
- en: Taking screenshots
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截图
- en: Locating target windows and iFrames
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位目标窗口和 iFrames
- en: Exploring Navigate
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索导航
- en: Waiting for WebElements to load
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待 Web 元素加载
- en: Handling cookies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 Cookie
- en: Let's get started without any further delay.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即开始，不要有任何延迟。
- en: Taking screenshots
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截图
- en: Taking a screenshot of a web page is a very useful capability of WebDriver.
    This is very handy when your test case fails, and you want to see the state of
    the application when the test case failed. The `TakesScreenShot` interface in
    the WebDriver library is implemented by all of the different variants of WebDriver,
    such as Firefox Driver, Internet Explorer Driver, Chrome Driver, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebDriver 库中，对网页进行截图是一个非常有用的功能。当测试用例失败，你想要查看测试用例失败时应用程序的状态时，这非常有用。WebDriver
    库中的 `TakesScreenShot` 接口由所有不同的 WebDriver 变体实现，例如 Firefox Driver、Internet Explorer
    Driver、Chrome Driver 等。
- en: The `TakesScreenShot` capability is enabled in all of the browsers by default.
    Because this is a read-only capability, a user cannot toggle it. Before we see
    a code example that uses this capability, we should look at an important method
    of the `TakesScreenShot` interface—`getScreenshotAs().`
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`TakesScreenShot` 功能在所有浏览器中默认启用。由于这是一个只读功能，用户无法切换它。在我们查看使用此功能的代码示例之前，我们应该看看
    `TakesScreenShot` 接口的一个重要方法——`getScreenshotAs().`'
- en: 'The API syntax for `getScreenshotAs()` is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`getScreenshotAs()` 的 API 语法如下：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `OutputType` is another interface of the WebDriver library. We can ask
    WebDriver to output the screenshot in three different formats : `BASE64`, `BYTES`
    (raw data), and `FILE`. If you choose the `FILE` format, it writes the data into
    a `.png` file, which will be deleted once the JVM is killed. So, you should always
    copy that file into a safe location so that it can be used for later reference.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`OutputType` 是 WebDriver 库的另一个接口。我们可以要求 WebDriver 以三种不同的格式输出截图：`BASE64`、`BYTES`（原始数据）和
    `FILE`。如果你选择 `FILE` 格式，它将数据写入一个 `.png` 文件，一旦 JVM 被终止，该文件将被删除。因此，你应该始终将该文件复制到安全位置，以便以后参考。
- en: The return type is a specific output that depends on the selected `OutputType`.
    For example, selecting `OutputType.BYTES` will return a `byte`array, and selecting
    `OutputType.FILE` will return a file object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型是特定于所选 `OutputType` 的特定输出。例如，选择 `OutputType.BYTES` 将返回一个 `byte` 数组，而选择 `OutputType.FILE`
    将返回一个文件对象。
- en: 'Depending on the browser used, the output screenshot will be one of the following,
    in order of preference:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的浏览器，输出截图将是以下之一，按优先级排序：
- en: The entire page
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个页面
- en: The current window
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前窗口
- en: A visible portion of the current frame
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前框架的可视部分
- en: The screenshot of the entire display containing the browser
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含浏览器的整个显示屏幕的截图
- en: For example, if you are using Firefox Driver, `getScreenshotAs()` takes a screenshot
    of the entire page, but Chrome Driver returns only the visible portion of the
    current frame.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在使用 Firefox Driver，`getScreenshotAs()` 会截取整个页面的截图，但 Chrome Driver 只返回当前框架的可视部分。
- en: 'It''s time to take a look at the following code example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看以下代码示例了：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we used the `getScreenshotAs()` method to take the screenshot
    of the web page and save it to a file format. We can open the saved image from
    the target folder and examine it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `getScreenshotAs()` 方法来截取网页截图并将其保存到文件格式。我们可以从目标文件夹中打开保存的图像并检查它。
- en: Locating target windows and Frames
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位目标窗口和 Frames
- en: WebDriver enables the developers to switch between multiple child windows, browser
    tabs, and frames used in the application. For example, when you click on an internet
    banking link on a bank web application, it will open the internet banking application
    in a separate window or Tab. At this point, you may want to switch back to the
    original window to handle some events. Similarly, you may have to deal with a
    web application that is divided into two frames on the web page. The frame on
    the left may contain navigation items, and the frame on the right displays the
    appropriate web page, based on what is selected in the frame on the left. Using
    WebDriver, you can develop test cases that can easily handle such complex situations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver 允许开发者切换到应用程序中使用的多个子窗口、浏览器标签页和框架。例如，当你在一个银行网络应用上点击互联网银行链接时，它将在一个单独的窗口或标签页中打开互联网银行应用。此时，你可能想切换回原始窗口来处理一些事件。同样，你可能需要处理一个网页上分为两个框架的网络应用。左侧的框架可能包含导航项，而右侧的框架根据左侧框架中选择的项显示相应的网页。使用
    WebDriver，你可以开发出能够轻松处理这种复杂情况的测试用例。
- en: The `WebDriver.TargetLocator` interface is used to locate a given frame or window.
    In this section, we will see how WebDriver handles switching between browser windows
    and between two frames in the same window.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebDriver.TargetLocator` 接口用于定位给定的框架或窗口。在本节中，我们将了解 WebDriver 如何处理在同一个窗口中切换浏览器窗口和两个框架。'
- en: Switching among windows
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在窗口之间切换
- en: First, we will see a code example for handling multiple windows. For this chapter,
    there is an HTML file provided with this book named `Window.html`. It is a very
    basic web page that links to Google's search page. When you click on the link,
    the Google's search page is opened in a different window. Every time you open
    a web page using WebDriver in a browser window, WebDriver assigns a window handle
    to that. WebDriver uses the window handle to identify the window. At this point,
    in WebDriver, there are two window handles registered. Now, on the screen, you
    can see that the Google's search page is in the front and has the focus. At this
    point, if you want to switch to the first browser window, you can use WebDriver's
    `switchTo()` method to do that.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看到一个处理多个窗口的代码示例。对于本章，本书提供了一个名为 `Window.html` 的 HTML 文件。这是一个非常基本的网页，它链接到谷歌的搜索页面。当你点击链接时，谷歌的搜索页面将在不同的窗口中打开。每次你使用
    WebDriver 在浏览器窗口中打开一个网页时，WebDriver 都会为它分配一个窗口句柄。WebDriver 使用窗口句柄来识别窗口。此时，在 WebDriver
    中已注册了两个窗口句柄。现在，在屏幕上，你可以看到谷歌的搜索页面在前台并且具有焦点。此时，如果你想切换到第一个浏览器窗口，你可以使用 WebDriver 的
    `switchTo()` 方法来实现。
- en: 'The API syntax for `TargetLocator` is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`TargetLocator` 的 API 语法如下：'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This method returns the `WebDriver.TargetLocator` instance, where you can tell
    the WebDriver whether to switch between browser windows or frames. Let''s see
    how WebDriver deals with this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回 `WebDriver.TargetLocator` 实例，其中你可以告诉 WebDriver 是否要在浏览器窗口或框架之间切换。让我们看看
    WebDriver 如何处理这个问题：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Observe the following line in the preceding code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下代码中的这一行：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, the driver returns the assigned identifier for the window. Now, before
    we move on to a different window, it is better to store this value so that if
    we want to switch back to this window, we can use this handle or identifier. To
    retrieve all the window handles that are registered with your driver so far, you
    can use the following method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，驱动程序返回窗口的分配标识符。现在，在我们切换到不同的窗口之前，最好存储这个值，以便如果我们想切换回这个窗口，我们可以使用这个句柄或标识符。要检索到目前为止与你的驱动程序注册的所有窗口句柄，你可以使用以下方法：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will return the set of identifiers of all of the browser window handles
    opened in the driver session so far. Now, in our example, after we open Google''s
    search page, the window corresponding to it is shown in front with the focus.
    If you want to go back to the first window, you have to use the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回到目前为止在驱动程序会话中打开的所有浏览器窗口句柄的标识符集合。现在，在我们的例子中，在我们打开谷歌的搜索页面后，对应的窗口将显示在前面并具有焦点。如果你想回到第一个窗口，你必须使用以下代码：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will bring the first window into focus.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使第一个窗口获得焦点。
- en: Switching between frames
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换框架
- en: 'Let''s now see how we can handle switching between the frames of a web page.
    In the HTML files supplied with this book, you will see a file named `Frames.html`.
    If you open that, you will see two HTML files loaded in two different frames.
    Let''s see how we can switch between them and type into the text boxes available
    in each frame:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们如何处理网页框架之间的切换。在这本书提供的 HTML 文件中，您将看到一个名为 `Frames.html` 的文件。如果您打开它，您将看到两个不同的框架中加载了两个
    HTML 文件。让我们看看我们如何在这两个框架之间切换，并输入每个框架中可用的文本框：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we have used `switchTo().frame` instead of `switchTo().window`
    because we are moving across frames.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `switchTo().frame` 而不是 `switchTo().window`，因为我们正在跨框架移动。
- en: 'The API syntax for `frame` is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`frame` 的 API 语法如下：'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method takes the index of the frame that you want to switch to. If your
    web page has three frames, WebDriver indexes them as 0, 1, and 2, where the zero
    index is assigned to the first frame encountered in the DOM. Similarly, you can
    switch between frames using their names by using the previous overloaded method.
    The API syntax is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法获取您想要切换到的框架的索引。如果您的网页有三个框架，WebDriver 将它们索引为 0、1 和 2，其中零索引分配给在 DOM 中遇到的第一个框架。同样，您可以通过使用之前重载的方法使用它们的名称在框架之间切换。API
    语法如下：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can pass the name of the frame or its ID. Using this, you can switch to
    the frame if you are not sure about the index of the target frame. The other overloaded
    method is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以传递框架的名称或其 ID。使用此方法，如果您不确定目标框架的索引，您也可以切换到框架。其他重载方法如下：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The input parameter is the WebElement of the frame. Let''s consider our code
    example: First, we have switched to our first frame and typed into the text field.
    Then, instead of directly switching to the second frame, we have come to the main
    or default content and then switched to the second frame. The code for that is
    as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数是框架的 `WebElement`。让我们考虑我们的代码示例：首先，我们已经切换到了我们的第一个框架并输入了文本字段。然后，我们并没有直接切换到第二个框架，而是来到了主或默认内容，然后切换到第二个框架。该代码如下：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is very important. If you don't do this and try to switch to the second
    frame while you are still in the first frame, your WebDriver will complain, saying
    that it couldn't find a frame with index 1\. This is because the WebDriver searches
    for the second frame in the context of the first frame, which is obviously not
    available. So, you have to first come to the top-level container and switch to
    the frame you are interested in.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要。如果您不这样做，而试图在仍然处于第一个框架的情况下切换到第二个框架，您的 WebDriver 将会抱怨说它找不到索引为 1 的框架。这是因为
    WebDriver 在第一个框架的上下文中搜索第二个框架，这显然是不可用的。因此，您必须首先来到顶级容器，然后切换到您感兴趣的框架。
- en: 'After switching to the default content, you can now switch to the second frame
    using the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换到默认内容后，您现在可以使用以下代码切换到第二个框架：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Thus, you can switch between the frames and execute the corresponding WebDriver
    actions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以在框架之间切换并执行相应的 WebDriver 操作。
- en: Handling alerts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理警报
- en: 'Apart from switching between windows and frames, you may have to handle various
    modal dialogs in a web application. For this, WebDriver provides an API to handle
    alert dialogs. The API for that is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在窗口和框架之间切换之外，您可能还需要处理 Web 应用程序中的各种模式对话框。为此，WebDriver 提供了一个处理警报对话框的 API。该 API
    如下所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding method will switch to the currently active modal dialog on the
    web page. This returns an `Alert` instance, where appropriate actions can be taken
    on that dialog. If there is no dialog currently present, and you invoke this API,
    it throws back a `NoAlertPresentException`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法将切换到网页上当前活动的模式对话框。这将返回一个 `Alert` 实例，您可以在该对话框上采取适当的操作。如果没有当前对话框，并且您调用此 API，它将抛出
    `NoAlertPresentException`。
- en: 'The `Alert` interface contains a number of APIs to execute different actions.
    The following list discusses them, one after the other:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Alert` 接口包含一系列 API 来执行不同的操作。以下列表逐一讨论它们：'
- en: '`void accept()`: This is equivalent to the **OK** button action on the dialog.
    The corresponding **OK** button actions are invoked when the `accept()` action
    is taken on a dialog.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void accept()`: 这相当于对话框上的 **OK** 按钮操作。当在对话框上执行 `accept()` 操作时，将调用相应的 **OK**
    按钮操作。'
- en: '`void dismiss()`: This is equivalent to clicking on the **CANCEL** action button.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void dismiss()`: 这相当于点击 **CANCEL** 操作按钮。'
- en: '`java.lang.String getText()`: This will return the text that appears on the
    dialog. This can be used if you want to evaluate the text on the modal dialog.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.String getText()`: 这将返回对话框上显示的文本。如果你想要评估模态对话框上的文本，可以使用此方法。'
- en: '`void sendKeys(java.lang.String keysToSend)`: This will allow the developer
    to type in some text into the alert if the alert has some provision for it.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void sendKeys(java.lang.String keysToSend)`: 如果警报有此功能，这将允许开发者输入一些文本到警报中。'
- en: Exploring Navigate
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Navigate
- en: As we know, WebDriver talks to individual browsers natively. This way it has
    better control, not just over the web page, but over the browser itself. **Navigate**
    is one such feature of WebDriver that allows the test script developer to work
    with the browser's back, forward, and refresh controls. As users of a web application,
    quite often, we use the browser's back and forward controls to navigate between
    the pages of a single application, or, sometimes, multiple applications. As a
    test-script developer, you may want to develop tests that observe the behavior
    of the application when browser navigation buttons are clicked, especially the
    back button. For example, if you use your navigation button in a banking application,
    the session should expire and the user should be logged out. So, using the WebDriver's
    navigation feature, you can emulate those actions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，WebDriver 以原生方式与单个浏览器进行通信。这种方式不仅使它能够更好地控制网页，还能控制浏览器本身。**Navigate** 是 WebDriver
    的一个功能，允许测试脚本开发者与浏览器的后退、前进和刷新控件进行交互。作为网络应用的用户，我们经常使用浏览器的前进和后退控件在单个应用或有时是多个应用之间导航。作为测试脚本开发者，你可能希望开发出在点击浏览器导航按钮时观察应用行为的测试，特别是后退按钮。例如，如果你在一个银行应用中使用导航按钮，会话应该过期，用户应该被登出。因此，使用
    WebDriver 的导航功能，你可以模拟这些操作。
- en: 'The method that is used for this purpose is `navigate()`. The following is
    its API syntax:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此目的的方法是 `navigate()`。以下是它的 API 语法：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Obviously, there is no input parameter for this method, but the return type
    is the `WebDriver.Navigation` interface, which contains all of the browser navigation
    options that help you navigate through your browser's history.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，此方法没有输入参数，但返回类型是 `WebDriver.Navigation` 接口，它包含所有帮助你在浏览器历史记录中导航的浏览器导航选项。
- en: 'Now let''s see a code example and then analyze the code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个代码示例，然后分析代码：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code opens the demo application's Homepage, and, at first, searches
    for `Phone`; then, after the search results are loaded. Now that we have a navigation
    history created in the browser, it uses WebDriver navigation to go back in the
    browser history, and then go forward and refresh the page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码打开演示应用的首页，首先搜索 `Phone`；然后，在搜索结果加载后。现在，我们在浏览器中创建了一个导航历史记录，它使用 WebDriver 导航返回浏览器历史记录，然后前进并刷新页面。
- en: 'Let''s analyze the navigation methods used in the preceding code. The line
    of code that initially loads the demo application''s Homepage uses the `to()`
    method of the `Navigation` class, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面代码中使用的导航方法。最初加载演示应用首页的代码行使用了 `Navigation` 类的 `to()` 方法，如下所示：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `driver.navigate()` method returns the `WebDriver.Navigation` interface
    on which the `to()` method is used to navigate to a web URL.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`driver.navigate()` 方法返回 `WebDriver.Navigation` 接口，在该接口上使用 `to()` 方法导航到网页
    URL。
- en: 'The API syntax is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: API 语法如下：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The input parameter for this method is the `url` string that has to be loaded
    in the browser. This method will load the page in the browser by using the `HTTP
    GET` operation, and it will block everything else until the page is completely
    loaded. This method is the same as the `driver.get(String url)` method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的输入参数是必须加载到浏览器中的 `url` 字符串。此方法将通过使用 `HTTP GET` 操作在浏览器中加载页面，并且直到页面完全加载，它会阻塞其他所有操作。此方法与
    `driver.get(String url)` 方法相同。
- en: 'The `WebDriver.Navigation` interface also provides an overloaded method of
    this `to()` method to make it easy to pass the URL. The API syntax for it is as
    follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebDriver.Navigation` 接口还提供了一个重载的 `to()` 方法，以便更容易传递 URL。它的 API 语法如下：'
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, in the code example, we did a search for `Phone`. Then, we tried to use
    Navigation''s `back()` method to emulate our browser''s back button, using the
    following line of code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在代码示例中，我们搜索了 `Phone`。然后，我们尝试使用 Navigation 的 `back()` 方法来模拟浏览器的前进按钮，使用以下代码行：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will take the browser to the home page. The API syntax for this method
    is pretty straightforward; it''s as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使浏览器跳转到主页。此方法的API语法相当简单；如下所示：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method doesn't take any input and doesn't return anything as well, but
    it takes the browser one level back in its history.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法也不接收任何输入，也不返回任何内容，但它将浏览器向后移动一个历史级别。
- en: 'Then, the next method in the navigation is the `forward()` method, which is
    pretty much similar to the `back()` method, but it takes the browser one level
    in the opposite direction. In the preceding code example, the following is invoked:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，导航中的下一个方法是`forward()`方法，它与`back()`方法非常相似，但它将浏览器带到相反方向的一个级别。在先前的代码示例中，以下方法被调用：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The API syntax for the method is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的API语法如下：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method doesn't take any input, and doesn't return anything either, but
    it takes the browser one level forward in its history.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法不接收任何输入，也不返回任何内容，但它将浏览器向前移动一个历史级别。
- en: 'The last line of code in the code example uses the `refresh()` method of WebDriver''s
    navigation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例中的最后一行使用了WebDriver的导航`refresh()`方法：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This method will reload the current URL to emulate the browser''s *refresh*
    (*F5* key) action. The API syntax is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将重新加载当前URL以模拟浏览器的*刷新*（*F5*键）操作。API语法如下：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the syntax is very similar to the `back()` and `forward()` methods,
    and this method will reload the current URL. Hence, these are the various methods
    WebDriver provides developers to emulate some browser actions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，语法与`back()`和`forward()`方法非常相似，并且此方法将重新加载当前URL。因此，这些都是WebDriver为开发者提供的用于模拟一些浏览器操作的各种方法。
- en: Waiting for WebElements to load
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待Web元素加载
- en: If you have a previous UI automation experience, I'm sure you would have come
    across a situation where your test script couldn't find an element on the web
    page because the web page was still loading. This could happen due to various
    reasons. One classic example is when the application server or web server is serving
    the page too slowly due to resource constraints; the other could be when you are
    accessing the page on a very slow network. The reason could be that the element
    on the web page is not loaded by the time your test script tries to find it. This
    is where you have to calculate and configure the average wait time for your test
    scripts to wait for WebElements to load on the web page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前有UI自动化经验，我敢肯定你遇到过这样的情况：你的测试脚本因为网页仍在加载而无法在网页上找到元素。这可能是由于各种原因造成的。一个经典的例子是当应用服务器或Web服务器由于资源限制而响应页面太慢时；另一种情况可能是当你在一个非常慢的网络中访问页面时。原因可能是当你的测试脚本尝试找到它时，网页上的元素尚未加载。这就是你必须计算和配置测试脚本等待Web元素在网页上加载的平均等待时间的地方。
- en: WebDriver provides test-script developers with a very handy feature to manage
    wait time. *Wait time* is the time your driver will wait for the WebElement to
    load, before it gives up and throws `NoSuchElementException`. Remember, in [Chapter
    1](9f647c33-1720-4d7b-973b-7d2ef9dad924.xhtml)*, Introducing WebDriver and WebElements*,
    we discussed the `findElement(By by)` method that throws a `NoSuchElementException`
    when it cannot find the target WebElement.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver为测试脚本开发者提供了一个非常实用的功能来管理等待时间。"等待时间"是指你的驱动程序在放弃并抛出`NoSuchElementException`之前，将等待Web元素加载的时间。记住，在[第1章](9f647c33-1720-4d7b-973b-7d2ef9dad924.xhtml)*介绍WebDriver和Web元素*中，我们讨论了`findElement(By
    by)`方法，当它无法找到目标Web元素时会抛出`NoSuchElementException`。
- en: There are two ways by which you can make the WebDriver wait for WebElement.
    They are **Implicit Wait** **Time** and **Explicit Wait** **Time**. Implicit timeouts
    are common to all the WebElements and have a global timeout period associated
    with them, but the explicit timeouts can be configured to individual WebElements.
    Let's discuss each of them here.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式让WebDriver等待WebElement。它们是**隐式等待时间**和**显式等待时间**。隐式超时对所有Web元素都是通用的，并且与它们关联着一个全局超时周期，但显式超时可以配置为单个Web元素。让我们在这里讨论每一个。
- en: Implicit wait time
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式等待时间
- en: Implicit wait time is used when you want to configure the WebDriver's wait time
    as a whole for the application under test. Imagine you have hosted a web application
    on a local server and on a remote server. Obviously, the time to load for a web
    page hosted on a local server would be less than the time for the same page hosted
    on a remote server, due to network latency. Now, if you want to execute your test
    cases against each of them, you may have to configure the wait time accordingly,
    such that your test case doesn't end up spending more time waiting for the page,
    or spend nowhere near enough time, and timeout. To handle these kinds of wait-time
    issues, WebDriver provides an option to set the implicit wait time for all of
    the operations that the driver does using the `manage()` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想为正在测试的应用程序配置WebDriver的整体等待时间时，会使用隐式等待时间。想象一下，你已经在本地服务器和远程服务器上托管了一个Web应用程序。显然，托管在本地服务器的网页加载时间会小于托管在远程服务器的相同页面的时间，这是由于网络延迟造成的。现在，如果你想要针对每个服务器执行你的测试用例，你可能需要相应地配置等待时间，以确保你的测试用例不会花费太多时间等待页面，或者几乎不花时间，从而导致超时。为了处理这类等待时间问题，WebDriver提供了一个选项，可以通过`manage()`方法为驱动器执行的所有操作设置隐式等待时间。
- en: 'Let''s see a code example of implicit wait time:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个隐式等待时间的代码示例：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s analyze the following highlighted line of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析以下高亮的代码行：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, `driver.manage().timeouts()` returns the `WebDriver.Timeouts` interface,
    which declares a method named `implicitlyWait`, which is where you specify the
    amount of time the driver should wait when searching for a WebElement on a web
    page if it is not immediately present. Periodically, the WebDriver will poll for
    the WebElement on the web page, until the maximum wait time specified to the previous
    method is over. In the preceding code, 10 seconds is the maximum wait time your
    driver will wait for any WebElement to load on your browser. If it loads within
    this time period, WebDriver proceeds with the rest of the code; otherwise, it
    will throw `NoSuchElementException`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`driver.manage().timeouts()`返回`WebDriver.Timeouts`接口，该接口声明了一个名为`implicitlyWait`的方法，在这里你指定当在网页上搜索一个WebElements时，如果它不是立即出现，驱动器应该等待多长时间。WebDriver会定期在网页上轮询WebElements，直到之前方法指定的最大等待时间结束。在前面的代码中，10秒是驱动器将等待任何WebElements在浏览器上加载的最大时间。如果在这个时间段内加载，WebDriver将继续执行其余代码；否则，它将抛出`NoSuchElementException`。
- en: Use this method when you want to specify a maximum wait time, which is generally
    common for most of the WebElements on your web application. The various factors
    that influence the performance of your page are network bandwidth, server configuration,
    and so on. Based on those conditions, as a developer of your WebDriver test cases,
    you have to arrive at a value for the maximum implicit wait time, such that your
    test cases don't take too long to execute, and, at the same time, don't timeout
    very frequently.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想指定一个最大等待时间时，请使用此方法，这在你的Web应用程序中的大多数WebElements中通常是常见的。影响你页面性能的各种因素包括网络带宽、服务器配置等等。基于这些条件，作为你的WebDriver测试用例的开发者，你必须确定一个最大隐式等待时间的值，以确保你的测试用例不会执行得太久，同时也不会频繁超时。
- en: Explicit wait time
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式等待时间
- en: Implicit timeout is generic to all the WebElements of a web page. But, if you
    have one specific WebElement in your application, where you want to wait for a
    very long time, this approach may not work. Setting the implicit wait time to
    the value of this very long time period will delay your entire test suite execution.
    So, you have to make an exception for only a particular case, such as this WebElement.
    To handle such scenarios, WebDriver has an explicit wait time for a WebElement.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式超时适用于网页上的所有WebElements。但是，如果你有一个特定的WebElements在你的应用程序中，你希望等待非常长的时间，这种方法可能不起作用。将隐式等待时间设置为这个非常长的时间段将会延迟整个测试套件的执行。因此，你必须为特定的情况，比如这个WebElements，做出例外。为了处理这类场景，WebDriver为WebElements提供了一个显式等待时间。
- en: 'So, let''s see how you can wait for a particular WebElement using WebDriver,
    with the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看如何使用以下代码使用WebDriver等待特定的WebElements：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The highlighted code is where we have created a conditional wait for a particular
    WebElement. The `ExpectedCondition` interface can be used to apply the conditional
    wait to a WebElement. Here, WebDriver will wait for a maximum of 20 seconds for
    this particular WebElement. The implicit timeout doesn't get applied for this
    WebElement. If the WebElement doesn't load within the 20 seconds maximum wait
    time, as we know, the driver throws a `NoSuchElementException`. Thus, you can
    override the implicit wait time exclusively for the WebElements you think will
    take more time, by using this handy explicit wait time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码是我们创建了对特定WebElement的条件等待的地方。可以使用`ExpectedCondition`接口将条件等待应用于WebElement。在这里，WebDriver将等待最多20秒以等待这个特定的WebElement。对于这个WebElement，不会应用隐式超时。如果WebElement在20秒的最大等待时间内没有加载，正如我们所知，驱动器会抛出`NoSuchElementException`异常。因此，你可以通过使用这个方便的显式等待时间来专门覆盖你认为将花费更多时间的WebElements的隐式等待时间。
- en: Handling cookies
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理cookie
- en: Let's say you are automating the demo application. There could be many scenarios
    you want to automate, such as searching for products, adding products to the shopping
    cart, checkout, returns, and so on. For all these actions, one common thing is
    to have to log into the demo application in each of the test cases. So, logging
    into the application in every test case of yours will increase the overall test
    execution time significantly. To reduce the execution time of your test cases,
    you can actually skip signing in for every test case. This can be done by signing
    in once and writing all the cookies of that domain into a file. From the next
    login onward, you can actually load the cookies from the file and add them to
    the driver.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在自动化演示应用程序。你可能想要自动化的场景有很多，例如搜索产品、将产品添加到购物车、结账、退货等。对于所有这些操作，一个共同点是需要在每个测试用例中登录到演示应用程序。因此，在你的每个测试用例中登录会增加整体测试执行时间。为了减少测试用例的执行时间，你实际上可以跳过每个测试用例的登录。这可以通过一次性登录并将该域的所有cookie写入文件来实现。从下一次登录开始，你实际上可以从文件中加载cookie并将其添加到驱动器中。
- en: 'To fetch all the cookies that are loaded for a web page, WebDriver provides
    the following method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取为网页加载的所有cookie，WebDriver提供了以下方法：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will return all the cookies that the web page stores in the current session.
    Each cookie is associated with a name, value, domain, path, expiry, and the status
    of whether it is secure or not. The server to validate a client cookie parses
    all of these values. Now, we will store all of this information for each cookie
    in a file so that our individual test cases read from this file and load that
    information into the driver. Hence, you can skip the login, because once your
    driver session has this information in it, the application server treats your
    browser session as authenticated and directly takes you to your requested URL.
    The following is a quick code to store the cookie information:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回当前会话中网页存储的所有cookie。每个cookie都与一个名称、值、域名、路径、过期时间和是否安全的状态相关联。服务器解析客户端cookie时会解析所有这些值。现在，我们将为每个cookie存储所有这些信息到一个文件中，以便我们的单个测试用例从这个文件中读取并加载这些信息到驱动器中。因此，你可以跳过登录，因为一旦你的驱动器会话中有了这些信息，应用程序服务器就会将你的浏览器会话视为已认证，并直接带你到请求的URL。以下是一个快速存储cookie信息的代码示例：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'From now on, for every test case or a set of test cases, load the cookie information
    from the `browser.data` file, and add it to the driver using the following method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，对于每一个测试用例或一组测试用例，需要从`browser.data`文件中加载cookie信息，并使用以下方法将其添加到驱动器中：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After you add this information to your browser session and go to the dashboard
    page, it will automatically redirect you to the home page, without asking for
    a login, thus avoiding a login every time, for every test case. The code that
    adds all of the previous cookies to the driver is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将此信息添加到浏览器会话并转到仪表板页面后，它将自动重定向到你主页，而无需请求登录，从而避免了每次测试用例都需要登录。将所有之前的cookie添加到驱动器的代码如下：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Hence, we can be directly taken to the home page without logging in again and
    again. As you can see, after creating the driver instance, we have the following
    line:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以直接进入主页而无需再次登录。正如你所见，在创建驱动器实例后，我们有以下行：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Ideally, this line should be visible after we have set the cookies to the driver.
    But the reason it is at the top is that the WebDriver doesn't allow you to set
    the cookies directly to this session, because it treats those cookies as if they
    were from a different domain. Try removing the previous line of code and execute
    it, and you will see the error. So, initially, you will try to visit the home
    page to set the domain value of the driver to the application server domain and
    load all the cookies. When you execute this code, initially, you will see the
    home page of the application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，此行应该在我们将cookies设置到驱动程序之后可见。但它在顶部的原因是WebDriver不允许你直接将cookies设置到这个会话中，因为它将这些cookies视为来自不同域的。尝试删除上一行代码并执行它，你就会看到错误。所以，最初，你将尝试访问主页，将驱动程序的域值设置为应用服务器域，并加载所有cookies。当你执行此代码时，最初你会看到应用的主页。
- en: Hence, you can avoid entering the username and the password on the server, validating
    them again and again for each test, and thereby save a lot of time, by using the
    WebDriver's cookies feature.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用WebDriver的cookies功能，你可以避免在服务器上输入用户名和密码，并且为每次测试再次验证它们，从而节省大量时间。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed various features of WebDriver, such as capturing
    screenshots and handling `Windows` and `Frames`. We also discussed implicit and
    explicit wait conditions for synchronization, and we used Navigation and the cookies
    API. Using these features will help you test your target web application more
    effectively, by designing more innovative test frameworks and test cases. In the
    next [chapter](ff724e47-f410-4c90-bc11-cf0fbd340773.xhtml), we will look at the
    **Actions** API to perform user interaction using keyboard and mouse events.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了WebDriver的各种功能，例如捕获屏幕截图和处理`Windows`和`Frames`。我们还讨论了同步的隐式和显式等待条件，并使用了导航和cookies
    API。使用这些功能将帮助你更有效地测试目标Web应用，通过设计更创新的测试框架和测试用例。在下一章中，我们将探讨**Actions** API，以使用键盘和鼠标事件执行用户交互。
- en: Questions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which are the different formats we can use to output a screenshot?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些不同的格式来输出屏幕截图？
- en: How can we switch to another browser tab with Selenium?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Selenium切换到另一个浏览器标签页？
- en: 'True or false: The `defaultContent()` method will switch to the previously
    selected frame.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对或错：`defaultContent()`方法将切换到之前选定的框架。
- en: What navigation methods are available with Selenium?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Selenium提供了哪些导航方法？
- en: How can we add a cookie using Selenium?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Selenium添加一个cookie？
- en: Explain the difference between an implicit wait and an explicit wait.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释隐式等待和显式等待之间的区别。
- en: Further information
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看以下链接，获取本章涵盖主题的更多信息：
- en: You can find out more about how you can use a set of predefined expected conditions
    while using an explicit wait at [https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html](https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html](https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/ui/ExpectedConditions.html)了解更多关于如何在显式等待时使用一组预定义的预期条件。
- en: You can read more about WebDriver's features in Chapter 4*, Working with Selenium
    API* and Chapter 5 *, Synchronizing Tests,* in *Selenium Testing Tools Cookbook*,
    2nd Edition, by Unmesh Gundecha, Packt Publications.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Unmesh Gundecha所著的《Selenium测试工具烹饪书》（第2版），Packt Publications出版的第4章*“与Selenium
    API一起工作”*和第5章*“同步测试”*中了解更多关于WebDriver功能的信息。
