- en: Chapter 3. Security and Traceability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 安全性和可追溯性
- en: In the era of open platforms, developers can build apps, which can be easily
    and quickly decoupled from the platform's business cycle. This API-based architecture
    enables agile development, easier adoption, prevalence, and scale and integration
    with applications within and outside the enterprise. One of the most important
    considerations for the apps is dealing with security. The developers building
    apps should not be concerned with the user's credentials. Additionally, there
    can be other clients consuming the REST services including but not limited to
    browsers and mobile applications to other services. The clients can be acting
    on behalf of other users and must be authorized to perform actions for them without
    the user having to share his credentials for a username and password. This is
    where the OAuth 2.0 specification comes into the picture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开放平台时代，开发人员可以构建应用程序，这些应用程序可以很容易地并快速地与平台的业务周期解耦。这种基于API的架构实现了敏捷开发、更容易的采用、普及和规模化，并与企业内外的应用程序集成。应用程序的最重要考虑因素之一是处理安全性。构建应用程序的开发人员不应该关心用户的凭据。此外，还可以有其他客户端使用REST服务，包括但不限于浏览器和移动应用程序到其他服务。客户端可以代表其他用户执行操作，并且必须经过授权才能代表他们执行操作，而无需用户共享用户名和密码。这就是OAuth
    2.0规范的作用所在。
- en: 'Another important aspect to consider when building distributed applications
    is traceability, which will involve logging the data related to requests for debugging
    purposes in an environment encompassing multiple micro services, which can be
    geographically distributed and deal with thousands of requests. Requests to the
    REST resources and status codes must be logged to help debug issues in production
    and can also serve as an audit trail. This chapter will cover advanced details
    in security and traceability in REST programming models. The topics covered are
    as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建分布式应用程序时需要考虑的另一个重要方面是可追溯性，这将涉及记录与请求相关的数据，以进行调试，这些请求在涵盖多个微服务的环境中可能是地理分布的，并且处理成千上万的请求。必须记录对REST资源的请求和状态代码，以帮助调试生产中的问题，并且还可以作为审计跟踪。本章将涵盖REST编程模型中安全性和可追溯性的高级细节。涵盖的主题如下：
- en: Logging REST APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录REST API
- en: Exception handling with RESTful services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful服务的异常处理
- en: Validation patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模式
- en: Federated identity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合身份
- en: SAML 2.0
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SAML 2.0
- en: OAuth 2.0
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: OpenID Connect
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID Connect
- en: This chapter will conclude with what it takes to work with the various building
    blocks for scalable, highly performing RESTful services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将总结构建可扩展、高性能的RESTful服务所需的各种构建块。
- en: Logging REST APIs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录REST API
- en: Complex distributed applications can introduce many points of failure. Problems
    are hard to find and fix, thus delaying incident response and creating costly
    escalations. Application developers and administrators may not have direct access
    to the machine data they need.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的分布式应用程序可能会引入许多故障点。问题很难找到和修复，因此延迟了事件响应并造成了昂贵的升级。应用程序开发人员和管理员可能无法直接访问他们所需的机器数据。
- en: Logging is a very important aspect of building RESTful services, especially
    in the case of debugging production issues in distributed nodes running various
    micro services. It helps to link events or transactions between the various components
    that make an application or a business service. A complete sequence of logs can
    help replay the course of events that occurred in a production system. Additionally,
    logs can help index, aggregate, slice the data, analyze the patterns of requests
    coming in, and provide a lot of potentially helpful information.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是构建RESTful服务的一个非常重要的方面，特别是在调试运行各种微服务的分布式节点中出现生产问题的情况下。它有助于链接构成应用程序或业务服务的各个组件之间的事件或事务。完整的日志序列可以帮助重现在生产系统中发生的事件过程。此外，日志还可以帮助索引、聚合、切片数据、分析请求模式，并提供大量潜在有用的信息。
- en: 'The following code covers how to write a simple logging filter, which can be
    integrated with the REST resources. The filter will log request-related data such
    as timestamp, query string, and inputs:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码涵盖了如何编写一个简单的日志记录过滤器，可以与REST资源集成。该过滤器将记录与请求相关的数据，如时间戳、查询字符串和输入：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `LoggingFilter` class is a simple filter that implements a `javax.servlet.Filter`
    interface. The logger will log all messages with the request path and inputs.
    The sample uses Apache Log4j to set up logging.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoggingFilter`类是一个简单的过滤器，实现了`javax.servlet.Filter`接口。记录器将记录所有带有请求路径和输入的消息。示例使用Apache
    Log4j设置日志记录。'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details on Apache Log4J, check [http://logging.apache.org/log4j/2.x/](http://logging.apache.org/log4j/2.x/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Apache Log4J的更多详细信息，请查看[http://logging.apache.org/log4j/2.x/](http://logging.apache.org/log4j/2.x/)。
- en: These logs can then be collected and mined from a distributed log server application,
    for example, Splunk ([http://www.splunk.com/](http://www.splunk.com/)), which
    can give the developer information and root causes analysis for outages or performance
    issues in production. An example in our coffee shop analogy could be that there
    was a problem processing a coffee order. If the request details were logged in
    a distributed log server application such as Splunk, the developer can query based
    on the time, and see what the client tried to send and why the request failed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以从分布式日志服务器应用程序（例如Splunk ([http://www.splunk.com/](http://www.splunk.com/)）中收集和挖掘这些日志，这可以为开发人员提供有关生产中故障或性能问题的信息和根本原因分析。在我们的咖啡店类比中，一个例子是处理咖啡订单时出现问题。如果请求细节被记录在Splunk等分布式日志服务器应用程序中，开发人员可以根据时间查询，并查看客户端尝试发送的内容以及请求失败的原因。
- en: The next section will cover numerous best practices to keep in mind when logging
    REST API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将涵盖许多在记录REST API时要牢记的最佳实践。
- en: Best practices for the logging REST API
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录REST API的最佳实践
- en: In a large-scale distributed environment, the log data may be the only information
    that is available to the developer for debugging issues. Auditing and logging,
    if done right, can help tremendously in figuring such production issues and replaying
    the sequence of steps that occurred before an issue. The following sections list
    a few best practices for logging to understand system behavior and reasoning for
    performance and other issues.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模分布式环境中，日志数据可能是开发人员用于调试问题的唯一信息。如果审计和日志记录做得好，可以极大地帮助解决此类生产问题，并重放出问题发生前的步骤序列。以下部分列出了一些用于理解系统行为和性能等问题的日志记录最佳实践。
- en: Including a detailed consistent pattern across service logs
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在服务日志中包括详细的一致模式
- en: 'It is a good practice for a logging pattern to at least include the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记录模式至少应包括以下内容是一个良好的实践：
- en: Date and current time
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期和当前时间
- en: Logging level
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录级别
- en: The name of the thread
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程的名称
- en: The simple logger name
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的记录器名称
- en: The detailed message
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细的消息
- en: Obfuscating sensitive data
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混淆敏感数据
- en: It is very important to mask or obfuscate sensitive data in production logs
    to protect the risk of compromising confidential and critical customer information.
    Password obfuscators can be used in the logging filter, which will mask passwords,
    credit card numbers, and so on from the logs. **Personally identifiable information**
    (**PII** is information that can be used by itself or along with some other information
    to identify a person. Examples of PII can be a person's name, e-mail, credit card
    number, and so on. Data representing PII should be masked using various techniques
    such as substitution, shuffling, encryption, and other techniques.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产日志中掩盖或混淆敏感数据非常重要，以保护泄露机密和关键客户信息的风险。密码混淆器可以在日志过滤器中使用，它将从日志中掩盖密码、信用卡号等。**个人可识别信息**（**PII**是指可以单独使用或与其他信息一起用于识别个人的信息。PII的例子可以是一个人的姓名、电子邮件、信用卡号等。表示PII的数据应该使用各种技术进行掩盖，如替换、洗牌、加密等技术。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details, check [http://en.wikipedia.org/wiki/Data_masking](http://en.wikipedia.org/wiki/Data_masking).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请查看[http://en.wikipedia.org/wiki/Data_masking](http://en.wikipedia.org/wiki/Data_masking)。
- en: Identifying the caller or the initiator as part of the logs
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别调用者或发起者作为日志的一部分
- en: It is a good practice to identify the initiator of the call in the logs. The
    API may be called by a variety of clients, for example, mobile, the Web, or other
    services. Adding a way to identify the caller may help debug issues in case the
    problems are specific to a client.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中标识调用者是一个良好的实践。API可能被各种客户端调用，例如移动端、Web端或其他服务。添加一种方式来识别调用者可能有助于调试问题，以防问题特定于某个客户端。
- en: Do not log payloads by default
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认情况下不记录有效负载
- en: Have a configurable option to log payloads so that by default no payload is
    logged. This will ensure, for resources dealing with sensitive data, the payloads
    do not get logged in the default case.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 具有可配置选项以记录有效负载，以便默认情况下不记录任何有效负载。这将确保对于处理敏感数据的资源，在默认情况下不会记录有效负载。
- en: Identifying meta-information related to the request
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别与请求相关的元信息
- en: Every request should have some details on how long it took to execute the request,
    the status of the request, and the size of the request. This will help to identify
    latency issues as well as any other performance issues that may come up with large
    messages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求都应该有一些关于执行请求所花费的时间、请求的状态和请求的大小的细节。这将有助于识别延迟问题以及可能出现的大消息的其他性能问题。
- en: Tying the logging system with a monitoring system
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将日志系统与监控系统绑定
- en: Ensure the data from the logs can also be tied to a monitoring system, which
    can collect data related to SLA metrics and other statistics in the background.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 确保日志中的数据也可以与监控系统绑定，后者可以在后台收集与SLA指标和其他统计数据相关的数据。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Case studies of logging frameworks in distributed environments in various
    platforms**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**各种平台上分布式环境中日志框架的案例研究**'
- en: Facebook has developed a homegrown solution called Scribe, which is a server
    for aggregating streaming log data. This can handle the large number of requests
    per day across servers distributed globally. The servers send data, which can
    be processed, diagnosed, indexed, summarized, or aggregated. Scribe is designed
    to scale to a very large number of nodes. It is designed to be robust to survive
    network and node failures. There is a scribe server running on every node in the
    system. It is configured to aggregate messages and sends them to a central scribe
    server in larger groups. If the central scribe server goes down, messages are
    written to a file by the local scribe server on the local disk and sends them
    when the central server recovers. For more details, check [https://github.com/facebookarchive/scribe](https://github.com/facebookarchive/scribe).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook开发了一个名为Scribe的自制解决方案，它是一个用于聚合流式日志数据的服务器。它可以处理全球分布的服务器每天大量的请求。服务器发送数据，可以进行处理、诊断、索引、汇总或聚合。Scribe被设计为可以扩展到非常大量的节点。它被设计为能够经受住网络和节点故障的考验。系统中的每个节点都运行着一个scribe服务器。它被配置为聚合消息，并将它们发送到一个更大的组中的中央scribe服务器。如果中央scribe服务器宕机，消息将被写入本地磁盘上的文件，并在中央服务器恢复时发送。更多详情，请查看[https://github.com/facebookarchive/scribe](https://github.com/facebookarchive/scribe)。
- en: Dapper is Google's tracing system, which samples data from the thousands of
    requests and provides sufficient information to trace data. Traces are collected
    in local logfiles and then pulled in Google's BigTable database. Google has found
    out that sampling sufficient information for common cases can help trace the details.
    For more details, check [http://research.google.com/pubs/pub36356.html](http://research.google.com/pubs/pub36356.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Dapper是谷歌的跟踪系统，它从成千上万的请求中采样数据，并提供足够的信息来跟踪数据。跟踪数据被收集在本地日志文件中，然后被拉入谷歌的BigTable数据库。谷歌发现对于常见情况采样足够的信息可以帮助跟踪细节。更多详情，请查看[http://research.google.com/pubs/pub36356.html](http://research.google.com/pubs/pub36356.html)。
- en: The next section will cover how to validate REST API requests and/or response
    entities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将介绍如何验证REST API请求和/或响应实体。
- en: Validating RESTful services
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证RESTful服务
- en: When exposing REST- or HTTP-based service APIs, it is important to validate
    that the API behaves correctly and that the exposed data format is structured
    in an expected manner. For example, it is important to validate an input to a
    RESTful service, such as e-mails sent as part of the request body, must conform
    to the standards, certain values in the payload must be present, the zip code
    must follow a particular format, and so on. This can be done by validations with
    RESTful services.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在暴露REST或基于HTTP的服务API时，验证API的行为是否正确以及暴露的数据格式是否按预期结构化是很重要的。例如，验证RESTful服务的输入，例如作为请求体发送的电子邮件，必须符合标准，负载中必须存在某些值，邮政编码必须遵循特定格式等。这可以通过RESTful服务的验证来完成。
- en: 'JAX-RS supports the Bean Validation to verify JAX-RS resource classes. This
    support consists of:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS支持Bean验证来验证JAX-RS资源类。这种支持包括：
- en: Adding constraint annotations to resource method parameters
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向资源方法参数添加约束注释
- en: Ensuring entity data is valid when the entity is passed in as a parameter
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在将实体作为参数传递时实体数据有效
- en: 'The following is a code snippet of a `CoffeesResource` class, which contains
    the `@Valid` annotation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含`@Valid`注释的`CoffeesResource`类的代码片段：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `javax.validation.executable.ValidateOnExecution` annotation can help specify
    which method or constructor should have their parameters and return values validated
    on execution. The `javax.validation.Valid` annotation on the request body will
    ensure the `Coffee` object will conform to the rules as specified in the POJO.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`javax.validation.executable.ValidateOnExecution`注释可以帮助指定哪个方法或构造函数应在执行时验证其参数和返回值。请求体上的`javax.validation.Valid`注释将确保`Coffee`对象将符合POJO中指定的规则。'
- en: 'The following is the snippet of the `Coffee` POJO:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Coffee` POJO的代码片段：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The field name has a `javax.validation.constrains.NotNull` annotation, which
    enforces that the name of the coffee in the order cannot be null. Similarly, we
    have defined custom annotations in the sample, which will verify the type and
    size and check if the values in the request body follow the right format.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 字段名具有`javax.validation.constrains.NotNull`注释，强制要求订单中的咖啡名称不能为空。同样，我们在示例中定义了自定义注释，它将验证类型和大小，并检查请求体中的值是否遵循正确的格式。
- en: 'For example, `Size` can be either of the following values as shown: `Small`,
    `Medium`, `Large`, or `ExtraLarge`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Size`可以是以下值之一：`Small`，`Medium`，`Large`或`ExtraLarge`：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `@VerifyValue(Size.class)` annotation is a custom annotation defined in
    the downloadable sample.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`@VerifyValue(Size.class)`注释是在可下载示例中定义的自定义注释。'
- en: Validation exception handling and response codes
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证异常处理和响应代码
- en: The following table provides a quick summary of the type of response codes when
    various validation-related exceptions are thrown. The type of error code depends
    on the exception thrown as well as whether the validation performed is on the
    request or the response of the HTTP method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了在抛出各种与验证相关的异常时返回的响应代码的快速摘要。错误代码的类型取决于抛出的异常以及验证是在HTTP方法的请求还是响应上执行的。
- en: '| HTTP Response code returned | Type of exception |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 返回的HTTP响应代码 | 异常类型 |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `500 Internal Server Error` | This error code is returned when `javax.validation.ValidationException`
    or any subclass of `ValidationException` including `ConstraintValidationException`
    is thrown while validating a method return type |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `500内部服务器错误` | 当验证方法返回类型时抛出`javax.validation.ValidationException`或`ValidationException`的任何子类，包括`ConstraintValidationException`时返回此错误代码
    |'
- en: '| `400 Error` | When `ConstraintViolationException` is thrown in all other
    cases for validating method |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `400错误` | 当在验证方法中抛出`ConstraintViolationException`以及所有其他情况时 |'
- en: The next section covers how the API developers can throw application-specific
    exceptions and map HTTP error codes based on the exceptions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分涵盖了API开发人员如何抛出特定于应用程序的异常，并根据异常映射HTTP错误代码。
- en: Error handling with RESTful services
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful服务的错误处理
- en: When building RESTful APIs, it is necessary to throw application-specific exceptions
    and provide specific HTTP responses containing the details of these exceptions.
    The following section covers how to deal with user-defined exceptions and map
    them to HTTP responses and status codes. The `javax.ws.rs.ext.ExceptionMapper`
    classes are custom, application provided, components that catch thrown application
    exceptions and write specific HTTP responses. Exception mapper classes are annotated
    with the `@Provider` annotation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建RESTful API时，需要抛出特定于应用程序的异常，并提供包含这些异常详细信息的特定HTTP响应。接下来的部分将介绍如何处理用户定义的异常并将它们映射到HTTP响应和状态代码。`javax.ws.rs.ext.ExceptionMapper`类是自定义的、应用程序提供的组件，它捕获抛出的应用程序异常并编写特定的HTTP响应。异常映射器类使用`@Provider`注释进行标注。
- en: 'The following snippets show how to build your custom exception mapper:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何构建自定义异常映射器：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As shown in the preceding code snippet, the `getCoffees()` method returns a
    `Coffee` object with the ID specified in the path parameter. If no coffee is found
    with the ID specified, the code throws a `CoffeeNotFoundException`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，`getCoffees()`方法返回一个带有指定路径参数的`Coffee`对象。如果找不到指定ID的咖啡，则代码会抛出`CoffeeNotFoundException`。
- en: 'The following is the code of an `ExceptionMapper` class implementation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ExceptionMapper`类实现的代码：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code shows an implementation of `ExceptionMapper` whose `toResponse()`
    method has been overridden. The code checks if the exception thrown is an instance
    of `CoffeeNotFoundException`, then returns a response whose entity is of the type
    `ResourceError`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了`ExceptionMapper`的实现，其`toResponse()`方法已被覆盖。代码检查抛出的异常是否是`CoffeeNotFoundException`的实例，然后返回一个实体类型为`ResourceError`的响应。
- en: 'The `ResourceError` class is a POJO annotated with `@XMLRootElement` and sent
    as part of the response:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceError`类是一个使用`@XMLRootElement`注释的POJO，并作为响应的一部分发送：'
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can run the sample as part of the downloadable bundle and the output is
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将示例作为可下载包的一部分运行，输出如下：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Authentication and authorization
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: In the past, organizations needed a way to unify the authentication for users
    in an enterprise. Single sign-on is a solution to keep one repository for usernames
    and passwords that can be used across the different applications in an enterprise.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，组织需要一种方式来统一企业用户的身份验证。单点登录是一个解决方案，可以在企业的不同应用程序中保持一个用户名和密码的存储库。
- en: With the evolution of service-oriented architectures, organizations needed a
    way so that the partners and other services could use the APIs and there needed
    to be a way to simplify the sign-on process across the various applications and
    platforms. The need grew with the generation of social media with various platforms
    opening up, the APIs and an ecosystem built with a myriad of applications, and
    a multitude of devices using the platforms such as Twitter, Facebook, and LinkedIn.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着面向服务的架构的发展，组织需要一种方式，使合作伙伴和其他服务可以使用API，并且需要一种简化各种应用程序和平台之间登录过程的方式。随着社交媒体的发展，各种平台开放，API和生态系统建立了大量应用程序和大量设备使用Twitter、Facebook和LinkedIn等平台。
- en: Thus, it has become increasingly important to decouple the authentication and
    authorization functions from the consumer application. Also, it is not mandatory
    for every application to be aware of the user's credentials. The following section
    will cover SAML 2.0 and OAuth 2.0 for authorization as part of the federated identities
    effort to simplify sign-on and increase security.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将认证和授权功能与消费应用程序解耦变得越来越重要。此外，并非每个应用程序都必须知道用户的凭据。接下来的部分将涵盖SAML 2.0和OAuth 2.0，作为简化登录和增加安全性的联合身份的一部分。
- en: 'Subsections will enumerate over the following topics:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 子节将枚举以下主题：
- en: SAML
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SAML
- en: OAuth
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth
- en: Refresh tokens versus Access tokens
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新令牌与访问令牌
- en: Jersey and OAuth 2.0
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jersey和OAuth 2.0
- en: When to use SAML or OAuth?
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用SAML或OAuth？
- en: OpenID Connect
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenID Connect
- en: What is authentication?
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是认证？
- en: Authentication is the process of establishing and communicating that the person
    operating a browser or native app is who he/she claims to be.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是建立和传达操作浏览器或本机应用程序的人是他/她声称的人的过程。
- en: SAML
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SAML
- en: '**Security Assertion Markup Language** (**SAML**) is a standard that encompasses
    profiles, bindings, and constructs to achieve **Single sign-on** (**SSO**), federation,
    and identity management.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全断言标记语言**（**SAML**）是一个标准，包括配置文件、绑定和构造，以实现**单点登录**（**SSO**）、联合和身份管理。'
- en: 'The SAML 2.0 spec provides a web browser SSO profile, which defines how single
    sign-on can be achieved for web applications. It defines three roles:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: SAML 2.0规范提供了Web浏览器SSO配置文件，定义了如何实现Web应用程序的单点登录。它定义了三个角色：
- en: '**Principal**: This is where the user is typically looking to verify his or
    her identity'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体**：这通常是用户想要验证自己的身份的地方'
- en: '**Identity provider** (**IdP**): This is the entity that is capable of verifying
    the identity of the end user'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份提供者**（**IdP**）：这是能够验证最终用户身份的实体'
- en: '**Service provider** (**SP**): This is the entity looking to use the identity
    provider to verify the identity of the end user'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务提供者**（**SP**）：这是希望使用身份提供者验证最终用户身份的实体'
- en: The following flow shows a simple example of SAML. Say, an employee wants to
    access the corporate travel website. The corporate travel application will request
    the identity provider the employee is associated with to verify his identity and
    then take actions for him.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下流程显示了SAML的一个简单示例。比如，员工想要访问企业旅行网站。企业旅行应用程序将请求与员工关联的身份提供者来验证他的身份，然后为他采取行动。
- en: '![SAML](img/7963OS_03_02.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![SAML](img/7963OS_03_02.jpg)'
- en: 'The flow is explained as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 流程解释如下：
- en: The user accesses a corporate application, say, travel application.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户访问企业应用程序，比如旅行应用程序。
- en: The travel application will generate a SAML request and redirects the user to
    the employer's **identity provider** (**IdP**).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旅行应用程序将生成一个SAML请求，并将用户重定向到雇主的**身份提供者**（**IdP**）。
- en: The user is redirected to the employer's identity provider to obtain a SAML
    authentication assertion.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被重定向到雇主的身份提供者以获取SAML认证断言。
- en: The IdP parses the SAML request, authenticates the user, and generates a SAML
    response.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IdP解析SAML请求，对用户进行身份验证，并生成SAML响应。
- en: The browser sends the SAML response to the travel application.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器将SAML响应发送到旅行应用程序。
- en: On receiving the access token, the corporate travel app is then able to access
    the web resource by passing the token in the header of the HTTP request. The access
    token acts as a session token that encapsulates the fact that the travel app is
    acting on behalf of the user.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收到访问令牌后，企业旅行应用程序随后能够通过在HTTP请求的标头中传递令牌来访问Web资源。访问令牌充当一个会话令牌，封装了旅行应用程序代表用户的事实。
- en: SAML has binding specifications for web browsers, SSO, SOAP, and WS-Security
    but no formal binding for the REST API.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SAML具有用于Web浏览器、SSO、SOAP和WS-Security的绑定规范，但没有正式的REST API绑定。
- en: The next section covers OAuth, which has been widely used by platforms such
    as Twitter, Facebook, and Google for authorization.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节涵盖了OAuth，这已被Twitter、Facebook和Google等平台广泛使用于授权。
- en: What is authorization?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是授权？
- en: Authorization is the process of checking whether the requestor has permissions
    to perform the requested operation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是检查请求者是否有权限执行所请求操作的过程。
- en: OAuth
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OAuth
- en: OAuth stands for **open authorization** and provides a way for a user to authorize
    an application to access their account-related data without giving out their username
    and password.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth代表**开放授权**，为用户授权应用程序访问其与账户相关的数据提供了一种方式，而不需要提供用户名和密码。
- en: Traditionally in client/server authentication, the client uses its credentials
    to access resources on the server. The server does not care if the request comes
    from the client or if the client is requesting the resource for some other entity.
    The entity can be another application or another person and thus the client is
    not accessing its own resource but that of another user. Anyone requesting access
    to a resource that is protected and requires authentication must be authorized
    to do so by the resource owner. OAuth is a way to open up the REST APIs for companies
    such as Twitter, Facebook, Google+, GitHub, and so on, and the myriad of third-party
    applications built on top of them. OAuth 2.0 completely relies on SSL.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端/服务器身份验证中，客户端使用其凭据访问服务器上的资源。服务器不在乎请求是来自客户端还是客户端是否为其他实体请求资源。实体可以是另一个应用程序或另一个人，因此客户端不是在访问自己的资源，而是在访问另一个用户的资源。请求访问受保护且需要身份验证的资源的任何人都必须得到资源所有者的授权。OAuth是一种打开Twitter、Facebook、Google+、GitHub等公司的REST
    API以及建立在其之上的众多第三方应用程序的方法。OAuth 2.0完全依赖于SSL。
- en: The number of legs in an OAuth request refers to the number of parties involved.
    A flow where there is client, server, and resource owner indicates 3-legged OAuth.
    When the client is acting on behalf of itself, it is known as 2-legged OAuth.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth请求中的步数指涉及的参与方数量。客户端、服务器和资源所有者都参与的流程表示3-legged OAuth。当客户端代表自己行事时，它被称为2-legged
    OAuth。
- en: 'OAuth achieves this functionality with the help of access tokens. Access tokens
    are like valet keys that give access to limited functionality for a limited period
    of time. Tokens have a limited lifespan from hours to a few days. The following
    diagram shows the flow of OAuth:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth通过访问令牌实现此功能。访问令牌就像提供有限功能的代客泊车钥匙，可以在有限的时间内访问。令牌的寿命有限，从几小时到几天不等。以下图表显示了OAuth的流程：
- en: '![OAuth](img/7963OS_03_01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![OAuth](img/7963OS_03_01.jpg)'
- en: The preceding diagram shows the authorization code grant flow.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了授权代码授予流程。
- en: In this example, a user has his photos on a service provider site, say, Flickr.
    Now, the user needs to call a print service to print his photos, for example,
    Snapfish, which is a consumer application. Instead of the user sharing his username
    and password to the consumer application, the user can use OAuth to allow the
    print service to access his photos for a limited period of time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户在服务提供商网站上有他的照片，比如Flickr。现在，用户需要调用打印服务来打印他的照片，例如Snapfish，这是一个消费者应用程序。用户可以使用OAuth允许打印服务在有限的时间内访问他的照片，而不是将他的用户名和密码分享给消费者应用程序。
- en: 'So in our example, we have three roles as described:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的示例中，有三个角色，如下所述：
- en: '**User or resource owner**: The user is the resource owner who wants to print
    his photos'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户或资源所有者**：用户是希望打印他的照片的资源所有者'
- en: '**Consumer application or client**: This is the print service application,
    which will act on behalf of the user'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者应用程序或客户端**：这是打印服务应用程序，将代表用户行事'
- en: '**Service provider or server**: The service provider is the resource server
    that will store the user''s photos'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务提供商或服务器**：服务提供商是将存储用户照片的资源服务器'
- en: 'With this example in mind, we can see the steps involved in the OAuth dance:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个例子，我们可以看到OAuth舞蹈中涉及的步骤：
- en: User wants to allow an application to do a task on his behalf. In our example,
    the task is to print photos, which are on a server using a consumer application.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户希望允许应用程序代表他执行任务。在我们的例子中，任务是打印照片，这些照片在服务器上使用消费者应用程序。
- en: The consumer application redirects the user to the service provider's authorization
    URL.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者应用程序将用户重定向到服务提供商的授权URL。
- en: Here, the provider displays a web page asking the user if they can grant the
    application access to read and update their data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，提供者显示一个网页，询问用户是否可以授予应用程序读取和更新其数据的访问权限。
- en: The user agrees to grant the application access by the print service consumer
    application.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户同意通过打印服务消费者应用程序授予应用程序访问权限。
- en: The service provider redirects the user back to the application (via the redirect
    URI), passing an authorization code as a parameter.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务提供商将用户重定向回应用程序（通过重定向URI），将授权代码作为参数传递。
- en: The application exchanges the authorization code for an access grant. The service
    provider issues the access grant to the application. The grant includes an access
    token and a refresh token.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序将授权代码交换为访问授权。服务提供商向应用程序发放访问授权。授权包括访问令牌和刷新令牌。
- en: Now that the connection is established, the consumer application can now obtain
    a reference to the service API and invoke the provider on behalf of the user.
    Thus, the print service can now access the user's photos from the service provider's
    site.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在连接建立，消费者应用程序现在可以获取对服务API的引用，并代表用户调用提供者。因此，打印服务现在可以从服务提供商的网站访问用户的照片。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The advantage of OAuth is that a compromised application will not create much
    havoc as access tokens are used instead of actual credentials. The SAML bearer
    flow is actually very similar to the classic OAuth 3-leg flow covered earlier.
    However, instead of redirecting the user's browser to the authorization server,
    the service provider works with the identity provider to get a simple authentication
    assertion. The service provider application swaps a SAML bearer assertion for
    the user instead of exchanging an authorization code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth的优势在于，由于使用访问令牌而不是实际凭据，受损的应用程序不会造成太多混乱。 SAML承载流实际上与之前介绍的经典OAuth 3-leg流非常相似。但是，与将用户的浏览器重定向到授权服务器不同，服务提供商与身份提供商合作以获得简单的身份验证断言。服务提供商应用程序为用户交换SAML承载断言，而不是交换授权代码。
- en: Differences between OAuth 2.0 and OAuth 1.0
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth 2.0和OAuth 1.0之间的区别
- en: OAuth 2.0 specification clearly lays out how to use OAuth entirely inside a
    browser using JavaScript that has no way to securely store a token. This also
    explains at a high level how to use OAuth on a mobile phone or even on a device
    that has no web browser at all, covering interactions to *apps* and *native applications*
    on both smartphones and traditional computing devices, in addition to websites.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0规范清楚地阐述了如何完全在浏览器中使用JavaScript使用OAuth，而没有安全地存储令牌的方法。这还在高层次上解释了如何在手机上或甚至在根本没有网络浏览器的设备上使用OAuth，涵盖了对智能手机和传统计算设备上的*应用程序*和*本机应用程序*的交互，以及网站。
- en: 'OAuth 2.0 defines the following three types of profiles:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0定义了以下三种类型的配置文件：
- en: Web application (In this case, the client password is stored on the server,
    and access tokens are used.)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序（在这种情况下，客户端密码存储在服务器上，并且使用访问令牌。）
- en: Web browser client (In this case, the OAuth credentials are not trusted; some
    providers won't issue a client secret. An example is JavaScript in the browser.)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web浏览器客户端（在这种情况下，不信任OAuth凭据；一些提供商不会发布客户端密钥。一个例子是浏览器中的JavaScript。）
- en: Native application (In this case, access tokens or refresh tokens that are generated
    can provide an acceptable level of protection. An example includes mobile applications.)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本机应用程序（在这种情况下，生成的访问令牌或刷新令牌可以提供可接受的保护级别。一个例子包括移动应用程序。）
- en: OAuth 2.0 does not require encryption and uses HTTPS not HMAC. Additionally,
    OAuth 2.0 allows limiting the lifetime of an access token.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0不需要加密，使用的是HTTPS而不是HMAC。此外，OAuth 2.0允许限制访问令牌的生命周期。
- en: An authorization grant
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授权授予
- en: 'An authorization grant is a credential representing the resource owner or the
    user''s authorization, which allows a client to access its protected resources
    to obtain an access token. The OAuth 2.0 specification defines four grant types
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 授权授予是代表资源所有者或用户授权的凭据，允许客户端访问其受保护的资源以获取访问令牌。OAuth 2.0规范定义了四种授权类型，如下所示：
- en: The authorization code grant
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权码授予
- en: The implicit grant
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式授予
- en: The resource owner password credentials grant
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者密码凭据授予
- en: The client credentials grant
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端凭据授予
- en: Additionally, OAuth 2.0 also defines an extensibility mechanism for defining
    additional types.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，OAuth 2.0还定义了用于定义其他类型的可扩展机制。
- en: Refresh tokens versus access tokens
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新令牌与访问令牌
- en: Refresh tokens are credentials used to obtain access tokens. Refresh tokens
    are used to obtain the access token when the current access token becomes invalid
    or expires. Issuing a refresh token is optional at the discretion of the server.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新令牌是用于获取访问令牌的凭据。当当前访问令牌无效或过期时，刷新令牌用于获取访问令牌。发放刷新令牌是服务器自行决定的可选项。
- en: Unlike access tokens, refresh tokens are intended for use only with authorization
    servers and are never sent to resource servers to access a resource.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与访问令牌不同，刷新令牌仅用于与授权服务器一起使用，永远不会发送到资源服务器以访问资源。
- en: Jersey and OAuth 2.0
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jersey和OAuth 2.0
- en: Even though OAuth 2.0 is widely used by various enterprises, OAuth 2.0 RFC is
    a framework to build solutions on top of it. There are numerous gray areas in
    the RFC where the specification leaves it to the implementer. There were indecisions
    in areas where there is no required token type, no agreement on the token expiration,
    or no specific guidance on the token size.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OAuth 2.0被各个企业广泛使用，但OAuth 2.0 RFC是在其基础上构建解决方案的框架。在RFC中有许多灰色地带，规范留给实施者。在没有必需的令牌类型、令牌过期协议或令牌大小的具体指导的领域存在犹豫。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Read this page for more details:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读此页面以获取更多详细信息：
- en: '[http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/](http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/](http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/)'
- en: Currently, Jersey support for OAuth 2.0 is only on the client side. OAuth 2.0
    specification defines many extension points and it is up to service providers
    to implement these details. Additionally, OAuth 2.0 defines more than one authorization
    flow. The Authorization Code Grant Flow is the flow currently supported by Jersey
    and none of the other flows are supported. For more details, check [https://jersey.java.net/documentation/latest/security.html](https://jersey.java.net/documentation/latest/security.html).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Jersey对OAuth 2.0的支持仅限于客户端。OAuth 2.0规范定义了许多扩展点，由服务提供商来实现这些细节。此外，OAuth 2.0定义了多个授权流程。授权码授予流程是Jersey目前支持的流程，其他流程都不受支持。有关更多详细信息，请查看[https://jersey.java.net/documentation/latest/security.html](https://jersey.java.net/documentation/latest/security.html)。
- en: Best practices for OAuth in the REST API
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API中OAuth的最佳实践
- en: The following section lists some of the best practices that can be followed
    by service providers implementing OAuth 2.0.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分列出了服务提供商实施OAuth 2.0可以遵循的一些最佳实践。
- en: Limiting the lifetime for an access token
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制访问令牌的生命周期
- en: The protocol parameter `expires_in` allows an authorization server to limit
    the lifetime of an access token and to pass this information to the client. This
    mechanism can be used to issue short-living tokens.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 协议参数`expires_in`允许授权服务器限制访问令牌的生命周期，并将此信息传递给客户端。此机制可用于发行短期令牌。
- en: Support providing refresh tokens in the authorization server
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持在授权服务器中提供刷新令牌
- en: A refresh token can be sent along with a short lifetime access token to grant
    longer access to resources without involving user authorization. This offers an
    advantage where resource servers and authorization servers may not be the same
    entity. For example, in a distributed environment, the refresh token is always
    exchanged at the authorization server.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新令牌可以与短期访问令牌一起发送，以授予对资源的更长时间访问，而无需涉及用户授权。这提供了一个优势，即资源服务器和授权服务器可能不是同一实体。例如，在分布式环境中，刷新令牌总是在授权服务器上交换。
- en: Using SSL and encryption
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SSL和加密
- en: OAuth 2.0 heavily relies on HTTPS. This will make the framework simpler but
    less secure.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0严重依赖于HTTPS。这将使框架更简单但不太安全。
- en: The following table provides a quick summary of when to use SAML and when to
    use OAuth.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了何时使用SAML和何时使用OAuth的快速摘要。
- en: '| Scenario | SAML | OAuth |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 场景 | SAML | OAuth |'
- en: '| --- | --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| If one of the parties is an enterprise | Use SAML |   |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 如果参与方之一是企业 | 使用SAML |   |'
- en: '| If the application needs to provide temporary access to some resources |
      | Use OAuth |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 如果应用程序需要为某些资源提供临时访问权限 |   | 使用OAuth |'
- en: '| If the application needs a custom identity provider | Use SAML |   |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 如果应用程序需要自定义身份提供者 | 使用SAML |   |'
- en: '| If the application has mobile devices accessing it |   | Use OAuth |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 如果应用程序有移动设备访问 |   | 使用OAuth |'
- en: '| If the application has no restrictions on the transport, for example, SOAP
    and JMS | Use SAML |   |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 如果应用程序对传输没有限制，例如SOAP和JMS | 使用SAML |   |'
- en: OpenID Connect
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenID Connect
- en: There is work going on at the OpenID foundation with OpenID Connect. OpenID
    Connect is a simple REST- and JSON-based interoperable protocol built on top of
    OAuth 2.0\. It is simpler than SAML, easy to maintain, and covers the various
    security levels from social networks to business applications to highly secure
    government applications. OpenID Connect and OAuth are the future for authentication
    and authorization. For more details, check [http://openid.net/connect/](http://openid.net/connect/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID基金会正在进行OpenID Connect的工作。OpenID Connect是建立在OAuth 2.0之上的简单的基于REST和JSON的可互操作协议。它比SAML更简单，易于维护，并覆盖了从社交网络到商业应用程序再到高度安全的政府应用程序的各种安全级别。OpenID
    Connect和OAuth是身份验证和授权的未来。有关更多详细信息，请访问[http://openid.net/connect/](http://openid.net/connect/)。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Case studies of companies using OAuth 2.0 and OpenID Connect**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用OAuth 2.0和OpenID Connect的公司案例**'
- en: Google+ Sign-In is built on the OAuth 2.0 and OpenID Connect protocols. It supports
    over-the-air installs, social features, and a sign-in widget on top of standardized
    OpenID Connect sign-in flows.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Google+登录是建立在OAuth 2.0和OpenID Connect协议之上的。它支持空中安装、社交功能，并在标准化的OpenID Connect登录流程之上提供登录小部件。
- en: The next section will summarize some of the various components that we have
    covered so far when building RESTful services.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将总结到目前为止我们在构建RESTful服务时涵盖的各种组件。
- en: REST architecture components
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST架构组件
- en: 'The following section will cover the various components that must be considered
    when building RESTful APIs. All of these will be covered in various sections of
    this book. We will also cover best practices for each pitfall to avoid when designing
    and developing the REST API. The REST architecture components are shown in the
    following diagram:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将涵盖在构建RESTful API时必须考虑的各种组件。所有这些将在本书的各个部分中进行介绍。我们还将介绍在设计和开发REST API时要避免的各种陷阱的最佳实践。REST架构组件如下图所示：
- en: '![REST architecture components](img/7963OS_03_03.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![REST架构组件](img/7963OS_03_03.jpg)'
- en: As seen from the preceding diagram, REST services can be consumed from a variety
    of clients and applications running on different platforms and devices such as
    mobile devices and web browsers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图中可以看到，REST服务可以从各种客户端和运行在不同平台和设备上的应用程序中消耗，例如移动设备和Web浏览器。
- en: These requests are sent through a proxy server. The REST architectural components
    in the diagram can be chained one after the other as shown in the preceding diagram.
    For example, there can be a filter chain, consisting of the **Auth**, **Rate limiting**,
    **Caching**, and **Logging** related filters. This will take care of authenticating
    the user, checking if the requests from the client are within rate limits, then
    a caching filter that can check if the request can be served from the cache respectively.
    This can be followed by a logging filter, which can log the details of the request.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些请求通过代理服务器发送。如前图所示，可以将图中的REST架构组件链接在一起。例如，可以有一个过滤器链，包括**Auth**、**速率限制**、**缓存**和**日志记录**相关的过滤器。这将负责对用户进行身份验证，检查来自客户端的请求是否在速率限制内，然后是一个缓存过滤器，可以检查请求是否可以从缓存中提供。接下来是一个日志记录过滤器，可以记录请求的详细信息。
- en: On the response side, there can be **Pagination**, to ensure the server sends
    a subset of results. Also, the server can do **Asynchronous processing**, thus
    improving responsiveness and scale. There can be links in the response, which
    deals with HATEOAS.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应端，可以进行**分页**，以确保服务器发送结果的子集。此外，服务器可以进行**异步处理**，从而提高响应能力和规模。响应中可以包含链接，处理HATEOAS。
- en: 'These are some of the REST architectural components we have covered so far:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们迄今为止涵盖的一些REST架构组件：
- en: HTTP requests to use the REST API with HTTP verbs for the uniform interface
    constraint
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP请求使用HTTP动词来使用REST API进行统一接口约束
- en: Content negotiation to select a representation for a response when there are
    multiple representations available
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容协商，在存在多个表示可用时选择响应的表示
- en: Logging to provide traceability to analyze and debug issues
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录以提供可追溯性以分析和调试问题
- en: Exception handling to send application-specific exceptions with HTTP codes
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理以使用HTTP代码发送特定于应用程序的异常
- en: Authentication and authorization with OAuth 2.0 to give access control to other
    applications and to take actions without the user having to send their credentials
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0进行身份验证和授权，以便为其他应用程序提供访问控制，并在用户无需发送其凭据的情况下执行操作
- en: Validation to send back detailed messages with error codes to the client as
    well as validations for the inputs received in the request
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证以向客户端发送详细的带有错误代码的消息，以及对请求中收到的输入进行验证
- en: The next few chapters will focus on advanced topics as well as best practices
    for the following blocks. We will provide code snippets to show how to implement
    these with JAX-RS.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几章将重点介绍高级主题以及以下模块的最佳实践。我们将提供代码片段，以展示如何使用JAX-RS实现这些功能。
- en: Rate limiting to ensure the server is not burdened with too many requests from
    a single client
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制以确保服务器不会因来自单个客户端的太多请求而负担过重
- en: Caching to improve application responsiveness
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存以提高应用程序的响应能力
- en: Asynchronous processing so that the server can asynchronously send back the
    responses to the client
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理，使服务器可以异步地向客户端发送响应
- en: Micro services that comprise breaking up a monolithic service into fine-grained
    services
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务将单片服务分解为细粒度服务
- en: HATEOAS to improve usability, understandability, and navigability by returning
    a list of links in the response
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HATEOAS通过在响应中返回链接列表来改善可用性、可理解性和可导航性
- en: Pagination to allow clients to specify items in a dataset that they are interested
    in
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页，允许客户端指定感兴趣的数据集中的项目
- en: We will also cover how major platforms such as Facebook, Google, GitHub, and
    PayPal have approached each of these solutions in their REST API.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍主要平台，如Facebook、Google、GitHub和PayPal是如何在其REST API中采用这些解决方案的。
- en: Recommended reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐阅读
- en: 'The following links can be useful to get additional information related to
    the topics in this chapter:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接可能对获取与本章主题相关的额外信息有用：
- en: '[https://developers.google.com/oauthplayground/](https://developers.google.com/oauthplayground/):
    Google OAuth playground to create and test signed requests'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/oauthplayground/](https://developers.google.com/oauthplayground/)：Google
    OAuth playground用于创建和测试签名请求'
- en: '[http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/](http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/):
    OAuth 2.0 and road to hell'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/](http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/)：OAuth
    2.0和通往地狱之路'
- en: '[https://developers.google.com/accounts/docs/OAuth2Login](https://developers.google.com/accounts/docs/OAuth2Login):
    Google Accounts Authentication and Authorization'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/accounts/docs/OAuth2Login](https://developers.google.com/accounts/docs/OAuth2Login)：Google账户身份验证和授权'
- en: '[https://github.com/facebookarchive/scribe](https://github.com/facebookarchive/scribe):
    Scribe log server for Facebook'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/facebookarchive/scribe](https://github.com/facebookarchive/scribe)：Facebook的Scribe日志服务器'
- en: '[http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36356.pdf](http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36356.pdf):
    Google Dapper large-scale distributed tracing architecture'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36356.pdf](http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36356.pdf)：Google
    Dapper大规模分布式跟踪架构'
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter started off with a brief introduction to logging RESTful APIs and
    the key principles were to recognize the importance of logging requests and best
    practices for logging including security compliance. We learned how to validate
    JAX-RS 2.0 resources using Bean Validation. In this chapter, we also saw how to
    write generic exception mappers for application-specific cases.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以对记录RESTful API进行简要介绍开始，关键原则是认识到记录请求的重要性以及记录的最佳实践，包括安全合规性。我们学习了如何使用Bean Validation验证JAX-RS
    2.0资源。在本章中，我们还看到了如何为特定应用程序情况编写通用异常映射器。
- en: We covered how federated identities are a necessity in the current era of interconnected
    hybrid systems, protocols, and devices. We covered SAML and OAuth 2.0 similarities
    between SAML and 3-legged OAuth as well as best practices for OAuth.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了联合身份在当前互联混合系统、协议和设备时代的必要性。我们讨论了SAML和OAuth 2.0之间的相似之处，以及3-legged OAuth和OAuth的最佳实践。
- en: The next chapter will walk through topics such as caching patterns and asynchronous
    REST API to improve performance and scalability, followed by a closer look at
    how to perform partial updates with HTTP Patch and the newer JSON Patch.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍诸如缓存模式和异步REST API以提高性能和可伸缩性，然后更详细地了解如何使用HTTP Patch和更新JSON Patch执行部分更新。
