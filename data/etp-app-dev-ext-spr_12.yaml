- en: Chapter 12. 3T Administration Made Easy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。3T管理简化
- en: 'The 3T administration interface allows a user to maintain company, project,
    and task relationships. As the relationship is hierarchical, we will be working
    with one of the most versatile components in Ext JS: `Ext.tree.Panel`.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 3T管理界面允许用户维护公司、项目和任务之间的关系。由于关系是分层的，我们将使用Ext JS中最通用的组件之一：`Ext.tree.Panel`。
- en: 'The interface we will be building looks like the following screenshot:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的界面如下截图所示：
- en: '![3T Administration Made Easy](img/5457_12_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![3T管理简化](img/5457_12_01.jpg)'
- en: Selecting an item in the tree will display the appropriate record on the panel
    to the right, while the **Add New Company** button will allow the user to enter
    the name of a new company. Let's now examine these actions in detail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在树中选择一个项目将在右侧面板上显示相应的记录，而**添加新公司**按钮将允许用户输入新公司的名称。现在让我们详细研究这些操作。
- en: Administration workflows and layouts
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理工作流程和布局
- en: 'There are three different entities that may be edited (company, project, and
    task), with the preceding screenshot showing the company. Selecting a project
    in the tree will display the **Edit Project** form:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的实体可以进行编辑（公司、项目和任务），前面的截图显示了公司。在树中选择一个项目将显示**编辑项目**表单：
- en: '![Administration workflows and layouts](img/5457_12_02.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![管理工作流程和布局](img/5457_12_02.jpg)'
- en: 'Selecting a task will display the **Edit Task** form:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个任务将显示**编辑任务**表单：
- en: '![Administration workflows and layouts](img/5457_12_03.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![管理工作流程和布局](img/5457_12_03.jpg)'
- en: 'Selecting the **Add New Company** button will display an empty company form:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**添加新公司**按钮将显示一个空的公司表单：
- en: '![Administration workflows and layouts](img/5457_12_04.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![管理工作流程和布局](img/5457_12_04.jpg)'
- en: Note that the **Delete** and **Add Project** buttons are disabled. When an action
    is not allowed, the appropriate button will be disabled in all the screens. In
    this situation, you cannot add a project to a company that has not yet been saved.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**删除**和**添加项目**按钮是禁用的。当某个操作不被允许时，适当的按钮将在所有屏幕上被禁用。在这种情况下，您不能向尚未保存的公司添加项目。
- en: 'The tree tools will allow the user to expand, collapse, and refresh the tree:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 树工具将允许用户展开、折叠和刷新树：
- en: '![Administration workflows and layouts](img/5457_12_05.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![管理工作流程和布局](img/5457_12_05.jpg)'
- en: 'When the user first displays the administration interface, the **Add New Company**
    screen is shown. When any item is deleted, the **Please select an item from the
    tree…** message is displayed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户首次显示管理界面时，将显示**添加新公司**屏幕。当删除任何项目时，将显示**请从树中选择一个项目...**消息：
- en: '![Administration workflows and layouts](img/5457_12_06.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![管理工作流程和布局](img/5457_12_06.jpg)'
- en: Now that we have defined the interfaces and their behavior, it is time to define
    our views.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了界面及其行为，是时候定义我们的视图了。
- en: Building the 3T administration interface
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建3T管理界面
- en: 'The 3T administration interface will require us to build the components displayed
    in the following screenshot. The `ProjectForm` and `TaskForm` views are not visible
    and will be displayed when required in a card layout:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 3T管理界面将要求我们构建以下截图中显示的组件。`ProjectForm`和`TaskForm`视图不可见，将在需要时以卡片布局显示：
- en: '![Building the 3T administration interface](img/5457_12_07.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![构建3T管理界面](img/5457_12_07.jpg)'
- en: The `ManageTasks` view is an `hbox` layout that equally splits the left and
    right parts of the screen. The toolbar contains a single button to add a new company,
    while the region to the right is a card layout containing the `CompanyForm`, `ProjectForm`,
    and `TaskForm` views. Let's now look at each component in detail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManageTasks`视图是一个`hbox`布局，平均分割屏幕的左右两部分。工具栏包含一个按钮用于添加新公司，右侧区域是包含`CompanyForm`、`ProjectForm`和`TaskForm`视图的卡片布局。现在让我们详细看看每个组件。'
- en: The ManageTasks.js file
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ManageTasks.js文件
- en: 'The `ManageTasks` view defines the toolbar with the **Add New Company** button
    and splits the view into an `hbox` layout. The `companytree` panel and `container`
    defined with the card layout are configured by `xtype`. The card layout container
    contains the `CompanyForm`, `ProjectForm`, and `TaskForm`. The `ManageTasks` view
    is defined as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManageTasks`视图定义了带有**添加新公司**按钮的工具栏，并将视图分割为`hbox`布局。由`xtype`配置的`companytree`面板和使用卡片布局定义的`container`。卡片布局容器包含`CompanyForm`、`ProjectForm`和`TaskForm`。`ManageTasks`视图定义如下：'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note the use of a simple container as the first item of the card layout to display
    the **Please select an item from the tree...** message.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用简单容器作为卡片布局的第一项，以显示**请从树中选择一个项目...**消息。
- en: The CompanyForm.js file
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProjectForm.js文件
- en: 'The `CompanyForm` view has a very simple interface that only has one data entry
    field: `companyName`. This can be seen in the following lines of code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompanyForm`视图具有非常简单的界面，只有一个数据输入字段：`companyName`。这可以在以下代码行中看到：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note the initial state of the **Delete** and **Add Project** buttons are disabled
    until a valid company is loaded.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**删除**和**添加项目**按钮的初始状态是禁用的，直到加载有效的公司为止。
- en: The ProjectForm.js file
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProjectForm.js文件
- en: 'The layout and structure of the `ProjectForm` view is very similar to the company
    form we have just defined:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProjectForm`视图的布局和结构与我们刚刚定义的公司表单非常相似：'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once again the initial state of the **Delete** and **Add Task** buttons is `disabled`
    until a valid project is loaded.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，**删除**和**添加任务**按钮的初始状态是`禁用`，直到加载有效项目为止。
- en: The TaskForm.js file
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TaskForm.js文件
- en: 'The `TaskForm` view is again similar to the previous forms but will only need
    two buttons that are defined as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskForm`视图与之前的表单类似，但只需要两个按钮，定义如下：'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once again, the initial state of the **Delete** button is disabled until a valid
    task has been loaded.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，**删除**按钮的初始状态是禁用的，直到加载有效任务为止。
- en: The CompanyTree.js file
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompanyTree.js文件
- en: The final view is the `CompanyTree` view that represents the relationship between
    the company, project, and task.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最终视图是`CompanyTree`视图，表示公司、项目和任务之间的关系。
- en: '![The CompanyTree.js file](img/5457_12_11.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![The CompanyTree.js file](img/5457_12_11.jpg)'
- en: 'This view is defined as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图定义如下：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `CompanyTree` view extends `Ext.tree.Panel` that requires a specialized
    `Ext.data.TreeStore` implementation which manages tree nodes and the relationship
    between items. The Ext JS 4 tree is a very flexible component and we recommend
    you become familiar with the core tree concepts at [http://docs.sencha.com/extjs/4.2.2/#!/guide/tree](http://docs.sencha.com/extjs/4.2.2/#!/guide/tree).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompanyTree`视图扩展了`Ext.tree.Panel`，需要一个专门的`Ext.data.TreeStore`实现来管理树节点和项之间的关系。Ext
    JS 4树是一个非常灵活的组件，我们建议您熟悉核心树概念，网址为[http://docs.sencha.com/extjs/4.2.2/#!/guide/tree](http://docs.sencha.com/extjs/4.2.2/#!/guide/tree)。'
- en: Introducing the Ext.data.TreeStore class
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍`Ext.data.TreeStore`类
- en: The `Ext.data.TreeStore` class is the default store implementation used by `Ext.tree.Panel`.
    The `TreeStore` function provides many convenient functions for loading and managing
    hierarchical data. A `TreeStore` function may be defined with a model but this
    is not required. If a model is provided, it is decorated with the fields, methods,
    and properties of `Ext.data.NodeInterface` that are required for use in the tree.
    This additional functionality is applied to the prototype of the model to allow
    the tree to maintain the state and relationships between models.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ext.data.TreeStore`类是`Ext.tree.Panel`默认使用的存储实现。`TreeStore`函数提供了许多方便的函数来加载和管理分层数据。`TreeStore`函数可以使用模型来定义，但这不是必需的。如果提供了模型，它将使用`Ext.data.NodeInterface`的字段、方法和属性来装饰模型，这些属性是树中使用所需的。这个额外的功能被应用到模型的原型上，以允许树维护模型之间的状态和关系。'
- en: If a model is not provided, one such model will be created by the store in a
    way that it implements the `Ext.data.NodeInterface` class. We recommend you browse
    the `NodeInterface` API documentation to see the full set of fields, methods,
    and properties available on nodes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供模型，存储将以一种实现`Ext.data.NodeInterface`类的方式创建一个这样的模型。我们建议您浏览`NodeInterface`
    API文档，以查看节点上可用的全部字段、方法和属性。
- en: 'Our `CompanyTree` store definition for use in our tree is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于树的`CompanyTree`存储定义如下：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All the tree stores consume data that is in a hierarchical structure, either
    in JSON or XML format. We will generate JSON data in our request handling layer
    with the following structure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有树存储都使用分层结构的数据，可以是JSON或XML格式。我们将在请求处理层生成以下结构的JSON数据：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This structure defines the core properties used by any tree including `id`,
    `children`, `text`, `leaf`, and `expanded`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构定义了任何树使用的核心属性，包括`id`、`children`、`text`、`leaf`和`expanded`。
- en: 'The `children` property defines an array of nodes that exist at the same level
    and belong to the same parent. The top-level children in the structure belong
    to the root node and will be added to the root level of the tree. The tree panel
    property, `rootVisible:false`, will hide the root level from the view, displaying
    only the children. Enabling root-level visibility by setting the property to `rootVisible:true`
    will display the root node as defined in the `TreeStore` class. For example, adding
    the following definition to the tree store will result in the `Companies` node
    being displayed as shown in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`children`属性定义了存在于同一级别并属于同一父级的节点数组。结构中的顶级子节点属于根节点，并将添加到树的根级别。树面板属性`rootVisible:false`将隐藏视图中的根级别，仅显示子节点。通过将属性设置为`rootVisible:true`来启用根级别的可见性，将显示`TreeStore`类中定义的根节点。例如，将以下定义添加到树存储中将导致`Companies`节点显示如下截图所示：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Introducing the Ext.data.TreeStore class](img/5457_12_08.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Introducing the Ext.data.TreeStore class](img/5457_12_08.jpg)'
- en: We wish to display each company at the top level of the tree and hence will
    be hiding the root node from the view.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在树的顶层显示每个公司，因此将隐藏根节点。
- en: The `id` property is used internally to uniquely identify each node. There can
    be no duplicates for this property within the tree structure, and we will hence
    prefix the `id` value with the type of node. A node representing a company will
    be prefixed with `C_`, a project node with `P_`, and a task node with `T_`. This
    `id` format will allow us to determine both the node type and the primary key
    of the node. If an ID is not provided, the store would generate one for us.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`属性在内部用于唯一标识每个节点。在树结构内，此属性不能重复，因此我们将`id`值前缀为节点类型。表示公司的节点将以`C_`为前缀，项目节点以`P_`为前缀，任务节点以`T_`为前缀。这种`id`格式将允许我们确定节点类型和节点的主键。如果没有提供ID，存储将为我们生成一个ID。'
- en: 'The ID can also be used to dynamically assign an `iconCls` class to the node.
    We do this through the use of the `append` listener of the store and define this
    later in the controller. Note that we could just as easily define the `iconCls`
    property in JSON itself:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ID还可以用于动态分配`iconCls`类给节点。我们通过存储的`append`监听器来定义这一点，稍后在控制器中定义。请注意，我们也可以在JSON本身中轻松定义`iconCls`属性：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, we are now combining data with the presentation, and the Java method
    that generates JSON should not be concerned with how data is displayed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们现在正在将数据与呈现结合在一起，生成JSON的Java方法不应该关心数据如何显示。
- en: The `text` field of the JSON tree is used to display the node's text. For simple
    trees, without multiple columns, this is the default field name if not explicitly
    set with a column definition (tree columns will be discussed later in this chapter).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JSON树的`text`字段用于显示节点的文本。对于没有多列的简单树，如果没有使用列定义显式设置字段名，这是默认字段名（树列将在本章后面讨论）。
- en: The leaf property identifies whether this node can have children. All the task
    nodes have the `"leaf":true` setting. The `leaf` property defines whether the
    expand icon is shown next to the node.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`leaf`属性标识此节点是否可以有子节点。所有任务节点都具有`"leaf":true`设置。`leaf`属性定义了是否在节点旁边显示展开图标。'
- en: The last property of interest is the `expanded` property that indicates whether
    the node should be displayed in an expanded state. This property must be set to
    `true` on each node that has children if we're loading an entire tree at once;
    otherwise, the proxy will attempt to load children for these nodes dynamically
    when they are expanded. Our JSON data will contain the entire tree, and hence
    we set the `expanded` property to `true` for each parent node.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的最后一个属性是`expanded`属性，它指示节点是否应以展开状态显示。如果一次加载整个树，这个属性必须设置为`true`，以便在每个具有子节点的节点上设置;
    否则，代理将在展开这些节点时动态尝试加载子节点。我们的JSON数据将包含整个树，因此我们为每个父节点将`expanded`属性设置为`true`。
- en: Generating a JSON tree in the CompanyHandler class
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CompanyHandler类中生成JSON树
- en: It is now time to enhance the `CompanyHandler` class to generate the required
    JSON to load the tree store and display the company tree. We will create two new
    methods to implement this functionality.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候增强`CompanyHandler`类以生成所需的JSON来加载树存储并显示公司树了。我们将创建两个新方法来实现这个功能。
- en: The CompanyHandler.getTreeNodeId() method
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompanyHandler.getTreeNodeId()方法
- en: The `CompanyHandler.getTreeNodeId()` helper method generates a unique ID based
    on the ID of the `EntityItem` class. It will be used to generate type-specific
    IDs for each node.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompanyHandler.getTreeNodeId()`辅助方法基于`EntityItem`类的ID生成唯一ID。它将用于为每个节点生成特定类型的ID。'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The CompanyHandler.getCompanyTreeJson() method
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompanyHandler.getCompanyTreeJson()方法
- en: 'The `CompanyHandler getCompanyTreeJson()` method is mapped to the `company/tree.json`
    URL and has the following definition:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompanyHandler getCompanyTreeJson()`方法映射到`company/tree.json` URL，并具有以下定义：'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This method performs the following tasks:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法执行以下任务：
- en: It creates a `JsonArrayBuilder` object with the name `companyChildrenArrayBuilder`
    to hold the set of company `JsonObjectBuilder` instances that will be created
    in the main `for` loop when iterating through the company list.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建一个名为`companyChildrenArrayBuilder`的`JsonArrayBuilder`对象，用于保存在主`for`循环中通过公司列表进行迭代时将创建的公司`JsonObjectBuilder`实例集。
- en: It loops through each project assigned to each company, adding each project's
    `JsonObjectBuilder` tree node representation to the `projectChildrenArrayBuilder
    JsonArrayBuilder` instance. The `projectChildrenArrayBuilder` instance is then
    added as the `children` property of the owning company `JsonObjectBuilder` instance.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它循环遍历分配给每个公司的每个项目，将每个项目的`JsonObjectBuilder`树节点表示添加到`projectChildrenArrayBuilder
    JsonArrayBuilder`实例中。然后将`projectChildrenArrayBuilder`实例作为拥有公司`JsonObjectBuilder`实例的`children`属性添加。
- en: It loops through each task assigned to each project, adding each task's `JsonObjectBuilder`
    tree node representation to the `taskChildrenArrayBuilder JsonArrayBuilder` instance.
    The `taskChildrenArrayBuilder` instance is then added as the `children` property
    of the owning project, the `JsonObjectBuilder` instance.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它循环遍历分配给每个项目的每个任务，将每个任务的`JsonObjectBuilder`树节点表示添加到`taskChildrenArrayBuilder
    JsonArrayBuilder`实例中。然后将`taskChildrenArrayBuilder`实例作为拥有项目的`JsonObjectBuilder`实例的`children`属性添加。
- en: It adds the `companyChildrenArrayBuilder` as the `children` property of the
    `builder` instance that will be used to build and return JSON from the method
    with `success` property `true`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将`companyChildrenArrayBuilder`作为将用于从具有`success`属性`true`的方法构建和返回JSON的`builder`实例的`children`属性添加。
- en: The `getCompanyTreeJson` method returns a hierarchical JSON structure that encapsulates
    the relationship between the company, project, and task in a format that can be
    consumed by the `CompanyTree` store.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCompanyTreeJson`方法返回一个分层的JSON结构，封装了公司、项目和任务之间的关系，以一种可以被`CompanyTree`存储消费的格式。'
- en: Controlling the 3T administration
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制3T管理
- en: The `TTT.controller.AdminController` ties together the views and implements
    the many actions that are possible in this user interface. You must download the
    source code to see the complete definition of this controller as it is not reproduced
    completely within the following text.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`TTT.controller.AdminController`将视图联系在一起，并实现此用户界面中可能的许多操作。您必须下载源代码才能看到此控制器的完整定义，因为它在以下文本中没有完全重现。'
- en: The `AdminController` has references to the four stores required for processing
    actions. Each store is reloaded after an `update` or `delete` action to ensure
    the store is in sync with the database. For multiuser applications, this is an
    important point to consider; can view data be changed by a different user during
    the lifetime of a session? Unlike the task log interface, where data belongs to
    the user in the session, the 3T administration module may be actively used by
    different users at the same time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdminController`引用了处理操作所需的四个存储。在`update`或`delete`操作后重新加载每个存储，以确保存储与数据库同步。对于多用户应用程序，这是一个重要的考虑点；在会话的生命周期内，视图数据是否可以被不同用户更改？与任务日志界面不同，其中数据属于会话中的用户，3T管理模块可能会同时被不同用户积极使用。'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is beyond the scope of this book to discuss strategies for data integrity
    in multiuser environments. This is usually achieved through the use of per record
    timestamps that indicate the last update time. Appropriate logic in the service
    layer would test the submitted record timestamp against the timestamp in the database
    and then process the action accordingly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的范围不包括讨论多用户环境中数据完整性的策略。这通常是通过使用每个记录的时间戳来实现的，该时间戳指示最后更新时间。服务层中的适当逻辑将测试提交的记录时间戳与数据库中的时间戳，然后相应地处理操作。
- en: There is one store and model that is yet to be fully defined; we will do so
    now.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个尚未完全定义的存储和模型；我们现在将这样做。
- en: Defining the Company model and store
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义公司模型和存储
- en: 'The `Company` model was first defined using Sencha Cmd in [Chapter 9](ch09.html
    "Chapter 9. Getting Started with Ext JS 4"), *Getting Started with Ext JS 4*,
    but we now need to add the appropriate proxy and validations. The full definition
    is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Company`模型首先是在[第9章](ch09.html "第9章。开始使用Ext JS 4")中使用Sencha Cmd定义的，但现在我们需要添加适当的代理和验证。完整的定义如下：'
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Company` store will load all the company records through the `company/findAll.json`
    URL as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Company`存储将通过`company/findAll.json` URL加载所有公司记录，如下所示：'
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Company` model and store are our simplest definitions to date. We will
    now examine the core actions in our `AdminController`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Company`模型和存储是迄今为止我们最简单的定义。现在我们将检查`AdminController`中的核心操作。'
- en: The doAfterActivate function
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doAfterActivate函数
- en: The three stores that are required for 3T administration are loaded when the
    `ManageTasks` panel is activated. This will ensure that valid records are available
    in each store when selecting an item in the tree. The `doAfterActivate` function
    can be used for initializing the state of any components belonging to the `AdminController`.
    This is especially useful when configuring the drag-and-drop action at the end
    of this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当激活`ManageTasks`面板时，将加载3T管理所需的三个存储。这将确保在树中选择项目时，每个存储中都有有效的记录。`doAfterActivate`函数可用于初始化属于`AdminController`的任何组件的状态。在本章末尾配置拖放操作时，这将特别有用。
- en: Note that we are adding the **append** listener to the tree store view and assigning
    the `doSetTreeIcon` function. It is not possible to do this in the `init` function
    control config as the view is not yet configured and ready at this point in time.
    Assigning the `doSetTreeIcon` function to the listener after the activation ensures
    the component is fully configured. The `doSetTreeIcon` function dynamically assigns
    an `iconCls` class to each node depending on the node type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在向树存储视图添加**append**监听器，并分配`doSetTreeIcon`函数。在`init`函数控制配置中无法在此时进行此操作，因为视图在此时尚未配置和准备就绪。在激活后将`doSetTreeIcon`函数分配给监听器可以确保组件完全配置。`doSetTreeIcon`函数根据节点类型动态分配`iconCls`类。
- en: The final step in the `doAfterActivate` function is to load the tree store to
    display the data in the tree.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`doAfterActivate`函数的最后一步是加载树存储以显示树中的数据。'
- en: The doSelectTreeItem function
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doSelectTreeItem函数
- en: 'The `doSelectTreeItem` function is called when a user selects an item in the
    tree. The node ID is retrieved and split to allow us to determine the type of
    node:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在树中选择项目时，将调用`doSelectTreeItem`函数。检索节点ID并拆分以允许我们确定节点类型：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For each node, the primary key value is determined and used to retrieve the
    record from the appropriate store. The record is then loaded into the form, which
    is then set to be the active item in the admin card's layout.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个节点，将确定主键值并用于从适当的存储中检索记录。然后将记录加载到表单中，并将其设置为管理员卡片布局中的活动项目。
- en: The doSave functions
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doSave函数
- en: Each save function retrieves the record from the form and updates the record
    with the form values. The record is saved if the validation is successful and
    the form updated to reflect the changing button state. The store that owns the
    record is then reloaded to sync with the database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个保存函数都会从表单中检索记录，并使用表单数值更新记录。如果验证成功，则保存记录，并更新表单以反映按钮状态的变化。然后重新加载拥有记录的存储以与数据库同步。
- en: The doDelete functions
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doDelete函数
- en: 'Each delete function confirms the user action before calling the `destroy`
    method of the model. If successful, the active item in the admin card''s layout
    is set to display the default message: **Please select an item from the tree**.
    If the deletion was not successful, an appropriate message is displayed to inform
    the user.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个删除函数在调用模型的`destroy`方法之前都会确认用户操作。如果成功，管理员卡片布局中的活动项目将设置为显示默认消息：**请从树中选择一个项目**。如果删除不成功，将显示适当的消息通知用户。
- en: The doAdd functions
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doAdd函数
- en: The **Add** buttons are on the form that is the parent for the `Add` action.
    You can only add a project to a company or add a task to a project. Each `doAdd`
    function retrieves the parent and creates an instance of the child before loading
    the appropriate form. Buttons on the child form are disabled as needed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加**按钮位于作为`Add`操作父级的表单上。您只能将项目添加到公司或将任务添加到项目。每个`doAdd`函数都会检索父级并创建子级的实例，然后加载适当的表单。根据需要禁用子表单上的按钮。'
- en: Testing the 3T administration interface
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试3T管理界面
- en: 'We now need to add our new components to our `Application.js` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将新的组件添加到我们的`Application.js`文件中：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also need to add the `ManageTasks` view to our `MainCards`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将`ManageTasks`视图添加到我们的`MainCards`中：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can now run the application in the GlassFish server and test the 3T administration
    interface by logging on as the `bjones` user (or any other user who has administrator
    permission).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在GlassFish服务器上运行应用程序，并通过以`bjones`用户（或任何其他具有管理员权限的用户）登录来测试3T管理界面。
- en: Dynamically loading tree nodes
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态加载树节点
- en: Enterprise applications usually have data sets that prohibit the loading of
    the full tree in a single JSON request. Large trees can be configured to load
    children on a per node basis by expanding levels on demand. A few minor changes
    to our code can allow us to implement this dynamic loading of node children.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 企业应用程序通常具有数据集，禁止通过单个JSON请求加载完整的树。可以通过按需展开级别来配置大树以按节点加载子级。对我们的代码进行一些小的更改就可以实现这种动态加载节点子级。
- en: 'When a node is expanded, the tree store proxy submits a request that contains
    a `node` parameter with the ID of the node being expanded. The URL submitted is
    that which is configured in the proxy. We will change our tree store proxy as
    follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当节点展开时，树存储代理会提交一个包含正在展开的节点的`node`参数的请求。提交的URL是在代理中配置的。我们将按以下方式更改我们的树存储代理：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that the URL of the proxy has been changed to `treenode`. This mapping,
    when implemented in `CompanyHandler`, will load one level at a time. The first
    request submitted by the proxy to load the top level of the tree will have the
    following format:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代理的URL已更改为`treenode`。当在`CompanyHandler`中实现此映射时，将一次加载一级。代理提交给加载树顶级的第一个请求将具有以下格式：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will return the root node''s list of companies:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回根节点的公司列表：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that there is no `children` array defined for each company, and the `leaf`
    property is set to `false`. The Ext JS tree will display an expander icon next
    to the node if there are no children defined and the node is not a leaf. Clicking
    on the expander icon will submit a request that has the `node` parameter set to
    the `id` value for the node being expanded. Expanding the `"PACKT Publishing"`
    node would hence submit a request to load the children via `company/treenode.json?node=C_1`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个公司都没有定义`children`数组，并且`leaf`属性设置为`false`。如果没有定义子节点并且节点不是叶子节点，Ext JS树将在节点旁显示一个展开图标。点击展开图标将提交一个请求，该请求的`node`参数设置为正在展开的节点的`id`值。因此，展开`"PACKT
    Publishing"`节点将提交一个请求通过`company/treenode.json?node=C_1`来加载子节点。
- en: 'The JSON response would consist of a `children` array that would be appended
    to the tree as children of the `PACKT Publishing` node. In our example, the response
    would include the projects assigned to the company:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JSON响应将包含一个`children`数组，该数组将作为`PACKT Publishing`节点的子节点附加到树上。在我们的示例中，响应将包括分配给公司的项目：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once again each project would not define a `children` array, even if there
    are tasks assigned. Each project would be defined with `"leaf":false` to render
    an expander icon if there are tasks assigned. Expanding the `P_1` node would result
    in the proxy submitting a request to load the next level: `company/treenode.json?node=P_1`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，每个项目都不会定义一个`children`数组，即使有任务分配。每个项目都将被定义为`"leaf":false`，以渲染一个展开图标，如果有任务分配的话。展开`P_1`节点将导致代理提交一个请求来加载下一级：`company/treenode.json?node=P_1`。
- en: 'This would result in the following JSON being returned:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致返回以下JSON：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This time we define these nodes with `"leaf":true` to ensure the expander icon
    is not displayed and users are unable to attempt loading a fourth level of the
    tree.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将这些节点定义为`"leaf":true`，以确保不显示展开图标，并且用户无法尝试加载树的第四级。
- en: 'The `CompanyHandler` method that is responsible for this logic can now be defined
    and mapped to the `company/treenode.json` URL:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以定义负责此逻辑的`CompanyHandler`方法，并将其映射到`company/treenode.json` URL：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `getCompanyTreeNode` method determines the type of node being expanded and
    loads appropriate records from the service layer. The returned JSON is then consumed
    by the store and displayed in the tree.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCompanyTreeNode`方法确定正在展开的节点类型，并从服务层加载适当的记录。然后存储返回的JSON并在树中显示。'
- en: 'We can now run the project in GlassFish and display the **3T Admin** interface.
    The first level of the tree is loaded as expected:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在GlassFish中运行项目并显示**3T Admin**界面。树的第一级如预期加载：
- en: '![Dynamically loading tree nodes](img/5457_12_09.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![动态加载树节点](img/5457_12_09.jpg)'
- en: 'When the expander icon is clicked, the next level of the tree will be dynamically
    loaded:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击展开图标时，树的下一级将被动态加载：
- en: '![Dynamically loading tree nodes](img/5457_12_10.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![动态加载树节点](img/5457_12_10.jpg)'
- en: 'The third level can then be expanded to display the tasks:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以展开第三级来显示任务：
- en: '![Dynamically loading tree nodes](img/5457_12_11.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![动态加载树节点](img/5457_12_11.jpg)'
- en: We will leave it to you to enhance the `AdminController` for use with dynamic
    trees. Reloading the tree after each successful save or delete would not be very
    user friendly; changing the logic to only reload the parent node would be a far
    better solution.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让您增强`AdminController`以用于动态树。在每次成功保存或删除后重新加载树将不太用户友好；更改逻辑以仅重新加载父节点将是一个更好的解决方案。
- en: Displaying multiple tree columns
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示多列树
- en: 'Ext JS 4 trees can be configured to display multiple columns for visualising
    advanced data structures. We will make a few minor changes to display the ID of
    each node in the tree. Simply adding a new column to the tree definition will
    achieve this purpose:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 4树可以配置为显示多列以可视化高级数据结构。我们将进行一些小的更改以显示树中每个节点的ID。只需向树定义中添加一个新列即可实现此目的：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have also added the `text` property to each column, which is displayed in
    the header row, and enabled headers with `hideHeaders:false`. These minor changes
    will result in the following tree being displayed when fully expanded:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向每列添加了`text`属性，该属性显示在标题行中，并启用了`hideHeaders:false`的标题。这些小的更改将导致完全展开时显示以下树：
- en: '![Displaying multiple tree columns](img/5457_12_12.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![显示多列树](img/5457_12_12.jpg)'
- en: Drag-and-drop made easy
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻松实现拖放
- en: 'Dragging and dropping nodes within trees is easy with Ext JS 4\. To allow the
    drag-and-drop action within a tree, we need to add the `TreeViewDragDrop` plugin
    as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ext JS 4中，树内拖放节点非常容易。要允许树内的拖放动作，我们需要添加`TreeViewDragDrop`插件如下：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This simple inclusion will enable the drag-and-drop support for your tree. You
    will now be able to drag-and-drop any node to a new parent. Unfortunately, this
    is not exactly what we need. A task node should only be allowed to drop on a project
    node, while a project node should only be allowed to drop on a company node. How
    can we restrict the drag-and-drop action to these rules?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的包含将使您的树支持拖放。现在您可以拖放任何节点到一个新的父节点。不幸的是，这并不是我们需要的。任务节点只应允许放置在项目节点上，而项目节点只应允许放置在公司节点上。我们如何限制拖放动作遵循这些规则？
- en: 'There are two events that can be used to configure this functionality. These
    events are fired from the `TreeViewDragDrop` plugin and can be configured in the
    `doAfterActivate` function of the `AdminController` in the following way:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个事件可用于配置此功能。这些事件是从`TreeViewDragDrop`插件触发的，并且可以在`AdminController`的`doAfterActivate`函数中以以下方式配置：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `beforedrop` event can be used to test whether the `drag` and `drop` actions
    are valid. Returning `false` will stop the `drop` action from occurring and animate
    the node back to the origin of the action. The `drop` event can be used to process
    the `drop` action, most likely to persist the change to the underlying storage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforedrop`事件可用于测试`拖动`和`放置`动作是否有效。返回`false`将阻止`放置`动作发生，并将节点动画回到动作的原点。`drop`事件可用于处理`放置`动作，很可能是将更改持久化到底层存储。'
- en: 'The `isDropAllowed` function returns `true` or `false` depending on whether
    the drop target is valid for the node:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`isDropAllowed`函数根据放置目标是否对节点有效返回`true`或`false`。'
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function will restrict the `drag` and `drop` actions to two valid scenarios:
    dragging a project to a new company and dragging a task to a new project. All
    the other `drag` and `drop` actions are not allowed.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能将限制`拖动`和`放置`操作到两种有效的情况：将项目拖到新公司和将任务拖到新项目。不允许所有其他`拖动`和`放置`操作。
- en: 'Dragging and dropping alone is not enough; we now need to save the new parent
    after a successful drop. This action is handled in the `doChangeParent` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅拖放是不够的；我们现在需要在成功放置后保存新的父节点。这个操作在`doChangeParent`函数中处理。
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Dragging a valid node to a new parent is now persisted when the record is saved.
    You will now be able to drag-and-drop between valid tree nodes and automatically
    save the changes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将有效节点拖动到新父节点现在在记录保存时是持久的。您现在可以在有效树节点之间进行拖放，并自动保存更改。
- en: 'The animations provided by Ext JS 4 trees will guide your `drag` and `drop`
    actions. Dragging the **Database Development** node will animate the action as
    shown in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 4树提供的动画将指导您的`拖动`和`放置`操作。拖动**数据库开发**节点将如下截图所示执行动画操作：
- en: '![Drag-and-drop made easy](img/5457_12_13.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![轻松实现拖放](img/5457_12_13.jpg)'
- en: Should the drop action not be allowed, the node will animate back to the original
    position, providing instant visual feedback for the user.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不允许放置操作，节点将动画返回到原始位置，为用户提供即时的视觉反馈。
- en: Ext JS 4 trees are very flexible components, and there is still much to learn
    if you want to fully leverage trees in your application. We recommend that you
    explores the many tree examples on the *Sencha Docs* website for more complex
    examples including the `drag` and `drop` actions between trees and persisting
    model-based data nodes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 4树是非常灵活的组件，如果您想充分利用应用程序中的树，还有很多东西需要学习。我们建议您在*Sencha Docs*网站上探索许多树示例，包括树之间的`拖动`和`放置`操作以及持久化基于模型的数据节点的更复杂的示例。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The **3T Admin** interface introduced the tree component for displaying hierarchical
    data. The company, project, and task relationship was loaded into the tree via
    a single JSON request and allowed the user to maintain and add new entities.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**3T Admin**界面引入了树组件来显示分层数据。公司、项目和任务关系通过单个JSON请求加载到树中，并允许用户维护和添加新实体。'
- en: Dynamic loading of tree nodes was then explained and implemented. This strategy
    is best suited for very large trees with potentially complex data structures.
    Node-by-node dynamic loading is easily achieved with minimum changes required
    in the Ext JS 4 client and Java backend.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后解释和实现了树节点的动态加载。这种策略最适合具有潜在复杂数据结构的非常大的树。逐个节点的动态加载在Ext JS 4客户端和Java后端中需要最少的更改即可轻松实现。
- en: Displaying multiple tree columns and the basic drag-and-drop functionality was
    also explored and implemented to show the flexibility of the Ext JS 4 tree.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 还探讨并实现了显示多个树列和基本的拖放功能，以展示Ext JS 4树的灵活性。
- en: Our final step in the enterprise application development with Ext JS and Spring
    journey is building our 3T project for production deployment. Thankfully, Maven
    and Sencha Cmd can help make this an easy task as you will learn in our final
    chapter, [Chapter 13](ch13.html "Chapter 13. Moving Your Application to Production"),
    *Moving Your Application to Production*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用Ext JS和Spring进行企业应用程序开发的最后一步是为生产部署构建我们的3T项目。幸运的是，Maven和Sencha Cmd可以帮助您轻松完成这项任务，您将在我们的最后一章中了解到，[第13章](ch13.html
    "第13章。将您的应用程序移至生产环境"), *将您的应用程序移至生产环境*。
