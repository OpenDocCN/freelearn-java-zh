- en: Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Any Java class we write depends on other classes. The other classes a class
    depends on are its dependencies. If a class directly creates instances of dependencies,
    a tight coupling is established between them. With Spring, the responsibility
    of creating and wiring objects is taken over by a new component called the **IoC
    container**. Classes define dependencies and the Spring **Inversion of Control**
    (**IoC**) container creates objects and wires the dependencies together. This
    revolutionary concept, where the control of creating and wiring dependencies is
    taken over by the container, is famously called IoC or **dependency** **injection**
    (**DI**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的任何Java类都依赖于其他类。类依赖的其他类是其依赖项。如果一个类直接创建依赖项的实例，它们之间建立了紧耦合。使用Spring，创建和连接对象的责任被一个称为**IoC容器**的新组件接管。类定义依赖关系，Spring的**控制反转**（**IoC**）容器创建对象并将依赖项连接在一起。这个革命性的概念，即创建和连接依赖项的控制被容器接管，被称为IoC或**依赖注入**（**DI**）。
- en: In this chapter, we start with exploring the need for DI. We use a simple example
    to illustrate the use of DI. We will understand the important advantages of DI--easier
    maintainability, less coupling and improved testability. We will explore the DI
    options in Spring. We will end the chapter by looking at the standard DI specification
    for Java **Contexts and Dependency Injection** (**CDI**) and how Spring supports
    it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了DI的需求。我们使用一个简单的例子来说明DI的用法。我们将了解DI的重要优势--更容易维护，耦合度更低和改进的可测试性。我们将探索Spring中的DI选项。我们将结束本章，看一下Java的标准DI规范**上下文和依赖注入**（**CDI**）以及Spring如何支持它。
- en: 'This chapter will answer the following questions:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将回答以下问题：
- en: What is dependency injection?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是依赖注入？
- en: How does proper use of dependency injection make applications testable?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入的正确使用如何使应用程序可测试？
- en: How does Spring implement DI with annotations?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring如何使用注解实现DI？
- en: What is a component scan?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是组件扫描？
- en: What is the difference between Java and XML application contexts?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java和XML应用上下文之间有什么区别？
- en: How do you create unit tests for Spring contexts?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为Spring上下文创建单元测试？
- en: How does mocking make unit testing simpler?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟如何使单元测试更简单？
- en: What are the different bean scopes?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的bean作用域是什么？
- en: What is CDI and how does Spring support CDI?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是CDI以及Spring如何支持CDI？
- en: Understanding dependency injection
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖注入
- en: We will look at an example to understand dependency injection. We will write
    a simple business service that talks to a data service. We will make the code
    testable and see how proper use of DI makes the code testable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个例子来理解依赖注入。我们将编写一个简单的业务服务，与一个数据服务交互。我们将使代码可测试，并看到正确使用DI如何使代码可测试。
- en: 'The following is the sequence of steps we will follow:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将遵循的步骤顺序：
- en: Write a simple example of a business service talking to a data service. When
    a business service directly creates an instance of a data service, they are tightly
    coupled to one another. Unit testing will be difficult.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个业务服务与数据服务交互的简单示例。当业务服务直接创建数据服务的实例时，它们之间是紧密耦合的。单元测试将会很困难。
- en: Make code loosely coupled by moving the responsibility of creating the data
    service outside the business service.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将创建数据服务的责任移出业务服务，使代码松耦合。
- en: Bring in the Spring IoC container to instantiate the beans and wire them together.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入Spring IoC容器来实例化bean并将它们连接在一起。
- en: Explore the XML and Java configuration options that Spring provides.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索Spring提供的XML和Java配置选项。
- en: Explore Spring unit testing options.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索Spring单元测试选项。
- en: Write real unit tests using mocking.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模拟编写真正的单元测试。
- en: Understanding dependencies
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解依赖关系
- en: We will start with writing a simple example; a business service talking to another
    data service. Most Java classes depend on other classes. These are called **dependencies**
    of that class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写一个简单的例子开始；一个业务服务与另一个数据服务交互。大多数Java类依赖于其他类。这些被称为该类的**依赖项**。
- en: 'Take a look at an example class `BusinessServiceImpl`, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 看一个示例类`BusinessServiceImpl`，如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Typically, all well-designed applications have multiple layers. Every layer
    has a well-defined responsibility. The business layer contains the business logic.
    The data layer talks to the external interfaces and/or databases to get the data.
    In the preceding example, the `DataServiceImpl` class gets some data related to
    the user from the database. `BusinessServiceImpl` class is a typical business
    service, talking to the data service `DataServiceImpl` for data and adding business
    logic on top of it (in this example, the business logic is very simple: calculate
    the sum of data returned by the data service).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有设计良好的应用程序都有多个层。每个层都有明确定义的责任。业务层包含业务逻辑。数据层与外部接口和/或数据库交互以获取数据。在前面的例子中，`DataServiceImpl`类从数据库中获取与用户相关的一些数据。`BusinessServiceImpl`类是一个典型的业务服务，与数据服务`DataServiceImpl`交互获取数据，并在其上添加业务逻辑（在本例中，业务逻辑非常简单：计算数据服务返回的数据的总和）。
- en: '`BusinessServiceImpl` depends on `DataServiceImpl`. So, `DataServiceImpl` is
    a dependency of `BusinessServiceImpl`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`BusinessServiceImpl`依赖于`DataServiceImpl`。因此，`DataServiceImpl`是`BusinessServiceImpl`的一个依赖项。'
- en: Focus on how `BusinessServiceImpl` creates an instance of `DataServiceImpl`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关注`BusinessServiceImpl`如何创建`DataServiceImpl`的实例。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`BusinessServiceImpl` creates an instance by itself. This is tight coupling.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`BusinessServiceImpl`自己创建一个实例。这是紧耦合。'
- en: Think for a moment about unit testing; how do you unit test the `BusinessServiceImpl`
    class without involving (or instantiating) the `DataServiceImpl` class? It's very
    difficult. One might need to do complicated things such as reflection to write
    a unit test. So, the preceding code is not testable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想单元测试；如何在不涉及（或实例化）`DataServiceImpl`类的情况下对`BusinessServiceImpl`类进行单元测试？这很困难。人们可能需要做复杂的事情，比如使用反射来编写单元测试。因此，前面的代码是不可测试的。
- en: A piece of code (a method, a group of methods, or a class) is testable when
    you can easily write a simple unit test for it. One of the approaches used in
    unit testing is to mock the dependencies. We will discuss mocking in more detail
    later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当您可以轻松地为代码编写简单的单元测试时，代码（方法、一组方法或类）就是可测试的。单元测试中使用的方法之一是模拟依赖关系。我们将稍后更详细地讨论模拟。
- en: 'Here''s a question to think about: how do we make the preceding code testable?
    How do we reduce tight coupling between `BusinessServiceImpl` and `DataServiceImpl`?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要思考的问题：我们如何使前面的代码可测试？我们如何减少`BusinessServiceImpl`和`DataServiceImpl`之间的紧耦合？
- en: The first thing we can do is to create an interface for `DataServiceImpl`. Instead
    of using the direct class, we can use the newly created interface of `DataServiceImpl`
    in `BusinessServiceImpl`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是为`DataServiceImpl`创建一个接口。我们可以在`BusinessServiceImpl`中使用`DataServiceImpl`的新创建接口，而不是直接使用该类。
- en: 'The following code shows how to create an interface:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何创建一个接口：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s update the code in `BusinessServiceImpl` to use the interface:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`BusinessServiceImpl`中的代码以使用接口：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using interfaces helps in creating loosely coupled code. We can replace the
    wire with any implementation of an interface into a well-defined dependency.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口有助于创建松散耦合的代码。我们可以将任何接口实现替换为一个明确定义的依赖关系。
- en: For example, consider a business service that needs some sorting.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个需要进行一些排序的业务服务。
- en: The first option is to use the sorting algorithm directly in the code, for example,
    bubble sort. The second option is to create an interface for the sorting algorithm
    and use the interface. The specific algorithm can be wired in later. In the first
    option, when we need to change the algorithm, we will need to change the code.
    In the second option, all that we need to change is the wiring.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是直接在代码中使用排序算法，例如冒泡排序。第二个选项是为排序算法创建一个接口并使用该接口。具体的算法可以稍后连接。在第一个选项中，当我们需要更改算法时，我们需要更改代码。在第二个选项中，我们只需要更改连接。
- en: We are now using the `DataService` interface, but `BusinessServiceImpl` is still
    tightly coupled as it is creating an instance of `DataServiceImpl`. How can we
    solve that?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用`DataService`接口，但`BusinessServiceImpl`仍然紧密耦合，因为它创建了`DataServiceImpl`的实例。我们如何解决这个问题？
- en: How about `BusinessServiceImpl` not creating an instance of `DataServiceImpl`
    by itself? Can we create an instance of `DataServiceImpl` elsewhere (we will discuss
    who will create the instance later) and give it to `BusinessServiceImpl`?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`BusinessServiceImpl`不自己创建`DataServiceImpl`的实例怎么样？我们可以在其他地方创建`DataServiceImpl`的实例（稍后我们将讨论谁将创建实例）并将其提供给`BusinessServiceImpl`吗？'
- en: 'To enable this, we will update the code in `BusinessServiceImpl` to have a
    setter for `DataService`. The `calculateSum` method is also updated to use this
    reference. The updated code is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将更新`BusinessServiceImpl`中的代码，为`DataService`添加一个setter。`calculateSum`方法也更新为使用此引用。更新后的代码如下：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Instead of creating a setter for the data service, we could have also created
    a `BusinessServiceImpl` constructor accepting a data service as an argument. This
    is called a **constructor injection**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为数据服务创建一个setter之外，我们还可以创建一个接受数据服务作为参数的`BusinessServiceImpl`构造函数。这称为**构造函数注入**。
- en: 'You can see that `BusinessServiceImpl` can now work with any implementation
    of `DataService`. It is not tightly coupled with a specific implementation: `DataServiceImpl`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`BusinessServiceImpl`现在可以与`DataService`的任何实现一起工作。它与特定实现`DataServiceImpl`没有紧密耦合。
- en: 'To make the code even more loosely coupled (as we start writing the tests),
    let''s create an interface for `BusinessService` and have `BusinessServiceImpl`
    updated to implement the interface:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更加松散耦合（在开始编写测试时），让我们为`BusinessService`创建一个接口，并更新`BusinessServiceImpl`以实现该接口：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have reduced coupling, one question remains still; who takes the
    responsibility for creating instance of the `DataServiceImpl` class and wiring
    it to the `BusinessServiceImpl` class?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经减少了耦合，但仍然有一个问题；谁负责创建`DataServiceImpl`类的实例并将其连接到`BusinessServiceImpl`类？
- en: That's exactly where the Spring IoC container comes into the picture.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Spring IoC容器发挥作用的地方。
- en: The Spring IoC container
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring IoC容器
- en: The Spring IoC container creates the beans and wires them together according
    to the configuration setup created by the application developer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Spring IoC容器根据应用程序开发人员创建的配置设置创建bean并将它们连接在一起。
- en: 'The following questions need to be answered:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 需要回答以下问题：
- en: '**Question 1**: How does the Spring IoC container know which beans to create?
    Specifically, how does the Spring IoC container know to create beans for the `BusinessServiceImpl`
    and `DataServiceImpl` classes?'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题1：Spring IoC容器如何知道要创建哪些bean？具体来说，Spring IoC容器如何知道要为`BusinessServiceImpl`和`DataServiceImpl`类创建bean？
- en: '**Question 2**: How does the Spring IoC container know how to wire beans together?
    Specifically, how does the Spring IoC container know to inject the instance of
    the `DataServiceImpl` class into the `BusinessServiceImpl` class?'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题2：Spring IoC容器如何知道如何将bean连接在一起？具体来说，Spring IoC容器如何知道将`DataServiceImpl`类的实例注入`BusinessServiceImpl`类？
- en: '**Question 3**: How does the Spring IoC container know where to search for
    beans? It is not efficient to search all packages in the classpath.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题3：Spring IoC容器如何知道在哪里搜索bean？在类路径中搜索所有包并不高效。
- en: Before we can focus on creating a container, let's focus on questions 1 and
    2; how to define what beans need to be created and how to wire them together.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们专注于创建容器之前，让我们先专注于问题1和2；如何定义需要创建哪些bean以及如何将它们连接在一起。
- en: Defining beans and wiring
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义bean和装配
- en: Let's address the first question; how does the Spring IoC container know which
    beans to create?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解决第一个问题；Spring IoC容器如何知道要创建哪些bean？
- en: We need to tell the Spring IoC container which beans to create. This can be
    done using `@Repository` or `@Component` or `@Service` annotations on the classes
    for which beans have to be created. All these annotations tell the Spring Framework
    to create beans for the specific classes where these annotations are defined.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉Spring IoC容器要创建哪些bean。这可以通过在需要创建bean的类上使用`@Repository`或`@Component`或`@Service`注解来完成。所有这些注解告诉Spring框架在定义这些注解的特定类中创建bean。
- en: A `@Component` annotation is the most generic way of defining a Spring bean.
    Other annotations have more specific context associated with them. `@Service`
    annotation is used in business service components. `@Repository` annotation is
    used in **Data Access Object** (**DAO**) components.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component`注解是定义Spring bean的最通用方式。其他注解具有更具体的上下文。`@Service`注解用于业务服务组件。`@Repository`注解用于**数据访问对象**（**DAO**）组件。'
- en: 'We use `@Repository` annotation on `DataServiceImpl` because it is related
    to getting data from the database. We use `@Service` annotation on the `BusinessServiceImpl`
    class as follows, since it is a business service:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`DataServiceImpl`上使用`@Repository`注解，因为它与从数据库获取数据有关。我们在`BusinessServiceImpl`类上使用`@Service`注解，因为它是一个业务服务：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's shift our attention to question 2 now--how does the Spring IoC container
    know how to wire beans together? The bean of the `DataServiceImpl` class needs
    to be injected into that of the `BusinessServiceImpl` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转移到第二个问题上--Spring IoC容器如何知道如何将bean装配在一起？`DataServiceImpl`类的bean需要注入到`BusinessServiceImpl`类的bean中。
- en: 'We can do that by specifying an `@Autowired` annotation on the instance variable
    of the `DataService` interface in the `BusinessServiceImpl` class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`BusinessServiceImpl`类中的`DataService`接口的实例变量上指定一个`@Autowired`注解来实现这一点：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have defined the beans and their wiring, to test this, we need
    an implementation of `DataService`. We will create a simple, hardcoded implementation.
    `DataServiceImpl` returns a couple of pieces of data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了bean和它们的装配，为了测试这一点，我们需要一个`DataService`的实现。我们将创建一个简单的、硬编码的实现。`DataServiceImpl`返回一些数据：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have our beans and dependencies defined, let's focus on how to create
    and run a Spring IoC container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的bean和依赖关系，让我们专注于如何创建和运行Spring IoC容器。
- en: Creating a Spring IoC container
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Spring IoC容器
- en: 'There are two ways to create a Spring IoC container:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Spring IoC容器有两种方式：
- en: Bean factory
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean工厂
- en: Application context
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序上下文
- en: Bean factory is the basis for all Spring IoC functionality--bean life cycle
    and wiring. Application context is basically a superset of Bean factory with the
    additional functionality typically needed in an enterprise context. Spring recommends
    that you use the application context in all scenarios, except when the additional
    few KBs of memory that the application context consumes are critical.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Bean工厂是所有Spring IoC功能的基础--bean的生命周期和装配。应用程序上下文基本上是Bean工厂的超集，具有在企业环境中通常需要的附加功能。Spring建议在所有情况下使用应用程序上下文，除非应用程序上下文消耗的额外几KB内存是关键的。
- en: Let's use an application context to create a Spring IoC container. We can have
    either a Java configuration or an XML configuration for an application context.
    Let's start with using a Java application configuration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用应用程序上下文来创建一个Spring IoC容器。我们可以使用Java配置或XML配置来创建应用程序上下文。让我们首先使用Java应用程序配置。
- en: Java configuration for the application context
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序上下文的Java配置
- en: 'The following example shows how to create a simple Java context configuration:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何创建一个简单的Java上下文配置：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The key is the `@Configuration` annotation. This is what defines this as a Spring
    configuration.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是`@Configuration`注解。这就是定义这个为Spring配置的地方。
- en: One question remains; how does Spring IoC container know where to search for
    beans?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题；Spring IoC容器如何知道在哪里搜索bean？
- en: 'We need to tell the Spring IoC container the packages to search for by defining
    a component scan. Let''s add a component scan to our earlier Java configuration
    definition:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉Spring IoC容器要搜索的包，通过定义一个组件扫描。让我们在之前的Java配置定义中添加一个组件扫描：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have defined a component scan for the `com.mastering.spring` package. It
    shows how all the classes we discussed until now are organized. All the classes
    we have defined until now are present in this package as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`com.mastering.spring`包定义了一个组件扫描。它展示了我们到目前为止讨论的所有类是如何组织的。到目前为止，我们定义的所有类都按如下方式存在于这个包中：
- en: '![](img/68af0511-85af-4771-aa06-4611895098dc.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68af0511-85af-4771-aa06-4611895098dc.png)'
- en: A quick review
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾
- en: 'Let''s take a moment and review all the things we have done until now to get
    this example working:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间回顾一下我们到目前为止所做的一切，以使这个例子工作起来：
- en: We have defined a Spring configuration class `SpringContext` with the `@Configuration`
    annotation with a component scan for the `com.mastering.spring` package
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经定义了一个Spring配置类`SpringContext`，带有`@Configuration`注解和一个对`com.mastering.spring`包的组件扫描
- en: 'We have a couple of files (in the preceding package):'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一些文件（在前面的包中）：
- en: '`BusinessServiceImpl` with the `@Service` annotation'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BusinessServiceImpl`带有`@Service`注解'
- en: '`DataServiceImpl` with the `@Repository` annotation'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataServiceImpl`带有`@Repository`注解'
- en: '`BusinessServiceImpl` has the `@Autowired` annotation on the instance of `DataService`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BusinessServiceImpl`在`DataService`的实例上有`@Autowired`注解'
- en: 'When we launch up a Spring context, the following things will happen:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个Spring上下文时，将会发生以下事情：
- en: It will scan the `com.mastering.spring` package and find the `BusinessServiceImpl`
    and `DataServiceImpl` beans.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将扫描`com.mastering.spring`包，并找到`BusinessServiceImpl`和`DataServiceImpl`的bean。
- en: '`DataServiceImpl` does not have any dependency. So, the bean for `DataServiceImpl`
    is created.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataServiceImpl`没有任何依赖。因此，将创建`DataServiceImpl`的bean。'
- en: '`BusinessServiceImpl` has a dependency on `DataService`. `DataServiceImpl`
    is an implementation of the `DataService` interface. So, it matches the autowiring
    criteria. So, a bean for `BusinessServiceImpl` is created and the bean created
    for `DataServiceImpl` is autowired to it through the setter.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BusinessServiceImpl`依赖于`DataService`。`DataServiceImpl`是`DataService`接口的实现。因此，它符合自动装配的条件。因此，为`BusinessServiceImpl`创建了一个bean，并且为`DataServiceImpl`创建的bean通过setter自动装配到它。'
- en: Launching the application context with Java configuration
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java配置启动应用程序上下文
- en: 'The following program shows how to launch a Java context; we use the main method
    to launch the application context using `AnnotationConfigApplicationContext`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序显示了如何启动Java上下文；我们使用主方法使用`AnnotationConfigApplicationContext`启动应用程序上下文：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following lines of code create the application context. We want to create
    an application context based on the Java configuration. So, we use `AnnotationConfigApplicationContext`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行创建应用程序上下文。我们希望基于Java配置创建应用程序上下文。因此，我们使用`AnnotationConfigApplicationContext`：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the context is launched, we will need to get the business service bean.
    We use the `getBean` method that passes the type of the bean (`BusinessService.class`)
    as an argument:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上下文启动，我们将需要获取业务服务bean。我们使用`getBean`方法，传递bean的类型（`BusinessService.class`）作为参数：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are all set to launch the application context by running the `LaunchJavaContext`
    program.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已准备好通过运行`LaunchJavaContext`程序来启动应用程序上下文。
- en: The console log
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台日志
- en: 'The following are some of the important statements from the log once the context
    is launched using `LaunchJavaContext`. Let''s quickly review the log to get a
    deeper insight into what Spring is doing:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`LaunchJavaContext`启动上下文后日志中的一些重要语句。让我们快速查看日志，以深入了解Spring正在做什么：
- en: 'The first few lines show the component scan in action:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行显示了组件扫描的操作：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Spring now starts to create the beans. It starts with `businessServiceImpl`,
    but it has an autowired dependency:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Spring现在开始创建bean。它从`businessServiceImpl`开始，但它有一个自动装配的依赖项：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Spring moves on to `dataServiceImpl` and creates an instance for it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Spring继续移动到`dataServiceImpl`并为其创建一个实例：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Spring autowires `dataServiceImpl` into `businessServiceImpl`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Spring将`dataServiceImpl`自动装配到`businessServiceImpl`：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The XML configuration for the application context
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序上下文的XML配置
- en: In the previous example, we used a Spring Java configuration to launch an application
    context. Spring also supports XML configuration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用了Spring Java配置来启动应用程序上下文。Spring也支持XML配置。
- en: 'The following example shows how to launch an application context with an XML
    configuration. This will have two steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用XML配置启动应用程序上下文。这将有两个步骤：
- en: Defining the XML Spring configuration
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义XML Spring配置
- en: Launching the application context with the XML configuration
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XML配置启动应用程序上下文
- en: Defining the XML Spring configuration
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义XML Spring配置
- en: 'The following example shows a typical XML Spring configuration. This configuration
    file is created in the `src/main/resources` directory with the name `BusinessApplicationContext.xml`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了典型的XML Spring配置。此配置文件在`src/main/resources`目录中创建，名称为`BusinessApplicationContext.xml`：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The component scan is defined using `context:component-scan`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`context:component-scan`定义组件扫描。
- en: Launching an application context with the XML configuration
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XML配置启动应用程序上下文
- en: 'The following program shows how to launch an application context using the
    XML configuration. We use the main method to launch the application context using
    `ClassPathXmlApplicationContext`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序显示了如何使用XML配置启动应用程序上下文。我们使用主方法使用`ClassPathXmlApplicationContext`启动应用程序上下文：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following lines of code create the application context. We want to create
    an application context based on the XML configuration. So, we use `ClassPathXmlApplicationContext`
    to create an application context: `AnnotationConfigApplicationContext`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行创建应用程序上下文。我们希望基于XML配置创建应用程序上下文。因此，我们使用`ClassPathXmlApplicationContext`创建应用程序上下文：`AnnotationConfigApplicationContext`。
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once the context is launched, we will need to get a reference to the business
    service bean. This is very similar to what we did with the Java configuration.
    We use the `getBean` method, passing the type of the bean (`BusinessService.class`)
    as an argument.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上下文启动，我们将需要获取对业务服务bean的引用。这与我们使用Java配置所做的非常相似。我们使用`getBean`方法，传递bean的类型（`BusinessService.class`）作为参数。
- en: We can go ahead and run the `LaunchXmlContext` class. You will notice that we
    get output very similar to that we get when run the context with the Java configuration.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续运行`LaunchXmlContext`类。您会注意到，我们得到的输出与使用Java配置运行上下文时非常相似。
- en: Writing JUnit using the Spring context
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring上下文编写JUnit
- en: In the previous sections, we looked at how to launch a Spring context from the
    main method. Now let's shift our attention to launching a Spring context from
    a unit test.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看了如何从主方法启动Spring上下文。现在让我们将注意力转向从单元测试中启动Spring上下文。
- en: 'We can use `SpringJUnit4ClassRunner.class` as a runner to launch a Spring context:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SpringJUnit4ClassRunner.class`作为运行器来启动Spring上下文：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We would need to provide the location of the context configuration. We will
    use the XML configuration that we created earlier. Here''s how you can declare
    this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供上下文配置的位置。我们将使用之前创建的XML配置。以下是您可以声明的方式：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can autowire a bean from the context into the test using the `@Autowired`
    annotation. BusinessService is autowired by the type:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@Autowired`注解将上下文中的bean自动装配到测试中。BusinessService是按类型自动装配的：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As of now, `DataServiceImpl`, which is wired in, returns `Arrays.asList(new
    Data(10)`, `new Data(20))`. `BusinessServiceImpl` calculates the sum `10`+`20`
    and returns `30`. We will assert for `30` in the test method using `assertEquals`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，已经自动装配的`DataServiceImpl`返回`Arrays.asList(new Data(10)`，`new Data(20))`。`BusinessServiceImpl`计算和返回`10`+`20`的和`30`。我们将使用`assertEquals`在测试方法中断言`30`：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Why do we introduce unit testing so early in the book?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们在书中这么早介绍单元测试？
- en: Actually, we believe we are already late. Ideally, we would have loved to use
    **Test-driven development** (**TDD**) and write tests before code. In my experience,
    doing TDD leads to simple, maintainable, and testable code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们认为我们已经迟了。理想情况下，我们会喜欢使用**测试驱动开发**（**TDD**）并在编写代码之前编写测试。根据我的经验，进行TDD会导致简单、可维护和可测试的代码。
- en: 'Unit testing has a number of advantages:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试有许多优点：
- en: A safety net against future defects
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对未来缺陷的安全网
- en: Defects are caught early
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期发现缺陷
- en: Following TDD leads to a better design
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循TDD会导致更好的设计
- en: Well-written tests act as documentation of code and functionality--especially
    those written using the BDD Given-When-Then style
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好编写的测试充当代码和功能的文档--特别是使用BDD Given-When-Then风格编写的测试
- en: The first test we will write is not really a unit test. We will load up all
    the beans in this test. The next test, written using mocking, will be a real unit
    test, where the functionality being unit tested is the specific unit of code being
    written.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写的第一个测试实际上并不是一个单元测试。我们将在这个测试中加载所有的bean。下一个使用模拟编写的测试将是一个真正的单元测试，其中被单元测试的功能是正在编写的特定代码单元。
- en: 'The complete list of the test is as follows; it has one test method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的完整列表如下；它有一个测试方法：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There is one problem with the **JUnit** that we wrote. It is not a true unit
    test. This test is using the real (almost) implementation of `DataServiceImpl`
    for the JUnit test. So, we are actually testing the functionality of both `BusinessServiceImpl`
    and `DataServiceImpl`. That's not unit testing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的**JUnit**存在一个问题。它不是一个真正的单元测试。这个测试使用了`DataServiceImpl`的真实（几乎）实现进行JUnit测试。因此，我们实际上正在测试`BusinessServiceImpl`和`DataServiceImpl`的功能。这不是单元测试。
- en: The question now is this; how do we unit test `BusinessServiceImpl` without
    using a real implementation of `DataService`?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是；如何在不使用`DataService`的真实实现的情况下对`BusinessServiceImpl`进行单元测试？
- en: 'There are two options:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个选项：
- en: Create a stub implementation of the data service, providing some dummy data
    in the `src\test\java` folder. Use a separate test context configuration to autowire
    the stub implementation instead of the real the `DataServiceImpl` class.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据服务的存根实现，在`src\test\java`文件夹中提供一些虚拟数据。使用单独的测试上下文配置来自动装配存根实现，而不是真正的`DataServiceImpl`类。
- en: Create a mock of `DataService` and autowire the mock into `BusinessServiceImpl`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`DataService`的模拟并将其自动装配到`BusinessServiceImpl`中。
- en: Creating a stub implementation would mean the creation of an additional class
    and an additional context. Stubs become more difficult to maintain, as we need
    more variations in data for the unit test.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建存根实现意味着创建一个额外的类和一个额外的上下文。存根变得更难维护，因为我们需要更多的数据变化来进行单元测试。
- en: In the next section, we will explore the second option of using a mock for unit
    testing. With the advances in mocking frameworks (especially **Mockito**) in the
    last few years, you will see that we would not even need to launch a Spring context
    to execute the unit test.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用模拟进行单元测试的第二个选项。随着模拟框架（特别是Mockito）在过去几年中的进步，您将看到我们甚至不需要启动Spring上下文来执行单元测试。
- en: Unit testing with mocks
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟进行单元测试
- en: Let's start with understanding what mocking is. Mocking is creating objects
    that simulate the behavior of real objects. In the previous example, in the unit
    test, we would want to simulate the behavior of `DataService`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解模拟开始。模拟是创建模拟真实对象行为的对象。在前面的例子中，在单元测试中，我们希望模拟`DataService`的行为。
- en: Unlike stubs, mocks can be dynamically created at runtime. We will use the most
    popular mocking framework, Mockito. To understand more about Mockito, we recommend
    the Mockito FAQ at [https://github.com/mockito/mockito/wiki/FAQ](https://github.com/mockito/mockito/wiki/FAQ).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与存根不同，模拟可以在运行时动态创建。我们将使用最流行的模拟框架Mockito。要了解有关Mockito的更多信息，我们建议查看[https://github.com/mockito/mockito/wiki/FAQ](https://github.com/mockito/mockito/wiki/FAQ)上的Mockito常见问题解答。
- en: 'We will want to create a mock for `DataService`. There are multiple approaches
    to creating mocks with Mockito. Let''s use the simplest among them--annotations.
    We use the `@Mock` annotation to create a mock for `DataService`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`DataService`的模拟。使用Mockito创建模拟有多种方法。让我们使用其中最简单的方法--注解。我们使用`@Mock`注解来创建`DataService`的模拟：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once we create the mock, we will need to inject it into the class under test,
    `BusinessServiceImpl`. We do that using the `@InjectMocks` annotation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模拟后，我们需要将其注入到被测试的类`BusinessServiceImpl`中。我们使用`@InjectMocks`注解来实现：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the test method, we will need to stub the mock service to provide the data
    that we want it to provide. There are multiple approaches. We will use the BDD
    style methods provided by Mockito to mock the `retrieveData` method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试方法中，我们将需要存根模拟服务以提供我们想要提供的数据。有多种方法。我们将使用Mockito提供的BDD风格方法来模拟`retrieveData`方法：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What we are defining in the preceding code is called stubbing. As with anything
    with Mockito, this is extremely readable. When the `retrieveData` method is called
    on the `dataService` mock with any object of type `User`, it returns a list of
    three items with values specified.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中我们定义的是所谓的存根。与Mockito的任何东西一样，这是非常易读的。当在`dataService`模拟上调用`retrieveData`方法并传入任何`User`类型的对象时，它将返回一个具有指定值的三个项目的列表。
- en: When we use Mockito annotations, we would need to use a specific JUnit runner,
    that is, `MockitoJunitRunner`. `MockitoJunitRunner` helps in keeping the test
    code clean and provides clear debugging information in case of test failures.
    `MockitoJunitRunner` initializes the beans annotated with `@Mock` annotation and
    also validates the usage of framework after execution of each test method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Mockito注解时，我们需要使用特定的JUnit运行器，即`MockitoJunitRunner`。`MockitoJunitRunner`有助于保持测试代码的清晰，并在测试失败时提供清晰的调试信息。`MockitoJunitRunner`在执行每个测试方法后初始化带有`@Mock`注解的bean，并验证框架的使用。
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The complete list of the test is as follows. It has one test method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的完整列表如下。它有一个测试方法：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Container managed beans
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器管理的bean
- en: Instead of a class creating its own dependencies, in the earlier example, we
    looked at how the Spring IoC container can take over the responsibility of managing
    beans and their dependencies. The beans that are managed by the container are
    called **Container Managed Beans**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与其类自己创建其依赖项，我们之前的示例中看到了Spring IoC容器如何接管管理bean及其依赖项的责任。由容器管理的bean称为**容器管理的bean**。
- en: '![](img/871f784e-c0d0-49c9-a749-dfe125835f77.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/871f784e-c0d0-49c9-a749-dfe125835f77.png)'
- en: 'Delegating the creation and management of beans to the container has many advantages.
    Some of them are listed as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将bean的创建和管理委托给容器有许多优点。其中一些列举如下：
- en: Since classes are not responsible for creating dependencies, they are loosely
    coupled and testable. This leads to good design and fewer defects.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于类不负责创建依赖项，它们之间松耦合且易于测试。这导致了良好的设计和较少的缺陷。
- en: Since the container manages the beans, a few hooks around the beans can be introduced
    in a more generic way. Cross-cutting concerns, such as logging, caching, transaction
    management, and exception handling can be woven around these beans using **Aspect-Oriented
    Programming** (**AOP**). This leads to more maintainable code.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于容器管理bean，可以以更通用的方式引入围绕bean的一些钩子。诸如日志记录、缓存、事务管理和异常处理等横切关注点可以使用**面向方面的编程**（**AOP**）围绕这些bean进行编织。这导致了更易于维护的代码。
- en: Dependency injection types
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入类型
- en: 'In the previous example, we used a setter method to wire in the dependency.
    There are two types of dependency injections that are used frequently:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了setter方法来注入依赖项。经常使用的两种依赖注入类型是：
- en: The setter injection
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: setter注入
- en: The constructor injection
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: The setter injection
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setter注入
- en: 'The setter injection is used to inject the dependencies through setter methods.
    In the following example, the instance of `DataService` uses the setter injection:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: setter注入用于通过setter方法注入依赖项。在以下示例中，`DataService`的实例使用了setter注入：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Actually, in order to use the setter injection, you do not even need to declare
    a setter method. If you specify `@Autowired` on the variable, Spring automatically
    uses the setter injection. So, the following code is all that you need for the
    setter injection for `DataService`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，为了使用setter注入，甚至不需要声明setter方法。如果在变量上指定了`@Autowired`，Spring会自动使用setter注入。因此，以下代码就是您为`DataService`进行setter注入所需要的全部内容：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The constructor injection
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: 'The constructor injection, on the other hand, uses a constructor to inject
    dependencies. The following code shows how to use a constructor for injecting
    in `DataService`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入，另一方面，使用构造函数来注入依赖项。以下代码显示了如何在`DataService`中使用构造函数进行注入：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you run the code with the preceding implementation of `BusinessServiceImpl`,
    you will see this statement in the log, asserting that autowiring took place using
    the constructor:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行具有前面`BusinessServiceImpl`实现的代码时，您将在日志中看到此语句，断言使用构造函数进行了自动装配：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Constructor versus setter injection
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数与setter注入
- en: Originally, in XML-based application contexts, we used the constructor injection
    with mandatory dependencies and the setter injection with nonmandatory dependencies.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，在基于XML的应用程序上下文中，我们使用构造函数注入来处理强制依赖项，使用setter注入来处理非强制依赖项。
- en: However, an important thing to note is that when we use `@Autowired` on a field
    or a method, the dependency is required by default. If no candidates are available
    for an `@Autowired` field, autowiring fails and throws an exception. So, the choice
    is not so clear anymore with Java application contexts.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的一点是，当我们在字段或方法上使用`@Autowired`时，默认情况下依赖项是必需的。如果没有可用于`@Autowired`字段的候选项，自动装配将失败并抛出异常。因此，在Java应用程序上下文中，选择并不那么明显。
- en: Using the setter injection results in the state of the object changing during
    the creation. For fans of immutable objects, the constructor injection might be
    the way to go. Using the setter injection might sometimes hide the fact that a
    class has a lot of dependencies. Using the constructor injection makes it obvious,
    since the size of the constructor increases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用setter注入会导致对象在创建过程中状态发生变化。对于不可变对象的粉丝来说，构造函数注入可能是更好的选择。有时使用setter注入可能会隐藏一个类具有大量依赖项的事实。使用构造函数注入会使这一点显而易见，因为构造函数的大小会增加。
- en: Spring bean scopes
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring bean作用域
- en: Spring beans can be created with multiple scopes. The default scope is a singleton.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Spring bean可以创建多种作用域。默认作用域是单例模式。
- en: Since there is only one instance of a singleton bean, it cannot contain any
    data that is specific to a request.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单例bean只有一个实例，因此不能包含特定于请求的任何数据。
- en: 'The scope can be provided with the `@Scope` annotation on any spring bean:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在任何Spring bean上使用`@Scope`注解来提供作用域：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following table shows the different types of scopes available for beans:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可用于bean的不同作用域类型：
- en: '| **Scope** | **Use** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **作用域** | **用途** |'
- en: '| `Singleton` | By default, all beans are of the scope singleton. Only one
    instance of such beans is used per instance of the Spring IoC container. Even
    if there are multiple references to a bean, it is created only once per container.
    The single instance is cached and used for all subsequent requests using this
    bean. It is important to specify that the Spring singleton scope is one object
    per one Spring container. If you have multiple spring containers in a single JVM,
    then there can be multiple instances of the same bean. So, the Spring singleton
    scope is a little different from the typical definition of a singleton. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `Singleton` | 默认情况下，所有bean都是单例作用域。每个Spring IoC容器实例只使用一次这样的bean实例。即使有多个对bean的引用，它也只在容器中创建一次。单个实例被缓存并用于使用此bean的所有后续请求。重要的是要指出，Spring单例作用域是一个Spring容器中的一个对象。如果在单个JVM中有多个Spring容器，则可以有多个相同bean的实例。因此，Spring单例作用域与典型的单例定义有些不同。|'
- en: '| `Prototype` | A new instance is created every time a bean is requested from
    the Spring container. If a bean contains a state, it is recommended that you use
    the prototype scope for it. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `Prototype` | 每次从Spring容器请求bean时都会创建一个新实例。如果bean包含状态，建议您为其使用原型范围。 |'
- en: '| `request` | Available only in Spring web contexts. A new instance of bean
    is created for every HTTP request. The bean is discarded as soon as the request
    processing is done. Ideal for beans that hold data specific to a single request.
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `request` | 仅在Spring Web上下文中可用。为每个HTTP请求创建一个bean的新实例。一旦请求处理完成，bean就会被丢弃。适用于保存特定于单个请求的数据的bean。
    |'
- en: '| `session` | Available only in Spring web contexts. A new instance of bean
    is created for every HTTP session. Ideal for data specific to a single user, such
    as user permissions in a web application. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `session` | 仅在Spring Web上下文中可用。为每个HTTP会话创建一个bean的新实例。适用于特定于单个用户的数据，例如Web应用程序中的用户权限。
    |'
- en: '| `application` | Available only in Spring web contexts. One instance of bean
    per web application. Ideal for things such as application configuration for a
    specific environment. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `application` | 仅在Spring Web上下文中可用。每个Web应用程序一个bean实例。适用于特定环境的应用程序配置等内容。 |'
- en: Java versus XML configuration
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java与XML配置
- en: With the advent of annotations in Java 5, there is widespread use of Java configuration
    for Spring based applications. What is the right choice to make if you have to
    choose between a Java-based configuration as opposed to an XML-based configuration?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 5中注解的出现，基于Java的配置在基于Spring的应用程序中得到了广泛使用。如果必须在基于Java的配置和基于XML的配置之间进行选择，应该做出什么样的选择？
- en: 'Spring provides equally good support for Java and XML-based configuration.
    So, it''s left to the programmer and their team to make the choice. Whichever
    choice is made, it is important to have consistency across teams and projects.
    Here are some things you might need to consider when making a choice:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Spring对基于Java和基于XML的配置提供了同样良好的支持。因此，选择权在于程序员及其团队。无论做出何种选择，都很重要的是在团队和项目之间保持一致。在做出选择时，可能需要考虑以下一些事项：
- en: Annotations lead to shorter and simpler bean definitions.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解导致bean定义更短、更简单。
- en: Annotations are closer to the code they are applicable on than the XML-based
    configuration.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解比基于XML的配置更接近其适用的代码。
- en: Classes using annotations are no longer simple POJOs because they are using
    framework-specific annotations.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注解的类不再是简单的POJO，因为它们使用了特定于框架的注解。
- en: Autowiring problems when using annotations might be difficult to solve because
    the wiring is no longer centralized and is not explicitly declared.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注解时出现自动装配问题可能很难解决，因为连线不再是集中的，也没有明确声明。
- en: There might be advantages of more flexible wiring using Spring context XML if
    it is packaged outside the application packaging--WAR or EAR. This will enable
    us to have different setup for integration tests, for example.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它被打包在应用程序包装之外--WAR或EAR，使用Spring上下文XML可能会有更灵活的连线优势。这将使我们能够为集成测试设置不同的设置，例如。
- en: The @Autowired annotation in depth
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解@Autowired注解
- en: When `@Autowired` is used on a dependency, the application context searches
    for a matching dependency. By default, all dependencies that are autowired are
    required.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当在依赖项上使用`@Autowired`时，应用程序上下文会搜索匹配的依赖项。默认情况下，所有自动装配的依赖项都是必需的。
- en: 'Possible results are as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的结果如下：
- en: '**One match is found**: This is the dependency you are looking for'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**找到一个匹配项**：这就是你要找的依赖项'
- en: '**More than one match is found**: Autowiring fails'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**找到多个匹配项**：自动装配失败'
- en: '**No match is found**: Autowiring fails'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**找不到匹配项**：自动装配失败'
- en: 'Cases where more than one candidate is found can be resolved in two ways:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过两种方式解决找到多个候选项的情况：
- en: Use the `@Primary` annotation to mark one of the candidates as the one to be
    used
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Primary`注解标记其中一个候选项作为要使用的候选项
- en: Use `@Qualifier` to further qualify autowiring
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@Qualifier`进一步限定自动装配
- en: The @Primary annotation
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Primary注解'
- en: When the `@Primary` annotation is used on a bean, it becomes the primary one
    to be used when there is more than one candidate available to autowire a specific
    dependency.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当在bean上使用`@Primary`注解时，它将成为在自动装配特定依赖项时可用的多个候选项中的主要候选项。
- en: 'In the case of the following example , there are two sorting algorithms available:
    `QuickSort` and `MergeSort`. If the component scan finds both of them, `QuickSort`
    is used to wire any dependencies on `SortingAlgorithm` because of the `@Primary`
    annotation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，有两种排序算法可用：`QuickSort`和`MergeSort`。如果组件扫描找到它们两个，`QuickSort`将用于在`SortingAlgorithm`上连线任何依赖项，因为有`@Primary`注解：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The @Qualifier annotation
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Qualifier注解'
- en: The `@Qualifier` annotation can be used to give a reference to a Spring bean.
    The reference can be used to qualify the dependency that needs to be autowired.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Qualifier`注解可用于给出对Spring bean的引用。该引用可用于限定需要自动装配的依赖项。'
- en: 'In the case of the following example, there are two sorting algorithms available:
    `QuickSort` and `MergeSort`. But since `@Qualifier("mergesort")` is used in the
    `SomeService` class, `MergeSort`, which also has a `mergesort` qualifier defined
    on it, becomes the candidate dependency selected for autowiring:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，有两种排序算法可用：`QuickSort`和`MergeSort`。但由于`SomeService`类中使用了`@Qualifier("mergesort")`，因此`MergeSort`成为了自动装配选定的候选依赖项，因为它也在其上定义了`mergesort`限定符。
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Other important Spring annotations
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他重要的Spring注解
- en: 'Spring provides a great deal of flexibility in defining beans and managing
    the life cycle of a bean. There are a few other important Spring annotations that
    we will discuss in the table, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Spring在定义bean和管理bean的生命周期方面提供了很大的灵活性。还有一些其他重要的Spring注解，我们将在下表中讨论。
- en: '| **Annotations** | **Use** |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **注解** | **用途** |'
- en: '| `@ScopedProxy` | Sometimes, we will need to inject a request or a session-scoped
    bean into a singleton-scoped bean. In such situations, the `@ScopedProxy` annotation
    provides a smart proxy to be injected into singleton-scoped beans. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '`@ScopedProxy` | 有时，我们需要将一个请求或会话作用域的bean注入到单例作用域的bean中。在这种情况下，`@ScopedProxy`注解提供了一个智能代理，可以注入到单例作用域的bean中。'
- en: '| `@Component`, `@Service`, `@Controller`, `@Repository` | `@Component` is
    the most generic way of defining a Spring bean. Other annotations have more specific
    contexts associated with them.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component`、`@Service`、`@Controller`、`@Repository` | `@Component`是定义Spring
    bean的最通用方式。其他注解与它们关联的上下文更具体。'
- en: '`@Service` is used in the business service layer'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Service` 用于业务服务层'
- en: '`@Repository` is used in the **data access object** (**DAO**)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Repository` 用于**数据访问对象**（**DAO**）'
- en: '`@Controller` is used in presentation components'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Controller` 用于表示组件'
- en: '|'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `@PostConstruct` | On any spring bean, a post construct method can be provided
    using the `@PostConstruct` annotation. This method is called once the bean is
    fully initialized with dependencies. This will be invoked only once during a bean
    lifecycle. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '`@PostConstruct` | 在任何Spring bean上，可以使用`@PostConstruct`注解提供一个post construct方法。这个方法在bean完全初始化了依赖项后被调用。这将在bean生命周期中只被调用一次。'
- en: '| `@PreDestroy` | On any spring bean, a predestroy method can be provided using
    the `@PreDestroy` annotation. This method is called just before a bean is removed
    from the container. This can be used to release any resources that are held by
    the bean. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '`@PreDestroy` | 在任何Spring bean上，可以使用`@PreDestroy`注解提供一个predestroy方法。这个方法在bean从容器中移除之前被调用。这可以用来释放bean持有的任何资源。'
- en: Exploring Contexts and dependency injection
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索上下文和依赖注入
- en: CDI is Java EE's attempt at bringing DI into Java EE. While not as fully-fledged
    as Spring, CDI aims to standardize the basics of how DI is done. Spring supports
    the standard annotations defined in *JSR-330*. For the most part, these annotations
    are treated the same way as Spring annotations.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: CDI是Java EE将DI引入到Java EE的尝试。虽然不像Spring那样功能齐全，但CDI旨在标准化DI的基本方式。Spring支持*JSR-330*中定义的标准注解。在大多数情况下，这些注解与Spring注解的处理方式相同。
- en: 'Before we can use CDI, we will need to ensure that we have dependencies for
    CDI jars included. Here''s the code snippet:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用CDI之前，我们需要确保已经包含了CDI jar的依赖项。以下是代码片段：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this table, let's compare the CDI annotations with the annotations provided
    by Spring Framework. It should be noted that `@Value`, `@Required`, and `@Lazy`
    Spring annotations have no equivalent CDI annotations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，让我们比较一下CDI注解和Spring Framework提供的注解。应该注意的是，`@Value`、`@Required`和`@Lazy`
    Spring注解没有等价的CDI注解。
- en: '| **CDI annotation** | **Comparison with Spring annotations** |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '**CDI注解** | **与Spring注解的比较**'
- en: '| `@Inject` | Similar to `@Autowired`. One insignificant difference is the
    absence of the required attribute on `@Inject`. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '`@Inject` | 类似于`@Autowired`。一个微不足道的区别是`@Inject`上没有required属性。'
- en: '| `@Named` | `@Named` is similar to `@Component`. Identifies named components.
    In addition, `@Named` can be used to qualify the bean with a name similar to the
    `@Qualifier` Spring annotation. This is useful in situations when multiple candidates
    are available for the autowiring of one dependency. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '`@Named` | `@Named`类似于`@Component`。用于标识命名组件。此外，`@Named`也可以用于类似于`@Qualifier`
    Spring注解的bean限定。在一个依赖项的自动装配中有多个候选项可用时，这是很有用的。'
- en: '| `@Singleton` | Similar to the Spring annotation `@Scope`("singleton"). |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '`@Singleton` | 类似于Spring注解`@Scope`("singleton")。'
- en: '| `@Qualifier` | Similar to a similarly named annotation in Spring--`@Qualifier`
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '`@Qualifier` | 与Spring中同名的注解类似--`@Qualifier`'
- en: An example of CDI
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI的一个例子
- en: When we use CDI, this is what the annotations on the different classes would
    look like. There is no change in how we create and launch the Spring application
    context.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用CDI时，不同类上的注解看起来是这样的。在如何创建和启动Spring应用上下文方面没有变化。
- en: CDI marks no differentiation between `@Repository`, `@Controller`, `@Service`,
    and `@Component`. We use `@Named` instead of all the preceding annotations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: CDI对`@Repository`、`@Controller`、`@Service`和`@Component`没有区别。我们使用`@Named`代替所有前面的注解。
- en: 'In the example, we use `@Named` for `DataServiceImpl` and `BusinessServiceImpl`.
    We use `@Inject` to inject `dataService` into `BusinessServiceImpl` (instead of
    `@Autowired`):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们对`DataServiceImpl`和`BusinessServiceImpl`使用了`@Named`。我们使用`@Inject`将`dataService`注入到`BusinessServiceImpl`中（而不是使用`@Autowired`）：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Dependency injection (or IoC) is the key feature of Spring. It makes code loosely
    coupled and testable. Understanding DI is the key to making the best use of Spring
    Framework.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（或IoC）是Spring的关键特性。它使代码松散耦合且可测试。理解DI是充分利用Spring Framework的关键。
- en: In this chapter, we took a deep look at DI and the options Spring Framework
    provides. We also looked at examples of writing testable code and wrote a couple
    of unit tests.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了DI和Spring Framework提供的选项。我们还看了编写可测试代码的示例，并编写了一些单元测试。
- en: In the next chapter, we will shift our attention toward Spring MVC, the most
    popular Java web MVC framework. We will explore how Spring MVC makes the development
    of web applications easier.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把注意力转向Spring MVC，这是最流行的Java Web MVC框架。我们将探讨Spring MVC如何使Web应用程序的开发更加简单。
