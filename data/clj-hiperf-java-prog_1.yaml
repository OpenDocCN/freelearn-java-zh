- en: Part 1. Module 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 部分. 模块 1
- en: '**Clojure for Java Developers**'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**面向 Java 开发者的 Clojure**'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Transition smoothly from Java to the most widely used functional JVM-based
    language – Clojure*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*平滑地从 Java 过渡到最广泛使用的基于 JVM 的函数式语言 – Clojure*'
- en: Chapter 1. Getting Started with Clojure
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. Clojure 入门
- en: Welcome to the world of Clojure! If you are here, you probably know a little
    about Lisp or Clojure, but you don't really have an idea of how things work in
    this world.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 Clojure 的世界！如果你在这里，你可能对 Lisp 或 Clojure 有点了解，但你并不真正了解这个世界的运作方式。
- en: We will get to know Clojure by comparing each feature to what you already know
    from Java. You will see that there are lists, maps and sets just like in Java,
    but they are immutable. To work with these kinds of collections, you need a different
    approach; a different paradigm.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将每个功能与您从 Java 已知的内容进行比较来了解 Clojure。你会发现有列表、映射和集合，就像在 Java 中一样，但它们是不可变的。要处理这些类型的集合，你需要不同的方法；不同的范式。
- en: This is what we will try to accomplish in this book, to give you a different
    way to approach problems. We hope you end up using Clojure in your every day life,
    but if you don't, we hope you use a new approach toward problem solving.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这本书中试图达成的目标，给你提供一种不同的方法来解决问题。我们希望你在日常生活中使用 Clojure，但如果你不这样做，我们希望你在解决问题的方法上采用一种新的方式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting to know Clojure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Clojure
- en: Installing Leiningen
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Leiningen
- en: Using a **Read Eval Print Loop** (**REPL**)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **读取-评估-打印循环** (**REPL**)
- en: Installing and using Cursive Clojure
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用 Cursive Clojure
- en: Clojure's simple syntax
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure 的简单语法
- en: Clojure's data types and their relationship to the JVM's data types
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure 的数据类型及其与 JVM 数据类型的关系
- en: Special syntax for functions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的特殊语法
- en: Getting to know Clojure
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Clojure
- en: Before getting started with Clojure, you should know some of its features and
    what it shares with Java.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始学习 Clojure 之前，你应该了解一些它的特性和它与 Java 共同之处。
- en: Clojure is a programming language that inherits a lot of characteristics from
    Lisp. You might think of Lisp as that weird programming language with all the
    parentheses. You need to keep in mind that Clojure chooses to embrace functional
    programming. This makes it very different from current mainstream programming
    languages. You will get to know about immutable data structures and how to write
    programs without changing variable values.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 是一种从 Lisp 继承了许多特性的编程语言。你可能会把 Lisp 视为那种充满括号的奇怪编程语言。你需要记住的是，Clojure 选择拥抱函数式编程。这使得它与当前的主流编程语言非常不同。你将了解不可变数据结构以及如何编写不改变变量值的程序。
- en: You will also find that Clojure is a dynamic programming language, which makes
    it a little easier and faster to write programs than using statically typed languages.
    There is also the concept of using a REPL, a tool that allows you to connect to
    a program running environment and change code dynamically. It is a very powerful
    tool.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会发现 Clojure 是一种动态编程语言，这使得它比使用静态类型语言更容易、更快地编写程序。还有使用 REPL 的概念，这是一个允许你连接到正在运行的环境并动态更改代码的工具。这是一个非常强大的工具。
- en: At last, you will find out that you can convert Clojure to anything you like.
    You can create or use a statically typed system and bend the language to become
    what you like. A good example of this is the `core.typed` library, which allows
    you to specify the type information without adding support to the compiler.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你会发现你可以将 Clojure 转换为你喜欢的任何东西。你可以创建或使用静态类型系统，并将语言弯曲成你喜欢的样子。一个很好的例子是 `core.typed`
    库，它允许你指定类型信息，而无需向编译器添加支持。
- en: Installing Leiningen
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Leiningen
- en: We are used to having certain tools to help us build our code, such as Ant,
    Maven, and Gradle.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于拥有某些工具来帮助我们构建代码，例如 Ant、Maven 和 Gradle。
- en: 'In the Clojure ecosystem, the de facto standard for dependency and build management
    is Leiningen (affectionately named after the short story "Leiningen versus the
    Ants", which I recommend reading at [http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants](http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants));
    Leiningen strives to be a familiar to Java developers, it gets the best ideas
    from Maven, like: convention over configuration. It also gets ideas from Ant like
    custom scripting and plugins.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 生态系统内，依赖和构建管理的既定标准是 Leiningen（亲切地以短篇小说《莱宁根对抗蚂蚁》命名，我推荐阅读[http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants](http://en.wikipedia.org/wiki/Leiningen_Versus_the_Ants)）；Leiningen
    力求让 Java 开发者感到熟悉，它从 Maven 中汲取了最佳想法，如：约定优于配置。它还从 Ant 中汲取了灵感，如自定义脚本和插件。
- en: Installing it is very simple, let's check how to do it on Mac OS X (installing
    on Linux should be the same) using bash as your default shell.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装它非常简单，让我们看看如何在Mac OS X上使用bash作为默认shell进行安装（在Linux上的安装应该相同）。
- en: You should also have Java 7 or 8 already installed and configured in your path.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该已经安装并配置了Java 7或8在你的路径中。
- en: 'You can check the detailed instructions on the Leiningen project page [http://leiningen.org/](http://leiningen.org/).
    If you want to get a Leiningen installation up and running, this is what you would
    have to do:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Leiningen项目的页面上查看详细的说明[http://leiningen.org/](http://leiningen.org/)。如果你想将Leiningen安装起来并运行，你需要做以下事情：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first time you run the `lein` command, it downloads everything needed from
    the internet. This makes it very easy to distribute your code, you can even include
    the `lein` script with your own projects and make it easier for other developers
    to get up and running, the only real requirement is the JDK.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行`lein`命令时，它会从互联网下载所有需要的文件。这使得分发你的代码变得非常容易，你甚至可以将`lein`脚本包含在你的项目中，使其他开发者更容易上手，唯一真正的要求是JDK。
- en: Using a REPL
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REPL
- en: One of the main advantages of Clojure (and Lisp) is interactive development,
    the REPL is the base of what can be achieved with interactive programming, it
    allows you to connect to a running VM running Clojure and execute or modify code
    on the fly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure（以及Lisp）的主要优势之一是交互式开发，REPL是交互式编程可以实现的基石，它允许你连接到一个正在运行的运行Clojure的VM，并实时执行或修改代码。
- en: There is a story about how NASA was able to debug and correct a bug on a $100
    million piece of hardware that was 100 million miles away ([http://www.flownet.com/gat/jpl-lisp.html](http://www.flownet.com/gat/jpl-lisp.html)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于NASA如何能够在100亿美元硬件上调试和纠正一个100亿英里外的错误的故事（[http://www.flownet.com/gat/jpl-lisp.html](http://www.flownet.com/gat/jpl-lisp.html)）。
- en: 'We have that same power with Clojure and Leiningen and invoking it is very
    simple, you just need a single command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Clojure和Leiningen中也有同样的能力，调用它非常简单，你只需要一个命令：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is what you''ll get after running the preceding command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的命令后，你会得到以下结果：
- en: '![Using a REPL](img/B04289_01_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用REPL](img/B04289_01_01.jpg)'
- en: 'Let''s go into a bit more detail, as we can see we are running with the following
    programs:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下，正如我们所见，我们正在运行以下程序：
- en: Java 8
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8
- en: Clojure 1.6.0
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure 1.6.0
- en: We can also get some nice suggestions on how to see documentation, `source`,
    `Javadoc`, and previous errors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以获得一些关于如何查看文档、`source`、`Javadoc`和之前错误的良好建议。
- en: The nREPL protocol
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: nREPL协议
- en: One particular thing that is important to note is the nREPL protocol; Someday
    it might grant us the power to go into a machine running 100 million miles away.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特别需要注意的事情是nREPL协议；有一天它可能会赋予我们进入运行在100亿英里外的机器的能力。
- en: 'When you fire up your REPL, the first thing you see is:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动你的REPL时，你看到的第一件事是：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What it is saying is that there's a Clojure process running an nREPL server
    on port `55995`. We have connected to it using a very simple client that allows
    us to interact with the Clojure process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它所表达的意思是有一个Clojure进程在端口`55995`上运行nREPL服务器。我们通过一个非常简单的客户端连接到它，这个客户端允许我们与Clojure进程进行交互。
- en: 'The really interesting bit is that you can connect to a remote host just as
    easily; let''s try attaching an REPL to the same process by simply typing the
    following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有趣的部分是你可以像连接本地主机一样轻松地连接到远程主机；让我们尝试通过简单地输入以下命令将REPL附加到同一个进程：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Most IDEs have a good integration with Clojure and most of them use this exact
    mechanism, as clients that work a little more intelligently.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数IDE都与Clojure有很好的集成，其中大多数都使用这个确切的机制，作为稍微智能一点的客户端。
- en: Hello world
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello world
- en: 'Now that we are inside the REPL, (any of the two) let''s try writing our first
    expression, go on and type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入了REPL内部，（任意一个），让我们尝试编写我们的第一个表达式，继续并输入：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You should get back a value from the REPL saying `Hello world`, this is not
    really a program, and it is the `Hello world` value printed back by the print
    phase of the REPL.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从REPL得到一个返回值，显示`Hello world`，这实际上不是一个程序，而是REPL打印阶段的`Hello world`值。
- en: 'Let''s now try to write our first Lisp form:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试编写我们的第一个Lisp形式：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This first expression looks different from what we are used to, it is called
    an S-expression and it is the standard Lisp way.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个表达式看起来与我们习惯的不同，它被称为S表达式，这是Lisp的标准方式。
- en: 'There are a couple of things to remember with S-expressions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在S表达式中，有几个需要注意的事项：
- en: They are lists (hence, the name, Lisp)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是列表（因此得名，Lisp）
- en: The first element of the list is the action that we want to execute, the rest
    are the parameters of that action (one two three).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表中的第一个元素是我们想要执行的操作，其余的是该操作的参数（一个、两个、三个）。
- en: 'So we are asking for the string `Hello world` to be printed, but if we look
    a bit closer at the output, as shown in the following screenshot, there is a `nil`
    that we weren''t expecting:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们要求打印字符串`Hello world`，但如果我们仔细观察输出，如以下截图所示，有一个我们未预期的`nil`：
- en: '![Hello world](img/B04289_01_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Hello world](img/B04289_01_02.jpg)'
- en: The reason for this is that the `println` function returns the value `nil` (Clojure's
    equivalent for null) after printing `Hello world`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`println`函数在打印`Hello world`后返回值`nil`（Clojure的null等价物）。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Clojure, everything has a value and the REPL will always print it back for
    you.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，一切都有值，REPL会始终为你打印它。
- en: REPL utilities and conventions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REPL实用工具和约定
- en: As we saw, the Leiningen nREPL client prints help text; but how does that work?
    Let's explore some of the other utilities that we have.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Leiningen nREPL客户端打印帮助文本；但它是如何工作的？让我们探索一些其他实用工具。
- en: 'Try each of them to get a feeling of what it does with the help of the following
    table:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用以下表格中的每个来了解它们的功能：
- en: '| Function | Description | Sample |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `doc` | Prints out a function''s `docstring` | (`doc println`) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `doc` | 打印函数的`docstring` | (`doc println`) |'
- en: '| `source` | Prints a function''s source code, it must be written in Clojure
    | (`source println`) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `source` | 打印函数的源代码，它必须用Clojure编写 | (`source println`) |'
- en: '| `javadoc` | Open the `javadoc` for a class in the browser | (`javadoc java.lang.Integer`)
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `javadoc` | 在浏览器中打开类的`javadoc` | (`javadoc java.lang.Integer`) |'
- en: 'Let''s check how these functions work:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些函数是如何工作的：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What you are seeing here is metadata pertaining to the `doc` function; Clojure
    has the ability to store metadata about every function or `var` you use. Most
    of the Clojure core functions include a doc string and the source of the function
    and this is something that will become very handy in your day to day work.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的是与`doc`函数相关的元数据；Clojure具有存储每个函数或`var`使用的元数据的能力。大多数Clojure核心函数都包括文档字符串和函数的源代码，这在你的日常工作中将非常有用。
- en: 'Besides these functions, we also get easy access to the latest three values
    and the latest exceptions that happened in the REPL, let''s check this out:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些函数外，我们还可以轻松访问REPL中最近三个值和最近发生的异常，让我们来看看：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`*e` gives you access to the actual plain old Java exception object, so you
    can analyze and introspect it at runtime.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`*e`让你访问实际的Java异常对象，因此你可以在运行时分析和内省它。'
- en: You can imagine the possibilities of being able to execute and introspect code
    with this, but what about the tools that we are already used to? How can we use
    this with an IDE?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象使用这种方式执行和内省代码的可能性，但我们的工具呢？我们如何使用它与集成开发环境（IDE）结合使用？
- en: Let's check now how to create a new Clojure project, we'll use Leiningen from
    the command line to understand what is happening.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个新的Clojure项目，我们将使用命令行中的Leiningen来理解发生了什么。
- en: Creating a new project
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新项目
- en: Leiningen can help us create a new project using templates, there is a wide
    variety of templates available and you can build and distribute your own in Maven.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen可以帮助我们使用模板创建新项目，有各种各样的模板可供选择，你可以在Maven中构建和分发自己的模板。
- en: 'Some of the most common types of templates are:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的模板类型包括：
- en: Creating a `jar` library (the default template)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`jar`库（默认模板）
- en: Creating a command-line app
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命令行应用程序
- en: Creating a Clojure web app
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Clojure网络应用程序
- en: 'Let''s create a new Clojure command-line app and run it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Clojure命令行应用程序并运行它：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Project structure
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目结构
- en: Leiningen is similar to other Java development tools; it uses a similar convention
    and allows for heavy customizations in the `project.clj` file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen与其他Java开发工具类似；它使用类似的约定，并允许在`project.clj`文件中进行大量自定义。
- en: If you are familiar with Maven or Gradle, you can think of it as `pom.xml` or
    `build.gradle` respectively.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Maven或Gradle，你可以将其视为`pom.xml`或`build.gradle`。
- en: 'The following screenshot is the project structure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了项目结构：
- en: '![Project structure](img/B04289_01_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构](img/B04289_01_03.jpg)'
- en: 'As you can see in the preceding screenshot, there are four main folders:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，有四个主要文件夹：
- en: '`resources`: It holds everything that should be in the class path, such as
    files, images, configuration files, properties files, and other resources needed
    at runtime.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`: 它包含所有应该在类路径中的内容，例如文件、图像、配置文件、属性文件和其他在运行时需要的资源。'
- en: '`src`: Your Clojure source files; they are ordered in a very similar fashion
    to the `classpath`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`: 您的 Clojure 源文件；它们的排序方式与 `classpath` 非常相似。'
- en: '`dev-resources`: Everything that should be in the `classpath` in development
    (when you are running Leiningen). You can override your "production" files here
    and add files that are needed for tests to run.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev-resources`: 在开发中应该在 `classpath` 中的所有内容（当您运行 Leiningen 时）。您可以在这里覆盖您的“生产”文件，并添加测试运行所需的文件。'
- en: '`test`: Your tests; this code doesn''t get packaged but it is run every time
    you execute the Leiningen test.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`: 您的测试；这段代码不会被打包，但每次您执行 Leiningen 测试时都会运行。'
- en: Creating a standalone app
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建独立应用程序
- en: 'Once your project is created, you can build and run a Java standalone command-line
    app quite easily, let''s try it now:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的项目创建完成，您就可以轻松地构建和运行一个 Java 独立命令行应用程序，现在让我们试试：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, it is quite easy to create a standalone app and it is very similar
    to using Maven or Gradle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，创建独立应用程序非常简单，并且与使用 Maven 或 Gradle 非常相似。
- en: Using Cursive Clojure
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cursive Clojure
- en: 'Java already has some great tools to help us be more productive and write higher
    quality code and we don''t need to forget about those tools. There are several
    plugins for Clojure depending on what your IDE is. Have a look at them from the
    following table:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Java 已经有一些很棒的工具可以帮助我们提高生产力和编写更高质量的代码，我们不应该忘记这些工具。根据您的 IDE，有几个 Clojure 插件。请从以下表格中查看它们：
- en: '| IDE | Plugins |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| IDE | Plugins |'
- en: '| --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| IntelliJ | Cursive Clojure, La Clojure |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| IntelliJ | Cursive Clojure, La Clojure |'
- en: '| NetBeans | NetBeans Clojure (works with NetBeans 7.4) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| NetBeans | NetBeans Clojure（与 NetBeans 7.4 兼容）|'
- en: '| Eclipse | CounterClockwise |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Eclipse | CounterClockwise |'
- en: '| Emacs | Cider |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Emacs | Cider |'
- en: '| VIM | vim-fireplace, vim-leiningen |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| VIM | vim-fireplace, vim-leiningen |'
- en: A lot of people writing real Clojure code use Emacs and I actually like using
    vim as my main development tool, but don't worry, our main IDE will be IntelliJ
    + Cursive Clojure throughout the book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编写真实 Clojure 代码的人使用 Emacs，我实际上喜欢使用 vim 作为我的主要开发工具，但请放心，本书中我们将主要使用 IntelliJ
    + Cursive Clojure。
- en: Installing Cursive Clojure
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Cursive Clojure
- en: You can check the full documentation for Cursive at their website ([https://cursiveclojure.com/](https://cursiveclojure.com/)),
    it is still under development but it is quite stable and a great aid when writing
    Clojure code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在他们的网站上查看 Cursive 的完整文档（[https://cursiveclojure.com/](https://cursiveclojure.com/)），它仍在开发中，但相当稳定，并且在编写
    Clojure 代码时非常有帮助。
- en: We are going to use the latest IntelliJ Community Edition release, which at
    the time of this writing is version 14.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用最新的 IntelliJ Community Edition 版本，在撰写本文时是版本 14。
- en: You can download IntelliJ from here [https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这里下载 IntelliJ：[https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/)。
- en: 'Installing Cursive Clojure is very simple, you need to add a repository for
    IntelliJ. You''ll find the instructions to your specific IntelliJ version here:
    [https://cursiveclojure.com/userguide/](https://cursiveclojure.com/userguide/).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Cursive Clojure 非常简单，您需要为 IntelliJ 添加一个仓库。您可以在以下位置找到您特定 IntelliJ 版本的说明：[https://cursiveclojure.com/userguide/](https://cursiveclojure.com/userguide/)。
- en: After you have installed Cursive Clojure, we are ready to go.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在您安装了 Cursive Clojure 之后，我们就准备出发了。
- en: Now, we are ready to import our getting started project into Cursive Clojure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备将入门项目导入到 Cursive Clojure 中。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Cursive Clojure doesn't currently have support to create Leiningen projects
    from within the IDE; however, support is great in order to import them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Cursive Clojure 目前不支持在 IDE 内创建 Leiningen 项目；然而，导入它们的支持非常好。
- en: 'Here is how you will do it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将如何操作：
- en: Click on **File**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**文件**。
- en: Import project.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入项目。
- en: Look for your project.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找您的项目。
- en: Open the folder or the `project.clj` file.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件夹或 `project.clj` 文件。
- en: Follow the **Next** steps in the IDE.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IDE 中遵循**下一步**操作。
- en: 'Now, we are ready to go, you can use the Cursive Clojure as your main development
    tool. There are a few more things to do with your IDE but I recommend you to look
    for them; they are important and will come in handy:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备出发了，您可以使用 Cursive Clojure 作为您的主要开发工具。在您的 IDE 中还有更多的事情要做，但我建议您自己查找它们；它们很重要，并且会很有用：
- en: To know how to execute the project
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何执行项目
- en: To know how to execute the tests
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何执行测试
- en: To open an REPL connected to some project.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个连接到某个项目的 REPL。
- en: The key binding to execute some given piece of code (run form before cursor
    in REPL)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一些给定代码的关键绑定（在 REPL 中运行光标前的形式）
- en: The key binding to execute a given file (load file in REPL)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行给定文件的关键绑定（在 REPL 中加载文件）
- en: One important part of Clojure programming is that it can modify and reevaluate
    code in runtime. Check the manual of your current version of Clojure and check
    for the structural editing section ([https://cursiveclojure.com/userguide/paredit.html](https://cursiveclojure.com/userguide/paredit.html)).
    It is one of the most useful functionalities of Clojure IDEs and a direct consequence
    of the Clojure syntax.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 编程的一个重要部分是它可以在运行时修改和重新评估代码。检查你当前版本 Clojure 的手册，并查看结构编辑部分 ([https://cursiveclojure.com/userguide/paredit.html](https://cursiveclojure.com/userguide/paredit.html))。这是
    Clojure IDE 中的最有用功能之一，并且是 Clojure 语法的一个直接后果。
- en: I recommend you to check other functionalities from the manual. I really recommend
    checking the Cursive Clojure manual, it includes animations of how each functionality
    works.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你检查手册中的其他功能。我强烈建议检查 Cursive Clojure 手册，它包括每个功能如何工作的动画。
- en: You will use the last two key bindings quite a lot, so it is important to set
    them up correctly. There is more information about keybindings at [https://cursiveclojure.com/userguide/keybindings.html](https://cursiveclojure.com/userguide/keybindings.html).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常使用最后两个键绑定，所以正确设置它们很重要。有关键绑定的更多信息，请参阅 [https://cursiveclojure.com/userguide/keybindings.html](https://cursiveclojure.com/userguide/keybindings.html)。
- en: Getting started with Clojure code and data
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Clojure 代码和数据
- en: Let's take a deep dive into Clojure's syntax now, it is pretty different from
    other languages but it is actually much simpler. Lisps have a very regular syntax,
    with few special rules. As we said earlier, Clojure code is made of S-expressions
    and S-expressions are just lists. Let's look at some examples of lists to become
    familiar with lists in Lisp.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们深入探讨 Clojure 的语法，它与其他语言非常不同，但实际上要简单得多。Lisps 有一个非常规则的语法，规则很少。正如我们之前所说的，Clojure
    代码由 S-表达式组成，而 S-表达式只是列表。让我们看看一些列表的示例，以便熟悉 Lisp 中的列表。
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'All of the above are lists, but not all of them are valid code. Remember, only
    lists where the first element is a function can be considered valid expressions.
    So, here only the following could be valid expressions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的这些都是列表，但并不是所有的都是有效代码。记住，只有第一个元素是函数的列表才能被认为是有效表达式。所以，这里只有以下可以被认为是有效表达式：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If `println` and `one` are defined as functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `println` 和 `one` 被定义为函数。
- en: Let's see a piece of Clojure code, to finally explain how everything works.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一段 Clojure 代码，以最终解释一切是如何工作的。
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Lists in Clojure
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure 中的列表
- en: 'Clojure is based around "forms" or lists. In Clojure, same as every Lisp, the
    way to denote a list is with parentheses, so here are some examples of lists in
    the last code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 是基于“形式”或列表的。在 Clojure 中，就像每个 Lisp 一样，表示列表的方式是使用括号，所以这里有一些在上一个代码中的列表示例：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Lists are one data type in Clojure and they are also the way to express code;
    you will learn later about all the benefits of expressing code as data. The first
    one is that it is really simple, anything you can do must be expressed as a list!
    Let''s look at some other examples of executable code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是 Clojure 中的一个数据类型，它们也是表达代码的方式；你将在以后了解将代码表达为数据的所有好处。第一个好处是它非常简单，你可以做的任何事都必须以列表的形式表达！让我们看看一些其他可执行代码的示例：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I encourage you to write everything into the REPL, so you get a good notion
    of what's happening.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你将所有内容都写入 REPL，这样你就能很好地理解正在发生的事情。
- en: Operations in Clojure
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure 中的操作
- en: 'In Clojure, `MOST` of the executable forms have this structure:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，`MOST` 的可执行形式都有这种结构：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`op` is the operation to be executed followed by all the parameters it needs,
    let''s analyze each of our previous forms in this new light:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`op` 是要执行的操作，后面跟着所有需要的参数，让我们用这种新的视角分析我们之前的形式：'
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are asking to execute the `+` (addition) operation with the parameters `1`,
    `2`, and `3`. The expected result is `6`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求使用参数 `1`、`2` 和 `3` 执行 `+`（加法）操作。预期结果是 `6`。
- en: 'Let''s analyze something a bit more complicated:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一些更复杂的东西：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this, we are asking to execute the `clojure.core/map` function with two
    parameters:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求使用两个参数执行 `clojure.core/map` 函数：
- en: '`inc` is a function name, it takes a number and increments it'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inc` 是一个函数名，它接受一个数字并将其增加'
- en: '`[1 2 3 4 5 6]` is a collection of numbers'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1 2 3 4 5 6]` 是一个数字集合'
- en: Map applies the `inc` function to each member of the passed collection and returns
    a new collection, what we expect is a collection containing `[2 3 4 5 6 7]`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Map将`inc`函数应用于传递的集合的每个成员，并返回一个新的集合，我们期望的是一个包含`[2 3 4 5 6 7]`的集合。
- en: Functions in Clojure
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure中的函数
- en: 'Now let''s check how a function definition is essentially the same as the previous
    two forms:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下函数定义本质上与前面两种形式是如何相同的：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `defn` is the operation that we are asking for. It has several parameters,
    such as:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`defn`是我们所请求的操作。它有几个参数，例如：'
- en: '`some-function` is the name of the function that we are defining'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`some-function`是我们正在定义的函数的名称'
- en: '`[times parameter]` is a collection of parameters'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[times parameter]`是参数的集合'
- en: '`"Prints a string certain number of times"` is the docstring, it is actually
    an optional parameter'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"打印指定次数的字符串"`是文档字符串，它实际上是一个可选参数'
- en: '`(dotimes [x times] (println parameter))` is the body of the function that
    gets executed when you call `some-function`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(dotimes [x times] (println parameter))`是当调用`some-function`时执行的函数体'
- en: The `defn` calls a function into existence. After this piece of code is executed,
    `some-function` exists in the current namespace and you can use it with the defined
    parameters.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`defn`调用一个函数以使其存在。在这段代码执行后，`some-function`存在于当前命名空间中，你可以使用定义的参数来使用它。'
- en: 'The `defn` is actually written in Clojure and supports a few nice things. Let''s
    now define a `multi-arity` function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`defn`实际上是用Clojure编写的，并支持一些不错的东西。现在让我们定义一个`multi-arity`函数：'
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Over here we are defining a function with two bodies, one of them has no arguments
    and the other one has one argument. It is actually pretty simple to understand
    what's happening.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个有两个主体的函数，其中一个没有参数，另一个有一个参数。实际上，理解正在发生的事情相当简单。
- en: 'Try changing the source in your project''s `core.clj` file similar to the following
    example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改项目中`core.clj`文件的源代码，类似于以下示例：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now run it, you'll get three different Hello outputs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行它，你会得到三个不同的Hello输出。
- en: As you can see, Clojure has a very regular syntax and even if it's a little
    strange for newcomers, it is actually quite simple.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Clojure有一个非常规则的语法，即使对于新手来说有点奇怪，但实际上相当简单。
- en: Here, we have used a few data types that we haven't properly introduced; in
    the next section we'll take a look at them.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了一些尚未适当介绍的数据类型；在下一节中，我们将查看它们。
- en: Clojure's data types
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure的数据类型
- en: Now is when everything you know about Java pays off; even the list forms that
    you saw earlier implement the `java.util.List` interface. Clojure was designed
    to be embeddable and to have a great integration with the host platform, so it's
    only natural that you can use everything you already know about Java types and
    objects.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是你所知道的关于Java的一切发挥作用的时候了；甚至你之前看到的列表形式也实现了`java.util.List`接口。Clojure被设计成可嵌入的，并且与宿主平台有很好的集成，因此你可以使用你已知的所有关于Java类型和对象的知识是自然而然的事情。
- en: 'There are two data types in Clojure: scalars and collections.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中有两种数据类型：标量和集合。
- en: Scalars
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标量
- en: In every language you need primitive types; you use them in everyday life as
    they represent numbers, strings, and Booleans. These primitive types are called
    scalars in the Clojure world.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种语言中，你都需要原始类型；你在日常生活中使用它们，因为它们代表数字、字符串和布尔值。在Clojure世界中，这些原始类型被称为标量。
- en: Clojure has a couple of very interesting types like ratios and keywords. In
    the following table, you get to know the different types of scalars, how they
    compare to Java and a simple example of how to use each of them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有几个非常有趣的数据类型，如比例和关键字。在下面的表中，你可以了解不同的标量类型，它们与Java的比较以及如何使用每个类型的简单示例。
- en: '| Clojure data type | Java data type | Sample | Description |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| Clojure数据类型 | Java数据类型 | 示例 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| String | String | "This is a string""This is a multiline string" | A string
    of characters; in Clojure you can use multiline strings without a problem |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 字符串 | "This is a string""This is a multiline string" | 字符串；在Clojure中，你可以使用多行字符串而不会出现问题'
- en: '| Boolean | Boolean | truefalse | Literal Boolean values |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 布尔 | 布尔 | truefalse | 文字布尔值 |'
- en: '| Character | Character | `\c``\u0045 ;; Unicode char 45 E` | Character values,
    they are `java.lang.Character` instances, you can define Unicode characters |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 字符 | `\c``\u0045 ;; Unicode char 45 E` | 字符值，它们是`java.lang.Character`实例，你可以定义Unicode字符'
- en: '| Keywords | Doesn''t exist in java | `:key``:sample``:some-keyword` | They
    evaluate themselves and they are often used as keys. They are also functions that
    look for themselves in a map. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | Java 中不存在 | `:key``:sample``:some-keyword` | 它们会自我评估，通常用作键。它们也是查找自己在映射中的函数。
    |'
- en: '| Number | Numbers are automatically handled as `BigDecimal`, `BigInteger`
    or lower precision depending on what''s necessary | `42N ;;Big Integer``42 ;;long``0.1M
    ;;BigDecimal` | It is important to remember the trade-offs of Java numbers, if
    precision is important, you should always use big decimals and `bigintegers`.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | 数字会自动处理为 `BigDecimal`、`BigInteger` 或根据需要使用较低精度 | `42N ;;大整数``42 ;;long``0.1M
    ;;BigDecimal` | 记住 Java 数字权衡很重要，如果精度很重要，你应该始终使用大数和 `bigintegers`。 |'
- en: '| Ratio | Doesn''t exist | `22/7` | Clojure provides great numerical precision;
    if necessary it can retain the ration and execute exact operation. The tradeoff
    when using ratios is speed. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 比率 | Java 中不存在 | `22/7` | Clojure 提供了出色的数值精度；如果需要，它可以保留比率并执行精确操作。使用比率时的权衡是速度。
    |'
- en: '| Symbol | Doesn''t exist | some-name | Symbols are identifiers in Clojure,
    very similar to a variable name in Java. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | Java 中不存在 | some-name | 符号是 Clojure 中的标识符，与 Java 中的变量名非常相似。 |'
- en: '| nil | null | nil | The null value |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| nil | null | nil | 空值 |'
- en: '| Regular expressions | `java.util.regex.Pattern` | `#"\d"` | Regular expressions,
    in Clojure you get free syntax to define regular expressions, but in the end it
    is a plain old Java reggae Pattern |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式 | `java.util.regex.Pattern` | `#"\d"` | 正则表达式，在 Clojure 中，你可以免费使用语法来定义正则表达式，但最终它是一个普通的
    Java 正则表达式模式 |'
- en: Collection data types
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合数据类型
- en: 'In Clojure there are two types of collections: sequential and associative collections.
    Sequential are things you can iterate, such as lists. Associative collections
    are maps, sets, and things you can access by a certain index. Clojure''s collections
    are fully compatible with Java and it can even implement the `java.util` interfaces,
    such as `java.util.List` and `java.util.Map`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中有两种类型的集合：顺序集合和关联集合。顺序集合是可以迭代的，例如列表。关联集合是映射、集合以及可以通过特定索引访问的内容。Clojure
    的集合与 Java 完全兼容，甚至可以实现 `java.util` 接口，如 `java.util.List` 和 `java.util.Map`。
- en: One of the main characteristics of collections in Clojure is that they are immutable;
    it has a lot of benefits that we'll see later.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 中集合的一个主要特征是它们是不可变的；它有很多好处，我们稍后会看到。
- en: Let's have a look at the characteristics of each collection data type available
    in Clojure and compare them with Java with the help of a sample (in Clojure) and
    its description.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Clojure 中可用的每种集合数据类型的特征，并借助一个示例（在 Clojure 中）及其描述与 Java 进行比较。
- en: '| Clojure data type | Java data type | Sample | Description |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| Clojure 数据类型 | Java 数据类型 | 示例 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `List` | `List` | `(1 2 3 4 5)` | A simple list, notice the quote character
    before the list, if you don''t specify it Clojure will try to evaluate the form
    as an instruction |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `List` | `List` | `(1 2 3 4 5)` | 一个简单的列表，注意列表前的引号字符，如果你没有指定它，Clojure 会尝试将形式评估为指令
    |'
- en: '| `Vector` | `Array` | `[1 2 3 4 5]` | It is the main workhorse in Clojure,
    it is similar to an array because you can access elements in a random order |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `Vector` | `Array` | `[1 2 3 4 5]` | 它是 Clojure 中的主要工作马，它类似于数组，因为你可以以随机顺序访问元素
    |'
- en: '| `Set` | `HashSet` | `#{1 2 3 4}` | A normal Java hash set |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `Set` | `HashSet` | `#{1 2 3 4}` | 一个普通的 Java 哈希集 |'
- en: '| `Map` | `HashMap` | `{:key 5 :key-2 "red"}` | A Clojure map |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `Map` | `HashMap` | `{:key 5 :key-2 "red"}` | Clojure 的映射 |'
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you can see, Clojure has a mature development environment that is always
    evolving. You can set up command-line tools and your IDE in a very similar fashion
    to the way you will do in a normal Java development.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Clojure 拥有一个成熟且不断发展的开发环境。您可以以与在正常 Java 开发中相似的方式设置命令行工具和您的 IDE。
- en: We also learned a little about Clojure's regular syntax, its data types and
    how they relate to Java's own data types.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了一些关于 Clojure 的常规语法、其数据类型以及它们与 Java 自身数据类型之间关系的内容。
- en: 'Overall, you should now be comfortable with:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，你现在应该对以下内容感到舒适：
- en: Lisp syntax
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lisp 语法
- en: Creating a Leiningen project from scratch
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头创建 Leiningen 项目
- en: Running and packaging your code
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和打包您的代码
- en: Importing a Leiningen project into IntelliJ
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Leiningen 项目导入 IntelliJ
- en: Using the REPL
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 REPL
- en: Knowing the relationship between Clojure types and Java types
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Clojure 类型与 Java 类型之间的关系
- en: In the next chapter, we will get an idea of how to organize our code and how
    that organization takes advantage of Java packages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何组织我们的代码以及这种组织如何利用Java包的优势。
- en: Chapter 2. Namespaces, Packages, and Tests
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章：命名空间、包和测试
- en: We now have a working installation of Clojure and IntelliJ.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Clojure和IntelliJ。
- en: As a Java developer, you are used to working with classes as the minimal unit
    of organization. Clojure has a very different sense and gives you different tools
    to organize your code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名Java开发者，您习惯于以类作为组织的最小单元进行工作。Clojure有着非常不同的感觉，并为您提供不同的工具来组织您的代码。
- en: For starters, you should keep in mind that code and data are separate; you don't
    have a minimal unit with attributes and functions that work over those attributes.
    Your functions can work on any data structure that you wish, as long as you follow
    the rules of how the function works.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您应该记住，代码和数据是分开的；您没有一个具有属性和在这些属性上工作的函数的最小单元。您的函数可以作用于您希望使用的任何数据结构，只要您遵循函数的工作规则。
- en: In this chapter, we will start writing some simple functions to illustrate how
    separation of functions and data works and we will have a look at the tools Clojure
    gives us to make the separation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始编写一些简单的函数来展示函数和数据分离的工作方式，并查看Clojure为我们提供的工具来实现这种分离。
- en: 'In this chapter, we will cover the following topic:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How namespaces work compared to the classpath and Java packages
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与类路径和Java包相比，命名空间是如何工作的
- en: Unit tests
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: More Clojure examples and syntax
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多Clojure示例和语法
- en: Namespaces in Clojure
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure中的命名空间
- en: Clojure namespaces might be familiar to you, as a Java developer, and for a
    very good reason, they have a very deep relationship with Java's packages and
    the classpath.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure命名空间可能对您来说很熟悉，作为一名Java开发者，这有一个非常好的原因，它们与Java的包和类路径有着非常深的关系。
- en: First of all, let's review what we already know from Java.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下我们从Java中学到的知识。
- en: Packages in Clojure
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure中的包
- en: The Java code is organized in packages, a package in Java is a namespace that
    allows you to group a set of similar classes and interfaces.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Java代码是按包组织的，Java中的一个包是一个命名空间，它允许您将一组类似类和接口分组在一起。
- en: You can think of a package as something very similar to a folder in your computer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将包想象成您电脑中的一个文件夹。
- en: 'The following are some common packages that you use a lot when programming
    in Java:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在Java编程中经常使用的常见包：
- en: '`java.lang`: Everything that''s native to Java, including basic types (integer,
    long, byte, boolean, character, string, number, short, float, void, and class),
    the basic threading primitives (runnable, thread), the basic primitives for exceptions
    (throwable, error, exception), the basic exceptions and errors (`NoSuchMethodError`,
    `OutOfMemoryError`, `StackOverflowError`, and so on) and runtime access classes
    like runtime and system.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang`：Java的本地内容，包括基本类型（整数、长整型、字节、布尔型、字符、字符串、数字、短整型、浮点型、void和类），基本线程原语（可运行、线程），异常的基本原语（可抛出、错误、异常），基本异常和错误（`NoSuchMethodError`、`OutOfMemoryError`、`StackOverflowError`等）以及运行时访问类，如runtime和system。'
- en: '`java.io`: This package includes the primitives for input and output, such
    as console, file, readers, input streams, and writers.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io`：这个包包括输入和输出的原语，如控制台、文件、读取器、输入流和写入器。'
- en: '`java.util`: This is one of the most heavily used packages besides `java.lang`.
    This includes the classic data structures (map, set, list) along with the most
    common implementations of such data structures. This package also includes utilities
    like properties tools, scanner for reading from various input resources, `ServiceLoader`
    to load custom services from the `classloader`, UUID generator, timers, and so
    on.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util`：这是除了`java.lang`之外最常用的包之一。它包括经典的数据结构（映射、集合、列表）以及这些数据结构的常见实现。此包还包括属性工具、从各种输入资源读取的扫描仪、`ServiceLoader`从`classloader`加载自定义服务、UUID生成器、计时器等实用工具。'
- en: '`java.util.logging`: The logging utilities, you normally use them to give you
    different levels of alert, from a debug to serious conditions.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.logging`：日志实用工具，您通常使用它们来提供不同级别的警报，从调试到严重情况。'
- en: '`java.text`: These are utilities to manage text, dates, and numbers in a language
    independent way.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.text`：这些是管理文本、日期和数字的语言无关的实用工具。'
- en: '`javax.servlet`: This includes the primitives to create web apps and deployment
    in standard web containers.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.servlet`：这包括创建Web应用和在标准Web容器中部署的原语。'
- en: Each one of these packages groups several related functionalities, the `java.lang`
    package is particularly important, since it has every Java core type, such as
    string, long, and integer. Everything inside the `java.lang` package is available
    automatically everywhere.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包中的每一个都包含几个相关的功能，特别是`java.lang`包尤为重要，因为它包含了所有的Java核心类型，如字符串、长整型和整型。`java.lang`包中的所有内容都可以在所有地方自动使用。
- en: 'The `java.lang` package provides a bit more than just code organization, it
    also provides access security. If you remember about Java, there are three security
    access levels:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang`包不仅提供了代码组织，还提供了访问安全性。如果你还记得Java，有三个安全访问级别：'
- en: private
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有的
- en: public
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共的
- en: protected
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的
- en: In the case of packages, we are concerned with the protected level of access.
    The classes in the same package allow every other class in the same package to
    access its protected attributes and methods.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在包的情况下，我们关注的是受保护的访问级别。同一包中的类允许同一包中的其他类访问其受保护的属性和方法。
- en: There are also ways to analyze a package in runtime but they are involved and
    allow for very little to be done.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时分析包也有方法，但它们很复杂，而且能做的事情非常有限。
- en: Packages are implemented at the top of Java's classpath and the classloader.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 包是在Java的类路径和类加载器的顶部实现的。
- en: The classpath and the classloader
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类路径和类加载器
- en: Java was designed to be modular and for that it needs some way to load your
    code easily. The answer to this was the classloader, the classloader allows you
    to read resources from every entry of the classpath; you can look at resources
    in the classpath as a hierarchical structure similar to the file system.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Java被设计成模块化的，为此它需要一种轻松加载你的代码的方法。这个答案就是类加载器，类加载器允许你从类路径的每个条目中读取资源；你可以将类路径资源视为类似于文件系统的一个分层结构。
- en: The classloader is just a list of entries; each entry can be a directory in
    the filesystem or a JAR file. At this point, you should also know that JAR files
    are just zip files.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器只是一个条目列表；每个条目可以是文件系统中的一个目录或一个JAR文件。此时，你也应该知道JAR文件只是zip文件。
- en: The classloader will treat each entry as a directory (JAR files are just zipped
    directories) and it will look for files in each directory.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器将每个条目视为一个目录（JAR文件只是压缩的目录），并且它会在每个目录中查找文件。
- en: 'There are a lot of concepts here to remember, let''s try to summarize them:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多概念需要记住，让我们尝试总结一下：
- en: JAR files are ZIP files; they might contain several classes, properties, files,
    and so on.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR文件是ZIP文件；它们可能包含多个类、属性、文件等。
- en: The classpath is a list of entries; each entry is a JAR file or a system directory.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径是一个条目列表；每个条目都是一个JAR文件或系统目录。
- en: The classloader looks for resources in each entry of the classpath, so you can
    think of classpath resources as a combination of all the directories in the classpath
    (repeated resources are not overwritten)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器在类路径的每个条目中查找资源，所以你可以将类路径资源视为类路径中所有目录的组合（重复的资源不会被覆盖）
- en: 'If you are not already familiar with how classloaders look for resources in
    classpath entries, this is the general process; let''s imagine that you want to
    load a class: `test.Test`, what happens next?'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉类加载器如何在类路径条目中查找资源，这是一个一般的过程；让我们想象一下，你想要加载一个类：`test.Test`，接下来会发生什么？
- en: You tell the JVM that you want to load `test.Test`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你告诉JVM你想加载`test.Test`。
- en: The JVM knows to look for the `test`/`Test.class` file.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM知道要查找`test`/`Test.class`文件。
- en: It starts looking for it in each entry of the classpath.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它开始在类路径的每个条目中查找它。
- en: If the resource is a ZIP file, it "unzips" the directory.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果资源是一个ZIP文件，它“解压”目录。
- en: It looks for the resource in the directory which represents the entry.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在代表条目的目录中查找资源。
- en: 'If you were to see the default classpath resources, you will probably see something,
    such as:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到默认的类路径资源，你可能会看到一些东西，例如：
- en: '[PRE21]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is important to note that each entry in the classpath doesn't just store
    class files, it can actually store any type of resource, It is a commonplace to
    store configuration files, such as `.properties` or `.xml`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，类路径中的每个条目不仅存储类文件，实际上可以存储任何类型的资源，存储配置文件，如`.properties`或`.xml`是很常见的。
- en: Nothing forbids you from storing anything else in the classpath resources, such
    as images, mp3 or even code! You can read and access anything from the classpath's
    resource like you can from the filesystem at runtime. The one thing that you can't
    do is modify the classpath's resource contents (at least not without some esoteric
    magic).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何规定你不能在类路径资源中存储其他东西，比如图片、mp3甚至代码！你可以像从文件系统运行时一样读取和访问类路径资源中的任何内容。唯一不能做的是修改类路径资源的内
    容（至少不是通过一些神秘的魔法）。
- en: Back to Clojure namespaces
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到Clojure的命名空间
- en: 'Now that we have had our little review of how packages and the classpaths work
    in Java, it''s time to go back to Clojure. You should understand that Clojure
    attempts to make the hosting platform transparent; this means a couple of very
    important things:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要回顾了Java中包和类路径的工作方式，是时候回到Clojure了。你应该明白，Clojure试图使托管平台透明；这意味着几件非常重要的事情：
- en: Anything that you can do with the classpath from Java, you can also do with
    Clojure (you can read configuration files, images, etc).
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以用Java的类路径做的任何事情，你同样可以用Clojure来做（你可以读取配置文件、图片等）。
- en: Namespaces use the classpath just as Java does with packages, which makes them
    easy to understand. Nevertheless, don't underestimate them, Clojure namespace
    declarations can be more involved.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间使用类路径的方式与Java使用包的方式相同，这使得它们容易理解。尽管如此，不要低估它们，Clojure的命名空间声明可能更加复杂。
- en: Let's get practical and play a little with namespaces.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际操作一下，玩一玩命名空间。
- en: Playing with namespaces
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩转命名空间
- en: 'Lets create a new Playground, in order to create it use the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Playground，为了创建它，请使用以下命令：
- en: '[PRE22]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can open this project with IntelliJ, as we did in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Clojure"), *Getting Started with Clojure*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用IntelliJ打开这个项目，就像我们在[第1章](ch01.html "第1章。Clojure入门")中做的那样，*Clojure入门*。
- en: 'Let''s look in detail at what was created for us:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看为我们创建的内容：
- en: '![Playing with namespaces](img/4289_02_03.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![玩转命名空间](img/4289_02_03.jpg)'
- en: 'This project structure looks similar to Java projects, we have:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目结构看起来与Java项目类似，我们有：
- en: '`resources`: These are the non-source files that get added to the classpath'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`: 这些是非源文件，它们被添加到类路径中'
- en: '`src`: Our source code'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`: 我们的源代码'
- en: '`test`: Our testing code'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`: 我们的测试代码'
- en: 'The code inside `src` and `test` is already structured into namespaces: by
    having a quick look, we could say that the name of the namespace is `ns_playground`.
    Let''s check the source code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 和 `test` 中的代码已经结构化为命名空间：通过快速查看，我们可以说命名空间的名称是 `ns_playground`。让我们检查源代码：'
- en: '[PRE23]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`:gen-class` was added here in order to create a Java class and allow the Java
    interpreter to start a static main method. It is not needed if you don''t intend
    to create a standalone program.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`:gen-class` 被添加在这里是为了创建一个Java类，并允许Java解释器启动静态main方法。如果你不打算创建一个独立程序，则不需要它。'
- en: We can see that the (`ns ns-playground.core`) form has been used at the top,
    as you might have guessed, this is how we declare a namespace in Clojure.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在顶部使用了 (`ns ns-playground.core`) 这种形式，正如你可能猜到的，这就是在Clojure中声明命名空间的方式。
- en: If you are observant, you will notice something odd; the namespace has a dash
    instead of an underscore like the folder.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够细心，你会注意到一些奇怪的地方；命名空间有一个破折号，而不是像文件夹那样的下划线。
- en: 'There are some reasons that lead to this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些原因导致了这种情况：
- en: Clojure like most lisp variable names can have dashes in it (it is actually
    the preferred style to name the variables, as opposed to camel case in Java).
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure像大多数Lisp变量名一样，可以包含破折号（实际上，这是命名变量的首选风格，与Java中的驼峰式命名相反）。
- en: Every namespace in Clojure is represented as a package containing several Java
    classes. The namespace is used as a name of the Java package and as you know,
    the dash is not acceptable in class or package names; so every filename and folder
    name must have low dashes.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure中的每个命名空间都表示为一个包含多个Java类的包。命名空间用作Java包的名称，正如你所知，破折号在类或包名称中是不被接受的；因此，每个文件名和文件夹名都必须使用短破折号。
- en: Tip
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Due to the nature of Lisp, you can use dashes in variable names (they will get
    converted to underscores at compile time). In fact, this is the recommended way
    to name your variables. In Clojure, (and most Lisps) `some-variable-name` is a
    more idiomatic style than `someVariableName`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lisp的特性，你可以在变量名中使用破折号（它们将在编译时转换为下划线）。实际上，这是命名变量的推荐方式。在Clojure中（以及大多数Lisp），`some-variable-name`
    比 `someVariableName` 更符合习惯用法。
- en: Creating a new namespace
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的命名空间
- en: Let's create a new namespace; in Cursive Clojure it is easy to do so, just right-click
    on the `ns_playground` package and go to **New** | **Clojure Namespace**, it asks
    for a name and we can call it `hello`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的命名空间；在Cursive Clojure中，这样做很容易，只需右键点击`ns_playground`包，然后转到**新建** | **Clojure命名空间**，它会要求你输入一个名称，我们可以将其命名为`hello`。
- en: 'This creates a `hello.clj` file with the following contents:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含以下内容的`hello.clj`文件：
- en: '[PRE24]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, namespace creation is quite easy; you can do it by hand with
    two simple steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命名空间创建相当简单；你可以通过两个简单的步骤手动完成：
- en: Create a new file; it doesn't have to follow the package naming specification,
    but it helps to maintain your code order and it is a de facto practice.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件；它不必遵循包命名规范，但这有助于保持你的代码顺序，并且是一种事实上的做法。
- en: Add your namespace declaration.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加你的命名空间声明。
- en: That's it! It is true, even though a namespace definition can become quite complex,
    as it is the place where you define the Java packages that you wish to import,
    namespaces or functions from those namespaces that you intend to use. But you
    will normally just use a subset of those capabilities.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！虽然命名空间定义可能会变得相当复杂，因为它是你定义你希望导入的Java包、命名空间或你打算使用的这些命名空间中的函数的地方。但通常你只会使用这些功能的一个子集。
- en: Tip
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind that a namespace in Clojure is normally represented by a single
    file.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Clojure中的命名空间通常由一个单独的文件表示。
- en: 'For your initial namespaces, I will advice you to have two of those capabilities
    in mind:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的初始命名空间，我建议你考虑以下两种能力：
- en: '| `:import` | Allows you to import the Java classes from a package that you
    wish to use |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `:import` | 允许你从你希望使用的包中导入Java类 |'
- en: '| `:require` | Allows you to bring in whatever Clojure namespace that you wish
    to use |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `:require` | 允许你引入你希望使用的任何Clojure命名空间 |'
- en: The syntax of both `require` and the `import` is simple, let's look at a couple
    of examples before we actually use it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`和`import`的语法都很简单，在我们实际使用它们之前，让我们看看几个例子。'
- en: 'Let''s start with the `import` option:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`import`选项开始：
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You'll notice that this is similar to what you can do in Java, we are importing
    the `List` interface here.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这和你在Java中能做的是相似的，我们在这里导入的是`List`接口。
- en: 'The good thing with Clojure is that it allows you to do some more specific
    things. Let''s check how to import two classes at once:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure的好之处在于它允许你做一些更具体的事情。让我们看看如何一次性导入两个类：
- en: '[PRE26]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can extend this to the number of classes you want to use.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个扩展到你想要使用的类的数量。
- en: 'The `require` option uses a similar syntax and then builds some more on it.
    Let''s check requiring a single function from a namespace:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`选项使用类似的语法，并在其基础上构建更多。让我们检查从一个命名空间中引入单个函数：'
- en: '[PRE27]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see, it is familiar and the interesting part is when you start importing
    everything:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是熟悉的，有趣的部分在于当你开始导入所有内容时：
- en: '[PRE28]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also use a custom name for everything inside your package:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为你的包内的所有内容使用自定义名称：
- en: '[PRE29]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or you could even combine different keywords:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你甚至可以组合不同的关键字：
- en: '[PRE30]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s try a bit of what we just learned, using the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下我们刚刚学到的东西，使用以下代码：
- en: '[PRE31]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You must have noticed the `&` operator in the arguments of the `<3` and `sum-something`
    functions; this allows those functions to receive any number of arguments and
    we can call them, as shown: (`sum-something 1 2 3 4 5 6 7 8`) or (`sum-something`)
    They are called **variadic** functions. In Java you will call this feature **varargs**.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须已经注意到了`<3`和`sum-something`函数的参数中的`&`运算符；这允许这些函数接收任意数量的参数，我们可以像这样调用它们：（`sum-something
    1 2 3 4 5 6 7 8`）或（`sum-something`）。它们被称为**可变参数**函数。在Java中，你会把这个特性称为**varargs**。
- en: Everything looks great, but we haven't yet seen how to require and use these
    functions from some other package. Let's write a test to see how this will be
    done.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很不错，但我们还没有看到如何从其他包中引入和使用这些函数。让我们写一个测试来看看这是如何完成的。
- en: Working with namespaces on the REPL
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在REPL上使用命名空间
- en: A great way of playing with namespaces is by using the REPL and we'll also get
    the benefit of getting to know it better.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用REPL来玩转命名空间是一个很好的方法，我们也会从中获得更好地了解它的好处。
- en: 'Since we are going to play with namespace, we need to know of a few functions
    that will help us move between namespaces and require other namespaces. The functions
    are listed as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要玩转命名空间，我们需要了解一些函数，这些函数将帮助我们在不同命名空间之间移动并引入其他命名空间。函数如下所示：
- en: '| Function | Description | Sample usage |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 | 示例用法 |'
- en: '| --- | --- | --- |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `in-ns` | Sets `*ns*` to the namespace named by the symbol, creating it if
    needed. | (`in-ns ''ns-playground.core`) |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `in-ns` | 将`*ns*`设置为名为符号的命名空间，如果需要则创建它。 | (`in-ns ''ns-playground.core`)
    |'
- en: '| `require` | Loads `libs`, skipping any that are already loaded. | (`require
    ''[clojure.java.io :as io]`) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `require` | 加载`libs`，跳过任何已加载的。 | (`require ''[clojure.java.io :as io]`) |'
- en: '| `import` | For each name in `class-name-symbols`, adds a mapping from name
    to the class named by `package.name` to the current namespace. | (`import java.util.Date`)
    |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `import` | 对于`class-name-symbols`中的每个名称，将名称到由`package.name`命名的类的映射添加到当前命名空间。
    | (`import java.util.Date`) |'
- en: '| `refer` | refers to all public `vars` of `ns`, subject to filters. | (`refer
    ''clojure.string :only ''[capitalize trim]`) |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `refer` | 指向`ns`的所有公共`vars`，受过滤器约束。 | (`refer ''clojure.string :only ''[capitalize
    trim]`) |'
- en: 'Let''s go into the REPL window of our IntelliJ. We can check what namespace
    we are in with the `*ns*` instruction. Let''s try now:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入我们的IntelliJ的REPL窗口。我们可以使用`*ns*`指令检查我们所在的命名空间。现在让我们试试：
- en: '[PRE32]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Imagine that we need to execute a code and test the code from within the `ns-playground.hello`
    namespace, we can do that with the `in-ns` function:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要在`ns-playground.hello`命名空间内执行代码并测试代码，我们可以使用`in-ns`函数来完成：
- en: '[PRE33]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We want to know what `str` does, it seems to receive three strings:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道`str`做了什么，它似乎接收了三个字符串：
- en: '[PRE34]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s try the `for` form now:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试一下`for`形式：
- en: '[PRE35]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `for` macro takes a collection of items and returns a new lazy sequence
    applying the body of the `for` to each element.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`宏接受一个项目集合，并返回一个新的惰性序列，将`for`的主体应用于每个元素。'
- en: 'Knowing this, understanding the `<3` function is easy, let''s try it:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，理解`<3`函数很容易，让我们试试：
- en: '[PRE36]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've used the REPL to test some simple functions, but let's now try to test
    something else like reading a properties file from the classpath.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用REPL测试了一些简单的函数，但现在让我们尝试测试其他一些东西，比如从类路径中读取属性文件。
- en: 'We can add a `test.properties` file to the resources folder with the following
    contents:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在资源文件夹中添加一个`test.properties`文件，内容如下：
- en: '[PRE37]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Remember to restart the REPL, as the changes to the contents that some piece
    of the classpath points to are not visible to a running REPL.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要重启REPL，因为类路径中某些部分内容的变化对正在运行的REPL是不可见的。
- en: 'Let''s try reading our properties file as an input stream, we can use the `clojure.java.io`
    namespace to do it, and we can check it as shown:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以输入流的形式读取我们的属性文件，我们可以使用`clojure.java.io`命名空间来完成它，并且我们可以像下面这样进行检查：
- en: '[PRE38]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now define our function for reading properties, we can input this into
    the REPL:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义我们的读取属性函数，我们可以将其输入到REPL中：
- en: '[PRE39]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `let` form lets us create local 'variables', instead of using the (`io/resource
    path`) directly in the code. We can create a reference once and use it through
    the code. It allows us to use simpler code and to have a single reference to an
    object.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`形式允许我们创建局部''变量''，而不是直接在代码中使用(`io/resource path`)。我们可以创建一个引用一次并在代码中使用它。它允许我们使用更简单的代码，并且对对象有一个单一的引用。'
- en: 'In the end, we can redefine the `hello` namespace to include everything we''ve
    checked, such as this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以重新定义`hello`命名空间以包含我们检查的所有内容，例如：
- en: '[PRE40]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Remember to include the `Properties` class in the `import` and to define the
    `:require` keyword for `clojure.java.io`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 记住要在`import`中包含`Properties`类，并为`clojure.java.io`定义`:require`关键字。
- en: Testing in Clojure
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure中的测试
- en: Clojure already comes with a unit testing support built-in, as a matter of fact
    Leiningen has already created a test for us; let's take a look at it right now.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure已经内置了单元测试支持，实际上Leiningen已经为我们创建了一个测试；让我们现在看看它。
- en: 'Open the `test/ns_playground/core_test.clj` file, you should be able to see
    this code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`test/ns_playground/core_test.clj`文件，你应该能看到以下代码：
- en: '[PRE41]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Again, as you can see, we are using `:require` to include functions from the
    `clojure.test` and the `ns-playground.core` packages.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，正如你所看到的，我们正在使用`:require`来包含`clojure.test`和`ns-playground.core`包中的函数。
- en: Note
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, the `:refer :all` works similar to how `char import static clojure.test.*`
    will work in Java.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`:refer :all`的工作方式与Java中的`char import static clojure.test.*`类似。
- en: Testing from the command line
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行测试
- en: 'Let''s first learn how to run these tests. From the command line, you can run:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先学习如何运行这些测试。从命令行，你可以运行：
- en: '[PRE42]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should get the following output:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE43]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We see that there is one test failing, we will go back to this in a bit; for
    now, let's see how to test in IntelliJ.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到有一个测试失败，我们稍后会回到这个问题；现在，让我们看看如何在IntelliJ中测试。
- en: Testing in IntelliJ
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IntelliJ中的测试
- en: 'First of all, we need a new REPL configuration. You can do it as you learned
    in the previous chapter. You just need to follow the following steps:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个新的 REPL 配置。您可以像在上一章中学到的那样做。您只需要遵循以下步骤：
- en: Right click on the `project.clj` file and select **Create REPL for ns-playground,**
    as shown in the following screenshot:![Testing in IntelliJ](img/4289_02_01.jpg)
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `project.clj` 文件并选择 **为 ns-playground 创建 REPL**，如图所示：![IntelliJ 中的测试](img/4289_02_01.jpg)
- en: Then click on **OK** in the next dialog.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在下一个对话框中点击 **确定**。
- en: After that, you should run the REPL again by right clicking the `project.clj`
    file and selecting **Run REPL for ns-playground**.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您应该通过右键单击 `project.clj` 文件并选择 **为 ns-playground 运行 REPL** 来再次运行 REPL。
- en: After that you can run any tests, just open your test file and go to **Tools**
    | **Run Tests** in the current NS in REPL. You should see something similar to
    the following screenshot:![Testing in IntelliJ](img/4289_02_02.jpg)
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您可以运行任何测试，只需打开您的测试文件，然后在 REPL 中的当前 NS 中选择 **工具** | **运行测试**。您应该会看到以下截图类似的内容：![IntelliJ
    中的测试](img/4289_02_02.jpg)
- en: As you can see, it signals that your test is currently failing. Let's fix it
    and run our test again. Change the `(is (= 0 1))` line to `(is (= 1 1))`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，它表示您的测试目前正在失败。让我们修复它并再次运行我们的测试。将 `(is (= 0 1))` 行更改为 `(is (= 1 1))`。
- en: 'Now, let''s try some real tests for our previously defined functions; don''t
    worry if you can''t understand all the code for now, you are not supposed to:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试对我们之前定义的函数进行一些实际的测试；如果您现在不能理解所有代码，请不要担心，您不需要这样做：
- en: '[PRE44]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can't use the Clojure contents function here because it has a different function.
    It looks for keys in a map.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在这里使用 Clojure 的内容函数，因为它具有不同的功能。它会在映射中查找键。
- en: 'Run the tests and you''ll see that everything passes correctly but there''s
    a lot going on over here, let''s go over it little by little:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，您会看到所有内容都正确通过，但这里发生了很多事情，让我们一点一点地过一遍：
- en: '[PRE45]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is the namespace declaration, let''s list everything it does:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命名空间声明，让我们列出它所做的一切：
- en: It declares the `ns-playground.core-test` package.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它声明了 `ns-playground.core-test` 包。
- en: It imports the `java.util.Date` class.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导入了 `java.util.Date` 类。
- en: It makes everything in the `clojure.test` namespace available in the current
    namespace, if we were in Java we might have used `import static clojure.test.*`
    to get a similar effect. We can achieve this with the `:refer :all` keywords.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得 `clojure.test` 命名空间中的所有内容在当前命名空间中可用，如果我们处于 Java 中，我们可能会使用 `import static
    clojure.test.*` 来获得类似的效果。我们可以通过使用 `:refer :all` 关键字来实现这一点。
- en: It makes everything in the `ns-playground.hello` namespace available with the
    hello shortcut but we need to prefix every function or value defined in `ns-playground.hello`
    with hello and it also makes the `<3` function available without a prefix. To
    generate an alias and make everything available with the `hello` alias, we use
    the `:as` keyword and then pass a vector to `:refer` to include certain elements.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得 `ns-playground.hello` 命名空间中的所有内容都可以通过 hello 快捷方式访问，但我们需要在 `ns-playground.hello`
    中定义的每个函数或值前加上 hello 前缀，并且它还使得 `<3` 函数可以在没有前缀的情况下使用。为了生成别名并使所有内容都可以通过 `hello` 别名访问，我们使用
    `:as` 关键字，然后传递一个向量给 `:refer` 以包含某些元素。
- en: It makes everything in the `ns-playground.core` namespace available in the current
    namespace. We achieve this with the `:refer :all` keywords.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得 `ns-playground.core` 命名空间中的所有内容在当前命名空间中可用。我们通过使用 `:refer :all` 关键字来实现这一点。
- en: '[PRE46]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is the declaration of a function called `lazy-contains?`, it is a `boolean`
    function and it is customary in Clojure to call it a predicate.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这是名为 `lazy-contains?` 的函数的声明，它是一个 `boolean` 函数，在 Clojure 中通常将其称为谓词。
- en: Note
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name of the function including the question mark might be something that
    looks awkward to you. In Clojure and Lisp, you can use question marks in the names
    of functions and it is common to do it for functions that return Booleans.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 包含问号的函数名称可能对您来说看起来有些不自然。在 Clojure 和 Lisp 中，您可以在函数名称中使用问号，并且对于返回布尔值的函数来说，这样做是常见的。
- en: 'It receives two parameters: `col` and `element`.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收两个参数：`col` 和 `element`。
- en: 'The actual body of the function looks a bit complicated but it is actually
    very simple. Whenever you encounter a function that looks similar to the one mentioned
    in the preceding section, try to read it from the inside out. The innermost part
    is, as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的实际主体看起来有点复杂，但实际上非常简单。每次您遇到一个看起来与上一节中提到的类似的函数时，请尝试从内向外阅读它。最内层部分如下：
- en: '[PRE47]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is a shorter way of writing an anonymous function which has a single parameter.
    If we want to write another function that compares its argument against the `element`,
    without the syntactic sugar, we can do it in the following method:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编写只有一个参数的匿名函数的简短方式。如果我们想写另一个函数，该函数将其参数与`element`比较，而不使用语法糖，我们可以用以下方法实现：
- en: '[PRE48]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is an anonymous function or in other words it is a function that has no
    name, but it works as every other function; we will read more about anonymous
    functions when we get back to functional programming.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个匿名函数，换句话说，它是一个没有名字的函数，但它像其他任何函数一样工作；当我们回到函数式编程时，我们将了解更多关于匿名函数的内容。
- en: 'Our anonymous function is a parameter to the following form:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的匿名函数是以下形式的参数：
- en: '[PRE49]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This new form filters the collection `col` and returns a new collection with
    only the elements that pass the test. Let''s see an example where we have used
    the predefined Clojure function `even?`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新形式过滤了集合`col`，并返回一个只包含通过测试的元素的新集合。让我们看看我们使用了预定义的Clojure函数`even?`的例子：
- en: '[PRE50]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our filter function now returns every element in the collection that passes
    the `#(= element %)`test. So we get every element that is equal to the element
    passed to `lazy-contains?`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的过滤器函数返回集合中通过`#(= element %)`测试的每个元素。因此，我们得到与传递给`lazy-contains?`的元素相等的每个元素。
- en: 'We then ask if none of the elements equal to `element` in `col` with the following
    form:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着询问是否没有任何元素等于`col`中的`element`，其形式如下：
- en: '[PRE51]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But we want to know if there is some element equal to element, so at last we
    negate the previous form:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们想知道是否有某个元素等于`element`，所以最后我们否定前面的形式：
- en: '[PRE52]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Imagine that if you had to write this in Java (and I asked to add every element
    that matches the element to a list), you will have something similar to this:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你必须用Java编写这个（并且我要求将匹配元素的每个元素添加到列表中），你将得到类似的东西：
- en: '[PRE53]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There is a big difference, it is more verbose and to understand it we need to
    "run" the algorithm in our heads. This is called imperative programming, Clojure
    allows us to do imperative programming as well as functional programming, which
    is a type of declarative programming. When you get used to it, you'll see that
    it's easier to reason about than loops.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个很大的区别，它更冗长，要理解它我们需要在脑海中“运行”算法。这被称为命令式编程，Clojure允许我们进行命令式编程以及函数式编程，这是一种声明式编程。当你习惯了，你会发现它比循环更容易推理。
- en: Note
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interactive programming means, telling every step of how something should be
    done to a computer. Declarative programming just asks for a result and doesn't
    give details of how to achieve it.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式编程意味着向计算机描述每一步应该如何执行。声明式编程只是要求一个结果，而不提供如何实现它的细节。
- en: 'The actual tests are simple to understand:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 实际测试很简单理解：
- en: '[PRE54]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This test checks the current date returns an instance of `java.util.Date`,
    the `is` form works as the Java assert instruction:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试检查当前日期返回一个`java.util.Date`实例，`is`形式像Java断言指令一样工作：
- en: '[PRE55]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This test checks the `<3` function, it checks that the returned collection contains
    `I love Clojure`, `I love doggies`, `I love chocolate` and `I love you` and it
    should not contain `I love Vogons`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试检查`<3`函数，它检查返回的集合包含`I love Clojure`、`I love doggies`、`I love chocolate`和`I
    love you`，并且不应该包含`I love Vogons`。
- en: This test is simple to understand. What might be not so simple to understand
    is the `<3` function, we'll look into it with the REPL.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试很容易理解。可能不太容易理解的是`<3`函数，我们将使用REPL来探讨它。
- en: Summary
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we got to know some utilities that we can use for better management
    of our code and we have some more examples of everyday Clojure code. In particular:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们了解了一些我们可以用来更好地管理我们的代码的实用工具，并且有一些Clojure日常代码的更多示例。特别是：
- en: Working of namespace in Clojure and their relation to Java packages
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure命名空间的工作原理及其与Java包的关系
- en: Writing out-of-the-box unit tests and executing them with Leiningen and Cursive
    Clojure
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Leiningen和Cursive Clojure编写和执行离线单元测试
- en: Delving into the Clojure Interactive development workflow and a bit of the Clojure
    mindset
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入Clojure交互式开发工作流程和一点Clojure思维模式
- en: Writing very simple functions and testing them
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写非常简单的函数并测试它们
- en: In the next chapter, we will learn about Java interop, so we can start using
    the familiar classes and libraries we already know in our Clojure code.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Java互操作性，这样我们就可以开始在Clojure代码中使用我们已知的熟悉类和库。
- en: We will also learn how to use Clojure from Java, so you can start using it in
    your everyday Java projects.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何从Java中使用Clojure，这样你就可以开始在日常Java项目中使用它。
- en: Chapter 3. Interacting with Java
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。与Java交互
- en: We know a bit about how to organize our code and how that relates to packages
    in Java. Now, you surely need to use your old Java code and all the libraries
    you already know; Clojure encourages a new way to think about programming and
    it also allows you to use all the dependencies and code that you've already generated.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对如何组织代码以及它与Java中的包的关系有一些了解。现在，你当然需要使用你已有的旧Java代码和所有已知的库；Clojure鼓励一种新的编程思考方式，它还允许你使用所有已经生成的依赖和代码。
- en: Clojure is a **Java Virtual Machine** (**JVM**) language and as such it is compatible
    with most Java dependencies and libraries out there; you should be able to use
    all the tools out there. You should also be able to use your Clojure programs
    with Java-only programs, this requires a bit of custom coding but in the end you
    can use Clojure in the right places of your project.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure是一种**Java虚拟机**（**JVM**）语言，因此它与大多数Java依赖项和库兼容；你应该能够使用所有工具。你也应该能够使用Java-only程序与Clojure程序一起使用，这需要一些自定义编码，但最终你可以在项目的正确位置使用Clojure。
- en: 'To be able to do this, we''ll have to learn:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够做到这一点，我们得学习：
- en: Using Maven dependencies
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven依赖项
- en: Using plain old Java classes from your Clojure code base
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Clojure代码库中使用普通的Java类
- en: A bit more about the Clojure language, in particular the `let` statements and
    destructuring
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Clojure语言的一些更多信息，特别是`let`语句和解构
- en: Creating a Java interface for your Clojure code
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的Clojure代码创建Java接口
- en: Using the Java interface from other Java projects
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他Java项目中使用Java接口
- en: Using Maven dependencies
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven依赖项
- en: Let's say that we want to write an image manipulation program; it is a very
    simple program that should be able to create thumbnails. Most of our codebase
    is in Clojure, so we want to write this in Clojure too.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个图像处理程序；这是一个非常简单的程序，应该能够创建缩略图。我们的代码库大部分是用Clojure编写的，所以我们希望也在Clojure中编写这个程序。
- en: There are a bunch of Java libraries meant to manipulate images, we decide to
    use imgscalr, which is very simple to use and it looks like it is available in
    Maven Central ([http://search.maven.org/](http://search.maven.org/)).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多Java库旨在处理图像，我们决定使用imgscalr，它非常易于使用，看起来它也存在于Maven Central ([http://search.maven.org/](http://search.maven.org/))。
- en: 'Let''s create a new Leiningen project, as shown:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Leiningen项目，如下所示：
- en: '[PRE56]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we need to edit the `project.clj` file in the thumbnails project:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编辑缩略图项目的`project.clj`文件：
- en: '[PRE57]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can add the `imgscalr` dependency similar to the following code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加类似于以下代码的`imgscalr`依赖项：
- en: '[PRE58]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you can see, you just need to add a dependency to the `:dependencies` vector,
    the dependencies are automatically resolved from:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你只需要将依赖项添加到`:dependencies`向量中，依赖项会自动从以下位置解析：
- en: Maven Local
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven Local
- en: Maven Central
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven Central
- en: Clojars
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojars
- en: Note
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Maven Local points to your local maven repository that is in the `~/.m2`
    folder. If you wish, you can change it with Leiningen's `:local-repo` key.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Maven Local指向你的本地Maven仓库，该仓库位于`~/.m2`文件夹中。如果你愿意，你可以使用Leiningen的`:local-repo`键来更改它。
- en: 'You can add your own repositories, let''s say you need to add **jcenter** (Bintray''s
    Java repository) you can do so, as shown:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加自己的仓库，比如说你需要添加**jcenter**（Bintray的Java仓库），你可以这样做，如下所示：
- en: '[PRE59]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Leiningen supports a wide array of options to configure your project, for more
    information you can check the sample at Leiningen''s official repository: [https://github.com/technomancy/leiningen/blob/master/sample.project.clj](https://github.com/technomancy/leiningen/blob/master/sample.project.clj).'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Leiningen支持一系列选项来配置你的项目，更多详细信息，你可以查看Leiningen官方仓库中的示例：[https://github.com/technomancy/leiningen/blob/master/sample.project.clj](https://github.com/technomancy/leiningen/blob/master/sample.project.clj)。
- en: 'In order to download the dependencies, you have to execute the following code:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为了下载依赖项，你必须执行以下代码：
- en: '[PRE60]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Tip
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You don't need to execute `lein deps` every time you want to download dependencies,
    you can do it to force a download but Leiningen will automatically download them
    when it needs to.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要每次想要下载依赖项时都执行`lein deps`，你可以这样做来强制下载，但Leiningen会在需要时自动下载它们。
- en: 'You can check the current dependencies by running:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来检查当前的依赖项：
- en: '[PRE61]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You will get something similar to this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到类似以下的内容：
- en: '[PRE62]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This lists your current dependency tree.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这列出了你的当前依赖树。
- en: Clojure interop syntax
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure互操作语法
- en: Clojure was designed to be a Hosted Language, which means that it can run in
    different environments or runtimes. One important philosophy aspect is that Clojure
    does not attempt to get in the way of your original host; this allows you to use
    your knowledge of the underlying platform to your advantage.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure被设计成一种托管语言，这意味着它可以在不同的环境或运行时中运行。一个重要的哲学方面是Clojure不会试图阻碍你的原始宿主；这允许你利用你对底层平台的了解来获得优势。
- en: In this case, we are using the Java platform. Let's look at the basic interrupt
    syntax that we need to know.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在使用Java平台。让我们看看我们需要了解的基本中断语法。
- en: Creating an object
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象
- en: There are two ways to create an object in Clojure; for example, let's have a
    look at how to create an instance of `java.util.ArrayList`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中创建对象有两种方式；例如，让我们看看如何创建`java.util.ArrayList`的一个实例。
- en: '[PRE63]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, we are using the `new` special form, as you can see it receives a symbol
    (the name of the class `java.util.ArrayList`) and in this case it is an integer.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`new`特殊形式，正如你所见，它接收一个符号（类的名称`java.util.ArrayList`）并且在这种情况下它是一个整数。
- en: The symbol `java.util.ArrayList` represents the `classname` and any Java class
    name will do here.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 符号`java.util.ArrayList`代表`classname`，任何Java类名都可以在这里使用。
- en: Next, you can actually pass any number of parameters (including `0` parameters).
    The next parameters are the parameters of the constructor.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以传递任意数量的参数（包括`0`个参数）。下一个参数是构造函数的参数。
- en: 'Lets have a look at the other special syntax that is available to create objects:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可用于创建对象的另一种特殊语法：
- en: '[PRE64]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The difference here is that we have a trailing dot; we prefer to see this syntax
    since it is shorter.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于我们有一个尾随的点；我们更喜欢看到这种语法，因为它更短。
- en: Calling an instance method
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用实例方法
- en: Once we have created our object we can call instance methods. This is done similar
    to how we call Clojure functions, using the special dot form.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了对象，我们就可以调用实例方法。这类似于我们调用Clojure函数的方式，使用特殊的点形式。
- en: 'If we want to add an element to our newly created list, we will have to do
    it, as shown:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在新建的列表中添加一个元素，我们必须这样做，如下所示：
- en: '[PRE65]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This syntax might look a little strange; here is how this syntax is formed:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法可能看起来有点奇怪；以下是这种语法是如何形成的：
- en: '[PRE66]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Similar to the two different options that we had when creating an object, we
    have another way to do this:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建对象时我们拥有的两种不同选项类似，我们还有另一种方法来做这件事：
- en: '[PRE67]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You might think that this is more familiar, since the method name starting with
    a dot resembles how we write the Java method calls.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这更熟悉，因为以点开头的方法名类似于我们编写Java方法调用的方式。
- en: Calling a static method or function
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用静态方法或函数
- en: Being able to call methods and create objects gives us a great deal of power,
    with this simple construct we have gained a lot of power; we can now use most
    of the Java standard libraries and also the custom ones.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 能够调用方法和创建对象给我们带来了巨大的力量，通过这个简单的结构，我们获得了大量的力量；现在我们可以使用大多数Java标准库以及自定义库。
- en: However, we still need a few more things; one of the most important ones is
    calling static methods. The static methods have a feel similar to Clojure functions,
    there is no `this` instance, you can simply call them as normal Clojure functions.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要一些其他的东西；其中最重要的一项是调用静态方法。静态方法的感觉类似于Clojure函数，没有`this`实例，你可以像调用正常的Clojure函数一样调用它们。
- en: 'For instance, if we want an `emptyMap` from the `Collections` class, we can
    do it as shown:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想从`Collections`类中获取一个`emptyMap`，我们可以这样做，如下所示：
- en: '[PRE68]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You can think of static methods as functions and the class as a namespace. It
    is not exactly right but the mental model will help you understand it easily.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将静态方法视为函数，将类视为命名空间。这并不完全正确，但这个心理模型将帮助你轻松理解它。
- en: Accessing inner classes
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问内部类
- en: Another common doubt when using Java – Clojure interop is how to access inner
    classes.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Java-Clojure互操作时，另一个常见的疑问是如何访问内部类。
- en: Imagine you want to represent a single entry from a map with the `java.util.AbstractMap.SimpleEntry`
    class.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想使用`java.util.AbstractMap.SimpleEntry`类来表示映射中的一个条目。
- en: 'You might think that we have to do something similar to this:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为我们必须做一些类似这样的事情：
- en: '[PRE69]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'That''s what you will normally do when writing Java, but in Clojure you might
    need to do something such as this:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你通常在编写Java时所做的，但在Clojure中，你可能需要做一些类似这样的事情：
- en: '[PRE70]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'What we are seeing here is actually an exposed implementation detail; if you
    look at the classes in the JAR files or in your classpath, you will see the precise
    file name `AbstractMap$SimpleEntry`, as shown in the following screenshot:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是实际上是一个暴露的实现细节；如果你查看JAR文件中的类或你的类路径中的类，你会看到精确的文件名`AbstractMap$SimpleEntry`，如下面的截图所示：
- en: '![Accessing inner classes](img/B04289_03_01.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![访问内部类](img/B04289_03_01.jpg)'
- en: This is what you need to keep in mind, always prefix the inner classes with
    the parent (or more correctly containing) class (in this case `java.util.AbstractMap`)
    and the dollar sign.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要记住的，总是用父类（或更准确地说，包含类）的前缀和美元符号来前缀内部类（在这种情况下为`java.util.AbstractMap`）。
- en: Writing a simple image namespace
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写简单的图像命名空间
- en: Let's now write some Clojure code and create a file in `src/thumbnails/image.clj`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些Clojure代码并在`src/thumbnails/image.clj`中创建一个文件。
- en: 'Let''s try to do this the Clojure way. First of all, write the namespace declaration
    and evaluate it:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用Clojure的方式来做这件事。首先，写下命名空间声明并评估它：
- en: '[PRE71]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now open up a REPL and write the following code:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开一个REPL并编写以下代码：
- en: '[PRE72]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We now have an image instance and you can call all of the Java methods in the
    REPL. This is one of Clojure''s core concepts, you can play with the REPL and
    check your code before really writing it and you can do it in an interactive way,
    as shown:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个图像实例，你可以在REPL中调用所有的Java方法。这是Clojure的核心概念之一，你可以在真正编写代码之前通过REPL来玩耍并检查你的代码，你可以以交互式的方式进行，如下所示：
- en: '![Writing a simple image namespace](img/B04289_03_02.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![编写简单的图像命名空间](img/B04289_03_02.jpg)'
- en: 'In the end, we want to stickwith the following contents:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望坚持以下内容：
- en: '[PRE73]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Tip
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can see that in this code we use the inner class syntax, with `Scalr$Mode`.
    Mode is not actually a class but an `enum`, you can use the same syntax for all
    other inner types.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在这段代码中，我们使用了内部类语法，`Scalr$Mode`。`Mode`实际上不是一个类，而是一个`enum`，你可以为所有其他内部类型使用相同的语法。
- en: The code is pretty simple, it is very similar to what you've already seen; we'll
    go through the differences either way.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单，它与你已经看到的非常相似；我们将通过两种方式来探讨这些差异。
- en: 'You can import the following classes:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以导入以下类：
- en: '`javax.imageio.ImageIO`'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.imageio.ImageIO`'
- en: '`java.awt.image.BufferedImageOp`'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.image.BufferedImageOp`'
- en: '`org.imgscalr.Scalr`'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.imgscalr.Scalr`'
- en: '`org.imgscalr.Scalr.Mode`'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.imgscalr.Scalr.Mode`'
- en: You have to be careful with the `Mode` class, since it is an inner class (it
    is inside another class) Clojure uses the special name `Scalr$Mode`.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须小心处理`Mode`类，因为它是一个内部类（它位于另一个类中），Clojure使用特殊的名称`Scalr$Mode`。
- en: Tip
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'When importing inner classes, you have to be careful with the naming process,
    in Java you will use the name: `org.imgscalr.Scalr.Mode`; in Clojure you use the
    name: `org.imgscalr.Scalr$Mode`. The `load-image`, `save-image`, and `image-size`
    functions are self explanatory and the `generate-thumbnail` function is pretty
    simple as well; however, it has a special detail, it calls the following as the
    last argument:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入内部类时，你必须小心命名过程，在Java中，你将使用名称：`org.imgscalr.Scalr.Mode`；在Clojure中，你使用名称：`org.imgscalr.Scalr$Mode`。`load-image`、`save-image`和`image-size`函数是自我解释的，而`generate-thumbnail`函数也很简单；然而，它有一个特殊的细节，它将以下内容作为最后一个参数调用：
- en: '[PRE74]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If you look at the ImageScalr javadoc, ([http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html](http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html))
    you can see that the `resize` method has several overloaded implementations; most
    of them have a `varargs` argument as their last argument. In Clojure, you have
    to declare these `varargs` arguments as an array.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看ImageScalr javadoc（[http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html](http://javadox.com/org.imgscalr/imgscalr-lib/4.2/org/imgscalr/Scalr.Mode.html)），你可以看到`resize`方法有几个重载实现；其中大多数都有`varargs`参数作为它们的最后一个参数。在Clojure中，你必须将这些`varargs`参数声明为数组。
- en: Writing the tests
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: Now that you have written your image processing code, it is a good time to write
    the tests.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了图像处理代码，现在是编写测试的好时机。
- en: Let's just check if we can generate a thumbnail. Create a new `thumbnails.thumbnail-test`
    namespace, in the tests.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下是否可以生成缩略图。在测试中创建一个新的`thumbnails.thumbnail-test`命名空间。
- en: Remember, if you create the file, it must be named `test/thumbnails/thumbnail_test.clj`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你创建了文件，它必须命名为`test/thumbnails/thumbnail_test.clj`。
- en: 'Add the following contents to it:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 向其中添加以下内容：
- en: '[PRE75]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here we are using some unknown features, such as the `let` form and destructuring.
    We will see this in more detail in the next section.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一些未知的功能，例如`let`形式和结构化。我们将在下一节中更详细地了解这些内容。
- en: The let statement
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`let` 语句'
- en: Clojure gives us a `let` statement to name things; it allows us to do something
    very similar to variable declaration in other languages.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 给我们一个 `let` 语句来命名事物；它允许我们做类似于其他语言中变量声明的类似事情。
- en: 'Keep in mind that we are not actually creating a variable in the same sense,
    as in Java. In Java, whenever we declare a variable. We state that we want to
    reserve a certain amount of memory to store something in the later stages; it
    can be a value for primitives or a memory location for objects. What we do here
    is simply name a value. This is a local scope that is useful to write cleaner
    and easier to understand code. Lets have a look at how it works:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们实际上并没有以 Java 中相同的方式创建变量。在 Java 中，每次我们声明变量时，我们都会声明我们想要为后期存储某些内容保留一定量的内存；它可以是一个原始值的值或对象的内存位置。我们在这里所做的只是命名一个值。这是一个有用的局部作用域，可以编写更干净、更容易理解的代码。让我们看看它是如何工作的：
- en: '[PRE76]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This is the simplest `let` statement that we could write and it is exactly
    the same as just writing `42`. However, we can write something a little more complex,
    such as this:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们能写的最简单的 `let` 语句，它和直接写 `42` 完全一样。然而，我们可以写一些更复杂的，比如这个：
- en: '[PRE77]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It looks self explanatory; to value `42` and `y,` we are assigning the value
    of multiplying `42` by `42`. In the end, we print `x is 42 and y 1764`. It is
    important to note two things here:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很直观；为了给 `42` 和 `y` 赋值，我们正在将 `42` 乘以 `42` 的值赋给它们。最后，我们打印 `x is 42 and y 1764`。这里需要注意的是两件事：
- en: We can use a previously defined value in the `let` statement; for example, we
    use `x` when defining `y`.
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在 `let` 语句中使用之前定义的值；例如，我们在定义 `y` 时使用 `x`。
- en: The `let` statement creates a scope, we can't use `x` or `y` outside of our
    `let` statement.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let` 语句创建了一个作用域，我们无法在 `let` 语句之外使用 `x` 或 `y`。'
- en: 'The `let` statement can even be nested, we could do something similar to the
    following example:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 语句甚至可以嵌套，我们可以做类似于以下示例的事情：'
- en: '[PRE78]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: It is a bit more complicated, since we are opening an unneeded set of parentheses
    and also writing more code; however, it allows us to see how lexical scope works.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点复杂，因为我们打开了一个不必要的括号组，并且写了更多的代码；然而，它允许我们看到词法作用域是如何工作的。
- en: 'Lets have a look at another interesting example:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个有趣的例子：
- en: '[PRE79]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In here, we are masking the value of `x` with `41` and again these are not variables.
    We are not changing a memory region, we are merely creating a new scope with a
    new *X* value.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用 `41` 隐藏了 `x` 的值，而且这些不是变量。我们并没有改变内存区域，我们只是在新的 *X* 值上创建了一个新的作用域。
- en: 'Going back to our test, the `let` statement begins with the following code:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的测试，`let` 语句以以下代码开始：
- en: '[PRE80]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It is pretty clear to understand, but the next line might prove a bit more
    difficult:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很容易理解，但下一行可能有点困难：
- en: '[PRE81]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It looks pretty strange; we are assigning the value of (`image-size image`)
    to `[w _]` but `[w _]` is not a symbol name!
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当奇怪；我们将 (`image-size image`) 的值赋给 `[w _]`，但 `[w _]` 不是一个符号名！
- en: What is happening here is that we are using a mechanism called destructuring
    to take the result of (`image-size image`) apart and just use the piece of information
    that we are interested in, which in this case is the width of the image.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是，我们正在使用一个称为解构的机制来分解 (`image-size image`) 的结果，并只使用我们感兴趣的信息，在这种情况下是图像的宽度。
- en: 'Destructuring is one of the key features of Clojure, it can be used almost
    everywhere where symbol binding happens, such as:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是 Clojure 的一个关键特性，它几乎可以在符号绑定发生的任何地方使用，例如：
- en: Let expressions
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let` 表达式'
- en: Function parameter lists
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数列表
- en: Destructuring helps write more concise code but it might strike you as strange
    when you are not used to it. Let's talk about it in depth in the next section.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 解构有助于编写更简洁的代码，但如果你不习惯这样做，可能会觉得有点奇怪。让我们在下一节深入探讨这个问题。
- en: Destructuring in Clojure
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure 中的解构
- en: Destructuring is a feature in Clojure that is not common in other lisps; the
    idea is to allow you to write more concise code in scenarios where code doesn't
    really add value (for example, getting the first element from a list or the second
    parameter from a function) and concentrating only on what is important to you.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是 Clojure 中一个在其他 Lisp 语言中不常见的特性；其想法是允许你在代码实际上没有增加价值的情况下编写更简洁的代码（例如，从列表中获取第一个元素或从函数中获取第二个参数），并只关注对你重要的事情。
- en: 'In order to understand this better, let''s see an example of why destructuring
    can help you:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们看看解构如何帮助你的一个示例：
- en: '[PRE82]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: What's wrong with the previous code? Nothing really, but you need to start thinking
    about what is `v`, what the first value of `v` is, what the nth function does,
    and at what index `v` starts.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有什么问题？实际上没有什么问题，但你需要开始思考 `v` 是什么，`v` 的第一个值是什么，`nth` 函数做什么，以及 `v` 从哪个索引开始。
- en: 'Instead we can do this:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做：
- en: '[PRE83]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Once you are used to destructuring, you will see that you don't need to think
    about how to get the elements you need. In this case, we directly access the first,
    second, and third elements from our vector and use the first and third out of
    the three elements. With good naming it can become even easier.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你习惯了解构，你就会发现你不需要考虑如何获取你需要的元素。在这种情况下，我们直接从我们的向量中访问第一个、第二个和第三个元素，并使用这三个元素中的第一个和第三个。通过良好的命名，这可以变得更加简单。
- en: Lets now take a deep dive into what destructuring is.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在深入探讨解构是什么。
- en: 'There are two types of destructuring:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的解构：
- en: '**Sequential destructuring**: It allows us to take sequential data structures
    apart and bind the values that you are interested in directly to symbols'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按顺序解构**：它允许我们将顺序数据结构拆分，并将你感兴趣的值直接绑定到符号上'
- en: '**Associative destructuring**: It allows us to take maps apart and bind only
    the key reference values that you are interested in directly to symbols'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联解构**：它允许我们将映射拆分，并将你感兴趣的键引用值直接绑定到符号上'
- en: Sequential destructuring
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按顺序解构
- en: 'Sequential destructuring should be easy to understand with some examples; lets
    have a look:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些示例，按顺序解构应该很容易理解；让我们看看：
- en: '[PRE84]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In these examples, as convention, we use `f` for first, `s` for second, `t`
    for third, and `a` for all the others.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，按照惯例，我们用 `f` 表示第一个，`s` 表示第二个，`t` 表示第三个，而 `a` 表示其他所有。
- en: 'The same destructuring idea and syntax can be used with function parameters,
    as shown in the next example:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的解构思想和语法也可以用于函数参数，如下一个示例所示：
- en: '[PRE85]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here we use the symbol `_`, there is a convention in Clojure to use the `_`
    symbol whenever you are not interested in some value and you don't need to use
    it in the future. In the previous example, we aren't interested in the second
    parameter of the `func` function.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用符号 `_`，在 Clojure 中有一个惯例，即当你对某个值不感兴趣且未来不需要使用它时，可以使用 `_` 符号。在上一个示例中，我们对
    `func` 函数的第二个参数不感兴趣。
- en: As you can see, it lets us write a much more concise code and focus only on
    what's important, which is the algorithm or business.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它让我们能够编写更简洁的代码，只关注重要的部分，即算法或业务。
- en: Associative destructuring
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联解构
- en: We've already seen sequential destructuring that allows getting certain elements
    of a sequence by index. In Clojure, there is also associative destructuring, which
    allows you to take just the keys of the map in which you are interested.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了按顺序解构，它允许通过索引获取序列的某些元素。在 Clojure 中，还有关联解构，它允许你仅获取你感兴趣的映射中的键。
- en: 'Again, an example is worth more than a thousand words:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一个例子胜过千言万语：
- en: '[PRE86]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Tip
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Thinking of symbols as keys to a map can feel strange, nonetheless it is important
    to remember this feature; it could come in handy at some point.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 将符号视为映射的键可能感觉有些奇怪，但重要的是要记住这个特性；它可能在某个时候派上用场。
- en: 'As you can see, it''s pretty simple too, but we have a few more options:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这也很简单，但我们还有更多选项：
- en: We can reference some keys and assigning them a name, as shown in the first
    and second example
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以引用一些键并将它们分配一个名称，就像第一个和第二个示例中那样。
- en: We can reference keyword keys, as in the third example
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以引用关键字键，就像第三个示例中那样
- en: We can reference string keys, as in the fourth example
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以引用字符串键，就像第四个示例中那样。
- en: We can define default values with the `:or` keyword!
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `:or` 关键字定义默认值！
- en: Destructuring is one of the most used features of Clojure and it allows you
    to write very concise code.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是 Clojure 中最常用的特性之一，它允许你编写非常简洁的代码。
- en: 'Going back to our test code, it should now be pretty easy to understand the
    get-`image-width` function:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的测试代码，现在应该很容易理解 `get-image-width` 函数：
- en: '[PRE87]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As you can see, it sets the image value as the loaded image and then it calculates
    the width, gets the width only and returns that value.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它将图像值设置为加载的图像，然后计算宽度，只获取宽度并返回该值。
- en: 'We can now understand the `test-load-image` test:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以理解 `test-load-image` 测试：
- en: '[PRE88]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: It just initializes an `image-stream` value, it then loads an image from that
    stream and generates a thumbnail. It finally loads the generated thumbnail and
    checks that the image width is 50px.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是初始化一个`image-stream`值，然后从这个流中加载一个图像并生成缩略图。最后，它加载生成的缩略图并检查图像宽度为50px。
- en: Now that we've written our tests and we are sure that everything works, we can
    use our little library from the Clojure projects, but what happens if we want
    to use it from a pure Java (or groovy, or scala) project?
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了测试，并且我们确信一切正常工作，我们可以从Clojure项目使用我们的小型库，但如果我们想从一个纯Java（或groovy，或scala）项目中使用它会发生什么呢？
- en: Exposing your code to Java
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的代码暴露给Java
- en: 'If you want to be able to use Clojure code from other JVM languages, in Clojure,
    there are a couple of ways in which you can do it:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望能够从其他JVM语言中使用Clojure代码，在Clojure中，你可以通过几种方式做到这一点：
- en: You can generate new Java classes and use them as you normally would; it can
    implement some interface or extend from some other class
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以生成新的Java类，并像通常一样使用它们；它可以实现某些接口或从某些其他类扩展
- en: You can generate a proxy on the fly, this way you can implement a contract (in
    the form of a class or an interface) that some framework requires with little
    code and effort
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以即时生成一个代理，这样你可以用很少的代码和努力实现一些框架要求的契约（以类或接口的形式）
- en: You can use the `clojure.java.api` package to call Clojure functions directly
    from Java
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`clojure.java.api`包直接从Java调用Clojure函数
- en: Note
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information on how this works at the following location:
    [http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html](http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html).'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到更多关于如何工作的信息：[http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html](http://www.falkoriemenschneider.de/a__2014-03-22__Add-Awesomeness-to-your-Legacy-Java.html)。
- en: Let's have a look at how we can define a Java class.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何定义一个Java类。
- en: 'Create a new namespace called `thumbnails.image-java` and write the following
    code:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`thumbnails.image-java`的新命名空间，并编写以下代码：
- en: '[PRE89]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This code is very similar to the Clojure code that we have already seen, except
    for the `gen-class` directive and the function names starting with a dash.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前看到的Clojure代码非常相似，只是多了`gen-class`指令和以减号开始的函数名。
- en: 'Let''s review the `gem-class` in better detail:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地回顾一下`gem-class`：
- en: '[PRE90]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When the Clojure compiler sees this, it generates the byte code of a class but
    it needs a little help from the keywords to know how to generate the class.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 当Clojure编译器看到这个时，它会生成类的字节码，但它需要从关键字那里得到一点帮助来知道如何生成类。
- en: The name key defines the name of the class, it is a symbol
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称键定义了类的名称，它是一个符号
- en: The main key defines whether this class should have a main method or not
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要键定义了此类是否应该有一个主方法
- en: 'The method key defines all the methods and their signatures, it is a vector
    with three parts: `[methodName [parameterTypes] returnType]`'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法键定义了所有方法和它们的签名，它是一个包含三个部分的向量：`[methodName [parameterTypes] returnType]`
- en: The methods are then implemented as functions starting with the (`-`) character,
    the prefix can be changed with the prefix key.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 方法被实现为以`(`字符开始的函数，前缀可以通过前缀键更改。
- en: You also need to tell Clojure to compile this class in advance, in Leiningen
    it can be achieved with `:aot`, go to your `project.clj` file and add an `:aot`
    key with the namespace or namespaces to be compiled in a vector; if you want everything
    to be compiled in advance, you could use the special `:all` value.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要告诉Clojure预先编译这个类，在Leiningen中可以通过`:aot`实现，转到你的`project.clj`文件，并添加一个`:aot`键，以向量形式指定要编译的命名空间或命名空间；如果你希望所有内容都预先编译，可以使用特殊的`:all`值。
- en: 'In the end, you should have something similar to this:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该有一个类似这样的结果：
- en: '![Exposing your code to Java](img/B04289_03_03.jpg)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![将你的代码暴露给Java](img/B04289_03_03.jpg)'
- en: Tip
  id: totrans-617
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want all of your code to be compiled in advance, you can use `:aot :all`
    in your `project.clj`.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望所有代码都预先编译，你可以在`project.clj`中使用`:aot :all`。
- en: 'Now, we can install our library to our Maven local repository. Go to the command
    line and run:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的库安装到我们的Maven本地仓库中。转到命令行并运行：
- en: '[PRE91]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You''ll get an output similar to the following screenshot:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到类似于以下截图的输出：
- en: '![Exposing your code to Java](img/B04289_03_04.jpg)'
  id: totrans-622
  prefs: []
  type: TYPE_IMG
  zh: '![将你的代码暴露给Java](img/B04289_03_04.jpg)'
- en: Now, you are good to go; you should have a `thumbnails:thumbnails:0.1.0-SNAPSHOT`
    dependency in your Maven local repository.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好了；你应该在你的Maven本地仓库中有一个`thumbnails:thumbnails:0.1.0-SNAPSHOT`依赖项。
- en: Testing from Groovy
  id: totrans-624
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Groovy进行测试
- en: In order to see how this works with several JVM languages, we will use Groovy
    and Gradle to test. We can use Java and Maven just as easily. Remember that you
    can get the source from the code bundle so that you don't need to know everything
    that's happening here.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这如何与几种 JVM 语言一起工作，我们将使用 Groovy 和 Gradle 进行测试。我们同样可以轻松地使用 Java 和 Maven。记住，你可以从代码包中获取源代码，这样你就不需要了解这里发生的所有事情。
- en: 'There are two files here; in the `build.gradle` file, we specify that we want
    to use our local Maven repository and we specify our dependency, as:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个文件；在 `build.gradle` 文件中，我们指定我们想要使用我们的本地 Maven 仓库，并指定我们的依赖项，如下所示：
- en: '[PRE92]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Then we can write our test, as the following code:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以编写我们的测试，如下面的代码所示：
- en: '[PRE93]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You can then run the tests:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行测试：
- en: '[PRE94]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: As you can see, it is very easy to run your code from Java, Groovy, or even
    Scala. There are other ways to use Clojure with Java, particularly, if you want
    to implement an interface or generate a class dynamically.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从 Java、Groovy 或甚至 Scala 运行你的代码非常简单。还有其他方法可以将 Clojure 与 Java 一起使用，特别是如果你想要实现一个接口或动态生成一个类的话。
- en: Proxy and reify
  id: totrans-633
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理和 reify
- en: 'There are situations when you are interacting with Java libraries, where you
    must send an instance of a specific Java class to some method; writing a class
    isn''t the best option, you should rather create an instance that conforms to
    a contract expected by some framework on the fly. We have two options to do this:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当你与 Java 库交互时，你必须向某个方法发送特定 Java 类的实例；编写一个类不是最佳选择，你最好在运行时创建一个符合某些框架期望的合约的实例。我们有两个选项来做这件事：
- en: '**Proxy**: It allows you to implement a Java interface or extend from some
    super class. In reality, it creates a new object that calls your Clojure functions
    when needed'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：它允许你实现一个 Java 接口或从某个超类扩展。实际上，它创建了一个新对象，当需要时调用你的 Clojure 函数'
- en: '**Reify**: Reify allows you to implement interfaces and Clojure protocols (we
    will see them later). It is not capable of extending classes. It is a better performant
    than the proxy and should be used whenever possible.'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reify**：Reify 允许你实现接口和 Clojure 协议（我们稍后会看到）。它不能扩展类。它的性能比代理更好，应该尽可能使用。'
- en: 'Let''s look at a minimal example:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个最小示例：
- en: '[PRE95]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Tip
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`doto` is a macro that allows us to call several methods on an instance; you
    can think of it as a way to call all of the methods separately. It works great
    with Java Beans!'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '`doto` 是一个宏，允许我们在一个实例上调用多个方法；你可以将其视为分别调用所有方法的一种方式。它与 Java Beans！配合得很好。'
- en: 'Open up an REPL and write the code; it should show a window with a button that
    prints `Hello world` (in the terminal) when clicked:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个 REPL 并编写代码；它应该显示一个带有按钮的窗口，当点击按钮时（在终端中）会打印 `Hello world`：
- en: '![Proxy and reify](img/B04289_03_05.jpg)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
  zh: '![代理和 reify](img/B04289_03_05.jpg)'
- en: If you are familiar with swing, then you know that the `addActionListener` of
    `JButton` needs a callback which is an instance of `ActionListener` and we are
    creating said instance with the `reify` function.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 Swing，那么你知道 `JButton` 的 `addActionListener` 需要一个回调，即 `ActionListener`
    的实例，我们使用 `reify` 函数创建这个实例。
- en: 'In Java code, you might normally do something similar to the following code:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 代码中，你可能通常会做类似于以下代码的事情：
- en: '[PRE96]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We call this an anonymous class and it is essentially the same as a closure
    in functional languages. In the previous example, the code was replaced by a reify:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这为匿名类，它本质上与函数式语言中的闭包相同。在先前的例子中，代码被替换为 reify：
- en: '[PRE97]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `reify` statement receives the interface that you are implementing and all
    the methods that you are implementing as you list. In this case, we just implement
    `actionPerformed` to receive the action event.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`reify` 语句接收你正在实现的接口以及你按列表出的所有方法。在这种情况下，我们只实现了 `actionPerformed` 以接收动作事件。'
- en: 'This is the structure:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结构：
- en: '[PRE98]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This creates an instance of `ActionListener`, you can do the same with servlets,
    threads, collections, lists, or any other Java interface defined by anyone.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个 `ActionListener` 的实例，你可以用相同的方式与 servlets、threads、collections、lists 或任何其他由任何人定义的
    Java 接口一起使用。
- en: One particular thing that you need to remember here is that you need to always
    add `self` as the first parameter to your method implementations; it takes the
    place of the `this` keyword that works in Java.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你需要记住的一件特别的事情是，你需要在方法实现中始终将 `self` 作为第一个参数添加；它取代了在 Java 中工作的 `this` 关键字。
- en: Summary
  id: totrans-653
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you have gained a lot of power from Clojure with a few new
    primitives.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过一些新的原语获得了 Clojure 的很多功能。
- en: 'As you can see, there are plenty of ways to interact with your current codebase;
    specifically, you can now:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有 plenty of ways to interact with your current codebase；特别是，你现在可以：
- en: Use Java code from Clojure
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Clojure使用Java代码
- en: Use Clojure code from Java
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Java使用Clojure代码
- en: Reuse Java frameworks by creating objects that adhere to their contracts
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建遵守其契约的对象来重用Java框架
- en: With all of our new tools in mind, we are ready to tackle more concepts and
    a little bit more complexity with collections and data structures.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们所有的这些新工具，我们现在准备好处理更多概念和稍微复杂一些的集合和数据结构。
- en: Chapter 4. Collections and Functional Programming
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：集合和函数式编程
- en: We are now comfortable with using Java code from our Clojure programs, and we
    also know how to expose our Clojure programs with a Java API. However, we need
    to take a deeper look at Clojure and its true nature, which is functional programming.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经习惯了在Clojure程序中使用Java代码，我们也知道如何通过Java API公开我们的Clojure程序。然而，我们需要更深入地了解Clojure及其真正的本质，即函数式编程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basics of functional programming
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程基础
- en: Persistent collections
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性集合
- en: Sequential and associative collections
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序和关联集合
- en: The sequence abstraction
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列抽象
- en: Collection types
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合类型
- en: Applying functional programming to collections
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数式编程应用于集合
- en: Basics of functional programming
  id: totrans-669
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程基础
- en: 'This is a topic that you can read about in lots of different places, and it
    seems that everyone has their own opinion of what functional programming is. There
    is however, some common ground that you will find in almost every definition,
    which relates to the benefits you gain from functional programming, such as:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你可以在很多不同地方读到的话题，似乎每个人都有自己关于函数式编程是什么的看法。然而，在几乎每个定义中，你都会找到一个共同点，这与你从函数式编程中获得的好处相关，例如：
- en: Easier code reuse
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易的重用代码
- en: Functions are easier to test
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数更容易测试
- en: Functions are easier to reason about
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数更容易推理
- en: 'In order to get these benefits, you need to take into account the following
    things:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这些好处，你需要考虑以下事项：
- en: You should think of functions as first class citizens
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该将函数视为一等公民
- en: Functions should minimize side effects (they shouldn't change any state)
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该最小化副作用（它们不应该改变任何状态）
- en: Functions should only depend on their parameters (this is called referential
    transparency)
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数应该只依赖于它们的参数（这被称为引用透明性）
- en: Lets take a look at two examples of functions (or methods) in Java to illustrate
    how, even in Java, you can get benefits from writing functions without side effects
    and context dependency.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Java中两个函数（或方法）的例子，以说明即使在Java中，你也可以从编写无副作用和上下文依赖的函数中获得好处。
- en: '[PRE99]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Imagine you had to test the preceding function; you might have a number of
    problems:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你必须测试前面的函数；你可能会遇到一些问题：
- en: You need to know how to get the current user; you might need to mock a database,
    or session storage. Or in the worst case scenario, you might need a real session
    storage service.
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要知道如何获取当前用户；你可能需要模拟数据库或会话存储。或者在最坏的情况下，你可能需要一个真实的会话存储服务。
- en: How can you know if something was paid for or not?
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何知道某物是否已支付？
- en: 'Now, look at this other example:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看这个其他例子：
- en: '[PRE100]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The preceding code is easier to test; you can create a user instance any way
    you want and with the `ValidateStrategy` class (or interface) you could do whatever
    you need.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码更容易测试；你可以以任何方式创建用户实例，并且使用`ValidateStrategy`类（或接口），你可以做你需要做的任何事情。
- en: In the end, instead of a side-effect you get a return value stating if the action
    was possible or not. This way you don't need to mock and you can reuse it in different
    contexts.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你得到的不是副作用，而是一个返回值，表示操作是否可行。这样你就不需要模拟，并且可以在不同的上下文中重用它。
- en: 'Now that we have seen some common ground for functional programming, let''s
    take a look at Clojure''s value proposition for functional programming:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了函数式编程的一些共同点，让我们来看看Clojure在函数式编程方面的价值主张：
- en: Functions are first class citizens or values. The same as with integers or strings,
    you can create them in runtime, pass them around, and receive them in other functions.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是一等公民或值。就像整数或字符串一样，你可以在运行时创建它们，传递它们，并在其他函数中接收它们。
- en: The same way that functions are values, the data structures are also values;
    they can't be modified in the sense that they can be modified in Java but they
    are a fixed value, just as an integer is a fixed value.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是值，数据结构也是值；它们不能像Java中那样被修改，它们是一个固定值，就像整数是一个固定值一样。
- en: Immutable data structures are very important, they allow for safe and simple
    multithreaded code.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变数据结构非常重要，它们允许编写安全和简单的多线程代码。
- en: Laziness (of data structures) allows deferring evaluation until needed, to execute
    just what you must.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性（数据结构的惰性）允许延迟评估直到需要时，只执行你必须执行的操作。
- en: Persistent collections
  id: totrans-692
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久集合
- en: One of the most important features in Clojure is that collections are persistent.
    That does not mean that they are persistent to disk, it means that you can have
    several historical versions of a collection with the guarantee that updating or
    looking for something in any of those versions is going to have the same effort
    (complexity). You get all this with very little extra memory.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure最重要的特性之一是集合是持久的。这并不意味着它们是持久到磁盘的，这意味着你可以有多个集合的历史版本，并且有保证，更新或在这些版本中查找任何内容都将具有相同的努力（复杂度）。你只需很少的额外内存就能得到所有这些。
- en: How? It is actually pretty simple. Clojure shares a common structure between
    several different data structures. If you add a single element to a data structure,
    Clojure shares the common part between the two structures and keeps track of the
    differences.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？实际上很简单。Clojure在几个不同的数据结构之间共享一个公共结构。如果你向一个数据结构添加一个元素，Clojure会共享两个结构之间的公共部分，并跟踪差异。
- en: 'Let''s see what we mean with an example:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来看看我们的意思：
- en: '[PRE101]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: As you can see, when you `conj` a new item into a collection, or even when you
    replace some elements from it, you aren't changing the original collection, you
    are just generating a new version of it.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当你将新项目`conj`到一个集合中，或者甚至替换它的一些元素时，你并没有改变原始集合，你只是在生成一个新的版本。
- en: Note
  id: totrans-698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Clojure, you can use `conj(conjoin)` as a verb. It means adding new elements
    into a collection in an efficient manner.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，你可以使用`conj(conjoin)`作为一个动词。这意味着以高效的方式将新元素添加到集合中。
- en: This new version doesn't modify the previous collections you had in any way.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本不会以任何方式修改你之前拥有的任何集合。
- en: 'This is a big difference from how common imperative languages work and at the
    first glance it might seem like a bad idea, but Clojure uses efficient algorithms
    that give us a couple of advantages, specifically:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 这与常见的命令式语言的工作方式有很大不同，乍一看可能像是一个坏主意，但Clojure使用高效的算法，给我们带来了一些优势，特别是：
- en: Different versions of the same collection share common parts, allowing us to
    use little memory
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同集合的不同版本共享公共部分，使我们能够使用很少的内存。
- en: When some part of the collection is not visible it gets garbage collected
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当集合的一部分不可见时，它会被垃圾回收。
- en: What you get out of this is similar memory usage to what you would have with
    a mutable collection. Remember that there is a cost in space and time but it is
    negligible for most use cases.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 你从这得到的是与可变集合相似的内存使用量。记住，在空间和时间上都有成本，但对于大多数用例来说可以忽略不计。
- en: Why would you want to have an immutable data collection? The main advantage
    is that it is simple to reason about them; passing them around to functions does
    not change them and when you are writing concurrent code, there is no chance that
    some other thread has modified your collection and you don't need to worry about
    explicitly handling locks.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么要有一个不可变的数据集合？主要优势是它们很容易理解；将它们传递给函数不会改变它们，当你编写并发代码时，没有其他线程会修改你的集合，你也不需要担心显式处理锁。
- en: Types of collections in Clojure
  id: totrans-706
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure中的集合类型
- en: 'There are three types of collections in Clojure: counted, sequential, and associative.
    They are not mutually exclusive, meaning one collection might be any.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中有三种类型的集合：计数集合、顺序集合和关联集合。它们不是互斥的，这意味着一个集合可能是任何一种。
- en: 'Let''s look at each type:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每种类型：
- en: '**Counted collection**: A counted collection is a collection which knows its
    size in constant time. It doesn''t need to traverse its elements to get a count.'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数集合**：计数集合是一个知道其大小在常数时间内的集合。它不需要遍历其元素来获取计数。'
- en: '**Sequential collection**: A sequential collection can be traversed sequentially;
    it''s the most common approach that you would use for a list. The easiest way
    to think about this is similar to Java''s list, which you can traverse with a
    for-loop or an iterator. In Clojure vectors, lists and lazy sequences are sequential
    collections.'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序集合**：顺序集合可以顺序遍历；这是您在处理列表时最常用的方法。最容易想到的类比是Java的列表，您可以使用for循环或迭代器遍历它。在Clojure中，向量、列表和惰性序列都是顺序集合。'
- en: '**Associative collections**: Associative collections can be accessed by keys;
    maps are the natural choice here. We said that one collection can be of any type;
    Clojure''s vectors can also be used as associative collections, and each element
    index can be used as a key. You can think of it as a map where the keys are 0,
    1, 2, 3, and so on.'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联集合**：关联集合可以通过键来访问；映射是这里的首选。我们说过一个集合可以是任何类型；Clojure的向量也可以用作关联集合，每个元素索引都可以用作键。您可以将其视为一个键为0、1、2、3等的映射。'
- en: 'Clojure has some functions that tell us if a given collection is of each type,
    sequential or associative. As you can guess, vectors return true for both. The
    following are those functions:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有一些函数可以告诉我们给定的集合是否为每种类型，顺序的还是关联的。正如您所猜想的，向量对两者都返回true。以下是一些函数：
- en: '| Function name | List | Vector | Map | Lazy sequence | Set |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 列表 | 向量 | 映射 | 惰性序列 | 集合 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| counted? | true | true | true | false | true |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| counted? | true | true | true | false | true |'
- en: '| sequential? | true | true | false | true | false |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| sequential? | true | true | false | true | false |'
- en: '| associative? | false | true | true | false | false |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| associative? | false | true | true | false | false |'
- en: '![Types of collections in Clojure](img/B04289_04_01.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_IMG
  zh: '![Clojure中的集合类型](img/B04289_04_01.jpg)'
- en: In the previous table and diagram, you can see that we take **Set** into account
    and as you can see, it's neither sequential nor associative.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的表格和图中，您可以看到我们考虑了**集合**，如您所见，它既不是顺序的也不是关联的。
- en: We should look at another property; whether a collection is counted or not.
    It means that a collection knows how many elements it has. Lists, vectors, maps,
    and sets are all counted; lazy sequences are not counted, since they are generated
    on the fly and they could even be infinite sequences.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该考虑另一个属性；一个集合是否计数。这意味着一个集合知道它有多少个元素。列表、向量、映射和集合都是计数的；惰性序列不是计数的，因为它们是即时生成的，甚至可能是无限序列。
- en: We will learn more about all of these sequences in the later sections of this
    chapter.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的部分学习更多关于所有这些序列的内容。
- en: The sequence abstraction
  id: totrans-722
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列抽象
- en: 'Clojure has some unique features that make it different from other Lisps; one
    of them is the sequence abstraction. You can think of it as an interface that
    collections comply with. Clojure has a standard API of functions that you can
    use with sequences. Here are some examples of those functions:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有一些独特的特性使其与其他Lisp不同；其中之一就是序列抽象。您可以将其视为集合遵守的接口。Clojure有一个标准的函数API，您可以使用序列。以下是一些这些函数的示例：
- en: 'The `distinct` function: This function returns a sequence that includes each
    element of the original sequence just once:'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct`函数：此函数返回一个序列，只包含原始序列中的每个元素一次：'
- en: '[PRE102]'
  id: totrans-725
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `take` function: This function takes a number of elements from the original
    sequence:'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take`函数：此函数从原始序列中取出一定数量的元素：'
- en: '[PRE103]'
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The `map` function: This function applies a function to each element of a sequence
    and creates a new sequence with these elements:'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`函数：此函数将函数应用于序列中的每个元素，并创建一个包含这些元素的新序列：'
- en: '[PRE104]'
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The interesting part here is that these functions receive and return sequences
    and you can compose them together. It can be seen in the following code:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是，这些函数接收并返回序列，并且您可以组合它们。这可以在以下代码中看到：
- en: '[PRE105]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'These are just some functions that accept and return sequences, but there are
    a lot more that you can use out of the box. The only assumption is that your sequence
    argument can respond to three functions:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是接受并返回序列的一些函数，但还有更多您可以直接使用。唯一的假设是您的序列参数可以响应三个函数：
- en: '`first`: This function returns the first of a sequence'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`：此函数返回序列的第一个元素'
- en: '`rest`: This function returns another sequence, containing everything but the
    first element'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rest`：此函数返回另一个序列，包含除了第一个元素之外的所有元素'
- en: '`cons`: This function receives two parameters, an item and another `seq` and
    returns a new `seq` containing the item followed by all the items in the second
    parameter'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cons`：这个函数接收两个参数，一个项和另一个`seq`，然后返回一个新的`seq`，其中包含第二个参数中的所有项'
- en: Note
  id: totrans-736
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One of the functions that you'll find yourself using more is the `seq` function,
    it can convert any collection to a seq, even Java native arrays and objects that
    implement the `java.util.Iterable` interface. One of its main uses is to test
    a collection for emptiness.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现你更频繁使用的函数之一是`seq`函数，它可以转换任何集合为序列，甚至Java原生的数组和实现了`java.util.Iterable`接口的对象。其主要用途之一是测试集合是否为空。
- en: Specific collection types in Clojure
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure中的特定集合类型
- en: Now that you know about Clojure's general collection properties and the sequence
    abstraction, it is a good time to get to know about Clojure's specific collection
    implementations.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Clojure的一般集合特性和序列抽象，现在是了解Clojure的具体集合实现的好时机。
- en: Vectors
  id: totrans-740
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量
- en: Vectors are Clojure's workhorse; together with map, it is the most used collection.
    Don't be afraid of them; they have nothing to do with Java's `java.util.Vector`.
    They are just a series of ordered values, such as a list or an array.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是Clojure的工作马；与map一起，它是使用最多的集合。不要害怕它们；它们与Java的`java.util.Vector`无关。它们只是一系列有序值，如列表或数组。
- en: 'They have the following properties:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 它们具有以下特性：
- en: They are immutable
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是不可变的
- en: They can be accessed sequentially
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以按顺序访问
- en: They are associative (they are maps of their indices, meaning that their keys
    are 0, 1, 2, and so on)
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是结合的（它们是它们索引的映射，这意味着它们的键是0、1、2等等）
- en: They are counted, meaning they have a finite size
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是计数的，意味着它们具有有限的大小
- en: They have random access, so you can access any element with almost constant
    time (with the nth function)
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有随机访问，因此你可以几乎以恒定的时间访问任何元素（使用nth函数）
- en: The `conj` function appends a given element to them
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conj`函数将给定元素附加到它们上'
- en: Tip
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The nth function allows us to get the nth element of any `seq`, but you shouldn't
    use it without care. It has no problem handling vectors and it returns in constant
    time, but it takes linear time when used with a list, since it has to traverse
    all the collections looking for the element you asked. Try to use it just with
    vectors.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: nth函数允许我们获取任何`seq`的第n个元素，但你不应不加考虑地使用它。它没有问题处理向量，并且以恒定时间返回，但与列表一起使用时，它需要线性时间，因为它必须遍历所有集合以找到你请求的元素。尽量只与向量一起使用它。
- en: 'They have a literal syntax; you can define a vector with square brackets, as
    shown:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 它们具有字面语法；你可以使用方括号定义一个向量，如下所示：
- en: '[PRE106]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Besides the literal syntax, there''s another function that you can use to build
    a vector. The `vec` function can build a vector out of any sequence passed to
    it:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字面语法之外，还有一个你可以用来构建向量的函数。`vec`函数可以从传递给它的任何序列中构建一个向量：
- en: '[PRE107]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Another important benefit of vectors is that they are used for function arguments
    for declarations and for `let` bindings.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 向量另一个重要的好处是它们被用于函数参数声明和`let`绑定。
- en: 'Take a look at the following example:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例：
- en: '[PRE108]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: As you can see, the parameters in the function are defined as a vector, same
    as the `let` binding.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，函数中的参数被定义为向量，与`let`绑定相同。
- en: One of the main complaints about Lisps is that they use too many parentheses,
    Clojure's decision to use vectors instead in these structures is welcomed and
    makes the code much easier to read.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Lisp的主要抱怨之一是它们使用太多的括号，Clojure在这些结构中使用向量而不是括号的决策受到欢迎，这使得代码更容易阅读。
- en: 'There are several ways to access a certain element of a vector:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以访问向量的某个元素：
- en: '**Using the vector as a function**: Vectors can be used as functions of their
    keys; we haven''t discussed maps yet but you will see that this is because they
    are associative:'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将向量用作函数**：向量可以用作其键的函数；我们还没有讨论map，但你会看到这是因为它们是结合的：'
- en: '[PRE109]'
  id: totrans-762
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '**The nth function**: The `nth` function can receive an extra parameter for
    signaling when an index is not found and can be used, as shown:'
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nth函数**：`nth`函数可以接收一个额外的参数来指示当索引未找到时，它可以像下面这样使用：'
- en: '[PRE110]'
  id: totrans-764
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '**The get function**: The `get` function can receive an extra parameter for
    signaling when an index is not found, it is used as shown. An important thing
    to keep in mind is that unlike nth, `get` cannot be used in sequences:'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get函数**：`get`函数可以接收一个额外的参数来指示当索引未找到时，它像下面这样使用。需要注意的是，与nth不同，`get`不能用于序列：'
- en: '[PRE111]'
  id: totrans-766
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'You should use vectors almost always; in particular, if you want to do any
    of the following there is no other way to go:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎总是应该使用向量；特别是，如果你想做以下任何一项，没有其他方法可行：
- en: You need random access to a collection (either modifying or accessing it)
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要随机访问一个集合（无论是修改还是访问它）
- en: You need to add elements at the tail of the collection
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要向集合的尾部添加元素
- en: Lists
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are the most important collection type in other Lisps. In Clojure, they
    are used to represent code, but their functionality is almost limited to that.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 列表在其他Lisp中是最重要的集合类型。在Clojure中，它们用于表示代码，但它们的功能几乎仅限于这一点。
- en: Lists in Clojure are single linked lists; as you can imagine, this means that
    they are not good for random access (you need to iterate the list until you get
    to the wanted index). That said, you can still use lists as sequences with every
    function of the API.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中的列表是单链表；正如你所想象的那样，这意味着它们不适合随机访问（你需要遍历列表直到到达想要的索引）。话虽如此，你仍然可以使用列表作为API中每个函数的序列。
- en: 'Let''s list their properties:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出它们的属性：
- en: They are immutable
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是不可变的
- en: They can be accessed sequentially
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以按顺序访问
- en: They are not associative
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不是关联的
- en: They are counted, meaning they have a finite size
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是有计数的，意味着它们有有限的大小
- en: They shouldn't be accessed in random order. If you want the 99th element, then
    Clojure will have to visit all the first 98 elements to get the 99th.
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不应该以随机顺序访问。如果你想得到第99个元素，那么Clojure将不得不访问前98个元素才能得到第99个。
- en: The `conj` function prepends a given element to it
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conj` 函数将给定元素添加到其前面'
- en: You can use destructuring with lists, as seen in the previous chapter. You shouldn't
    be afraid to use the first function (or even nth with a small index).
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用与上一章中看到的一样解构列表。你不应该害怕使用第一个函数（甚至可以使用带有小索引的nth）。
- en: Tip
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Lists have their use cases and as you learn more you'll probably be comfortable
    using them in some places (such as macros), but as a rule of thumb, try to use
    vectors instead.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 列表有其用例，随着你学习的深入，你可能会在某些地方（如宏）感到舒适地使用它们，但作为一个经验法则，尽量使用向量。
- en: Maps
  id: totrans-783
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: Maps are probably the most important collection type across all languages. They
    are also very important in Clojure.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 地图可能是所有语言中最重要的一种集合类型。在Clojure中，它们也非常重要。
- en: Maps are collections of key value pairs, which mean that you can access or store
    an element by a key. We have been calling this type of collection an associative
    collection. Keys can be of any type of value in Clojure, even functions, lists,
    sets, vectors, or other maps.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是键值对的集合，这意味着你可以通过键访问或存储一个元素。我们一直称这种类型的集合为关联集合。在Clojure中，键可以是任何类型的值，甚至是函数、列表、集合、向量或其他映射。
- en: Sorted maps and hash maps
  id: totrans-786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序映射和哈希映射
- en: There are two types of maps in Clojure, each one of them with its own advantages.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure中有两种映射类型，每种类型都有其自身的优点。
- en: '**Hash maps**: They are the most used form of map in Clojure; the literal syntax
    of maps creates this type of maps. They have a nearly constant lookup time, which
    makes them extremely fast and usable in most scenarios. Their down-side is that
    you can''t access them in an ordered fashion. You can create them, as shown:'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希映射**：它们是Clojure中最常用的映射形式；映射的文本语法创建了这种类型的映射。它们具有几乎恒定的查找时间，这使得它们在大多数场景中都非常快且可用。它们的缺点是你不能按顺序访问它们。你可以创建它们，如下所示：'
- en: '[PRE112]'
  id: totrans-789
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '**Sorted maps**: If you need to be able to access a map''s key-value pairs
    in a certain order, then you have to use a sorted map. The downside of sorted
    maps is that the lookup time is *not* constant, which means that they are a little
    slower to access by key. However, when you need to traverse a map in the order
    of the keys, then this is the only way to go. A strong constraint here is that
    the keys must be comparable between them. Sorted maps can be created, as shown:'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序映射**：如果你需要能够以特定顺序访问映射的键值对，那么你必须使用排序映射。排序映射的缺点是查找时间**不是**常数，这意味着它们通过键访问会稍微慢一些。然而，当你需要按键的顺序遍历映射时，这是唯一的方法。这里的一个强约束是键之间必须是可比较的。排序映射可以创建，如下所示：'
- en: '[PRE113]'
  id: totrans-791
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Tip
  id: totrans-792
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Comparable objects are the ones that implement the `compareTo` interface.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 可比较的对象是实现了`compareTo`接口的对象。
- en: Common properties
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见属性
- en: 'Associative objects, including maps have the following properties:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 关联对象，包括映射具有以下属性：
- en: 'They are functions of their keys:'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是它们键的函数：
- en: '[PRE114]'
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'They can be used with associative destructuring:'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以与关联解构一起使用：
- en: '[PRE115]'
  id: totrans-799
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'They can be accessed with the `get` function:'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`get`函数访问：
- en: '[PRE116]'
  id: totrans-801
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'You can convert a map to a `seq` with the `seq` function; you will get a sequence
    where each element is a vector representing a key-value pair in the map:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`seq`函数将一个映射转换为`seq`；你将得到一个序列，其中每个元素都是一个表示映射中键值对的向量：
- en: '[PRE117]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '`Doseq` is similar to Java''s for-each loop. It executes the body for each
    element in a sequence.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '`Doseq`类似于Java的for-each循环。它对序列中的每个元素执行主体。'
- en: 'It works as shown: `(doseq [x sequence] ;;`. This works the same way as the
    let statement, you can use destructuring if needed:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式如下：`(doseq [x sequence] ;;`。这与let语句的工作方式相同，如果需要，你可以使用解构：
- en: '[PRE118]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Sets
  id: totrans-807
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: Clojure sets are a collection of unique elements. You can think of them as mathematical
    sets and as such, Clojure has operations, such as union intersection and difference.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure集合是唯一元素的集合。你可以把它们看作是数学集合，因此Clojure有并集、交集和差集等操作。
- en: 'Let''s look at the properties of sets:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看集合的性质：
- en: They are immutable
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是不可变的
- en: They are associative (their keys are their elements)
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是关联的（它们的键是它们的元素）
- en: They are counted, meaning they have a finite size
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是计数的，这意味着它们有有限的大小
- en: Their elements are unique (contained at most once)
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的元素是唯一的（最多包含一次）
- en: Sorted sets and hash sets
  id: totrans-814
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有序集合和哈希集合
- en: 'There are two kinds of sets: hash-sets and sorted-sets.'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 集合有两种类型：哈希集合和有序集合。
- en: '**Hash-set**: Besides the properties that we already saw, hash-sets are unordered.
    They are implemented using a hash map as a backing implementation.'
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希集合**：除了我们之前看到的属性外，哈希集合是无序的。它们使用哈希映射作为后端实现。'
- en: '**Sorted-set**: Besides the properties that we already saw, sorted-sets are
    sorted. They can be used as a parameter to all the functions that expect a sorted
    `seq`. They can be accessed sequentially in sorted order:'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序集合**：除了我们之前看到的属性外，有序集合是有序的。它们可以用作所有期望有序`seq`的函数的参数。它们可以按顺序访问：'
- en: '[PRE119]'
  id: totrans-818
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: You can also reverse them without problems, filter them, or map them similarly
    to a vector or list.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以无问题地反转它们，过滤它们，或者像向量或列表一样映射它们。
- en: Common properties
  id: totrans-820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见属性
- en: 'Sets are associative, which gives them some properties of maps:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是关联的，这给了它们一些映射的性质：
- en: 'They are functions of their elements:'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是它们元素的函数：
- en: '[PRE120]'
  id: totrans-823
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'They can be used with map destructuring:'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以与映射解构一起使用：
- en: '[PRE121]'
  id: totrans-825
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `get` function can be used to access their elements:'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`get`函数来访问它们的元素：
- en: '[PRE122]'
  id: totrans-827
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Union, difference, and intersection
  id: totrans-828
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并集、差集和交集
- en: 'If you remember mathematical sets, you''ll know that the three main operations
    you can execute on them are the following:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得数学集合，你就会知道你可以对它们执行以下三个主要操作：
- en: '**Union** (`union a b`): The union includes all of the elements both in `a`
    and `b`'
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并集**（`union a b`）：并集包括`a`和`b`中的所有元素'
- en: '**Difference** (`difference a b`): The difference is all the elements that
    are in `a` except for the elements that are also in `b`'
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差集**（`difference a b`）：差集是`a`中所有不在`b`中的元素'
- en: '**Intersection** (`intersection a b`): It includes only the elements that are
    both in `a` and `b`'
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交集**（`intersection a b`）：它只包括`a`和`b`中都有的元素'
- en: 'Here are some examples:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE123]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Applying functional programming to collections
  id: totrans-835
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数式编程应用于集合
- en: Now that we have a better understanding of how collections work, we have a better
    foundation to understand functional programming and how to make the most out of
    it.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对集合的工作方式有了更好的理解，我们就有了更好的基础来理解函数式编程以及如何充分利用它。
- en: This requires a different way of thinking about how to solve problems and you
    should keep your mind open.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一种不同的思维方式来解决问题，你应该保持开放的心态。
- en: 'Something that you might have found really strange about all of the collections
    is this feature: *They are immutable*.'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能发现所有这些集合中有一个非常奇怪的特性：*它们是不可变的*。
- en: This is indeed something quite strange; if you are used to Java, how can you
    possibly write programs without adding or removing elements from a list or set?
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一件相当奇怪的事情；如果你习惯了Java，你怎么可能不添加或从列表或集合中删除元素来编写程序？
- en: How is that even possible? In Java, we are used to writing `for` and `while`
    loops. We are used to mutating variables every step of the way.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 这怎么可能呢？在Java中，我们习惯于编写`for`和`while`循环。我们习惯于每一步都修改变量。
- en: How can we cope with immutable data structures? Let's find out in the subsequent
    sections.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理不可变的数据结构？让我们在接下来的章节中找出答案。
- en: The imperative programming model
  id: totrans-842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式编程模型
- en: The software industry has been using a single software paradigm for a long time;
    this paradigm is an imperative programming model.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业长期以来一直使用单一软件范式；这个范式是命令式编程模型。
- en: In the imperative paradigm, you have to tell the computer what to do at every
    single step. You are responsible for how the memory works, for whether it is running
    in a single core or multi core and, if you want to use multi core, you need to
    make sure that you change the program state correctly and avoid concurrency problems.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式范式中，你必须告诉计算机在每一步要做什么。你负责内存的工作方式，是运行在单核还是多核上，如果你想使用多核，你需要确保正确地改变程序状态并避免并发问题。
- en: 'Let''s see how you would calculate the factorial in an imperative style:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你将如何以命令式风格计算阶乘：
- en: '[PRE124]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: You are creating a variable result and a variable `i`. You change the variable
    `i` each time by assigning it the value `i + 1`. You can change the result by
    multiplying by `i`. The computer just executes your orders, comparing, adding,
    and multiplying. This is what we call the imperative programming model, because
    you need to tell the computer the exact commands it needs to execute.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在创建一个可变的结果和一个可变的变量`i`。每次你通过将其赋值为`i + 1`来改变变量`i`的值。你可以通过乘以`i`来改变结果。计算机只是执行你的命令，比较、加法和乘法。这就是我们所说的命令式编程模型，因为你需要告诉计算机它需要执行的精确命令。
- en: 'This has worked fine in the past for various reasons, such as:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种原因，这在过去一直工作得很好，例如：
- en: The tight constraints of memory size forced programmers to make use of the memory
    as efficient as possible
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存大小的严格限制迫使程序员尽可能高效地使用内存
- en: It was easier to think about a single thread of execution and how the computer
    executes it step-by-step
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑单个执行线程及其逐步执行的方式更容易
- en: Of course, there were some drawbacks. A code can get complicated easily and
    the world has changed; the constraints that existed many years ago are gone. In
    addition, most of today's computers have more than one CPU. Multi-threading with
    shared mutable states is burdensome.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有一些缺点。代码很容易变得复杂，世界已经改变；多年前存在的约束已经消失。此外，今天的大多数计算机都有多个CPU。使用共享可变状态的多线程是负担。
- en: This makes thinking about this complicated. We get in trouble even in single
    threaded programs; just think, what would be the outcome of the following code?
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得思考变得复杂。即使在单线程程序中我们也会遇到麻烦；想想看，以下代码的结果会是什么？
- en: '[PRE125]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Is it `0`? You can't possibly know because the `doSomething` method gets the
    list by reference and it can add or remove things without you knowing.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 是`0`吗？你不可能知道，因为`doSomething`方法通过引用获取列表，并且可以在你不知道的情况下添加或删除东西。
- en: Now, imagine that you have a multithreaded program and a single `List` that
    can be modified by any of the threads. In the Java world, you have to know about
    `java.util.concurrent.CopyOnWriteArrayList` and you need to know about its implementation
    details to know when it's a good idea to use it and when not to use it.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你有一个多线程程序和一个可以被任何线程修改的单个`List`。在Java世界中，你必须了解`java.util.concurrent.CopyOnWriteArrayList`，并且你需要了解其实现细节，以便知道何时使用它以及何时不使用它。
- en: Even with these structures, it is difficult to think about multithreaded code.
    You still need to think about semaphores, locks, synchronizers, and so on.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了这些结构，思考多线程代码仍然困难。你仍然需要考虑信号量、锁、同步器等等。
- en: The imperative world might be easy for the easy case, but it is not simple.
    The whole industry has realized this and there are many new languages and technologies
    that take ideas from other places. Java 8 has the streaming API and it includes
    lambda blocks, which are essentially functions. All these ideas are taken from
    the functional world.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单情况下，命令式世界可能容易，但它并不简单。整个行业已经意识到这一点，并且有许多新的语言和技术从其他地方汲取了灵感。Java 8 有流式API，它包括lambda块，本质上就是函数。所有这些想法都是从函数式世界借鉴来的。
- en: The functional paradigm
  id: totrans-858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式范式
- en: There are other ways of thinking about how to solve a problem; in particular,
    the functional paradigm has become important lately. It is nothing new; Lisp has
    supported this kind of programming since it was conceived in 1958\. It has probably
    not been strong until recently, as it requires a more abstract way of thinking.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的思考方式有很多种；特别是，函数式范式最近变得很重要。这并不是什么新鲜事；Lisp自从1958年构思以来就支持这种编程方式。它可能直到最近才变得强大，因为它需要一种更抽象的思维方式。
- en: 'For you to get a better idea, let''s see a couple of examples of how functional
    programming looks similar to the following code:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你更好地理解，让我们看看几个函数式编程看起来与以下代码相似示例：
- en: '[PRE126]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: As you can see, it looks quite different; in the first case, we are passing
    the `str` function to another function called map.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它看起来相当不同；在第一种情况下，我们将`str`函数传递给另一个名为`map`的函数。
- en: In the second case, we are passing the `*` function to another function called
    reduce. In both cases, we are using functions as you would pass a list or a number,
    they are **first level citizens**.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们将`*`函数传递给另一个名为`reduce`的函数。在这两种情况下，我们使用函数，就像传递一个列表或一个数字一样，它们是**第一级公民**。
- en: One important difference in functional programming is that you don't need to
    tell the machine how to do things. In the first case, the map traverses the vector
    and applies the `str` function to each element, converting it to a `seq` of strings.
    You don't have to increment the index, you just need to tell the map what function
    you want to be applied to each element.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的一个重要区别是你不需要告诉机器如何做事。在第一种情况下，map遍历向量并将`str`函数应用于每个元素，将其转换为字符串的`seq`。你不需要递增索引，你只需要告诉map你想要应用于每个元素的函数。
- en: In the factorial case, there is a reduce function that receives the `*` and
    a `seq` from `1` to `n`.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 在阶乘的情况下，有一个接收`*`和一个从`1`到`n`的`seq`的`reduce`函数。
- en: It just works, you don't need to tell it how to do anything, just what you want
    done.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是工作，你不需要告诉它如何做任何事情，只需要告诉它你想要做什么。
- en: Both `map` and `reduce` are **higher order functions** because they accept functions
    such as parameters; they are also higher level abstractions.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`reduce`都是**高阶函数**，因为它们接受函数作为参数；它们也是高级抽象。'
- en: Note
  id: totrans-868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Higher order functions are functions that either accept a function as an argument,
    return a function as result, or both.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是那些接受函数作为参数、返回函数作为结果，或者两者都做的函数。
- en: You need to think on another level of abstraction and you don't care how things
    are really done, just that it gets the work done.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在一个更高级的抽象层面上思考，你不在乎事情是如何真正完成的，只在乎它完成了工作。
- en: This comes with some benefit, if the implementation of a map someday changes
    to become multithreaded, you would just need to update the versions and you would
    be ready to go!
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一些好处，如果某个时候映射的实现变成了多线程，你只需要更新版本，就可以准备出发了！
- en: Functional programming and immutability
  id: totrans-872
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程和不可变性
- en: You may have also noticed that functional programming makes working with immutable
    structures necessary, because you can't mutate some or the other state in every
    step; you can just describe how you want to create a new collection based on some
    other collection and then get it. Clojure's efficient collections make it possible
    to share pieces of collections to keep memory usage at a minimum.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了，函数式编程使得使用不可变结构成为必要，因为你不能在每一步中更改某些或所有状态；你只能描述你想要基于某个其他集合创建新集合的方式，然后获取它。Clojure的高效集合使得在最小内存使用的情况下共享集合的片段成为可能。
- en: 'There are some other benefits to immutability:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性还有一些其他好处：
- en: You can share your data structures with anyone you want because you are certain
    that nobody can change your copy.
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以与任何你想分享的数据结构，因为你确定没有人会更改你的副本。
- en: Debugging is simpler because you can test the program with some immutable value
    instead of some mutating state. When you get a value, you can find out which function
    returned the value that you got; there are not multiple places where a collection
    was mutated for you to check.
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试更简单，因为你可以用一些不可变值而不是可变状态来测试程序。当你得到一个值时，你可以找出哪个函数返回了你得到的值；没有多个地方会修改集合供你检查。
- en: Concurrent programming is simpler; again being certain that nobody can change
    your copy, even in other concurrently running threads, makes reasoning about your
    program simpler.
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程更简单；再次确定没有人可以更改你的副本，即使在其他并发运行的线程中，这也使得对程序的推理更简单。
- en: Laziness
  id: totrans-878
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 懒惰
- en: 'Clojure also supports lazy evaluation of transformations of sequences. Let''s
    take a look at the `range` function:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure还支持序列转换的惰性求值。让我们看看`range`函数：
- en: '[PRE127]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: When running this function without parameters, you are creating an infinite
    sequence starting from `0`.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此函数不带参数时，你正在创建一个从`0`开始的无限序列。
- en: It is an infinite sequence; so why does the Clojure REPL return automatically?
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无限序列；那么为什么Clojure的REPL会自动返回？
- en: 'Clojure doesn''t compute a collection value until needed, so in order to get
    a value you would have to do something, such as this:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 不会在需要之前计算集合值，因此为了获取一个值，你必须做些什么，比如这样：
- en: '[PRE128]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Tip
  id: totrans-885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you try to print an infinite sequence at the REPL, it will freeze.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在 REPL 中打印一个无限序列，它将会冻结。
- en: Here, Clojure is resolving first one element and then five of the collection
    `r` because it needs to print them in the REPL.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Clojure 首先解析集合 `r` 中的一个元素，然后解析五个元素，因为它需要在 REPL 中打印它们。
- en: Tip
  id: totrans-888
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Lazy evaluation just works for collections and for sequence processing. Other
    operations (such as additions, method calls, and so on), are executed eagerly.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估仅适用于集合和序列处理。其他操作（如加法、方法调用等）是立即执行的。
- en: The interesting part is that you can define a new lazy collection by applying
    functions like filter and map to a certain collection.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你可以通过将函数如 filter 和 map 应用到某个集合上来定义一个新的惰性集合。
- en: 'For instance, let''s get a new collection that contains all odd numbers:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们获取一个包含所有奇数的新的集合：
- en: '[PRE129]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now, `odd-numbers` is an infinite sequence of odd numbers and we have just
    asked for three of them. Whenever a number is already computed, it is not computed
    again. Let''s change our collection a little bit in order to understand how this
    works:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`odd-numbers` 是一个奇数的无限序列，我们刚刚请求了其中的三个。每当一个数字已经被计算，它就不会再次被计算。让我们稍微改变一下我们的集合，以便理解它是如何工作的：
- en: '[PRE130]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: As you can see, some numbers get calculated first; you shouldn't expect or rely
    on a particular number of elements to be precomputed at a certain time.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，一些数字首先被计算；你不应该期望或依赖于在特定时间预先计算特定数量的元素。
- en: Also, keep in mind that the computation isn't executed again when we ask for
    the same number of elements, since it has been already cached.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，当我们请求相同数量的元素时，计算不会再次执行，因为它已经被缓存。
- en: Summary
  id: totrans-897
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Collections and functional programming in Clojure are extremely powerful tools
    that allow us to use a completely different paradigm of programming.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，集合和函数式编程是非常强大的工具，允许我们使用完全不同的编程范式。
- en: 'Here''s what we have learned so far:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学到了以下内容：
- en: The mechanics of immutable collections and what each collection type in Clojure
    is best for
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变集合的机制以及 Clojure 中每种集合类型最适合做什么
- en: How sequence abstraction and how a lot of Clojure functions are available to
    work on collections, using this abstraction
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列抽象以及许多 Clojure 函数如何使用这种抽象在集合上工作
- en: How functional programming enables us to write simpler programs that work better
    in parallel environments and help us save resources using laziness
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程如何使我们能够编写更简单的程序，这些程序在并行环境中表现更好，并帮助我们通过惰性节省资源
- en: In the subsequent chapters, we will learn about other new Clojure features that
    give us a new and much more powerful way to implement polymorphism than what Java
    offers.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的章节中，我们将学习其他新的 Clojure 功能，这些功能为我们提供了比 Java 提供的更新、更强大的实现多态的方法。
- en: Chapter 5. Multimethods and Protocols
  id: totrans-904
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。多态方法和协议
- en: We now have a better understanding of how Clojure works; we understand how to
    perform simple operations with immutable data structures but we are missing some
    features that could make our lives much easier.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Clojure 的工作方式有了更好的理解；我们理解了如何使用不可变数据结构执行简单操作，但我们缺少一些可以使我们的生活更加容易的功能。
- en: If you have been a Java programmer for a while, you are probably thinking about
    polymorphism and its particular flavor in Java.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经是一名 Java 程序员一段时间了，你可能会想到多态及其在 Java 中的特定风味。
- en: Polymorphism is one of the concepts that enable us to reuse a code. It gives
    us the ability to interact with different objects with the same API.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是我们能够重用代码的概念之一。它赋予我们与不同对象使用相同 API 交互的能力。
- en: Clojure has a powerful polymorphism paradigm that allows us to write simple
    code, create code that interacts with types that don't exist yet, and extend code
    in ways it wasn't devised for when a programmer wrote it.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 有一个强大的多态范式，它允许我们编写简单的代码，创建与尚未存在的类型交互的代码，并在程序员编写代码时以它未设计的方式扩展代码。
- en: 'To help us with polymorphism in Clojure, we have two important concepts that
    we will cover in this chapter:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们在 Clojure 中实现多态，我们有两个重要的概念，我们将在本章中介绍：
- en: Multimethods
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态方法
- en: Protocols
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议
- en: Each of them has its own use cases and things it is best at; we will look into
    them in the next section.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都有其自己的用例和它最擅长的事情；我们将在下一节中探讨它们。
- en: We will learn each of these different concepts by reviewing what we already
    know from Java and then we will learn similar concepts from Clojure that give
    us much more power.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过回顾我们从 Java 中已经了解的知识来学习这些不同的概念，然后我们将从 Clojure 中学习类似的概念，这些概念给我们带来了更多的力量。
- en: Polymorphism in Java
  id: totrans-914
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 中的多态
- en: 'Java uses polymorphism heavily, its collection API is based on it. Probably
    the best examples of polymorphism in Java are the following classes:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: Java 严重使用多态，其集合 API 基于它。Java 中多态的最好例子可能是以下这些类：
- en: '`java.util.List`'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.List`'
- en: '`java.util.Map`'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Map`'
- en: '`java.util.Set`'
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Set`'
- en: We know that depending on our use case we should use a particular implementation
    of these data structures.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，根据我们的用例，我们应该使用这些数据结构的一个特定实现。
- en: If we prefer to use an ordered Set, we might use a TreeSet.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更喜欢使用有序集，我们可能会使用 TreeSet。
- en: If we need a Map in a concurrent environment, we will use a `java.util.concurrent.ConcurrentHashMap`.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在并发环境中使用 Map，我们将使用 `java.util.concurrent.ConcurrentHashMap`。
- en: The beautiful thing is that you can write your code using the `java.util.Map`
    and `java.util.Set` interfaces and if you need to change to another type of Set
    or Map, because the conditions have changed or someone has created a better version
    of the collection for you, you don't need to change any code!
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 美妙的是，你可以使用 `java.util.Map` 和 `java.util.Set` 接口来编写你的代码，如果你需要更改到另一种类型的 Set 或
    Map，因为条件发生了变化或有人为你创建了一个更好的集合版本，你不需要更改任何代码！
- en: Lets look at a very simple example of polymorphism in Java.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Java 中多态的一个非常简单的例子。
- en: 'Imagine that you have a Shapes hierarchy; it might look similar to the following
    code:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个形状层次结构；它可能看起来像以下代码：
- en: '[PRE131]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'You surely are aware of the power of this concept, you can now calculate the
    summation of all the areas of a collection of figures, such as this:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定已经意识到了这个概念的力量，你现在可以计算一组图形的所有面积的总和，如下所示：
- en: '![Polymorphism in Java](img/B04289_05_01.jpg)'
  id: totrans-927
  prefs: []
  type: TYPE_IMG
  zh: '![Java 中的多态](img/B04289_05_01.jpg)'
- en: The `totalArea` method doesn't care about the specific types of shapes that
    you pass to it and you can add new types of shapes, such as rectangles or trapezoids.
    Your same code will now work with new data types.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalArea` 方法不关心你传递给它的具体形状类型，你可以添加新的形状类型，例如矩形或梯形。现在，你的相同代码将能够处理新的数据类型。'
- en: Now, with the same Java code base, imagine that you wanted to add a new function
    to your shape interface, something simple, such as a `getPerimeter` method.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用相同的 Java 代码库，假设你想要向你的形状接口添加一个新函数，比如一个简单的 `getPerimeter` 方法。
- en: This seems quite simple; you will have to modify each class that implements
    the Shape interface. I'm sure you've faced this problem a lot of times when you
    don't have access to the base source. The solution is to write a wrapper around
    your Shape objects but this introduces more classes and incidental complexity.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当简单；你将不得不修改实现 Shape 接口的所有类。我确信你多次遇到过当你无法访问基源时的问题。解决方案是围绕你的 Shape 对象编写包装器，但这引入了更多的类和偶然的复杂性。
- en: Clojure has its own idea of polymorphism, it is much simpler but also very powerful;
    you can in fact solve the perimeter problem with it in a very simple way.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 有它自己对多态的想法，它更简单但也很强大；实际上，你可以用一个非常简单的方法解决周长问题。
- en: One way to solve this is with multimethods; lets have a look at how they work.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用多方法；让我们看看它们是如何工作的。
- en: Multimethods in Clojure
  id: totrans-933
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure 中的多方法
- en: Multimethods are similar to interfaces, they allow you to write a common contract
    and then a family of functions can fulfill that interface with a specific implementation.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 多方法类似于接口，它们允许你编写一个通用合同，然后一个函数族可以用特定的实现来满足该接口。
- en: They are extremely flexible, as you will see they grant you a very fine control
    over what function is going to get invoked for a specific data object.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 它们非常灵活，正如你将看到的，它们让你能够非常精细地控制对特定数据对象将要调用哪个函数。
- en: 'Multimethods consist of three parts:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 多方法由三个部分组成：
- en: A function (or method) declaration
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数（或方法）声明
- en: A dispatch function
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分派函数
- en: Each possible implementation of the function
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的每种可能实现
- en: One of the most interesting features of multimethods is that you can implement
    new functions for already existing types without having to write wrappers around
    your currently existing object.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 多方法最有趣的特点之一是，你可以在不围绕现有对象编写包装器的情况下为现有类型实现新函数。
- en: 'The multimethod declaration works the same way as the interface; you define
    a common contract for the polymorphic function, as shown:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 多方法声明与接口的工作方式相同；您为多态函数定义一个公共契约，如下所示：
- en: '[PRE132]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `defmulti` macro defines the contract for your multimethod, it consists
    of:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '`defmulti` 宏定义了您的多方法的契约，它由以下部分组成：'
- en: The multimethod's name
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多方法的名称
- en: An optional `doctstring` (this is the documentation string)
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的 `doctstring`（这是文档字符串）
- en: The attribute map
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性映射
- en: The `dispatch-fn` function
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch-fn` 函数'
- en: Note
  id: totrans-948
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `dispatch` function gets called for every piece of content; it generates
    a dispatch key that is later checked against its function implementation. When
    the dispatch key and the key in the function implementation match, the function
    is called.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每块内容，都会调用 `dispatch` 函数；它生成一个分派键，稍后将其与函数实现中的键进行比较。当分派键与函数实现中的键匹配时，调用该函数。
- en: The `dispatch` function receives the same parameters that the function you are
    calling receives and returns a dispatch key that is used to determine the function
    that should dispatch the request.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch` 函数接收与您正在调用的函数相同的参数，并返回一个用于确定应分派请求的函数的分派键。'
- en: Each implementation function must define a dispatch key, if it matches with
    the `dispatch` function's result, then this function is executed.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实现函数都必须定义一个分派键，如果它与 `dispatch` 函数的结果匹配，则执行此函数。
- en: 'An example should clarify:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子应该可以澄清：
- en: '[PRE133]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Here, we are defining a multimethod called `area`; the `defmulti` statement
    has the following structure:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `area` 的多方法；`defmulti` 语句具有以下结构：
- en: '[PRE134]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In this case, the multimethod is called `area` and the `dispatch` function is
    the `:shape` keyword.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，多方法被命名为 `area`，而 `dispatch` 函数是 `:shape` 关键字。
- en: Note
  id: totrans-957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, keywords can be used as functions that look up themselves in maps.
    So, for example, the result of (`:shape {:shape :square}`) is `:square`.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，关键字可以用作在映射中查找自己的函数。所以，例如，(`:shape {:shape :square}`) 的结果是 `:square`。
- en: 'Afterwards, we define a method, as shown:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们定义一个方法，如下所示：
- en: '[PRE135]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Note that the `dispatch-key` is always the result of invoking the `dispatch-function`
    with `params` as parameters.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`dispatch-key` 总是调用 `dispatch-function` 并以 `params` 作为参数的结果。
- en: 'Finally, let''s look at the invocation, `(area {:shape :square :side 5})` which
    is calling a multimethod. The first thing that happens is that we call the dispatch
    function `:shape`, as shown:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看调用，`(area {:shape :square :side 5})`，这是在调用一个多方法。首先发生的事情是我们调用分派函数 `:shape`，如下所示：
- en: '[PRE136]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The `:square` function is now the dispatch key, we need to look for the method
    that has that dispatch key; in this case, the only method that we defined works.
    So, the function is executed and we get the result of `25`.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `:square` 函数是分派键，我们需要寻找具有该分派键的方法；在这种情况下，我们定义的唯一方法就是它。因此，函数被执行，我们得到 `25` 的结果。
- en: 'It is pretty simple to add the area and perimeter for both square and circle,
    lets check the implementation:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 为正方形和圆形添加面积和周长非常简单，让我们检查一下实现：
- en: '[PRE137]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Now, we have defined how to calculate the perimeter and area of circles and
    squares with very little effort and without having to define a very strict object
    hierarchy. However, we are just starting to uncover the power of multimethods.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们用很少的努力就定义了如何计算圆和正方形的周长和面积，而且无需定义一个非常严格的对象层次结构。然而，我们才刚刚开始揭示多方法的力量。
- en: Note
  id: totrans-968
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keywords can be namespaced, it allows you to keep your code better organized.
    There are two ways to define a namespaced keyword, such as `:namespace/keyword`
    and `::keyword`. When using the `::` notation, the used namespace is the current
    namespace. So if you write `::test` in the REPL, you will be defining `:user/test`.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字可以有命名空间，这有助于您更好地组织代码。有两种方式可以定义命名空间关键字，例如 `:namespace/keyword` 和 `::keyword`。当使用
    `::` 符号时，使用的命名空间是当前命名空间。所以如果您在 REPL 中写 `::test`，您将定义 `:user/test`。
- en: 'Let''s try another example, copy the following code into your REPL:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个例子，将以下代码复制到您的 REPL 中：
- en: '![Multimethods in Clojure](img/B04289_05_02.jpg)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
  zh: '![Clojure 中的多方法](img/B04289_05_02.jpg)'
- en: As you can see, it just works as you might expect it to. However, let's see
    how you can create a keyword hierarchy to be a little bit more flexible than this.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它的工作方式正如您所期望的那样。然而，让我们看看如何创建一个关键字层次结构，使其比这更灵活一些。
- en: Keyword hierarchies
  id: totrans-973
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字层次结构
- en: 'You can declare that a keyword derives from another keyword and then respond
    to other dispatch keys, for that you can use the `derive` function:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以声明一个关键字从另一个关键字派生，然后响应其他分派键，为此您可以使用 `derive` 函数：
- en: '[PRE138]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Tip
  id: totrans-976
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When defining a keyword hierarchy, you have to use namespaced keywords.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义关键字层次结构时，你必须使用命名空间关键字。
- en: 'Here, you are declaring that the `::hominid` key is derived from the `::animal`
    key and you can now use `::hominid` as `::animal`; let''s see that now:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你声明`::hominid`键是从`::animal`键派生出来的，你现在可以使用`::hominid`作为`::animal`；让我们看看现在的情况：
- en: '[PRE139]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'We do have some problems when defining hierarchies, for instance what will
    happen if the same keyword were to be derived from two conflicting keywords? Let''s
    give it a try:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义层次结构时，我们确实会遇到一些问题，例如，如果相同的关键字从两个冲突的关键字派生出来会发生什么？让我们试一试：
- en: '[PRE140]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: We get an error that says, there are two methods that match the dispatch value.
    Since our hominid derives both from animal and primate, it doesn't know which
    to resolve.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个错误，说有两个方法匹配分发值。由于我们的hominid既从animal派生，又从primate派生，它不知道该解析哪个。
- en: 'We can work this out explicitly with:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下方式明确地解决这个问题：
- en: '[PRE141]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Now, everything works correctly. We know that we prefer to resolve to a primate
    when calling the walk multimethod with the hominid key.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切工作正常。我们知道在调用带有hominid键的walk多方法时，我们更喜欢解析为灵长类动物。
- en: 'You can also define a more specific method, just for the `hominid` key:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义一个更具体的方法，仅针对`hominid`键：
- en: '[PRE142]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The derivation hierarchy can get a little complex and we might need some functions
    to introspect relationships. Clojure has the following functions to work with
    type hierarchies.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 派生层次结构可能会变得有些复杂，我们可能需要一些函数来检查关系。Clojure有以下函数来处理类型层次结构。
- en: '`isa?`'
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isa?`'
- en: '`parents`'
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parents`'
- en: '`descendants`'
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`descendants`'
- en: '`underive`'
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`underive`'
- en: isa?
  id: totrans-993
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isa?
- en: The `isa` function checks if a type derives from some other type, it works with
    Java classes as well as Clojure keywords.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '`isa`函数检查一个类型是否从另一个类型派生，它既与Java类一起工作，也与Clojure关键字一起工作。'
- en: 'It is simple to explain with examples:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 用例子来说明很简单：
- en: '[PRE143]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: parents
  id: totrans-997
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: parents
- en: 'The `parent` function returns a set of a type''s parents, they might be Java
    or Clojure keywords:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent`函数返回一个类型的父集，它们可能是Java或Clojure关键字：'
- en: '[PRE144]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: descendants
  id: totrans-1000
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: descendants
- en: 'The `descendants` function, as you can imagine, returns a set of descendants
    of the `passd` keyword; it is important to keep in mind that in this case only
    Clojure keywords are allowed:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，`descendants`函数返回`passd`关键字的子集；重要的是要记住，在这种情况下，只允许Clojure关键字：
- en: '[PRE145]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: underive
  id: totrans-1003
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: underive
- en: 'The `underive` function breaks the relation between two types, as you can imagine
    it only works with the Clojure keywords:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，`underive`函数打破了两个类型之间的关系，它只与Clojure关键字一起工作：
- en: '[PRE146]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: This function will normally be used at development time and they allow you to
    play around with your type hierarchy in a very simple and dynamic way.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通常在开发时间使用，并且允许你以非常简单和动态的方式玩转你的类型层次结构。
- en: A la carte dispatch functions
  id: totrans-1007
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按需分发函数
- en: 'Until now, we have used a keyword as a dispatch function but you can use any
    function you like with as many arguments as you want. Let''s take a look at some
    examples:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用关键字作为分发函数，但你可以使用任何你喜欢的函数，并且可以传递任意数量的参数。让我们看看一些例子：
- en: '[PRE147]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'This is a simple function, but it shows two important facts:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，但它展示了两个重要的事实：
- en: The `dispatch` function can receive more than one argument
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch`函数可以接收多个参数'
- en: The `dispatch` key can be anything, not just a keyword
  id: totrans-1012
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch`键可以是任何东西，不仅仅是关键字'
- en: 'Lets have a look at how we can use this `dispatch` function:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这个`dispatch`函数：
- en: '[PRE148]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: We are getting to know the `dispatch` function a little bit better; now that
    you know that you can implement any `dispatch` function, you have a very fine
    grained control over what function gets called and when.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`dispatch`函数有了更深入的了解；现在你知道你可以实现任何`dispatch`函数，你就可以非常精细地控制哪个函数会被调用以及何时调用。
- en: 'Lets look at one more example, so we can finally grasp the complete idea:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子，这样我们就可以最终完全理解这个概念：
- en: '![A la carte dispatch functions](img/B04289_05_03.jpg)'
  id: totrans-1017
  prefs: []
  type: TYPE_IMG
  zh: '![按需分发函数](img/B04289_05_03.jpg)'
- en: Now the true power of multimethods becomes apparent. You now have an adhoc way
    of defining polymorphic functions which has the possibility to define type hierarchies
    and even execute your own logic to determine the function that is going to be
    called finally.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，多方法的真正力量变得明显。你现在有一种定义多态函数的临时方法，它有定义类型层次结构和执行自己的逻辑以确定最终要调用的函数的可能性。
- en: Protocols in Clojure
  id: totrans-1019
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure中的协议
- en: Multimethods are just one of the options for polymorphism you have in Clojure,
    there are other ways to implement polymorphic functions.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 多方法只是Clojure中实现多态性的一个选项，还有其他方法可以实现多态函数。
- en: Protocols are a little easier to understand and they might feel more similar
    to Java interfaces.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 协议更容易理解，它们可能感觉更类似于Java接口。
- en: 'Lets try to define our shape program using protocols:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用协议定义我们的形状程序：
- en: '[PRE149]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Here, we have defined a protocol and it is called shaped and everything that
    implements this protocol must implement the following two functions: `perimeter`
    and `area`.'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个协议，它被称为shaped，并且实现此协议的所有内容都必须实现以下两个函数：`perimeter`和`area`。
- en: There are a number of ways to implement a protocol; one interesting feature
    is that you can even extend Java classes to implement a protocol without an access
    to the Java source and without having to recompile anything.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 实现协议有多种方式；一个有趣的特点是，你甚至可以在没有访问Java源代码的情况下，无需重新编译任何内容，将Java类扩展为实现协议。
- en: Let's start by creating a record that implements the type.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个实现该类型的记录开始。
- en: Records in Clojure
  id: totrans-1027
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clojure中的记录
- en: Records work exactly like maps, but they are much faster if you stick to the
    predefined keys. Defining a record is similar to defining a class, Clojure knows
    beforehand about the fields that the record will have, so it can generate byte
    code on the fly and the code that uses the records is much faster.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的工作方式与映射完全一样，但如果你坚持使用预定义的键，它们会更快。定义一个记录类似于定义一个类，Clojure事先知道记录将有哪些字段，因此它可以即时生成字节码，使用记录的代码会更快。
- en: 'Lets define a `Square` record, as shown:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个`Square`记录，如下所示：
- en: '[PRE150]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Here, we are defining the `Square` record and it has the following properties:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义`Square`记录，并且它具有以下属性：
- en: It has only one field, `size`; this is going to work as a map with only the
    side key
  id: totrans-1032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只有一个字段，`size`；这将作为一个只有边键的映射来工作。
- en: It implements the `Shape` protocol
  id: totrans-1033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它实现了`Shape`协议
- en: 'Lets have a look at how a record is instantiated and how we can use it:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实例化一个记录以及我们如何使用它：
- en: '[PRE151]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'As you can see it works exactly like a map, you can even associate things to
    it:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它的工作方式与映射完全一样，你甚至可以将其与事物关联：
- en: '[PRE152]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The downside of doing this is that we no longer have the performance guarantees
    that we had when defining just the record fields; nonetheless, it is a great way
    of giving some structure to our code.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的缺点是，我们不再有定义记录字段时拥有的性能保证；尽管如此，这仍然是一种为我们的代码提供一些结构的好方法。
- en: 'We still have to check how we can use our perimeter and area functions, it
    is pretty simple. Let''s have a look:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要检查我们如何使用我们的周长和面积函数，这很简单。让我们看看：
- en: '[PRE153]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Just to continue with the example, let''s define the `Circle` record:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了继续这个例子，让我们定义`Circle`记录：
- en: '[PRE154]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: One of the promises was that we will be able to extend our existing records
    and types without having to touch the current code. Well, lets keep to that promise
    and check how to extend our records without having to touch existing code.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个承诺是我们将能够扩展我们的现有记录和类型，而无需触及当前代码。好吧，让我们遵守这个承诺，并检查如何扩展我们的记录而无需触及现有代码。
- en: 'Imagine, we need to add a predicate telling us whether a shape has an area
    or not; we might then define the next protocol, as shown:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要添加一个谓词来告诉我们一个形状是否有面积；然后我们可以定义下一个协议，如下所示：
- en: '[PRE155]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Let''s get directly to the extend type, which is going to help us define this
    `num-sides` function for our old protocols. Note that with `extend-type` we can
    even define functions for existing Java types:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入扩展类型，这将帮助我们为我们的旧协议定义`num-sides`函数。注意，使用`extend-type`，我们甚至可以为现有的Java类型定义函数：
- en: '[PRE156]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Protocols become much more interesting when you extend them for Java types.
    Lets create a protocol that includes some functions for list like structures:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为Java类型扩展协议时，协议变得更加有趣。让我们创建一个包括一些列表结构函数的协议：
- en: '[PRE157]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'And now you can use the positive values, negative values and `non-zero-values`
    with anything that extends from `java.util.List`, including Clojure''s vectors:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用正数、负数和`non-zero-values`与从`java.util.List`扩展的任何东西一起使用，包括Clojure的向量：
- en: '[PRE158]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: It might not be very exciting to extend `java.util.List`, since you can define
    these three as functions and it works the same way but you can extend any custom
    Java type with this mechanism.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`java.util.List`可能并不那么令人兴奋，因为你可以将这三个定义为函数，并且它们以相同的方式工作，但你可以用这种机制扩展任何自定义的Java类型。
- en: Summary
  id: totrans-1053
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Now we understand Clojure''s way a little bit better and we have a better grasp
    of what to look for when we need polymorphism. We understand that when needing
    a polymorphic function we have several options:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Clojure的方式有了更好的理解，并且当我们需要多态性时，我们有了更好的把握。我们了解到，当需要多态函数时，我们有几个选项：
- en: We can implement multimethods if we need a highly customized dispatching mechanism
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要一个高度定制的分派机制，我们可以实现多方法
- en: We can implement multimethods if we need to define a complex inheritance structure
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们需要定义复杂的继承结构，我们可以实现多方法
- en: We can implement a protocol and define a custom type that implements that protocol
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以实现一个协议并定义一个实现该协议的自定义类型
- en: We can define a protocol and extend existing Java or Clojure types with our
    custom functions for each type
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以定义一个协议并使用我们的自定义函数扩展现有的Java或Clojure类型
- en: Polymorphism in Clojure is very powerful. It allows you to extend the functionality
    of Clojure or Java types that already exist; it feels like adding methods to an
    interface. The best thing about it is that you don't need to redefine or recompile
    anything.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure的多态非常强大。它允许您扩展已存在的Clojure或Java类型的函数；感觉就像向接口添加方法。最好的事情是您不需要重新定义或重新编译任何东西。
- en: In the next chapter, we will talk about concurrency—one of the key features
    of Clojure. We will learn about the idea of what the identity and values are and
    how those key concepts make writing concurrent programs much easier.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论并发——Clojure的关键特性之一。我们将了解身份和值的理念以及这些关键概念如何使编写并发程序变得更容易。
- en: Chapter 6. Concurrency
  id: totrans-1061
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 并发
- en: Programming has changed, in the past we could just rely on computers getting
    faster year after year. This is proving to be more and more difficult; so, hardware
    manufacturers are taking a different approach. Now, they are embedding more processors
    into computers. Nowadays, it's not uncommon to see phones with just or four cores.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 编程已经发生了变化，在过去，我们只需依赖计算机每年变得更快。这变得越来越困难；因此，硬件制造商正在采取不同的方法。现在，他们正在将更多的处理器嵌入到计算机中。如今，看到只有或四个核心的手机并不罕见。
- en: This calls for a different way of writing software, one in which we are able
    to execute some tasks in other processes, explicitly. The modern languages are
    trying to make this task feasible and easier for modern developers, and Clojure
    is no exception.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一种不同的软件编写方式，其中我们能够明确地在其他进程中执行一些任务。现代语言正在努力使这项任务对现代开发者来说可行且更容易，Clojure也不例外。
- en: 'In this chapter, we will see how Clojure enables you to write simple concurrent
    programs by reviewing Clojure''s core concepts and primitives; in particular,
    we need to understand the concept of identity and value that Clojure has embedded
    into the language. In this chapter, we will cover the following topics:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过回顾Clojure的核心概念和原语来了解Clojure如何使您能够编写简单的并发程序；特别是，我们需要理解Clojure嵌入到语言中的身份和值的概念。在本章中，我们将涵盖以下主题：
- en: Using your Java knowledge
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的Java知识
- en: The Clojure model of state and identity
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure的状态和身份模型
- en: Promises
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺
- en: Futures
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期货
- en: Software transactional memory and refs
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件事务内存和refs
- en: Atoms
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子
- en: Agents
  id: totrans-1071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Validators
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证器
- en: Watchers
  id: totrans-1073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Using your Java knowledge
  id: totrans-1074
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用您的Java知识
- en: Knowing Java and your way around Java's threading APIs gives you a great advantage,
    since Clojure relies on the tools that you already know.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Java以及熟悉Java的线程API给您带来了很大的优势，因为Clojure依赖于您已经知道的工具。
- en: Here, you'll see how to use threads and you can extend everything you see here
    to execute other services.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将了解如何使用线程，并且可以将这里看到的一切扩展到执行其他服务。
- en: Before going any further, let's create a new project that we'll use as a sandbox
    for all of our tests.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们创建一个新的项目，我们将将其用作所有测试的沙盒。
- en: 'Create it, as shown in the following screenshot:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示创建它：
- en: '![Using your Java knowledge](img/B04289_06_01.jpg)'
  id: totrans-1079
  prefs: []
  type: TYPE_IMG
  zh: '![使用您的Java知识](img/B04289_06_01.jpg)'
- en: 'Modify the `clojure-concurrency.core` namespace, so that it looks similar to
    the following code snippet:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`clojure-concurrency.core`命名空间，使其看起来类似于以下代码片段：
- en: '[PRE159]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'It''s easy to understand what''s happening here. We are creating a thread with
    our function and then starting it; so that we can use it in the REPL, as follows:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 这里很容易理解正在发生的事情。我们正在创建一个带有我们的函数的线程，然后启动它；这样我们就可以在REPL中使用它，如下所示：
- en: '![Using your Java knowledge](img/B04289_06_02.jpg)'
  id: totrans-1083
  prefs: []
  type: TYPE_IMG
  zh: '![使用您的Java知识](img/B04289_06_02.jpg)'
- en: Tip
  id: totrans-1084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`java.lang.Thread` has a constructor, which receives an object implementing
    the runnable interface. You can just pass a Clojure function because every function
    in Clojure implements runnable and callable interfaces. This means that you can
    also use the executors transparently in Clojure!'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Thread`有一个构造函数，它接收一个实现可运行接口的对象。您可以直接传递一个Clojure函数，因为Clojure中的每个函数都实现了可运行和可调用接口。这意味着您也可以在Clojure中透明地使用执行器！'
- en: We'll see a `nil` and `Hello threaded world` values in any random order. The
    `nil` value is what the start thread returns.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到`nil`和`Hello threaded world`的值以任意顺序出现。`nil`值是启动线程返回的值。
- en: The `Hello threaded world` is a message from another thread. With this, we now
    have the basic tools to get to know and understand how threads work in Clojure.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello threaded world`是来自另一个线程的消息。有了这个，我们现在有了了解和理解Clojure中线程工作方式的基本工具。'
- en: The Clojure model of state and identity
  id: totrans-1088
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure的状态和身份模型
- en: Clojure has very strong opinions about concurrency, in order to take it in a
    simpler way it redefines what state and identity mean. Let's explore the meaning
    of this concepts in Clojure.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure对并发有非常强烈的看法，为了以更简单的方式理解它，它重新定义了状态和身份的含义。让我们来探讨Clojure中这些概念的含义。
- en: When talking about state in Java, you probably think about the values of the
    attributes of your Java classes. The state in Clojure is similar to Java, it refers
    to the values of objects but there are very important differences that allow simpler
    concurrency.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论Java中的状态时，你可能想到的是你的Java类属性值。Clojure中的状态与Java类似，它指的是对象的值，但有一些非常重要的区别，这允许更简单的并发。
- en: 'In Clojure, identity is an entity that might have different values over time.
    Consider the following examples:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，身份是一个可能在时间上具有不同值的实体。考虑以下例子：
- en: I have an identity; I will be and continue being this particular individual,
    my opinions, ideas, and appearance might change over time but I am the same individual
    with the same identity.
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我有一个身份；我会继续是这一特定个体，我的观点、想法和外观可能会随时间而改变，但我始终是同一个具有相同身份的个体。
- en: You have a bank account; it has a particular number and is run by a particular
    bank. The amount of money you have in it changes over time, but it is the same
    bank account.
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个银行账户；它有一个特定的号码，由特定的银行运营。你账户中的金额会随时间变化，但它始终是同一个银行账户。
- en: Consider a ticker symbol (such as GOOG), it identifies a stock in the stock
    market; the value associated with it changes over time, but not its identity.
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一个股票代码（例如GOOG），它在股市中标识一支股票；与其相关的价值会随时间变化，但其身份不会改变。
- en: '**State** is a value that an identity took at some point in time. One of its
    important features is that it is immutable. State is a snapshot of an identity''s
    value at some given time.'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**是身份在某个时间点所采取的值。它的一个重要特征是不可变性。状态是身份在某个给定时间点的值的快照。'
- en: 'So, in the previous examples:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在先前的例子中：
- en: Who you are right now, how you feel, how you look, and what you think is your
    current state
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你现在的身份、你的感受、你的外表以及你的想法是你的当前状态
- en: The money you currently have in your bank account is its current state
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你目前在银行账户中的钱是其当前状态
- en: The value of the GOOG stock is its current state
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GOOG股票的价值是其当前状态
- en: All of these states are immutable; it doesn't matter who you are tomorrow or
    how much you win or spend. It is true and it will always be true that in this
    particular moment in time you have a certain state.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些状态都是不可变的；无论你明天是谁，无论你赢了多少或花了多少，这个事实都是真实的，并且始终是真实的，即在特定的时刻，你处于某种状态。
- en: Tip
  id: totrans-1101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Rich Hickey, Clojure's author, is a great talker and has several talks in which
    he explains the ideas and philosophy behind Clojure. In one of them, (Are We There
    Yet?) he explains this idea of state, identity, and time very extensively.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure的作者Rich Hickey是一位出色的演讲者，他有很多演讲，其中解释了Clojure背后的思想和哲学。在其中一个演讲（Are We There
    Yet?）中，他非常详细地解释了状态、身份和时间这个概念。
- en: 'Let''s now explain the two key concepts in Clojure:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释Clojure中的两个关键概念：
- en: '**Identity**: Throughout your whole life, you have a single identity; you never
    stop being you, even if you keep changing throughout your whole life.'
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份**：在你的一生中，你有一个单一的身份；你永远不会停止成为你自己，即使你在整个一生中都在不断变化。'
- en: '**State**: At any given moment in your life, you are a certain person with
    likes, dislikes, and some beliefs. We call this way of being at a moment of your
    life, the state. If you look at a particular moment in your life, you will see
    a fixed value. Nothing will change the fact that you were the way you were in
    that moment in time. That particular state is immutable; over time, you have different
    states or values, but each of those states is immutable.'
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：在生活的任何时刻，你都是一个特定的人，有喜好、厌恶和某些信念。我们称这种在生活某一时刻的存在方式为状态。如果你看生活中的一个特定时刻，你会看到一个固定的值。没有任何事情会改变你在那个时刻的样子。那个特定的状态是不可变的；随着时间的推移，你会有不同的状态或值，但每个状态都是不可变的。'
- en: We use this fact to write simpler concurrent programs. Whenever you want to
    interact with an identity, you look at it and you get its current value (a snapshot
    at the time), and then you operate with what you have.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用这一事实来编写更简单的并发程序。每当你想与一个身份进行交互时，你查看它并获取其当前值（一个时间快照），然后使用你所拥有的进行操作。
- en: In imperative programming, you normally have a guarantee that you have the latest
    value but it is very difficult to keep it in a consistent state. The reason for
    this is that you are relying on a shared mutable state.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，你通常有一个保证你拥有最新的值，但很难保持其一致性状态。原因在于你依赖于共享的可变状态。
- en: A shared mutable state is the reason why you need to use a synchronized code,
    locks, and mutexes. It is also the reason for very complex programs, with difficult
    bugs to track.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 共享的可变状态是为什么你需要使用同步代码、锁和互斥锁的原因。它也是复杂程序和难以追踪的bug的原因。
- en: Nowadays, Java is learning the lessons from other programming languages and
    now it has primitives that allow simpler concurrent programming. These ideas are
    taken from other languages and newer ideas, so there is a good chance that someday
    you'll see similar concepts to what you'll study here in other mainstream programming
    languages.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Java正在从其他编程语言中吸取教训，现在它有了允许更简单并发编程的原语。这些想法来自其他语言和新的想法，所以你有一天可能会在其他主流编程语言中看到与这里所学相似的概念。
- en: There is no guarantee that you'll always have the latest value, but don't worry,
    you just have to think about things differently and use the concurrency primitives
    that Clojure gives you.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 没有保证你总能获得最新的值，但不用担心，你只需换一种思维方式，并使用Clojure提供的并发原语即可。
- en: This is similar to how you work in real life, you don't know exactly what's
    happening with all of your friends or co-workers when you do something for them;
    you talk to them, get the current facts, and then go and get working. While you
    are at it, something needs to change; in this case we need a coordination mechanism.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你在现实生活中工作的方式类似，当你为朋友或同事做某事时，你不知道他们具体发生了什么；你与他们交谈，获取当前事实，然后去工作。在你做这件事的时候，有些事情需要改变；在这种情况下，我们需要一个协调机制。
- en: Clojure has various such coordination mechanisms, let's have a look at them.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有各种这样的协调机制，让我们来看看它们。
- en: Promises
  id: totrans-1113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承诺
- en: If you are a full stack Java developer, there is a good chance that you have
    met promises in JavaScript.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名全栈Java开发者，你很可能在JavaScript中遇到过承诺。
- en: Promises are simple abstractions that don't impose strict requirements on you;
    you can use them to calculate the result on some other thread, light process,
    or anything you like.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是简单的抽象，不会对你提出严格的要求；你可以使用它们在另一个线程、轻量级进程或任何你喜欢的地方计算结果。
- en: In Java, there are a couple of ways to achieve this; one of them is with futures
    (`java.util.concurrentFuture`) and if you want something more similar to JavaScript's
    promise there is a nice implementation called **jdeferred** ([https://github.com/jdeferred/jdeferred](https://github.com/jdeferred/jdeferred)),
    which you might have used before.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，有几种方法可以实现这一点；其中之一是使用未来（`java.util.concurrentFuture`），如果你想得到更类似于JavaScript的承诺的实现，有一个叫做**jdeferred**（[https://github.com/jdeferred/jdeferred](https://github.com/jdeferred/jdeferred)）的很好的实现，你可能之前已经使用过。
- en: 'In essence a promise is just a promise that you can give to your caller, the
    caller can use it at any given time. There are two possibilities:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，承诺只是你可以提供给调用者的一个承诺，调用者可以在任何给定时间使用它。有两种可能性：
- en: If the promise has already been fulfilled, the call returns immediately
  id: totrans-1118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果承诺已经得到履行，调用将立即返回
- en: If not, the caller will block until the promise is fulfilled
  id: totrans-1119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是，调用者将阻塞，直到承诺得到履行
- en: 'Let''s take a look at an example; remember to use the start-thread function
    in the `clojure-concurrency.core` package:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子；记得使用`clojure-concurrency.core`包中的`start-thread`函数：
- en: '![Promises](img/B04289_06_03.jpg)'
  id: totrans-1121
  prefs: []
  type: TYPE_IMG
  zh: '![承诺](img/B04289_06_03.jpg)'
- en: Tip
  id: totrans-1122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Promises are only calculated once and then cached. So don't worry about using
    them as many times as you like once it has been calculated, there is no runtime
    cost associated!
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺只计算一次并缓存。所以一旦计算完成，你就可以随意多次使用它们，没有运行时成本！
- en: Let's stop here and analyze the code, we are creating a promise called `p` and
    then we start a thread that does two things.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里停下来分析代码，我们正在创建一个名为`p`的承诺，然后我们启动一个线程执行两件事。
- en: It tries to get a value from `p` (the `deref` function tries to read the value
    from a promise) and then prints `Hello world`.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图从 `p`（`deref` 函数试图从承诺中读取值）获取一个值，然后打印 `Hello world`。
- en: We won't see the `Hello world` message just yet; we will instead see a `nil`
    value. Why is that?
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在还看不到 `Hello world` 消息；相反，我们会看到一个 `nil` 值。那是什么原因呢？
- en: The start thread returns the `nil` value and what happens now is what we described
    in the first place; `p` is the promise and our new thread will block it until
    it gets a value.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 启动线程返回 `nil` 值，现在发生的事情正是我们最初描述的；`p` 是承诺，我们的新线程将阻塞它，直到它获得一个值。
- en: 'In order to see the `Hello world` message, we need to deliver the promise.
    Let''s do that now:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到 `Hello world` 消息，我们需要交付承诺。现在让我们这么做：
- en: '![Promises](img/B04289_06_04.jpg)'
  id: totrans-1129
  prefs: []
  type: TYPE_IMG
  zh: '![承诺](img/B04289_06_04.jpg)'
- en: As you can see, we now get the `Hello world` message!
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在得到了 `Hello world` 消息！
- en: 'As I said, there is no need to use another thread. Let''s now see another example
    in the REPL:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我说的，没有必要使用另一个线程。现在让我们在 REPL 中看看另一个例子：
- en: '![Promises](img/B04289_06_05.jpg)'
  id: totrans-1132
  prefs: []
  type: TYPE_IMG
  zh: '![承诺](img/B04289_06_05.jpg)'
- en: Tip
  id: totrans-1133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use `@p` instead of (`deref p`), it works for every identity in this
    chapter too.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `@p` 而不是 `deref p`，这对本章中的每个身份也适用。
- en: In this example we don't create separate threads; we create the promise, deliver
    it, and then use it in the same thread.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不会创建单独的线程；我们创建承诺，交付它，然后在同一线程中使用它。
- en: As you can see, promises are an extremely simple type of synchronization mechanism,
    you can decide whether to use threads, executor services (which are just thread
    pools), or some other mechanism, such as lightweight threads.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，承诺是一种极其简单的同步机制，您可以选择是否使用线程、执行器服务（这实际上是线程池）或某些其他机制，例如轻量级线程。
- en: Let's have a look at Pulsar library for creating lightweight threads.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Pulsar 库是如何创建轻量级线程的。
- en: Pulsar and lightweight threads
  id: totrans-1138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pulsar 和轻量级线程
- en: 'Creating a thread is an expensive operation and it consumes RAM memory. To
    know how much memory creating a thread consumes in Mac OS X or Linux, run the
    next command:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程是一个昂贵的操作，并且它会消耗 RAM 内存。为了知道在 Mac OS X 或 Linux 上创建线程消耗了多少内存，请运行以下命令：
- en: '[PRE160]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'What you see here will depend on the OS and JVM version that you are using,
    with Java 1.8u45 on Mac OS X, we get the following output:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里看到的内容将取决于您使用的操作系统和 JVM 版本，在 Mac OS X 上使用 Java 1.8u45，我们得到以下输出：
- en: '![Pulsar and lightweight threads](img/B04289_06_06.jpg)'
  id: totrans-1142
  prefs: []
  type: TYPE_IMG
  zh: '![Pulsar 和轻量级线程](img/B04289_06_06.jpg)'
- en: I am getting a stack size of 1024 kilobytes per thread. What can we do to improve
    the numbers? Other languages, such as Erlang and Go create a few threads from
    the beginning and then execute their tasks using those threads. It becomes important
    to be able to suspend a particular task and run another in the same thread.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在为每个线程获取 1024 千字节的堆栈大小。我们能做些什么来提高这些数字？其他语言，如 Erlang 和 Go，一开始就创建几个线程，然后使用这些线程执行任务。能够挂起特定任务并在同一线程中运行另一个任务变得很重要。
- en: In Clojure there is a library called **Pulsar** ([https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar)),
    which is an interface for a Java API called **Quasar** ([https://github.com/puniverse/quasar](https://github.com/puniverse/quasar)).
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中有一个名为 **Pulsar** 的库（[https://github.com/puniverse/pulsar](https://github.com/puniverse/pulsar)），它是一个名为
    **Quasar** 的 Java API 的接口（[https://github.com/puniverse/quasar](https://github.com/puniverse/quasar)）。
- en: In order to support Pulsar, as of version 0.6.2, you need to do two things.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持 Pulsar，从版本 0.6.2 开始，您需要做两件事。
- en: Add the `[co.paralleluniverse/pulsar "0.6.2"]` dependency to your project
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `[co.paralleluniverse/pulsar "0.6.2"]` 依赖项添加到您的项目中
- en: Add an instrumentation agent to your JVM (`adding :java-agents [[co.paralleluniverse/quasar-core
    "0.6.2"]]` to your `project.clj`)
  id: totrans-1147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个仪器代理添加到您的 JVM 中（在 `project.clj` 中添加 `adding :java-agents [[co.paralleluniverse/quasar-core
    "0.6.2"]]`）
- en: 'The instrumentation agent should be able to suspend functions in a thread and
    then change them for other functions. In the end, your `project.clj` file should
    look similar to:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器代理应该能够挂起线程中的函数，然后将其更改为其他函数。最后，您的 `project.clj` 文件应该看起来类似于：
- en: '[PRE161]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Let's write our last example with promises using Pulsar's lightweight threads
    called fibers.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 Pulsar 的轻量级线程（称为 fibers）编写我们的最后一个使用承诺的例子。
- en: 'Pulsar comes with its own promises in the `co.paralleluniverse.pulsar.core`
    package and they can be used as a drop-in replacement for promises in `clojure.core`:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: Pulsar 在 `co.paralleluniverse.pulsar.core` 包中提供了自己的承诺，并且可以用作 `clojure.core`
    中承诺的直接替换：
- en: '[PRE162]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'This example is a bit more interesting, we use two of Pulsar''s functions:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子更有趣一些，我们使用了 Pulsar 的两个函数：
- en: '`spawn-fiber`: This function creates a light thread, you can create thousands
    of fibers if you want in a single program. They are cheap to create and as long
    as you program them carefully, there shouldn''t be many problems coming from this.'
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spawn-fiber`：这个函数创建一个轻量级线程，如果你想在单个程序中创建数千个纤程，你可以这样做。它们创建成本低，只要你小心编程，不应该会有太多问题。'
- en: '`span-thread`: This is Pulsar''s version of start-thread, it creates a real
    thread and runs it.'
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`span-thread`：这是Pulsar的`start-thread`版本，它创建一个真实线程并运行它。'
- en: In this particular example, we calculate `p2` and `p3` in two fibers and then
    `p3` in a thread. At this point, everything is waiting for us to deliver the value
    of `p1`; we do it with the `deliver` function.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们在两个纤程中计算`p2`和`p3`，然后在线程中计算`p3`。此时，所有东西都在等待我们提供`p1`的值；我们使用`deliver`函数来完成它。
- en: Pulsar has other very interesting features that allow for simpler parallel programming,
    have a look at the documentation if you are interested. In the last part of this
    chapter, we will have a look at `core.async`. Pulsar has an interface modelled
    after `core.async`, which you can use if you like.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: Pulsar有其他非常有趣的功能，允许更简单的并行编程，如果你感兴趣，请查看文档。在本章的最后部分，我们将探讨`core.async`。Pulsar有一个基于`core.async`的接口，如果你喜欢，可以使用它。
- en: Futures
  id: totrans-1158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期货
- en: If you have been using Java for a while, you might know the `java.util.concurrent.Future`
    class, this is Clojure's implementation of futures and it is extremely similar
    to Java, only a bit simpler. Its interface and usage are almost identical to promises
    with a very important difference, when using futures everything will run in a
    different thread automatically.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用Java一段时间了，你可能知道`java.util.concurrent.Future`类，这是Clojure对期货的实现，它与Java非常相似，只是稍微简单一些。它的接口和用法几乎与承诺相同，但有一个非常重要的区别，当使用期货时，所有操作都会自动在不同的线程中运行。
- en: 'Let''s see a simple example using futures, in any REPL do the following:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用期货的一个简单示例，在任何REPL中执行以下操作：
- en: '[PRE163]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Your REPL should freeze for 20 seconds and then print `Hello world`.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 你的REPL应该冻结20秒，然后打印`Hello world`。
- en: Tip
  id: totrans-1163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Futures are also cached, so you only need to pay once for the cost of calculation
    and then you can use them any number of times you want.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 期货也是缓存的，所以你只需要为计算成本付费一次，然后你可以根据需要多次使用它们。
- en: 'At first glance, futures look much easier than promises. You don''t need to
    worry about creating threads or fibers, but there are downsides to this approach:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，期货似乎比承诺要简单得多。你不需要担心创建线程或纤程，但这种方法也有其缺点：
- en: You have less flexibility; you can only run futures in a predefined thread pool.
  id: totrans-1166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的灵活性较低；你只能在预定义的线程池中运行期货。
- en: You should be careful if your futures take too much time, they could end up
    NOT running because the implicit thread pool has a number of threads available.
    If they are all busy some of your tasks will end up queued and waiting.
  id: totrans-1167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的期货运行时间过长，你需要小心，因为隐含的线程池有可用的线程数量。如果它们都忙碌，一些任务将最终排队等待。
- en: '`Futures` have their use cases, if you have very few processor intensive tasks,
    if you have IO bound tasks, maybe using promises with fibers is a good idea, since
    they allow you to keep your processor free to run more tasks concurrently.'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Futures`有其用例，如果你有非常少的处理器密集型任务，如果你有I/O密集型任务，也许使用带有纤程的承诺是个好主意，因为它们允许你保持处理器空闲，以便并发运行更多任务。'
- en: Software transactional memory and refs
  id: totrans-1169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件事务内存和refs
- en: One of Clojure's most interesting features is **software transactional memory**
    (**STM**). It uses **multiversion concurrency control** (**MVCC**), in a very
    similar fashion to how databases work, implementing a form of optimistic concurrency
    control.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure最有趣的功能之一是**软件事务内存**（**STM**）。它使用**多版本并发控制**（**MVCC**），其工作方式与数据库非常相似，实现了一种乐观并发控制的形式。
- en: Note
  id: totrans-1171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MVCC is what databases use for transactions; what this means is that every operation
    within a transaction has its own copy of variables. After executing its operations,
    it checks if any of the used variables changed during the transaction and if they
    did the transaction fails. This is called optimistic concurrency control because
    we are optimistic and we don't lock any variable; we let every thread do its work
    thinking that it's going to work correctly and then check if it was correct. In
    practice, this allows for greater concurrency.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: MVCC是数据库用于事务的；这意味着事务内的每个操作都有自己的变量副本。在执行其操作后，它检查在事务期间是否有任何使用的变量发生了变化，如果有，则事务失败。这被称为乐观并发控制，因为我们持乐观态度，我们不锁定任何变量；我们让每个线程做其工作，认为它会正确工作，然后检查它是否正确。在实践中，这允许更高的并发性。
- en: Let's start with the most obvious example, a bank account.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最明显的例子开始，一个银行账户。
- en: 'Let''s write some code now, enter into the REPL and write:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一些代码，进入REPL并输入：
- en: '[PRE164]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Try to write the future and the `dosync` functions at the same time so you have
    the same results.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试同时编写`future`和`dosync`函数，以确保得到相同的结果。
- en: We have just three lines of code here but there are quite a few things happening.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有三行代码，但发生了很多事情。
- en: First of all we define a `ref (account)`; refs are the managed variables in
    transactions. They are also the first implementation we see of Clojure's identity
    idea. Note that the account is an identity now and it might take multiple values
    throughout its life.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`ref (account)`；refs是事务中的管理变量。它们也是我们看到的Clojure身份概念的第一个实现。请注意，账户现在是一个身份，它在其生命周期中可能具有多个值。
- en: We now modify its value, we do this within a transaction since refs cannot be
    modified outside of transactions; thus, the `dosync` block.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在修改其值，我们在事务内进行此操作，因为refs不能在事务之外修改；因此，`dosync`块。
- en: In the end, we print the account and we can use (`deref` account) or `@account`,
    as we did for promises and futures.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印账户，我们可以使用(`deref` account)或`@account`，就像我们对承诺和未来所做的那样。
- en: Refs can be read from anywhere, there is no need for it to be within a transaction.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: Refs可以从任何地方读取，不需要它在事务内。
- en: 'Let''s look at something a little bit more interesting now, write or copy the
    next code into the REPL:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个更有趣的东西，将下面的代码写入或复制到REPL中：
- en: '[PRE165]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'If everything goes well, you should have an output similar to the following
    screenshot:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该得到一个类似于以下屏幕截图的输出：
- en: '![Software transactional memory and refs](img/B04289_06_07.jpg)'
  id: totrans-1185
  prefs: []
  type: TYPE_IMG
  zh: '![软件事务内存和refs](img/B04289_06_07.jpg)'
- en: This might seem a little strange, what is happening?
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点奇怪，发生了什么？
- en: The first transaction starts its process using the current value for account,
    the other transaction then modifies the value of account before the first transaction
    is finished; Clojure realizes this and it restarts the first transaction.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一笔交易使用账户的当前值开始其过程，而另一笔交易在第一笔交易完成之前修改了账户的值；Clojure意识到这一点，然后重新启动第一笔交易。
- en: Tip
  id: totrans-1188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You shouldn't execute functions with side effects within transactions, as there
    is no guarantee that they will be executed only once. If you need to do something
    like that you should use an agent.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该在事务中执行有副作用的函数，因为没有保证它们只会执行一次。如果你需要做类似的事情，你应该使用代理。
- en: This is the first example of how a transaction works, but using `ref-set` is
    not a good idea in general.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是事务工作的第一个例子，但使用`ref-set`通常不是一个好主意。
- en: 'Let''s take a look at another example, the classic example of moving money
    from an account *A* to an account *B*:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，将资金从账户*A*转移到账户*B*的经典例子：
- en: '[PRE166]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'This is a better example of how transactions work; you will probably see something
    similar to the following screenshot:'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是事务工作方式的更好例子；你可能看到类似于以下屏幕截图的内容：
- en: '![Software transactional memory and refs](img/B04289_06_08.jpg)'
  id: totrans-1194
  prefs: []
  type: TYPE_IMG
  zh: '![软件事务内存和refs](img/B04289_06_08.jpg)'
- en: 'First of all, you need to understand how the `alter` function works; it''s
    simple and it receives:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要理解`alter`函数的工作方式；它很简单，它接收：
- en: The ref that it has to modify
  id: totrans-1196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要修改的ref
- en: The function that it has to apply
  id: totrans-1197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要应用的功能
- en: The extra arguments
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的参数
- en: 'So this function:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个函数：
- en: '[PRE167]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Is translated to something like this:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为类似以下内容：
- en: '[PRE168]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: This is the preferred way to modify the current value.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改当前值的推荐方式。
- en: 'Let''s see a step by step description of what''s going on here:'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地描述一下这里正在发生的事情：
- en: We define two accounts with a balance of 10000 and 2000.
  id: totrans-1205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了两个账户，余额分别为10000和2000。
- en: We try to move 500 units from the first account to the second but first we sleep
    for 5 seconds.
  id: totrans-1206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们尝试将500个单位从第一个账户移动到第二个账户，但首先我们休眠5秒钟。
- en: We announce (using the promise) that we have started the transaction. The current
    thread moves on, since it was waiting for the started value.
  id: totrans-1207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过承诺宣布我们已经开始交易。当前线程继续运行，因为它正在等待已启动的值。
- en: We set the balance of account-a to 20.
  id: totrans-1208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将账户-a的余额设置为20。
- en: The first transaction realizes that something has changed and restarts.
  id: totrans-1209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一笔交易意识到某些东西已经改变并重新启动。
- en: The transaction goes on and is finished this time.
  id: totrans-1210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交易正在进行并已在此完成。
- en: Nothing happens, since the new balance is not enough to move 50 units.
  id: totrans-1211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有发生任何事情，因为新的余额不足以移动50个单位。
- en: In the end, if you check the balance, like `[@account-a @account-b]`, you will
    see that the first account has 20 and the second account has 2000.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你检查余额，比如`[@account-a @account-b]`，你会看到第一个账户有20，第二个账户有2000。
- en: 'There is another use case that you should take into account; let''s check the
    following code:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一个你应该考虑的使用案例；让我们检查以下代码：
- en: '[PRE169]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The idea is that if `secured` is set to true, you shouldn't be able to withdraw
    any money.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是，如果`secured`设置为true，你不应该能够提取任何钱。
- en: If you run it and then check for the value of `@account`, you'll see that even
    after changing the value of `secured` to true a withdrawal occurs. Why is that?
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行它并检查`@account`的值，你会发现即使在将`secured`的值更改为true之后，仍然发生了提款。为什么会有这种情况？
- en: 'The reason is that transactions only check for values that you modify within
    a transaction or values that you read; here we are reading the secured value before
    the modification, so the transaction doesn''t fail. We can tell the transaction
    to be a little bit more careful by using the following code:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，交易只检查你在交易中修改的值或你读取的值；在这里，我们在修改之前读取了受保护的值，所以交易没有失败。我们可以通过以下代码让交易更加小心：
- en: '[PRE170]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Here almost the same thing happened. What is the difference?
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎发生了同样的事情。有什么区别？
- en: There is one subtle difference, the second transaction can't finish until the
    first transaction is done. If you look at it in detail, you will notice that you
    can't modify the secured value until after the other transaction runs.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个细微的差别，第二笔交易必须等到第一笔交易完成后才能完成。如果你仔细观察，你会注意到你无法在另一个交易运行之后修改受保护的值。
- en: This is similar to a lock; not the best idea but useful in some cases.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于一个锁；虽然不是最好的主意，但在某些情况下很有用。
- en: Atoms
  id: totrans-1222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子
- en: We have now seen how promises, futures, and transactions work in Clojure. We'll
    now see atoms.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了在Clojure中如何使用承诺、未来和交易。现在我们将看到原子。
- en: Even though STM is very useful and powerful you'll see that in practice it is
    not very commonly used.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管STM非常有用且强大，但你会发现实际上它并不常用。
- en: Atoms are one of Clojure's workhorses, when it comes to concurrent programming.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 原子是Clojure在并发编程中的一个重要工具。
- en: You can think of atoms as transactions that modify one single value. You might
    be thinking, what good is that? Imagine you had lots of events that you want to
    store in a single vector. If you are used to Java, you probably know that using
    a `java.util.ArrayList` package is bound to have problems; since, you are almost
    surely going to lose data.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把原子看作是修改单个值的交易。你可能想知道，那有什么好处？想象一下，你有很多事件想要存储在一个单一的向量中。如果你习惯于Java，你可能知道使用`java.util.ArrayList`包肯定会出问题；因为你几乎肯定会丢失数据。
- en: In that case, you probably want to use a class from the `java.util.concurrent`
    package, how can you guarantee that you'll have no data loss in Clojure?
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，你可能想使用`java.util.concurrent`包中的一个类，你如何在Clojure中保证没有数据丢失？
- en: 'It''s easy, atoms come to the rescue! Let''s try this piece of code:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，原子来拯救！让我们尝试以下代码：
- en: '[PRE171]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: We are again using Pulsar and its lightweight threads. Here, we define an events
    atom and a `log-events` function.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用Pulsar及其轻量级线程。在这里，我们定义了一个事件原子和一个`log-events`函数。
- en: The `log-events` execute a `swap!` a given number of times.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '`log-events`执行了给定次数的`swap!`。'
- en: '`Swap!` is similar to the `alter` function it receives:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swap!`与它接收到的`alter`函数类似：'
- en: The atom that it should modify
  id: totrans-1233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该修改的原子
- en: The function that it applies to the atom
  id: totrans-1234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应用于原子的函数
- en: The extra arguments
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的参数
- en: 'In this case, it gives the atom the new value that comes from:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它给原子提供了来自以下内容的新值：
- en: '[PRE172]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: We then spawn five fibers, each fiber adds 500 events to the events atom.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了五个纤维，每个纤维向事件原子添加500个事件。
- en: 'After running this, we can check for the number of events from each fiber like
    this:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，我们可以检查每个纤维的事件数量如下：
- en: '[PRE173]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: As you can see, we have 500 elements from each fiber with no data loss and using
    Clojure's default data structures. There is no need to use special data structures
    for each use case, locks, or mutexes. This allows for greater concurrency.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们每个纤维有500个元素，没有数据丢失，并且使用Clojure的默认数据结构。不需要为每个用例使用特殊的数据结构，锁或互斥量。这允许有更高的并发性。
- en: When you modify an atom, you need to wait for the operation to be complete meaning
    it is synchronous.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修改一个原子时，你需要等待操作完成，这意味着它是同步的。
- en: Agents
  id: totrans-1243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: What if you don't care about the result of some operation? You just need to
    fire something and then forget it. In that case agents are what you need.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎某些操作的结果？你只需要触发某物然后忘记它。在这种情况下，代理是你需要的。
- en: 'Agents also run in separate thread pools, there are two functions that you
    can use to fire an agent:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 代理也在单独的线程池中运行，有两个函数可以用来触发代理：
- en: '`send`: This executes your function in an implicit thread pool'
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send`：这将在隐式线程池中执行你的函数'
- en: '`send-off`: This tries to execute your function in a new thread but there''s
    a change, it will reuse another thread'
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send-off`：这试图在一个新线程中执行你的函数，但有一个变化，它将重用另一个线程'
- en: Agents are the way to go if you want to cause side effects in a transaction;
    since, they will only be executed after the transaction has completed successfully.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在事务中引起副作用，代理是最佳选择；因为，它们只会在事务成功完成后执行。
- en: 'They work in a very simple manner, here is an example usage:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 它们以非常简单的方式工作，以下是一个示例用法：
- en: '[PRE174]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: If you copy and paste the exact previous code you will see a `0` and then a
    `:done` message, if you check for the value of `@agt`, then you will see the value
    `10`.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你复制并粘贴确切的上一段代码，你会看到一个`0`然后是一个`:done`消息，如果你检查`@agt`的值，那么你会看到值`10`。
- en: Agents are a good way to execute a given task and modify some value in a different
    thread with simpler semantics than those of futures or manually modifying values
    in another thread.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是执行给定任务并在不同线程中修改一些值的良好方式，其语义比未来或手动修改另一个线程中的值更简单。
- en: Validators
  id: totrans-1253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证器
- en: We have seen the primary concurrency primitives now, let's see some utilities
    that apply to all of them at once.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了主要的并发原语，现在让我们看看一些适用于所有这些的实用工具。
- en: We can define a validator that checks if the new value of some function is desirable
    or not; you can use them for refs, atoms, agents, and even vars.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个验证器来检查某个函数的新值是否可取；你可以为refs、atoms、agents甚至vars使用它们。
- en: The `validator` function must receive a single value and return true if the
    new value is valid or false otherwise.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '`validator`函数必须接收一个值，如果新值有效则返回`true`，否则返回`false`。'
- en: 'Let''s create a simple `validator` that checks if the new value is lower than
    `5`:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的`validator`来检查新值是否小于`5`：
- en: '[PRE175]'
  id: totrans-1258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: We get an exception. The reason is that the new value (`10`) is not valid.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了一个异常。原因是新值（`10`）无效。
- en: 'You can add `4` without a problem:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以无问题地添加`4`：
- en: '[PRE176]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Be careful with the validator and agents, since you will probably not know
    when an exception occurred:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用验证器和代理，因为你可能不知道何时发生异常：
- en: '[PRE177]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Watchers
  id: totrans-1264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视器
- en: 'Similar to validators, there are also watchers. Watchers are functions that
    are executed whenever Clojure''s identities get a new value. An important question
    is the thread in which watchers run. Watchers run in the same thread as the watched
    entity (if you add a watcher to an agent it will be run in the agent''s thread),
    it will be run before the agent code executes, so you should be careful and use
    the old-value new-value instead of reading the value with `deref`:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 与验证器类似，也存在监视器。监视器是当Clojure的身份获得新值时执行的函数。一个重要的问题是监视器运行的线程。监视器在监视实体相同的线程中运行（如果你向代理添加监视器，它将在代理的线程中运行），它将在代理代码执行之前运行，所以你应该小心，并使用旧值和新值而不是使用`deref`读取值：
- en: '[PRE178]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The `add-watch` function receives:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '`add-watch`函数接收：'
- en: The ref, atom, agent, or var that should be watched
  id: totrans-1268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该监视的ref、atom、agent或var
- en: A key that will be passed to the watcher function
  id: totrans-1269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要传递给监视函数的键
- en: 'A function with four parameters: the key, the reference itself, the old value,
    and the new value'
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有四个参数的函数：键、引用本身、旧值和新值
- en: 'After executing the previous code we get:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，我们得到：
- en: '[PRE179]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: core.async
  id: totrans-1273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: core.async
- en: The `core.async` is yet another way of programming concurrently; it uses the
    idea of lightweight threads and channels to communicate between them.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: '`core.async` 是另一种并发编程的方式；它使用轻量级线程和通道的概念在它们之间进行通信。'
- en: Why lightweight threads?
  id: totrans-1275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用轻量级线程？
- en: The lightweight threads are used in languages, such as go and Erlang. They excel
    in being able to run thousands of threads in a single process.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级线程被用于像 go 和 Erlang 这样的语言中。它们擅长在单个进程中运行成千上万的线程。
- en: What is the difference between the lightweight threads and traditional threads?
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级线程与传统线程之间有什么区别？
- en: The traditional threads need to reserve memory. This also takes some time. If
    you want to create a couple of thousand threads, you will be using a noticeable
    amount of memory for each thread; asking the kernel to do that also takes time.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 传统线程需要预留内存。这也需要一些时间。如果你想要创建几千个线程，你将为每个线程使用相当数量的内存；请求内核这样做也需要时间。
- en: What is the difference with lightweight threads? To have a couple of hundred
    lightweight threads, you only need to create a couple of threads. There is no
    need to reserve memory and lightweight threads are a mere software idea.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 轻量级线程与它们的区别是什么？要拥有几百个轻量级线程，你只需要创建几个线程。不需要预留内存，轻量级线程只是一个软件概念。
- en: This can be achieved with most languages and Clojure is adding first class support
    (without changing the language this is part of the Lisp power) with using `core.async`!
    Let's have a look at how it works.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过大多数语言实现，Clojure 通过使用 `core.async` 添加了一级支持（不改变语言本身，这是 Lisp 力量的体现）！让我们看看它是如何工作的。
- en: 'There are two concepts that you need to keep in mind:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个概念你需要记住：
- en: '**Goblocks**: They are the lightweight threads.'
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Goblocks**：它们是轻量级线程。'
- en: '**Channels**: Channels are a way to communicate between goblocks, you can think
    of them as queues. Goblocks can publish a message to the channel and other goblocks
    can take a message from them. Just as there are integration patterns for queues,
    there are integration patterns for channels and you will find concepts similar
    to broadcasting, filtering, and mapping.'
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：通道是 goblocks 之间通信的一种方式，你可以把它们看作是队列。Goblocks 可以向通道发布消息，其他 goblocks 可以从它们那里获取消息。就像有队列的集成模式一样，也有通道的集成模式，你将发现类似广播、过滤和映射的概念。'
- en: Now, let's play a little with each of them so you can understand better how
    to use them for our program.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分别玩一玩它们，这样你可以更好地理解如何为我们的程序使用它们。
- en: Goblocks
  id: totrans-1285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Goblocks
- en: You will find goblocks in the `clojure.core.async` namespace.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 `clojure.core.async` 命名空间中找到 goblocks。
- en: 'Goblocks are extremely easy to use, you need the go macro and you will do something
    similar to this:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: Goblocks 非常容易使用，你需要 go 宏，然后你会做类似这样的事情：
- en: '[PRE180]'
  id: totrans-1288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: They are similar to threads; you just need to remember that you can create goblocks
    freely. There can be thousands of running goblocks in a single JVM.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 它们类似于线程；你只需要记住你可以自由地创建 goblocks。在单个 JVM 中可以有成千上万的运行中的 goblocks。
- en: Channels
  id: totrans-1290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道
- en: You can actually use anything you like to communicate between goblocks, but
    it is recommended that you use channels.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以使用任何你喜欢的东西在 goblocks 之间进行通信，但建议你使用通道。
- en: 'Channels have two main operations: putting and getting. Let''s check how to
    do it:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 通道有两个主要操作：放置和获取。让我们看看如何做：
- en: '[PRE181]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'That''s it!! It looks pretty simple, as you can see there are three main functions
    that we are using with channels:'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！！看起来很简单，正如你所见，我们使用通道时主要有三个主要功能：
- en: '`chan`: This function creates a channel and the channels can store some messages
    in a buffer. If you want this functionality, you should just pass the size of
    the buffer to the `chan` function. If no size is specified, the channel can store
    only one message.'
  id: totrans-1295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chan`：这个函数创建一个通道，通道可以在缓冲区中存储一些消息。如果你想使用这个功能，你应该只将缓冲区的大小传递给 `chan` 函数。如果没有指定大小，通道只能存储一条消息。'
- en: '`>!`: The put function must be used within a goblock; it receives a channel
    and the value you want to publish to it. This function blocks, if a channel''s
    buffer is already full. It will block until something is consumed from the channel.'
  id: totrans-1296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>!`：put 函数必须在 goblock 中使用；它接收一个通道和你要发布到它的值。如果通道的缓冲区已满，这个函数会阻塞。它将阻塞，直到从通道中消耗掉一些内容。'
- en: '`<!`: This takes function; this function must be used within a goblock. It
    receives the channel you are taking from. It is blocking and if you haven''t published
    something in the channel it will park until there''s data available.'
  id: totrans-1297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<!`: 这个取函数；这个函数必须在goblock内部使用。它接收你从中取通道。它是阻塞的，如果你在通道中没有发布任何东西，它将停车直到有数据可用。'
- en: 'There are lots of other functions that you can use with channels, for now let''s
    add two related functions that you will probably use soon:'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用很多其他函数与通道一起使用，现在让我们添加两个你可能会很快用到的相关函数：
- en: '`>!!`: The blocking put, works exactly the same as the `put` function; except
    it can be used from anywhere. Note that if a channel cannot take more data, this
    function will block the entire thread from where it runs.'
  id: totrans-1299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>!!`: 阻塞put操作与`put`函数工作方式完全相同；除了它可以从任何地方使用。注意，如果通道无法接收更多数据，此函数将阻塞从它运行的那个线程。'
- en: '`<!!`: The blocking works exactly the same as the `take` function, except you
    can use this from anywhere and not just from inside goblocks. Just keep in mind
    that this blocks the thread where it runs until there''s data available.'
  id: totrans-1300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<!!`: 阻塞工作方式与`take`函数完全相同，除了你可以从任何地方使用它，而不仅仅是goblocks内部。只需记住，它会在有数据可用之前阻塞运行它的线程。'
- en: If you look into the `core.async` API docs ([http://clojure.github.io/core.async/](http://clojure.github.io/core.async/))
    you will find a fair amount of functions.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`core.async` API文档([http://clojure.github.io/core.async/](http://clojure.github.io/core.async/))，你会找到相当多的函数。
- en: 'Some of them look similar to the functions that give you functionalities similar
    to queues, let''s take a look at the `broadcast` function:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些看起来与给你类似队列功能的函数相似，让我们来看看`broadcast`函数：
- en: '[PRE182]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: With this you can publish it to several channels at the same time, this is helpful
    if you want to subscribe multiple processes to a single source of events with
    a great amount of separation of concern.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，你可以同时发布到多个通道，如果你想要将多个进程订阅到单个事件源，并且有大量的关注点分离，这会很有帮助。
- en: 'If you take a good look, you will also find familiar functions over there:
    `map`, `filter`, and `reduce`.'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你也会在那里找到熟悉的函数：`map`、`filter`和`reduce`。
- en: Note
  id: totrans-1306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Depending on the version of `core.async`, some of these functions might not
    be there anymore.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`core.async`的版本，其中一些函数可能已经不再存在。
- en: Why are these functions there? Those functions are meant to modify collections
    of data, right?
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这些函数在这里？这些函数是用来修改数据集合的，对吧？
- en: The reason is that there has been a good amount of effort towards using channels
    as higher-level abstractions.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是已经投入了大量努力来使用通道作为高级抽象。
- en: The idea is to see channels as collections of events, if you think of them that
    way it's easy to see that you can create a new channel by mapping every element
    of an old channel or you can create a new channel by filtering away some elements.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是将通道视为事件集合，如果你这样想，就很容易看出你可以通过映射旧通道的每个元素来创建一个新的通道，或者你可以通过过滤掉一些元素来创建一个新的通道。
- en: In recent versions of Clojure, the abstraction has become even more noticeable
    with transducers.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure的最近版本中，通过转换器，抽象变得更加明显。
- en: Transducers
  id: totrans-1312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换器
- en: Transducers are a way to separate the computations from the input source. Simply,
    they are a way to apply a sequence of steps to a sequence or a channel.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器是一种将计算与输入源分离的方法。简单来说，它们是将一系列步骤应用于序列或通道的方法。
- en: 'Let''s look at an example of a sequence:'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个序列的例子：
- en: '[PRE183]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: The `comp` feels similar to the threading macros, it composes functions and
    stores the steps of the computation.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '`comp`感觉与线程宏类似，它组合函数并存储计算的步骤。'
- en: 'The interesting part is that we can use the same odd-counts transformation
    with a channel, such as:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是我们可以使用相同的奇数转换与通道，例如：
- en: '[PRE184]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Summary
  id: totrans-1319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We have checked the core Clojure mechanisms for concurrent programming, as
    you can see, they feel natural and they build on already existing paradigms, such
    as immutability. The most important idea is what an identity and value is; we
    now know that we can have the following values as identifiers:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了核心Clojure的并发编程机制，如你所见，它们感觉很自然，并且建立在已经存在的范式之上，如不可变性。最重要的想法是一个身份和值是什么；我们现在知道我们可以有以下的值作为标识符：
- en: Refs
  id: totrans-1321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用
- en: Atoms
  id: totrans-1322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子
- en: Agents
  id: totrans-1323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: We can also get the snapshot of their value with the defer function or the `@`
    shortcut.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用defer函数或`@`快捷键获取它们的值快照。
- en: If we want to use something a little more primitive, we can use promises or
    futures.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用一些更原始的东西，我们可以使用promises或futures。
- en: We have also seen how to use threads, or Pulsar's fibers. Most of Clojure's
    primitives aren't specific to some concurrency mechanism, so we can use any parallel
    programming mechanism with any type of Clojure primitive.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了如何使用线程或 Pulsar 的纤维。Clojure 的许多原语并不特定于某种并发机制，因此我们可以使用任何并行编程机制与任何类型的 Clojure
    原语一起使用。
- en: Chapter 7. Macros in Clojure
  id: totrans-1327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。Clojure 中的宏
- en: 'In this chapter, we will get to know one of Clojure''s most complicated facilities:
    macros. We will learn what they are for, how to write them, and how to use them.
    It can be a little challenging, but there is good news too. You should be aware
    of some tools from your knowledge of the Java language that can help you understand
    macros better. We will progress little by little with comparisons to other JVM
    languages, and in the end, we will write some macros and understand that we have
    been using them for a while.'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 Clojure 最复杂的设施之一：宏。我们将学习它们的作用、如何编写它们以及如何使用它们。这可能会有些挑战，但也有一些好消息。你应该意识到一些来自你
    Java 语言知识的工具可以帮助你更好地理解宏。我们将通过与其他 JVM 语言的比较逐步进行，最终我们将编写一些宏并理解我们已经在使用它们了。
- en: 'We will learn about the following topics:'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习以下主题：
- en: Understanding Lisp's foundational ideas
  id: totrans-1330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Lisp 的基础思想
- en: Macros as code modification tools
  id: totrans-1331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏作为代码修改工具
- en: Modifying code in Groovy
  id: totrans-1332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 Groovy 代码
- en: Writing your first macro
  id: totrans-1333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的第一个宏
- en: Debugging your first macro
  id: totrans-1334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试你的第一个宏
- en: Macros in the real world
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏在现实世界中的应用
- en: Lisp's foundational ideas
  id: totrans-1336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lisp 的基础思想
- en: 'Lisp is a very different beast from what you used to know. According to Paul
    Graham, there are nine ideas that make Lisp different (these ideas have existed
    since the late 1950s), and they are:'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 与你过去所知的大相径庭。根据保罗·格雷厄姆的说法，有九个想法使 Lisp 与众不同（这些想法自 1950 年代后期以来一直存在），它们是：
- en: Conditionals (remember, we are talking 1950s–1960s)
  id: totrans-1338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件语句（记住，我们谈论的是 1950 年代至 1960 年代）
- en: Functions as first-class citizens
  id: totrans-1339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数作为一等公民
- en: Recursion
  id: totrans-1340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归
- en: Dynamic typing
  id: totrans-1341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态类型
- en: Garbage collection
  id: totrans-1342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Programs as sequences of expressions
  id: totrans-1343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序作为表达式序列
- en: The symbol type
  id: totrans-1344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 符号类型
- en: Lisp's syntax
  id: totrans-1345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lisp 的语法
- en: 'The whole language is there all the time: at compilation, runtime—always!'
  id: totrans-1346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个语言始终都在那里：在编译时，在运行时——始终如此！
- en: Note
  id: totrans-1347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you can, read Paul Graham's essay *Revenge of the Nerds* ([http://www.paulgraham.com/icad.html](http://www.paulgraham.com/icad.html)),
    where he talks about Lisp, what makes it different, and why the language is important.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，阅读保罗·格雷厄姆的论文《书呆子的复仇》(*Revenge of the Nerds* ([http://www.paulgraham.com/icad.html](http://www.paulgraham.com/icad.html)))，其中他谈论了
    Lisp，它为什么与众不同，以及为什么这种语言很重要。
- en: These ideas have thrived even after the Lisp age; most of them are common nowadays
    (can you imagine a language without conditionals?). But the last couple of ideas
    are what makes us Lisp lovers love the syntax (we will fully understand what they
    mean through this chapter).
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法即使在 Lisp 时代之后也依然繁荣；其中大部分现在都很常见（你能想象一个没有条件语句的语言吗？）。但最后几个想法正是让我们这些 Lisp 爱好者喜欢其语法的理由（我们将在本章中完全理解它们的含义）。
- en: Common languages are trying to achieve the very same things now with a slightly
    different approach, and you, as a Java developer, have probably seen this.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 常见语言正在尝试以略有不同的方法实现相同的目标，而你作为一个 Java 开发者，可能已经看到了这一点。
- en: Macros as code modification tools
  id: totrans-1351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏作为代码修改工具
- en: One of the first and most common uses of macros is to be able to modify code;
    they work on the code level, as you will see. Why should we do that? Let's try
    to understand the problem with something that you are more familiar with—Java.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的第一个也是最常见用途之一是能够修改代码；它们在代码级别上工作，正如你将看到的。我们为什么要这样做呢？让我们通过一些你更熟悉的东西来尝试理解这个问题——Java。
- en: Modifying code in Java
  id: totrans-1353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 Java 代码
- en: Have you ever used AspectJ or Spring AOP? Have you ever had problems with tools
    such as ASM or Javassist?
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经使用过 AspectJ 或 Spring AOP？你是否曾经遇到过使用 ASM 或 Javassist 等工具的问题？
- en: You have probably used code modification in Java. It is common in Java EE applications,
    just not explicit. (Have you ever thought about what the `@Transactional` annotation
    does in Java EE or Spring applications?)
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在 Java 中使用过代码修改。这在 Java EE 应用程序中很常见，但并不明显。（你有没有想过 `@Transactional` 注解在
    Java EE 或 Spring 应用程序中做什么？）
- en: As developers, we try to automate everything we can, so how could we leave out
    our own devtools?
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们试图自动化我们能做的一切，那么我们怎么能忽略我们自己的开发工具呢？
- en: We have tried to create ways to modify the bytecode at runtime so that we don't
    have to remember to open and close resources, or so that we can decouple dependencies
    and get dependency injection.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尝试创建在运行时修改字节码的方法，这样我们就不必记得打开和关闭资源，或者我们可以解耦依赖关系并实现依赖注入。
- en: 'If you use Spring, you probably know about the following use cases:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Spring，你可能知道以下用例：
- en: The `@Transactional` annotation modifies the annotated method to ensure that
    your code is wrapped in a database transaction
  id: totrans-1359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Transactional` 注解修改注解的方法以确保你的代码被数据库事务包裹'
- en: The `@Autowired` annotation looks for the required bean and injects it into
    the annotated property or method
  id: totrans-1360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Autowired` 注解寻找所需的bean并将其注入到注解的属性或方法中'
- en: The `@Value` annotation looks for a configuration value and then injects it
  id: totrans-1361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Value` 注解寻找配置值并将其注入'
- en: You could probably think of several other annotations that modify the way your
    classes work.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还能想到其他几个修改类工作方式的注解。
- en: The important thing here is that you understand why we want to modify code,
    and you probably already know a few mechanisms for doing it, including AspectJ
    and Spring AOP.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是你要理解我们为什么要修改代码，你可能已经知道一些实现它的机制，包括AspectJ和Spring AOP。
- en: 'Let''s take a look at how it is done in the Java world; this is what an aspect
    in Java looks like:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在Java世界中是如何实现的；这就是Java中一个方面的样子：
- en: '[PRE185]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Aspects have the advantage that you can modify any code you like without having
    to touch it. This also has its drawbacks since you could modify the code in ways
    the original author didn't expect and thus cause bugs.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: Aspect具有优势，你可以修改任何你喜欢的代码而不必触及它。这也存在一些缺点，因为你可以以原始作者没有预料到的方式修改代码，从而引发错误。
- en: Another drawback is that you have an extremely limited field of action; you
    can wrap your modifications around some code or execute something before or after.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是你有一个极其有限的行动范围；你可以在某些代码周围包装你的修改或在之前或之后执行某些操作。
- en: The libraries that generate this code are extremely complex and they can either
    create a proxy around your objects or modify the bytecode, at runtime or compile
    time.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此代码的库非常复杂，它们可以在运行时或编译时创建你的对象的代理或修改字节码。
- en: As you can imagine, there are lots of things that you must be aware of, and
    anything could go wrong. Hence, debugging could prove complicated.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，有很多你必须注意的事情，任何事都可能出错。因此，调试可能很复杂。
- en: Modifying code in Groovy
  id: totrans-1370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Groovy中修改代码
- en: Groovy has gone further down the road and it provides us with more solutions
    and more macro-like features.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy已经走得更远，它为我们提供了更多解决方案和更多类似宏的功能。
- en: Since Groovy 1.8, we have got a lot of AST transformations. What does AST stand
    for? It stands for **abstract syntax tree**—sounds complicated, right?
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Groovy 1.8以来，我们已经得到了很多AST转换。AST代表什么？它代表**抽象语法树**——听起来很复杂，对吧？
- en: Before explaining it all, let's check what some of them do.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释所有这些之前，让我们看看它们中的一些功能。
- en: The @ToString annotation
  id: totrans-1374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@ToString` 注解'
- en: The `@ToString` annotation generates a simple `toString` method that includes
    information about the class of the object and the value of its properties.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ToString` 注解生成一个简单的`toString`方法，其中包含有关对象类及其属性值的信息。'
- en: The @TupleConstructor annotation
  id: totrans-1376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@TupleConstructor` 注解'
- en: 'The `@TupleConstructor` creates a constructor that is able to take all of the
    values of your class at once. Here is an example:'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '`@TupleConstructor` 创建了一个构造函数，能够一次性接受你类中的所有值。以下是一个示例：'
- en: '[PRE186]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: The @Slf4j annotation
  id: totrans-1379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@Slf4j` 注解'
- en: 'The `@Slf4j` annotation adds an instance of a logger, called log by default,
    to your class, so you can do this:'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Slf4j` 注解将一个名为log的日志实例添加到你的类中，默认情况下，你可以这样做：'
- en: '[PRE187]'
  id: totrans-1381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: This can be done without having to manually declare the log instance, the class
    name, and so on. There are lots of other things that you can do with this type
    of annotation, but how do they work?
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在不手动声明日志实例、类名等的情况下完成。你可以用这种类型的注解做很多事情，但它们是如何工作的呢？
- en: Now, what is AST and what does it have to do with Clojure macros? Come to think
    of it, it actually has a lot to do with them.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，AST是什么，它与Clojure宏有什么关系？想想看，它实际上与它们有很大关系。
- en: To answer that last question, you'll have to understand a little bit about how
    compilers work.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答最后一个问题，你必须稍微了解一些编译器的工作原理。
- en: We all know that machines (your machine, the JVM, the Erlang BEAM machine) are
    not capable of understanding human code, so we need a process to convert whatever
    developers write into what machines understand.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道机器（您的机器、JVM、Erlang BEAM 机器）无法理解人类代码，因此我们需要一个过程将开发者编写的内容转换为机器能理解的内容。
- en: 'One of the most important steps of the process is to create a syntax tree,
    something similar to the following figure:'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程最重要的步骤之一是创建一个语法树，类似于以下图示：
- en: '![The @Slf4j annotation](img/B04289_07_01.jpg)'
  id: totrans-1387
  prefs: []
  type: TYPE_IMG
  zh: '![The @Slf4j annotation](img/B04289_07_01.jpg)'
- en: 'This is a very simple example of the following expression:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以下表达式的一个非常简单的例子：
- en: '[PRE188]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'This tree is what we call the abstract syntax tree. Let''s see the tree of
    something that''s a bit more complicated, such as this piece of code:'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 这棵树就是我们所说的抽象语法树。让我们看看一个稍微复杂一点的树的例子，比如下面的这段代码：
- en: '[PRE189]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Thus, the tree will look like the following figure:'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这棵树看起来会像以下图示：
- en: '![The @Slf4j annotation](img/B04289_07_02.jpg)'
  id: totrans-1393
  prefs: []
  type: TYPE_IMG
  zh: '![The @Slf4j annotation](img/B04289_07_02.jpg)'
- en: As you can see, the figure is still pretty straightforward, and you can probably
    understand how someone would execute code from a structure like this one.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个图示仍然相当直接，您可能能理解如何从这样的结构中执行代码。
- en: Groovy's AST transformation is a way to meddle with such generated code.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 的 AST 转换是一种干预这种生成代码的方法。
- en: As you can imagine, this is a much more powerful approach, but you are now messing
    with what the compiler generated; the probable downside to this is the complexity
    of the code.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，这是一个更强大的方法，但现在您正在与编译器生成的代码打交道；这种可能的缺点是代码的复杂性。
- en: 'Let''s check, for instance, the code of the `@Slf4j` AST. It should be pretty
    simple, right? It just adds a log property:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 `@Slf4j` AST 的代码为例进行检查。它应该相当简单，对吧？它只是添加了一个日志属性：
- en: '[PRE190]'
  id: totrans-1398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Note
  id: totrans-1399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can check the complete code at [https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java](https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java),
    and it's also included with the code bundle of this chapter.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java](https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java)
    检查完整的代码，它也包含在本章的代码包中。
- en: This doesn't look simple at all. It is just a fragment and still looks very
    complicated. What happens here is that you have to deal with the Java bytecode
    format and with compiler complications.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来一点也不简单。这只是一个片段，看起来仍然非常复杂。这里发生的事情是，您必须处理 Java 字节码格式和编译器复杂性。
- en: Here, we should remember point number 8that Paul Graham made about the syntax
    of Lisp.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们应该记住保罗·格雷厄姆关于 Lisp 语法提出的第8点。
- en: 'Let''s write our last code example in Clojure:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Clojure 中编写最后一个代码示例：
- en: '[PRE191]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'There''s something peculiar about this piece of code: it feels very similar
    to the AST! This is not a coincidence. Actually, in Clojure and Lisp, you are
    directly writing the AST. This is one of the features that make Lisp a very simple
    language; you directly write what the computer understands. This might help you
    understand a little more about why code is data and data is code.'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有点特别：它感觉非常类似于 AST！这不是巧合。实际上，在 Clojure 和 Lisp 中，您直接编写 AST。这是使 Lisp 成为一个非常简单的语言的特征之一；您直接编写计算机能理解的内容。这可能会帮助您更好地理解代码是数据，数据是代码的原因。
- en: Imagine if you could modify the AST the same way that you modify any other data
    structure in your programs. But you can, and that's what macros are for!
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果您能够像修改程序中的任何其他数据结构一样修改 AST 会怎样。但是您可以，这正是宏的作用！
- en: Writing your first macro
  id: totrans-1407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个宏
- en: Now that you have a clear understanding of how macros work and what they are
    for, let's start working with Clojure.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经清楚地理解了宏的工作原理和它们的作用，让我们开始使用 Clojure 进行操作。
- en: 'Let me present you with a challenge: write an `unless` function in Clojure,
    something that works like this:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给您出一个挑战：在 Clojure 中编写一个 `unless` 函数，它的工作方式如下：
- en: '[PRE192]'
  id: totrans-1410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Let''s give it a first try; maybe with something like the following syntax:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试；也许可以用以下这样的语法：
- en: '[PRE193]'
  id: totrans-1412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Do you know what would happen if you wrote this code and then ran it? If you
    test it, you will get the following result:'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道如果您编写了这段代码然后运行会发生什么吗？如果您测试它，您将得到以下结果：
- en: '[PRE194]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'What''s happening here? Let''s modify it a bit so that we get a value and we
    can understand what''s happening. Let''s define it a bit differently, and let''s
    return a value so that we see something different:'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？让我们稍作修改，以便我们得到一个值，我们可以理解正在发生的事情。让我们以不同的方式定义它，并返回一个值，以便我们看到一些不同：
- en: '[PRE195]'
  id: totrans-1416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'We will get the following output:'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE196]'
  id: totrans-1418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: What's going on here?
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: When you pass parameters to a function, everything is evaluated before the actual
    code of the function runs, so over here, before the body of your function runs,
    you execute both of the `println` methods. After that, the `if` runs correctly
    and you get `:bigger`, but we still got an output for the positive and negative
    cases of our `if`. It looks like our code is not working!
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向函数传递参数时，在函数的实际代码运行之前，所有内容都会被评估，所以在这里，在你函数的主体运行之前，你执行了两个`println`方法。之后，`if`运行正确，你得到了`:bigger`，但我们仍然得到了`if`的正负情况输出。看起来我们的代码没有正常工作！
- en: 'How can we fix this? With our current tools, we probably need to write closures
    and change the `my-if` code to accept functions as parameters:'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何解决这个问题？使用我们当前的工具，我们可能需要编写闭包并将`my-if`代码修改为接受函数作为参数：
- en: '[PRE197]'
  id: totrans-1422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'This works, but there are several disadvantages:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但有几个缺点：
- en: There are a lot of constraints now for the code (both clauses should now be
    functions)
  id: totrans-1424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在代码有很多限制（两个子句现在都应该作为函数）
- en: It doesn't work for every single case
  id: totrans-1425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不适用于每个单一的情况
- en: It is very complicated
  id: totrans-1426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这非常复杂
- en: 'In order to solve this problem, Clojure gives us macros. Let''s have a look
    at how they work:'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Clojure给了我们宏。让我们看看它们是如何工作的：
- en: '[PRE198]'
  id: totrans-1428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'The output will be this:'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是这样的：
- en: '[PRE199]'
  id: totrans-1430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: This is great! It works, but what just happened? Why did we just use a macro
    and why did it work?
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒！它工作了，但发生了什么？为什么我们使用宏，为什么它有效？
- en: Note
  id: totrans-1432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Macros are not normal Clojure functions; they are supposed to generate code
    and should return a Clojure form. This means that they should return a list that
    we can use as normal Clojure code.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 宏不是正常的Clojure函数；它们应该生成代码，并应该返回一个Clojure形式。这意味着它们应该返回一个我们可以用作正常Clojure代码的列表。
- en: 'Macros return code that will be executed later. And here is where point number
    nine of Paul Graham''s list comes into play: you have all of the language all
    the time.'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 宏返回将在以后执行的代码。这就是保罗·格雷厄姆列表中的第九点发挥作用的地方：你始终拥有整个语言。
- en: In C++, you have a mechanism called a macro; when you use it, you have a very
    limited set of things that you can do compared to actual C++ code.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，你有一个称为宏的机制；当你使用它时，与实际的C++代码相比，你可以做的非常有限的事情。
- en: In Clojure, you can manipulate the Clojure code any way you want, and you can
    use the full language here too! Since Clojure code is data, manipulating the code
    is as easy as manipulating any other data structure.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，你可以按任何你想要的方式操作Clojure代码，你在这里也可以使用完整的语言！由于Clojure代码是数据，操作代码就像操作任何其他数据结构一样简单。
- en: Note
  id: totrans-1437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Macros are run at compile time, which means that at the time of running the
    code, there is no trace of macros; every macro call is replaced with the generated
    code.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 宏在编译时运行，这意味着在运行代码时，没有宏的痕迹；每个宏调用都被替换为生成的代码。
- en: Debugging your first macro
  id: totrans-1439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试你的第一个宏
- en: 'Now, as you can imagine, since things can get complicated when using macros,
    there should be some way to debug them. We have two functions to accomplish that:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所想象的，由于使用宏时事情可能会变得复杂，应该有一种方法可以调试它们。我们有两个函数来完成这个任务：
- en: '`macroexpand`'
  id: totrans-1441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`macroexpand`'
- en: '`macroexpand-1`'
  id: totrans-1442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`macroexpand-1`'
- en: The difference between them has to do with recursive macros. There is no rule
    telling you that you can't use a macro from a macro (the whole language is there
    all the time, remember?). If you wish to go all the way through any macro, you
    can use `macroexpand`; if you wish to go a single step forward, you can use `macroexpand-1`.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的区别与递归宏有关。没有规则告诉你你不能从宏中使用宏（整个语言始终都在那里，记得吗？）。如果你想完全遍历任何宏，你可以使用`macroexpand`；如果你想向前迈出一小步，你可以使用`macroexpand-1`。
- en: Both of them show you the code generated by a macro call; this is what happens
    when you compile your Clojure code.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都显示了宏调用生成的代码；这就是当你编译Clojure代码时发生的事情。
- en: 'Give this a try:'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这个：
- en: '[PRE200]'
  id: totrans-1446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: There is not much more to macros than this; you now understand them to a good
    level of detail.
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的内容不外乎如此；你现在对它们有了很好的理解。
- en: There are, however, many common problems that you will come across and tools
    for solving them that you should know about. Let's have a look.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你将遇到许多常见问题，以及解决这些问题的工具，你应该了解它们。让我们看看。
- en: Quote, syntax quote, and unquoting
  id: totrans-1449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用、语法引号和unquote
- en: 'As you can see, the `my-if` macro uses a quote in it:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`my-if`宏在其中使用了quote：
- en: '[PRE201]'
  id: totrans-1451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: This happens because you need the `if` symbol as the first element in the resulting
    form.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为你需要`if`符号作为结果形式的第一个元素。
- en: Quoting is very common in macros, since we need to build code instead of evaluating
    it on the fly.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏中，引用非常常见，因为我们需要构建代码而不是即时评估它。
- en: 'There is another type of quoting very common in macros—syntax quoting—that
    makes it easier to write code similar to the final code you want to generate.
    Let''s change the implementation of our macro to this:'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏中还有一种非常常见的引用类型——语法引用，它使得编写与最终要生成的代码类似的代码变得更容易。让我们改变我们宏的实现，如下所示：
- en: '[PRE202]'
  id: totrans-1455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Let's see what happens here. For one,`(if test positive negative)` looks much
    more beautiful than the `list` function we had before, but the code generated
    with `macroexpand-1` looks pretty strange. What happened?
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里会发生什么。首先，`(if test positive negative)`看起来比我们之前使用的`list`函数要漂亮得多，但使用`macroexpand-1`生成的代码看起来相当奇怪。发生了什么？
- en: We just used a different form of quoting that allows us to quote full expressions.
    It does some interesting things. As you can see, it changes the parameters to
    fully qualified `var` names (`clojure.core/test`, `user/positive`, `user/negative`).
    This is something that you'll be grateful for in the future, but you don't need
    this for now.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用了一种不同的引用形式，它允许我们引用完整的表达式。它做了一些有趣的事情。正如你所见，它将参数更改为完全限定的`var`名称（`clojure.core/test`、`user/positive`、`user/negative`）。这是你将来会感激的事情，但现在你不需要这个。
- en: What you need are the values of test, positive, and negative. How can you get
    them in this macro?
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的是test、positive和negative的值。你如何在宏中获取它们？
- en: 'Using syntax quotes, you can ask for something to be evaluated inline with
    the unquote operator, like this:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法引号，你可以使用unquote操作符来请求对某些内容进行内联评估，如下所示：
- en: '[PRE203]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Let''s try our macro expansion again and see what we get:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试宏展开并看看我们得到什么：
- en: '![Quote, syntax quote, and unquoting](img/B04289_07_03.jpg)'
  id: totrans-1462
  prefs: []
  type: TYPE_IMG
  zh: '![引用、语法引号和unquote](img/B04289_07_03.jpg)'
- en: Unquote splicing
  id: totrans-1463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unquote splicing
- en: There are some other cases that become common in macros. Let's imagine we want
    to reimplement the `>` function as a macro and retain the ability to compare several
    numbers; what would that look like?
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏中还有一些其他情况变得很常见。让我们想象我们想要重新实现`>`函数作为宏，并保留比较多个数字的能力；那会是什么样子？
- en: 'Maybe a first attempt could be something like this:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的第一次尝试可能如下所示：
- en: '[PRE204]'
  id: totrans-1466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![Unquote splicing](img/B04289_07_04.jpg)'
  id: totrans-1468
  prefs: []
  type: TYPE_IMG
  zh: '![Unquote splicing](img/B04289_07_04.jpg)'
- en: Do you see the problem here?
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到问题了吗？
- en: The problem is that we are trying to pass a list of values to `clojure.core/>`
    instead of passing the values themselves.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们试图将值列表传递给`clojure.core/>`，而不是传递值本身。
- en: This is easily solved with something called **unquote splicing**. Unquote splicing
    takes a vector or list of parameters and expands it as if you had used the `as`
    parameter on a function or macro.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一种称为**unquote splicing**的方法轻松解决。Unquote splicing接受一个向量或参数列表，并像使用函数或宏上的`as`参数一样展开它。
- en: 'It works like this:'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这样工作的：
- en: '[PRE205]'
  id: totrans-1473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![Unquote splicing](img/B04289_07_05.jpg)'
  id: totrans-1475
  prefs: []
  type: TYPE_IMG
  zh: '![Unquote splicing](img/B04289_07_05.jpg)'
- en: You will use unquote splicing almost every time you have a variable number of
    arguments to a macro.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎每次在宏的参数数量可变时都会使用unquote splicing。
- en: gensym
  id: totrans-1477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gensym
- en: Generating code can be troublesome, and we end up discovering common issues.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 生成代码可能会很麻烦，我们最终会发现一些常见问题。
- en: 'See if you can find the issue in the following code:'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能在以下代码中找到问题：
- en: '[PRE206]'
  id: totrans-1480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'This is a common issue when generating code. You overwrite another value, Clojure
    doesn''t even let you run this, and it displays something like the following screenshot:'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在生成代码时常见的问题。你覆盖了另一个值，Clojure甚至不允许你运行这个，并显示如下截图：
- en: '![gensym](img/B04289_07_06.jpg)'
  id: totrans-1482
  prefs: []
  type: TYPE_IMG
  zh: '![gensym](img/B04289_07_06.jpg)'
- en: 'But don''t worry; there''s another way in which you can make sure you are not
    messing with your environment, which is the `gensym` function:'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心；还有另一种确保你没有破坏你的环境的方法，那就是`gensym`函数：
- en: '[PRE207]'
  id: totrans-1484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'The `gensym` function creates a new `var-name` each time the macro is run,
    which guarantees that there is no other `var-name` that it obscures. If you try
    the macro expansion now, you will get this:'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '`gensym`函数在宏每次运行时都会创建一个新的`var-name`，这保证了没有其他`var-name`会被它覆盖。如果你现在尝试宏展开，你会得到以下结果：'
- en: '[PRE208]'
  id: totrans-1486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'The following screenshot is the result of the preceding code:'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是前面代码的结果：
- en: '![gensym](img/B04289_07_07.jpg)'
  id: totrans-1488
  prefs: []
  type: TYPE_IMG
  zh: '![gensym](img/B04289_07_07.jpg)'
- en: Macros in the real world
  id: totrans-1489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界中的宏
- en: 'Do you want to know when it is that macros are used extensively? Think about
    `defn`; what''s more, do this:'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道宏被广泛使用的时候吗？想想 `defn`；更重要的是，这样做：
- en: '[PRE209]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Did you know that `defn` is a macro in `clojure.core` that creates a function
    and binds it to a `var` in the current namespace?
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗，`defn` 是 `clojure.core` 中的一个宏，它创建一个函数并将其绑定到当前命名空间中的 `var` 吗？
- en: Clojure is filled with macros; if you want some samples, you can look at Clojure
    core, but what else can you do with macros?
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 中充满了宏；如果你想看看一些示例，你可以查看 Clojure 核心，但你可以用宏做什么呢？
- en: 'Let''s have a look at some interesting libraries:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些有趣的库：
- en: '`yesql`: The `yesql` library is a very interesting sample of code generation.
    It reads SQL code from a SQL file and generates the Clojure functions accordingly.
    Look for the `defquery` and `defqueries` macros in the `yesql` project on GitHub;
    it can be very enlightening.'
  id: totrans-1495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yesql`: `yesql` 库是代码生成的一个非常有趣的示例。它从 SQL 文件中读取 SQL 代码并相应地生成 Clojure 函数。在 GitHub
    上的 `yesql` 项目中查找 `defquery` 和 `defqueries` 宏；这可能会非常有启发性。'
- en: '`core.async`: If you are familiar with the `go` language and `goroutines`,
    you would probably like to have that same functionality in the Clojure language.
    This isn''t necessary since you could have provided them yourself! The `core.async`
    library is just `goroutines` for Clojure, and it is provided as a library (no
    obscure language change is needed). This shows a great example of the power of
    macros.'
  id: totrans-1496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core.async`: 如果你熟悉 `go` 语言和 `goroutines`，你可能会希望在 Clojure 语言中也有相同的功能。这并不是必要的，因为你完全可以自己提供它们！`core.async`
    库就是 Clojure 中的 `goroutines`，它作为一个库提供（不需要进行神秘的语言更改）。这是一个宏强大功能的绝佳例子。'
- en: '`core.typed`: With macros, you can even change the dynamic nature of Lisp.
    The `core.typed` library is an effort that allows you to define type constraints
    for your Clojure code; macros are extensively used here to generate boilerplate
    code and checks. This is probably much more complex.'
  id: totrans-1497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core.typed`: 使用宏，你甚至可以改变 Lisp 的动态特性。`core.typed` 库是一个允许你为 Clojure 代码定义类型约束的努力；在这里宏被广泛使用以生成样板代码和检查。这可能是更复杂的事情。'
- en: References
  id: totrans-1498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'If you need further references, you can look at the following list. There are
    entire books committed to the topic of macros. I recommend two in particular:'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要进一步参考，你可以查看以下列表。有整本书致力于宏这个主题。我特别推荐两本：
- en: Mastering Clojure Macros ([https://pragprog.com/book/cjclojure/](https://pragprog.com/book/cjclojure/)).
  id: totrans-1500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 Clojure 宏 ([https://pragprog.com/book/cjclojure/](https://pragprog.com/book/cjclojure/))。
- en: Let over Lambda ([http://letoverlambda.com/](http://letoverlambda.com/)).It
    talks about common Lisp, but the knowledge is very valuable.
  id: totrans-1501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Let over Lambda ([http://letoverlambda.com/](http://letoverlambda.com/)).它讨论了常见的
    Lisp，但知识非常宝贵。
- en: Summary
  id: totrans-1502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You now understand the power of macros and have a very strong grasp of how they
    work, but we just touched the tip of the iceberg when it comes to macros.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经理解了宏的强大功能，并且对它们的工作方式有了非常强的掌握，但当我们谈到宏时，我们只是触及了冰山一角。
- en: 'In this chapter, we learned about the following:'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了以下内容：
- en: Fundamentals of how macros work
  id: totrans-1505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏的工作原理基础
- en: Modifying your code in Groovy
  id: totrans-1506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Groovy 中修改你的代码
- en: The relation of macros to other tools in the Java world
  id: totrans-1507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏与 Java 世界中其他工具的关系
- en: Writing your own macros
  id: totrans-1508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你自己的宏
- en: I am sure you've enjoyed working with Clojure so far, and moving forward, I'd
    recommend you to keep reading and exploring this amazing language.
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你到目前为止已经享受了使用 Clojure 的过程，并且向前看，我建议你继续阅读和探索这个惊人的语言。
