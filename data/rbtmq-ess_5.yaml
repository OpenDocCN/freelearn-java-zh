- en: Message Routing
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 消息路由
- en: Thus far, all message interaction in this book has been unidirectional, flowing
    from message publishers to consumers. What if a consumer wants to alert a publisher
    that processing is complete and send a reply, or a taxi driver wants to acknowledge
    a taxi booking request?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中所有的消息交互都是单向的，从消息发布者流向消费者。如果消费者想要通知发布者处理已完成并发送响应，或者出租车司机想要确认出租车预订请求，会怎样呢？
- en: This chapter covers steps 5 to 10 in the taxi application system architecture,
    where a taxi driver responds to the customer and confirms a booking request. The
    taxi publishes its current location to a queue. The customer's application connects
    to the broker through WebSockets and subscribes to location updates, delivered
    directly from the taxi.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了出租车应用系统架构中的步骤5到10，其中出租车司机响应客户并确认预订请求。出租车将其当前位置发布到一个队列中。客户的应用程序通过WebSockets连接到代理，并订阅位置更新，这些更新直接来自出租车。
- en: The **Remote Procedure Call** (**RPC**) request-response concept will be introduced,
    along with how to route a response back to the consumer. Since **Advanced Message
    Queuing Protocol** (**AMQP**) 0-9-1 , brokers provide four exchange types. This
    chapter also shows how to implement the last one, headers exchange.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将介绍**远程过程调用（RPC**）请求-响应概念，以及如何将响应路由回消费者。自**高级消息队列协议（AMQP）0-9-1**以来，代理提供了四种交换类型。本章还将展示如何实现最后一种，即头部交换。
- en: 'Let''s dive into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入以下主题：
- en: Sending responses to the publisher
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向发布者发送响应
- en: Reply-to queues and RPC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回复队列和RPC
- en: Creating a data analysis service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据分析服务
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter05).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，地址为[https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter05)。
- en: Sending responses to the publisher
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向发布者发送响应
- en: It is true that all of our interactions with RabbitMQ so far have been one way
    and asynchronous. It is also true that clients interacting with a service usually
    expect to receive a response. Reversing the publisher and consumer roles in the
    response phase requires the client to act as a publisher and the service as a
    consumer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，到目前为止，我们与RabbitMQ的所有交互都是单向的异步交互。同样，与服务交互的客户端通常期望收到响应。在响应阶段反转发布者和消费者的角色需要客户端充当发布者，而服务充当消费者。
- en: 'Different queues are used for requests and responses, as demonstrated in [Chapter
    *2*](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating a Taxi Application*,
    and illustrated in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第*2*章](377ec533-342d-4a08-9011-7176de197886.xhtml)中所示，*创建出租车应用*，并如图所示，使用不同的队列来处理请求和响应：
- en: '![](img/df52094d-f1e9-4f0a-a789-08d0dc4c2553.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df52094d-f1e9-4f0a-a789-08d0dc4c2553.png)'
- en: 'Fig 5.1: A request-response interaction performed with message queues'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：使用消息队列执行请求-响应交互
- en: 'In the following diagram, *Fig 5.2*, we can see the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，*图5.2*，我们可以看到以下内容：
- en: When a taxi driver confirms a booking request, a message is sent to the message
    broker with information about the driver (5).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当出租车司机确认预订请求时，会向消息代理发送包含司机信息的信息（5）。
- en: The application service receives the message (6), stores the information in
    the database (7), and confirms the booking with the mobile application, which
    is ultimately shown to the customer (8).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序服务接收消息（6），将信息存储在数据库中（7），并通过移动应用程序确认预订，最终显示给客户（8）。
- en: At this point, the taxi needs to continuously share its current location with
    the customer. This is accomplished by sending the car's latitude and longitude
    to a location queue every minute (9). The customer side of the app uses a WebSocket
    connection over RabbitMQ to subscribe to the current location queue (10).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这一点上，出租车需要持续与客户分享其当前位置。这是通过每分钟向位置队列发送汽车的纬度和经度来实现的（9）。应用程序的客户端使用通过RabbitMQ的WebSocket连接订阅当前位置队列（10）。
- en: '**Complete Car**''s (**CC**''s) architecture is shown in the following diagram,
    as a reminder:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整汽车**（**CC**）的架构如下所示，以供参考：'
- en: '![](img/af043c33-805f-4566-9920-8d1dc2fc470d.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af043c33-805f-4566-9920-8d1dc2fc470d.png)'
- en: 'Fig 5.2: CC''s main application architecture'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：CC的主要应用架构
- en: Let's see how WebSockets is implemented.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看WebSockets是如何实现的。
- en: WebSockets in RabbitMQ
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RabbitMQ中的WebSockets
- en: RabbitMQ is a multi-protocol message broker. This section explores the **Single
    Text-Oriented Message Protocol** (**STOMP**) and how to use it with RabbitMQ to
    build interactive web applications. The Web STOMP RabbitMQ plugin makes it possible
    to use STOMP over the internet, by using WebSockets to send real-time data between
    a client—such as a web browser—and a broker via a web server. The plugin allows
    for highly interactive user experiences with data stored or processed on a server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 是一个多协议消息代理。本节探讨了 **单文本导向消息协议**（**STOMP**）以及如何使用 RabbitMQ 来构建交互式 Web
    应用程序。Web STOMP RabbitMQ 插件使得通过互联网使用 STOMP 成为可能，通过使用 WebSocket 在客户端（如网页浏览器）和通过
    Web 服务器代理之间发送实时数据。该插件允许用户在服务器上存储或处理数据时获得高度交互的用户体验。
- en: Start by enabling the Web STOMP plugin.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先启用 Web STOMP 插件。
- en: Enabling the Web STOMP plugin
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用 Web STOMP 插件
- en: As with the RabbitMQ management plugin, RabbitMQ does not embed the Web STOMP
    plugin by default but offers it as an option. The appropriate RabbitMQ plugin
    must be enabled as well as installed, and a **virtual host** (**vhost**) has to
    be created with the appropriate permissions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与 RabbitMQ 管理插件一样，RabbitMQ 默认不嵌入 Web STOMP 插件，而是将其作为选项提供。必须启用并安装适当的 RabbitMQ
    插件，并且必须创建一个具有适当权限的 **虚拟主机**（**vhost**）。
- en: 'Run the following Debian package script to install the Web STOMP plugin:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下 Debian 软件包脚本以安装 Web STOMP 插件：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For security purposes, create at least one user, with limited permissions,
    on a publicly exposed vhost. Run the following code to create the new vhost:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，在公开暴露的虚拟主机上至少创建一个具有有限权限的用户。运行以下代码以创建新的虚拟主机：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, add user permissions for the `cc-dev` user and the `cc-dev-ws` vhost:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为 `cc-dev` 用户和 `cc-dev-ws` 虚拟主机添加用户权限：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The new vhost is now created and is accessible to the `cc-dev` user. Some basic
    security options should be configured before setting up a new queue for the taxis
    to publish their current locations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 新的虚拟主机已创建，并且对 `cc-dev` 用户可访问。在为出租车设置新队列以发布当前位置之前，应配置一些基本的安全选项。
- en: Securing Web STOMP with SSL
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SSL 保护 Web STOMP
- en: Web STOMP uses the internet, which, in CC's application, leaves information
    vulnerable to snooping unless properly secured. Since most clients send the broker
    **Uniform Resource Locator** (**URL**), username, and password information, an
    additional level of security is necessary.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Web STOMP 使用互联网，在 CC 的应用中，除非得到适当的安全保护，否则信息容易受到窃听。由于大多数客户端发送代理 **统一资源定位符**（**URL**）、用户名和密码信息，因此需要额外的安全层。
- en: 'Luckily, it is possible to tell RabbitMQ to use **Secure Sockets Layer** (**SSL**)
    through the configuration file. For security, the CC team will add the following
    lines to the configuration to set up a certificate:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以通过配置文件告诉 RabbitMQ 使用 **安全套接字层**（**SSL**）。为了安全起见，CC 团队将在配置文件中添加以下行以设置证书：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For the settings to take effect, the broker must be restarted and the default
    username and password changed. The scripts contain the broker URL, which could
    give unwanted easy access to the server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使设置生效，必须重新启动代理并更改默认用户名和密码。脚本包含代理 URL，这可能会给服务器带来不希望的简单访问。
- en: Creating and publishing GPS data to the queue
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建并发布 GPS 数据到队列
- en: 'Now, the CC team will create a queue where the taxi sends the current location,
    this time by using `rabbitmqadmin` and running the following commands to create
    a queue called `taxi_information`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，CC 团队将创建一个队列，出租车将发送当前位置，这次使用 `rabbitmqadmin` 并运行以下命令来创建名为 `taxi_information`
    的队列：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add an exchange called `taxi_exchange`, like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为 `taxi_exchange` 的交换机，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the command-line tools do not allow the action to bind queues to exchanges,
    use the RabbitMQ management interface to bind the `taxi_information` queue to
    the `taxi_exchange` exchange using the `taxi_information` routing key.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令行工具不允许将队列绑定到交换，请使用 RabbitMQ 管理界面使用 `taxi_information` 路由键将 `taxi_information`
    队列绑定到 `taxi_exchange` 交换。
- en: 'The CC team will log in, head to the Queues section, and add this information
    to the Bindings section, as shown in the following diagram:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: CC 团队将登录，转到队列部分，并将此信息添加到绑定部分，如图所示：
- en: '![](img/87070943-e468-4e28-994b-8ccbc3c86988.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87070943-e468-4e28-994b-8ccbc3c86988.png)'
- en: 'Fig 5.3: Add binding to the queue via RabbitMQ management'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：通过 RabbitMQ 管理界面将绑定添加到队列
- en: 'With a queue established, the taxi application can communicate with the broker.
    The code for this is not provided since it would be almost the same code as in
    [Chapter 2](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating a Taxi Application*.
    Instead, the following diagram shows how a message can be published via the management
    console, which is usually used for testing purposes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 建立队列后，出租车应用程序可以与代理通信。此代码未提供，因为它几乎与[第2章](377ec533-342d-4a08-9011-7176de197886.xhtml)中的代码相同，*创建出租车应用程序*。相反，以下图表显示了如何通过管理控制台发布消息，这通常用于测试目的：
- en: '![](img/6edb8a77-9336-496d-985d-ad30f26448bf.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6edb8a77-9336-496d-985d-ad30f26448bf.png)'
- en: 'Fig 5.4: Send GPS coordinates to RabbitMQ'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：将GPS坐标发送到RabbitMQ
- en: The consumer can now subscribe to **Global Positioning System** (**GPS**) data
    from the `taxi_information` queue.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者现在可以订阅来自`taxi_information`队列的**全球定位系统**（**GPS**）数据。
- en: Subscribing to GPS and driver information via WebSockets
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过WebSockets订阅GPS和司机信息
- en: The customer can use the mobile clients to receive location data through WebSockets,
    as shown in *Fig 5.2*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以使用移动客户端通过WebSockets接收位置数据，如图5.2所示。
- en: The customer mobile application uses JavaScript and HTML, made possible with
    tools such as React Native or Angular NativeScript, which are two cross-platform
    frameworks that continue to gain traction.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端移动应用程序使用JavaScript和HTML，这得益于React Native或Angular NativeScript等工具，它们是两个持续获得关注的跨平台框架。
- en: 'The CC team imports the StompJs library ([stomp.umd.min.js](https://stomp-js.github.io/guide/stompjs/using-stompjs-v5.html))
    into the application using a content delivery network, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: CC团队使用内容分发网络将StompJs库([stomp.umd.min.js](https://stomp-js.github.io/guide/stompjs/using-stompjs-v5.html))导入到应用程序中，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, CC includes some code, in order to receive updates from the queue.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，CC包含一些代码，以便从队列中接收更新。
- en: 'First of all, the `stompClient` variable is declared and configured. The broker
    URL should start with `ws://` or `wss://`. The `reconnectDelay` variable in the
    example is set to `200` ms, which means that a retry will happen 200 ms after
    a disconnect, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明并配置`stompClient`变量。代理URL应以`ws://`或`wss://`开头。示例中的`reconnectDelay`变量设置为`200`毫秒，这意味着在断开连接后200毫秒将进行重试，如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, the instance is created and connected to, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建实例并将其连接，如下所示：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The CC team will create a callback to handle incoming messages and subscribe
    directly to the `taxi_information` queue. The username, password, and broker URL
    must be changed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CC团队将创建一个回调来处理传入的消息，并直接订阅到`taxi_information`队列。用户名、密码和代理URL必须更改。
- en: The broker URL must include the Web STOMP port, defaulting to `15674`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代理URL必须包含Web STOMP端口，默认为`15674`。
- en: Happy times! The customer will now know approximately where the taxi is located,
    both before and during the ride.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 快乐时光！客户现在将知道出租车的大致位置，无论是乘车前还是乘车过程中。
- en: Now, let's look at another option to receive a reply from the consumer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一种从消费者那里接收回复的方法。
- en: Reply-to queues and RPC
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回复队列和RPC
- en: The CC application can now communicate in a good way between the publisher and
    the consumer, but what if a function has to run on a remote computer and wait
    for the result? Hardcoding an exchange and routing key in the service to publish
    responses isn't possible as it would be too inflexible. The solution is to have
    the request message carry the coordinates of the location where the response should
    be sent, a pattern commonly known as RPC.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: CC应用程序现在可以在发布者和消费者之间良好地通信，但如果一个函数需要在远程计算机上运行并等待结果呢？在服务中硬编码交换和路由键以发布响应是不可能的，因为这会过于不灵活。解决方案是让请求消息携带响应应发送的位置坐标，这是一种常见的称为RPC的模式。
- en: The application service calls a specific function residing on the taxi application,
    and the taxi sends the result to the end user. The request message carries the
    name of the queue where the response should be sent. The AMQP protocol supports
    this mechanism out of the box. The client can store the queue name of the location
    where the response must be sent.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务调用出租车应用程序中驻留的特定函数，出租车将结果发送给最终用户。请求消息携带应发送响应的队列名称。AMQP协议支持这种机制。客户端可以存储必须发送响应的位置的队列名称。
- en: When RabbitMQ delivers a message to the consumer, it will change the `reply-to`
    property. The server can reply to the message from the publisher by sending a
    message to the default exchange with the routing key of the `reply-to` property.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当RabbitMQ将消息传递给消费者时，它将更改`reply-to`属性。服务器可以通过向默认交换发送带有`reply-to`属性路由键的消息来从发布者回复消息。
- en: 'Any type of queue can be used for the `reply-to` mechanism, but in practice,
    the following two approaches are used:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`reply-to`机制，可以使用任何类型的队列，但在实践中，以下两种方法被使用：
- en: '**Create a short-lived queue for each request-response interaction**. This
    approach uses an exclusive, auto-deleted, nondurable, server-side named queue
    created by the client with the following benefits:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为每个请求-响应交互创建一个短暂队列**。这种方法使用客户端创建的专用、自动删除、非持久的、服务器端命名的队列，具有以下优点：'
- en: No other consumer can get messages from it since it is exclusive.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是专用的，没有其他消费者可以从中获取消息。
- en: It can be auto-deleted; once the reply has been consumed, there is no longer
    a use for it.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以自动删除；一旦回复被消费，就不再需要它。
- en: No need for it to be durable; request-response interactions are not meant to
    be long-lived.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要它是持久的；请求-响应交互并不打算长期存在。
- en: The server generates a unique name, which relieves the client from having to
    figure out a unique naming scheme.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器生成一个唯一的名称，从而减轻了客户端需要想出唯一命名方案的负担。
- en: '**Use a permanent reply-to queue specific to the client**. This approach uses
    a nonexclusive, non-automatically deleted, nondurable, client-side named queue
    with the following benefits:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用针对客户端的特定永久`reply-to`队列**。这种方法使用非专用、非自动删除、非持久的客户端端命名的队列，具有以下优点：'
- en: No need for it to be durable, for the same reason explained previously.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样不需要它是持久的，原因如前所述。
- en: No need for it to be exclusive—a different consumer will be used for each request-response
    interaction.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要它是专用的——每个请求-响应交互将使用不同的消费者。
- en: The difficulty in using a permanent queue is in correlating responses with requests.
    This is done through the `CorrelationId` message property, carried from the request
    message to the response message. This property allows the client to identify the
    correct request to process.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用永久队列的困难在于关联响应与请求。这是通过`CorrelationId`消息属性完成的，该属性从请求消息携带到响应消息。该属性允许客户端识别要处理的正确请求。
- en: A permanent queue is more efficient than using short-lived queues with each
    request since creation and deletion are expensive operations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 永久队列比使用每个请求的短暂队列更有效，因为创建和删除是昂贵的操作。
- en: RabbitMQ client libraries offer primitives that simplify responses correlated
    with requests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ客户端库提供了简化与请求关联的响应的原始操作。
- en: That completes the information on routing back options to response queues through `reply-to`.
    To continue, the CC team will discover the fourth type of exchange offered by
    RabbitMQ by connecting a data analysis service.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了通过`reply-to`将路由回选项信息到响应队列的信息。为了继续，CC团队将通过连接数据分析服务来发现RabbitMQ提供的第四种交换类型。
- en: Creating a data analysis service
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据分析服务
- en: CC wants to be able to analyze incoming data. This system analyses requests
    for taxis in different areas, discovers important patterns, and finds peak request
    times. The project manager assigned the team to build a system capable of running
    several versions of the same service in parallel, allowing the graceful evolution
    of the service during updates.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CC希望能够分析传入的数据。该系统分析不同地区的出租车请求，发现重要模式，并找出高峰请求时间。项目经理指派团队构建一个能够并行运行同一服务的多个版本的系统，以便在更新期间优雅地演进服务。
- en: A member of the team stated that it is possible to use a topic exchange and
    structure the routing key as `{service_name}{version}`. Their idea works within
    the current system; however, RabbitMQ offers a more elegant solution to this problem
    through the headers exchange.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 团队成员表示，可以使用主题交换并将路由键结构化为`{service_name}{version}`。他们的想法在当前系统中是可行的；然而，RabbitMQ通过头部交换提供了对这个问题的更优雅的解决方案。
- en: The headers exchange allows the routing of messages based on their headers,
    which are custom key-value pairs stored in the message properties. The custom
    key-value pairs guide messages to the correct queue or queues. With this approach,
    the message and its routing information are all self-contained, remain consistent,
    and are therefore easier to inspect as a whole.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 头部交换机允许根据消息的头部路由消息，这些头部是存储在消息属性中的自定义键值对。自定义键值对引导消息到正确的队列或队列。采用这种方法，消息及其路由信息都是自包含的，保持一致，因此更容易作为一个整体进行检查。
- en: 'This addition works flawlessly within CC''s architecture, merely requiring
    the team to bind the queues to a headers exchange and send messages with the appropriate
    headers. Start by opening a command-line shell and executing the following commands:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个添加在 CC 的架构中工作得非常完美，只需团队将队列绑定到头部交换机并带有适当头部的消息发送即可。首先打开命令行shell并执行以下命令：
- en: 'Create a new headers exchange called `taxi_headers_exchange`, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `taxi_headers_exchange` 的新头部交换机，如下所示：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The CC team will set up a queue to receive information from the taxis.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CC 团队将设置一个队列以接收来自出租车的信息。
- en: 'Create a new queue called `taxi_information_with_headers`, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `taxi_information_with_headers` 的新队列，如下所示：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Bind the new queue to the `taxi_header_exchange` headers exchange in the management
    console, as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理控制台中，将新队列绑定到 `taxi_header_exchange` 头部交换机，如图下所示：
- en: '![](img/4461780b-78c2-47b2-9f8f-ba96b9bdd10c.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4461780b-78c2-47b2-9f8f-ba96b9bdd10c.png)'
- en: 'Fig 5.5: Bind a queue to an exchange in the management console'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：在管理控制台中将队列绑定到交换机
- en: By setting x-match to all, this means that RabbitMQ will route messages sent
    to taxi_header_exchange to the taxi_information_with_headers queue only when system
    = taxi and version = 0.1b. Otherwise, the system drops the message. Header values
    to match on may be of the String, Number, Boolean, or List types. Routing keys
    aren't required since the key-value pairs serve as the key.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置 x-match 为 all，这意味着只有当 system = taxi 且 version = 0.1b 时，RabbitMQ 才会将发送到
    taxi_header_exchange 的消息路由到 taxi_information_with_headers 队列。否则，系统将丢弃该消息。要匹配的头部值可能是
    String、Number、Boolean 或 List 类型。由于键值对充当键，因此不需要路由键。
- en: 'The x-match parameter specifies whether all headers must match or just one.
    The property can have two different values—any or all, described as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: x-match 参数指定是否所有头部都必须匹配或只需一个。该属性可以有两个不同的值——any 或 all，如下所述：
- en: all is the default value, which means that all header pairs (key, value) must
    match.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: all 是默认值，这意味着所有头部对（键，值）都必须匹配。
- en: any means at least one of the header pairs must match.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: any 表示至少有一个头部对必须匹配。
- en: Because the data analysis service is written in Python, we will switch away
    from Ruby for the moment. Luckily, connecting and publishing messages in Python
    is very much the same as it is in Ruby, so there is no big learning curve to get
    through.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据分析服务是用 Python 编写的，我们将暂时放弃 Ruby。幸运的是，在 Python 中连接和发布消息与在 Ruby 中非常相似，因此没有很大的学习曲线需要克服。
- en: 'Note that the RabbitMQ recommended library for Python is `pika` ([https://pypi.
    org/project/pika/](https://pypi.org/project/pika/)). Information can be sent to
    the new queue as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，RabbitMQ 推荐的 Python 库是 `pika` ([https://pypi.org/project/pika/](https://pypi.org/project/pika/))。信息可以按照以下方式发送到新队列：
- en: 'Start to import the client library `pika` and `json`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始导入客户端库 `pika` 和 `json`：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set credentials to connect to RabbitMQ:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置连接到 RabbitMQ 的凭据：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Assert that the connection is established, and try to open a channel on the
    connection. Set the header version value to `0.1b` and the system value to `taxi`.
    A message is published to the `taxi_header_exchange` with the given GPS positions:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言连接已建立，并尝试在连接上打开一个通道。将头部版本值设置为 `0.1b`，系统值设置为 `taxi`。发布一个带有给定 GPS 位置的消息到 `taxi_header_exchange`。
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because `x-match=all`, both header values must be embedded in the message properties.
    The exchange ensures that the system and version match the values specified in
    the management console before routing the message to the `taxi_information_with_headers`
    queue.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `x-match=all`，两个头部值都必须嵌入到消息属性中。交换机确保在将消息路由到 `taxi_information_with_headers`
    队列之前，system 和 version 与管理控制台中指定的值匹配。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As CC's users and customers become more familiar with the system, they begin
    to ask for more functionality. The CC application is now able to connect to the
    broker through WebSockets and subscribes to location updates delivered directly
    from the taxi. Location messages are flowing and CC's app is working great and
    offering more complex features.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着CC的用户和客户对系统越来越熟悉，他们开始要求更多的功能。现在CC应用程序能够通过WebSockets连接到代理，并订阅直接从出租车发送的位置更新。位置信息正在流动，CC的应用程序运行良好，并提供了更复杂的功能。
- en: This chapter further demonstrated how to use RPC in RabbitMQ via reply-to queues.
    The header exchange was introduced to build a system capable of running several
    versions of the same service in parallel, allowing graceful evolution during updates.
    Another exciting addition to the CC system took place in this chapter, which was
    the ability to incorporate data analysis into the system to discover important
    user patterns and other insights. Header exchanges were thereby explained.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本章进一步演示了如何通过回复队列在RabbitMQ中使用RPC。引入了头部交换，以构建能够并行运行同一服务多个版本的系统，允许在更新期间优雅地演进。CC系统在这一章中还有一项令人兴奋的添加，那就是将数据分析集成到系统中，以发现重要的用户模式和其它洞察。因此，头部交换得到了解释。
- en: The next chapter covers the all-important production realities that CC must
    understand going forward. Important topics such as federation features and clustering,
    along with health checks and alerts, are coming up.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章涵盖了CC必须了解的前瞻性生产现实。重要的话题，如联盟功能和集群，以及健康检查和警报，即将出现。
