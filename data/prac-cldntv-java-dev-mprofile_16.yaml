- en: '*Chapter 12*: MicroProfile LRA and the Future of MicroProfile'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*: MicroProfile LRA及其MicroProfile的未来'
- en: You have reached the final chapter of this book. Congratulations on making it
    this far! In this final chapter, we will briefly discuss the newly released MicroProfile
    **Long-Running Action** (**LRA**) and then look at the future of MicroProfile.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经到达了这本书的最后一章。恭喜您走到了这一步！在本章的最后，我们将简要讨论新发布的MicroProfile **长运行操作**（**LRA**），然后看看MicroProfile的未来。
- en: While writing this book, MicroProfile LRA 1.0 was released to address the need
    for microservice transactions. A traditional **transaction**, as we all must know,
    is a movement of money, such as an online payment or a withdrawal of money from
    a bank. In a traditional application, you normally use technologies such as the
    **two-phase commit** or **eXtended Architecture** (**XA**) protocol to manage
    transactions. However, these technologies do not suit cloud-native application
    transactions. In this chapter, we will explore how MicroProfile addresses the
    need to manage cloud-native transactions. We also will have a look at the transaction
    architecture for cloud-native applications. After that, we will take you through
    the latest MicroProfile platform release. Finally, we will learn about the future
    roadmap of MicroProfile as well as its alignment with the Jakarta EE community.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这本书的过程中，MicroProfile LRA 1.0版本发布，以解决微服务事务的需求。正如我们大家所知道的，传统的**事务**是指资金的移动，例如在线支付或从银行取款。在传统应用中，你通常使用**两阶段提交**或**扩展架构**（**XA**）协议来管理事务。然而，这些技术并不适合云原生应用的事务。在本章中，我们将探讨MicroProfile如何满足管理云原生事务的需求。我们还将查看云原生应用的交易架构。之后，我们将向您介绍最新的MicroProfile平台版本。最后，我们将了解MicroProfile的未来路线图以及它与Jakarta
    EE社区的协同。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Cloud-native application transactions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生应用事务
- en: Using the latest MicroProfile platform release
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最新的MicroProfile平台版本
- en: MicroProfile's technical roadmap
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile的技术路线图
- en: MicroProfile and Jakarta EE alignment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MicroProfile与Jakarta EE的协同
- en: By the end of this chapter, you should be able to use MicroProfile LRA for cloud-native
    application transactions and describe the roadmap for MicroProfile, which will
    help you to architect applications for the future.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该能够使用MicroProfile LRA进行云原生应用事务，并描述MicroProfile的路线图，这将帮助您为未来设计应用。
- en: Cloud-native application transactions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生应用事务
- en: 'Cloud-native application transactions try to ensure data consistency and integrity,
    similar to a traditional transaction. Traditional transactions normally use the
    two-phase commit or XA protocol. The two-phase commit protocol ensures that transactional
    updates are committed in all databases or are fully rolled back in the case of
    a failure. It is widely supported by many databases. As its name implies, this
    protocol consists of two phases: the **voting** **phase** and the **commit phase**.
    In the voting phase, the transaction manager gets approval or rejection from the
    participating XA resources. In the commit phase, the transaction manager informs
    the participants about the result. If the result is positive, the entire transaction
    will be committed. Otherwise, it will be rolled back. This protocol is very reliable
    and guarantees data consistency. The drawback is that it locks resources and might
    lead to indefinite blocking. Therefore, it is not suitable for cloud-native applications,
    because they do not scale well and the latency of held locks is problematic. Consequently,
    the **saga pattern** was established for cloud-native application transactions
    to achieve eventual data consistency. The saga pattern commits local transactions
    and then either completes or compensates the transactions. MicroProfile LRA is
    a realization of the saga pattern. In the upcoming subsections, we will discuss
    more on LRA.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序事务试图确保数据一致性和完整性，类似于传统事务。传统事务通常使用两阶段提交或XA协议。两阶段提交协议确保事务更新在所有数据库中提交，或者在失败的情况下完全回滚。它被许多数据库广泛支持。正如其名称所暗示的，此协议由两个阶段组成：**投票**
    **阶段**和**提交** **阶段**。在投票阶段，事务管理器从参与XA资源获得批准或拒绝。在提交阶段，事务管理器通知参与者结果。如果结果是积极的，整个事务将被提交。否则，它将被回滚。此协议非常可靠，并保证数据一致性。缺点是它会锁定资源，可能导致无限期阻塞。因此，它不适合云原生应用程序，因为它们扩展性不好，持有的锁的延迟问题。因此，为云原生应用程序事务建立了**saga模式**以实现最终数据一致性。MicroProfile
    LRA是saga模式的实现。在接下来的小节中，我们将更详细地讨论LRA。
- en: Using MicroProfile LRA for cloud-native application transactions
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MicroProfile LRA进行云原生应用程序事务
- en: 'MicroProfile LRA ([https://download.eclipse.org/microprofile/microprofile-lra-1.0](https://download.eclipse.org/microprofile/microprofile-lra-1.0))
    provides a solution for cloud-native application transactions. It introduces two
    main concepts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile LRA ([https://download.eclipse.org/microprofile/microprofile-lra-1.0](https://download.eclipse.org/microprofile/microprofile-lra-1.0))
    为云原生应用程序事务提供了一种解决方案。它引入了两个主要概念：
- en: '**LRA participants**: LRA participants are transaction participants, which
    are cloud-native applications.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LRA参与者**：LRA参与者是事务参与者，即云原生应用程序。'
- en: '**LRA coordinator**: The LRA coordinator is a transaction coordinator that
    manages the LRA processing and LRA participants. The LRA coordinator manages all
    LRAs and invokes LRA methods based on the LRA status.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LRA协调器**：LRA协调器是一个事务协调器，负责管理LRA处理和LRA参与者。LRA协调器管理所有LRAs并根据LRA状态调用LRA方法。'
- en: 'The following illustrates the relationships between LRA participants and the
    LRA coordinator:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明了LRA参与者和LRA协调器之间的关系：
- en: '![Figure 12.1 – LRA coordinator and participants'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – LRA协调器和参与者'
- en: '](img/B17377_12_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1](img/B17377_12_01.jpg)'
- en: Figure 12.1 – LRA coordinator and participants
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – LRA协调器和参与者
- en: As shown in *Figure 12.1*, the LRA participants enlist with the LRA coordinator,
    which will then call back with the relevant JAX-RS methods based on the transaction
    status. We will now discuss LRA participants in more detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图12.1*所示，LRA参与者向LRA协调器注册，然后根据事务状态调用相关的JAX-RS方法。我们现在将更详细地讨论LRA参与者。
- en: LRA participants
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LRA参与者
- en: 'LRA participants are JAX-RS methods that are involved in a transaction and
    are annotated with the following LRA annotations in the `org.eclipse.microprofile.lra.annotation`
    package:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: LRA参与者是涉及事务的JAX-RS方法，并在`org.eclipse.microprofile.lra.annotation`包中注解了以下LRA注解：
- en: '`@LRA`: A method with this annotation will be associated with an LRA. The `@LRA`
    annotation registers the method with the LRA coordinator. When using this annotation,
    the following `LRA.Type` is like the `TransactionAttributeType` enum in `LRA.Type`
    variants are as follows:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@LRA`：带有此注解的方法将与LRA相关联。`@LRA`注解将方法注册到LRA协调器。当使用此注解时，以下`LRA.Type`类似于`TransactionAttributeType`枚举，其变体如下：'
- en: 'a) `REQUIRED`: With this type, the method invocation will run with a new LRA
    context if called outside an LRA context. Otherwise, it will run with the same
    context.'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'a) `REQUIRED`: 使用此类型时，如果方法在LRA上下文外部被调用，方法调用将运行在新LRA上下文中。否则，它将以相同的上下文运行。'
- en: 'b) `REQUIRES_NEW`: With this type, the method invocation will always run with
    a new LRA context.'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'b) `REQUIRES_NEW`: 使用此类型时，方法调用将始终在新LRA上下文中运行。'
- en: 'c) `MANDATORY`: With this type, the method invocation will run inside an LRA
    context. If it is called outside an LRA context, an error will be returned.'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'c) `MANDATORY`: 使用此类型时，方法调用将在LRA上下文内部运行。如果它在LRA上下文外部被调用，将返回错误。'
- en: 'd) `SUPPORTS`: With this type, if the method is called outside an LRA context,
    it will be executed outside an LRA context. If it is called inside an LRA context,
    it will be executed inside an LRA context.'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'd) `SUPPORTS`: 使用此类型时，如果方法在LRA上下文外部被调用，它将在LRA上下文外部执行。如果它在LRA上下文内部被调用，它将在LRA上下文内部执行。'
- en: 'e) `NOT_SUPPORTED`: With this type, the method is always executed outside an
    LRA context.'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'e) `NOT_SUPPORTED`: 使用此类型时，方法始终在LRA上下文外部执行。'
- en: 'f) `NEVER`: With this type, if the method is called outside an LRA context,
    it will be executed outside an LRA context. If it is called inside an LRA context,
    the method execution will fail and the return code `412` will be returned.'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'f) `NEVER`: 使用此类型时，如果方法在LRA上下文外部被调用，它将在LRA上下文外部执行。如果在LRA上下文内部调用，方法执行将失败，并返回返回代码`412`。'
- en: 'g) `NESTED`: With this type, when the method is called, a new LRA will be created,
    which can be either top-level or nested based on whether it is called inside an
    LRA context or not. If invoked outside a context, the new LRA will be top-level.
    Otherwise, the new LRA will be nested.'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'g) `NESTED`: 使用此类型时，当方法被调用时，将创建一个新的LRA，这可以是顶层或嵌套的，具体取决于它是否在LRA上下文内部被调用。如果在外部上下文中调用，新的LRA将是顶层的。否则，新的LRA将是嵌套的。'
- en: You might be wondering how to determine whether a method is called inside an
    LRA context. If the `LRA_HTTP_CONTEXT_HEADER` header is present, it means the
    method is called inside an LRA context.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何确定方法是否在LRA上下文内部被调用。如果存在`LRA_HTTP_CONTEXT_HEADER`头，则表示方法是在LRA上下文内部被调用的。
- en: '`@Complete`: A method with this annotation will be called when the LRA closes.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Complete`: 带有此注解的方法将在LRA关闭时被调用。'
- en: '`@Compensate`: A method with this annotation will be invoked if the LRA is
    canceled.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Compensate`: 如果LRA被取消，将调用带有此注解的方法。'
- en: '`@Forget`: A method with this annotation will be invoked if either the `@Complete`
    or `@Compensate` method invocation fails.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Forget`: 如果`@Complete`或`@Compensate`方法调用失败，将调用带有此注解的方法。'
- en: '`@Leave`: A method with this annotation causes the LRA participant to be removed
    from the LRA participation.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Leave`: 带有此注解的方法会导致LRA参与者从LRA参与中移除。'
- en: '`@Status`: A method with this annotation reports the status of the associated
    LRA.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Status`: 带有此注解的方法报告相关LRA的状态。'
- en: '`@AfterLRA`: A method with this annotation will be called when an LRA ends.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AfterLRA`: 带有此注解的方法将在LRA结束时被调用。'
- en: 'The `@Compensate`, `@Complete`, and `@AfterLRA` annotations are for the `PUT`
    operation, while the `@Status` annotation is for the `GET` operation and `@Forget`
    for the `DELETE` operation. Let''s go through this code snippet to explain these
    annotations further:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Compensate`、`@Complete`和`@AfterLRA`注解用于`PUT`操作，而`@Status`注解用于`GET`操作，`@Forget`用于`DELETE`操作。让我们通过这个代码片段进一步解释这些注解：'
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the code snippet, when the `bookHotel()`method is called inside an LRA, this
    method will run with the same LRA context. If it is called outside an LRA context,
    the method will run with a new context. This method might call in to another service.
    If this method succeeds, the `completeBooking()` method will be invoked. Otherwise,
    the `cancelBooking()`method will be invoked. You might be wondering which service
    calls the `completeBooking()` and `cancelBooking()`methods. It's the job of the
    LRA coordinator, which will ensure the corresponding method is invoked. In the
    next section, we will discuss how to make the APIs from LRA available to your
    Maven and Gradle projects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，当`bookHotel()`方法在LRA内部被调用时，此方法将以相同的LRA上下文运行。如果它在LRA上下文外部被调用，该方法将以新的上下文运行。此方法可能会调用另一个服务。如果此方法成功，将调用`completeBooking()`方法。否则，将调用`cancelBooking()`方法。你可能想知道哪个服务调用`completeBooking()`和`cancelBooking()`方法。这是LRA协调器的职责，它将确保调用相应的方法。在下一节中，我们将讨论如何将LRA的API提供给你的Maven和Gradle项目。
- en: Making MicroProfile LRA available
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使MicroProfile LRA可用
- en: 'To use the MicroProfile LRA APIs, you need to make these APIs available to
    your application. If you create a Maven project, you can directly add the following
    to your `pom.xml`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 MicroProfile LRA API，您需要使这些 API 可用于您的应用程序。如果您创建 Maven 项目，您可以直接将以下内容添加到您的
    `pom.xml` 中：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, if you create a Gradle project, you need to add the following
    dependency:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您创建 Gradle 项目，您需要添加以下依赖项：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this, you have learned how to perform transactions in your cloud-native
    application. Congratulations! You have now learned about all the MicroProfile
    specifications. In the next section, let's discuss how best to use the latest
    MicroProfile platform release.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您已经学会了如何在您的云原生应用程序中执行事务。恭喜！您现在已经了解了所有 MicroProfile 规范。在下一节中，让我们讨论如何最好地使用最新的
    MicroProfile 平台版本。
- en: Using the latest MicroProfile platform release
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最新的 MicroProfile 平台版本
- en: In [*Chapter 2*](B17377_02_Final_SB_epub.xhtml#_idTextAnchor036), *How Does
    MicroProfile Fit Into Cloud-Native Application Development?*, we mentioned the
    MicroProfile platform release and its content. So far, the latest MicroProfile
    platform release is MicroProfile 4.1, which can be found at [https://download.eclipse.org/microprofile/microprofile-4.1/](https://download.eclipse.org/microprofile/microprofile-4.1/).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B17377_02_Final_SB_epub.xhtml#_idTextAnchor036)，“MicroProfile 如何适应云原生应用程序开发？”，我们提到了
    MicroProfile 平台版本及其内容。到目前为止，最新的 MicroProfile 平台版本是 MicroProfile 4.1，可以在 [https://download.eclipse.org/microprofile/microprofile-4.1/](https://download.eclipse.org/microprofile/microprofile-4.1/)
    找到。
- en: 'MicroProfile 4.1 was built on top of MicroProfile 4.0, with MicroProfile Health
    updating from 3.0 to 3.1\. MicroProfile 4.1 aligns with the following Jakarta
    EE 8 specifications:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 4.1 是建立在 MicroProfile 4.0 之上的，MicroProfile Health 从 3.0 更新到 3.1。MicroProfile
    4.1 与以下 Jakarta EE 8 规范保持一致：
- en: Jakarta Contexts and Dependency Injection 2.0
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta 上下文和依赖注入 2.0
- en: Jakarta Annotations 1.3, Jakarta RESTful Web Services 2.1
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta 注解 1.3、Jakarta RESTful Web 服务 2.1
- en: Jakarta JSON-B 1.0
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta JSON-B 1.0
- en: Jakarta JSON-P 1.1
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta JSON-P 1.1
- en: Jakarta Annotations 1.3
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jakarta 注解 1.3
- en: 'It also includes the following MicroProfile specifications:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包括以下 MicroProfile 规范：
- en: Config 2.0
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 2.0
- en: Fault Tolerance 3.0
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容错 3.0
- en: Health 3.1
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康性 3.1
- en: JWT Propagation 1.2
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT 传播 1.2
- en: Metrics 3.0
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标 3.0
- en: OpenAPI 2.0
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAPI 2.0
- en: OpenTracing 2.0
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenTracing 2.0
- en: Rest Client 2.0
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rest 客户端 2.0
- en: 'If you want to use a few of the MicroProfile specifications from MicroProfile
    4.1 for your cloud-native applications, you need to follow these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为您的云原生应用程序使用 MicroProfile 4.1 的一些规范，您需要遵循以下步骤：
- en: Make the APIs from MicroProfile 4.1 available for compiling your cloud-native
    applications.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使 MicroProfile 4.1 的 API 可用于编译您的云原生应用程序。
- en: 'If you build a Maven project, add the following dependency in your `pom.xml`
    to make the APIs available to your cloud-native applications:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您构建 Maven 项目，请在您的 `pom.xml` 中添加以下依赖项，以便将 API 供您的云原生应用程序使用：
- en: '[PRE3]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, specify the following dependency for your Gradle projects:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，为您的 Gradle 项目指定以下依赖项：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Choose a MicroProfile 4.1 implementation to run your cloud-native applications.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个 MicroProfile 4.1 实现来运行您的云原生应用程序。
- en: 'Open Liberty was used as the compatible implementation to release MicroProfile
    4.1\. Open Liberty, as mentioned in [*Chapter 7*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146),
    *The MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes,* is a very
    lightweight and performant runtime for supporting MicroProfile specifications.
    It is also a composable runtime. Specifying the following MicroProfile 4.1 feature
    in your `server.xml` causes the implementation of MicroProfile 4.1 to be loaded:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Open Liberty 被用作兼容实现来发布 MicroProfile 4.1。如 [*第 7 章*](B17377_07_Final_SB_epub.xhtml#_idTextAnchor146)，“使用
    Open Liberty、Docker 和 Kubernetes 的 MicroProfile 生态系统”中提到的，Open Liberty 是一个非常轻量级且性能优异的运行时，用于支持
    MicroProfile 规范。它也是一个可组合的运行时。在您的 `server.xml` 中指定以下 MicroProfile 4.1 功能会导致 MicroProfile
    4.1 的实现被加载：
- en: '[PRE5]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use the standalone specifications, such as MicroProfile GraphQL, MicroProfile
    Context Propagation, MicroProfile Reactive Messaging, and MicroProfile LRA, you
    will need to specify the relevant API Maven dependencies as mentioned in the previous
    chapters and then include the corresponding feature elements in your `server.xml`,
    as shown next. The following line pulls in the implementation of MicroProfile
    GraphQL 1.0:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用独立规范，例如 MicroProfile GraphQL、MicroProfile 上下文传播、MicroProfile 反应式消息传递和 MicroProfile
    LRA，您需要指定前几章中提到的相关 API Maven 依赖项，然后在您的 `server.xml` 中包含相应的功能元素，如下所示。以下行引入了 MicroProfile
    GraphQL 1.0 的实现：
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This line enables the support of MicroProfile Context Propagation 1.2:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码启用了 MicroProfile Context Propagation 1.2 的支持：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This line pulls in the implementation of MicroProfile Reactive Messaging 1.0:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码引入了 MicroProfile Reactive Messaging 1.0 的实现：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This line enables MicroProfile LRA participants of MicroPorfile LRA 1.0:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码启用了 MicroProfile LRA 1.0 的 MicroProfile LRA 参与者：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This line enables the MicroProfile LRA coordinator of MicroProfile LRA 1.0:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码启用了 MicroProfile LRA 1.0 的 MicroProfile LRA 协调器：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The support for MicroProfile LRA 1.0 is available in the Open Liberty beta driver
    from 20.0.0.12-beta onward.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 20.0.0.12-beta 版本开始，Open Liberty beta 驱动程序提供了对 MicroProfile LRA 1.0 的支持。
- en: With this, you have gained up-to-date information about MicroProfile. In the
    next section, we will discuss the future roadmap for MicroProfile.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，你已经获得了关于 MicroProfile 的最新信息。在下一节中，我们将讨论 MicroProfile 的未来路线图。
- en: MicroProfile's technical roadmap
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile 的技术路线图
- en: MicroProfile is used to define a programming model for developing cloud-native
    applications. It helps to establish a great ecosystem using different cloud infrastructure
    technologies. These cloud infrastructure technologies include some cloud-native
    frameworks such as Kubernetes, Jaeger, Prometheus, Grafana, and OpenTelemetry.
    Kubernetes, Jaeger, Prometheus, and Grafana are mature technologies, and you probably
    know about them already. You might not know a great deal about OpenTelemetry.
    OpenTelemetry is a new sandbox project from the **Cloud Native Computing Foundation**
    (**CNCF**), and we will spend some time explaining it a bit.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 用于定义开发云原生应用的编程模型。它有助于使用不同的云基础设施技术建立良好的生态系统。这些云基础设施技术包括一些云原生框架，如
    Kubernetes、Jaeger、Prometheus、Grafana 和 OpenTelemetry。Kubernetes、Jaeger、Prometheus
    和 Grafana 是成熟的技术，你可能已经了解它们。你可能对 OpenTelemetry 了解不多。OpenTelemetry 是来自 **云原生计算基金会**
    (**CNCF**) 的新沙盒项目，我们将花一些时间对其进行简要解释。
- en: Adopting OpenTelemetry in MicroProfile
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用 OpenTelemetry 的 MicroProfile
- en: '**OpenTelemetry** ([https://opentelemetry.io/](https://opentelemetry.io/))
    is a new CNCF observability framework developed by merging of **OpenTracing**
    ([https://opentracing.io/](https://opentracing.io/)) and **OpenCensus** ([https://opencensus.io/](https://opencensus.io/)).
    Since MicroProfile OpenTracing, covered in [*Chapter 6*](B17377_06_Final_SB_epub.xhtml#_idTextAnchor123),
    *Observing and Monitoring Cloud-Native Applications*, was based on OpenTracing,
    OpenTelemetry was bound to be adopted by MicroProfile eventually.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenTelemetry** ([https://opentelemetry.io/](https://opentelemetry.io/))
    是由 **OpenTracing** ([https://opentracing.io/](https://opentracing.io/)) 和 **OpenCensus**
    ([https://opencensus.io/](https://opencensus.io/)) 合并而成的一个新的 CNCF 可观测性框架。由于 MicroProfile
    OpenTracing，如 [*第6章*](B17377_06_Final_SB_epub.xhtml#_idTextAnchor123) 中所述，*观察和监控云原生应用*
    基于OpenTracing，OpenTelemetry 最终必然会被 MicroProfile 采用。'
- en: 'A lot of effort has been gone to in the MicroProfile community to investigate
    how to utilize OpenTelemetry in MicroProfile. One suggestion is to continue supporting
    the OpenTracing API, but its implementation adopts OpenTelemetry by using the
    following code snippet to transform an OpenTelemetry tracer to an OpenTracing
    tracer:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 社区投入了大量精力来研究如何在 MicroProfile 中利用 OpenTelemetry。一个建议是继续支持 OpenTracing
    API，但其实现采用 OpenTelemetry，通过以下代码片段将 OpenTelemetry 追踪器转换为 OpenTracing 追踪器：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the tracer transformation, the current MicroProfile OpenTracing should
    be able to continue working. However, the OpenTracing Tracer API won't be maintained
    anymore because the community has moved to working on OpenTelemetry APIs. The
    ultimate goal is to expose the Tracer API (`io.opentelemetry.api.trace.Tracer`)
    from OpenTelemetry. The MicroProfile community is trying to find the best way
    of adopting OpenTelemetry.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过追踪器转换，当前的 MicroProfile OpenTracing 应该能够继续工作。然而，OpenTracing 追踪器 API 将不再维护，因为社区已经转向开发
    OpenTelemetry API。最终目标是暴露 OpenTelemetry 的追踪器 API (`io.opentelemetry.api.trace.Tracer`)。MicroProfile
    社区正在努力寻找采用 OpenTelemetry 的最佳方式。
- en: You might be aware that OpenTelemetry also provides metrics support. Do we need
    to pull OpenTelemetry metrics to MicroProfile? This is an open question. Let's
    discuss the future roadmap of MicroProfile Metrics in the next section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道 OpenTelemetry 也提供了指标支持。我们需要将 OpenTelemetry 指标拉入 MicroProfile 吗？这是一个悬而未决的问题。让我们在下一节中讨论
    MicroProfile Metrics 的未来路线图。
- en: What is the future of MicroProfile Metrics?
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile Metrics 的未来是什么？
- en: '**MicroProfile Metrics**, explained in [*Chapter 6*](B17377_06_Final_SB_epub.xhtml#_idTextAnchor123),
    *Observing and Monitoring Cloud-Native Applications*, was based on **Dropwizard**
    ([https://www.dropwizard.io/en/latest/](https://www.dropwizard.io/en/latest/)),
    a Java framework for developing ops-friendly, high-performance, RESTful web services.
    Dropwizard has been very popular in the past few years. However, recently, **Micrometer**
    ([https://micrometer.io/](https://micrometer.io/)) has gained more momentum and
    become a prominent metrics framework. The MicroProfile Metrics specification team
    is investigating how to adopt Micrometer while keeping the current APIs working
    with either Micrometer or Dropwizard.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile度量指标**，在第[*6章*](B17377_06_Final_SB_epub.xhtml#_idTextAnchor123)中解释，*观察和监控云原生应用*，基于**Dropwizard**
    ([https://www.dropwizard.io/en/latest/](https://www.dropwizard.io/en/latest/))，这是一个用于开发操作友好、高性能、RESTful
    Web服务的Java框架。Dropwizard在过去几年中非常受欢迎。然而，最近，**Micrometer** ([https://micrometer.io/](https://micrometer.io/))获得了更多的动力，并成为了一个突出的度量指标框架。MicroProfile度量指标规范团队正在研究如何在保持当前API与Micrometer或Dropwizard兼容的同时采用Micrometer。'
- en: 'As mentioned previously, OpenTelemetry also contains metrics support. The other
    suggestion is for MicroProfile Metrics to align with OpenTelemetry Metrics. If
    OpenTelemetry Metrics is the new metrics standard in the future, MicroProfile
    should adopt OpenTelemetry Metrics instead. So, MicroProfile offers two metrics
    candidates to choose from. Now, the question arises: *Which one should you choose*?
    It depends on which one will become the mainstream. The ideal situation is that
    Micrometer integrates with OpenTelemetry. if Micrometer integrates well with OpenTelemetry
    Metrics, adopting Micrometer would naturally align with OpenTelemetry Metrics.
    Maybe MicroProfile Metrics should wait for OpenTelemetry Metrics to settle and
    then work out which framework to adopt.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，OpenTelemetry也包含度量指标支持。另一个建议是让MicroProfile度量指标与OpenTelemetry度量指标对齐。如果OpenTelemetry度量指标是未来的新度量标准，MicroProfile应该采用OpenTelemetry度量指标。因此，MicroProfile提供了两个度量指标候选方案供选择。现在，问题出现了：*你应该选择哪一个*？这取决于哪一个将成为主流。理想的情况是Micrometer与OpenTelemetry集成。如果Micrometer与OpenTelemetry度量指标集成良好，采用Micrometer将自然与OpenTelemetry度量指标对齐。也许MicroProfile度量指标应该等待OpenTelemetry度量指标稳定下来，然后确定采用哪个框架。
- en: Apart from the existing MicroProfile specifications, the MicroProfile community
    is also interested in new initiatives, such as gRPC.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了现有的MicroProfile规范之外，MicroProfile社区也对新的倡议感兴趣，例如gRPC。
- en: Adopting gPRC
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用gRPC
- en: Apart from the evolution of the current MicroProfile specifications, the community
    is interested in adopting new technologies to provide better support in cloud-native
    applications. One potential new specification is gRPC.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了当前MicroProfile规范的演变之外，社区还感兴趣于采用新技术以提供更好的云原生应用支持。一个潜在的新规范是gRPC。
- en: '**gRPC** ([https://grpc.io/](https://grpc.io/)) is a modern high-performance
    **Remote Procedure Call** (**RPC**) framework that can run in any environment.
    To make gRPC easier to use in cloud-native applications, it would be great if
    it can be integrated with CDI, JAX-RS, and so on. If MicroProfile adopts gRPC
    to create a new specification MicroProfile gRPC, this specification will be able
    to work closely and seamlessly with other MicroProfile specifications.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**gRPC** ([https://grpc.io/](https://grpc.io/))是一个现代高性能**远程过程调用**（RPC）框架，可以在任何环境中运行。为了使gRPC在云原生应用中更容易使用，如果它能与CDI、JAX-RS等集成，那就太好了。如果MicroProfile采用gRPC创建一个新的规范MicroProfile
    gRPC，这个规范将能够与其他MicroProfile规范紧密且无缝地工作。'
- en: Now that we have discussed the specification updates, we will discuss MicroProfile
    alignment with Jakarta EE releases.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了规范更新，我们将讨论MicroProfile与Jakarta EE版本的对齐。
- en: MicroProfile and Jakarta EE alignment
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MicroProfile与Jakarta EE对齐
- en: MicroProfile adopts a few Jakarta EE technologies, such as CDI, JAX-RS, JSON-B,
    JSON-P, and Common Annotations. MicroProfile 4.0 and 4.1 align with the Jakarta
    EE 8 release. This book is based on the MicroProfile 4.1 release. MicroProfile
    has been working very closely with Jakarta EE. Most major players in MicroProfile
    are also involved in Jakarta EE. MicroProfile and Jakarta EE form a great ecosystem
    for developing cloud-native applications. It is very important that they always
    keep in sync and are compatible with each other. Jakarta EE 9.1 ([https://jakarta.ee/release/9.1/](https://jakarta.ee/release/9.1/))
    was released in 2021, which adds a requirement for MicroProfile to work with this
    release so that end users can use APIs from both frameworks. Due to this requirement,
    we will discuss MicroProfile 5.0 in the next section, which is planned to align
    with Jakarta EE 9.1\.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 采用了几个 Jakarta EE 技术，例如 CDI、JAX-RS、JSON-B、JSON-P 和 Common Annotations。MicroProfile
    4.0 和 4.1 与 Jakarta EE 8 版本对齐。本书基于 MicroProfile 4.1 版本。MicroProfile 与 Jakarta
    EE 一直保持着非常紧密的合作。MicroProfile 中的大多数主要参与者也参与了 Jakarta EE。MicroProfile 和 Jakarta
    EE 形成了一个非常适合开发云原生应用的生态系统。它们始终保持同步并且相互兼容非常重要。Jakarta EE 9.1（[https://jakarta.ee/release/9.1/](https://jakarta.ee/release/9.1/））于
    2021 年发布，这为 MicroProfile 与此版本一起工作添加了一个要求，以便最终用户可以使用这两个框架的 API。由于这个要求，我们将在下一节讨论
    MicroProfile 5.0，该版本计划与 Jakarta EE 9.1 对齐。
- en: Aligning MicroProfile 5.0 with Jakarta EE 9.1
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 MicroProfile 5.0 与 Jakarta EE 9.1 对齐
- en: The focus of MicroProfile 5.0 is to align with Jakarta EE 9.1\. The eight component
    specifications, including Config, Fault Tolerance, Rest Client, Health, Metrics,
    OpenTracing, OpenAPI, and JWT Propagation, need to be updated so that they are
    aligned with Jakarta EE 9.1\. Some of these specifications do not directly depend
    on the Jakarta specifications in their APIs, but their **Technology Compatibility
    Kits** (**TCKs**) pull in Jakarta specifications. For these specifications, only
    a minor release is needed. To make all the MicroProfile specifications work with
    Jakarta 9.1, the specifications under the standalone releases such as Reactive
    Streams Operators, Reactive Messaging, LRA, GraphQL, and Context Propagation all
    need to be updated to align with Jakarta EE 9.1\.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile 5.0 的重点是与 Jakarta EE 9.1 对齐。包括 Config、容错、Rest 客户端、健康、度量、OpenTracing、OpenAPI
    和 JWT 传播在内的八个组件规范需要更新，以便与 Jakarta EE 9.1 对齐。其中一些规范在它们的 API 中并不直接依赖于 Jakarta 规范，但它们的
    **技术兼容性工具包**（**TCKs**）会引入 Jakarta 规范。对于这些规范，只需要进行小版本更新。为了使所有 MicroProfile 规范都能与
    Jakarta 9.1 一起工作，独立发布下的规范，如 Reactive Streams Operators、Reactive Messaging、LRA、GraphQL
    和 Context Propagation，都需要更新以与 Jakarta EE 9.1 对齐。
- en: Apart from the alignment with Jakarta EE, some of the MicroProfile specifications
    extend the current Jakarta specifications. Since these MicroProfile specifications
    were created while Java EE was stagnant, it might be the right time for these
    MicroProfile specifications to become Jakarta specifications so that other Jakarta
    specifications can benefit from them. Let's look at those specifications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与 Jakarta EE 对齐之外，一些 MicroProfile 规范扩展了当前的 Jakarta 规范。由于这些 MicroProfile 规范是在
    Java EE 停滞不前时创建的，因此这些 MicroProfile 规范成为 Jakarta 规范可能是正确的时间，这样其他 Jakarta 规范就可以从中受益。让我们看看那些规范。
- en: Moving some MicroProfile specifications to Jakarta EE
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将一些 MicroProfile 规范迁移到 Jakarta EE
- en: 'Some Jakarta EE specifications, such as **Jakarta NoSQL** (GitHub repository:
    [https://github.com/eclipse-ee4j/nosql](https://github.com/eclipse-ee4j/nosql)),
    would benefit from MicroProfile Config for configuration. If Jakarta EE depended
    on MicroProfile, this would create a circular dependency as MicroProfile aligns
    with Jakarta EE specifications. The other problem is that Jakarta EE specifications
    have traditionally maintained backward compatibility more carefully, while MicroProfile
    specifications can introduce backward-incompatibility changes from time to time.
    Therefore, it might be problematic for Jakarta EE specifications to directly depend
    on MicroProfile specifications. To solve this problem, a new proposal, **Jakarta
    Config**, was put forward to collaborate with MicroProfile Config. Jakarta Config
    (GitHub repository: [https://github.com/eclipse-ee4j/config](https://github.com/eclipse-ee4j/config))
    could become the centerpiece of Jakarta EE. Jakarta Config aims to be included
    in Jakarta Core Profile so that other profiles and MicroProfile can depend on
    this specification.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Jakarta EE规范，例如**Jakarta NoSQL**（GitHub仓库：[https://github.com/eclipse-ee4j/nosql](https://github.com/eclipse-ee4j/nosql)），将受益于MicroProfile
    Config进行配置。如果Jakarta EE依赖于MicroProfile，这将创建一个循环依赖，因为MicroProfile与Jakarta EE规范保持一致。另一个问题是，Jakarta
    EE规范传统上更仔细地维护向后兼容性，而MicroProfile规范有时会引入向后不兼容的更改。因此，Jakarta EE规范直接依赖于MicroProfile规范可能存在一些问题。为了解决这个问题，提出了一个新的提案，**Jakarta
    Config**，以与MicroProfile Config合作。Jakarta Config（GitHub仓库：[https://github.com/eclipse-ee4j/config](https://github.com/eclipse-ee4j/config)）可能成为Jakarta
    EE的核心。Jakarta Config的目标是包含在Jakarta Core Profile中，以便其他配置文件和MicroProfile可以依赖于这个规范。
- en: Apart from alignment with Jakarta EE, MicroProfile is also trying to adopt **Long-Term
    Support** (**LTS**) Java releases such as Java 11 and Java 17\.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与Jakarta EE保持一致之外，MicroProfile还在尝试采用**长期支持**（**LTS**）Java版本，如Java 11和Java
    17。
- en: 'You might still remember the two releases in MicroProfile: platform and standalone.
    The MicroProfile community needs to look at the specifications included in the
    standalone release to see whether it is time to move some specifications back
    to the platform release bucket. The other area the MicroProfile community needs
    to improve is the end-user experience. The MicroProfile community will continue
    improving its entry page ([https://microprofile.io/](https://microprofile.io/)).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得MicroProfile中的两个版本：平台和独立。MicroProfile社区需要查看独立版本中包含的规范，以确定是否是时候将一些规范移回平台版本桶中。MicroProfile社区需要改进的另一个领域是最终用户体验。MicroProfile社区将继续改进其入口页面([https://microprofile.io/](https://microprofile.io/))。
- en: We can't believe that we have reached the end of this book. There are so many
    topics to cover. For further information on MicroProfile, please go to [https://microprofile.io/](https://microprofile.io/).
    If you would like to learn about anything related to MicroProfile, please visit
    the Open Liberty guides ([https://openliberty.io/guides/](https://openliberty.io/guides/)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简直不敢相信这本书已经接近尾声。还有这么多主题需要涵盖。有关MicroProfile的更多信息，请访问[https://microprofile.io/](https://microprofile.io/)。如果您想了解与MicroProfile相关的任何内容，请访问Open
    Liberty指南([https://openliberty.io/guides/](https://openliberty.io/guides/))。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'With that, we come to the end of this book. Let''s revisit what you have learned.
    Throughout this book, we learned how to create cloud-native applications using
    Jakarta REST, JSON-P, JSON-B, CDI, and the MicroProfile Rest Client; then enhance
    cloud-native applications using MicroProfile Config, Fault Tolerance, Open API,
    and JWT Propagation; and finally monitor cloud-native applications using MicroProfile
    Health, Metrics, and Open Tracing. We then learned about the MicroProfile ecosystem
    with Open Liberty, Docker, Kubernetes, and Istio. After we covered all the technologies,
    we then looked at an end-to-end project that utilized different MicroProfile technologies.
    Afterward, we discussed deployment and day 2 operations. We then looked at the
    standalone specifications: MicroProfile GraphQL, MicroProfile Context Propagation,
    and MicroProfile Reactive Messaging.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们来到了这本书的结尾。让我们回顾一下你所学到的内容。在这本书中，我们学习了如何使用Jakarta REST、JSON-P、JSON-B、CDI和MicroProfile
    Rest Client创建云原生应用；然后使用MicroProfile Config、容错、Open API和JWT Propagation增强云原生应用；最后使用MicroProfile
    Health、Metrics和Open Tracing监控云原生应用。然后我们了解了MicroProfile生态系统，包括Open Liberty、Docker、Kubernetes和Istio。在覆盖了所有技术之后，我们查看了一个利用不同MicroProfile技术的端到端项目。之后，我们讨论了部署和第二天操作。然后我们研究了独立的规范：MicroProfile
    GraphQL、MicroProfile Context Propagation和MicroProfile Reactive Messaging。
- en: In this final chapter, we discussed the latest release of MicroProfile LRA 1.0\.
    We then discussed the future roadmap in MicroProfile, followed by the plan with
    Jakarta EE alignment. The takeaway from this chapter is that MicroProfile and
    Jakarta EE are complementary to each other, and they form a great ecosystem that
    supports cloud-native applications.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们讨论了MicroProfile LRA 1.0的最新版本。然后，我们讨论了MicroProfile的未来路线图，接着是与其Jakarta
    EE对齐的计划。本章的要点是MicroProfile和Jakarta EE是相互补充的，它们共同构成了一个支持云原生应用程序的伟大生态系统。
- en: We hope you have enjoyed reading this book and learned how to use the amazing
    features of MicroProfile to help you with your cloud-native application development,
    deployment, and management. If you would like to contribute to MicroProfile, please
    click on the **Join The Discussion** link on the microprofile.io website ([https://microprofile.io/](https://microprofile.io/))
    to express your interest in being on the mailing list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您喜欢阅读这本书，并学会了如何使用MicroProfile的惊人特性来帮助您进行云原生应用程序的开发、部署和管理。如果您想为MicroProfile做出贡献，请点击microprofile.io网站上的**加入讨论**链接（[https://microprofile.io/](https://microprofile.io/))以表达您加入邮件列表的兴趣。
