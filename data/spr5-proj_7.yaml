- en: Task Management System Using Spring and Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring和Kotlin的任务管理系统
- en: In the chapters so far, we have explored various topics and concepts in depth.
    Starting with the pure Spring Framework and moving onto Spring Boot, we learned
    how quickly and easily we can create an enterprise-grade application with Spring
    Boot.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们深入探讨了各种主题和概念。从纯Spring框架开始，到Spring Boot，我们学习了如何快速、轻松地使用Spring Boot创建企业级应用程序。
- en: We also learned about the integration of the Spring Framework with other tools
    and technologies, such as Elasticsearch, LDAP, and OAuth, within the purview of
    the Spring Boot context. We then learned a new way of creating an application
    with Spring as a backend and Angular as a frontend with a tool called **JHipster**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了Spring框架与其他工具和技术的集成，例如Elasticsearch、LDAP和OAuth，这些都属于Spring Boot的范畴。然后，我们学习了使用Spring作为后端和Angular作为前端创建应用程序的新方法，这个工具叫做**JHipster**。
- en: Then, we discovered how to create an application with modern architecture in
    the dimension of the distributed environment called **microservice**. In this
    chapter, we go further and explore a completely different dimension of the Spring
    Framework, looking at how it is supported by a new programming language called
    **Kotlin**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们发现了如何在**微服务**这种分布式环境的维度中创建应用程序。在本章中，我们将进一步探索Spring框架的另一个完全不同的维度，看看它如何被一种名为**Kotlin**的新编程语言所支持。
- en: As a programming language, Kotlin has quickly become popular among developers
    and companies. The first stable version of Kotlin was released officially in 2016\.
    The very next year Google officially declared Kotlin as a supported language for
    mobile development on an Android platform. This greatly increased the popularity
    and adoption rate of Kotlin.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种编程语言，Kotlin在开发者和公司中迅速流行起来。Kotlin的第一个稳定版本于2016年正式发布。就在第二年，谷歌正式宣布Kotlin是Android平台移动开发的官方支持语言。这极大地提高了Kotlin的知名度和采用率。
- en: 'Starting with version 5, Spring announced support for Kotlin to develop enterprise
    applications on a Spring Framework. In this chapter, we will explore how to develop
    a Spring-based application with Kotlin. We will build an application called Task
    Management with Spring Boot and Kotlin, and will cover the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本5开始，Spring宣布支持使用Kotlin在Spring框架上开发企业应用程序。在本章中，我们将探讨如何使用Kotlin开发基于Spring的应用程序。我们将构建一个名为Task
    Management的应用程序，使用Spring Boot和Kotlin，并涵盖以下内容：
- en: Introduction to Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin简介
- en: Basic features of Kotlin as a programming language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin作为编程语言的基本功能
- en: Kotlin versus Java
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin与Java的比较
- en: Spring support for Kotlin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring对Kotlin的支持
- en: Developing a Task Management application in Spring with Kotlin
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kotlin在Spring中开发任务管理应用程序
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter07](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter07).
    The code can be executed on any operating system, although it has only been tested
    on Windows.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter07](https://github.com/PacktPublishing/Spring-5.0-Projects/tree/master/chapter07)。代码可以在任何操作系统上执行，尽管它只在Windows上进行了测试。
- en: Introducing Kotlin
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kotlin
- en: Kotlin is a language for **Java Virtual Machine** (**JVM**) and hence can be
    used in place of Java. Be it server side, mobile, or web, you can use Kotlin everywhere
    Java is used at present. It is sponsored by a company called **JetBrains**; it
    is open source, and you can download the source code from GitHub ([https://github.com/jetbrains/kotlin](https://github.com/jetbrains/kotlin)).
    They plan to roll out Kotlin for embedded and iOS platforms in the near future.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin是一种针对**Java虚拟机**（**JVM**）的语言，因此可以替代Java使用。无论是服务器端、移动端还是Web端，你都可以在Java目前使用的任何地方使用Kotlin。它由一家名为**JetBrains**的公司赞助；它是开源的，你可以从GitHub（[https://github.com/jetbrains/kotlin](https://github.com/jetbrains/kotlin)）下载源代码。他们计划在不久的将来推出Kotlin用于嵌入式和iOS平台。
- en: Kotlin provides good support as a functional programming language. The term
    functional programming is used to describe a declarative paradigm where the program
    is created by an expression or declaration rather than by the execution of commands.
    The functional programming model inherently brings certain qualities to the application,
    such as more compressed and predicted code, easy testing ability, reusability,
    and so on. Kotlin brings a functional paradigm in the form of inbuilt features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 作为一种函数式编程语言提供了良好的支持。函数式编程这个术语用来描述一种声明性范式，其中程序是通过表达式或声明创建的，而不是通过命令的执行。函数式编程模型本质上为应用程序带来某些品质，如更紧凑和可预测的代码、易于测试的能力、可重用性等等。Kotlin
    通过内置特性引入了函数式范式。
- en: There are many similarities between Java and Kotlin, and so the question arises,
    why do we need another programming language when Java has been widely used and
    very popular for more than two decades. The answer lies in some of the cool features
    Kotlin has, which make it the better choice for developing JVM-based applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Java 和 Kotlin 之间有许多相似之处，因此产生了这样的问题：当 Java 已经被广泛使用并且超过二十年来非常受欢迎时，为什么我们还需要另一种编程语言。答案在于
    Kotlin 拥有一些酷炫的特性，这使得它成为开发基于 JVM 的应用程序的更好选择。
- en: Interoperability
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互操作性
- en: One of the most promising features of Kotlin is its interoperable capabilities.
    Kotlin is 100% interoperable with Java. The application can combine both the languages.
    The call to Java libraries can be made from Kotlin without any conversion or fuss.
    Similarly, code written in Kotlin can also be called from Java with ease. This
    greatly helps Java developers to migrate from Java to Kotlin without any difficulty.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 最有希望的特性之一是其互操作性。Kotlin 与 Java 完全兼容。应用程序可以结合这两种语言。可以从 Kotlin 中调用 Java
    库，而无需任何转换或麻烦。同样，用 Kotlin 编写的代码也可以轻松地从 Java 中调用。这极大地帮助 Java 开发者轻松地从 Java 迁移到 Kotlin。
- en: 'Migrating a code from one programming language to another is a quite tedious
    and time-consuming task, especially when those programming languages are incompatible,
    in terms of rules, syntax, features, and so on. Although there are a bunch of
    features available in Kotlin that are not present directly or indirectly in Java,
    it is the interoperability of Kotlin that allows running the code with both programming
    languages simultaneously. You do not have to migrate all Java code to Kotlin.
    Kotlin''s **Interoperability** is shown in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码从一个编程语言迁移到另一个编程语言是一项相当繁琐且耗时的工作，尤其是当这些编程语言在规则、语法、特性等方面不兼容时。尽管 Kotlin 中有一些在
    Java 中直接或间接不存在的功能，但正是 Kotlin 的互操作性允许同时运行这两种编程语言的代码。您不必将所有 Java 代码迁移到 Kotlin。以下图表展示了
    Kotlin 的**互操作性**：
- en: '![](img/e3cc5dc9-95a7-4c99-a716-6a793669cb62.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3cc5dc9-95a7-4c99-a716-6a793669cb62.png)'
- en: 'On top of this, the Kotlin standard library is dependent on the Java Class
    Library, which enables reusing the dependencies, and no code refactoring is required
    in any of the places. For example: Kotlin''s collection framework is built on
    top of Java''s collection API.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kotlin 的标准库依赖于 Java 类库，这使得可以重用依赖项，并且在任何地方都不需要代码重构。例如：Kotlin 的集合框架建立在 Java
    的集合 API 之上。
- en: Concise yet powerful
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简洁而强大
- en: While working with Kotlin, you will find another good quality is how concise
    it is. The Kotlin syntax is easy to read and interpret even without prior knowledge
    of any programming language. Kotlin has certain features that make it a truly
    concise language, such as type interface, data classes, properties, smart casts,
    and a lot more. We will see more detail about each of them later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Kotlin 的过程中，你会发现另一个很好的品质就是它的简洁性。Kotlin 的语法易于阅读和理解，即使没有任何编程语言的前置知识。Kotlin
    拥有一些特性，使其成为一个真正简洁的语言，例如类型接口、数据类、属性、智能转换等等。我们将在本章后面更详细地介绍它们。
- en: With these features, the code written with Kotlin is compact without losing
    its capabilities. Kotlin is more concise than Java in many aspects, and because
    of this we can implement the same functionality with fewer lines of code. This
    greatly improves legibility and ease of use. Developers can easily read, code,
    and update the program, even when it has been written by others.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些特性，用 Kotlin 编写的代码紧凑而不失其功能。在许多方面，Kotlin 比 Java 更简洁，因此我们可以用更少的代码实现相同的功能。这极大地提高了可读性和易用性。开发者可以轻松地阅读、编写和更新程序，即使它是别人编写的。
- en: Furthermore, Kotlin enables the speeding up of day-to-day development tasks
    with various features such as default parameters, extension functions, and object
    declarations. Your code is more compact and yet robust, without raising any maintainability
    concerns. This will reduce the possibility of bugs in the system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kotlin 通过各种功能如默认参数、扩展函数和对象声明等，能够加速日常开发任务的执行。您的代码更加紧凑且稳健，同时不会引发任何可维护性问题。这将降低系统出现错误的可能性。
- en: Kotlin evolved as an enhancement to Java rather than as a completely new language.
    So the skills and knowledge you have with Java can be applied to Kotlin, making
    it an easy language to learn.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是作为 Java 的增强而非完全新的语言而演化的。因此，您在 Java 中拥有的技能和知识可以应用于 Kotlin，使其成为一门易于学习的语言。
- en: Safety feature
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全特性
- en: Another reason you will love Kotlin is its safety feature. The code written
    in Kotlin is far safer than that written in Java. Kotlin is designed in a way
    to shield it from the common programming flaws, which results in a more stable
    system with fewer crashes and failures.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您会喜欢 Kotlin 的另一个原因是它的安全特性。用 Kotlin 编写的代码比用 Java 编写的代码要安全得多。Kotlin 的设计旨在防止常见的编程错误，从而使得系统更加稳定，减少崩溃和故障。
- en: For any programming language that allows the null reference will create a runtime
    exception, such as `NullPointerException` , during the execution of the application.
    Improper handling of such a scenario may result in an abrupt system collision.
    If you have prior experience of Java, you might have experienced such scenarios.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何允许空引用的编程语言，在应用程序执行过程中都可能会创建运行时异常，例如 `NullPointerException`。不恰当地处理此类场景可能会导致系统突然崩溃。如果您有
    Java 的经验，您可能已经遇到过这样的场景。
- en: 'Kotlin was designed with this in mind and defines the reference types in two
    categories: those that are nullable and those that are not. By default, Kotlin
    does not allow the reference with the null value and forces the developer to handle
    them in a specific manner. This greatly reduces the possibility of problems caused
    by `NullPointerException`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 就是基于这个理念设计的，并定义了两种引用类型：可空类型和不可空类型。默认情况下，Kotlin 不允许使用空值引用，并强制开发者以特定方式处理它们。这大大减少了由
    `NullPointerException` 引起的问题的可能性。
- en: IDE Support
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE 支持
- en: '**JetBrains**, the company behind Kotlin, is well known for its **i****ntegrated
    development environment (IDE)** called **IntelliJ IDEA**, andobviously has first-class
    support for Kotlin. As far as the IDE is concerned, Eclipse is also one of the
    most favored among Java developers, and so JetBrains also offers a Kotlin plugin
    for Eclipse.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**JetBrains**，Kotlin 背后的公司，因其名为 **IntelliJ IDEA** 的 **集成开发环境（IDE**）而闻名，并且显然为
    Kotlin 提供了一级支持。就 IDE 而言，Eclipse 也是 Java 开发者中最受欢迎的之一，因此 JetBrains 也为 Eclipse 提供了一个
    Kotlin 插件。'
- en: In the very early days when Java had just evolved, there was no IDE in the initial
    stage and developers had to use text editors to do coding. It was difficult working
    without the safety and convenience of an IDE. When Eclipse came onto the market,
    developers quickly adopted it and since then it has become popular and widely
    accepted among Java developers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 刚刚发展的早期，初始阶段并没有 IDE，开发者必须使用文本编辑器进行编码。没有 IDE 的安全和便利性进行工作是非常困难的。当 Eclipse
    进入市场时，开发者迅速采用了它，从那时起，它已经成为 Java 开发者中流行且广泛接受的工具。
- en: Kotlin, on the other hand, was lucky enough to get IDE support from day one.
    This quickly boosted the popularity of Kotlin. It was really convenient and easy
    to learn. Developers were able to produce good quality code quickly, improving
    the software development life cycle.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Kotlin 从一开始就幸运地获得了 IDE 支持。这迅速提升了 Kotlin 的知名度。它非常方便且易于学习。开发者能够快速生成高质量的代码，从而提高软件开发周期。
- en: Needless to say, Kotlin allows coding with text editors. Also, you can use Command
    Prompt to build Kotlin applications. Additionally, if you are an Android developer,
    it has its own IDE called **Android Studio** developed on top of IntelliJ IDEA
    IDE.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，Kotlin 允许使用文本编辑器进行编码。此外，您还可以使用命令提示符构建 Kotlin 应用程序。另外，如果您是 Android 开发者，它还有自己的
    IDE，名为 **Android Studio**，这是基于 IntelliJ IDEA IDE 开发的。
- en: Kotlin features
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 特性
- en: Kotlin was designed not to compete with Java, but rather to be a good JVM language
    with added features not present in Java. Kotlin, as a language, has lots of new
    and exciting features, compared to Java, that increase code readability and maintainability.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的设计初衷不是与 Java 竞争，而是要成为一个具有 Java 所不具备的额外功能的良好 JVM 语言。与 Java 相比，Kotlin
    作为一种语言，拥有许多新颖且令人兴奋的特性，这些特性提高了代码的可读性和可维护性。
- en: It is vital to understand the basic features of Kotlin. In this section, we
    will explore a few of them that are essential for building an application in Kotlin.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Kotlin的基本特性至关重要。在本节中，我们将探讨一些对于在Kotlin中构建应用程序至关重要的特性。
- en: The concept of a function
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数的概念
- en: By definition, a function is a set or group of related statements that perform
    a specific task. It is a basic building block of any program. You can equate the
    function in Kotlin with the method in Java; however, there are certain differences.
    The function in Kotlin can be defined at the top level, meaning it is not required
    to be enclosed in a class. The function can be part of a class as well as defined
    within another function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，函数是一组执行特定任务的语句集合或组。它是任何程序的基本构建块。你可以在Kotlin中将函数等同于Java中的方法；然而，它们之间有一些区别。Kotlin中的函数可以在顶级定义，这意味着它不需要被包含在类中。函数可以是类的一部分，也可以在另一个函数中定义。
- en: In Kotlin, the functions get first-class support, meaning it supports all the
    operations and can be stored into a variable and data structure, passed as an
    argument to other function as well as being returned from other (top-level) functions,
    it can be defined as an expression, and lots more. All these features bring a
    great amount of flexibility and make Kotlin really concise. We will see the following
    uses of functions in Kotlin.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，函数获得了一级支持，这意味着它支持所有操作，可以存储到变量和数据结构中，可以作为参数传递给其他函数，也可以从其他（顶级）函数返回，可以定义为表达式，还有更多。所有这些特性都带来了极大的灵活性，使Kotlin非常简洁。我们将看到Kotlin中函数的以下用法。
- en: Function as an expression
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为表达式
- en: 'While writing the function, you need to put the code in a function body. However,
    in Kotlin, you can define a function as an expression. For example: you want to
    find the minimum between two numbers and you wrote a function called `min()` as
    follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数时，你需要将代码放在函数体中。然而，在Kotlin中，你可以将函数定义为表达式。例如：你想找出两个数字中的最小值，你编写了一个名为`min()`的函数，如下所示：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will return the minimum number out of two given numbers. This function
    can be written as an expression style as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回两个给定数字中的最小值。这个函数可以按照以下表达式风格编写：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is how the code looks expressive and compact. Also, notice that we have
    removed the `return` keyword, as Kotlin is smart enough to return the last value
    without explicitly specifying the `return` keyword. This is what is called a **single
    line** or **one line** function. However, for a complex function, you can write
    it in multiple lines as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码看起来既简洁又具有表现力的方式。此外，请注意，我们已经删除了`return`关键字，因为Kotlin足够智能，可以在不显式指定`return`关键字的情况下返回最后一个值。这被称为**单行**或**一行**函数。然而，对于复杂的函数，你可以像以下这样编写多行：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This looks more compact and expressive.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更紧凑且更具表现力。
- en: Default function arguments
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认函数参数
- en: Often, the amount of data that we supply to functions or constructors varies
    in different use cases. The system should be flexible enough to produce the desired
    result even if we don't provide the values of all the parameters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们提供给函数或构造函数的数据量在不同用例中会有所不同。系统应该足够灵活，即使我们没有提供所有参数的值，也能产生所需的结果。
- en: If you want to achieve this in Java, you need to write a couple of overloaded
    functions or constructors as per your need. You will end up writing the same method
    multiple times with a different set of input parameters and calling other constructors
    or methods with default values. This quickly results in verbose code—writing code
    again and again for the same thing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Java中实现这个功能，你需要根据需要编写几个重载的函数或构造函数。你将不得不多次编写相同的方法，但输入参数不同，并使用默认值调用其他构造函数或方法。这很快会导致代码冗长——为同一件事反复编写代码。
- en: Kotlin provides an intuitive solution to this scenario with the feature called
    the default function argument. This is as simple as it sounds. You need to define
    a default value to those function arguments that you feel may not be provided
    with the value at the time of executing the function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin通过一个名为默认函数参数的功能提供了对这种场景直观的解决方案。这听起来很简单。你需要为那些你认为在执行函数时可能没有提供值的函数参数定义默认值。
- en: 'For example: let''s say we wrote the function to find the volume of the cube
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：假设我们编写了一个函数来计算立方体的体积，如下所示：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While calling this function, you need to pass all three parameters or else
    the compiler will signal the error. Now, assume that we want the system to take
    the default height as `10` if it is not provided explicitly. It can be written
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用此函数时，您需要传递所有三个参数，否则编译器将发出错误信号。现在，假设我们希望系统在没有明确提供的情况下使用默认高度`10`。它可以写成以下形式：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function can be called as `getVolume(2,4)` and `10` will be substituted
    as a default value to `height`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以调用为`getVolume(2,4)`，并将`10`作为默认值替换为`height`。
- en: Extension functions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: If you need to extend a class with a set of new functionalities, you need to
    update the Java source code. However, if you are using third-party libraries,
    you may not have the source. A class needs to be extended to accommodate other
    functions. You also can use various design patterns such as decorator and strategy
    for this purpose.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要通过一组新功能扩展一个类，您需要更新Java源代码。然而，如果您正在使用第三方库，您可能没有源代码。一个类需要被扩展以容纳其他函数。您还可以使用各种设计模式，如装饰者和策略，来实现这一目的。
- en: However, Kotlin allows the straightforward adding of extra functions to an existing
    class with the feature called an **e****xtension function**. As its name implies,
    an extension function extends the functionality of the class without touching
    its source code. In other words, you are no longer required to inherit the class
    to be extended. This sounds really interesting. It behaves just like other member
    functions but is declared outside of the class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kotlin允许通过一个称为**扩展函数**的功能直接向现有类添加额外的函数。正如其名所示，扩展函数扩展了类的功能，而不接触其源代码。换句话说，您不再需要继承要扩展的类。这听起来非常有趣。它表现得就像其他成员函数一样，但声明在类的外部。
- en: 'Assume that you need to convert the given string into camel case. The Kotlin `String` class
    does not provide the functionality to convert a given string into camel case out
    of the box. We will the use extension function to define a separate function that,
    will actually do this job as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要将给定的字符串转换为驼峰式。Kotlin的`String`类不提供直接将字符串转换为驼峰式的功能。我们将使用扩展函数来定义一个单独的函数，该函数实际上会执行这项工作，如下所示：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `camelCase()` function is the extension function on the `String` class,
    which returns the string. The custom logic resides in the body of this function.
    You can call the `camelCase()` function on any string literal as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`camelCase()`函数是`String`类上的扩展函数，它返回字符串。自定义逻辑位于此函数的主体中。您可以在任何字符串字面量上调用`camelCase()`函数，如下所示：'
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `camelCase()` function is our custom function so you can use any other
    name you feel appropriate. Let''s see one more example of an extension function.
    Suppose you want to find the square of a given integer. Again, Kotlin does not
    provide a direct function for that but we can write the extension function as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`camelCase()`函数是我们自定义的函数，因此您可以使用任何您认为合适的其他名称。让我们再看一个扩展函数的例子。假设您想找到一个整数的平方。同样，Kotlin不提供直接的功能，但我们可以编写扩展函数如下：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `square()` extension function can be called in an integer literal as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`square()`扩展函数可以在整数字面量中调用，如下所示：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is an extraordinary feature that we can use to extend functionalities without
    updating the code or inheriting the base class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常出色的功能，我们可以使用它来扩展功能，而无需更新代码或继承基类。
- en: Lambda expression or function literal
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式或函数字面量
- en: 'Every programming language has a provision for defining the literals, such
    as string, integer, double, and so on. They can be defined in a specific manner
    such as string literal as `Hello`, double literal as `34.23`, and so on. Kotlin
    allows us to define a function as a literal by enclosing the code in braces as
    follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都提供了定义字面量的规定，例如字符串、整数、双精度浮点数等。它们可以以特定方式定义，例如字符串字面量`Hello`，双精度浮点数字面量`34.23`等。Kotlin允许我们通过将代码括在花括号中来定义一个函数字面量，如下所示：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function can be declared in a normal way as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以按照以下方式正常声明：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is essentially the same thing as a function literal. But the functional
    literal looks pretty compact yet expressive. A function literal can be assigned
    to a variable and called at a later point of the code as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它本质上与函数字面量相同。但函数字面量看起来既紧凑又富有表现力。函数字面量可以被分配给变量，并在代码的稍后位置调用，如下所示：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The function literal can be assigned to a variable as in the first line. Just
    like other functions, the function literal can be invoked with a variable (with
    parenthesis) as shown in the second line. There are certain characteristics of
    the function literal as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 函数字面量可以像第一行那样分配给变量。就像其他函数一样，函数字面量可以用变量（带括号）调用，如第二行所示。函数字面量有以下某些特性：
- en: It represents the block or body of the function that does not have any name.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它代表函数的块或主体，该块没有名称。
- en: It is not associated with or bound to any entity such as class, interface, or
    object, and hence an access modifier is not allowed.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与任何实体（如类、接口或对象）无关联或绑定，因此不允许使用访问修饰符。
- en: Since it does not have a name, it is called **anonymous.**
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它没有名称，因此被称为**匿名**。
- en: It can be passed to other functions (mainly high-order functions) as an argument.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以作为参数传递给其他函数（主要是高阶函数）。
- en: It is generally surrounded by curly braces and without the `fun` keyword.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通常被大括号包围，且没有 `fun` 关键字。
- en: It is also known as a lambda expression.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也被称为 lambda 表达式。
- en: 'Kotlin also allows passing parameters to a function literal or lambda expression
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 还允许将参数传递给函数字面量或 lambda 表达式，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The lambda expression is divided into two parts by an arrow (`->`). The left
    part is the parameter section, while the right part is the lambda or function
    body. Multiple parameters are allowed with comma-separated lists and without enclosing
    them in parentheses as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 表达式由一个箭头（`->`）分为两部分。左边是参数部分，而右边是 lambda 或函数主体。允许使用逗号分隔的列表来指定多个参数，且不需要用括号括起来，如下所示：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can write this code in a slightly different way as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以稍微不同的方式编写此代码，如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, the declaration of a parameter is moved out from the lambda expression.
    The `Unit` function in Kotlin is equivalent to `void` in Java. This feature makes
    Kotlin a truly functional language. The function literal can also be the parameter
    of another function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，参数的声明被从 lambda 表达式中移出。Kotlin 中的 `Unit` 函数相当于 Java 中的 `void`。这个特性使得 Kotlin
    成为一个真正的函数式语言。函数字面量也可以作为另一个函数的参数。
- en: Passing lambda to another function
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 lambda 传递给另一个函数
- en: Kotlin allows us to pass a function to other (higher-order) functions as a parameter,
    using the lambda expression. Such a function can accept as a parameter a lambda
    expression or an anonymous function. Before discussing this topic further, let
    us first understand what a function type is.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 允许我们将函数传递给其他（高阶）函数作为参数，使用 lambda 表达式。这样的函数可以接受 lambda 表达式或匿名函数作为参数。在进一步讨论这个主题之前，让我们首先了解什么是**函数类型**。
- en: 'Kotlin is a statically typed language and the functions also need to have a
    type. It is called a **function type**. We will see a few examples of how to define
    them as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是一种静态类型语言，函数也需要有类型。这被称为**函数类型**。以下是一些定义它们的示例：
- en: '`()->Int`: The function type that returns an integer type and takes no argument.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()->Int`：返回整数类型且不接受任何参数的函数类型。'
- en: '`(Int)->Unit`: The function type that takes an integer parameter and returns
    nothing.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(Int)->Unit`：接受一个整数参数且不返回任何内容的函数类型。'
- en: '`()->(Int)->String`: The function type that returns another function, which
    eventually returns a string. The latter function takes an integer as a parameter.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()->(Int)->String`：返回另一个函数的函数类型，该函数最终返回一个字符串。后一个函数接受一个整数作为参数。'
- en: 'Now, let''s see how we can define a function type as an input parameter to
    the outer function. Consider a scenario where you are designing an application
    for a bank loan. You need to check the eligibility criteria and decide whether
    a loan is applicable. The function that does this job should look as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将函数类型定义为外部函数的输入参数。考虑这样一个场景，你正在为银行贷款应用程序设计。你需要检查资格标准并决定是否可以申请贷款。执行此任务的函数应如下所示：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `isEligibleForLoan()` function is a higher-order function that takes two
    parameters. The first parameter is the applicant''s mobile number from which it
    will fetch the applicant''s details. The second parameter is a function type,
    which we can consider as a sort of interface type. It simply calculates the eligibility
    score based on a given applicant ID. The actual implementation of the function
    type will be provided when the `isEligibleForLoan()` function is called as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEligibleForLoan()` 函数是一个高阶函数，它接受两个参数。第一个参数是申请人的手机号码，它将从中获取申请人的详细信息。第二个参数是函数类型，我们可以将其视为一种接口类型。它简单地根据给定的申请人ID计算资格分数。该函数类型的实际实现将在调用
    `isEligibleForLoan()` 函数时提供，如下所示：'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need to pass a lambda expression in the second parameter. It is nothing but
    an anonymous function that takes the application ID as an input parameter and
    calculates an eligibility score. The score will be returned back to the `isEligibleForLoan()`
    function from where, based on the score, we return whether a loan is applicable
    or not.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在第二个参数中传递一个 lambda 表达式。这实际上是一个匿名函数，它接受应用程序ID作为输入参数并计算资格分数。分数将被返回到 `isEligibleForLoan()`
    函数，然后根据分数，我们返回是否可以申请贷款。
- en: 'If the function type is the last parameter, then Kotlin allows to call it in
    a slightly different way. The preceding function can be called alternatively as
    follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数类型是最后一个参数，那么 Kotlin 允许以稍微不同的方式调用它。前面的函数可以如下替代调用：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this way, the lambda expression is placed outside of the parenthesis, which
    is more expressive. But this is only possible when a function type is declared
    at the last parameter. Passing a lambda expression as a function type is useful,
    especially for an Ajax call where we want to update the page element once we get
    the data from the response without freezing the UI. The function that is injected
    through the lambda expression will work as a callback function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，lambda 表达式被放置在括号之外，这更加具有表达性。但这只有在最后一个参数声明了函数类型时才可行。将 lambda 表达式作为函数类型传递是有用的，尤其是在
    Ajax 调用中，我们希望在从响应中获取数据后更新页面元素，而不冻结用户界面。通过 lambda 表达式注入的函数将作为回调函数工作。
- en: Returning a function from another function
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一个函数中返回一个函数
- en: We have seen how function type can be defined as a parameter while calling another
    function. With the help of a lambda expression, it becomes even more straightforward.
    One step further, Kotlin allows the returning of a function from another function.
    Let's understand how that works.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在调用另一个函数时将函数类型定义为参数。借助 lambda 表达式，这变得更加简单。更进一步，Kotlin 允许从另一个函数中返回一个函数。让我们了解它是如何工作的。
- en: 'Suppose we have one interface called `WildAnimal` that is implemented by three
    classes as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `WildAnimal` 的接口，该接口由以下三个类实现：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each class implements two methods—`setName()` and `bark()` that will set the
    animal and show a barking voice respectively. We will create an instance of each
    of the class, set its name, and call the `bark()` function to print the barking
    voice and also print the name of the animal. To achieve this, we will write a
    function as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类实现了两个方法——`setName()` 和 `bark()`，分别用于设置动物和显示叫声。我们将为每个类创建一个实例，设置其名称，并调用 `bark()`
    函数以打印叫声和动物名称。为此，我们将编写如下函数：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `getAnimalVoiceFun` function takes the implementation of `WildAnimal` as
    a parameter and returns the function that takes `String` as a parameter and returns
    `String` as an output. The code written inside the `{ }` braces in the body of
    the `getAnimalVoiceFun` function denotes the function that is returning from it.
    The `it` parameter points to the `String` parameter of the enclosing function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAnimalVoiceFun` 函数接受 `WildAnimal` 的实现作为参数，并返回一个接受 `String` 作为参数并返回 `String`
    作为输出的函数。`getAnimalVoiceFun` 函数体内部的 `{ }` 大括号中的代码表示从该函数返回的函数。`it` 参数指向封装函数的 `String`
    参数。'
- en: 'The `animal.bark()` function, which actually returns the string, will be ultimately
    returned from an enclosed function. This function can be written in a slightly
    different way as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实际返回字符串的 `animal.bark()` 函数最终将从内部函数返回。这个函数可以稍微以不同的方式编写，如下所示：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The difference is we are declaring the name of the parameter—`name` of the
    type string and using it as a `name=it` expression in the enclosing function.
    In both of the previous ways, the parenthesis represents the function, so the `fun`
    keyword is silent. However, you can declare it as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于我们正在声明参数的名称——类型字符串的 `name`，并在封装函数中使用它作为 `name=it` 表达式。在这两种之前的方法中，括号代表函数，所以
    `fun` 关键字是静默的。然而，你可以这样声明：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this way, we are explicitly using the `fun` keyword for enclosing function.
    Also, you have to explicitly mention the `return` keyword in the enclosing function.
    You can use either of these ways to declare the `getAnimalVoiceFun` function.
    You can call this function as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们明确地使用了 `fun` 关键字来封装函数。此外，你必须在封装函数中明确提及 `return` 关键字。你可以使用这两种方式之一来声明
    `getAnimalVoiceFun` 函数。你可以这样调用这个函数：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are calling the `getAnimalVoiceFun` function with an instance of the respective
    class. You can see how the second string parameter included in separate parenthesis
    will be provided to a function defined within the function—`getAnimalVoiceFun`.
    You will get an output as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在调用 `getAnimalVoiceFun` 函数，使用相应类的实例。你可以看到如何将包含在单独括号中的第二个字符串参数提供给函数内部的函数——`getAnimalVoiceFun`。你将得到以下输出：
- en: '![](img/e42631de-5550-4cfc-9cc8-32fdebc12724.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e42631de-5550-4cfc-9cc8-32fdebc12724.png)'
- en: 'In Kotlin, the function can be defined as a type. We can use the function type
    to declare the preceding function as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，函数可以被定义为类型。我们可以使用函数类型来声明前面的函数，如下所示：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `getAnimalVoice` variable is defined as a function type, which takes the `WildAnimal`
    object and returns another function, which takes `String` as an input parameter
    (with the `it` keyword) and returns a `String` output (by calling `animal.bark()`).
    The lambda expression is used to define this function. This can be called as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAnimalVoice` 变量被定义为函数类型，它接受一个 `WildAnimal` 对象并返回另一个函数，该函数接受 `String` 作为输入参数（使用
    `it` 关键字）并返回一个 `String` 输出（通过调用 `animal.bark()`）。这个 lambda 表达式被用来定义这个函数。可以这样调用它：'
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And the output would be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/cca14107-1d57-453e-af30-9f17e0808088.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cca14107-1d57-453e-af30-9f17e0808088.png)'
- en: There may be other straightforward ways to set the animal name and print the
    barking voice. However, we have just seen how it can be possible by returning
    the function from another function. You can write some common logic that is applicable
    to multiple functions, and returning common code as a separate function would
    be an ideal scenario to use the function as a return type of another function.
    This is how flexible and concise Kotlin is.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他简单的方法来设置动物名称并打印叫声。然而，我们刚刚看到了通过从另一个函数返回函数来实现这一点的可能性。你可以编写一些适用于多个函数的通用逻辑，将通用代码作为单独的函数返回将是使用函数作为另一个函数返回类型的一个理想场景。这正是
    Kotlin 的灵活性和简洁性所在。
- en: Null safety
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空安全
- en: While working with Java, when the program executes and tries to access the variables
    set to null and then not initialized with a proper value, it will crash the system
    and produce the classic exception called `NullPointerException`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 Java 一起工作时，当程序执行并尝试访问设置为 null 且未用适当值初始化的变量时，它将使系统崩溃并产生称为 `NullPointerException`
    的经典异常。
- en: As we know, Kotlin is a statically typed language so everything is defined as
    a type, including null values. The nullability is a type in Kotlin. By default,
    a Kotlin compiler does not allow a null value to any type. Generally, when we
    define variables, we set their values at the time of declaration.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Kotlin 是一种静态类型语言，所以所有内容都被定义为类型，包括空值。在 Kotlin 中，空可性是一个类型。默认情况下，Kotlin 编译器不允许任何类型有空值。通常，当我们定义变量时，我们会在声明时设置它们的值。
- en: 'But, in some exceptional cases, you don''t want to initialize the variable
    at the time of declaration. In this case, while using those variables, the Kotlin
    compiler will raise the concern. For example: the following code will give an
    error signal in Kotlin:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在某些异常情况下，你不想在声明时初始化变量。在这种情况下，使用这些变量时，Kotlin 编译器将提出质疑。例如：以下代码在 Kotlin 中将产生错误信号：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The variable initialized with some value is not allowed to be reassigned with
    the null value. Also, any variable defined with type (`String` , in our case)
    is not allowed to initialize with null. The Kotlin compiler has this restriction
    to avoid `NullPointerException`, so it will catch this at compile time rather
    than causing a runtime error which results in an abrupt system collision.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化了某个值的变量不允许被重新赋值为null。此外，任何定义为特定类型（在我们的例子中是`String`）的变量也不允许用null初始化。Kotlin编译器有这个限制，以避免`NullPointerException`，因此它会在编译时捕获这个错误，而不是在运行时导致系统崩溃的错误。
- en: 'Kotlin wants us to initialize the typed variable at the time of declaration. As
    we said, there are situations where we have to initialize variables with null
    and Kotlin allows it in a different way, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin希望我们在声明时初始化类型化变量。正如我们所说，有些情况下我们必须用null初始化变量，而Kotlin以不同的方式允许这样做，如下所示：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The nullable variable can be defined with a question mark with a type of variable
    called a **safe call operator**. You can now assign null value. However, when
    we define a nullable variable and try to call its method, the compiler will show
    an error as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可空变量可以用带有类型（称为**安全调用运算符**）的问号来定义。你现在可以分配null值。然而，当我们定义一个可空变量并尝试调用其方法时，编译器会显示如下错误：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The reason for this is Kotlin will not allow calling methods on a nullable
    type without either explicitly checking for null or calling the method in a safe
    way. The previous code can be rewritten to avoid a compilation error in the following
    ways:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是Kotlin不允许在没有显式检查null或以安全方式调用方法的情况下对可空类型调用方法。前面的代码可以按照以下方式重写，以避免编译错误：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `nullableMsg2?` method is the safe way to call a nullable variable. If
    the variable is null, Kotlin will silently bypass that call and return a null
    value. This is a more concise way for a safe null check in Kotlin. But if you
    want to make sure the value is returned, even if it is null, then you can use
    another approach as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`nullableMsg2?`方法是以安全方式调用可空变量的方式。如果变量为null，Kotlin会静默地跳过该调用并返回null值。这是在Kotlin中进行安全null检查的更简洁方式。但如果你想要确保返回值，即使它是null，那么你可以使用另一种方法，如下所示：'
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The additional question mark and colon (`?:` ) is called the **Elvis operator**.
    It is basically similar to the if-else block and returns the length if not null.
    If it is null, then it will return `-1`. This is basically the short form of a
    ternary operator, such as `if(a) ? b : c` , but cleaner and more compact. This will
    prevent any accidental `NullPointerException` at runtime.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '额外的问号和冒号（`?:`）被称为**Elvis运算符**。它基本上类似于if-else块，如果非null则返回长度。如果是null，则返回`-1`。这基本上是三元运算符的简写形式，例如`if(a)
    ? b : c`，但更简洁、更紧凑。这将防止在运行时意外抛出`NullPointerException`。'
- en: Data classes
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类
- en: 'You might have created a class that is a simple data container without specific
    business logic or functionality. Such a scenario happens while following the value
    object or the data transfer object pattern. Typically, such classes look as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能创建了一个没有特定业务逻辑或功能的数据容器类。这种情况通常在遵循值对象或数据传输对象模式时发生。这类类通常如下所示：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There is nothing special in this class, just a few properties, getters, setters,
    constructor, and the implementation of `hashCode()`, `equals()`, and `toString()`.
    Lots of boilerplate code would really distract any business functionality. Due
    to this, the code becomes less readable, searchable, and verbose.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类没有特别之处，只有几个属性、getter、setter、构造函数以及`hashCode()`、`equals()`和`toString()`的实现。大量的样板代码会真正分散任何业务功能。正因为如此，代码的可读性、可搜索性和简洁性都降低了。
- en: 'With the help of modern IDEs, it is just a matter of a few clicks to generate
    this code, but still it has a readability issue. The same code written in Kotlin
    is not only much cleaner on the first view but also helps with focusing on the
    important part out of the boring boilerplate stuff, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代IDE的帮助下，生成这段代码只需要几秒钟，但仍然存在可读性问题。用Kotlin编写的相同代码不仅一开始看起来更干净，而且有助于关注那些无聊的样板代码之外的重要部分，如下所示：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Everything is covered in just a single line of code, and it is also more readable.
    A declaration such as this will create setters, getters, constructor, and the
    implementation of the `toString()`, `hashCode()`, and `equals()` methods along
    with other useful functionalities behind the curtain by Kotlin. If you want to
    make your class immutable, just declare the properties with `val` instead of `var`
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内容都只在一行代码中完成，而且也更易读。这样的声明将创建设置器、获取器、构造函数以及 `toString()`、`hashCode()` 和 `equals()`
    方法的实现，以及其他幕后的有用功能，这些都是 Kotlin 自动完成的。如果你想使你的类不可变，只需用 `val` 而不是 `var` 声明属性，如下所示：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Immutable variables can be defined with `val` in Kotlin. You can now call only
    getters on the object of the `StudentVOKotlin` class. We can use this class as
    follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，可以使用 `val` 定义不可变变量。现在你只能对 `StudentVOKotlin` 类的对象调用获取器。我们可以如下使用这个类：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This really makes the code compact and readable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实使代码更加紧凑和易读。
- en: Interoperability
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互操作性
- en: As we have seen, Kotlin is fully interoperable with Java so that you can write
    Java and Kotlin functions altogether in the same project and call them from each
    other. Let's understand how that magic happens. Before that, let's look at how
    things happen behind the scenes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Kotlin 与 Java 完全兼容，因此你可以在同一个项目中同时编写 Java 和 Kotlin 函数，并相互调用。让我们了解这种魔法是如何发生的。在此之前，让我们看看幕后发生了什么。
- en: 'For example, you wrote a Kotlin function in the `CheckOperability.kt` file
    as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你已经在`CheckOperability.kt`文件中编写了一个 Kotlin 函数，如下所示：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This code will be compiled by the Kotlin compiler and converted into byte code.
    The generated Java class file will be as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将由 Kotlin 编译器编译并转换为字节码。生成的 Java 类文件如下所示：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, Kotlin converts the `.kt` file (`CheckInterOperabilityKt.class`)
    into a corresponding Java class. The `greeting()` function defined in Kotlin is
    also converted to a Java function. By default, all functions in Kotlin are static.
    Also, Kotlin is not forcing you to define a `void` in case there is no-return
    value. (Kotlin has `Unit` in place of `void` actually.) While converting, it will
    add `void` along with a `static` keyword to the function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Kotlin 将 `.kt` 文件（`CheckInterOperabilityKt.class`）转换为相应的 Java 类。在 Kotlin
    中定义的 `greeting()` 函数也被转换为 Java 函数。默认情况下，Kotlin 中的所有函数都是静态的。此外，Kotlin 不会强迫你在没有返回值的情况下定义
    `void`（实际上 Kotlin 有 `Unit` 来代替 `void`）。在转换过程中，它将添加 `void` 和 `static` 关键字到函数中。
- en: We will now see how we can call the Java code from Kotlin, and vice versa.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何从 Kotlin 调用 Java 代码，反之亦然。
- en: Calling the Kotlin code from Java
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Java 调用 Kotlin 代码
- en: 'Let''s create a Kotlin function that simply does multiplication of two given
    numbers in the `KotlinFile.kt` file as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `KotlinFile.kt` 文件中创建一个 Kotlin 函数，该函数简单地执行两个给定数字的乘法，如下所示：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We want to call a Kotlin `multiply()` function into a Java class. As we know,
    the Kotlin compiler processes this file into a Java class, where it defines the
    `multiply()` method as a static method of the `KotlinFileKt.class` generated class file, so
    that it can be accessible with the `KotlinFileKt.multiply()` expression.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将 Kotlin 的 `multiply()` 函数调用到 Java 类中。正如我们所知，Kotlin 编译器将此文件处理成一个 Java 类，其中它将
    `multiply()` 方法定义为生成类文件 `KotlinFileKt.class` 的静态方法，以便可以通过 `KotlinFileKt.multiply()`
    表达式访问。
- en: In case you wish to change the Java class file name from the Kotlin source,
    you need to define it as `@file:JvmName("CustomKotlinFile")` in the Kotlin file.
    In this case, the Kotlin compiler will generate the `CustomKotlinFile.class` file
    and the function can be accessed with the `CustomKotlinFile.multiply()` call.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望从 Kotlin 源文件更改 Java 类文件名，你需要在 Kotlin 文件中将其定义为 `@file:JvmName("CustomKotlinFile")`。在这种情况下，Kotlin
    编译器将生成 `CustomKotlinFile.class` 文件，函数可以通过 `CustomKotlinFile.multiply()` 调用访问。
- en: 'Let''s first add the Java class and call the Kotlin function as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加 Java 类，并按如下方式调用 Kotlin 函数：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is how the Kotlin function can be called from the Java class. Now let's
    see how to call a Java function from Kotlin.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Kotlin 函数如何从 Java 类中调用的方式。现在让我们看看如何从 Kotlin 调用 Java 函数。
- en: Calling Java code from Kotlin
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Kotlin 调用 Java 代码
- en: 'Let''s define a function that simply does the addition of two numbers in a
    Java file as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Java 文件中定义一个简单的函数，该函数执行两个数字的加法，如下所示：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This can be called in the Kotlin file in a similar way to how we called the
    Kotlin code into Java. Since this is a static function, we can call it with the
    Java class in Kotlin as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在 Kotlin 文件中以类似我们调用 Kotlin 代码到 Java 的方式调用。由于这是一个静态函数，我们可以用 Kotlin 中的 Java
    类来调用它，如下所示：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `main` function in Kotlin represents the execution point similar to `public
    static void main()` in Java.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的 `main` 函数表示执行点，类似于 Java 中的 `public static void main()`。
- en: Smart casts
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能转换
- en: 'While working with Java, you may face the scenario where you need to cast the
    object before further processing. However, even if there is certainty about the
    type of object that you are passing, you still need to cast the object explicitly
    in Java as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Java 时，您可能会遇到需要在对对象进行进一步处理之前对其进行转换的场景。然而，即使对传递的对象类型有确定性，您仍然需要在 Java 中显式地转换对象，如下所示：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we try to call `greetingMsg()` without an explicit cast, the Java compiler
    will show an error because the `name` variable is of the `Object` type. In this
    case, although the compiler knows that `name` can be only of the `String` type
    (through the condition `if(name instanceOf String)`), the Java compiler needs
    explicit casting. In other words, we need to perform casting, even though it is
    actually redundant.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试在不进行显式转换的情况下调用 `greetingMsg()`，Java 编译器将显示错误，因为 `name` 变量是 `Object` 类型。在这种情况下，尽管编译器知道
    `name` 只能是 `String` 类型（通过条件 `if(name instanceOf String)`），Java 编译器仍然需要显式转换。换句话说，即使实际上是不必要的，我们仍然需要进行转换。
- en: 'However, in the case of Kotlin, you are not required to cast explicitly if
    a parameter is proven to be of a required type. This code can be written in Kotlin
    as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Kotlin 的情况下，如果参数被证明是所需类型，则不需要显式转换。以下是这样在 Kotlin 中编写的代码：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Any` type in Kotlin is equivalent to `Object` in Java. In this code, the
    compiler knows that the input given to the `greetingMsg` function can only be
    of the `String` type (with the `if` condition) so an explicit cast is not required.
    This is called **smart** **cast** in Kotlin.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的 `Any` 类型与 Java 中的 `Object` 相当。在这个代码中，编译器知道传递给 `greetingMsg` 函数的输入只能是
    `String` 类型（通过 `if` 条件），因此不需要显式转换。这被称为 Kotlin 中的 **智能** **转换**。
- en: Operator overloading
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Operator overloading is another convenient feature of Kotlin, which makes it
    more expressive and readable. It allows you to use standard symbols such as `+`,
    `-`, `*`, `/`, `%`, `<`, `>`, and so on, to perform various operations on any
    object. Under the hood, operator overloading initiates a function call to perform
    various mathematical operations, comparisons, indexing operations with arrays,
    and lots more.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符重载是 Kotlin 的另一个便捷特性，这使得它更具表达性和可读性。它允许您使用标准符号，如 `+`、`-`、`*`、`/`、`%`、`<`、`>`
    等，对任何对象执行各种操作。在底层，运算符重载会启动一个函数调用，以执行各种数学运算、比较、数组索引操作等等。
- en: 'The classes such as int, byte, short, long, double, float, and so on, have
    defined corresponding functions for each of these operators. For example: if we
    do `a+b` on an integer, Kotlin will call `a.plus(b)` internally as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 类如 int、byte、short、long、double、float 等为每个这些运算符定义了相应的函数。例如：如果我们对一个整数执行 `a+b`，Kotlin
    将在内部调用 `a.plus(b)`，如下所示：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Both print statements show the same result. We can define how operators work
    for custom classes by overloading corresponding functions. For example, we have
    a class called `CoordinatePoint`, which represents the x and y coordinates for
    a given point in the graph. If we want to override the operators on this class,
    then it should be coded as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 两个打印语句显示相同的结果。我们可以通过重载相应的函数来定义自定义类中运算符的工作方式。例如，我们有一个名为 `CoordinatePoint` 的类，它表示图中给定点的
    x 和 y 坐标。如果我们想覆盖这个类上的运算符，那么应该这样编写代码：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `CoordinatePoint` class is our custom class, and the `plus()` and `minus()` functions
    are actually called when the objects of this class are used along with the corresponding
    operators. The `operator` keyword is used to associate the corresponding function
    with the operators.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoordinatePoint` 类是我们自定义的类，当使用这个类的对象以及相应的运算符时，实际上会调用 `plus()` 和 `minus()`
    函数。`operator` 关键字用于将相应的函数与运算符关联。'
- en: Apart from arithmetic, Kotlin supports other operators, such as **index access**
    operators, **in** operators, **invoke** operators, **argument** **assignment**
    operators, **equal** operators, **function** operators, and so on. With operator
    overloading, this code is more compact and concise and of course is clearer as
    well.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算术运算之外，Kotlin 还支持其他运算符，例如 **索引访问** 运算符、**in** 运算符、**调用** 运算符、**参数** **赋值**
    运算符、**等于** 运算符、**函数** 运算符等等。通过运算符重载，这段代码更加紧凑、简洁，当然也更清晰。
- en: Kotlin versus Java
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 与 Java 的比较
- en: 'After going through the feature richness of Kotlin, it would be really helpful
    to compare it to Java. This is not to prove a particular language is more appropriate
    than the other, but rather to just list the differences to make the choice easier
    for different scenarios:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了Kotlin的功能丰富性之后，将其与Java进行比较将非常有帮助。这并不是为了证明某种语言比另一种语言更合适，而是为了列出差异，以便在不同场景下更容易做出选择：
- en: '**Null safety**: Kotlin provides a nice way to define and handle nullable types,
    whereas Java does not have a similar feature out of the box.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空安全**：Kotlin提供了一种优雅的方式来定义和处理可空类型，而Java没有类似的功能。'
- en: '**Extension function**: Java needs an inheritance to extend the class, whereas
    Kotlin allows you to define the extension function without inheriting any class.
    You can define an extension function for custom classes as well.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展函数**：Java需要继承类来扩展，而Kotlin允许你定义扩展函数而不需要继承任何类。你还可以为自定义类定义扩展函数。'
- en: '**Type reference**: In Java, we need to specify the type of variable explicitly,
    but Kotlin will handle it based on the assignment so you do not have to define
    the type in all the scenarios.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型引用**：在Java中，我们需要显式指定变量的类型，而Kotlin会根据赋值来处理它，因此你不必在所有情况下定义类型。'
- en: '**Functional programming**: Kotlin is a functional language and provides many
    useful features for functions. Java, on the other hand, has started supporting
    lambda expressions.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式编程**：Kotlin是一种函数式语言，并为函数提供了许多有用的特性。另一方面，Java已经开始支持lambda表达式。'
- en: '**Coroutine support**: Coroutines are lightweight threads used to handle asynchronous,
    non-blocking code. Kotlin support coroutines out of the box. The Co-routines are
    managed by users. Java, on other hand, supports similar functionality with multithreads
    managed by the underlying OS.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程支持**：协程是轻量级线程，用于处理异步、非阻塞代码。Kotlin内置支持协程。协程由用户管理。另一方面，Java通过底层操作系统管理的多线程支持类似的功能。'
- en: '**Data class**: In Java, we need to declare constructors, getters, setters,
    `toString()`, `hashCode()`, and `equals()` manually, while Kotlin does all that
    behind the scene.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类**：在Java中，我们需要手动声明构造函数、getter、setter、`toString()`、`hashCode()`和`equals()`，而Kotlin会在幕后完成所有这些。'
- en: '**Smart cast**: Java needs to check for cast explicitly, while Kotlin does
    this job smartly.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能转换**：Java需要显式检查转换，而Kotlin会智能地完成这项工作。'
- en: '**Checked exception**: Java does support checked exceptions, whereas Kotlin
    does not support them.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已检查异常**：Java支持已检查异常，而Kotlin不支持。'
- en: Spring supports for Kotlin
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring对Kotlin的支持
- en: Due to its stunning features, Kotlin has rapidly grown in popularity, and many
    frameworks have started supporting it. The Spring Framework has allowed the development
    of Spring applications with Kotlin since version 5\. Though Kotlin is fully interoperable
    with Java, you can write an application with pure and fully idiomatic Kotlin code.
    The diverse range of Kotlin features enhances productivity and combines well with
    Spring for application development.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其惊人的特性，Kotlin的受欢迎程度迅速增长，许多框架也开始支持它。Spring框架自5.0版本起就允许使用Kotlin开发Spring应用程序。尽管Kotlin与Java完全兼容，但你仍然可以编写纯且完全符合Kotlin语法的应用程序。Kotlin丰富的特性提高了生产力，并且与Spring结合得很好，适用于应用程序开发。
- en: As we have seen, the extension function in Kotlin is a non-intrusive way of
    providing a better alternative to the utility class or creating a class hierarchy
    for adding new features. Spring has used this feature to apply new Kotlin specific
    capabilities to existing Spring APIs. It is mainly used for dependency management. In
    the same way, Spring has also made framework APIs null safe to take full advantage
    of Kotlin.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Kotlin中的扩展函数是一种非侵入式的方式，提供了一种更好的替代方案，用于实用类或创建类层次结构以添加新功能。Spring利用这个特性将新的Kotlin特定功能应用于现有的Spring
    API。它主要用于依赖管理。同样，Spring也将框架API转换为空安全，以充分利用Kotlin。
- en: Even Spring Boot has first-class Kotlin support, starting from version 2.x.
    This means you can write Spring-based applications in Kotlin as if Spring was
    a native framework of Kotlin. The current version of Kotlin released in October
    2018 is 1.3, and Spring supports Kotlin 1.1 and higher.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Spring Boot也从2.x版本开始提供了一级Kotlin支持。这意味着你可以用Kotlin编写基于Spring的应用程序，就像Spring是Kotlin的本地框架一样。2018年10月发布的Kotlin当前版本是1.3，Spring支持1.1及更高版本的Kotlin。
- en: Developing an application – Task Management System
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发应用程序 – 任务管理系统
- en: This chapter aims to create an application called **Task Management System**
    (**TMS**) with Spring Boot and Kotlin. In previous chapters, we created various
    applications in Java. In this section, we will learn how to develop Spring-based
    applications in Kotlin with Spring Boot.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在使用Spring Boot和Kotlin创建一个名为**任务管理系统**（**TMS**）的应用程序。在之前的章节中，我们使用Java创建了各种应用程序。在本节中，我们将学习如何使用Spring
    Boot在Kotlin中开发基于Spring的应用程序。
- en: 'With TMS, we will implement the following functionalities; instead of making
    full-fledged and feature-rich applications, our focus will be on how to leverage
    Kotlin capability while developing Spring-based applications:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TMS，我们将实现以下功能；而不是制作功能齐全且功能丰富的应用程序，我们的重点将是如何在开发基于Spring的应用程序时利用Kotlin的能力：
- en: Task creation and assigning to the user.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建任务并将其分配给用户。
- en: View, update, and delete the task by an admin user.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员用户查看、更新和删除任务。
- en: Add comments to a given task by the admin and normal user to whom the task is
    assigned.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员和被分配任务的普通用户可以为给定任务添加注释。
- en: Implement authentication and authorization with Spring Security.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security实现身份验证和授权。
- en: For simplicity, we will expose the REST service to add users. There will be
    one admin user and one or more normal users.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将公开REST服务以添加用户。将有一个管理员用户和一个或多个普通用户。
- en: Creating a Spring Boot project with Kotlin
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kotlin创建Spring Boot项目
- en: 'The first thing is to create a project structure through the Spring Boot initializer.
    In all previous chapters, we created a project structure in **Spring Tool Suit** (**STS**—an
    Eclipse-based IDE). There is another way to create it from the web. Go to the  [https://start.spring.io/](https://start.spring.io/) URL,
    and fill in the data as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是通过Spring Boot初始化器创建项目结构。在所有前面的章节中，我们都在**Spring Tool Suite**（**STS**——一个基于Eclipse的IDE）中创建了项目结构。还有另一种从网络创建它的方法。访问  [https://start.spring.io/](https://start.spring.io/) URL，并按照以下方式填写数据：
- en: '![](img/b2d965e3-a06a-4333-b41c-5bbe1b59bdce.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2d965e3-a06a-4333-b41c-5bbe1b59bdce.png)'
- en: 'Make sure you select Kotlin as a programming language option along with latest
    stable Spring Boot version (2.1.2 as of now). Also select the dependencies as
    follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您选择编程语言选项为Kotlin，并选择最新的稳定版Spring Boot版本（目前为2.1.2）。同时选择以下依赖项：
- en: 'JPA: Used to interact with the database through **Java Persistence API** (**JPA**)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA：用于通过**Java持久化API**（**JPA**）与数据库交互
- en: 'Web: Add Spring **Model-View-Controller** (**MVC**) specific features'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Web: 添加Spring **模型-视图-控制器**（**MVC**）特定功能'
- en: 'Security: Required to add Spring Security capabilities'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性：需要添加Spring Security功能
- en: 'DevTools: To make live reload on code changes'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevTools：用于在代码更改时进行实时重新加载
- en: 'Thymeleaf: Designing the views with Thymeleaf templates'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thymeleaf：使用Thymeleaf模板设计视图
- en: 'MySQL: Java connector to interact with the MySQL database'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MySQL: 用于与MySQL数据库交互的Java连接器'
- en: Click on the Generate Project button, and you will see an application structure
    is downloaded as a ZIP bundle. Just unzip it in your local machine. So far, we
    have used STS—an Eclipse IDE—as an IDE to develop various applications in previous
    chapters. However, for a more comprehensive experience, we will use IntelliJ IDEA
    (a well-known IDE  native with support for Kotlin) in this chapter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“生成项目”按钮，您将看到应用程序结构作为ZIP包下载。只需在您的本地机器上解压缩即可。到目前为止，我们在前面的章节中使用了STS——一个Eclipse
    IDE——作为IDE来开发各种应用程序。然而，为了获得更全面的体验，在本章中我们将使用IntelliJ IDEA（一个知名IDE，原生支持Kotlin）。
- en: 'IntelliJ IDEA ships in two versions: Community and Ultimate. The former is
    available free of cost for JVM and Android-based development, while the later
    is for web and enterprise development, with more feature support. It is available
    for popular operating systems—Windows, macOS, and Linux. We will use the Community
    version. Download it from the [https://www.jetbrains.com/idea/download](https://www.jetbrains.com/idea/download) URL,
    and install it on your local machine.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA有两种版本：社区版和终极版。前者免费提供给JVM和Android开发，而后者用于Web和企业开发，具有更多功能支持。它适用于流行的操作系统——Windows、macOS和Linux。我们将使用社区版。从 [https://www.jetbrains.com/idea/download](https://www.jetbrains.com/idea/download) URL下载它，并在您的本地机器上安装它。
- en: To import the project, open the IntelliJ IDEA IDE, select the File | Open menu,
    and select the extracted project structure folder that we have downloaded from
    the Spring initializer. The very first difference you will see in the Kotlin-based
    Spring application is the folder structure. The Kotlin source code will reside
    in `src/main/kotlin` compared to `src/main/java`for standard Java-based applications.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入项目，请打开 IntelliJ IDEA IDE，选择 File | Open 菜单，然后选择从 Spring 初始化器下载的已提取的项目结构文件夹。您将在基于
    Kotlin 的 Spring 应用程序中看到的第一个区别是文件夹结构。Kotlin 源代码将位于 `src/main/kotlin`，而不是标准基于 Java
    的应用程序的 `src/main/java`。
- en: 'To support Kotlin, Spring requires certain dependencies, which are added automatically
    to `pom.xml` while generating it from the Spring initializer. You will see the
    Kotlin specific dependencies as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持 Kotlin，Spring 需要某些依赖项，这些依赖项在从 Spring 初始化器生成 `pom.xml` 时会自动添加。您将看到以下 Kotlin
    特定依赖项：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `kotlin-stdlib-jdk8` dependency is required for Kotlin 1.2 and higher versions.
    For Kotlin 1.1, you need to use `kotlin-stdlib-jre8`. The Kotlin-reflect is a
    reflection feature used in Kotlin.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Kotlin 1.2 及更高版本，需要 `kotlin-stdlib-jdk8` 依赖项。对于 Kotlin 1.1，您需要使用 `kotlin-stdlib-jre8`。Kotlin-reflect
    是 Kotlin 中使用的反射功能。
- en: DB design
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库设计
- en: 'To store task-related data, we will use the MySQL database. We will also store
    user and role information in database tables. The tables and their relationship
    details look as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储与任务相关的数据，我们将使用 MySQL 数据库。我们还将用户和角色信息存储在数据库表中。表及其关系细节如下所示：
- en: '![](img/7735aa6d-919b-4860-9a9d-53929f0626f6.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7735aa6d-919b-4860-9a9d-53929f0626f6.png)'
- en: 'The table details are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 表的详细信息如下：
- en: '**task:** This table stores the details about tasks added into the system.
    It has a one-to-many relationship with the **comments** table.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**task**：此表存储系统添加的任务的详细信息。它与 **comments** 表具有一对多关系。'
- en: '**comments:** When a user enters a **task** comment, it will be added to this
    table.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评论**：当用户输入 **task** 评论时，它将被添加到这个表中。'
- en: '**users:** This is a master table to store user details. It has a many-to-many
    relationship with the table **role**. It also has a one-to-many relationship with
    the **task** and **comments** tables.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：这是一个存储用户详情的主表。它与表 **role** 具有多对多关系。它还与 **task** 和 **comments** 表具有一对多关系。'
- en: '**role:** This is a master table for roles. Mainly, there are two roles—`ROLE_USER`
    and `ROLE_ADMIN`. It has a many-to-many relationship with the table **users**.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**：这是一个角色主表。主要包含两个角色——`ROLE_USER` 和 `ROLE_ADMIN`。它与表 **users** 具有多对多关系。'
- en: '**user_role:** This is a link table and will store the associated data of **role** and
    **users**.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**user_role**：这是一个链接表，将存储 **role** 和 **users** 的关联数据。'
- en: Entity classes
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体类
- en: We will use Spring Data JPA to interact with the database, so first we need
    to write entity classes. An entity class will be mapped to a database table, and
    its attributes are mapped to the table columns. The JPA entity class is a user-defined
    POJO class, which is nothing but an ordinary Java class with certain JPA specific
    annotation and is capable of presenting the objects in the database.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring Data JPA 与数据库交互，因此首先我们需要编写实体类。一个实体类将被映射到一个数据库表，其属性将被映射到表列。JPA 实体类是一个用户定义的
    POJO 类，它不过是一个具有特定 JPA 特定注解的普通 Java 类，并且能够表示数据库中的对象。
- en: We will create a separate entity class for each of the tables except the link
    table **user_role**, which is handled with the `@ManyToMany` annotation. The details
    are as follows.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为除了链接表 **user_role** 之外的所有表创建一个单独的实体类，该链接表通过 `@ManyToMany` 注解处理。具体细节如下。
- en: Users
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户
- en: 'Entity class for the `users` table should look as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`users` 表的实体类应如下所示：'
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `@Entity` annotation is used to declare that the class is a JPA entity.
    The `@Table` annotation is used to map the class with a specific database table.
    The attributes of this class are mapped to the respective columns with the `@Column`
    annotation. The attributes are defined as nullable, as they will be populated
    at runtime.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Entity` 注解用于声明该类是 JPA 实体。`@Table` 注解用于将类映射到特定的数据库表。该类的属性通过 `@Column` 注解映射到相应的列。属性被定义为可空的，因为它们将在运行时填充。'
- en: 'The `@JoinTable` annotation is used to declare the link table, and `JoinColumn`
    is used to define the column reference between tables associated with a many-to-many
    relationship along with the link table. The many-to-many relationship declaration
    in Kotlin is a little bit different than in Java. The same configuration is declared
    in Java as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`@JoinTable` 注解用于声明链接表，`JoinColumn` 用于定义与链接表关联的表之间的列引用。在 Kotlin 中，多对多关系的声明与
    Java 中略有不同。相同的配置在 Java 中如下声明：'
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The visible difference here is the declaration of the `joinColumns` attribute
    of the `@JoinTable` annotation. In Java, it is declared with an annotation, while
    in Kotlin it is defined as an array. Another difference is defining the `cascade`
    attribute in the `@ManyToMany` annotation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的明显区别是 `@JoinTable` 注解的 `joinColumns` 属性的声明。在 Java 中，它使用注解声明，而在 Kotlin 中，它被定义为一个数组。另一个区别是在
    `@ManyToMany` 注解中定义 `cascade` 属性。
- en: Role
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: 'The entity class corresponding to the `role` table looks as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于 `role` 表的实体类如下所示：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the many-to-many relationship between `User` and `Role` entities, the ownership
    is with the`User` entity so the `@ManyToMany` annotation in the `Role` entity
    is defined with the `mappedBy` attribute.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `User` 和 `Role` 实体之间的多对多关系中，所有者属于 `User` 实体，因此 `Role` 实体中的 `@ManyToMany` 注解使用
    `mappedBy` 属性定义。
- en: Task
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: 'The entity class associated to `task` table should look as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `task` 表关联的实体类应如下所示：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `@OneToMany` annotation is used to declare a one-to-many relationship with
    the `comments` table. The `@JoinColumn` annotation is used to declare the column
    reference in the `comments` table.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`@OneToMany` 注解用于声明与 `comments` 表的一对多关系。`@JoinColumn` 注解用于声明 `comments` 表中的列引用。'
- en: Comments
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评论
- en: 'The entity class for `comments` table should look as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`comments` 表的实体类应如下所示：'
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `@ManyToOne` annotation is used to declare a many-to-one relationship with
    a **task** table. The `@JoinColumn` annotation is used to define the reference
    column (primary key).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ManyToOne` 注解用于声明与 **任务** 表的多对一关系。`@JoinColumn` 注解用于定义参考列（主键）。'
- en: Spring Security
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security
- en: Spring Security is the de facto standard for implementing security constraints
    in Spring-based applications. In previous chapters, we used Spring Security with
    an in-memory model while implementing user authentication and authorization. The
    in-memory model should only be used for testing purposes only. In a real scenario,
    authentication and authorization details are fetched from other systems to make
    it loosely coupled with the application code, such as LDAP, OAuth, and so on.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 是在基于 Spring 的应用程序中实现安全约束的事实标准。在前面的章节中，我们使用 Spring Security 与内存模型一起实现用户认证和授权。内存模型仅应用于测试目的。在实际场景中，认证和授权细节是从其他系统获取的，以使其与应用程序代码松散耦合，例如
    LDAP、OAuth 等。
- en: 'In [Chapter 3](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml), *Blogpress – A
    Simple Blog Management System*, we learned how to configure Spring Security with
    LDAP and OAuth in detail. In this chapter, we will use database tables to store
    authentication and authorization details. First, let''s create a class and define
    the security configuration as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml)，*Blogpress – 一个简单的博客管理系统*
    中，我们详细学习了如何配置 Spring Security 使用 LDAP 和 OAuth。在本章中，我们将使用数据库表来存储认证和授权细节。首先，让我们创建一个类并定义如下安全配置：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is a typical security configuration. The way we declared annotation for
    Kotlin is similar to what we have done with Java. However, there are differences
    as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的安全配置。我们为 Kotlin 声明注解的方式与 Java 中所做的方式相似。然而，存在以下差异：
- en: In Kotlin, we can use a colon (`:`) to declare inheritance. The `WebSecurityConfigurerAdapter` class
    is a parent class, but with the surprise that it is a Java class. You can extend
    your Kotlin class from another Java class, and it is absolutely fine. This is
    how Kotlin is deeply interoperable with Java. Another difference is the parent
    class is used with the constructor notation (with brackets).
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，我们可以使用冒号 (`:`) 来声明继承。`WebSecurityConfigurerAdapter` 类是一个父类，但令人惊讶的是它是一个
    Java 类。你可以从另一个 Java 类扩展你的 Kotlin 类，这是完全可以接受的。这就是 Kotlin 如何与 Java 深度互操作。另一个区别是父类使用构造函数表示法（带有括号）。
- en: To override a method from the parent class, Kotlin uses the `override` keyword.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要覆盖父类的方法，Kotlin 使用 `override` 关键字。
- en: Since Kotlin does not support checked exceptions directly, the `@Throws` annotation
    is used to define the exception details.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Kotlin 不直接支持检查异常，因此使用 `@Throws` 注解来定义异常详细信息。
- en: 'Next, the access mechanism needs to be configured to various pages in the system.
    This can be done by overriding the configure method, which basically provides
    an HTTP specific security configuration. It looks as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要配置访问机制以访问系统中的各个页面。这可以通过重写配置方法来完成，它基本上提供了特定的 HTTP 安全配置。它看起来如下所示：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The noticeable things here are we have configured various URLs accessible for
    all users, even without login, and only the admin needs to log in. We also have
    configured the login, success, and failure URLs along with the logout URL. We
    will talk more about them in the *Defining the Spring MVC controller* section.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是，我们已经为所有用户配置了可访问的各个 URL，甚至无需登录，只有管理员需要登录。我们还配置了登录、成功、失败和注销 URL。我们将在
    *定义 Spring MVC 控制器* 部分中更多地讨论它们。
- en: Now, we will configure an authentication mechanism. Spring supports various
    options such as in-memory, LDAP, OAuth, and so on. For this application, we will
    fetch user details from the database. To implement Spring Security with the database,
    there are two approaches.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将配置一个认证机制。Spring 支持多种选项，例如内存、LDAP、OAuth 等。对于这个应用程序，我们将从数据库中获取用户详细信息。要使用数据库实现
    Spring Security，有两种方法。
- en: Query approach
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询方法
- en: 'Spring Security needs users and their role details to perform the security
    check. In this approach, we will fetch the user and role details with a SQL query.
    We will define a query in the `application.properties` file as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 需要用户及其角色详细信息来执行安全检查。在这个方法中，我们将使用 SQL 查询获取用户和角色详细信息。我们将在 `application.properties`
    文件中定义一个查询，如下所示：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first query fetches user details while second queries retrieve the list
    of roles for a given username. These properties can be read in the `WebSecurityConfig`
    class as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个查询获取用户详细信息，第二个查询检索给定用户名的角色列表。这些属性可以在 `WebSecurityConfig` 类中读取，如下所示：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In Kotlin, the symbol `$` is used to print the variable within `String` without
    explicitly using the `+` operator. Since we want to read the property from the `application.properties`
    file, we have to use the escape character (`\`) along with the `$` operator. Apart
    from this, the variables are declared as nullable (with `String?`) as they will
    be populated by Spring at runtime.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，符号 `$` 用于在 `String` 中打印变量，而不需要显式使用 `+` 运算符。由于我们想从 `application.properties`
    文件中读取属性，我们必须使用转义字符（`\`）以及 `$` 运算符。除此之外，变量被声明为可空（使用 `String?`），因为它们将在运行时由 Spring
    填充。
- en: 'Next, we will override the `configure()` method to define the authentication
    configuration as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重写 `configure()` 方法来定义认证配置，如下所示：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The nice thing about IntelliJ IDEA is, whenever you pass any Java code, it
    will prompt to convert to Java. On choosing yes, it will automatically convert
    Java code into Kotlin code. The `!!` symbol is a not-null assertion operator,
    which basically converts any value to a non-null type and throws a `NullPointerException`
    if the variable is null. It is part of the null safety feature of Kotlin. The
    `dataSource` and `passwordEncoder` methods can be defined as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA 的好处是，无论何时你传递任何 Java 代码，它都会提示将其转换为 Java。选择“是”后，它将自动将 Java 代码转换为
    Kotlin 代码。`!!` 符号是一个非空断言运算符，它基本上将任何值转换为非空类型，如果变量为空，则抛出 `NullPointerException`。它是
    Kotlin 的空安全特性的一部分。`dataSource` 和 `passwordEncoder` 方法可以定义如下：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `dataSource` will be injected by Spring at runtime, so it must be declared
    as nullable (with `?`). We will use `BCryptPasswordEncoder` to encode the password
    with the `bcrpt` algorithm, which is considered to be a very strong encoding algorithm.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataSource` 将在运行时由 Spring 注入，因此必须声明为可空（使用 `?`）。我们将使用 `BCryptPasswordEncoder`
    以 `bcrpt` 算法对密码进行编码，这被认为是一个非常强大的编码算法。'
- en: The `userQuery` and `roleQuery` objects are not necessarily required.  If you
    do not provide them, you need to design the tables with predefined names and columns.
    The user table must be created with a name—`users` with columns `username`, `password`,
    and `enabled` , while the **role** table must be created with a name—`authorities`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`userQuery` 和 `roleQuery` 对象不是必需的。如果你不提供它们，你需要设计具有预定义名称和列的表。用户表必须以名称 `users`
    创建，包含列 `username`、`password` 和 `enabled`，而 **角色** 表必须以名称 `authorities` 创建。'
- en: This approach has certain restrictions. For example: `userQuery` must return
    the `username`, `password`, and `enabled` column value in the same sequence and  `roleQuery`
    must return  `username` and `role name` in the same sequence. If any change happens
    in this sequence, it may not work properly.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有一定的限制。例如：`userQuery`必须以相同的顺序返回`username`、`password`和`enabled`列值，而`roleQuery`必须以相同的顺序返回`username`和`role
    name`。如果此顺序发生任何变化，它可能无法正常工作。
- en: UserDetailsService approach
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UserDetailsService方法
- en: Another approach to fetch use and role information is using the `UserDetailsService`
    interface. It is an abstract way to fetch authentication and authorization details.
    It has one method—`loadUserByUsername()` that will return user details based on
    `username`. You can override it and write your own logic to retrieve the user
    details.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户和角色信息的另一种方法是使用`UserDetailsService`接口。它是一种抽象的方式来获取认证和授权详情。它有一个方法——`loadUserByUsername()`，该方法将根据`username`返回用户详情。你可以覆盖它并编写自己的逻辑来检索用户详情。
- en: 'Spring provides a class called `DaoAuthenticationProvider` that basically uses
    the `UserDetailsService` implementation to fetch user details during the authentication
    process. The flexibility in this approach means we can define a custom method
    to fetch user details. We will define a method in the JPA repository for the `User`
    entity. The JPA is a standard way of interacting with a relational database with
    Java objects. The repository looks as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一个名为`DaoAuthenticationProvider`的类，它基本上在认证过程中使用`UserDetailsService`实现来获取用户详情。此方法的灵活性意味着我们可以定义一个自定义方法来获取用户详情。我们将在JPA仓库的`User`实体中定义一个方法。JPA是与关系数据库交互的Java对象的标准方式。仓库看起来如下：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`UserRepository` is a Kotlin interface that extends the Java `JpaRepository` interface.
    The `@Repository` annotation is used to declare this interface as a JPA repository.
    The `findByUsername` method is a query method, which will fetch the user. Spring
    Data JPA has an inbuilt query building mechanism, based on the repository method
    name.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserRepository`是一个扩展Java `JpaRepository`接口的Kotlin接口。`@Repository`注解用于声明此接口为JPA仓库。`findByUsername`方法是一个查询方法，它将获取用户。Spring
    Data JPA有一个基于仓库方法名的内置查询构建机制。'
- en: 'For the `findByUsername` method, it will first remove the `findBy` prefix and
    compose the query from the rest of the method name. In this case, it will internally
    create a query, such as `select * from users where username=?`. This method returns
    an object of the `User` entity class. Next, we need to provide a custom user service,
    and for that we will implement `UserDetailsService` as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`findByUsername`方法，它将首先移除`findBy`前缀，并从方法名的其余部分构建查询。在这种情况下，它将内部创建一个查询，例如`select
    * from users where username=?`。此方法返回`User`实体类的对象。接下来，我们需要提供一个自定义用户服务，为此我们将实现`UserDetailsService`如下：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `CustomUserDetailsService` class is declared with a `@Service` annotation
    to declare it as a service component. It overrides a `loadUserByUsername()` method,
    where we can write custom logic to fetch user details. A repository `findByUsername()` method
    that we have created is used here to fetch user details.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomUserDetailsService`类使用`@Service`注解声明为服务组件。它覆盖了`loadUserByUsername()`方法，其中我们可以编写自定义逻辑来获取用户详情。我们创建的`findByUsername()`仓库方法在这里用于获取用户详情。'
- en: 'The return type is `UserDetails` that is an interface that actually stores
    user information, which is then encapsulated to authenticate objects later. We
    have created a `CustomUserPrinciple` class to provide an implementation of `UserDetails`
    as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型是`UserDetails`，它实际上是一个存储用户信息的接口，然后封装成用于后续认证的对象。我们已创建一个`CustomUserPrinciple`类来提供`UserDetails`的实现如下：
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `UserDetails` interface requires the implementation of certain methods
    as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDetails`接口需要实现以下某些方法：'
- en: '`isEnable()`: This method basically returns if the user is activated or not.
    In a practical scenario, there must be a separate database column to check if
    the user is enabled or not. For simplicity, we simply return `true`  assuming
    that all users are enabled. If the user returns `false`, Spring Security will
    not allow login.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEnable()`: 此方法基本上返回用户是否已激活。在实际场景中，必须有一个单独的数据库列来检查用户是否已启用。为了简单起见，我们简单地返回`true`，假设所有用户都已启用。如果用户返回`false`，Spring
    Security将不允许登录。'
- en: '`getUsername()`: This simply returns the username.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUsername()`: 这只是返回用户名。'
- en: '`isCredentialsNonExpired()`: This is a very useful method when you want to
    impose a constraint on the user to update the password after a certain time limit.
    In this method, you need to check whether the password has expired, based on your
    requirement, and return the value accordingly. For simplicity, if we return `true` ,
    it means password has not expired.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isCredentialsNonExpired()`: 当你想在特定时间限制后对用户施加更新密码的约束时，这是一个非常有用的方法。在这个方法中，你需要根据你的要求检查密码是否已过期，并相应地返回值。为了简单起见，如果我们返回`true`，这意味着密码尚未过期。'
- en: '`getPassword()`: It should return the password.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPassword()`: 它应该返回密码。'
- en: '`isAccountNonExpired()`: This indicates whether a user account has expired
    or not. To make it simple, we just return `true`.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAccountNonExpired()`: 这表示用户账户是否已过期。为了简单起见，我们只返回`true`。'
- en: '`isAccountNonLocked()`: This is used to check whether a user account is locked.
    Again, for simplicity, we a just return `true`.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAccountNonLocked()`: 这个方法用于检查用户账户是否被锁定。同样，为了简单起见，我们只返回`true`。'
- en: '`getAuthorities()`: This method returns authorities granted to the user. We
    retrieve roles from a user object and wrap them in a `GrantedAuthority` type.
    The `GrantedAuthority` is an interface. We have provided an implementation through the `CustomGrantedAuthority`
    class as follows:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAuthorities()`: 这个方法返回授予用户的权限。我们从用户对象中检索角色并将它们包装在`GrantedAuthority`类型中。`GrantedAuthority`是一个接口。我们通过`CustomGrantedAuthority`类提供了一个实现，如下所示：'
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We are injecting a user object through the constructor, which can be used to
    retrieve further details in each of these methods.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过构造函数注入一个用户对象，这些方法可以用来在每种方法中检索更多详细信息。
- en: 'The last part is to define the Spring Security configuration. Add methods to
    the `WebSecurityConfig` class as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是定义Spring Security配置。向`WebSecurityConfig`类添加以下方法：
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `authenticationProvider()` method simply creates an object of the `DaoAuthenticationProvider` type,
    configure it with user detail service object and password encoder and return.
    It is then used in the `configure()` method to set as the authentication provider.
    The object of `UserDetailService` can be injected in the same class as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticationProvider()`方法简单地创建一个`DaoAuthenticationProvider`类型的对象，配置用户详情服务对象和密码编码器，然后返回。它随后在`configure()`方法中被用作认证提供者。`UserDetailService`对象可以通过以下方式注入到同一个类中：'
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This approach is more flexible in terms of allowing a customized way to fetch
    user details, which are then used by Spring to perform various security constraints.
    It simply decouples the logic of authentication and authorization from the mechanism
    to fetch user details. This makes the system more flexible.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在允许以自定义方式获取用户详情方面更为灵活，这些详情随后被Spring用于执行各种安全约束。它简单地将认证和授权的逻辑与获取用户详情的机制解耦。这使得系统更加灵活。
- en: Defining the Spring MVC controller
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Spring MVC控制器
- en: 'Our backend layer is ready, and now we will design the controller and view
    layer. We have decided to user Spring MVC for the frontend, which is the best
    fit for web-based Spring applications. The declaration of Spring MVC controller
    in Kotlin is similar to what we have done in Java, as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的后端层已经准备好了，现在我们将设计控制器和视图层。我们决定使用Spring MVC作为前端，因为它是最适合基于Web的Spring应用的。在Kotlin中声明Spring
    MVC控制器的方式与我们在Java中做的是相似的，如下所示：
- en: '[PRE62]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The Kotlin `TaskMgmtSystemController` class is declared with the `@Controller`
    annotation, which is used to define the class as a Spring MVC controller. The
    way of defining controller methods in Kotlin is also similar to Java. For example:
    a home page can be shown by the following controller method:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的`TaskMgmtSystemController`类使用`@Controller`注解声明，这用于将类定义为Spring MVC控制器。在Kotlin中定义控制器方法的方式也与Java相似。例如：可以通过以下控制器方法显示主页：
- en: '[PRE63]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This method is mapped with the `/` URL (accessible at [http://localhost:8080](http://localhost:8080))
    and returns a home page. As mentioned, we are going to use Thymeleaf templates
    to construct a view layer.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与`/` URL（可在[http://localhost:8080](http://localhost:8080)访问）映射，并返回一个主页。如前所述，我们打算使用Thymeleaf模板来构建视图层。
- en: If you are not very familiar with Thymeleaf, it is a natural template engine
    used to produce views, which are processed at the server side. A detail explanation
    was given in [Chapter 3](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml)*, Blogpress
    – A Simple Blog Management System,* of this book. You can refer to it to get more
    idea about how Thymeleaf works with Spring.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 Thymeleaf，它是一个用于生成视图的自然模板引擎，这些视图在服务器端进行处理。本书的 [第 3 章](e32452e8-07bb-4815-96d6-b0db0a6009ba.xhtml)*，博客压力
    - 一个简单的博客管理系统* 中给出了详细说明。你可以参考它来了解更多关于 Thymeleaf 如何与 Spring 一起工作的信息。
- en: 'We also have defined constants to access predefined values. Unlike Java, we
    can not define constants in the Kotlin interface. To define constants, we will
    use a singleton class. In Kotlin, we can create a singleton class by an object
    declaration feature. This can be achieved with the `object` keyword. The `TaskMgmntConstant` singleton
    class looks as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了常量来访问预定义值。与 Java 不同，我们无法在 Kotlin 接口中定义常量。要定义常量，我们将使用单例类。在 Kotlin 中，我们可以通过对象声明功能创建单例类。这可以通过
    `object` 关键字实现。`TaskMgmntConstant` 单例类看起来如下：
- en: '[PRE64]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Though there is no `class` keyword used here, this code combines both `class`
    and the singleton declaration altogether. Internally, Kotlin will create a single
    static instance of the `TaskMgmntConstant` class. The `object` declaration can
    contain functions as well, which can be accessed with the `object` declaration
    name directly. It is similar to accessing the static variables and methods of
    the class type in Java.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里没有使用 `class` 关键字，但此代码将 `class` 和单例声明结合在一起。内部，Kotlin 将创建 `TaskMgmntConstant`
    类的单个静态实例。`object` 声明也可以包含函数，可以直接使用 `object` 声明名称来访问。这类似于在 Java 中访问类类型的静态变量和方法。
- en: The `const` keyword is used to define constants. The variables declared with
    the `const` keyword are compile-time constants, meaning they must be populated
    at the time of compilation. Because of this reason, they can not be assigned to
    function or class constructors but only to a string or primitives.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `const` 关键字来定义常量。使用 `const` 关键字声明的变量是编译时常量，这意味着它们必须在编译时填充。正因为如此，它们不能分配给函数或类构造函数，只能分配给字符串或原始数据类型。
- en: Next, we will see how to define controller methods for other operations as follows.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何定义其他操作的控制器方法如下。
- en: Showing the control page
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示控制页面
- en: 'When a user does log in, the system will land on a page called the control
    page. From this page, users can view the task and perform various operations based
    on the role they have. For example: a normal user can see the task list assigned
    to it and also able to add a comment for a specific task. The admin user can add
    a new task, edit, and delete an existing one. This controller method simply redirects
    the user to the landing (or control) page. The code looks as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录时，系统将跳转到称为控制页面的页面。从该页面，用户可以查看任务并根据其角色执行各种操作。例如：普通用户可以看到分配给它的任务列表，并且可以为特定任务添加评论。管理员用户可以添加新任务、编辑和删除现有任务。此控制器方法简单地重定向用户到登录（或控制）页面。代码如下：
- en: '[PRE65]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the *Spring Security* section, we configured `/controlPage` accessible to
    normal and admin users. It cannot be accessed without login.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Spring Security* 部分，我们配置了 `/controlPage`，使其对普通用户和管理员用户可访问。未经登录无法访问。
- en: Showing the login page
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示登录页面
- en: 'This controller method will redirect the user to the login page. It looks as
    follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此控制器方法将重定向用户到登录页面。它看起来如下：
- en: '[PRE66]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It is accessible from the navigation menu. This method also handles an error
    in the case of invalid credentials and shows an appropriate message to the user.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以从导航菜单中访问。此方法还处理无效凭据的情况，并向用户显示适当的消息。
- en: Showing the add new task page
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示添加新任务页面
- en: 'The add new task feature is configured to allow only admin users. It will redirect
    the user to the add new task page. The code looks as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新任务功能配置为仅允许管理员用户。它将重定向用户到添加新任务页面。代码如下：
- en: '[PRE67]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The  `/showAddTask` URL is configured as a navigation menu in the control page.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`/showAddTask` URL 在控制页面中配置为导航菜单。'
- en: Showing the edit task page
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示编辑任务页面
- en: Only admin users can edit existing tasks. Admin users can see an Edit button
    for each task record on task—list screen. Upon clicking it, this method will be
    triggered. It looks as follows.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 只有管理员用户可以编辑现有任务。管理员用户可以在任务列表屏幕上的每个任务记录旁看到一个编辑按钮。点击它后，将触发此方法。它看起来如下。
- en: '[PRE68]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `taskId` parameter will be sent as a request parameter from the task list
    screen. First, we fetch the task object from a given `taskId` with `taskRepository`
    and then copy it to the `TaskDTO` object. You can see we have declared variables
    with the `val` keyword, which is used to declare constants. Kotlin recommends
    using `val` in case the variable is not changed after assigning the value. The
    `TaskDTO` class is a data class defined in Kotlin as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskId` 参数将从任务列表屏幕作为请求参数发送。首先，我们使用 `taskRepository` 从给定的 `taskId` 获取任务对象，然后将其复制到
    `TaskDTO` 对象中。你可以看到我们已使用 `val` 关键字声明了变量，它用于声明常量。Kotlin 建议在变量赋值后不再改变的情况下使用 `val`。`TaskDTO`
    类是在 Kotlin 中定义的数据类，如下所示：'
- en: '[PRE69]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The Edit Task screen looks as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑任务屏幕如下所示：
- en: '![](img/95e80311-3475-48d1-93f3-96d63fb1f4bd.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95e80311-3475-48d1-93f3-96d63fb1f4bd.png)'
- en: Adding a new task
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新任务
- en: 'Only admin users can add a new task. This controller method will insert the
    task record in the database. It looks as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 只有管理员用户可以添加新任务。此控制器方法将在数据库中插入任务记录。如下所示：
- en: '[PRE70]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `title`, `detail`, and `userId` parameters (to whom the task is assigned)
    are provided from the add task screen. This method simply creates an instance
    of the `Task` class, populates its value, and saves it in `taskRepsitory`. Unlike
    Java, the instance can be created without the `new` keyword in Kotlin. Also, Kotlin
    defers the type of variable wherever it is possible. For example, we have not
    defined the type of the `task` variable because it is assigned the object of the `Task` type
    class so Kotlin understands that it is the `Task` type only.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`title`、`detail` 和 `userId` 参数（任务分配给谁）来自添加任务屏幕。此方法简单地创建 `Task` 类的实例，填充其值，并在
    `taskRepsitory` 中保存。与 Java 不同，在 Kotlin 中可以不使用 `new` 关键字创建实例。此外，Kotlin 在可能的情况下将变量的类型推迟。例如，我们没有定义
    `task` 变量的类型，因为它被分配给 `Task` 类型类的对象，所以 Kotlin 理解它只能是 `Task` 类型。'
- en: Instead of redirecting to a specific page, we are redirecting to another controller
    method with the `/allTaskList` URL pattern, which basically shows a task list.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是重定向到特定的页面，而是重定向到另一个控制器方法，该方法的 URL 模式为 `/allTaskList`，它基本上显示任务列表。
- en: Updating a task
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新任务
- en: 'Updating a task is similar to adding a new task method. Only admin users can
    update the existing task. This method looks as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 更新任务与添加新任务方法类似。只有管理员用户可以更新现有任务。此方法如下所示：
- en: '[PRE71]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The code looks similar to the `addTask()` method. The only difference is we
    get the `taskId` of the existing task as an additional parameter. First, we retrieve
    it, update its value, and finally save it with `taskRepository`. This method also
    redirects to another controller method to show a task list with an `/allTaskList` URL
    pattern.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来与 `addTask()` 方法类似。唯一的区别是我们获取现有任务的 `taskId` 作为额外的参数。首先，我们检索它，更新其值，并最终使用
    `taskRepository` 保存它。此方法还重定向到另一个控制器方法，以 `/allTaskList` URL 模式显示任务列表。
- en: Adding a task comment
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加任务评论
- en: 'Normal and admin users can add comments to an existing task. On opening the
    task in view mode, the screen provides a facility to add a comment. The code of
    the controller method for adding task comments looks as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 普通用户和管理员用户可以向现有任务添加评论。在以查看模式打开任务时，屏幕提供了一个添加评论的便利设施。添加任务评论的控制器方法的代码如下所示：
- en: '[PRE72]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this method, the `taskId` and `taskComment` parameters are supplied by the view
    task screen from where the user can add the comment. We fetch the `Task` object
    from `taskId` and fetch its comments as a mutable set.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，`taskId` 和 `taskComment` 参数由用户可以添加评论的查看任务屏幕提供。我们从 `taskId` 获取 `Task` 对象，并获取其评论作为可变集合。
- en: Kotlin provides an API collection (list, set, map, and so on) with a clear distinction
    between mutable and immutable types. This is very handy to ensure you avoid bugs
    and design clear APIs. When you declare any collection, say, `List<out T>`, it
    is immutable by default and Kotlin allows read-only operations, such as `size()`,
    `get()`, and so on. You cannot add any element to it.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了一个 API 集合（列表、集合、映射等），其中可变类型和不可变类型之间有明确的区分。这非常方便，可以确保你避免错误并设计清晰的 API。当你声明任何集合时，比如
    `List<out T>`，它默认是不可变的，Kotlin 允许只读操作，例如 `size()`、`get()` 等。你不能向其中添加任何元素。
- en: If you wish to modify the collection, you need to use mutable types explicitly,
    such as `MutableList<String>`, `MutableMap<String, String>`, and so on. In our
    case, we need to add a comment in the existing set so we used the `MutableSet`
    type. The comment set is empty while adding the first comment so we create an
    empty set with the `mutableSetOf()` method. This method is used to create a collection
    of the `Set` type on the fly.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想修改集合，则需要显式使用可变类型，例如 `MutableList<String>`、`MutableMap<String, String>` 等。在我们的情况下，我们需要在现有集合中添加评论，因此我们使用了
    `MutableSet` 类型。在添加第一个评论时，评论集合是空的，所以我们使用 `mutableSetOf()` 方法创建一个空集合。此方法用于动态创建
    `Set` 类型的集合。
- en: We also need to add `userId` of the currently logged-in user to a comment. To
    do so, we make a call to `SecurityContextHolder.getContext().authentication.principal`.
    The `SecurityContextHolder` class is provided by Spring Security, and it is used
    to get various security-related information.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将当前登录用户的 `userId` 添加到评论中。为此，我们调用 `SecurityContextHolder.getContext().authentication.principal`。`SecurityContextHolder`
    类由 Spring Security 提供，用于获取各种安全相关信息。
- en: Getting all users
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有用户
- en: 'This method will return all users available in the system. It is used to create
    a task screen to fetch a user list to choose for a task assignment. The method
    is as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将返回系统中所有可用的用户。它用于创建任务屏幕以获取用户列表以选择任务分配。方法如下：
- en: '[PRE73]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We call it from the model popup in the add task screen. The UI will be rendered
    by the Thymeleaf template—`users.html`*.*
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从添加任务屏幕中的模型弹出窗口调用它。UI 将由 Thymeleaf 模板 `users.html` 渲染。
- en: Showing a task list
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示任务列表
- en: 'This method shows the list of tasks to both normal and admin users. The difference
    is a normal user can only view and add comments, while the admin user can view,
    edit, and delete operations on a task record. Another difference is a normal user
    can see a list of tasks assigned to it, while an admin user can see all tasks
    available in the system. The method should look as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法向普通用户和管理员用户显示任务列表。区别在于普通用户只能查看和添加评论，而管理员用户可以对任务记录进行查看、编辑和删除操作。另一个区别是普通用户可以看到分配给他的任务列表，而管理员用户可以看到系统中所有可用的任务。此方法应如下所示：
- en: '[PRE74]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This method serves two operations, based on the `myTask` request parameter.
    If it is available then pull the tasks assigned to current users only or else
    fetch all tasks. Fetching all tasks is available to the user with the admin role. After
    fetching the tasks from the database, we map them on to an object of the `TaskDTO`
    class. The **data transfer object** (**DTO**) is the Kotlin data class and looks
    as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法基于 `myTask` 请求参数执行两种操作。如果它可用，则仅拉取分配给当前用户的任务，否则获取所有任务。获取所有任务的功能对具有管理员角色的用户可用。从数据库中获取任务后，我们将它们映射到
    `TaskDTO` 类的对象上。**数据传输对象**（**DTO**）是 Kotlin 数据类，如下所示：
- en: '[PRE75]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the task list, we show the name of the user to whom the task is assigned.
    In the `task` table, we store `userId` , so we need to fetch the username by combining
    the task and user tables. Spring Data JAP provides a convenient way of fetching
    results of complex queries with the `@Query` annotation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务列表中，我们显示分配给任务的用户名称。在 `task` 表中，我们存储 `userId`，因此我们需要通过组合任务和用户表来获取用户名。Spring
    Data JPA 提供了一种使用 `@Query` 注解方便地获取复杂查询结果的方法。
- en: 'This annotation is used to define a query using JAP query language (and even
    native SQL query) and bind it to the method of the JPA repository. When we call
    that repository method, JPA will execute the query attached to that method with
    the `@Query` annotation. Let''s define two methods with join query on a repository
    interface as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释用于使用 JAP 查询语言（甚至原生 SQL 查询）定义查询并将其绑定到 JPA 存储库的方法。当我们调用该存储库方法时，JPA 将执行带有 `@Query`
    注解的方法附加的查询。以下是在存储库接口上定义两个方法的示例，这些方法使用连接查询：
- en: '[PRE76]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The first method will fetch all tasks available in the system, while the second
    method will fetch tasks that are assigned to a specific user only. The `nativeQery` attribute
    indicates that it is a SQL query. Since this query returns columns from multiple
    tables (**task** and **users** in our case), it returns a list of an array of
    the `Any` type, instead of a specific entity class object. The `List` object represents
    the records row, the elements of `Array` are columns, and `Any` means any available
    type in Kotlin. `Any` is equivalent to `Object` in Java.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法将获取系统中所有可用的任务，而第二种方法将仅获取分配给特定用户的任务。`nativeQuery`属性表示这是一个SQL查询。由于此查询返回多个表（在我们的例子中是**task**和**users**）的列，它返回一个`Any`类型的数组列表，而不是特定的实体类对象。`List`对象代表记录行，`Array`的元素是列，而`Any`表示Kotlin中任何可用的类型。`Any`在Java中相当于`Object`。
- en: 'It can be then used to populate the `TaskDTO` object in the controller method—`showAllTaskList`.
    The keyword `as` is used to do casting from `Any` to a respective type. Kotlin
    compiler uses smart cast so you don''t need to explicitly check if the `Any` type
    given is compatible. For admin users, the task list screen looks as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它可以在控制器方法`showAllTaskList`中用于填充`TaskDTO`对象。关键字`as`用于将`Any`类型转换为相应的类型。Kotlin编译器使用智能转换，因此您不需要显式检查给定的`Any`类型是否兼容。对于管理员用户，任务列表屏幕如下所示：
- en: '![](img/03c35fa4-fe75-44f5-8a64-7994e74c3498.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03c35fa4-fe75-44f5-8a64-7994e74c3498.png)'
- en: 'For the normal user, it looks as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通用户，情况如下所示：
- en: '![](img/7dae280f-8eba-41cd-9ecc-6d9e87392924.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7dae280f-8eba-41cd-9ecc-6d9e87392924.png)'
- en: Viewing a task
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看任务
- en: 'The view task screen will open the task in view mode, meaning it will show
    the details of the task. It also allows you to add a comment and shows the list
    of comments added to the selected task. The controller method for viewing the
    task will populate the task and comment data, and redirects the user to view the
    task screen. The method looks as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 视图任务屏幕将以查看模式打开任务，这意味着它将显示任务的详细信息。它还允许您添加注释并显示添加到所选任务的注释列表。查看任务的控制器方法将填充任务和注释数据，并将用户重定向到查看任务屏幕。该方法如下所示：
- en: '[PRE77]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `taskId` parameter will be sent from a task list screen. First, we fetch
    the task detail from a given `taskId`. We also fetch the user data from the user
    ID associated with the `Task` object. For comments, we do the same thing: fetch
    comments with a given `taskId` from `commentRepository`.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskId`参数将从任务列表屏幕发送。首先，我们从给定的`taskId`获取任务详情。我们还从与`Task`对象关联的用户ID获取用户数据。对于注释，我们做同样的事情：从`commentRepository`获取具有给定`taskId`的注释。'
- en: We fetch comments from `commentRepository` , but we could have fetched it from
    the `Task` object, since they have one-to-many relationships. The reason we do
    not fetch them that way is, we want to show the username to whom the task is assigned.
    If we fetch comments from `Task`, it will return the collection of the object
    of the `Comments` type, which has a user ID but not first and last name. So we
    might have to make an additional round of database calls to fetch the user first
    and last name for each comments record. This may result in a poor performance.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`commentRepository`获取注释，但我们也可以从`Task`对象获取它，因为它们有一对多关系。我们不那样获取的原因是，我们想显示分配给任务的用户名。如果我们从`Task`获取注释，它将返回`Comments`类型的对象集合，该对象具有用户ID但没有首字母和姓氏。因此，我们可能需要再次进行数据库调用以获取每个注释记录的首字母和姓氏。这可能会导致性能不佳。
- en: 'As an alternative, we use a JPA query language mechanism, by associating the `join`
    SQL query with the repository method as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，我们使用JPA查询语言机制，通过将`join` SQL查询与存储库方法关联如下所示：
- en: '[PRE78]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'It is returned as a `List<Array<Any>>` type because the data is fetched from
    multiple tables (**task** and **comments**). We are iterating it and populating
    the list of `CommentDTO` , which is defined as a data class as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据是从多个表（**task**和**comments**）中获取的，它以`List<Array<Any>>`类型返回。我们正在迭代它并填充`CommentDTO`列表，该列表被定义为以下数据类：
- en: '[PRE79]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The  `TaskDTO` object is used to show task details while the list of `CommentDTO`
    is used to show comments in tabular format in the view task screen.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskDTO`对象用于显示任务详情，而`CommentDTO`列表用于在查看任务屏幕中以表格格式显示评论。'
- en: Deleting a task
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除任务
- en: 'Only admin users can delete an existing task. The delete option is visible
    in the task list screen. The controller method of deleting a task looks as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 只有管理员用户可以删除现有任务。删除选项在任务列表屏幕中可见。删除任务的控制器方法如下所示：
- en: '[PRE80]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `taskId` parameter is provided in the task list screen. First, we fetch
    the object of `Task` with `taskId` from `taskRepository` and delete if it is not
    null. Finally, we redirect to another controller method with the `/allTaskList` URL
    to show the task list screen.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskId`参数在任务列表屏幕中提供。首先，我们从`taskRepository`获取带有`taskId`的`Task`对象，如果它不为空，则删除它。最后，我们重定向到另一个控制器方法，使用`/allTaskList`
    URL以显示任务列表屏幕。'
- en: REST call in Kotlin
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中的REST调用
- en: 'Let''s understand how to make a REST call with Kotlin. We expose the REST API
    to add users to the system. Basic user details along with role information need
    to be given. Defining REST controller in Kotlin is similar to Java as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何使用Kotlin进行REST调用。我们公开REST API以向系统中添加用户。需要提供基本用户详情以及角色信息。在Kotlin中定义REST控制器与Java类似，如下所示：
- en: '[PRE81]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `TaskMgmntRESTController` Kotlin class is defined as a REST controller
    with `@RestController` and configures the `/api` URL pattern with the `@RequestMapping`
    annotation. We will write a function that handles the registration of users as
    follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskMgmntRESTController` Kotlin类被定义为REST控制器，使用`@RestController`并使用`@RequestMapping`注解配置了`/api`
    URL模式。我们将编写一个处理用户注册的函数，如下所示：'
- en: '[PRE82]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This function is defined with the `@PostMapping` annotation so data must be
    sent with the HTTP POST method. Also, the URL mapping is `/register` so the effective
    path would be `/api/register` to access this function (method). It consumes the
    data in JSON format. Spring will populate an object of `UserRegistrationDTO` from
    the JSON input. The Kotlin data class is as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用`@PostMapping`注解定义，因此必须使用HTTP POST方法发送数据。此外，URL映射是`/register`，因此有效路径将是`/api/register`以访问此函数（方法）。它以JSON格式消耗数据。Spring将从JSON输入中填充`UserRegistrationDTO`对象。Kotlin数据类如下所示：
- en: '[PRE83]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `username`, `password`, `firstname`, and `lastname` attributes are used
    to insert a record in the user table, while the `roleList` attribute is used to
    associate the roles this user has. The input data must be given in JSON format
    with the HTTP POST method from the REST client as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`username`、`password`、`firstname`和`lastname`属性用于在用户表中插入记录，而`roleList`属性用于关联此用户拥有的角色。输入数据必须以JSON格式通过REST客户端使用HTTP
    POST方法提供，如下所示：'
- en: '[PRE84]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The code written in the `registerNewUser` method will be divided into the following
    two parts.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在`registerNewUser`方法中编写的代码将被分为以下两个部分。
- en: Validation
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: 'A user sends the data in JSON format and it must be validated before entering
    into the system to avoid any backend errors. Instead of imposing a full list of
    validations, we will implement a few basic validations. For example, validating
    an existing username,the role list has invalid values other than `ROLR_USER` and
    `ROLE_ADMIN`. The code looks as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 用户以JSON格式发送数据，在进入系统之前必须进行验证以避免任何后端错误。我们不会强加完整的验证列表，而是将实现一些基本验证。例如，验证现有用户名，角色列表具有除`ROLR_USER`和`ROLE_ADMIN`之外的其他无效值。代码如下所示：
- en: '[PRE85]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'First, we check whether the username sent in JSON data already exists in the
    system. If it does, then return an appropriate message. The second check is about
    the role list. We have created a predefined role list in the `TaskMgmntConstant`
    class with the function declaration as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查JSON数据中发送的用户名是否已在系统中存在。如果存在，则返回适当的消息。第二个检查是关于角色列表的。我们在`TaskMgmntConstant`类中创建了一个预定义的角色列表，其函数声明如下：
- en: '[PRE86]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Let's recall that `TaskMgmntConstant` is singleton class and we can define functions
    apart from constants. If the `roleList` data sent as a JSON string is different
    than these two roles, then we show an appropriate message. You can see how a for-loop
    is used by the `forEach` method with a lambda expression. If any error occurs,
    we send a validation message with HTTP status 401 (`HttpStatus.BAD_REQUEST`).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`TaskMgmntConstant`是一个单例类，我们可以在常量之外定义函数。如果作为JSON字符串发送的`roleList`数据与这两个角色不同，则显示适当的消息。您可以通过`forEach`方法和lambda表达式看到如何使用for循环。如果发生任何错误，我们将使用HTTP状态401（`HttpStatus.BAD_REQUEST`）发送验证消息。
- en: User registration
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户注册
- en: 'If all validations are satisfied, then we will do user registration along with
    role mapping with the following code:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有验证都满足，则我们将执行用户注册以及角色映射，如下所示：
- en: '[PRE87]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In this code, we create the `User` object and populate its value from the `UserRegistrationDTO`
    object. We also create the mutable role list and populate it by fetching roles
    with `roleRepository` , based on the role name populated in `UserRegistrationDTO`
    from the JSON data. Finally, we associate the mutable set with the `User` object
    and save it in `userRepository`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了`User`对象，并从`UserRegistrationDTO`对象中填充其值。我们还创建了一个可变的角色列表，并通过从`roleRepository`获取基于在`UserRegistrationDTO`中填充的角色名称的角色来填充它。最后，我们将可变集合与`User`对象关联，并将其保存到`userRepository`中。
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the basics of Kotlin and its various features, and
    then created an application with Spring Boot and Kotlin. Within a short time span,
    Kotlin has gained huge momentum and popularity due to its capabilities, such as
    its interoperability, conciseness, safety features, and support for well-known
    IDEs.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了Kotlin的基础知识和其各种特性，然后使用Spring Boot和Kotlin创建了一个应用。在很短的时间内，Kotlin因其互操作性、简洁性、安全特性以及对知名IDE的支持而获得了巨大的动力和人气。
- en: Spring Framework has lots of features and is widely used in developing modern
    enterprise applications. With its first class support of various programming languages
    such as Java, Scala, Groovy, and Kotlin, Spring Framework has become a dominant
    player among enterprise-application development frameworks.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架拥有众多特性，并且在开发现代企业应用中被广泛使用。凭借其对Java、Scala、Groovy和Kotlin等编程语言的顶级支持，Spring框架已经成为企业应用开发框架中的主导者。
- en: Spring Framework has a modular design and provides seamless integration in all
    aspects of the system, such as the frontend, controller layer, security, persistence,
    cloud support, messaging support, web flow, and lots more. With the invention
    of Spring Boot, developing Spring-based applications has become easier than ever
    before.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架具有模块化设计，并在系统的各个方面提供无缝集成，例如前端、控制器层、安全、持久化、云支持、消息支持、Web流程等等。随着Spring Boot的发明，基于Spring的应用开发比以往任何时候都要简单。
- en: Throughout this book, we have explored the Spring Framework, showcasing its
    capabilities by developing a sample application in each chapter. This should definitely
    build your confidence and encourage you to explore the framework further. However, we
    recommend you create more sample apps so that you gain more hands-on experience
    and you really get the most out of the framework.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，我们探讨了Spring框架，通过在每一章中开发一个示例应用来展示其功能。这绝对可以增强你的信心，并鼓励你进一步探索这个框架。然而，我们建议你创建更多的示例应用，这样你可以获得更多的实践经验，并真正充分利用这个框架。
- en: Here is a perfect way to finish our journey. For further reading, you can refer
    to the official Spring documentation and forums. Spring has a huge active community,
    and you can find many personal blogs that will help you to learn and explore the
    concepts.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完美的方式结束我们的旅程。为了进一步阅读，你可以参考官方的Spring文档和论坛。Spring有一个庞大的活跃社区，你可以找到许多个人博客，这些博客将帮助你学习和探索这些概念。
