- en: Introduction to Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kubernetes
- en: In this chapter, we will start to learn about Kubernetes, the most popular and
    widely used container orchestrator at the time of writing this book. Since the
    subjects on container orchestrators in general and Kubernetes itself are too big
    to be covered in one chapter, I will focus on introducing the areas that I have
    found to be the most important when I used Kubernetes over the last few years.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始学习Kubernetes，这是在撰写本书时最受欢迎和广泛使用的容器编排器。由于一般容器编排器以及Kubernetes本身的内容太多，无法在一章中覆盖，我将重点介绍在我过去几年使用Kubernetes时发现最重要的内容。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing Kubernetes concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kubernetes概念
- en: Introducing Kubernetes API objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kubernetes API对象
- en: Introducing Kubernetes runtime components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kubernetes运行时组件
- en: Creating a local Kubernetes cluster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建本地Kubernetes集群
- en: Trying out a sample deployment and getting used to the `kubectl` Kubernetes
    CLI tool
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一个示例部署并熟悉`kubectl` Kubernetes命令行工具：
- en: Managing a Kubernetes cluster
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理一个Kubernetes集群
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work with Kubernetes locally, we will use Minikube running on VirtualBox.
    We will also use the Kubernetes CLI tool known as `kubectl` a lot. `kubectl` comes
    with Docker for macOS, but unfortunately with a version that''s too old (at least
    as of when this chapter was written). Therefore, we need to install a newer version.
    In total, we need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地与Kubernetes合作，我们将使用在VirtualBox上运行的Minikube。我们还将大量使用名为`kubectl`的Kubernetes
    CLI工具。`kubectl`随Docker for macOS提供，但不幸的是，版本太旧（至少在撰写本章时）。因此，我们需要安装一个新版本。总共我们需要以下内容：
- en: Minikube version 1.2 or later
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube 1.2或更高版本
- en: kubectl version 1.15 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl` 1.15或更高版本'
- en: VirtualBox version 6.0 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VirtualBox 6.0或更高版本
- en: 'These tools can be installed using Homebrew with the following commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具可以使用Homebrew以下命令安装：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After installing `kubectl`, run the following command to ensure that the newer
    version of `kubectl` is used:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装`kubectl`后，运行以下命令确保使用新版本的`kubectl`：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The installation of VirtualBox will ask you to rely on the system extensions
    that come with VirtualBox:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装VirtualBox时，它会要求你依赖VirtualBox附带的系统扩展：
- en: '![](img/d6ccf0f8-41b0-4145-8956-2f97719b5556.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6ccf0f8-41b0-4145-8956-2f97719b5556.png)'
- en: 'Click on the OK button and then on the Allow button in the next dialog window:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 点击对话框中的“确定”按钮，然后点击下一个对话窗口中的“允许”按钮：
- en: '![](img/23dd883f-5cb1-4078-be74-65f77336496c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23dd883f-5cb1-4078-be74-65f77336496c.png)'
- en: 'Conclude the tool''s installation by verifying the versions of the installed
    tools with the following commands:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令验证安装工具的版本：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Expect a response such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到如下响应：
- en: '![](img/860bf0d5-1a10-4dc4-9a58-95c7651f5921.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/860bf0d5-1a10-4dc4-9a58-95c7651f5921.png)'
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter15](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter15).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter15](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter15)。
- en: 'To be able to run the commands that are described in this book, you need to
    download the source code to a folder and set up an environment variable, `$BOOK_HOME`,
    that points to that folder. Some sample commands are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中描述的命令，你需要将源代码下载到一个文件夹中，并设置一个环境变量`$BOOK_HOME`，该变量指向该文件夹。一些示例命令如下：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All the source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter15`
    and have been tested using Kubernetes 1.15.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有源代码示例都来自`$BOOK_HOME/Chapter15`的源代码，并使用Kubernetes 1.15进行了测试。
- en: Introducing Kubernetes concepts
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kubernetes概念
- en: At a high level, as a container orchestrator, Kubernetes makes a cluster of
    servers (physical or virtual) that run containers appear as one big logical server
    running containers. As an operator, we declare a desired state to the Kubernetes
    cluster by creating objects using the Kubernetes API. Kubernetes continuously
    compares the desired state with the current state. If it detects differences,
    it takes actions to ensure that the current state is the same as the desired state.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在较高层面上，作为容器编排器，Kubernetes 使得运行容器的服务器集群（物理或虚拟）呈现为一个运行容器的巨大逻辑服务器。作为操作员，我们通过使用
    Kubernetes API 创建对象来向 Kubernetes 集群声明期望状态。Kubernetes 持续将期望状态与当前状态进行比较。如果检测到差异，它会采取行动确保当前状态与期望状态一致。
- en: One of the main purposes of a Kubernetes cluster is to deploy and run containers,
    but also to support zero-downtime rolling upgrades using techniques such as green/blue
    and canary deployments. Kubernetes can schedule containers, that is, **pods** that
    contain one or more co-located containers, to the available nodes in the cluster.
    To be able to monitor the health of running containers, Kubernetes assumes that
    containers implement a **liveness** **probe**. If a liveness probe reports an
    unhealthy container, Kubernetes will restart the container. Containers can be
    scaled in the cluster manually or automatically using a horizontal autoscaler.
    To optimize the use of the available hardware resources in a cluster, for example,
    memory and CPU, containers can be configured with **quotas** that specify how
    much resources a container needs. On the other hand, limits regarding how much
    a group of containers is allowed to consume can be specified on a **namespace**
    level. Namespaces will be introduced as we proceed through this chapter. This
    is of extra importance if several teams share a common Kubernetes cluster.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群的主要目的之一是部署和运行容器，同时也支持使用绿色/蓝色和金丝雀部署等技术实现零停机滚动升级。Kubernetes 可以安排容器，即包含一个或多个并列容器的**豆荚**，到集群中可用的节点。为了能够监控运行中容器的健康状况，Kubernetes
    假定容器实现了**存活探针**。如果存活探针报告了一个不健康的容器，Kubernetes 将重新启动该容器。容器可以在集群中手动或自动扩展，使用水平自动扩展器。为了优化集群中可用硬件资源的使用，例如内存和
    CPU，容器可以配置**配额**，指明容器需要多少资源。另一方面，可以在**命名空间**级别指定关于一组容器允许消耗多少资源的上限。随着本章的进行，将介绍命名空间。如果多个团队共享一个
    Kubernetes 集群，这尤为重要。
- en: Another main purpose of Kubernetes is to provide service discovery of the running
    pods and its containers. Kubernetes `Service` objects can be defined for services
    discovery and will also load balance incoming requests over the available pods.
    `Service` objects can be exposed externally of a Kubernetes cluster. However,
    as we will see, an Ingress object is, in many cases, better suited to handling
    externally incoming traffic to a group of services. To help Kubernetes find out
    whether a container is ready to accept incoming requests, a container can implement
    a **readiness probe**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的另一个主要目的是提供运行豆荚及其容器的服务发现。Kubernetes `Service` 对象可以定义为服务发现，并且还会负载均衡传入请求到可用的豆荚。`Service`
    对象可以暴露在 Kubernetes 集群的外部。然而，正如我们将看到的，在许多情况下，Ingress 对象更适合处理一组服务的外部传入流量。为了帮助 Kubernetes
    查明一个容器是否准备好接受传入请求，容器可以实现一个**就绪探针**。
- en: Internally, a Kubernetes cluster provides one big flat IP network where each
    pod gets its own IP address and can reach all the other pods, independent of what
    node they run on. To support multiple network vendors, Kubernetes allows the use
    of network plugins that comply with the **Container Network Interface** (**CNI**) specification
    ([https://github.com/containernetworking/cni](https://github.com/containernetworking/cni)).
    Pods are not isolated by default, that is, they accept all incoming requests.
    CNI plugins that support the use of network policy definitions can be used to
    lock down access to pods, for example, only allowing traffic from pods in the
    same namespace.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 内部而言，Kubernetes 集群提供了一个大的扁平化 IP 网络，每个豆荚获得自己的 IP 地址，并且可以独立于它们运行的节点到达所有其他豆荚。为了支持多个网络供应商，Kubernetes
    允许使用符合**容器网络接口**（**CNI**）规范的网络插件([https://github.com/containernetworking/cni](https://github.com/containernetworking/cni))。豆荚默认情况下是不隔离的，也就是说，它们接受所有传入请求。支持使用网络策略定义的网络插件可以用来锁定对豆荚的访问，例如，只允许来自同一命名空间中豆荚的流量。
- en: To allow multiple teams to work on the same Kubernetes cluster in a safe way, **Role-Based
    Access Control** (**RBAC**, [https://kubernetes.io/docs/reference/access-authn-authz/rbac](https://kubernetes.io/docs/reference/access-authn-authz/rbac)/)
    can be applied. For example, administrators can be authorized to access resources
    on a cluster level, while the access of team members can be locked down to resources
    that are created in a namespace owned by the teams.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使多个团队能够安全地在同一个Kubernetes集群上工作，可以应用**基于角色的访问控制**（**RBAC**，[https://kubernetes.io/docs/reference/access-authn-authz/rbac](https://kubernetes.io/docs/reference/access-authn-authz/rbac)/）。例如，管理员可以被授权访问集群级别的资源，而团队成员的访问可以被限制在他们团队拥有的命名空间中创建的资源。
- en: In total, these concepts provide a platform for running containers that is scalable,
    secure, highly available, and resilient.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这些概念为运行容器提供了一个可扩展、安全、高可用性和弹性的平台。
- en: Let's look a bit more into API objects that are available in Kubernetes and
    after that, what runtime components make up a Kubernetes cluster.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解一下Kubernetes中可用的API对象，然后看看组成Kubernetes集群的运行时组件是什么。
- en: Introducing Kubernetes API objects
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kubernetes API对象
- en: 'Kubernetes defines an API that is used to manage different types of *objects* or
    *resources*, as they are also known as. Some of the most commonly used types, or *kinds*, as
    they are referred to in the API, are as follows in my experience:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes定义了一个API，用于管理不同类型的*对象*或*资源*，在API中也被称为*种类*。根据我的经验，一些最常用的类型或*种类*如下：
- en: '**Node:** A node represents a server, virtual or physical, in the cluster.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点：** 节点代表集群中的一个服务器，可以是**虚拟的**或**物理的**。'
- en: '**Pod:** A pod represents the smallest possible deployable component in Kubernetes,
    consisting of one or more co-located containers. Typically, a pod consists of
    one container, but there are use cases for extending the functionality of the
    main container by running the second container in a pod. In [Chapter 18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml),
    *Using a Service Mesh to Improve Observability and Management*, a second container
    will be used in the pods, running a sidecar that makes the main container join
    the service mesh.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod：** Pod是Kubernetes中可部署的最小组件，由一个或多个共置的容器组成。通常，一个Pod包含一个容器，但有一些用例通过在Pod中运行第二个容器来扩展主容器的功能。在[第18章](422649a4-94bc-48ae-b92b-e3894c014962.xhtml)，*使用服务网格提高可观测性和管理*，将在Pod中运行第二个容器，运行一个边车使主容器加入服务网格。'
- en: '**Deployment**: Deployment is used to deploy and upgrade pods. The deployment
    objects hand over the responsibility of creating and monitoring the pods to a
    ReplicaSet. When creating a deployment for the first time, the work performed
    by the deployment object is no much more than creating the ReplicaSet object.
    When performing a rolling upgrade of deployment, the role of the deployment object
    is more involved.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：部署用于部署和升级Pod。部署对象将创建和监控Pod的责任交给了副本集。第一次创建部署时，部署对象所做的工作并不多，只是创建了副本集对象。在执行部署的滚动升级时，部署对象的角色更加复杂。'
- en: '**ReplicaSet**: A ReplicaSet is used to ensure that a specified number of pods
    are running at all times. If a pod is deleted, it will be replaced with a new
    pod by the ReplicaSet.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副本集**：副本集用于确保始终运行指定数量的Pod。如果一个Pod被删除，副本集会用一个新的Pod来替换它。'
- en: '**Service**: A service is a stable network endpoint that you can use to connect
    to one or multiple pods. A service is assigned an IP address and a DNS name in
    the internal network of the Kubernetes cluster. The IP address of the service
    will stay the same for the lifetime of the service. Requests that are sent to
    a service will be forwarded to one of the available pods using round-robin-based
    load balancing. By default, a service is only exposed inside the cluster using
    a cluster IP address. It is also possible to expose a service outside the cluster,
    either on a dedicated port on each node in the cluster or – even better – through
    an external load balancer that is aware of Kubernetes, that is, it can automatically
    provision a public IP address and/or DNS name for the service. Cloud providers
    that offer Kubernetes as a service, in general, support this type of load balancer.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务（Service）**：服务是一个稳定的网络端点，您可以使用它来连接一个或多个Pod。服务在Kubernetes集群的内部网络中被分配一个IP地址和DNS名称。服务的IP地址在其生命周期内保持不变。发送到服务的请求将通过轮询负载均衡转发到可用的Pod之一。默认情况下，服务只通过集群IP地址在集群内部暴露。还可以将服务暴露在集群外部，要么在每个节点上专用端口上，要么——更好的方法——通过一个意识到Kubernetes的外部负载均衡器，也就是说，它可以自动为服务分配一个公共IP地址和/或DNS名称。通常，提供Kubernetes作为服务的云提供商支持这种负载均衡器。'
- en: '**Ingress*:*** Ingress can manage external access to services in a Kubernetes
    cluster, typically using HTTP. For example, it can route traffic to the underlying
    services based on URL paths or HTTP headers such as the hostname. Instead of exposing
    a number of services externally, either using node ports or through load balancers,
    it is, in general, more convenient to set up an Ingress in front of the services.
    To handle the actual communication defined by the Ingress objects, an Ingress
    controller must be running in the cluster. We will see an example of an Ingress
    controller as we proceed.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入口（Ingress）**：入口可以管理Kubernetes集群中服务的对外访问，通常使用HTTP。例如，它可以根据URL路径或HTTP头（如主机名）将流量路由到底层服务。与其在外部暴露多个服务，使用节点端口或负载均衡器，通常在服务前设置一个入口更为方便。为了处理Ingress对象定义的实际通信，必须在集群中运行一个Ingress控制器。我们将在后面看到一个Ingress控制器的示例。'
- en: '**Namespace**: A namespace is used to group and, on some levels, isolate resources
    in a Kubernetes cluster. The names of resources must be unique in their namespaces,
    but not between namespaces.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间（Namespace）**：命名空间用于将资源分组并在某些层面上隔离在Kubernetes集群中。资源在其命名空间内的名称必须是唯一的，但命名空间之间不需要唯一。'
- en: '**ConfigMap**: ConfigMap is used to store configuration that''s used by containers.
    ConfigMaps can be mapped into a running container as environment variables or
    files.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置映射（ConfigMap）**：ConfigMap用于存储容器使用的配置。ConfigMaps可以映射到运行中的容器作为环境变量或文件。'
- en: '**Secret: **This is used to store sensitive data used by containers, such as
    credentials. Secrets can be made available to containers in the same way as ConfigMaps.
    Anyone with full access to the API server can access the values of created secrets,
    so they are not as safe as the name might imply.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥（Secret）**：此功能用于存储容器使用的敏感数据，例如凭据。密钥可以像ConfigMaps一样供容器使用。任何具有对API服务器完全访问权限的人都可以访问创建的密钥的值，因此它们并不像名称暗示的那样安全。'
- en: '**DaemonSet**: This ensures that one pod is running on each node in a set of
    nodes in the cluster. In [Chapter 19](7a733f89-e54e-48d2-9a03-d7d2f72157ac.xhtml),
    *Centralized Logging with the EFK Stack*, we will see an example of a log collector,
    Fluentd, that will run on each worker node.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**守护进程集（DaemonSet）**：这确保在集群的一组节点中每个节点上运行一个Pod。在[第19章](7a733f89-e54e-48d2-9a03-d7d2f72157ac.xhtml)，*使用EFK堆栈进行集中日志记录*，我们将看到一个日志收集器Fluentd的示例，它将在每个工作节点上运行。'
- en: For a full list of resource objects that the Kubernetes API covers in v1.15,
    see [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Kubernetes API在v1.15中涵盖的资源对象列表，请参阅[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/)。
- en: 'The following diagram summarizes the Kubernetes resources that are involved
    in handling incoming requests:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了处理传入请求的Kubernetes资源：
- en: '![](img/cdf2a486-253b-4f11-abc7-2ee25e3694e6.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdf2a486-253b-4f11-abc7-2ee25e3694e6.png)'
- en: 'In the preceding diagram, we can see the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到以下内容：
- en: Two deployments, **Deployment A** and **Deployment B**, have been deployed to
    a cluster with two nodes, **Node 1** and **Node ****2**.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个部署，**Deployment A** 和 **Deployment B**，已经部署在具有两个节点的集群上，分别是**Node 1**和**Node
    2**。
- en: '**Deployment A** contains two pods, **Pod A1** and **Pod** **A2**.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployment A** 包含两个 Pod，**Pod A1** 和 **Pod A2**。'
- en: '**Deployment B** contains one **Pod** **B1**.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployment B** 包含一个 **Pod** **B1**。'
- en: '**Pod A1** is scheduled to **Node 1**.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod A1** 被调度到**节点 1**。'
- en: '**Pod A2** and **Pod B1** are scheduled to **Node 2**.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod A2** 和 **Pod B1** 被调度到**节点 2**。'
- en: Each deployment has a corresponding service deployed, **Service A** and **Service B**,
    and they are available on all nodes.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部署都有一个对应的服务，**服务 A** 和 **服务 B**，它们在所有节点上都可用。
- en: An Ingress is defined to route incoming requests to the two services.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个 Ingress 以将传入请求路由到两个服务。
- en: A client typically sends requests to the cluster via an external load balancer.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端通常通过外部负载均衡器向集群发送请求。
- en: These objects are not, by themselves, running components; instead, they are
    definitions of different types of desired states. To reflect the desired state
    in the cluster's current state, Kubernetes comes with an architecture consisting
    of a number of runtime components, as described in the next section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象本身并不是运行中的组件；相反，它们是不同类型期望状态的定义。为了将期望状态反映到集群的当前状态，Kubernetes 包含一个由多个运行时组件组成的架构，如下一节所述。
- en: Introducing Kubernetes runtime components
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Kubernetes 运行时组件
- en: 'A Kubernetes cluster contains two types of nodes: master nodes and worker nodes.
    Master nodes manage the cluster, while the main purpose of worker nodes is to
    run the actual workload, for example, the containers we deploy in the cluster.
    Kubernetes is built up by a number of runtime components. The most important components
    are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Kubernetes 集群包含两种类型的节点：主节点和工作节点。主节点负责管理集群，而工作节点的的主要用途是运行实际的工作负载，例如我们在集群中部署的容器。Kubernetes
    由多个运行时组件构成。最重要的组件如下：
- en: 'There are components that run on master nodes, constituting the control plane:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主节点上运行的组件构成了控制平面：
- en: '`api-server`, the entry point to the control plane. This exposes a RESTful
    API, which, for example, the Kubernetes CLI tool known as `kubectl` uses.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api-server`，控制平面的入口点。它暴露一个 RESTful API，例如，Kubernetes CLI 工具 `kubectl` 使用该
    API。'
- en: '`etcd`, a highly available and distributed key/value store, used as a database
    for all cluster data.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`，一个高可用性和分布式键/值存储，用作所有集群数据的数据库。'
- en: A controller manager, which contains a number of controllers that continuously evaluate
    the desired state versus the current state for the objects defined in the `etcd`
    database.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个控制器管理器，其中包含多个控制器，这些控制器不断地评估对象在 `etcd` 数据库中定义的期望状态与当前状态。
- en: Whenever the desired or the current state changes, a controller that's responsible
    for that type of state takes actions to move the current state to the desired
    state. For example, a replication controller that's responsible for managing pods
    will react if a new pod is added through the API server or a running pod dies
    and ensures that new pods are started. Another example of a controller is the
    node controller. It is responsible for acting if a node becomes unavailable, ensuring
    that pods running on a failing node are rescheduled on other nodes in the cluster.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当期望状态或当前状态发生变化时，负责该类型状态的控制器会采取行动将当前状态移动到期望状态。例如，负责管理 Pod 的复制控制器如果通过 API 服务器添加新的
    Pod 或者运行中的 Pod 停止运行，会做出反应并确保新的 Pod 被启动。控制器的一个其他例子是节点控制器。如果一个节点变得不可用，它负责确保在失败节点上运行的
    Pod 被重新调度到集群中的其他节点。
- en: A **Scheduler**, which is responsible for assigning newly created pods to a
    node with available capacity, for example, in terms of memory and CPU. Affinity
    rules can be used to control how pods are assigned to nodes. For example, pods
    that perform a lot of disks I/O can be assigned to a group of worker nodes that
    have fast SSD disks. Anti-affinity rules can be defined to separate pods, for
    example, to avoid scheduling pods from the same deployment to the same worker
    node.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**调度器**，负责将新创建的 Pod 分配给具有可用能力的节点，例如，在内存和 CPU 方面。可以使用亲和规则来控制 Pod 如何分配到节点。例如，执行大量磁盘
    I/O 的 Pod 可以将分配给拥有快速 SSD 磁盘的一组工作节点。可以定义反亲和规则来分离 Pod，例如，避免将来自同一部署的 Pod 调度到同一工作节点。
- en: 'Components that run on all the nodes that constitute the data plane are as
    follows:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有节点上运行构成数据平面的组件如下：
- en: '`kubelet`, a node agent that executes as a process directly in the nodes operating
    system and not as a container. It is responsible for that the containers that
    are up and running in the pods being assigned to the node where `kubelet` runs.
    It acts as a conduit between the `api-server` and the container runtime on its
    node.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubelet`，这是一个在节点操作系统中直接作为进程执行而不是作为容器的节点代理。它负责在分配给 `kubelet` 运行的节点上运行的 pod
    中的容器运行和启动。它充当 `api-server` 和其节点上的容器运行时之间的通道。'
- en: '`kube-proxy`, a network proxy that enables the service concept in Kubernetes
    and is capable of forwarding requests to the appropriate pods, typically in a
    round-robin fashion if more than one pod is available for the specific service. `kube-proxy`
    is deployed as a DaemonSet.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-proxy`，这是一个网络代理，它使 Kubernetes 中的服务概念成为可能，并能够将请求转发到适当的 pod，通常如果有多个 pod
    可用，就会以轮询方式转发。`kube-proxy` 作为 DaemonSet 部署。'
- en: '**Con****tainer** **runtime**, which is the software that runs containers on
    the node. Typically, this is Docker, but any implementation of the Kubernetes **Container
    Runtime Interface** (**CRI**) can be used, for example, `cri-o` ([https://cri-o.io](https://cri-o.io)), `containerd` ([https://containerd.io/](https://containerd.io/)),
    or `rktlet` ([https://github.com/kubernetes-incubator/rktlet](https://github.com/kubernetes-incubator/rktlet)).'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器运行时**，运行在节点上的容器的软件。通常这是 Docker，但任何实现 Kubernetes **容器运行时接口**（**CRI**）的都可以使用，例如
    `cri-o` ([https://cri-o.io](https://cri-o.io))、`containerd` ([https://containerd.io/](https://containerd.io/))
    或 `rktlet` ([https://github.com/kubernetes-incubator/rktlet](https://github.com/kubernetes-incubator/rktlet))。'
- en: '**Kubernetes DNS**, which is a DNS server that''s used in the cluster''s internal
    network. Services and pods are assigned a DNS name, and pods are configured to
    use this DNS server to resolve the internal DNS names. The DNS server is deployed
    as a deployment object and a service object.'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes DNS**，这是一个在集群内部网络中使用的 DNS 服务器。服务和 pod 会被分配一个 DNS 名称，而 pod 会被配置使用这个
    DNS 服务器来解析内部 DNS 名称。DNS 服务器作为部署对象和服务对象部署。'
- en: 'The following diagram summarizes the Kubernetes runtime components:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了 Kubernetes 运行时组件：
- en: '![](img/6d8bfda7-c2b2-4b85-b4d7-5f30250bc9b9.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d8bfda7-c2b2-4b85-b4d7-5f30250bc9b9.png)'
- en: Now that we understand the Kubernetes runtime components and what they support
    and run on, let's move on to creating a Kubernetes cluster with Minikube.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 Kubernetes 运行时组件以及它们支持什么和运行在什么上，那么接下来让我们使用 Minikube 创建一个 Kubernetes
    集群。
- en: Creating a Kubernetes cluster using Minikube
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Minikube 创建 Kubernetes 集群
- en: Now, we are ready to create a Kubernetes cluster! We will use Minikube to create
    a local single-node cluster running on VirtualBox.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建一个 Kubernetes 集群！我们将使用 Minikube 创建一个在 VirtualBox 上运行的本地单节点集群。
- en: Before creating the Kubernetes cluster, we need to learn a bit about Minikube
    profiles, the Kubernetes CLI tool known as `kubectl`, and its use of contexts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Kubernetes 集群之前，我们需要了解一下 Minikube 配置文件、被称为 `kubectl` 的 Kubernetes CLI 工具以及其使用的上下文。
- en: Working with Minikube profiles
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Minikube 配置文件工作
- en: 'In order to run multiple Kubernetes clusters locally, Minikube comes with the
    concept of profiles. For example, if you want to work with multiple versions of
    Kubernetes, you can create multiple Kubernetes clusters using Minikube. Each cluster
    will be assigned a separate Minikube profile. Most of the Minikube commands accept
    a `--profile` flag (or `-p` for short) that can be used to specify which of the Kubernetes
    clusters the command shall be applied to. If you plan to work with one specific
    profile for a while, a more convenient alternative exists, where you specify the
    current profile with the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地运行多个 Kubernetes 集群，Minikube 带有一个配置文件的概念。例如，如果你想与多个版本的 Kubernetes 一起工作，可以使用
    Minikube 创建多个 Kubernetes 集群。每个集群将被分配一个单独的 Minikube 配置文件。Minikube 的大部分命令都接受一个 `--profile`
    标志（或 `-p` 的简写），可以用来指定哪个 Kubernetes 集群应应用该命令。如果你计划与一个特定的配置文件工作一段时间，还有一个更方便的替代方案，你通过以下命令指定当前配置文件：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command will set the `my-profile` profile as the current profile.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会将 `my-profile` 配置文件设置为当前配置文件。
- en: 'To get the current profile, run the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前配置文件，请运行以下命令：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If no profile is specified, neither using the `minikube profile` command nor
    the `--profile` switch, a default profile named `minikube` will be used.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定配置文件，既没有使用 `minikube profile` 命令也没有使用 `--profile` 选项，那么将使用名为 `minikube`
    的默认配置文件。
- en: Information regarding existing profiles can be found in the `~/.minikube/profiles` folder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有关现有配置文件的信息可以在 `~/.minikube/profiles` 文件夹中找到。
- en: Working with Kubernetes CLI, kubectl
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes CLI，kubectl
- en: '`kubectl` is the Kubernetes CLI tool. Once a cluster has been set up, this
    is usually the only tool you need to manage the cluster!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 是 Kubernetes 的命令行工具。一旦建立了一个集群，这通常是管理集群所需的所有工具！'
- en: For managing the API objects we described earlier in this chapter, the `kubectl
    apply` command is the only command you need to know about. It is a declarative
    command; that is, as an operator, we ask Kubernetes to apply the object definition
    we give to the command. It is then up to Kubernetes to figure out what actually
    needs to be done.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理本章前面描述的 API 对象，`kubectl apply`命令是您需要了解的唯一命令。它是一个声明性命令，也就是说，作为操作员，我们要求 Kubernetes
    应用我们给出的对象定义到命令中。然后由 Kubernetes 决定实际需要执行哪些操作。
- en: Another example of a declarative command that's hopefully familiar to many readers
    of this book is a `SQL SELECT` statement that joins information from several database
    tables. We only declare the expected result in the SQL query, and it is up to
    the database query optimizer to figure out in what order the tables shall be accessed
    and what indexes to use to retrieve the data in the most efficient way.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 许多阅读本书的读者可能熟悉的另一个声明性命令是一个`SQL SELECT`语句，它从几个数据库表中连接信息。我们只在 SQL 查询中声明期望的结果，而数据库查询优化器则负责决定按什么顺序访问表以及使用哪些索引以最有效的方式检索数据。
- en: In some cases, imperative statements that explicitly tell Kubernetes what to
    do are preferred. One example is the `kubectl delete` command, where we explicitly
    tell Kubernetes to delete some API objects. Creating a namespace object can also
    be conveniently done with an explicit `kubectl create namespace` command.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，显式告诉 Kubernetes 做什么的命令式语句更受欢迎。一个例子是`kubectl delete`命令，我们明确告诉 Kubernetes
    删除一些 API 对象。也可以使用显式的`kubectl create namespace`命令方便地创建一个命名空间对象。
- en: Repetitive usage of the imperative statements will make them fail, for example,
    deleting the same API object twice using `kubectl delete` or creating the same
    namespace twice using `kubectl create`. A declarative command, that is, using
    `kubectl apply`, will not fail on repetitive usage—it will simply state that there
    is no change and exit without taking any action.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用命令式语句会导致它们失败，例如，使用`kubectl delete`删除两次相同的 API 对象，或者使用`kubectl create`创建两次相同的命名空间。声明性命令，即使用`kubectl
    apply`，在重复使用时不会失败——它只会声明没有变化并退出，不采取任何行动。
- en: 'Some commonly used commands for retrieving information about a Kubernetes cluster
    are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于获取关于 Kubernetes 集群信息的一些常用命令：
- en: '`kubectl get` shows information about the specified API object.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl get`显示指定 API 对象的信息。'
- en: '`kubectl describe` gives more detail about the specified API object.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl describe`为指定的 API 对象提供更多详细信息。'
- en: '`kubectl logs` display log output from containers.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl logs`显示容器的日志输出。'
- en: We will see a lot of examples of these and other `kubectl` commands in this
    and the upcoming chapters!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章及接下来的章节中看到许多这些以及其他`kubectl`命令的示例！
- en: If in doubt about how to use the `kubectl` tool, the `kubectl help` and `kubectl
    <command> --help` commands are always available and provide very useful information
    on how to use the `kubectl` tool.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对如何使用`kubectl`工具感到困惑，`kubectl help`和`kubectl <command> --help`命令始终可用，并提供有关如何使用`kubectl`工具非常有用的信息。
- en: Working with kubectl contexts
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 kubectl 上下文工作
- en: 'To be able to work with more than one Kubernetes cluster, using either Minikube
    locally or Kubernetes clusters set up on-premises servers or in the cloud, `kubectl`
    comes with the concept of contexts. A context is a combination of the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够与多个 Kubernetes 集群一起工作，使用本地 Minikube 或者在本地服务器或云上设置的 Kubernetes 集群，`kubectl`
    带来了上下文（contexts）的概念。上下文是以下内容的组合：
- en: A Kubernetes cluster
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 集群
- en: Authentication information for a user
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户认证信息
- en: A default namespace
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认命名空间
- en: By default, contexts are saved in the `~/.kube/config` file, but the file can
    be changed using the `KUBECONFIG` environment variable. In this book, we will
    use the default location, so we will unset `KUBECONFIG` using the `unset KUBECONFIG` command.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，上下文保存在`~/.kube/config`文件中，但可以通过`KUBECONFIG`环境变量来更改该文件。在这本书中，我们将使用默认位置，因此我们将使用`unset
    KUBECONFIG`命令来取消设置`KUBECONFIG`。
- en: When a Kubernetes cluster is created in Minikube, a context is created with
    the same name as the Minikube profile and is then set as the current context.
    So, `kubectl` commands that are issued after the cluster is created in Minikube
    will be sent to that cluster.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Minikube中创建Kubernetes集群时，会创建一个与Minikube配置文件同名上下文，并将其设置为当前上下文。因此，在Minikube中创建集群后发布的`kubectl`命令将会发送到该集群。
- en: 'To list the available contexts, run the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出可用的上下文，请运行以下命令：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is a sample response:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例响应：
- en: '![](img/9f432d73-d57a-4227-bdf6-880fe1b7a39a.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f432d73-d57a-4227-bdf6-880fe1b7a39a.png)'
- en: The wildcard, `*`, in the first column, mark the current context.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列中的通配符`*`标记当前上下文。
- en: You will only see the `handson-spring-boot-cloud` context in the preceding response
    once the cluster has been created, which we will describe here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在集群创建完成后，你才会在前面的响应中看到`handson-spring-boot-cloud`上下文，下面我们将进行描述。
- en: 'If you want to switch the current context to another context, that is, work
    with another Kubernetes cluster, run the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将当前上下文切换到另一个上下文，即与其他Kubernetes集群一起工作，请运行以下命令：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the current context will be changed to `my-cluster`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当前上下文将更改为`my-cluster`。
- en: To update a context, for example, switching the default namespace used by `kubectl`,
    use the `kubectl config set-context` command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新上下文，例如，切换`kubectl`使用的默认命名空间，请使用`kubectl config set-context`命令。
- en: 'For example, to change the default namespace of the current context to `my-namespace`,
    use the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将当前上下文的默认命名空间更改为`my-namespace`，请使用以下命令：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding command, `kubectl config current-context` is used to get the
    name of the current context.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`kubectl config current-context`用于获取当前上下文的名字。
- en: Creating a Kubernetes cluster
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Kubernetes集群
- en: 'To create a Kubernetes cluster using Minikube, we need to run a few commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Minikube创建Kubernetes集群，我们需要运行几个命令：
- en: Unset the `KUBECONFIG` environment variable to ensure that the `kubectl` context
    is created in the default config file, `~/.kube/config`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消设置`KUBECONFIG`环境变量，以确保`kubectl`上下文创建在默认配置文件`~/.kube/config`中。
- en: Specify the Minikube profile to be used for the cluster. We will use `handson-spring-boot-cloud` as
    the profile name.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定要用于集群的Minikube配置文件。我们将使用`handson-spring-boot-cloud`作为配置文件名。
- en: Create the cluster using the `minikube start` command, where we can also specify
    how much hardware resources we want to allocate to the cluster. To be able to
    complete the examples in the remaining chapters of this book, allocate at least
    10 GB of memory, that is, 10,240 MB, to the cluster.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`minikube start`命令创建集群，我们还可以指定要分配给集群的硬件资源量。为了能够完成本书剩余章节中的示例，请至少为集群分配10 GB内存，即10,240
    MB。
- en: After the cluster has been created, we will use the add-on manager in Minikube
    to enable an Ingress controller and a metrics server that comes out of the box
    with Minikube. The Ingress controller and the metrics will be used in the next
    two chapters.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群创建完成后，我们将使用Minikube的插件管理器来启用Minikube自带的Ingress控制器和指标服务器。Ingress控制器和指标将在接下来的两章中使用。
- en: Before you create a Kubernetes cluster using Minikube, it might be a good idea
    to shut down Docker for macOS to avoid running out of memory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Minikube创建Kubernetes集群之前，关闭macOS上的Docker可能是个好主意，以避免内存不足。
- en: 'Run the following commands to create the Kubernetes cluster:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来创建Kubernetes集群：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After the preceding commands complete, you should be able to communicate with
    the cluster. Try the `kubectl get nodes` command. It should respond with something
    that looks similar to the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令完成后，你应该能够与集群通信。尝试运行`kubectl get nodes`命令。它应该响应与以下内容相似的东西：
- en: '![](img/da7ecf41-9129-4e4a-8eb1-c37936e83aa6.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da7ecf41-9129-4e4a-8eb1-c37936e83aa6.png)'
- en: 'Once created, the cluster will initialize itself in the background, starting
    up a number of system pods in the `kube-system` namespace. We can monitor its
    progress by issuing the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，集群将在后台初始化自己，在`kube-system`命名空间中启动多个系统pods。我们可以通过以下命令监控其进度：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the startup is complete, the preceding command should report the status
    for all pods as `Running` and the READY count should be `1/1`, meaning that a
    single container in each pod is up and running:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动完成，之前的命令应该报告所有pods的状态为`运行中`，并且READY计数应该是`1/1`，这意味着每个pods中的单个容器都在运行中。
- en: '![](img/91deb3a4-1969-4c58-a0bf-6c7bab49fd86.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91deb3a4-1969-4c58-a0bf-6c7bab49fd86.png)'
- en: We are now ready for some action!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备采取一些行动！
- en: Trying out a sample deployment
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一个示例部署
- en: 'Let''s see how we can do the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们应该如何进行以下操作呢？
- en: Deploy a simple web server based on NGINX in our Kubernetes cluster.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Kubernetes集群中部署一个基于NGINX的简单web服务器。
- en: 'Apply some changes to the deployment:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对部署应用一些更改：
- en: Delete a pod and verify that the ReplicaSet creates a new one.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个pods并验证ReplicaSet创建一个新的。
- en: Scale the web server to three pods to verify that the ReplicaSet fills the gap.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将web服务器扩展到三个pods，以验证ReplicaSet填充差距。
- en: Route external traffic to it using a service with a node port.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具有节点端口的服务的路由将外部流量指向它。
- en: 'First, create a namespace, `first-attempts`, and update the `kubectl` context
    to use this namespace by default:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`first-attempts`的命名空间，并更新`kubectl`上下文，使其默认使用此命名空间：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now create a deployment of NGINX in the namespace using the `kubernetes/first-attempts/nginx-deployment.yaml` file.
    This file looks as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`kubernetes/first-attempts/nginx-deployment.yaml`文件在命名空间中创建一个NGINX部署。这个文件如下所示：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: The `kind` and `apiVersion` attributes are used to specify that we are declaring
    a deployment object.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`和`apiVersion`属性用于指定我们正在声明一个部署对象。'
- en: The `metadata` section is used to describe the deployment object, for example,
    when we give it a name of `nginx-deploy`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`部分用于描述部署对象，例如，当我们给它一个名字`nginx-deploy`时。'
- en: 'Next comes a `spec` section that defines our desired state of the deployment
    object:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一个`spec`部分，它定义了部署对象的期望状态：
- en: '`replicas: 1` specifies we want to have one pod up and running.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replicas: 1`指定我们希望运行一个pods。'
- en: A `selector` section that specifies how the deployment will find the pods it
    manages. In this case, the deployment will look for pods that have the `app` label
    set to `nginx-app`.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`部分指定部署如何查找其管理的pods。在这种情况下，部署将查找具有`app`标签设置为`nginx-app`的pods。'
- en: 'The `template` section is used to specify how pods shall be created:'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`部分用于指定如何创建pods：'
- en: 'The `metadata` section specifies the `label`, `app: nginx-app`, which is used
    to identify the pods, thereby matching the selector.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`部分指定了`label`，`app: nginx-app`，用于标识pods，从而匹配选择器。'
- en: The `spec` section specifies details for the creation of the single container
    in the pod, that is, `name` and `image` and what `ports` it uses.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`部分指定单个容器在pods中的创建细节，即`name`和`image`以及它使用哪些`ports`。'
- en: 'Create the deployment with the following commands:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建部署：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s see what we got with the `kubectl get all` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`kubectl get all`命令我们能得到什么：
- en: '![](img/b598f9f8-8904-434f-8927-9e2ff0860e89.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b598f9f8-8904-434f-8927-9e2ff0860e89.png)'
- en: As expected, we got a deployment, ReplicaSet, and pod object. After a short
    while, which mainly depends on the time it takes to download the NGINX Docker
    image, the pod will be up and running, and the desired state will be equal to
    the current state!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期那样，我们得到了一个部署、ReplicaSet和pods对象。在短暂的时间后，这主要取决于下载NGINX Docker镜像所需的时间，pods将启动并运行，期望的状态将等于当前状态！
- en: 'Change the current state by deleting the pod with the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令删除pods来改变当前状态：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the pod has a random name (`nginx-deploy-59b8c5f7cd-mt6pg` in the preceding
    example), the pod is selected based on the `app` label, which is set to `nginx-app` in
    the pod.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于pods有一个随机名称（在前面的示例中为`nginx-deploy-59b8c5f7cd-mt6pg`），pods是基于设置为`nginx-app`的`app`标签来选择的。
- en: Running a subsequent `kubectl get all` command will reveal that the difference
    between the desired and current state was detected and handled by the ReplicaSet
    in just a few seconds, that is, a new pod was launched almost immediately.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行随后的`kubectl get all`命令将揭示ReplicaSet在几秒钟内检测到期望状态和当前状态之间的差异并处理，即几乎立即启动一个新的pods。
- en: Change the desired state by setting the number of desired pods to three replicas
    in the `kubernetes/first-attempts/nginx-deployment.yaml` deployment file. Apply
    the change in the desired state by simply repeating the `kubectl apply` command,
    as we mentioned previously.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`kubernetes/first-attempts/nginx-deployment.yaml`部署文件中将期望的pods数量设置为三个副本来改变期望状态。只需重复之前的`kubectl
    apply`命令，就可以将更改应用到期望的状态。
- en: 'Quickly run the `kubectl get all` command a couple of times to monitor how
    Kubernetes takes action to ensure that the current state meets the new desired
    state. After a few seconds, two new NGINX pods will be up and running. The desired
    state is, again, equal to the current state with three running NGINX pods. Expect
    a response that looks similar to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 快速运行几次`kubectl get all`命令，以监控Kubernetes如何采取行动确保当前状态满足新的期望状态。几秒钟后，将会有两个新的NGINX
    pod启动并运行。期望的状态再次等于具有三个运行中的NGINX pod的当前状态。期待看到的响应类似于以下内容：
- en: '![](img/45d803cd-745b-4d3f-9d25-79df6eadfeb1.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45d803cd-745b-4d3f-9d25-79df6eadfeb1.png)'
- en: 'To enable external communication with the web servers, create a service using
    the `kubernetes/first-attempts/nginx-service.yaml` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使外部通信能够与Web服务器通信，请使用`kubernetes/first-attempts/nginx-service.yaml`文件创建服务：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: The `kind` and `apiVersion` attributes are used to specify that we are declaring
    a `Service` object.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`和`apiVersion`属性用于指定我们正在声明一个`Service`对象。'
- en: The `metadata` section is used to describe the `Service` object, for example,
    to give it a name: `nginx-service`.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`部分用于描述`Service`对象，例如，给它一个名字：`nginx-service`。'
- en: 'Next comes a `spec` section, which defines the desired state of the `Service` object:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是`spec`部分，它定义了`Service`对象的期望状态：
- en: With the `type` field, we specify that we want `NodePort`, that is, something
    that's accessible externally on a dedicated port on each node in the cluster. This
    means that an external caller can reach the pods using this port on any of the
    nodes in the cluster, independent of which nodes the pods actually run on.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`type`字段，我们指定我们希望是`NodePort`，即在每个集群节点上的专用端口上可访问的外部服务。这意味着外部调用者可以使用这个端口访问集群中的任何节点的pods，而不依赖于pods实际运行在哪些节点上。
- en: 'The selector is used by the service to find available pods, which, in our case,
    is pods labeled with `app: nginx-app`.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '选择器由服务用来查找可用的pods，在我们的案例中，是标记有`app: nginx-app`的pods。'
- en: 'Finally, `ports` are declared as follows:'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`ports`如下声明：
- en: '`port: 80` specifies on which port the services will be accessible on, that
    is, internally in the cluster.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port: 80`指定服务将在哪个端口上内部可访问，即在集群内部。'
- en: '`nodePort: 30080` specifies on what port the service will be externally accessible
    on using any of the nodes in the cluster. By default, a node port must be in the
    range of `30000` to `32767`.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodePort: 30080`指定服务将在哪个端口上使用集群中的任何节点对外部可访问。默认情况下，节点端口必须在`30000`到`32767`的范围内。'
- en: '`targetPort: 80` specifies the port in the pod where the requests shall be
    forwarded to.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetPort: 80`指定请求将在哪个端口上转发到pods中。'
- en: This port range is used to minimize the risk of colliding with other ports in
    use. In a production system, a load balancer is typically placed in front of the
    Kubernetes cluster, shielding the external users both from the knowledge of these
    ports and the IP numbers of the nodes in the Kubernetes cluster. See [Chapter
    18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml), *Using a Service Mesh to Improve
    Observability and Management*, the *Setting up port forwarding required by Istio*
    section, for more on the usage of a `LoadBalanced` Kubernetes service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此端口范围用于最小化与其他正在使用的端口冲突的风险。在生产系统中，通常会在Kubernetes集群前放置一个负载均衡器，保护外部用户既不知道这些端口，也不知道Kubernetes集群中节点的IP地址。参见[第18章](422649a4-94bc-48ae-b92b-e3894c014962.xhtml)、*使用服务网格提高可观测性和管理*节的*设置Istio所需的端口转发*，了解有关`LoadBalanced`
    Kubernetes服务的使用。
- en: 'Create the service with the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建服务：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To see what we got, run the `kubectl get svc` command. Expect a response such
    as the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们得到了什么，运行`kubectl get svc`命令。期待如下的响应：
- en: '![](img/987abb3e-e317-4cb1-8169-63a163c2ac1c.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/987abb3e-e317-4cb1-8169-63a163c2ac1c.png)'
- en: '`kubectl` supports short names for many of the API objects as an alternative
    to their full name. For example, `svc` was used in the preceding command instead
    of the full name, `service`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`支持许多API对象的简称，作为其全名的替代。例如，在前面的命令中使用了`svc`而不是完整名称`service`。'
- en: 'To try this out, we need to know the IP address of the single node in our cluster.
    We can get that by issuing the `minikube ip` command. In my case, it is `192.168.99.116`.
    With this IP address and the node port `30080`, we can direct our web browser
    to the deployed web server. In my case, the address is `http://192.168.99.116:30080`.
    Expect a response such as the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个，我们需要知道我们集群中单个节点的 IP 地址。我们可以通过运行 `minikube ip` 命令来获取。在我的情况下，它是 `192.168.99.116`。使用这个
    IP 地址和节点端口 `30080`，我们可以将网页浏览器定向到部署的 Web 服务器。在我的情况下，地址是 `http://192.168.99.116:30080`。预期如下的响应：
- en: '![](img/2f710472-8b21-4b04-ba91-1496388ec643.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f710472-8b21-4b04-ba91-1496388ec643.png)'
- en: Great! But what about the internal cluster IP address and port?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！但是内部集群 IP 地址和端口又如何呢？
- en: One way to verify this is to launch a small pod inside the cluster that we can
    use to run `curl` from the inside, that is, we are able to use the internal cluster
    IP address and port. We don't need to use the IP address; instead, we can use
    a DNS name that is created for the service in the internal DNS server. The short
    name of the DNS name is the same as the name of the service, that is, `nginx-service`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的一种方法是，在集群内部启动一个小型 pod，我们可以用它从内部运行 `curl`，也就是说，我们能够使用集群内部的 IP 地址和端口。我们不需要使用
    IP 地址，相反，我们可以使用为服务在内部 DNS 服务器上创建的 DNS 名称。DNS 名称的短名称与服务的名称相同，即 `nginx-service`。
- en: 'Run the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding command looks a bit complex, but it will only do the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令看起来有点复杂，但它只会做以下事情：
- en: Create a pod with a small container based on the `tutum/curl:alpine` Docker
    image, which contains the `curl` command.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于 `tutum/curl:alpine` Docker 镜像创建一个小型容器，该镜像包含 `curl` 命令。
- en: Run the `curl -s 'http://nginx-service:80'` command inside the container and
    redirect the output to the Terminal using the `-i` option.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内运行 `curl -s 'http://nginx-service:80'` 命令，并使用 `-i` 选项将输出重定向到终端。
- en: Delete the pod using the `--rm` option.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `--rm` 选项删除 pod。
- en: 'Expect the output from the preceding command to contain the following information
    (we are only showing parts of the response here):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 预期前面命令的输出将包含以下信息（我们这里只展示了响应的一部分）：
- en: '![](img/da13fcf8-bed7-49e3-ac2a-5013a5d3621f.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da13fcf8-bed7-49e3-ac2a-5013a5d3621f.png)'
- en: This means that the web server is also accessible internally in the cluster!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Web 服务器也可以在集群内部访问！
- en: This is basically all we need to know to be able to deploy our system landscape.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们需要了解的，以便能够部署我们的系统架构。
- en: 'Wrap this up by removing the namespace containing the `nginx` deployment:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除包含 `nginx` 部署的命名空间来结束：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Before we end this introductory chapter on Kubernetes, we need to learn how
    to manage our Kubernetes cluster.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束关于 Kubernetes 的入门章节之前，我们需要学习如何管理我们的 Kubernetes 集群。
- en: Managing a Kubernetes cluster
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 Kubernetes 集群
- en: A running Kubernetes cluster consumes a lot of resources, mostly memory. So,
    when we are done working with a Kubernetes cluster in Minikube, we must be able
    to hibernate it in order to release the resources allocated to it. We also need
    to know how to resume the cluster when we want to continue working with it. Eventually,
    we must also be able to permanently remove the cluster when we don't want to keep
    it on disk anymore.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的 Kubernetes 集群会消耗大量资源，主要是内存。因此，当我们完成在 Minikube 中与 Kubernetes 集群的工作时，我们必须能够挂起它，以释放分配给它的资源。我们还需要知道如何恢复集群，当我们想继续工作时。最终，我们也必须能够永久删除集群，当我们不想再在磁盘上保留它时。
- en: Minikube comes with a `stop` command that can be used to hibernate a Kubernetes
    cluster. The `start` command we used to initially create the Kubernetes cluster
    can also be used to resume the cluster from its hibernated state. To permanently
    remove a cluster, we can use the `delete` command from Minikube.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 带有一个 `stop` 命令，可以用来挂起一个 Kubernetes 集群。我们用来最初创建 Kubernetes 集群的 `start`
    命令也可以用来从挂起状态恢复集群。要永久删除一个集群，我们可以使用 Minikube 的 `delete` 命令。
- en: Hibernating and resuming a Kubernetes cluster
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂起和恢复 Kubernetes 集群
- en: 'Run the following command to hibernate (that is, `stop`) the Kubernetes cluster:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来挂起（即 `stop`）Kubernetes 集群：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the following command to resume (that is, `start`) the Kubernetes cluster
    again:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来恢复（即 `start`）Kubernetes 集群：
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When resuming an already existing cluster, the `start` command ignores switches
    that were used when you were creating the cluster.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当恢复一个已经存在的集群时，`start` 命令会忽略你在创建集群时使用的开关。
- en: 'After resuming the Kubernetes cluster, the `kubectl` context will be updated
    to use this cluster with the currently used namespace set to `default`. If you
    are working with another namespace, for example, the `hands-on` namespace that
    we will use in the upcoming chapter, that is, [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml), *Deploying
    Our Microservices to Kubernetes*, you can update the `kubectl` context with the
    following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复 Kubernetes 集群后，`kubectl` 上下文将更新为使用此集群，当前使用的命名空间设置为 `default`。如果你正在使用另一个命名空间，例如我们将在下一章使用的
    `hands-on` 命名空间，即 [第 16 章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)，*将我们的微服务部署到
    Kubernetes*，你可以使用以下命令更新 `kubectl` 上下文：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Subsequent `kubectl` commands will be applied to the `hands-on` namespace when
    applicable.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的 `kubectl` 命令将在适用的情况下应用于 `hands-on` 命名空间。
- en: Terminating a Kubernetes cluster
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁 Kubernetes 集群
- en: 'Run the following command to terminate a Kubernetes cluster:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以终止 Kubernetes 集群：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can actually run the `delete` command without specifying the profile, but
    I find it safer to be explicit regarding the profile when it comes to the `delete`
    command. Otherwise, you may accidentally delete the wrong Kubernetes cluster!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以不指定配置文件运行 `delete` 命令，但我发现指明配置文件更安全。否则，你可能会意外地删除错误的 Kubernetes 集群！
- en: 'Neither the Minikube profile definition under `~/.minikube/profiles/` nor the
    `kubectl` context in `~/.kube/config` is deleted by this command. If they are
    no longer required, they can be deleted with the following commands:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'neither the Minikube profile definition under `~/.minikube/profiles/` nor the
    `kubectl` context in `~/.kube/config` is deleted by this command. If they are
    no longer required, they can be deleted with the following commands:'
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `kubectl config delete-context` command will warn you about deleting the
    active context, but that's okay.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl config delete-context` 命令会警告你关于删除活动上下文的内容，但是没关系。'
- en: We've successfully learned how to manage a Kubernetes cluster that runs in Minikube.
    We now know how to suspend and resume a cluster and, when no longer needed, we
    know how to permanently remove it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学会了如何管理在 Minikube 中运行的 Kubernetes 集群。我们现在知道如何挂起和恢复集群，当不再需要时，我们知道如何永久删除它。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have been introduced to Kubernetes as a container orchestrator.
    Kubernetes makes a cluster of servers that run containers appear as one big logical
    server. As an operator, we declare a desired state to the cluster and Kubernetes
    continuously compares the desired state with the current state. If it detects
    differences, it takes actions to ensure that the current state is the same as
    the desired state.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了 Kubernetes 作为容器编排器。Kubernetes 使得运行容器的集群服务器看起来像一个大的逻辑服务器。作为操作员，我们向集群声明一个期望状态，Kubernetes
    持续将期望状态与当前状态进行比较。如果它检测到差异，它将采取行动确保当前状态与期望状态相同。
- en: The desired state is declared by creating resources using the Kubernetes API
    server. The controller manager in Kubernetes and its controllers react to the
    various resources that were created by the API server and takes actions to ensure
    that the current state meets the new desired state. The scheduler assigns nodes
    to newly created containers, that is, pods that contain one or more containers.
    On each node, an agent, `kubelet`, runs and ensures that the pods that were scheduled
    to its node are up and running. `kube-proxy` acts as a network proxy, enabling
    a service abstraction by forwarding requests that are sent to the service to available
    pods in the cluster. External requests can be handled either by a service that
    specifies a node port that's available on all of the nodes in the cluster or through
    a dedicated Ingress resource.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的状态通过使用 Kubernetes API 服务器创建资源来声明。Kubernetes 控制器管理器和其控制器对由 API 服务器创建的各种资源做出反应，并采取行动确保当前状态满足新的期望状态。调度器为新生成的容器分配节点，即包含一个或多个容器的
    pod。在每个节点上，都有一个代理，`kubelet` 运行并确保调度到其节点的 pod 正在运行。`kube-proxy` 充当网络代理，通过将发送到服务的请求转发到集群中可用的
    pod，实现服务抽象。外部请求可以由指定节点上可用的节点端口的服务处理，或者通过专用的 Ingress 资源处理。
- en: We have also tried out Kubernetes by creating a local single-node cluster using
    Minikube and VirtualBox. Using the Kubernetes CLI tool known as `kubectl`, we
    deployed a simple web server based on NGINX. We tried out resilience capabilities
    by deleting the web server, and we observed it being recreated automatically and
    scaled it by requesting three pods running on the web server. Finally, we created
    a service with a node port and verified that we could access it both externally
    and from the inside of the cluster.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过使用 Minikube 和 VirtualBox 创建了一个本地单节点集群来尝试 Kubernetes。使用名为 `kubectl` 的 Kubernetes
    CLI 工具，我们部署了一个基于 NGINX 的简单 Web 服务器。我们通过删除 Web 服务器来尝试弹性能力，并观察它自动重建以及通过请求在 Web 服务器上运行三个
    Pod 来扩展它。最后，我们创建了一个具有节点端口的服务的服务，并验证了我们可以从集群内外访问它。
- en: Finally, we learned how to manage a Kubernetes cluster running in Minikube on
    VirtualBox in terms of how to hibernate, resume, and terminate a Kubernetes cluster.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学会了如何管理在 VirtualBox 上运行的 Minikube 中的 Kubernetes 集群，包括如何休眠、恢复和终止 Kubernetes
    集群。
- en: We are now ready to deploy our system landscape from the earlier chapters in
    Kubernetes. Head over to the next chapter to find out how to do this!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备将前面章节中的系统架构部署到 Kubernetes 中。翻到下一章，了解如何进行部署！
- en: Questions
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What happens if you run the same `kubectl create` command twice?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你两次运行相同的 `kubectl create` 命令会发生什么？
- en: What happens if you run the same `kubectl apply` command twice?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你两次运行相同的 `kubectl apply` 命令会发生什么？
- en: In terms of questions *1* and *2*, why do they act differently the second time
    they are run?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于问题 *1* 和 *2*，为什么它们第二次运行时行为不同？
- en: What is the purpose of a ReplicaSet, and what other resource creates a ReplicaSet?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReplicaSet 的目的是什么，还有哪些资源会创建 ReplicaSet？
- en: What is the purpose of `etcd` in a Kubernetes cluster?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中 `etcd` 的作用是什么？
- en: How can a container find out the IP address of another container that runs in
    the same pod?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器如何找出同一 Pod 中运行的另一容器的 IP 地址？
- en: What happens if you create two deployments with the same name but in different
    namespaces?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你创建了两个名称相同但在不同命名空间中的部署会发生什么？
- en: What can you make the creation of two services with the same name fail if they
    are created in two different namespaces?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在两个不同的命名空间中创建了两个名称相同的服务，你会使得这两个服务的创建失败。
