- en: Containerizing Your Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序容器化
- en: Containers are becoming one of the key factors of software development, changing
    the way that developers are writing and deploying IT systems. These are mainly
    used to solve problems related to setup environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器正在成为软件开发的关键因素之一，改变了开发人员编写和部署IT系统的方式。主要用于解决与设置环境相关的问题。
- en: 'Working with containers can be overwhelming when you have to manage multiple
    containers and multi-instance environments. However, some really cool tools have
    been released that are designed to accomplish these container orchestration tasks.
    We are going to look at these tools throughout this chapter, along with the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要管理多个容器和多实例环境时，使用容器可能会让人感到不知所措。然而，一些非常酷的工具已经发布，旨在完成这些容器编排任务。在本章中，我们将一起看看这些工具，以及以下主题：
- en: '**Containers**:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：'
- en: Basic concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本概念
- en: Basic commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本命令
- en: Building your own images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你自己的镜像
- en: '**Containerizing Applications**: Docker Gradle plugin'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器化应用程序**：Docker Gradle插件'
- en: '**Registries**: Publishing images'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册表**：发布镜像'
- en: '**Provisioning multiple-container environments**: Docker Compose'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置多容器环境**：Docker Compose'
- en: '**Container orchestration with Kubernetes**:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Kubernetes进行容器编排**：'
- en: Pods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pods
- en: Labels
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Replication controllers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制控制器
- en: Services
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Containers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: 'Containers provide a lightweight approach to virtualization that consists of
    providing the bare minimum that an application requires in order to work. In the
    old days, VMs used to be the main choice for provisioning environments and running
    applications. However, they require a complete OS in order to work. Containers,
    on the other hand, reuse the host OS to run and provision the required environments.
    Let''s learn more about this concept by looking at the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供了一种轻量级的虚拟化方法，它提供了应用程序运行所需的最低限度。在过去，虚拟机曾经是设置环境和运行应用程序的主要选择。然而，它们需要完整的操作系统才能工作。另一方面，容器重用主机操作系统来运行和配置所需的环境。让我们通过查看下图来更多地了解这个概念：
- en: '![](img/efbb30f8-49cd-4d73-b325-67db986da2ca.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efbb30f8-49cd-4d73-b325-67db986da2ca.png)'
- en: Virtual machines and containers
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机和容器
- en: In the preceding diagram, we can see the **Virtual Machines** (**VMs**) on the
    left side and the **containers** on the right side. Let's start by learning how
    a Vm works.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到左侧是**虚拟机**（**VMs**），右侧是**容器**。让我们从学习虚拟机是如何工作开始。
- en: VMs require their own OS using the hardware assigned to the VM, which is supported
    by the hypervisor. The preceding diagram shows three VMs, which means that we
    need to have installed three OSes, one per VM. When you're running applications
    within VMs, you have to consider the resources that will be consumed by the application
    and the OS.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机需要使用分配给虚拟机的硬件的自己的操作系统，这由hypervisor支持。上图显示了三个虚拟机，这意味着我们需要安装三个操作系统，每个虚拟机一个。当你在虚拟机中运行应用程序时，你必须考虑应用程序和操作系统将消耗的资源。
- en: On the other hand, containers use the kernel provided by the OS host, which
    also supplies the basic services for all containers using virtual-memory support
    for isolation. In this case, there is no need to install a whole OS for each container;
    this is an effective approach in terms of memory and storage usage. When you're
    running applications using containers, you only have to consider the resources
    consumed by the application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，容器使用主机操作系统提供的内核，还使用虚拟内存支持来隔离所有容器的基本服务。在这种情况下，不需要为每个容器安装整个操作系统；这是一种在内存和存储使用方面非常有效的方法。当你使用容器运行应用程序时，你只需要考虑应用程序消耗的资源。
- en: Containers are small and can be measured in tens of megabytes, taking only a
    few seconds to be provisioned. In contrast, VMs are measured in tens of gigabytes,
    but they can take a few minutes to even start working. You should also consider
    OS licensing—when you're using VMs, you'll have to pay for the licenses of each
    installed OS. When using containers, you only need one OS that all the containers
    will use to function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 容器体积小，可以用几十兆来衡量，只需要几秒钟就可以被配置。相比之下，虚拟机的体积以几十GB来衡量，但它们甚至需要几分钟才能开始工作。你还需要考虑操作系统许可证费用——当你使用虚拟机时，你必须为每个安装的操作系统付费。使用容器时，你只需要一个操作系统，所有容器都将使用它来运行。
- en: There are different containers currently available on the market, but Docker
    is the most popular implementation these days. For this reason, we are going to
    choose this option to explain all the concepts in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上目前有不同的容器可用，但Docker是目前最流行的实现。因此，我们将选择这个选项来解释本章中的所有概念。
- en: Basic concepts
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本概念
- en: In this section, we are going to review some basic concepts and commands that
    you'll commonly use on a daily basis. This should help you to understand the rest
    of this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些基本概念和命令，这些命令你在日常使用中会经常用到。这应该有助于你理解本章的其余内容。
- en: Containers and images
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和镜像
- en: 'When talking about Docker, people often use the terms *containers* and *images*.
    The difference between these two terms is simple: a container is an instance of
    an image, while an image is an immutable file that''s essentially a snapshot of
    a container. In terms of **object-oriented programming** (**OOP**), we can say
    that images are like classes and containers are instances of these classes. For
    example, let''s say you have a Docker image that is comprised of CentOS and Java
    8\. Using this image, you can create a container to run a Spring Boot application
    and another container to run a JEE application, as shown in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到Docker时，人们经常使用*容器*和*镜像*这两个术语。这两个术语之间的区别很简单：容器是镜像的一个实例，而镜像是一个不可变的文件，本质上是容器的快照。从**面向对象编程**（**OOP**）的角度来看，我们可以说镜像就像类，容器是这些类的实例。例如，假设你有一个由CentOS和Java
    8组成的Docker镜像。使用这个镜像，你可以创建一个容器来运行一个Spring Boot应用程序，另一个容器来运行一个JEE应用程序，如下图所示：
- en: '![](img/1c98cbae-61e1-45f2-9857-9b537399823a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c98cbae-61e1-45f2-9857-9b537399823a.png)'
- en: Docker images and containers
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像和容器
- en: Basic commands
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本命令
- en: Docker has a large set of commands to execute different operations using containers
    and images. However, there is no need to be familiar with all of them. We will
    now review some of the most common commands that you need to know in order to
    work with Docker.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有一大堆命令来执行使用容器和镜像的不同操作。然而，并不需要熟悉所有这些命令。我们现在将回顾一些你需要了解的最常用的命令。
- en: Running containers
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器
- en: 'We mentioned earlier that containers are instances of images. When you want
    to run a Docker container, you can use the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，容器是镜像的实例。当你想要运行一个Docker容器时，你可以使用以下命令：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are plenty of Docker images available on the internet. Before creating
    a custom image, you should first review the list of images available on Docker
    Hub ([https://hub.docker.com/](https://hub.docker.com/)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有大量的Docker镜像可用。在创建自定义镜像之前，你应该首先查看Docker Hub上可用的镜像列表（[https://hub.docker.com/](https://hub.docker.com/)）。
- en: Docker Hub is a cloud-based registry service that allows you to link to code
    repositories, build your images, and test them. It also stores manually pushed
    images and links to Docker Cloud so that you can deploy images to your hosts.
    Docker Hub provides a centralized resource for container and image discovery,
    distribution, and change management; user and team collaboration; and workflow
    automation throughout the development pipeline.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub是一个基于云的注册服务，允许你链接到代码仓库，构建你的镜像并对其进行测试。它还存储手动推送的镜像，并链接到Docker Cloud，以便你可以将镜像部署到你的主机上。Docker
    Hub为容器和镜像的发现、分发和变更管理；用户和团队协作；以及整个开发流程中的工作流自动化提供了一个集中的资源。
- en: 'Let''s say that you want to run a container using `nginx`. In this case, all
    that you need to do is execute the following command in the Terminal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你想要使用`nginx`运行一个容器。在这种情况下，你只需要在终端中执行以下命令：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you run this command, Docker will try to find the image locally. If it''s
    unable to find it there, it will look for the image using all the registries available
    (we will talk about registries later on). In our case, this is Docker Hub. The
    first thing you should see in the terminal is an output similar to the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个命令后，Docker将尝试在本地找到镜像。如果它找不到，它将在所有可用的注册表中查找镜像（我们稍后会谈论注册表）。在我们的情况下，这是Docker
    Hub。你在终端中应该看到的第一件事是类似于以下内容的输出：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After executing this operation, you will get a string similar to `d38bbaffa51cdd360761d0f919f924be3568fd96d7c9a80e7122db637cb8f374` that
    represents the image ID.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个操作后，你将得到一个类似于`d38bbaffa51cdd360761d0f919f924be3568fd96d7c9a80e7122db637cb8f374`的字符串，它代表了镜像ID。
- en: 'Some useful flags for running containers are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用于运行容器的有用标志如下：
- en: The `-d` flag runs the image as a daemon
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`标志将镜像作为守护进程运行'
- en: The `-p` flag connects the image ports to the host
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`标志将镜像端口连接到主机'
- en: 'For example, the following command makes it possible to run `nginx` as a daemon
    and maps port `80` from the container to port `32888` on the host:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下命令可以让你将`nginx`作为守护进程运行，并将容器的端口`80`映射到主机的端口`32888`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now you will have control of the terminal again, and you can see the `nginx` homepage
    in the `http://localhost:32888/` URL, as shown in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将再次控制终端，并且你可以在`http://localhost:32888/`URL中看到`nginx`的主页，如下截图所示：
- en: '![](img/17afc51c-8e5b-4a5d-9f68-ef64d827257a.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17afc51c-8e5b-4a5d-9f68-ef64d827257a.png)'
- en: Nginx homepage
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx主页
- en: 'Containers only have the software and services that are strictly necessary for
    them to work, which is why you''ll find that they don''t even include an SSH entry.
    If you want to get into a container, you can use the `-it` flag, which executes
    a command within the container as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 容器只包含软件和服务，这些软件和服务对它们的工作是绝对必要的，这就是为什么你会发现它们甚至不包括SSH入口。如果你想进入一个容器，你可以使用`-it`标志，在容器内执行命令如下：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Working with containers
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器
- en: 'If you are interested in checking all the containers running on your host,
    you can use the `ps` command as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣检查主机上运行的所有容器，你可以使用以下`ps`命令：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding command will list all the containers running on your host. If
    you also want to check the images that are not running, you can use the `-a` flag.
    After executing the preceding command, you''ll have an output in your terminal
    similar to the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令将列出主机上运行的所有容器。如果你还想检查那些没有运行的镜像，你可以使用`-a`标志。执行上面的命令后，你将在终端中得到一个类似于以下截图的输出：
- en: '![](img/2483fdc5-fbe5-4f4f-9d8a-578119d6b16f.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2483fdc5-fbe5-4f4f-9d8a-578119d6b16f.png)'
- en: The Docker ps command output
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Docker ps命令输出
- en: 'The first column of the preceding screenshot explains the information in the
    following list. The most useful part of this output is the CONTAINER ID**,** which
    can be used to perform the following operations:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图的第一列解释了以下列表中的信息。这个输出中最有用的部分是CONTAINER ID，它可以用来执行以下操作：
- en: 'Restart the container:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动容器：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Stop the container:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止容器：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Start the container:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动容器：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Remove the container:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除容器：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These are the most common commands, and they provide all that you need in order
    to start working with Docker containers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最常用的命令，它们提供了你在使用Docker容器时所需要的一切。
- en: Working with images
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用镜像
- en: 'Docker also has some commands that allow your system to work with images. The
    most commonly used commands are the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还有一些命令，允许你的系统与镜像一起工作。最常用的命令如下：
- en: 'Listing all the images available on the host:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出主机上所有可用的镜像：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Removing images:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除镜像：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Downloading images:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载镜像：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Building your own images
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你自己的镜像
- en: On the internet, we can find many Docker images that are ready to use. These
    images are created using a configuration file called the Dockerfile, which has
    all the instructions for provisioning the container.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，我们可以找到许多准备好使用的Docker镜像。这些镜像是使用一个名为Dockerfile的配置文件创建的，它包含了为容器进行配置的所有指令。
- en: 'The common commands that you will find as part of this file are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个文件的一部分，你会发现以下常用命令：
- en: '`FROM`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`'
- en: '`MAINTAINER`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAINTAINER`'
- en: '`RUN`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`'
- en: '`ENV`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`'
- en: '`EXPOSE`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`'
- en: '`CMD`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`'
- en: Let's review all of these commands one by one in order to understand how they
    work.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个审查所有这些命令，以了解它们的工作原理。
- en: FROM command
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FROM命令
- en: 'The `FROM` command is used to specify the base Docker image that will be used
    by the Dockerfile to build the new image. For example, if you want to create a
    custom image based on Debian, you should add the following line as part of your
    file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`命令用于指定Dockerfile将用于构建新镜像的基础Docker镜像。例如，如果您想基于Debian创建自定义镜像，您应该在文件中添加以下行：'
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: MAINTAINER command
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAINTAINER命令
- en: 'The `MAINTAINER` command is used entirely for documentation purposes, and this
    has the Dockerfile''s author name, as well as their email, as shown in the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAINTAINER`命令完全用于文档目的，其中包含了Dockerfile的作者姓名以及他们的电子邮件，如下所示：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: RUN command
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RUN命令
- en: 'A Dockerfile usually has more than one `RUN` command as part of it. These are
    intended to be executed as part of the system bash commands and are mainly used
    to install packages. For example, the following `RUN` command is used to install
    Java 8:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile通常有多个`RUN`命令作为其一部分。这些命令旨在作为系统bash命令的一部分执行，并主要用于安装软件包。例如，以下`RUN`命令用于安装Java
    8：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding command was taken from the Dockerfile provided by an image called
    `oracle-java8` ([https://github.com/dockerfile/java/blob/master/oracle-java8/Dockerfile](https://github.com/dockerfile/java/blob/master/oracle-java8/Dockerfile)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令取自名为`oracle-java8`的镜像提供的Dockerfile（[https://github.com/dockerfile/java/blob/master/oracle-java8/Dockerfile](https://github.com/dockerfile/java/blob/master/oracle-java8/Dockerfile)）。
- en: This command is easy to read, and each line describes how the installation process
    is done. The last two lines remove some directories from the container because
    they are no longer needed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令很容易阅读，每一行描述了安装过程是如何进行的。最后两行从容器中删除了一些不再需要的目录。
- en: All installations are done as a single line because every `RUN` command generates
    a new layer. For example, in the `RUN` command, we can see that six instructions
    are executed at once. If we run those instructions one by one, we will end up
    having six images, each of which contains the base image plus the `RUN` command
    that was executed. We will not discuss layers in detail in this book, but if you
    feel curious, I highly encourage you to read about them at [https://docs.docker.com/storage/storagedriver/#images-and-layers](https://docs.docker.com/storage/storagedriver/#images-and-layers).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有安装都是作为单行完成的，因为每个`RUN`命令生成一个新的层。例如，在`RUN`命令中，我们可以看到一次执行了六条指令。如果我们逐条运行这些指令，最终会得到六个镜像，每个镜像都包含了基础镜像以及执行的`RUN`命令。我们不会在本书中详细讨论层，但如果您感到好奇，我强烈鼓励您阅读有关它们的内容：[https://docs.docker.com/storage/storagedriver/#images-and-layers](https://docs.docker.com/storage/storagedriver/#images-and-layers)。
- en: ENV command
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENV命令
- en: 'The `ENV` command is used to create environmental variables in the system.
    The following `ENV` command is used as part of the previously mentioned Dockerfile
    in order to define the `JAVA_HOME `variable:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`命令用于在系统中创建环境变量。以下`ENV`命令作为前面提到的Dockerfile的一部分，用于定义`JAVA_HOME`变量：'
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: EXPOSE command
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EXPOSE命令
- en: 'The `EXPOSE` command defines which ports we are going to expose from the container.
    For example, if you want to expose ports `80` and `32777`, you need to add the
    following line to your Dockerfile:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`命令定义了我们将从容器中公开的端口。例如，如果您想公开端口`80`和`32777`，您需要在Dockerfile中添加以下行：'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: CMD command
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMD命令
- en: 'The `CMD` command is used to specify which command should be executed once
    the container is started. For example, if you want to run a Java application using
    the standard `java -jar` command, you will need to add the following line to the
    file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`命令用于指定容器启动后应执行的命令。例如，如果要使用标准的`java -jar`命令运行Java应用程序，需要在文件中添加以下行：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you have completed your Dockerfile, you should run the `build` command
    to create the image locally, as shown in the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完成Dockerfile后，应该运行`build`命令在本地创建镜像，如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Containerizing applications
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化应用程序
- en: A dockerized application is a basic deployable unit that can be integrated later
    as part of your whole ecosystem of applications. When you're dockerizing your
    application, you'll have to create your own Dockerfile with all the required instructions
    to make your application work.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个docker化的应用程序是一个基本的可部署单元，可以作为整个应用程序生态系统的一部分进行集成。当您将应用程序docker化时，您将不得不创建自己的Dockerfile，并包含所有必需的指令来使您的应用程序工作。
- en: As we mentioned in the last section, we can create a container using an existing
    base image with the `FROM` command. You can also copy the Dockerfile content of
    the base image, but this practice is highly discouraged because it does not make
    sense to duplicate the code that was already written when the image was created.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到，可以使用`FROM`命令使用现有的基础镜像创建一个容器。您还可以复制基础镜像的Dockerfile内容，但这种做法是不鼓励的，因为在创建镜像时已经编写了代码，复制代码是没有意义的。
- en: It is strongly recommended that you find official images in DockerHub. Since
    the Dockerfile is available, you should always read it in order to avoid security
    issues and fully understand how the image works.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您在DockerHub中找到官方镜像。由于Dockerfile可用，您应该始终阅读它以避免安全问题，并充分了解镜像的工作原理。
- en: Before dockerizing an application, it is important that you make your system
    use environmental variables instead of configuration files. In this way, you can
    create images that can be reused by other applications. One of the biggest advantages
    of using Spring Framework is the ability to use different approaches to configure
    your applications. This is something that we did in [Chapter 8](7c38500a-5a66-422b-a41b-21f4fd18de51.xhtml),
    *Microservices**, *when we used a configuration server to centralize all the application
    configurations. Spring makes it possible for us to use a local configuration file
    as part of our application, and we can override those configuration values using
    environment variables later.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用程序docker化之前，重要的是要使系统使用环境变量而不是配置文件。这样，您可以创建可以被其他应用程序重用的镜像。使用Spring Framework的最大优势之一是能够使用不同的方法来配置您的应用程序。这是我们在[第8章](7c38500a-5a66-422b-a41b-21f4fd18de51.xhtml)中所做的，*微服务*，当时我们使用配置服务器来集中所有应用程序配置。Spring使我们能够使用本地配置文件作为应用程序的一部分，并且我们可以稍后使用环境变量覆盖这些配置值。
- en: Now let's look at how to dockerize a Spring Boot application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何将Spring Boot应用程序docker化。
- en: 'In the first step, we will create the Dockerfile to run our application. The
    content of this file is shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们将创建Dockerfile来运行我们的应用程序。该文件的内容如下所示：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s briefly review the commands listed in the Dockerfile:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下Dockerfile中列出的命令：
- en: '| **Command** | **Description** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| `FROM java:8` | The base `java:8` image is used |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `FROM java:8` | 使用基本的`java:8`镜像 |'
- en: '| `WORKDIR` | Default directory within the image filesystem |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `WORKDIR` | 镜像文件系统中的默认目录 |'
- en: '| `ARG` | We are going to use an argument for the JAR file |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `ARG` | 我们将使用一个参数来指定JAR文件 |'
- en: '| `COPY` | The provided file will be copied inside the container as `app.jar`
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `COPY` | 提供的文件将被复制到容器中作为`app.jar` |'
- en: '| `EXPOSE` | Port 8080 of the container is exposed |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `EXPOSE` | 容器的端口8080被暴露 |'
- en: '| `ENTRYPOINT` | Run the Java application inside the container |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRYPOINT` | 在容器内运行Java应用程序 |'
- en: 'This Dockerfile should be located in the root of the project. The following
    screenshot shows the project layout:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile应该位于项目的根目录。以下截图显示了项目的布局：
- en: '![](img/141a309e-e383-4ccb-9b89-c71f6836b836.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/141a309e-e383-4ccb-9b89-c71f6836b836.png)'
- en: Project layout
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 项目布局
- en: 'The application JAR is located under the `PROJECT/build/libs` directory. This
    artifact is generated by running the `bootRepackage` task using the Gradle wrapper,
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序JAR位于`PROJECT/build/libs`目录下。通过使用Gradle wrapper运行`bootRepackage`任务生成此构件，如下所示：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the artifact has been created, it''s time to create the Docker image by
    running the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构件被创建，就该是时候通过运行以下命令来创建Docker镜像了：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the command has finished, the image should exist locally. You can check
    this by running the `docker images` command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令完成，镜像应该存在于本地。您可以通过运行`docker images`命令来检查：
- en: '![](img/d7b2c033-fc34-4564-a8ae-af112d207844.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7b2c033-fc34-4564-a8ae-af112d207844.png)'
- en: Docker images console output
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像控制台输出
- en: 'Note that the `java` image is also present. This was downloaded during the
    `spring-boot` image build process. We can then create a container using the recently
    created image by running the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`java`镜像也存在。这是在`spring-boot`镜像构建过程中下载的。然后，我们可以通过运行以下命令创建一个使用最近创建的镜像的容器：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can now visit the application deployed in the container in the `http://localhost:8081/index `URL.
    The following screenshot shows this application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以访问部署在容器中的应用程序，网址为`http://localhost:8081/index`。以下截图显示了这个应用程序：
- en: '![](img/4a077f67-7dce-4056-be8e-67ba79b15389.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a077f67-7dce-4056-be8e-67ba79b15389.png)'
- en: Application deployed in the container
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序部署在容器中
- en: The build process for the image can and should be automated using your preferred
    build tool. There are plugins for Gradle and Maven that can be integrated as part
    of your application. Let's look at how to integrate a Gradle plugin for this task.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的构建过程可以并且应该使用您喜欢的构建工具进行自动化。Gradle和Maven都有插件可以作为应用程序的一部分集成。让我们看看如何为这个任务集成Gradle插件。
- en: Docker Gradle plugin
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Gradle插件
- en: Even when generating a Docker image, using Docker commands is not hard or complex;
    it's always a good idea to automate all of these steps as much as we can. The
    Docker Gradle plugin is pretty useful for accomplishing this task. Let's learn
    how to make this part of our application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 即使生成Docker镜像时，使用Docker命令并不难或复杂；尽可能自动化所有这些步骤总是一个好主意。Docker Gradle插件非常有用，可以完成这个任务。让我们学习如何将其作为应用程序的一部分。
- en: 'First of all, we need to include the repository that contains the plugin and
    the plugin itself as a dependency within the `buildscript` section, as shown in
    the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`buildscript`部分内包含包含插件的仓库和插件本身作为依赖项，如下所示：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Later, the plugin should be applied to the project in the same way as any other
    plugin—using its ID. This is shown in the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，插件应该以与任何其他插件相同的方式应用到项目中——使用其ID。这在以下代码中显示：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The image build process can be customized using the parameters described in
    the official documentation at [https://github.com/palantir/gradle-docker](https://github.com/palantir/gradle-docker).
    To keep things simple, we are only going to indicate the image name that is required
    within a `docker` block, as shown in the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用官方文档中描述的参数来自定义镜像构建过程，网址为[https://github.com/palantir/gradle-docker](https://github.com/palantir/gradle-docker)。为了简化，我们只会在`docker`块中指定所需的镜像名称，如下所示：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you may have noticed, we are now using the variables that are available in
    the `build.gradle` file, such as the generated JAR name and its version.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的那样，我们现在正在使用`build.gradle`文件中可用的变量，比如生成的JAR名称及其版本。
- en: 'Now that the plugin has been fully integrated within the project, you can build
    the image by running the following Gradle task:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件已经完全集成到项目中，您可以通过运行以下Gradle任务来构建镜像：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can also check the recently created image, as shown in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查最近创建的镜像，如下屏幕截图所示：
- en: '![](img/123cf284-aece-4007-864b-8f9c63cd0fbc.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/123cf284-aece-4007-864b-8f9c63cd0fbc.png)'
- en: The docker images console output
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: docker镜像控制台输出
- en: It is a good idea to have all of these steps automated as this provides free documentation
    that can be improved in the future if needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些步骤自动化是个好主意，因为这提供了可以在将来改进的免费文档。
- en: Registries
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册表
- en: As we have seen, Docker helps us to reproduce the setup used to deploy an application,
    but it also helps us to distribute the application to be used in different environments.
    This task can be performed using registries.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Docker帮助我们复制用于部署应用程序的设置，但它也帮助我们分发应用程序以在不同环境中使用。可以使用注册表执行此任务。
- en: 'A registry is a service that is responsible for hosting and distributing Docker
    images. The default registry used by Docker is Docker Hub. There are other options
    available on the market that can be used as Docker registries, including the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表是负责托管和分发Docker镜像的服务。Docker使用的默认注册表是Docker Hub。市场上还有其他可用作Docker注册表的选项，包括以下内容：
- en: Quay
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quay
- en: Google Container Registry
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google容器注册表
- en: AWS Container Registry
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS容器注册表
- en: Docker Hub is really popular because it works in ways that you do not even notice.
    For instance, if you're creating a container and the image doesn't exist in your
    local repository, it will automatically download the image from Docker Hub. All
    the existing images are created by someone else and published in these registries.
    In the same way, we can publish our own images in order to make them available
    to other people within an organization by using private repositories. Alternatively,
    you can publish them in public repositories. You can also self-host a Docker registry
    on your own hardware using solutions such as Nexus, JFrog, and so on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub非常受欢迎，因为它以您甚至都没有注意到的方式工作。例如，如果您正在创建一个容器，而本地存储库中不存在该镜像，它将自动从Docker
    Hub下载该镜像。所有现有的镜像都是由其他人创建并发布在这些注册表中。同样，我们可以发布我们自己的镜像，以便通过私有存储库使其对组织内的其他人可用。或者，您也可以将它们发布在公共存储库中。您还可以使用诸如Nexus、JFrog等解决方案在自己的硬件上自行托管Docker注册表。
- en: Docker Hub has a free plan that allows you to create an unlimited number of
    public repositories and one private repository. It also offers another plan that
    enables you to have more private repositories, if necessary. We use Docker Hub
    for Docker in the same way that we use GitHub for Git repositories.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub有一个免费计划，允许您创建无限数量的公共存储库和一个私有存储库。如果需要，它还提供另一个计划，可以让您拥有更多的私有存储库。我们使用Docker
    Hub来处理Docker，就像我们使用GitHub来处理Git存储库一样。
- en: Publishing images
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布镜像
- en: 'In order to publish a Docker image in Docker Hub, you will need to create an
    account and then log into Docker Hub using the terminal with the `docker login`
    command. After entering your credentials, you should see an output similar to
    the following code in the terminal:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Docker Hub中发布Docker镜像，您需要创建一个帐户，然后使用终端和`docker login`命令登录Docker Hub。输入凭据后，您应该在终端中看到类似以下代码的输出：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that you''re logged in, you can push the image into the registry using
    the `docker push` command, as shown in the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已登录，可以使用`docker push`命令将镜像推送到注册表，如下代码所示：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the tag version is not specified, the `latest `value is used by default.
    In our case, a pretty small change should be applied to the `build.gradle` file
    to append the `docker-hub-username` prefix required by Docker Hub, as shown in
    the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当未指定标签版本时，默认使用`latest`值。在我们的情况下，应该对`build.gradle`文件进行一些小的更改，以附加Docker Hub所需的`docker-hub-username`前缀，如下代码所示：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After generating the image again, you should log into Docker Hub from the terminal
    using the `docker login` command, and the image can be pushed later, as shown
    in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 再次生成镜像后，您应该使用`docker login`命令从终端登录Docker Hub，稍后可以推送镜像，如下代码所示：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once the image has been pushed, you can pull it and run a container in any
    other computer by typing the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像推送后，您可以通过输入以下命令在任何其他计算机上拉取并运行容器：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will download the image from Docker Hub and run the application locally.
    In the same way, we can repeat this process to deploy an application in any environment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从Docker Hub下载镜像并在本地运行应用程序。同样，我们可以重复此过程在任何其他计算机上部署应用程序。
- en: 'The following screenshot shows how the pushed image looks on Docker Hub:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在Docker Hub上推送的镜像的外观：
- en: '![](img/3ba70773-de9d-4ab6-bdd4-aa42efdec445.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ba70773-de9d-4ab6-bdd4-aa42efdec445.png)'
- en: Docker image pushed into Docker Hub
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像推送到Docker Hub
- en: The `push` command should be automated using continuous integration servers.
    A good idea is to execute this command once a branch is merged into a `master` tag
    or a new tag is created in the version control system. You should always avoid
    using the default `latest` tag value. Instead, you should create version numbers
    by yourself using an automatic process, as we did using the Gradle plugin in the
    previous section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用持续集成服务器自动化`push`命令。一个好主意是在分支合并到`master`标签或在版本控制系统中创建新标签时执行此命令。您应该始终避免使用默认的`latest`标签值。相反，您应该使用自动过程自己创建版本号，就像我们在上一节中使用Gradle插件所做的那样。
- en: The integrated plugin also has the ability to push images using the `dockerPush`
    Gradle task.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 集成插件还具有使用`dockerPush` Gradle任务推送镜像的功能。
- en: Provisioning multiple-container environments
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多容器环境进行配置
- en: 'One of the biggest problems that we have when we are working with distributed
    applications is the difficulty of provisioning all the dependencies that an application
    needs in order to work. For example, let''s say that you''re working on an application
    that is persisting information in a MySQL database and using RabbitMQ for sending
    messages, as shown in the following diagram:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用分布式应用程序时，我们面临的最大问题之一是难以提供应用程序工作所需的所有依赖关系。例如，假设您正在开发一个将信息存储在MySQL数据库中并使用RabbitMQ发送消息的应用程序，如下图所示：
- en: '![](img/e15db607-8afa-403e-b7c1-656a45b83ef9.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e15db607-8afa-403e-b7c1-656a45b83ef9.png)'
- en: Application with RabbitMQ and MySQL dependencies
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 具有RabbitMQ和MySQL依赖项的应用程序
- en: In this case, all the developers on the team will need to install MySQL and
    RabbitMQ on their computers if they want to have the whole environment working
    locally.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果团队中的所有开发人员都希望在本地使整个环境工作，他们都需要在他们的计算机上安装MySQL和RabbitMQ。
- en: Installing a couple of tools is not so difficult, but as soon as your application
    begins to have more and more dependencies, this task becomes a nightmare. This
    is the exact problem that Docker Compose addresses.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 安装一些工具并不难，但一旦您的应用程序开始有越来越多的依赖关系，这项任务就变成了一场噩梦。这正是Docker Compose要解决的问题。
- en: Docker Compose
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Docker Compose is a tool which lets you define and execute multiple-container
    Docker environments. This means that every dependency in your application will
    be containerized and managed by this tool. Docker Compose was born as an independent
    open source project called **FIG** that was later integrated as part of the Docker
    family. At present, the latest Compose version is 2.4.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是一个工具，它允许您定义和执行多容器Docker环境。这意味着您应用程序中的每个依赖都将被容器化并由此工具管理。Docker
    Compose诞生于一个名为**FIG**的独立开源项目，后来作为Docker家族的一部分进行了整合。目前，最新的Compose版本是2.4。
- en: 'In the preceding example, you need a couple of extra services running: MySQL
    and RabbitMQ.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，您需要运行一些额外的服务：MySQL和RabbitMQ。
- en: When using Docker Compose, instead of installing the aforementioned services
    one by one, you'll able to build your application services in a `docker-compose.yaml`
    file, and then start and stop all of these services using this configuration file.
    This configuration file uses a YAML syntax that makes it easy to understand.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose时，您可以在`docker-compose.yaml`文件中构建应用程序服务，然后使用此配置文件启动和停止所有这些服务，而不是逐个安装上述服务。这个配置文件使用了易于理解的YAML语法。
- en: 'The content of the required configuration file to get RabbitMQ and MySQL services up
    and running locally is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 获取RabbitMQ和MySQL服务在本地运行所需的配置文件内容如下：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the same way, we can keep adding as many services as we want within the
    configuration file. The use case of the `docker-compose.yaml` file is self-explanatory,
    and it''s worth mentioning that this file has specific configurations that are
    not defined within the Dockerfile, such as port mapping. Running this file is
    not difficult at all: you only have to use the `up` command from Docker Compose,
    as shown in the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在配置文件中添加尽可能多的服务。`docker-compose.yaml`文件的用例是不言自明的，值得一提的是，该文件具有特定的配置，这些配置在Dockerfile中没有定义，比如端口映射。运行这个文件并不难：您只需要使用Docker
    Compose中的`up`命令，就像下面的代码所示：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As a good practice, it is recommended that you provide a `docker-compose.yaml`
    file as part of your project. In this way, the provisioning process can be done easily
    by the team members.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个良好的实践，建议您在项目中提供一个`docker-compose.yaml`文件。这样，团队成员可以轻松地进行配置。
- en: Linking containers
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接容器
- en: 'When you''re running distributed applications, you have to connect different
    services in order to make them work together. To achieve this requirement, you
    need to know the hostnames or IP addresses of the services, among other configuration
    variables. The order in which the services are made available is also important.
    Let''s consider the following simple application:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行分布式应用程序时，您必须连接不同的服务以使它们一起工作。为了满足这个要求，您需要知道服务的主机名或IP地址，以及其他配置变量。服务的可用顺序也很重要。让我们考虑以下简单的应用程序：
- en: '![](img/b81c4411-573a-4cfa-9dc1-53d66ddb9ede.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b81c4411-573a-4cfa-9dc1-53d66ddb9ede.png)'
- en: Services dependencies
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 服务依赖关系
- en: The preceding diagram represents the most simple application; it has only one
    dependency on a database server. In this example, the application needs some database
    configuration parameters, such as the IP address, port, and so on. And of course,
    the database service should be available before starting the application; otherwise,
    the application won't be able to start.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图表示了最简单的应用程序；它只依赖于一个数据库服务器。在这个例子中，应用程序需要一些数据库配置参数，比如IP地址、端口等。当然，在启动应用程序之前，数据库服务应该是可用的；否则，应用程序将无法启动。
- en: 'In order to solve this simple requirement, you can use the following two options
    as part of your `docker-compose.yaml` file:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个简单的需求，您可以在您的`docker-compose.yaml`文件中使用以下两个选项：
- en: '`links`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`links`'
- en: '`depends_on`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on`'
- en: links
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: links
- en: The `links` option can be used to connect various containers by their names.
    This way, you won't need to know their hostnames or IP addresses at all.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`links`选项可以用来通过它们的名称连接各种容器。这样，您根本不需要知道它们的主机名或IP地址。'
- en: depends_on
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: depends_on
- en: Using the `depends_on` option, you can specify the order in which the service
    should start. One service can have dependencies on more than one service, if that's
    needed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`depends_on`选项，您可以指定服务启动的顺序。如果需要，一个服务可以依赖于多个服务。
- en: 'Let''s review the following `docker-compose.yaml` file, which uses both of
    these options:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下使用了这两个选项的`docker-compose.yaml`文件：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `depends_on` and `links` options in the preceding code are highlighted in
    bold. It's pretty easy to understand from this that the application connects to
    the database server once the database is up.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的`depends_on`和`links`选项已经用粗体标出。从这可以很容易地理解，应用程序在数据库服务器启动后连接到数据库。
- en: 'The `enriquezrene/docker-compose-banking-app: 1.0` image has a Spring Boot
    application running inside of it. As part of this application, we have the configuration
    file named `application.properties` with the following content:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`enriquezrene/docker-compose-banking-app: 1.0` 镜像中有一个运行在其中的Spring Boot应用程序。作为这个应用程序的一部分，我们有一个名为`application.properties`的配置文件，内容如下：'
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You may notice that the password and data source URL parameters are already
    provided. However, Spring offers the ability to override these configurations
    by using environment variables, as we did in the `docker-compose.yaml` file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到密码和数据源URL参数已经提供。但是，Spring提供了使用环境变量覆盖这些配置的能力，就像我们在`docker-compose.yaml`文件中所做的那样。
- en: Docker Compose is easy to use, and it has the same options as Docker. Let's quickly
    review some commands that will allow us to start using it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose易于使用，并且具有与Docker相同的选项。让我们快速回顾一些命令，以便开始使用它。
- en: 'This command allows us to start all the containers listed in the configuration
    file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令允许我们启动配置文件中列出的所有容器：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `up` command also allows the `-d` flag to run all processes as a daemon.
    If you want to, you can start only one service from the `docker-compose.yaml`
    file specifying the service name. Let''s say we only want to run the database
    server. The command that allows you to perform this action is the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`up`命令还允许使用`-d`标志将所有进程作为守护进程运行。如果您愿意，您可以从`docker-compose.yaml`文件中只启动一个服务，指定服务名称。假设我们只想运行数据库服务器。允许您执行此操作的命令如下：'
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this way, you can specify the service name for the other commands available
    in Docker Compose.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以为Docker Compose中可用的其他命令指定服务名称。
- en: 'Once the services are up, you can list all the containers that are running
    using the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务启动，您可以使用以下命令列出所有正在运行的容器：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you want to stop all the commands that were started, you will need to use
    the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想停止所有已启动的命令，您需要使用以下命令：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Docker Compose is comprised of a large set of commands. For a complete reference,
    you can visit [https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose由一大堆命令组成。要获取完整的参考资料，您可以访问[https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/)。
- en: Container orchestration with Kubernetes
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行容器编排
- en: Kubernetes introduces a new set of concepts for an environment working with
    Docker containers. We could say that Kubernetes does in production what Docker
    Compose does in development, but there is much more to it than that. Kubernetes
    is an open source system originally created for Google Cloud Engine, but you can
    use it with AWS or any other cloud provider. It is intended for remotely managing
    Docker clusters in different environments.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为使用Docker容器的环境引入了一套新的概念。我们可以说Kubernetes在生产中做的是Docker Compose在开发中做的，但实际上远不止于此。Kubernetes是一个开源系统，最初是为Google
    Cloud Engine创建的，但您可以在AWS或任何其他云提供商中使用它。它旨在远程管理不同环境中的Docker集群。
- en: 'Kubernetes introduces the following main concepts:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes引入了以下主要概念：
- en: Pods
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pods
- en: Replication controllers
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制控制器
- en: Services
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Labels
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Pod
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod
- en: The pod is a new concept introduced by Kubernetes. A pod is comprised of a group
    of related containers that represent a specific application. This is the most
    basic unit within Kubernetes; you don't have to keep thinking about containers
    because pods are what you should focus on here.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: pod是Kubernetes引入的一个新概念。一个pod由一组相关的容器组成，代表一个特定的应用程序。这是Kubernetes中最基本的单位；您不必一直考虑容器，因为在这里您应该专注于pod。
- en: 'Let''s consider an application called XYZ that stores its information in a
    database that exposes a REST API that is consumed by its UI, as shown in the following
    diagram:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个名为XYZ的应用程序，它将其信息存储在一个数据库中，该数据库提供了一个REST API，该API由其UI使用，如下图所示：
- en: '![](img/a2b2a568-cd2b-4886-8715-3af7e5e93232.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2b2a568-cd2b-4886-8715-3af7e5e93232.png)'
- en: The XYZ application with its dependencies
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 带有其依赖项的XYZ应用程序
- en: 'It''s obvious that we need three separate services to make this application
    work. If we were dealing with Docker, we would say that we need three different
    containers, but from a Kubernetes perspective, all these three containers represent
    a single pod. This abstraction allows us to manage distributed applications more
    easily. In order to create a pod definition, you should create a `.yaml` file
    describing all the containers that are part of the pod. An example of the XYZ
    application that we mentioned earlier is described in the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们需要三个单独的服务来使这个应用程序工作。如果我们在处理Docker，我们会说我们需要三个不同的容器，但从Kubernetes的角度来看，所有这三个容器代表一个单独的pod。这种抽象使我们能够更轻松地管理分布式应用程序。为了创建一个pod定义，您应该创建一个描述pod中所有容器的`.yaml`文件。我们之前提到的XYZ应用程序的示例描述在以下代码中：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the file is created, you can execute the pod using the following Kubernetes
    command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件后，您可以使用以下Kubernetes命令执行pod：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Labels
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签
- en: 'As soon as the number of applications grows within an organization, managing
    all of them tends to be a nightmare. Imagine that you only have fifteen microservices
    and two environments: one for staging and the other for production. In this case,
    identifying all of the running pods would be really hard to do, and you would
    need to remember all of the pod names in order to query their statuses.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦组织内的应用程序数量增加，管理所有这些应用程序往往会成为一场噩梦。想象一下，您只有十五个微服务和两个环境：一个用于暂存，另一个用于生产。在这种情况下，要识别所有正在运行的pod将会非常困难，您需要记住所有pod名称以查询它们的状态。
- en: 'Labels are intended to make this task easier. You can use them to tag pods
    with label names that are easy to remember and which make sense to you. Since
    a label is a key–value pair, you have the chance to use whatever you want, including `environment:<environment-name>`,
    for instance. Let''s review the following `application-xyz-pod.yaml` example file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 标签旨在使此任务更容易。您可以使用它们为pod打上易于记忆的标签名称，并且对您来说是有意义的。由于标签是键-值对，您有机会使用任何您想要的内容，包括`environment:<environment-name>`。让我们来看看下面的`application-xyz-pod.yaml`示例文件：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The code in bold shows how the label can be created. Here, you can add as many
    labels as you want. Let''s create this pod with the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体中的代码显示了标签如何创建。在这里，您可以添加尽可能多的标签。让我们使用以下命令创建这个pod：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the pod has been created, you can look for it using the labels with the
    following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦pod被创建，您可以使用以下命令使用标签查找它：
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Replication controllers
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制控制器
- en: At first sight, one may think that we should care about pods, but Kubernetes
    recommends using another abstraction called replication controllers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，人们可能会认为我们应该关心pod，但Kubernetes建议使用另一个称为复制控制器的抽象。
- en: 'You will never run one pod instance in production. Instead, you will run many
    of them to offer high availability and to support all the traffic. Replication
    controllers are intended to ensure that a specified number of pods are up and
    running. It''s common to have issues with services running in the wild, and sometimes
    a host crashes, making one or more pods unavailable. Replication controllers are
    constantly monitoring the system for such problems, and when a pod crashes, it
    automatically creates a new replica for this pod, as shown in the following diagram:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中永远不会运行一个pod实例。相反，您将运行许多pod以提供高可用性并支持所有流量。复制控制器旨在确保指定数量的pod正在运行。在野外运行服务通常会出现问题，有时主机会崩溃，导致一个或多个pod不可用。复制控制器会不断监视系统以查找此类问题，当一个pod崩溃时，它会自动为此pod创建一个新的副本，如下图所示：
- en: '![](img/aae89f3e-0546-4a1d-a0ff-c5ef41832e09.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aae89f3e-0546-4a1d-a0ff-c5ef41832e09.png)'
- en: Replica services and pods
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 复制服务和pod
- en: Replica controllers are also useful for rolling out new application versions.
    You can easily turn off all the pods associated with a specific replica and then
    turn the new one on.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 复制控制器也对推出新的应用程序版本很有用。您可以轻松关闭与特定副本关联的所有pod，然后打开新的pod。
- en: 'Let''s review the following file, which shows an example of a replication controller:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看下面的文件，它展示了一个复制控制器的示例：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The content of this file is pretty similar for pods; the main difference is
    the kind of Docker Service that is specified. In this case, it uses the `ReplicaController`
    value. Later, we will define the desired number of replicas and the selector section
    can be used to specify labels.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的内容与pod非常相似；主要区别在于指定的Docker服务的种类。在这种情况下，它使用了`ReplicaController`值。稍后，我们将定义所需的副本数量，并且选择器部分可以用来指定标签。
- en: 'Using this file, the replica can be created by running the `kubectl create`
    command, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此文件，可以通过运行`kubectl create`命令来创建副本，如下所示：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can verify how pods are being created when required. You can delete a pod
    with the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以验证在需要时如何创建pod。您可以使用以下命令删除一个pod：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can then query the available pods with the following command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下命令查询可用的pod：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Services
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'It''s common to have many replica services serving applications in production
    in order to offer a good user experience. However, no matter how many hosts or
    images are involved in this process, we need to offer a unique entry point for
    all this functionality: this is what Kubernetes services are intended for.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中通常会有许多复制服务来提供良好的用户体验。然而，无论此过程涉及多少主机或图像，我们都需要为所有这些功能提供一个唯一的入口点：这就是Kubernetes服务的目的。
- en: A Kubernetes service acts as both an endpoint and load balancer for a specific
    application. Since a service is located in front of a group of replicated pods,
    it will distribute the traffic across all the available instances.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes服务充当特定应用程序的端点和负载均衡器。由于服务位于一组复制的pod的前面，它将在所有可用的实例之间分发流量。
- en: Remember, pods and Docker containers are ephemeral, and we can't rely on their
    IP addresses. This is why Kubernetes services are important for continuously providing
    a service.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，pod和Docker容器是短暂的，我们不能依赖它们的IP地址。这就是为什么Kubernetes服务对于持续提供服务非常重要。
- en: 'Let''s look at an example of a configuration file for a Kubernetes service:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个Kubernetes服务的配置文件示例：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `kind` configuration entry in line 2 has a new value—in this case, the
    value is `Service`. The selector indicates the replica container associated with
    this service, and the rest of the configuration parameters are self-explanatory.
    Using this file, you can use the `kubectl create` command as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行的`kind`配置条目具有一个新值—在本例中，该值为`Service`。选择器指示与此服务关联的副本容器，其余的配置参数都是不言自明的。使用此文件，您可以使用`kubectl
    create`命令如下：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Furthermore, if you don''t want to create a file for a service, you can directly
    expose an existing replica controller using the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您不想为服务创建文件，可以直接使用以下命令公开现有的复制控制器：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started reviewing the basic concepts of containers and how
    they are applied to Docker, one of the most popular products used for containerizing
    applications.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始回顾容器的基本概念以及它们如何应用于Docker，这是用于容器化应用程序的最流行的产品之一。
- en: We then learned how to automate this process and made it part of the build process
    for a Java application, using Gradle as a build tool. The main intention behind
    automation is to be aligned to DevOps principles; we are going to talk about DevOps
    in detail in the following chapter. At the end of this chapter, we looked at other
    Docker tools that automate the provisioning process in development environments,
    and we also learned about Kubernetes and how it can be used for production environments.
    In the next chapter, we will review DevOps and release management concepts.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何自动化这个过程，并将其作为Java应用程序构建过程的一部分，使用Gradle作为构建工具。自动化背后的主要意图是为了与DevOps原则保持一致；我们将在下一章节详细讨论DevOps。在本章末尾，我们看了其他Docker工具，它们可以自动化开发环境中的配置过程，并学习了Kubernetes以及它在生产环境中的应用。在下一章中，我们将回顾DevOps和发布管理的概念。
