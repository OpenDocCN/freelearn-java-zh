- en: Building a Web Application with Spring MVC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring MVC构建Web应用程序
- en: Spring MVC is the most popular web framework used to develop Java web applications.
    The beauty of Spring MVC lies in its clean, loosely coupled architecture. With
    a clean definition of roles for controllers, handler mappings, view resolvers,
    and **Plain Old Java Object** (**POJO**) command beans, Spring MVC makes use of
    all the core Spring features--like dependency injection and autowiring--to make
    it simple to create web applications. With its support for multiple view technologies,
    it is extensible too.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC是用于开发Java Web应用程序的最流行的Web框架。Spring MVC的优势在于其清晰的、松散耦合的架构。通过对控制器、处理程序映射、视图解析器和**普通的Java对象**（**POJO**）命令bean的角色进行清晰定义，Spring
    MVC利用了所有核心Spring功能--如依赖注入和自动装配--使得创建Web应用程序变得简单。它支持多种视图技术，也具有可扩展性。
- en: While Spring MVC can be used to create REST services, we discuss that in [Chapter
    5](72e55d58-492f-404a-adbf-c3f86cf583c9.xhtml), *Building Microservices with Spring
    Boot*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Spring MVC可以用于创建REST服务，但我们将在[第5章](72e55d58-492f-404a-adbf-c3f86cf583c9.xhtml)中讨论*使用Spring
    Boot构建微服务*。
- en: In this chapter, we will focus on reviewing the basics of Spring MVC with simple
    examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍Spring MVC的基础知识，并提供简单的示例。
- en: 'In this chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Spring MVC architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC架构
- en: The roles played by DispatcherServlet, view resolvers, handler mappings and
    controllers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DispatcherServlet、视图解析器、处理程序映射和控制器所扮演的角色
- en: Model attributes and session attributes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型属性和会话属性
- en: Form binding and validation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单绑定和验证
- en: Integration with Bootstrap
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Bootstrap集成
- en: Basics of Spring Security
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring安全的基础知识
- en: Writing simple unit tests for controllers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为控制器编写简单的单元测试
- en: Java web application architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java Web应用程序架构
- en: 'The way we develop Java web applications has evolved during the last couple
    of decades. We will discuss the different architectural approaches to developing
    Java web applications and see where Spring MVC fits in:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年里，我们开发Java Web应用程序的方式已经发生了变化。我们将讨论开发Java Web应用程序的不同架构方法，并看看Spring MVC适用于哪些方面：
- en: Model 1 architecture
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型1架构
- en: Model 2 or MVC architecture
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型2或MVC架构
- en: Model 2 with Front Controller
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有前端控制器的模型2
- en: Model 1 architecture
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型1架构
- en: 'Model 1 architecture is one of the initial architecture styles used to develop
    Java-based web applications. A few important details are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模型1架构是用于开发基于Java的Web应用程序的初始架构风格之一。一些重要的细节如下：
- en: JSP pages directly handled the requests from the browser
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSP页面直接处理来自浏览器的请求
- en: JSP pages made use of the model containing simple Java beans
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSP页面使用包含简单Java bean的模型
- en: In some applications of this architecture style, JSPs even performed queries
    to the database
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种架构风格的一些应用中，甚至JSP执行了对数据库的查询
- en: 'JSPs also handled the flow logic: which page to show next'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSP还处理流程逻辑：下一个要显示的页面
- en: 'The following picture represents typical Model 1 architecture:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片代表典型的模型1架构：
- en: '![](img/a74fb9ad-d01d-4d70-93fa-f980215c48f1.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a74fb9ad-d01d-4d70-93fa-f980215c48f1.png)'
- en: 'There are a lot of disadvantages in this approach, leading to quick shelving
    and the evolution of other architectures. A few important disadvantages are listed
    as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在许多缺点，导致快速搁置和其他架构的演变。以下是一些重要的缺点：
- en: '**Hardly any separation of concerns**: JSPs were responsible for retrieving
    data, displaying data, deciding which pages to show next (flow), and sometimes,
    even business logic as well'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几乎没有关注点分离**：JSP负责检索数据，显示数据，决定下一个要显示的页面（流程），有时甚至包括业务逻辑'
- en: '**Complex JSPs**: Because JSPs handled a lot of logic, they were huge and difficult
    to maintain'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的JSP**：因为JSP处理了很多逻辑，它们很庞大且难以维护'
- en: Model 2 architecture
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型2架构
- en: 'Model 2 architecture came in to solve the complexity involved with complex
    JSPs having multiple responsibilities. This forms the base for the MVC architecture
    style. The following image represents typical Model 2 architecture:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 模型2架构出现是为了解决处理多个责任的复杂JSP所涉及的复杂性。这构成了MVC架构风格的基础。以下图片代表典型的模型2架构：
- en: '![](img/cfce1c1a-1aa9-400d-b641-4bc8a2f4c0a0.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfce1c1a-1aa9-400d-b641-4bc8a2f4c0a0.png)'
- en: 'Model 2 architecture has a clear separation of roles between Model, View, and
    Controller. This leads to more maintainable applications. A few important details
    are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 模型2架构在模型、视图和控制器之间有明确的角色分离。这导致了更易维护的应用程序。一些重要的细节如下：
- en: '**Model**: Represents the data to be used to generate a View.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：表示用于生成视图的数据。'
- en: '**View**: Uses the Model to render the screen.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：使用模型来呈现屏幕。'
- en: '**Controller**: Controls the flow. Gets the request from the browser, populates
    the Model and redirects to the View. Examples are **Servlet1** and **Servlet2**
    in the preceding figure.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制流程。从浏览器获取请求，填充模型并重定向到视图。示例是前面图中的**Servlet1**和**Servlet2**。'
- en: Model 2 Front Controller architecture
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型2前端控制器架构
- en: In the basic version of Model 2 architecture, the requests from the browser
    are handled directly by different servlets (or Controllers). In a number of business
    scenarios, one would want to do a few common things in servlets before we handle
    the request. An example would be to ensure that the logged-in user has the right
    authorization to execute the request. This is a common functionality that you
    would not want to be implemented in every servlet.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型2架构的基本版本中，浏览器的请求直接由不同的servlet（或控制器）处理。在许多业务场景中，我们希望在处理请求之前在servlet中执行一些常见的操作。例如，确保已登录的用户有权执行请求。这是一个常见的功能，您不希望在每个servlet中实现。
- en: In Model 2 **Front Controller** architecture, all requests flow into a single
    controller called the Front Controller.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型2**前端控制器**架构中，所有请求都流入一个称为前端控制器的单个控制器。
- en: 'Picture below represents typical Model 2 Front Controller architecture:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图片代表典型的模型2前端控制器架构：
- en: '![](img/8afb2351-2192-4dac-8589-b197a1ff401b.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8afb2351-2192-4dac-8589-b197a1ff401b.png)'
- en: 'The following are some of the responsibilities of a typical Front Controller:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是典型前端控制器的一些职责： '
- en: It decides which Controller executes the request
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它决定了哪个控制器执行请求
- en: It decides which View to render
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它决定了要渲染哪个视图
- en: It provides provisions to add more common functionality
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了添加更多常见功能的规定
- en: Spring MVC uses an MVC pattern with Front Controller. The Front Controller is
    called **DispatcherServlet**. We will discuss DispatcherServlet a little later.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC使用带有Front Controller的MVC模式。前端控制器称为**DispatcherServlet**。我们稍后将讨论DispatcherServlet。
- en: Basic flows
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本流程
- en: 'Spring MVC uses a modified version of the Model 2 Front Controller architecture.
    Before we go into details about how Spring MVC works, we will focus on creating
    a few simple web flows using Spring MVC. In this section, we will create six typical
    web application flows using Spring MVC. The flows are listed as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC使用了修改版的Model 2 Front Controller架构。在我们深入了解Spring MVC的工作原理之前，我们将专注于使用Spring
    MVC创建一些简单的Web流程。在本节中，我们将使用Spring MVC创建六种典型的Web应用程序流程。流程如下所示：
- en: '**Flow 1**: Controller without a View; serving content on its own'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程1**：没有视图的控制器；自己提供内容'
- en: '**Flow 2**: Controller with a View (a JSP)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程2**：带有视图（JSP）的控制器'
- en: '**Flow 3**: Controller with a View and using ModelMap'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程3**：带有视图并使用ModelMap的控制器'
- en: '**Flow 4**: Controller with a View and using ModelAndView'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程4**：带有视图并使用ModelAndView的控制器'
- en: '**Flow 5**: Controller for a simple form'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程5**：简单表单的控制器'
- en: '**Flow 6**: Controller for a simple form with validation'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程6**：带有验证的简单表单的控制器'
- en: At the end of every flow, we will discuss how to unit test the Controller.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个流程结束时，我们将讨论如何对控制器进行单元测试。
- en: Basic setup
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本设置
- en: Before we start with the first flow, we would need to get the application set
    up to use Spring MVC. In the next section, we will start by understanding how
    to set up Spring MVC in a web application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始第一个流程之前，我们需要设置应用程序以使用Spring MVC。在下一节中，我们将开始了解如何在Web应用程序中设置Spring MVC。
- en: 'We are using Maven to manage our dependencies. The following steps are involved
    in setting up a simple web application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Maven来管理我们的依赖关系。设置一个简单的Web应用程序涉及以下步骤：
- en: Add a dependency for Spring MVC.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Spring MVC的依赖。
- en: Add DispatcherServlet to `web.xml`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将DispatcherServlet添加到`web.xml`中。
- en: Create a Spring application context.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Spring应用上下文。
- en: Adding dependency for Spring MVC
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Spring MVC的依赖
- en: 'Let''s start with adding the Spring MVC dependency to our `pom.xml`. The following
    code shows the dependency to be added in. Since we are using Spring BOM, we do
    not need to specify the artifact version:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`pom.xml`中添加Spring MVC依赖开始。以下代码显示了要添加的依赖项。由于我们使用Spring BOM，我们不需要指定artifact版本：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: DispatcherServlet is an implementation of the Front Controller pattern. Any
    request to Spring MVC will be handled by the Front Controller, that is, DispatcherServlet.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: DispatcherServlet是Front Controller模式的一种实现。Spring MVC的任何请求都将由前端控制器DispatcherServlet处理。
- en: Adding DispatcherServlet to web.xml
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将DispatcherServlet添加到web.xml
- en: 'To enable this, we would need to add DispatcherServlet to `web.xml`. Let''s
    look at how to do that:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要将DispatcherServlet添加到`web.xml`中。让我们看看如何做到这一点：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first part is to define a servlet. We are also defining a context configuration
    location, `/WEB-INF/user-web-context.xml`. We will define a Spring context in
    the next step. In the second part, we are defining a servlet mapping. We are mapping
    a URL `/` to the DispatcherServlet. So, all requests will be handled by the DispatcherServlet.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是定义一个servlet。我们还定义了一个上下文配置位置，`/WEB-INF/user-web-context.xml`。我们将在下一步中定义一个Spring上下文。在第二部分中，我们正在定义一个servlet映射。我们正在将URL
    `/`映射到DispatcherServlet。因此，所有请求都将由DispatcherServlet处理。
- en: Creating Spring context
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Spring上下文
- en: 'Now that we have DispatcherServlet defined in `web.xml`, we can go ahead and
    create our Spring context. Initially, we will create a very simple context without
    really defining anything concrete:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`web.xml`中定义了DispatcherServlet，我们可以继续创建我们的Spring上下文。最初，我们将创建一个非常简单的上下文，而不是真正定义任何具体内容：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are defining a component scan for the `com.mastering.spring.springmvc` package
    so that all the beans and controllers in this package are created and auto-wired.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为`com.mastering.spring.springmvc`包定义一个组件扫描，以便在此包中创建和自动装配所有的bean和控制器。
- en: 'Using `<mvc:annotation-driven/>` initializes support for a number of features
    that Spring MVC supports such as:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<mvc:annotation-driven/>`初始化了Spring MVC支持的许多功能，例如：
- en: Request mapping
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求映射
- en: Exception handling
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Data binding and validation
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定和验证
- en: Automatic conversion (for example, JSON) when the `@RequestBody` annotation
    is used
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`@RequestBody`注解时，自动转换（例如JSON）
- en: That's all the setup we need to be able to set up a Spring MVC application.
    We are ready to get started with the first flow.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要设置Spring MVC应用程序的所有设置。我们已经准备好开始第一个流程了。
- en: Flow 1 - Simple controller flow without View
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程1 - 没有视图的简单控制器流程
- en: Let's start with a simple flow by showing some simple text that is output from
    a Spring MVC controller on screen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的流程开始，通过在屏幕上显示一些简单的文本来输出Spring MVC控制器的内容。
- en: Creating a Spring MVC controller
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Spring MVC控制器
- en: 'Let''s create a simple Spring MVC controller as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的Spring MVC控制器，如下所示：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A few important things to note here are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一些重要事项如下：
- en: '`@Controller`: This defines a Spring MVC controller that can contain request
    mappings--mapping URLs to controller methods.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Controller`：这定义了一个Spring MVC控制器，可以包含请求映射--将URL映射到控制器方法。'
- en: '`@RequestMapping(value = "/welcome")`: This defines a mapping of the URL `/welcome`
    to the `welcome` method. When the browser sends a request to `/welcome`, Spring
    MVC does the magic and executes the `welcome` method.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping(value = "/welcome")`：这定义了URL `/welcome`到`welcome`方法的映射。当浏览器发送请求到`/welcome`时，Spring
    MVC会执行`welcome`方法。'
- en: '`@ResponseBody`: In this specific context, the text returned by the `welcome`
    method is sent out to the browser as the response content. `@ResponseBody` does
    a lot of magic--especially in the context of REST services. We will discuss this
    in [Chapter 5](72e55d58-492f-404a-adbf-c3f86cf583c9.xhtml), *Building Microservices
    with Spring Boot*.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ResponseBody`：在这个特定的上下文中，`welcome`方法返回的文本被发送到浏览器作为响应内容。`@ResponseBody`做了很多魔术--特别是在REST服务的上下文中。我们将在[第5章](72e55d58-492f-404a-adbf-c3f86cf583c9.xhtml)中讨论这个问题，*使用Spring
    Boot构建微服务*。'
- en: Running the web application
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Web应用程序
- en: We are using Maven and Tomcat 7 to run this web application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Maven和Tomcat 7来运行这个Web应用程序。
- en: Tomcat 7 server launches up on port 8080 by default.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat 7服务器默认在8080端口启动。
- en: We can run the server by invoking the `mvn tomcat7:run` command.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`mvn tomcat7:run`命令来运行服务器。
- en: 'Here is a screenshot of how this would look on the screen when the `http://localhost:8080/welcome`
    URL is hit on the browser as in following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当在浏览器上访问`http://localhost:8080/welcome`URL时，屏幕上的显示如下截图所示：
- en: '![](img/fa4a0b7a-e415-4331-a0e3-707430ee9550.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa4a0b7a-e415-4331-a0e3-707430ee9550.png)'
- en: Unit testing
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Unit testing is a very important part of developing maintainable applications.
    We will be using the Spring MVC Mock framework to unit test the Controllers that
    we will write in this chapter. We will add in a dependency on the Spring test
    framework to use the Spring MVC Mock framework:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是开发可维护应用程序的一个非常重要的部分。我们将使用Spring MVC Mock框架来对本章中编写的控制器进行单元测试。我们将添加Spring测试框架的依赖来使用Spring
    MVC Mock框架：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The approach we will be taking would involve the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取以下方法：
- en: Setting up the Controller to test.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置要测试的控制器。
- en: Writing the test method.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写测试方法。
- en: Setting up the Controller to test
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置要测试的控制器
- en: The controller we want to test is `BasicController`. The convention to create
    a unit test is a class name with a suffix `Test`. We will create a test class
    named `BasicControllerTest`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要测试的控制器是`BasicController`。创建单元测试的约定是类名后缀为`Test`。我们将创建一个名为`BasicControllerTest`的测试类。
- en: 'The basic setup is shown as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 基本设置如下所示：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A few important things to note are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`mockMvc`: This variable can be used across different tests. So, we define
    an instance variable of the `MockMvc` class.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mockMvc`：这个变量可以在不同的测试中使用。因此，我们定义了`MockMvc`类的一个实例变量。'
- en: '`@Before setup`: This method is run before every test in order to initialize
    `MockMvc`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Before setup`：这个方法在每个测试之前运行，以初始化`MockMvc`。'
- en: '`MockMvcBuilders.standaloneSetup(new BasicController()).build()`: This line
    of code builds a `MockMvc` instance. It initializes DispatcherServlet to serve
    requests to the configured controller(s), `BasicController` in this instance.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockMvcBuilders.standaloneSetup(new BasicController()).build()`：这行代码构建了一个`MockMvc`实例。它初始化DispatcherServlet来为配置的控制器（在这个例子中是`BasicController`）提供请求服务。'
- en: Writing the Test method
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试方法
- en: 'The complete `Test` method is shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`Test`方法如下所示：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A few important things to note are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`MockMvc` `mockMvc.perform`: This method executes the request and returns an
    instance of ResultActions that allows chaining calls. In this example, we are
    chaining the andExpect calls to check expectations.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockMvc` `mockMvc.perform`：这个方法执行请求并返回一个ResultActions的实例，允许链式调用。在这个例子中，我们正在链接andExpect调用来检查期望。'
- en: '`get("/welcome").accept(MediaType.parseMediaType("application/html;charset=UTF-8"))`:
    This creates an HTTP get request accepting a response with the media type `application/html`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get("/welcome").accept(MediaType.parseMediaType("application/html;charset=UTF-8"))`：这创建了一个接受`application/html`媒体类型响应的HTTP
    get请求。'
- en: '`andExpect`: This method is used to check expectations. This method will fail
    the test if the expectation is not met.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`andExpect`：这个方法用于检查期望。如果期望没有被满足，这个方法将使测试失败。'
- en: '`status().isOk()`: This uses ResultMatcher to check whether the response status
    is that of a successful request - 200.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status().isOk()`：这使用ResultMatcher来检查响应状态是否是成功请求的状态-200。'
- en: '`content().contentType("application/html;charset=UTF-8"))`: This uses ResultMatcher
    to check whether the content type of the response is as specified.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content().contentType("application/html;charset=UTF-8"))`：这使用ResultMatcher来检查响应的内容类型是否与指定的内容类型相匹配。'
- en: '`content().string("Welcome to Spring MVC")`: This uses ResultMatcher to check
    whether the response content contains the specified string.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content().string("Welcome to Spring MVC")`：这使用ResultMatcher来检查响应内容是否包含指定的字符串。'
- en: Flow 2 - Simple controller flow with a View
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程2 - 带有视图的简单控制器流程
- en: In the previous flow, the text to show on the browser was hardcoded in the Controller.
    That is not a good practice. The content to be shown on the browser is typically
    generated from a View. The most frequently used option is a JSP.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的流程中，要在浏览器上显示的文本是在控制器中硬编码的。这不是一个好的做法。在浏览器上显示的内容通常是从视图生成的。最常用的选项是JSP。
- en: In this flow, let's redirect from the Controller to a View.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个流程中，让我们从控制器重定向到一个视图。
- en: Spring MVC controller
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC控制器
- en: 'Similar to the previous example, let''s create a simple Controller. Consider
    the example of a controller here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子类似，让我们创建一个简单的控制器。考虑一个控制器的例子：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A few important things to note are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '`@RequestMapping(value = "/welcome-view")`: We are mapping an URL `/welcome-view`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping(value = "/welcome-view")`：我们正在映射一个URL`/welcome-view`。'
- en: '`public String welcome()`: There is no `@RequestBody` annotation on this method.
    So, Spring MVC tries to match the string that is returned, `welcome`, to a view.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public String welcome()`：这个方法上没有`@RequestBody`注解。所以，Spring MVC尝试将返回的字符串`welcome`与一个视图匹配。'
- en: Creating a View - a JSP
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个视图-JSP
- en: 'Let''s create `welcome.jsp` in the `src/main/webapp/WEB-INF/views/welcome.jsp`
    folder with the following content:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`src/main/webapp/WEB-INF/views/welcome.jsp`文件夹中创建`welcome.jsp`，内容如下：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is a simple HTML with head, body, and some text in the body.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的HTML，包含头部、主体和主体中的一些文本。
- en: Spring MVC has to map the string returned from the `welcome` method to the real
    JSP at `/WEB-INF/views/welcome.jsp`. How does this magic happen?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC必须将从`welcome`方法返回的字符串映射到`/WEB-INF/views/welcome.jsp`的实际JSP。这个魔术是如何发生的呢？
- en: View resolver
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图解析器
- en: A view resolver resolves a View name to the actual JSP page.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 视图解析器将视图名称解析为实际的JSP页面。
- en: The View name in this example is `welcome`, and we would want it to resolve
    to `/WEB-INF/views/welcome.jsp`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的视图名称为`welcome`，我们希望它解析为`/WEB-INF/views/welcome.jsp`。
- en: 'A view resolver can be configured in the spring context `/WEB-INF/user-web-context.xml`.
    Here''s the code snippet for that:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在spring上下文`/WEB-INF/user-web-context.xml`中配置视图解析器。以下是代码片段：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A few important points to note:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要点：
- en: '`org.springframework.web.servlet.view.InternalResourceViewResolver`: A view
    resolver supporting JSPs. `JstlView` is typically used. It also supports tiles
    with a TilesView.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.web.servlet.view.InternalResourceViewResolver`：支持JSP的视图解析器。通常使用`JstlView`。它还支持使用`TilesView`的tiles。'
- en: '`<property name="prefix"> <value>/WEB-INF/views/</value> </property><property
    name="suffix"> <value>.jsp</value> </property>`: This maps the prefix and suffix
    to be used by view resolver. View resolver takes the string from the controller
    method and resolves to the view: `prefix` + viewname + `suffix`. So, the view
    name welcome is resolved to `/WEB-INF/views/welcome.jsp`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<property name="prefix"> <value>/WEB-INF/views/</value> </property><property
    name="suffix"> <value>.jsp</value> </property>`：将前缀和后缀映射到视图解析器使用的值。视图解析器从控制器方法中获取字符串并解析为视图：`prefix`
    + viewname + `suffix`。因此，视图名称welcome解析为`/WEB-INF/views/welcome.jsp`。'
- en: 'Here is a screenshot of how this would look on the screen when the URL is hit:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当URL被访问时屏幕上的截图：
- en: '![](img/5b609f94-2dc2-4d2f-9c2e-30483d38677e.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b609f94-2dc2-4d2f-9c2e-30483d38677e.png)'
- en: Unit testing
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: A standalone setup of MockMvc Framework creates the bare minimum infrastructure
    required by DispatcherServlet. If provided with a view resolver, it can execute
    view resolution. However, it would not execute the view. So, during a unit test
    with the standalone setup, we cannot verify the content of the view. However,
    we can check whether the correct view is being delivered.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: MockMvc框架的独立设置创建了DispatcherServlet所需的最低基础设施。如果提供了视图解析器，它可以执行视图解析。但是，它不会执行视图。因此，在独立设置的单元测试中，我们无法验证视图的内容。但是，我们可以检查是否传递了正确的视图。
- en: In this unit test, we want to set up `BasicViewController`, execute a get request
    to `/welcome-view`, and check whether the view name returned is `welcome`. In
    a future section, we will discuss how to execute the integration test, including
    the rendering of view. As far as this test is concerned, we restrict our purview
    to verifying the view name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个单元测试中，我们想要设置`BasicViewController`，执行一个对`/welcome-view`的get请求，并检查返回的视图名称是否为`welcome`。在以后的部分中，我们将讨论如何执行集成测试，包括视图的渲染。就这个测试而言，我们将限制我们的范围以验证视图名称。
- en: Setting up the Controller to test
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置要测试的控制器
- en: 'This step is very similar to the previous flow. We want to test `BasicViewController`.
    We instantiate MockMvc using `BasicViewController`. We also configure a simple
    view resolver:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步与之前的流程非常相似。我们想要测试`BasicViewController`。我们使用`BasicViewController`实例化MockMvc。我们还配置了一个简单的视图解析器：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Writing the Test method
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试方法
- en: 'The complete test method is shown as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的测试方法如下所示：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A few important things to note are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要事项如下：
- en: '`get("/welcome-model-view")`: This executes the get request to the specified
    URL'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get("/welcome-model-view")`：执行对指定URL的get请求'
- en: '`view().name("welcome")`: This uses Result Matcher to check whether the view
    name returned is as specified'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view().name("welcome")`：使用Result Matcher来检查返回的视图名称是否与指定的相同'
- en: Flow 3 - Controller redirecting to a View with Model
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程3 - 控制器重定向到具有模型的视图
- en: Typically, in order to generate the view, we would need to pass some data to
    it. In Spring MVC, data can be passed to the view using a model. In this flow,
    we would set up a model with a simple attribute and use the attribute in the view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了生成视图，我们需要向其传递一些数据。在Spring MVC中，可以使用模型将数据传递给视图。在这个流程中，我们将使用一个简单的属性设置模型，并在视图中使用该属性。
- en: Spring MVC controller
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC控制器
- en: 'Let''s create a simple Controller. Consider the following example controller:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的控制器。考虑以下示例控制器：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A few important things to note are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要事项如下：
- en: '`@RequestMapping(value = "/welcome-model-map")`: The URI mapped is `/welcome-model-map`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping(value = "/welcome-model-map")`：映射的URI为`/welcome-model-map`。'
- en: '`public String welcome(ModelMap model)`: The new parameter added is `ModelMap
    model`. Spring MVC will instantiate a model and make it available for this method.
    The attributes put into the model will be available for use in the view.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public String welcome(ModelMap model)`：添加的新参数是`ModelMap model`。Spring MVC将实例化一个模型，并使其对此方法可用。放入模型中的属性将可以在视图中使用。'
- en: '`model.put("name", "XYZ")`: This adds an attribute with the `name` name and
    `XYZ` value to the model.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model.put("name", "XYZ")`：向模型中添加一个名为`name`值为`XYZ`的属性。'
- en: Creating a View
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个视图
- en: 'Let''s create a view using the model attribute `name` that was set in the model
    in the controller. Let''s create a simple JSP in the `WEB-INF/views/welcome-model-map.jsp`
    path:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在控制器中设置的模型属性`name`创建一个视图。让我们在`WEB-INF/views/welcome-model-map.jsp`路径下创建一个简单的JSP：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'One thing to note is this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是：
- en: '`${name}`: This uses the **Expression Language** (**EL**) syntax to access
    the attribute from the model.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${name}`：使用**表达式语言**（**EL**）语法来访问模型中的属性。'
- en: 'Here is a screenshot of how this would look on the screen when the URL is hit:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当URL被访问时屏幕上的截图：
- en: '![](img/c46d8dab-18e6-4964-9122-95ecebdee805.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c46d8dab-18e6-4964-9122-95ecebdee805.png)'
- en: Unit testing
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In this unit test, we want to set up `BasicModelMapController`, execute a get
    request to `/welcome-model-map`, and check whether the model has the expected
    attribute and whether the expected view name is returned.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个单元测试中，我们想要设置`BasicModelMapController`，执行一个对`/welcome-model-map`的get请求，并检查模型是否具有预期的属性，以及返回的视图名称是否符合预期。
- en: Setting up the Controller to test
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置要测试的控制器
- en: 'This step is very similar to the previous flow. We instantiate Mock MVC with
    `BasicModelMapController`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步与上一个流程非常相似。我们使用`BasicModelMapController`实例化Mock MVC：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Writing the Test method
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试方法
- en: 'The complete Test method is shown in the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的测试方法如下所示：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A few important things to note:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要事项：
- en: '`get("/welcome-model-map")`: Execute `get` request to the specified URL'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get("/welcome-model-map")`：执行对指定URL的`get`请求'
- en: '`model().attribute("name", "XYZ")`: Result Matcher to check if the model contains
    specified attribute **name** with specified value **XYZ**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model().attribute("name", "XYZ")`：结果匹配器，用于检查模型是否包含指定属性**name**和指定值**XYZ**'
- en: '`view().name("welcome-model-map")`: Result Matcher to check if the view name
    returned is as specified'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view().name("welcome-model-map")`：结果匹配器，用于检查返回的视图名称是否与指定的相同'
- en: Flow 4 - Controller redirecting to a View with ModelAndView
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程4 - 控制器重定向到带有ModelAndView的视图
- en: In the previous flow, we returned a view name and populated the model with attributes
    to be used in the view. Spring MVC provides an alternate approach using `ModelAndView`.
    The controller method can return a `ModelAndView` object with the view name and
    appropriate attributes in the Model. In this flow, we will explore this alternate
    approach.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个流程中，我们返回了一个视图名称，并在模型中填充了要在视图中使用的属性。Spring MVC提供了一种使用`ModelAndView`的替代方法。控制器方法可以返回一个带有视图名称和模型中适当属性的`ModelAndView`对象。在这个流程中，我们将探讨这种替代方法。
- en: Spring MVC controller
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC控制器
- en: 'Take a look at the following controller:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的控制器：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A few important things to note are as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要事项如下：
- en: '`@RequestMapping(value = "/welcome-model-view")`: The URI mapped is `/welcome-model-view`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping(value = "/welcome-model-view")`：映射的URI是`/welcome-model-view`。'
- en: '`public ModelAndView welcome(ModelMap model)`: Note that the return value is
    no longer a String. It is `ModelAndView`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public ModelAndView welcome(ModelMap model)`：请注意，返回值不再是String。它是`ModelAndView`。'
- en: '`return new ModelAndView("welcome-model-view", model)`: Create a `ModelAndView`
    object with the appropriate view name and model.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return new ModelAndView("welcome-model-view", model)`：使用适当的视图名称和模型创建`ModelAndView`对象。'
- en: Creating a View
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个视图
- en: 'Let''s create a view using the model attribute `name` that was set in the model
    in the controller. Create a simple JSP in the `/WEB-INF/views/welcome-model-view.jsp`
    path:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用在控制器中设置的模型属性`name`创建一个视图。在`/WEB-INF/views/welcome-model-view.jsp`路径下创建一个简单的JSP：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is a screenshot of how this would look on the screen when the URL is hit:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当URL被访问时，屏幕上会显示如下截图：
- en: '![](img/9f4dccc1-4ac3-4fa6-9f46-c2bc20e0c77c.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f4dccc1-4ac3-4fa6-9f46-c2bc20e0c77c.png)'
- en: Unit testing
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing for this flow is similar to the previous flow. We would need to
    check if the expected view name is returned.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个流程的单元测试与上一个流程类似。我们需要检查是否返回了预期的视图名称。
- en: Flow 5 - Controller redirecting to a View with a form
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程5 - 控制器重定向到带有表单的视图
- en: Now let's shift our attention to creating a simple form to capture input from
    the user.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转移到创建一个简单的表单，以从用户那里获取输入。
- en: 'The following steps will be needed:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 需要以下步骤：
- en: Create a simple POJO. We want to create a user. We will create a POJO User.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的POJO。我们想创建一个用户。我们将创建一个POJO用户。
- en: Create a couple of Controller methods--one to display the form, and the other
    to capture the details entered in the form.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一对控制器方法——一个用于显示表单，另一个用于捕获表单中输入的详细信息。
- en: Create a simple View with the form.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有表单的简单视图。
- en: Creating a command or form backing object
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个命令或表单备份对象
- en: POJO stands for Plain Old Java Object. It is usually used to represent a bean
    following the typical JavaBean conventions. Typically, it contains private member
    variables with getters and setters and a no-argument constructor.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: POJO代表普通的旧Java对象。通常用于表示遵循典型JavaBean约定的bean。通常，它包含具有getter和setter的私有成员变量和一个无参数构造函数。
- en: 'We will create a simple POJO to act as a command object. Important parts of
    the class are listed as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的POJO作为命令对象。类的重要部分列在下面：
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A few important things to note are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要事项如下：
- en: This class does not have any annotations or Spring-related mappings. Any bean
    can act as a form-backing object.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类没有任何注释或与Spring相关的映射。任何bean都可以充当表单备份对象。
- en: We are going to capture the `name`, `user ID`, and `password` in the form. We
    have a password confirmation field, `password2`, and unique identifier field guid.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在表单中捕获`name`、`用户ID`和`密码`。我们有一个密码确认字段`password2`和唯一标识符字段guid。
- en: '`Constructor`, `getters`, `setters`, and `toString` methods are not shown for
    brevity.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为简洁起见，构造函数、getter、setter和toString方法未显示。
- en: The Controller method to show the form
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示表单的控制器方法
- en: 'Let''s start with creating a simple controller with a logger:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个带有记录器的简单控制器开始：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s add the following method to the controller:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在控制器中添加以下方法：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Important things to note are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项如下：
- en: '`@RequestMapping(value = "/create-user", method = RequestMethod.GET)`: We are
    mapping a `/create-user` URI. For the first time, we are specifying a `Request`
    method using the method attribute. This method will be invoked only for HTTP Get
    Requests. HTTP `Get` Requests are typically used to show the form. This will not
    be invoked for other types of HTTP requests, such as Post.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping(value = "/create-user", method = RequestMethod.GET)`：我们正在映射一个`/create-user`
    URI。这是第一次使用method属性指定`Request`方法。此方法仅在HTTP Get请求时调用。HTTP `Get`请求通常用于显示表单。这不会被其他类型的HTTP请求调用，比如Post。'
- en: '`public String showCreateUserPage(ModelMap model)`: This is a typical control
    method.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public String showCreateUserPage(ModelMap model)`：这是一个典型的控制方法。'
- en: '`model.addAttribute("user", new User())`: This is used to set up the model
    with an empty form backing object.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model.addAttribute("user", new User())`：这用于使用空表单备份对象设置模型。'
- en: Creating the View with a form
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有表单的视图
- en: Java Server Pages is one of the view technologies supported by Spring Framework.
    Spring Framework makes it easy to create views with JSPs by providing a tag library.
    This includes tags for various form elements, binding, validation, setting themes
    and internationalizing messages. We will use the tags from the Spring MVC tag
    library as well as standard JSTL tag libraries to create our view in this example.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Java Server Pages是Spring Framework支持的视图技术之一。Spring Framework通过提供标签库，使得使用JSP轻松创建视图变得容易。这包括各种表单元素、绑定、验证、设置主题和国际化消息的标签。在本例中，我们将使用Spring
    MVC标签库以及标准的JSTL标签库来创建我们的视图。
- en: Let's start with creating the `/WEB-INF/views/user.jsp` file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建`/WEB-INF/views/user.jsp`文件开始。
- en: 'First, let''s add the reference to the tag libraries to be used:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加要使用的标签库的引用：
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first two entries are for JSTL core and formatting tag libraries. We will
    use the Spring form tags extensively. We provide a `prefix` to act as a shortcut
    to refer to tags.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个条目是JSTL核心和格式化标签库。我们将广泛使用Spring表单标签。我们提供一个`prefix`作为引用标签的快捷方式。
- en: 'Let''s create a form with one field first:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个只有一个字段的表单：
- en: '[PRE22]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Important things to note are as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项如下：
- en: '`<form:form method="post" modelAttribute="user">`: This is the `form` tag from
    the Spring form tag library. Two attributes are specified. Data in the form is
    sent using the post method. The second attribute, `modelAttribute`, specifies
    the attribute from the model that acts as the form backing object. In the model,
    we added an attribute with the name user. We use that attribute as `modelAttribute`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<form:form method="post" modelAttribute="user">`：这是Spring表单标签库中的`form`标签。指定了两个属性。表单中的数据使用post方法发送。第二个属性`modelAttribute`指定了模型中充当表单后备对象的属性。在模型中，我们添加了一个名为user的属性。我们使用该属性作为`modelAttribute`。'
- en: '`<fieldset>`: This is the HTML element to group a set of related controls--labels,
    form fields, and validation messages**.**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<fieldset>`：这是HTML元素，用于对一组相关控件（标签、表单字段和验证消息）进行分组。'
- en: '`<form:label path="name">Name</form:label>`: This is the Spring form tag to
    show a label. The path attribute specifies the field name (from bean) this label
    is applied to.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<form:label path="name">Name</form:label>`：这是Spring表单标签，用于显示标签。path属性指定了该标签应用于的字段名称（来自bean）。'
- en: '`<form:input path="name" type="text" required="required" />`: This is the Spring
    form tag to create a text input field. The `path` attribute specifies the field
    name in the bean that this input field has to be mapped to. The required attribute
    indicates that this is a `required` field.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<form:input path="name" type="text" required="required" />`：这是Spring表单标签，用于创建文本输入字段。`path`属性指定了该输入字段要映射到的bean中的字段名称。required属性表示这是一个`required`字段。'
- en: When we use the Spring form tags, the values from the form backing object (`modelAttribute="user"`)
    are bound automatically to the form, and on submitting the form, the values from
    the form are automatically bound to the form backing object.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Spring表单标签时，表单后备对象（`modelAttribute="user"`）中的值会自动绑定到表单上，并且在提交表单时，表单中的值会自动绑定到表单后备对象上。
- en: 'A more complete list of the form tags including the name and user ID fields
    are listed as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 包括名称和用户ID字段在内的更完整的表单标签列表如下：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Controller get method to handle form submit
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器获取方法来处理表单提交
- en: 'When the user submits the form, the browser sends an HTTP **POST** request.
    Now let''s create a method to handle this. To keep things simple, we will log
    the content of the form object. The complete listing of the method is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交表单时，浏览器会发送一个HTTP **POST**请求。现在让我们创建一个方法来处理这个请求。为了保持简单，我们将记录表单对象的内容。该方法的完整列表如下：
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A few important details are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的细节如下：
- en: '`@RequestMapping(value = "/create-user", method = RequestMethod.POST)`: Since
    we want to handle the form submit, we use the `RequestMethod.POST` method.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RequestMapping(value = "/create-user", method = RequestMethod.POST)`：由于我们要处理表单提交，我们使用`RequestMethod.POST`方法。'
- en: '`public String addTodo(User user)`: We are using the form backing object as
    the parameter. Spring MVC will automatically bind the values from the form to
    the form backing object.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public String addTodo(User user)`：我们使用表单后备对象作为参数。Spring MVC将自动将表单中的值绑定到表单后备对象。'
- en: '`logger.info("user details " + user)`: Log the details of the user.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logger.info("user details " + user)`：记录用户的详细信息。'
- en: 'return `redirect:list-users`: Typically, on submitting a form, we save the
    details of a database and redirect the user to a different page. Here, we are
    redirecting the user to `/list-users`. When we use `redirect`, Spring MVC sends
    an HTTP Response with status `302`; that is, `REDIRECT` to the new URL. The browser,
    on processing the `302` response, will redirect the user to the new URL. While
    the `POST`/`REDIRECT`/`GET` pattern is not a perfect fix for the duplicate form
    submission problem, it does reduce the occurrences, especially those that occur
    after the view is rendered.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`redirect:list-users`：通常，在提交表单后，我们会将数据库的详细信息保存并将用户重定向到不同的页面。在这里，我们将用户重定向到`/list-users`。当我们使用`redirect`时，Spring
    MVC会发送一个带有状态`302`的HTTP响应；也就是说，`REDIRECT`到新的URL。浏览器在处理`302`响应时，会将用户重定向到新的URL。虽然`POST`/`REDIRECT`/`GET`模式并不是解决重复表单提交问题的完美方法，但它确实减少了发生的次数，特别是在视图渲染后发生的次数。
- en: 'The code for list users is pretty straightforward and is listed as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列出用户的代码非常简单，如下所示：
- en: '[PRE25]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Unit testing
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: We will discuss unit testing when we add validations in the next flow.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在下一个流程中添加验证时，我们将讨论单元测试。
- en: Flow 6 - Adding validation to the previous flow
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程6 - 在上一个流程中添加验证
- en: In the previous flow, we added a form. However, we did not validate the values
    in the form. While we can write JavaScript to validate the form content, it is
    always secure to do validation on the server. In this flow, let's add validation
    to the form that we created earlier on the server side using Spring MVC.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个流程中，我们添加了一个表单。但是，我们没有验证表单中的值。虽然我们可以编写JavaScript来验证表单内容，但在服务器上进行验证总是更安全的。在本流程中，让我们使用Spring
    MVC在服务器端对我们之前创建的表单添加验证。
- en: Spring MVC provides great integration with the Bean Validation API. *JSR 303*
    and *JSR 349* define specifications for the the Bean Validation API (version 1.0
    and 1.1, respectively), and Hibernate Validator is the reference implementation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC与Bean Validation API提供了很好的集成。 *JSR 303*和*JSR 349*分别定义了Bean Validation
    API的规范（版本1.0和1.1），而Hibernate Validator是参考实现。
- en: Hibernate Validator dependency
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hibernate Validator依赖
- en: 'Let''s start with adding Hibernate Validator to our project `pom.xml`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将Hibernate Validator添加到我们的项目`pom.xml`开始：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Simple validations on the bean
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean上的简单验证
- en: 'The Bean Validation API specifies a number of validations that can be specified
    on attributes on the beans. Take a look at the following listing:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation API指定了可以在bean的属性上指定的一些验证。看一下以下列表：
- en: '[PRE27]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'An important thing to note are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件重要的事情如下：
- en: '`@Size(min = 6, message = "Enter at least 6 characters")` : This specifies
    that the field should at least have six characters. If the validation does not
    pass, the text from the message attribute is used as a validation error message.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Size(min = 6, message = "Enter at least 6 characters")`：指定字段至少应有六个字符。如果验证未通过，则使用消息属性中的文本作为验证错误消息。'
- en: 'Other validations that can be performed using Bean Validation are as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Bean Validation可以执行的其他验证如下：
- en: '`@NotNull`: It should not be null'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull`：它不应为null'
- en: '`@Size(min =5, max = 50)`: Maximum size of 50 characters and minimum of 5 characters.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Size(min =5, max = 50)`：最大50个字符，最小5个字符。'
- en: '`@Past`: Should be a date in the past'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Past`：应该是过去的日期'
- en: '`@Future`: Should be a future date'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Future`：应该是未来的日期'
- en: '`@Pattern`: Should match the provided regular expression'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Pattern`：应该匹配提供的正则表达式'
- en: '`@Max`: Maximum value for the field'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Max`：字段的最大值'
- en: '`@Min`: Minimum value for the field'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Min`：字段的最小值'
- en: 'Now let''s focus on getting the controller method to validate the form on submits.
    The complete method listing is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们专注于使控制器方法在提交时验证表单。完整的方法列表如下：
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Some important things are as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的事项：
- en: '`public String addTodo(@Valid User user, BindingResult result)`: When the `@Valid`
    annotation is used, Spring MVC validates the bean. The result of the validation
    is made available in the `BindingResult` instance result.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public String addTodo(@Valid User user, BindingResult result)`：当使用`@Valid`注释时，Spring
    MVC验证bean。验证的结果在`BindingResult`实例result中可用。'
- en: '`if (result.hasErrors())`: Checks whether there are any validation errors.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (result.hasErrors())`：检查是否有任何验证错误。'
- en: '`return "user"`: If there are validation errors, we send the user back to the
    user page.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return "user"`：如果有验证错误，我们将用户发送回用户页面。'
- en: 'We need to enhance the `user.jsp` to show the validation messages in case of
    validation errors. The complete list for one of the fields is shown here. Other
    fields have to be similarly updated:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要增强`user.jsp`以在验证错误时显示验证消息。其中一个字段的完整列表如下所示。其他字段也必须类似地更新：
- en: '[PRE29]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`<form:errors path="name" cssClass="text-warning"/>`: This is the Spring form
    tag to display the errors related to the field name specified in the path. We
    can also assign the CSS class used to display the validation error.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form:errors path="name" cssClass="text-warning"/>`：这是Spring表单标签，用于显示与指定路径中的字段名称相关的错误。我们还可以分配用于显示验证错误的CSS类。'
- en: Custom validations
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义验证
- en: 'More complex custom validations can be implemented using the `@AssertTrue`
    annotation. The following list an example method added to the `User` class:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`@AssertTrue`注释实现更复杂的自定义验证。以下是添加到`User`类的示例方法列表：
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`@AssertTrue(message = "Password fields don''t match")` is the message to be
    shown if the validation fails.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`@AssertTrue(message = "Password fields don''t match")`是在验证失败时要显示的消息。'
- en: Any complex validation logic with multiple fields can be implemented in these
    methods.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这些方法中实现具有多个字段的复杂验证逻辑。
- en: Unit testing
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing for this part is focused on checking for validation errors. We
    will write a test for an empty form, which triggers four validation errors.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分的单元测试重点是检查验证错误。我们将为一个空表单编写一个测试，触发四个验证错误。
- en: Controller setup
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器设置
- en: 'The controller setup is very simple:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器设置非常简单：
- en: '[PRE31]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The Test method
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试方法
- en: 'The complete `Test` method is listed as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`Test`方法如下所示：
- en: '[PRE32]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Some points to note here are as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一些要点如下：
- en: '`post("/create-user-with-validation")`: Creates an HTTP `POST` request to the
    specified URI. Since we are not passing any request parameters, all attributes
    are null. This will trigger validation errors.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post("/create-user-with-validation")`：创建到指定URI的HTTP `POST`请求。由于我们没有传递任何请求参数，所有属性都为null。这将触发验证错误。'
- en: '`model().errorCount(4)`: Checks whether there are four validation errors on
    the model.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model().errorCount(4)`：检查模型上是否有四个验证错误。'
- en: '`model().attributeHasFieldErrorCode("user", "name", "Size")`: Checks whether
    the `user` attribute has a field `name` with the validation error named `Size`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model().attributeHasFieldErrorCode("user", "name", "Size")`：检查`user`属性是否具有名为`Size`的验证错误的`name`字段。'
- en: An overview of Spring MVC
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC概述
- en: Now that we've looked at a few basic flows with Spring MVC, we will switch our
    attention to understanding how these flows work. How does the magic happen with
    Spring MVC?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了Spring MVC的一些基本流程，我们将把注意力转向理解这些流程是如何工作的。Spring MVC是如何实现魔术的？
- en: Important features
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要特性
- en: 'When working with the different flows, we looked at some of the important features
    of the Spring MVC Framework. These include the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理不同的流程时，我们看了Spring MVC框架的一些重要特性。这些包括以下内容：
- en: Loosely coupled architecture with well-defined, independent roles for each of
    the objects.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有明确定义的独立角色的松散耦合架构。
- en: Highly flexible Controller method definitions. Controller methods can have a
    varied range of parameters and return values. This gives flexibility to the programmer
    to choose the definition that meets their needs.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度灵活的控制器方法定义。控制器方法可以具有各种参数和返回值。这使程序员可以灵活选择满足其需求的定义。
- en: Allows the reuse of domain objects as form backing objects. Reduces the need
    to have separate form objects.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许重用域对象作为表单后备对象。减少了需要单独的表单对象。
- en: Built-in tag libraries (Spring, spring-form) with localization support.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有本地化支持的内置标签库（Spring，spring-form）。
- en: Model uses a HashMap with key-value pairs. Allows integration with multiple
    view technologies.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Model使用具有键值对的HashMap。允许与多个视图技术集成。
- en: Flexible binding. Type mismatches while binding can be handled as validation
    errors instead of runtime errors.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活的绑定。绑定时的类型不匹配可以作为验证错误而不是运行时错误来处理。
- en: Mock MVC Framework to unit test controllers.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟MVC框架以对控制器进行单元测试。
- en: How it works
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Key components in the Spring MVC architecture are shown in the following figure:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC架构中的关键组件如下图所示：
- en: '![](img/e7d21789-55e6-4613-802e-632509dc37b3.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7d21789-55e6-4613-802e-632509dc37b3.png)'
- en: 'Let''s look at an example flow and understand the different steps involved
    in executing the flow. We will take flow **4**, returning `ModelAndView` as the
    specific example. The URL of flow **4** is `http://localhost:8080/welcome-model-view`.
    The different steps are detailed as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例流程，并了解执行流程涉及的不同步骤。我们将采取流程**4**，返回`ModelAndView`作为具体示例。流程**4**的URL是`http://localhost:8080/welcome-model-view`。不同的步骤详细说明如下：
- en: The browser issues a request to a specific URL. DispatcherServlet is the Front
    Controller, handling all requests. So, it receives the request.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器向特定URL发出请求。DispatcherServlet是前端控制器，处理所有请求。因此，它接收请求。
- en: Dispatcher Servlet looks at the URI (in the example, `/welcome-model-view`)
    and needs to identify the right controller to handle it. To help find the right
    controller, it talks to the handler mapping.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dispatcher Servlet查看URI（在示例中为`/welcome-model-view`），并需要确定正确的控制器来处理它。为了帮助找到正确的控制器，它与处理程序映射进行通信。
- en: Handler mapping returns the specific handler method (in the example, the `welcome`
    method in `BasicModelViewController`) that handles the request.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理程序映射返回处理请求的特定处理程序方法（在示例中，`BasicModelViewController`中的`welcome`方法）。
- en: DispatcherServlet invokes the specific handler method (`public ModelAndView
    welcome(ModelMap model)`).
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DispatcherServlet调用特定的处理程序方法（`public ModelAndView welcome(ModelMap model)`）。
- en: The handler method returns the model and view. In this example, the ModelAndView
    object is returned.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理程序方法返回模型和视图。在这个例子中，返回了ModelAndView对象。
- en: DispatcherServlet has the logical view name (from ModelAndView; in this example,
    `welcome-model-view`). It needs to figure out how to determine the physical view
    name. It checks whether there are any view resolvers available. It finds the view
    resolver that was configured (`org.springframework.web.servlet.view.InternalResourceViewResolver`).
    It calls the view resolver, giving it the logical view name (in this example,
    `welcome-model-view`) as the input.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DispatcherServlet具有逻辑视图名称（来自ModelAndView；在这个例子中是`welcome-model-view`）。它需要找出如何确定物理视图名称。它检查是否有任何可用的视图解析器。它找到了配置的视图解析器（`org.springframework.web.servlet.view.InternalResourceViewResolver`）。它调用视图解析器，将逻辑视图名称（在这个例子中是`welcome-model-view`）作为输入。
- en: View resolver executes the logic to map the logical view name to the physical
    view name. In this example, `welcome-model-view` is translated to `/WEB-INF/views/welcome-model-view.jsp`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: View解析器执行逻辑以将逻辑视图名称映射到物理视图名称。在这个例子中，`welcome-model-view`被翻译为`/WEB-INF/views/welcome-model-view.jsp`。
- en: DispatcherServlet executes the View. It also makes the Model available to the
    View.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DispatcherServlet执行View。它还使Model可用于View。
- en: View returns the content to be sent back to DispatcherServlet.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: View将返回要发送回DispatcherServlet的内容。
- en: DispatcherServlet sends the response back to the browser.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DispatcherServlet将响应发送回浏览器。
- en: Important concepts behind Spring MVC
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC背后的重要概念
- en: Now that we have completed an example with Spring MVC, we are ready to understand
    the important concepts behind Spring MVC.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了一个Spring MVC示例，我们准备理解Spring MVC背后的重要概念。
- en: RequestMapping
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RequestMapping
- en: As we've discussed in earlier examples, a `RequestMapping` is used to map a
    URI to a Controller or a Controller method. It can be done at class and/or method
    levels. An optional method parameter allows us to map the method to a specific
    request method (`GET`, `POST`, and so on).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的示例中讨论的，`RequestMapping`用于将URI映射到Controller或Controller方法。它可以在类和/或方法级别完成。可选的方法参数允许我们将方法映射到特定的请求方法（`GET`，`POST`等）。
- en: Examples of request mapping
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求映射的示例
- en: A few examples in the upcoming sections illustrate the variations.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 即将出现的几个示例将说明各种变化。
- en: Example 1
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例1
- en: 'In the following example, there is only one `RequestMapping` in the `showPage`
    method. The `showPage` method will be mapped to `GET`, `POST`, and any other request
    types for URI `/show-page`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`showPage`方法中只有一个`RequestMapping`。`showPage`方法将映射到`GET`，`POST`和URI`/show-page`的任何其他请求类型：
- en: '[PRE33]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Example 2
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例2
- en: 'In the following example, there is a method defined on `RequestMapping`--`RequestMethod.GET`.
    The `showPage` method will be mapped only to the `GET` request for URI `/show-page`.
    All other request method types would throw "method not supported exception":'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，定义了一个`RequestMapping`--`RequestMethod.GET`的方法。`showPage`方法将仅映射到URI`/show-page`的`GET`请求。所有其他请求方法类型都会抛出“方法不受支持异常”：
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Example 3
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例3
- en: 'In the following example, there are two `RequestMapping` methods--one in the
    class and the other in the method. A combination of both `RequestMapping` methods
    is used to determine the URI. The `showPage` method will be mapped only to the
    `GET` request for the URI `/user/show-page`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，有两个`RequestMapping`方法--一个在类中，另一个在方法中。使用两种`RequestMapping`方法的组合来确定URI。`showPage`方法将仅映射到URI`/user/show-page`的`GET`请求：
- en: '[PRE35]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Request Mapping methods - supported method arguments
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求映射方法-支持的方法参数
- en: 'The following are some of the types of arguments that are supported in Controller
    methods with Request Mapping:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在具有RequestMapping的Controller方法中支持的一些参数类型：
- en: '| **Argument Type/Annotatio**n | **Use** |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| **参数类型/注释** | **用途** |'
- en: '| `java.util.Map` / `org.springframework.ui.Model` / `org.springframework.ui.ModelMap`
    | Acts as the model (MVC) that will be the container for values that are exposed
    to the view. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.Map` / `org.springframework.ui.Model` / `org.springframework.ui.ModelMap`
    | 作为模型（MVC），用于容纳暴露给视图的值。 |'
- en: '| Command or form objects | Used to bind request parameters to beans. Support
    for validation as well. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 命令或表单对象 | 用于将请求参数绑定到bean。还支持验证。 |'
- en: '| `org.springframework.validation.Errors` / `org.springframework.validation.BindingResult`
    | Result of validating the command or form object (the form object should be the
    immediately preceding method argument). |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `org.springframework.validation.Errors` / `org.springframework.validation.BindingResult`
    | 验证命令或表单对象的结果（表单对象应该是前一个方法参数）。 |'
- en: '| `@PreDestroy` | On any spring bean, a pre-destroy method can be provided
    using the `@PreDestroy` annotation. This method is called just before a bean is
    removed from the container. It can be used to release any resources that are held
    by the bean. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `@PreDestroy` | 在任何Spring bean上，可以使用`@PreDestroy`注解提供预销毁方法。该方法在bean从容器中移除之前调用。它可以用于释放bean持有的任何资源。
    |'
- en: '| `@RequestParam` | The annotation to access specific HTTP request parameters.
    |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `@RequestParam` | 访问特定HTTP请求参数的注解。 |'
- en: '| `@RequestHeader` | The annotation to access specific HTTP request headers.
    |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `@RequestHeader` | 访问特定HTTP请求头的注解。 |'
- en: '| `@SessionAttribute` | The annotation to access attributes from HTTP Session.
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `@SessionAttribute` | 访问HTTP会话中的属性的注解。 |'
- en: '| `@RequestAttribute` | The annotation to access specific HTTP request attributes.
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `@RequestAttribute` | 访问特定HTTP请求属性的注解。 |'
- en: '| `@PathVariable` | The annotation allows access to variables from the URI
    template. `/owner/{ownerId}`. We will look at this in depth when we discuss microservices.
    |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `@PathVariable` | 允许从URI模板中访问变量的注解。`/owner/{ownerId}`。当我们讨论微服务时，我们将深入研究这个问题。
    |'
- en: RequestMapping methods - supported return types
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RequestMapping方法-支持的返回类型
- en: 'The `RequestMapping` methods support a varied range of return types. Thinking
    conceptually, a request mapping method should answer two questions:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestMapping`方法支持各种返回类型。从概念上讲，请求映射方法应该回答两个问题：'
- en: What's the view?
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图是什么？
- en: What's the model that the view needs?
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图需要什么模型？
- en: 'However, with Spring MVC, the view and model need not be explicitly declared
    at all times:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用Spring MVC时，视图和模型不一定需要始终明确声明：
- en: If a view is not explicitly defined as part of the return type, then it is implicitly
    defined.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果视图没有明确定义为返回类型的一部分，则它是隐式定义的。
- en: Similarly, any model object is always enriched as detailed in the rules below.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，任何模型对象始终按照以下规则进行丰富。
- en: 'Spring MVC uses simple rules to determine the exact view and model. A couple
    of important rules are listed as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC使用简单的规则来确定确切的视图和模型。以下列出了一些重要的规则：
- en: '**Implicit enriching of the Model**: If a model is part of the return type,
    it is enriched with command objects (including results from validation of the
    command objects). In addition, the results of methods with the `@ModelAttribute`
    annotations are also added to the model.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型的隐式丰富**：如果模型是返回类型的一部分，则它将与命令对象（包括命令对象验证的结果）一起丰富。此外，带有`@ModelAttribute`注解的方法的结果也会添加到模型中。'
- en: '**Implicit determination of the View**: If a view name is not present in the
    return type, it is determined using `DefaultRequestToViewNameTranslator`. By default,
    `DefaultRequestToViewNameTranslator` removes the leading and trailing slashes
    as well as the file extension from the URI; for example, the `display.html` becomes
    display.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图的隐式确定**：如果返回类型中没有视图名称，则使用`DefaultRequestToViewNameTranslator`确定。默认情况下，`DefaultRequestToViewNameTranslator`会从URI中删除前导和尾随斜杠以及文件扩展名；例如，`display.html`变成了display。'
- en: 'The following are some of the return types that are supported on Controller
    methods with Request Mapping:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在带有请求映射的控制器方法上支持的一些返回类型：
- en: '| **Return Type** | **What happens?** |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **返回类型** | **发生了什么？** |'
- en: '| ModelAndView | The object includes a reference to the model and the view
    name. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| ModelAndView | 该对象包括对模型和视图名称的引用。 |'
- en: '| Model | Only Model is returned. The view name is determined using `DefaultRequestToViewNameTranslator`.
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 模型 | 只返回模型。视图名称使用`DefaultRequestToViewNameTranslator`确定。 |'
- en: '| Map | A simple map to expose a model. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| Map | 一个简单的映射来暴露模型。 |'
- en: '| View | A view with a model implicitly defined. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 视图 | 隐式定义模型的视图。 |'
- en: '| String | Reference to a view name. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| String | 视图名称的引用。 |'
- en: View resolution
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图解析
- en: 'Spring MVC provides very flexible view resolution. It provides multiple view
    options:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC提供非常灵活的视图解析。它提供多个视图选项：
- en: Integration with JSP, Freemarker.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与JSP、Freemarker集成。
- en: 'Multiple view resolution strategies. A few of them are listed as follows:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种视图解析策略。以下列出了其中一些：
- en: '`XmlViewResolver`: View resolution based on an external XML configuration'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlViewResolver`：基于外部XML配置的视图解析'
- en: '`ResourceBundleViewResolver`: View resolution based on a property file'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceBundleViewResolver`：基于属性文件的视图解析'
- en: '`UrlBasedViewResolver`: Direct mapping of the logical view name to a URL'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UrlBasedViewResolver`：将逻辑视图名称直接映射到URL'
- en: '`ContentNegotiatingViewResolver`: Delegates to other view resolvers based on
    the Accept request header'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentNegotiatingViewResolver`：根据接受请求头委托给其他视图解析器'
- en: Support for chaining of view resolvers with the explicitly defined order of
    preference.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持显式定义首选顺序的视图解析器的链接。
- en: Direct generation of XML, JSON, and Atom using Content Negotiation.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内容协商直接生成XML、JSON和Atom。
- en: Configuring JSP view resolver
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置JSP视图解析器
- en: 'The following example shows the commonly used approach to configure a JSP view
    resolver using `InternalResourceViewResolver`. The physical view name is determined
    using the configured prefix and suffix for the logical view name using `JstlView`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了配置JSP视图解析器使用`InternalResourceViewResolver`的常用方法。使用`JstlView`，通过配置的前缀和后缀确定逻辑视图名称的物理视图名称：
- en: '[PRE36]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There are other approaches using property and XML files for mapping.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他使用属性和XML文件进行映射的方法。
- en: Configuring Freemarker
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Freemarker
- en: The following example shows the typical approach used to configure a Freemarker
    view resolver.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了配置Freemarker视图解析器的典型方法。
- en: 'First, the `freemarkerConfig` bean is used to load the Freemarker templates:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`freemarkerConfig` bean用于加载Freemarker模板：
- en: '[PRE37]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following bean definition shows how to configure a Freemarker view resolver:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何配置Freemarker视图解析器的bean定义：
- en: '[PRE38]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As with JSPs, the view resolution can be defined using properties or an XML
    file.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 与JSP一样，视图解析可以使用属性或XML文件来定义。
- en: Handler mappings and Interceptors
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理程序映射和拦截器
- en: In the version before Spring 2.5 (before there was support for Annotations),
    the mapping between a URL and a Controller (also called a handler) was expressed
    using something called a handler mapping. It is almost a historical fact today.
    The use of annotations eliminated the need for an explicit handler mapping.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring 2.5之前的版本（在支持注解之前），URL和控制器（也称为处理程序）之间的映射是使用称为处理程序映射的东西来表达的。今天几乎是一个历史事实。注解的使用消除了对显式处理程序映射的需求。
- en: HandlerInterceptors can be used to intercept requests to handlers (or **controllers**).
    Sometimes, you would want to do some processing before and after a request. You
    might want to log the content of the request and response, or you might want to
    find out how much time a specific request took.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: HandlerInterceptors可用于拦截对处理程序（或**控制器**）的请求。有时，您希望在请求之前和之后进行一些处理。您可能希望记录请求和响应的内容，或者您可能想找出特定请求花费了多少时间。
- en: 'There are two steps in creating a HandlerInterceptor:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 创建HandlerInterceptor有两个步骤：
- en: Define the HandlerInterceptor.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义HandlerInterceptor。
- en: Map the HandlerInterceptor to the specific handlers to be intercepted.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HandlerInterceptor映射到要拦截的特定处理程序。
- en: Defining a HandlerInterceptor
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义HandlerInterceptor
- en: 'The following are the methods you can override in `HandlerInterceptorAdapter`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以在`HandlerInterceptorAdapter`中重写的方法：
- en: '`public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
    Object handler)`: Invoked before the handler method is invoked'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
    Object handler)`: 在调用处理程序方法之前调用'
- en: '`public void postHandle(HttpServletRequest request, HttpServletResponse response,
    Object handler, ModelAndView modelAndView)`: Invoked after the handler method
    is invoked'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void postHandle(HttpServletRequest request, HttpServletResponse response,
    Object handler, ModelAndView modelAndView)`: 在调用处理程序方法后调用'
- en: '`public void afterCompletion(HttpServletRequest request, HttpServletResponse
    response, Object handler, Exception ex)`: Invoked after the request processing
    is complete'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void afterCompletion(HttpServletRequest request, HttpServletResponse
    response, Object handler, Exception ex)`: 在请求处理完成后调用'
- en: 'The following example implementation shows how to create a HandlerInterceptor.
    Let''s start with creating a new class that extends `HandlerInterceptorAdapter`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例实现显示了如何创建HandlerInterceptor。让我们从创建一个扩展`HandlerInterceptorAdapter`的新类开始：
- en: '[PRE39]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `preHandle` method is invoked before the handler is called. Let''s place
    an attribute on the request, indicating the start time of handler invocation:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`preHandle`方法在调用处理程序之前被调用。让我们在请求上放置一个属性，指示处理程序调用的开始时间：'
- en: '[PRE40]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `postHandle` method is invoked after the handler is called. Let''s place
    an attribute on the request, indicating the end time of the handler invocation:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`postHandle`方法在调用处理程序后被调用。让我们在请求上放置一个属性，指示处理程序调用的结束时间：'
- en: '[PRE41]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `afterCompletion` method is invoked after the request processing is complete.
    We will identify the time spent in the handler using the attributes that we set
    into the request earlier:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`afterCompletion`方法在请求处理完成后被调用。我们将使用我们之前设置到请求中的属性来识别处理程序中花费的时间：'
- en: '[PRE42]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Mapping HandlerInterceptor to handlers
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HandlerInterceptor映射到处理程序
- en: 'HandlerInterceptors can be mapped to specific URLs you would want to intercept.
    The following example shows an example XML context configuration. By default,
    the interceptor will intercept all handlers (**controllers**):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: HandlerInterceptors可以映射到您希望拦截的特定URL。以下示例显示了一个示例XML上下文配置。默认情况下，拦截器将拦截所有处理程序（**控制器**）：
- en: '[PRE43]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can configure precise URIs to be intercepted. In the following example,
    all handlers except those with URI mapping starting with `/secure/`are intercepted:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置精确的URI进行拦截。在下面的示例中，除了以`/secure/`开头的URI映射的处理程序之外，所有处理程序都会被拦截：
- en: '[PRE44]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Model attributes
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型属性
- en: Common web forms contain a number of drop-down values--the list of states, the
    list of countries, and so on. These lists of values need to be available in the
    model so that the view can display the list. Such common things are typically
    populated into the model using methods that are marked with `@ModelAttribute`
    annotations.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的Web表单包含许多下拉值--州的列表，国家的列表等等。这些值列表需要在模型中可用，以便视图可以显示列表。这些常见的东西通常使用标有`@ModelAttribute`注解的方法填充到模型中。
- en: 'There are two variations possible. In the following example, the method returns
    the object that needs to be put into the model:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能的变体。在下面的示例中，该方法返回需要放入模型中的对象：
- en: '[PRE45]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The approach in this example is used to add multiple attributes to the model:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的方法用于向模型添加多个属性：
- en: '[PRE46]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: An important thing to note is that there is no limitation to the number of methods
    that can be marked with the `@ModelAttribute` annotation.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是，可以标记为`@ModelAttribute`注解的方法数量没有限制。
- en: Model attributes can be made common across multiple controllers using Controller
    Advice. We will discuss Controller Advice later in this section.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Controller Advice可以使模型属性在多个控制器中变得通用。我们将在本节后面讨论Controller Advice。
- en: Session attributes
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话属性
- en: All the attributes and values that we discussed until now are used within a
    single request. However, there might be values such as a specific web user configuration
    that might not change across requests. These kinds of values will typically be
    stored in an HTTP session. Spring MVC provides a simple type level (class level)
    annotation `@SessionAttributes` to specify the attributes that would be stored
    in the session.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的所有属性和值都是在单个请求中使用的。但是，可能存在值（例如特定的Web用户配置）在请求之间不会发生变化。这些类型的值通常将存储在HTTP会话中。Spring
    MVC提供了一个简单的类型级别（类级别）注释`@SessionAttributes`，用于指定要存储在会话中的属性。
- en: 'Take a look at the following example:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例：
- en: '[PRE47]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Putting an attribute in the session
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将属性放入会话中
- en: Once we define an attribute in the `@SessionAttributes` annotation, it is automatically
    added to the session if the same attribute is added to the model.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`@SessionAttributes`注释中定义了一个属性，如果将相同的属性添加到模型中，它将自动添加到会话中。
- en: 'In the preceding example, if we put an attribute with the name `exampleSessionAttribute`
    into the model, it would be automatically stored into the session conversation
    state:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果我们将一个名为`exampleSessionAttribute`的属性放入模型中，它将自动存储到会话对话状态中：
- en: '[PRE48]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Reading an attribute from the session
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从会话中读取属性
- en: 'This value can be accessed in other controllers by first specifying the `@SessionAttributes`
    annotation at a type level:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在类型级别指定`@SessionAttributes`注释，然后可以在其他控制器中访问此值：
- en: '[PRE49]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The value of the session attribute will be directly made available to all model
    objects. So, it can be accessed from the model:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 会话属性的值将直接提供给所有模型对象。因此，可以从模型中访问：
- en: '[PRE50]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Removing an attribute from the session
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从会话中删除属性
- en: 'It is important to remove values from the session when they are no longer needed.
    There are two ways in which we can remove values from the session conversational
    state. The first way is demonstrated in the following snippet. It uses the `removeAttribute`
    method available in the `WebRequest` class:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要会话中的值时，将其从会话中删除非常重要。我们可以通过两种方式从会话对话状态中删除值。第一种方式在以下代码片段中进行了演示。它使用`WebRequest`类中可用的`removeAttribute`方法：
- en: '[PRE51]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This example shows the second approach using the `cleanUpAttribute` method
    in `SessionAttributeStore`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了使用`SessionAttributeStore`中的`cleanUpAttribute`方法的第二种方法：
- en: '[PRE52]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: InitBinders
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InitBinders
- en: Typical web forms have dates, currencies, and amounts. The values in the forms
    need to be bound to the form backing objects. Customization of how binding happens
    can be introduced using the `@InitBinder` annotation.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Web表单包含日期、货币和金额。表单中的值需要绑定到表单后端对象。可以使用`@InitBinder`注释引入绑定发生的自定义。
- en: 'Customization can be done in a specific controller or a set of controllers
    using Handler Advice. This example shows how to set the default date format to
    use for form binding:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Handler Advice在特定控制器或一组控制器中进行自定义。此示例显示了如何设置用于表单绑定的默认日期格式：
- en: '[PRE53]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The @ControllerAdvice annotation
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ControllerAdvice注释'
- en: Some of the functionality we defined at the controller level can be common across
    the application. For example, we might want to use the same date format across
    the application. So, `@InitBinder` that we defined earlier can be applicable across
    the application. How do we achieve that? `@ControllerAdvice` helps us make the
    functionality common across all Request Mappings by default.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制器级别定义的一些功能可能在整个应用程序中是通用的。例如，我们可能希望在整个应用程序中使用相同的日期格式。因此，我们之前定义的`@InitBinder`可以适用于整个应用程序。我们如何实现？`@ControllerAdvice`可以帮助我们使功能在默认情况下在所有请求映射中通用。
- en: 'For example, consider the Controller advice example listed here. We use a `@ControllerAdvice`
    annotation on the class and define the method with `@InitBinder` in this class.
    By default, the binding defined in this method is applicable to all request mappings:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑此处列出的Controller建议示例。我们在类上使用`@ControllerAdvice`注释，并在此类中使用`@InitBinder`定义方法。默认情况下，此方法中定义的绑定适用于所有请求映射：
- en: '[PRE54]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Controller advice can also be used to define common model attributes (`@ModelAttribute`)
    and common exception handling (`@ExceptionHandler`). All you would need to do
    is create methods marked with appropriate annotations. We will discuss exception
    handling in the next section.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Controller建议还可以用于定义公共模型属性（`@ModelAttribute`）和公共异常处理（`@ExceptionHandler`）。您只需要创建带有适当注释的方法。我们将在下一节讨论异常处理。
- en: Spring MVC - advanced features
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC - 高级功能
- en: 'In this section, we will discuss about advanced features related to Spring
    MVC, including the following:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论与Spring MVC相关的高级功能，包括以下内容：
- en: How do we implement generic exception handling for the web application?
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为Web应用程序实现通用异常处理？
- en: How do we internationalize messages?
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何国际化消息？
- en: How do we write integration tests?
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写集成测试？
- en: How do we expose static content and integrate with frontend frameworks like
    Bootstrap?
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何公开静态内容并与前端框架（如Bootstrap）集成？
- en: How do we secure our web application with Spring Security?
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Spring Security保护我们的Web应用程序？
- en: Exception handling
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Exception handling is one of the critical parts of any application. It is very
    important to have a consistent exception handling strategy across the application.
    One of the popular misconceptions is that only bad applications need exception
    handling. Nothing can be further from the truth. Even well-designed, well-written
    applications need good exception handling.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是任何应用程序的关键部分之一。在整个应用程序中拥有一致的异常处理策略非常重要。一个流行的误解是，只有糟糕的应用程序才需要异常处理。事实并非如此。即使设计良好、编写良好的应用程序也需要良好的异常处理。
- en: Before the emergence of the Spring Framework, exception handling code was needed
    across application code due to the wide use of checked exceptions. For example,
    most of the JDBC methods threw checked exceptions, requiring a try catch to handle
    the exception in every method (unless you would want to declare that the method
    throws a JDBC exception). With Spring Framework, most of the exceptions were made
    unchecked exceptions. This made sure that, unless specific exception handling
    was needed, exception handling could be handled generically across the application.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Framework出现之前，由于受检异常的广泛使用，需要在应用程序代码中处理异常处理代码。例如，大多数JDBC方法抛出受检异常，需要在每个方法中使用try
    catch来处理异常（除非您希望声明该方法抛出JDBC异常）。使用Spring Framework，大多数异常都变成了未经检查的异常。这确保除非需要特定的异常处理，否则可以在整个应用程序中通用地处理异常。
- en: 'In this section, we will look at couple of example implementations of exception
    handling as follows:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下异常处理的几个示例实现：
- en: Common exception handling across all controllers
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有控制器中的通用异常处理
- en: Specific exception handling for a Controller
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器的特定异常处理
- en: Common exception handling across controllers
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨控制器的通用异常处理
- en: Controller advice can also be used to implement common exception handling across
    controllers.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Controller Advice也可以用于实现跨控制器的通用异常处理。
- en: 'Take a look at the following code:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE55]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Some things to note are as follows:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的事项：
- en: '`@ControllerAdvice`: Controller Advice, by default, is applicable to all controllers.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ControllerAdvice`：Controller Advice，默认情况下适用于所有控制器。'
- en: '`@ExceptionHandler(value = Exception.class)`: Any method with this annotation
    will be called when an exception of the type or the sub-type of the class specified(`Exception.class`)
    is thrown in the controllers.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ExceptionHandler(value = Exception.class)`：当控制器中抛出指定类型（`Exception.class`）或子类型的异常时，将调用带有此注解的任何方法。'
- en: '`public ModelAndView handleException (HttpServletRequest request, Exception
    ex)`: The exception that is thrown is injected into the Exception variable. The
    method is declared with a ModelAndView return type to be able to return a model
    with the exception details and an exception view.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public ModelAndView handleException (HttpServletRequest request, Exception
    ex)`：抛出的异常被注入到Exception变量中。该方法声明为ModelAndView返回类型，以便能够返回一个带有异常详细信息和异常视图的模型。'
- en: '`mav.addObject("exception", ex)`: Adding the exception to the model so that
    the exception details can be shown in the view.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mav.addObject("exception", ex)`：将异常添加到模型中，以便在视图中显示异常详细信息。'
- en: '`mav.setViewName("common/spring-mvc-error")`: The exception view.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mav.setViewName("common/spring-mvc-error")`：异常视图。'
- en: The error view
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误视图
- en: 'Whenever an exception happens, `ExceptionController` redirects the user to
    the `ExceptionController` spring-mvc-error view after populating the model with
    exception details. The following snippet shows the complete jsp `/WEB-INF/views/common/spring-mvc-error.jsp`:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生异常时，`ExceptionController`在填充模型的异常详细信息后将用户重定向到`ExceptionController`的spring-mvc-error视图。以下代码片段显示了完整的jsp`/WEB-INF/views/common/spring-mvc-error.jsp`：
- en: '[PRE56]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Important things to note are as follows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项如下：
- en: '`URL: ${url}`: Shows the URL from the model.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL: ${url}`：显示模型中的URL。'
- en: '`Exception: ${exception.message}`: Displays the exception message. The exception
    is populated into the model from `ExceptionController`.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception: ${exception.message}`：显示异常消息。异常是从`ExceptionController`中填充到模型中的。'
- en: '`forEach around ${exceptionStackTrace}`: Displays the stack trace from exception
    handling specific to `ExceptionController`.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach around ${exceptionStackTrace}`：显示特定于`ExceptionController`的异常处理的堆栈跟踪。'
- en: Specific exception handling in a Controller
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器中的特定异常处理
- en: In some situations, there is a need for specific exception handling in a Controller.
    This situation can easily be handled by implementing a method annotated with `@ExceptionHandler(value
    = Exception.class)`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，控制器需要特定的异常处理。可以通过实现一个带有`@ExceptionHandler(value = Exception.class)`注解的方法来轻松处理这种情况。
- en: In case specific exception handling is needed only for a specific exception,
    the specific exception class can be provided as the value for the value attribute
    of the annotation.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要针对特定异常进行特定异常处理，则可以将特定异常类提供为注解的value属性的值。
- en: Internationalization
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: When we develop applications, we would want them to be usable in multiple locales.
    You would want the text that is shown to the user to be customized based on the
    location and language of the user. This is called **internationalization**. Internationalization,
    `i18n`, is also called **Localization**.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发应用程序时，希望它们能够在多个区域设置中使用。您希望根据用户的位置和语言定制向用户显示的文本。这称为**国际化**。国际化，`i18n`，也称为**本地化**。
- en: 'It can be implemented using two approaches:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种方法实现：
- en: '`SessionLocaleResolver`'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SessionLocaleResolver`'
- en: '`CookieLocaleResolver`'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CookieLocaleResolver`'
- en: In the case of `SessionLocaleResolver`, the locale chosen by the user is stored
    in the user session and, therefore, is valid for the user session only. However,
    in the case of a `CookieLocaleResolver`, the locale chosen is stored as a cookie.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SessionLocaleResolver`的情况下，用户选择的区域设置存储在用户会话中，因此仅对用户会话有效。但是，在`CookieLocaleResolver`的情况下，选择的区域设置存储为cookie。
- en: Message bundle setup
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息包设置
- en: 'First, let''s set up a message bundler. The code snippet from the spring context
    is as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个消息绑定器。来自spring上下文的代码片段如下：
- en: '[PRE57]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Important points to note are as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项如下：
- en: '`class="org.springframework.context.support.ReloadableResourceBundleMessageSource"`:
    We are configuring a reloadable resource bundle. Support reloading properties
    through the cacheSeconds setting.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class="org.springframework.context.support.ReloadableResourceBundleMessageSource"`：我们正在配置一个可重新加载的资源包。通过cacheSeconds设置支持重新加载属性。'
- en: '`<property name="basename" value="classpath:messages" />`: Configure the loading
    of properties from the `messages.properties` and `messages_{locale}.properties
    file`. We will discuss the locale soon.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<property name="basename" value="classpath:messages" />`：配置从`messages.properties`和`messages_{locale}.properties`文件中加载属性。我们将很快讨论语言环境。'
- en: 'Let''s configure a couple of property files and make them available in the
    `src/main/resources folder`:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置一些属性文件，并使它们在`src/main/resources`文件夹中可用：
- en: '[PRE58]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can display the message from the message bundle in a view using the `spring:message`
    tag:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`spring:message`标签在视图中显示来自消息包的消息：
- en: '[PRE59]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Configuring a SessionLocaleResolver
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置SessionLocaleResolver
- en: 'There are two parts to configuring a `SessionLocaleResolver`. The first one
    is to configure a `localeResolver`. The second one is to configure an interceptor
    to handle the change in locale:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 配置`SessionLocaleResolver`有两个部分。第一个是配置`localeResolver`。第二个是配置拦截器来处理语言环境的更改：
- en: '[PRE60]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Important things to note are as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项如下：
- en: '`<property name="defaultLocale" value="en" />`: By default, `en` locale is
    used.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<property name="defaultLocale" value="en" />`：默认情况下使用`en`语言环境。'
- en: '`<mvc:interceptors>`: `LocaleChangeInterceptor` is configured as a HandlerInterceptor.
    It would intercept all the handler requests and check for the locale.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<mvc:interceptors>`：`LocaleChangeInterceptor`被配置为HandlerInterceptor。它将拦截所有处理程序请求并检查语言环境。'
- en: '`<property name="paramName" value="language" />`: `LocaleChangeInterceptor`
    is configured to use a request param name called language to indicate the locale.
    So, any URL of the `http://server/uri?language={locale}` format would trigger
    a change in the locale.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<property name="paramName" value="language" />`：`LocaleChangeInterceptor`被配置为使用名为language的请求参数来指示语言环境。因此，任何`http://server/uri?language={locale}`格式的URL都会触发语言环境的更改。'
- en: If you append `language=en` to any URL, you would be using `en` locale for the
    duration of the session. If you append `language=fr` to any URL, then you would
    be using a French locale.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在任何URL后附加`language=en`，则会在会话期间使用`en`语言环境。如果您在任何URL后附加`language=fr`，则会使用法语语言环境。
- en: Configuring a CookieLocaleResolver
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置CookieLocaleResolver
- en: 'We use a `CookieLocaleResolver` in the following example:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用`CookieLocaleResolver`：
- en: '[PRE61]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Important things to note are as follows:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项如下：
- en: '`<property name="cookieName" value="userLocaleCookie"/>`: The name of the cookie
    stored in the browser will be `userLocaleCookie`.'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<property name="cookieName" value="userLocaleCookie"/>`：存储在浏览器中的cookie的名称将是`userLocaleCookie`。'
- en: '`<property name="cookieMaxAge" value="7200"/>`: The lifetime of the cookie
    is 2 hours (`7200` seconds).'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<property name="cookieMaxAge" value="7200"/>`：cookie的生存期为2小时（`7200`秒）。'
- en: Since we are using `LocaleChangeInterceptor` from the previous example, if you
    append `language=en` to any URL, you would be using `en` locale for a duration
    of 2 hours (or until the locale is changed). If you append `language=fr` to any
    URL, then you would be using a French locale for 2 hours (or until locale is changed).
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们在前一个示例中使用了`LocaleChangeInterceptor`，如果您在任何URL后附加`language=en`，则会在2小时内（或直到语言环境更改）使用`en`语言环境。如果您在任何URL后附加`language=fr`，则会在2小时内（或直到语言环境更改）使用法语语言环境。
- en: Integration testing Spring controllers
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试Spring控制器
- en: In the flows we discussed, we looked at using real unit tests--ones that only
    load up the specific controllers that are being tested.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的流程中，我们考虑使用真正的单元测试--只加载正在测试的特定控制器。
- en: 'Another possibility is to load up the entire Spring context. However, this
    would be more of an integration test as we would load up the entire context. The
    following code shows you how to do a complete launch of a Spring context, launching
    all controllers:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是加载整个Spring上下文。但是，这将更多地是一个集成测试，因为我们将加载整个上下文。以下代码向您展示了如何启动Spring上下文，启动所有控制器：
- en: '[PRE62]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'A few things to note are as follows:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些事项如下：
- en: '`@RunWith(SpringRunner.class)`: `SpringRunner` helps us launch a Spring context.'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RunWith(SpringRunner.class)`：`SpringRunner`帮助我们启动Spring上下文。'
- en: '`@WebAppConfiguration`: Used to launch a web app context with Spring MVC'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WebAppConfiguration`：用于使用Spring MVC启动Web应用程序上下文'
- en: '`@ContextConfiguration("file:src/main/webapp/WEB-INF/user-web-context.xml")`:
    Specifies the location of the spring context XML.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ContextConfiguration("file:src/main/webapp/WEB-INF/user-web-context.xml")`：指定spring上下文XML的位置。'
- en: '`this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build()`: In the
    earlier examples, we used a standalone setup. However, in this example, we want
    to launch the entire web app. So, we use `webAppContextSetup`.'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build()`：在之前的示例中，我们使用了独立设置。但是，在这个示例中，我们想要启动整个Web应用程序。因此，我们使用`webAppContextSetup`。'
- en: The execution of the test is very similar to how we did it in earlier tests.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的执行与我们之前的测试非常相似。
- en: Serving static resources
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态资源
- en: Most teams today have separate teams delivering frontend and backend content.
    The frontend is developed with modern JavaScript frameworks, such as AngularJs,
    Backbone, and so on. Backend is built through web applications or REST services
    based on frameworks such as Spring MVC.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数团队都有专门的团队提供前端和后端内容。前端使用现代的JavaScript框架开发，如AngularJs，Backbone等。后端是通过基于Spring
    MVC等框架构建的Web应用程序或REST服务。
- en: With this evolution in frontend frameworks, it is very important to find the
    right solutions to version and deliver frontend static content.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 随着前端框架的发展，找到正确的解决方案来版本化和交付前端静态内容非常重要。
- en: 'The following are some of the important features provided by the Spring MVC
    framework:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Spring MVC框架提供的一些重要功能：
- en: They expose static content from folders in the web application root
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们从Web应用程序根目录中的文件夹中公开静态内容
- en: They enable caching
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们启用了缓存
- en: They enable GZip compression of static content
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们启用了静态内容的GZip压缩
- en: Exposing static content
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公开静态内容
- en: 'Web applications typically have a lot of static content. Spring MVC provides
    options to expose static content from folders on the web application root as well
    locations on the classpath. The following snippet shows that content within the
    war can be exposed as static content:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序通常具有大量静态内容。Spring MVC提供了从Web应用程序根目录中的文件夹或类路径上的位置公开静态内容的选项。以下代码片段显示了war中的内容可以公开为静态内容：
- en: '[PRE63]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Things to note are as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的事项如下：
- en: '`location="/static-resources/"`: The location specifies the folders inside
    the war or classpath that you would want to expose as static content. In this
    example, we want to expose all the content in the `static-resources` folder inside
    the root of war as static content. We can specify multiple comma-separated values
    to expose multiple folders under the same external facing URI.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location="/static-resources/"`：位置指定war或类路径中要公开为静态内容的文件夹。在此示例中，我们希望将根目录中`static-resources`文件夹中的所有内容公开为静态内容。我们可以指定多个逗号分隔的值以在相同的外部URI下公开多个文件夹。'
- en: '`mapping="/resources/**"`: The mapping specifies the external facing URI path.
    So, a CSS file named `app.css` inside the static-resources folder can be accessed
    using the `/resources/app.css` URI.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapping="/resources/**"`：映射指定外部URI路径。因此，静态资源文件夹中名为`app.css`的CSS文件可以使用`/resources/app.css`
    URI进行访问。'
- en: 'The complete Java configuration for the same configuration is shown here:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 相同配置的完整Java配置在此处显示：
- en: '[PRE64]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Caching static content
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存静态内容
- en: 'Caching for static resources can be enabled for improved performance. The browser
    would cache the resources served for the specified time period. The `cache-period`
    attribute or the `setCachePeriod` method can be used to specify the caching interval
    (in seconds) based on the type of configuration used. The following snippets show
    the details:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 可以启用静态资源的缓存以提高性能。浏览器将缓存为指定时间段提供的资源。可以使用`cache-period`属性或`setCachePeriod`方法来指定基于使用的配置类型的缓存间隔（以秒为单位）。以下代码片段显示了详细信息：
- en: 'This is the Java configuration:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Java配置：
- en: '[PRE65]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This is the XML configuration:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这是XML配置：
- en: '[PRE66]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `Cache-Control: max-age={specified-max-age}` response header will be sent
    to the browser.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '将发送`Cache-Control: max-age={specified-max-age}`响应头到浏览器。'
- en: Enabling GZip compression of static content
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用静态内容的GZip压缩
- en: Compressing a response is a simple way to make web applications faster. All
    modern browsers support GZip compression. Instead of sending the full static content
    file, a compressed file can be sent as a response. The browser will decompress
    and use the static content.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩响应是使Web应用程序更快的一种简单方法。所有现代浏览器都支持GZip压缩。可以发送压缩文件作为响应，而不是发送完整的静态内容文件。浏览器将解压并使用静态内容。
- en: The browser can specify that it can accept the compressed content with a request
    header. If the server supports it, it can deliver the compressed content--again,
    marked with a response header.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器可以指定它可以接受压缩内容的请求头。如果服务器支持，它可以传递压缩内容-再次标记为响应头。
- en: 'Request Header sent from browser is as follows:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器发送的请求头如下：
- en: '[PRE67]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Response Header sent from the web application is as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Web应用程序的响应头如下：
- en: '[PRE68]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following snippet shows how to add a Gzip resolver to deliver compressed
    static content:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何添加Gzip解析器以提供压缩的静态内容：
- en: '[PRE69]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Things to note are as follows:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的事项如下：
- en: '`resourceChain(true)`: We would want to enable Gzip compression, but would
    want to fall back to delivering the full file if full file was requested. So,
    we use resource chaining (chaining of resource resolvers).'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resourceChain(true)`：我们希望启用Gzip压缩，但希望在请求完整文件时返回完整文件。因此，我们使用资源链（资源解析器的链接）。'
- en: '`addResolver(new PathResourceResolver()): PathResourceResolver`: This is the
    default resolver. It resolves based on the resource handlers and locations configured.'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addResolver(new PathResourceResolver()): PathResourceResolver`：这是默认解析器。它根据配置的资源处理程序和位置进行解析。'
- en: '`addResolver(new GzipResourceResolver()): GzipResourceResolver`: This enables
    Gzip compression when requested.'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addResolver(new GzipResourceResolver()): GzipResourceResolver`：当请求时启用Gzip压缩。'
- en: Integrating Spring MVC with Bootstrap
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Spring MVC与Bootstrap集成
- en: One of the approaches to using Bootstrap in a web application is to download
    the JavaScript and CSS files and make them available in their respective folders.
    However, this would mean that every time there is a new version of Bootstrap,
    we would need to download and make it available as part of the source code. The
    question is this--is there a way that we can introduce Bootstrap or any other
    static (JS or CSS) libraries using dependency management such as Maven?
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中使用Bootstrap的一种方法是下载JavaScript和CSS文件，并将它们放在各自的文件夹中。但是，这意味着每次有新版本的Bootstrap时，我们都需要下载并将其作为源代码的一部分提供。问题是这样的-是否有办法可以通过Maven等依赖管理引入Bootstrap或任何其他静态（JS或CSS）库？
- en: The answer is WebJars. WebJars are client-side JS or CSS libraries packaged
    into JAR files. We can use Java build tools (Maven or Gradle) to download and
    make them available to the application. The biggest advantage is that WebJars
    are resolve transitive dependencies.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是WebJars。WebJars是打包成JAR文件的客户端JS或CSS库。我们可以使用Java构建工具（Maven或Gradle）来下载并使它们可用于应用程序。最大的优势是WebJars可以解析传递依赖关系。
- en: 'Now let''s use Bootstrap WebJar and include it in our web application. The
    steps involved are as follows:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Bootstrap WebJar并将其包含在我们的Web应用程序中。涉及的步骤如下：
- en: Add Bootstrap WebJars as a Maven dependency
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Bootstrap WebJars作为Maven依赖项添加
- en: Configure the Spring MVC resource handler to deliver static content from WebJar
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring MVC资源处理程序以从WebJar提供静态内容
- en: Use Bootstrap resources (CSS and JS) in the JSP
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JSP中使用Bootstrap资源（CSS和JS）
- en: Bootstrap WebJar as Maven dependency
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bootstrap WebJar作为Maven依赖项
- en: 'Let''s add this to the `pom.xml` file:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到`pom.xml`文件中：
- en: '[PRE70]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Configure Spring MVC resource handler to deliver WebJar static content
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Spring MVC资源处理程序以提供WebJar静态内容
- en: 'This is very simple. We need to add the following mapping to the spring context:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。我们需要将以下映射添加到spring上下文中：
- en: '[PRE71]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With this configuration, `ResourceHttpRequestHandler` makes the content from
    WebJars available as static content.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此配置，`ResourceHttpRequestHandler`使来自WebJars的内容可用作静态内容。
- en: As discussed in the section on static content, we can specifically cache a period
    if we want to cache the content.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如静态内容部分所讨论的，如果我们想要缓存内容，我们可以特别缓存一段时间。
- en: Using Bootstrap resources in JSP
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JSP中使用引导资源
- en: 'We can add bootstrap resources just like other static resources in the JSP:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像JSP中的其他静态资源一样添加引导资源：
- en: '[PRE72]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Spring Security
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security
- en: A critical part of web applications is authentication and authorization. Authentication
    is the process of establishing a user's identity, verifying that the user is who
    he/she claims to be. Authorization is checking whether the user has access to
    perform a specific action. Authorization specifies the access a user has. Can
    the user view a page? Can the user edit a page? Can the user delete a page?
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的关键部分是身份验证和授权。身份验证是建立用户身份的过程，验证用户是否是他/她声称的人。授权是检查用户是否有权执行特定操作。授权指定用户的访问权限。用户能否查看页面？用户能否编辑页面？用户能否删除页面？
- en: A best practice is to enforce authentication and authorization on every page
    in the application. User credentials and authorization should be verified before
    executing any request to a web application.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是在应用程序的每个页面上强制进行身份验证和授权。在执行对Web应用程序的任何请求之前，应验证用户凭据和授权。
- en: Spring Security provides a comprehensive security solution for Java EE enterprise
    applications. While providing great support to Spring-based (and Spring MVC-based)
    applications, it can be integrated with other frameworks as well.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security为Java EE企业应用程序提供了全面的安全解决方案。虽然为基于Spring（和基于Spring MVC的）应用程序提供了很好的支持，但它也可以与其他框架集成。
- en: 'The following list highlights some of vast range of authentication mechanisms
    that Spring Security supports:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表突出显示了Spring Security支持的广泛范围的身份验证机制中的一些：
- en: '**Form-based authentication**: Simple integration for basic applications'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于表单的身份验证**：基本应用程序的简单集成'
- en: '**LDAP**: Typically used in most Enterprise applications'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LDAP**：通常在大多数企业应用程序中使用'
- en: '**Java Authentication and Authorization Service (JAAS)**: Authentication and
    authorization standard; part of Java EE standard specification'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java身份验证和授权服务（JAAS）**：身份验证和授权标准；Java EE标准规范的一部分'
- en: Container managed authentication
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器管理的身份验证
- en: Custom authentication systems
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义身份验证系统
- en: Let's consider a simple example to enable Spring Security on simple web application.
    We will use an in-memory configuration.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的示例，在简单的Web应用程序上启用Spring Security。我们将使用内存配置。
- en: 'The steps involved are as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的步骤如下：
- en: Add Spring Security dependency.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Spring Security依赖。
- en: Configure the interception of all requests.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置拦截所有请求。
- en: Configure Spring Security.
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Spring Security。
- en: Add the logout functionality.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加注销功能。
- en: Adding Spring Security dependency
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Spring Security依赖
- en: 'We will start with adding the Spring Security dependencies to `pom.xml`:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从向`pom.xml`添加Spring Security依赖开始：
- en: '[PRE73]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The dependencies added in are `spring-security-web` and `spring-security-config`.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的依赖是`spring-security-web`和`spring-security-config`。
- en: Configuring a filter to intercept all requests
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置过滤器以拦截所有请求
- en: The best practice when implementing security is to validate all incoming requests.
    We would want our security framework to look at the incoming request, authenticate
    the user and allow the action to be performed only if the user has access to perform
    the operation. We will make use of a filter to intercept and validate the request.
    The following example shows more details.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施安全性时的最佳实践是验证所有传入请求。我们希望我们的安全框架查看传入请求，对用户进行身份验证，并仅在用户有权执行操作时才允许执行操作。我们将使用过滤器拦截和验证请求。以下示例显示了更多细节。
- en: 'We would want to configure Spring Security to intercept all requests to a web
    application. We will use a filter, `DelegatingFilterProxy`, which delegates to
    a Spring-managed bean `FilterChainProxy`:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望配置Spring Security拦截对Web应用程序的所有请求。我们将使用一个过滤器`DelegatingFilterProxy`，它委托给一个Spring管理的bean`FilterChainProxy`：
- en: '[PRE74]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, all requests to our web application will go through the filter. However,
    we have not configured anything related to security yet. Let''s use a simple Java
    configuration example:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有对我们Web应用程序的请求都将通过过滤器。但是，我们尚未配置与安全相关的任何内容。让我们使用一个简单的Java配置示例：
- en: '[PRE75]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Things to note are as follows:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的事项如下：
- en: '`@EnableWebSecurity`: This annotation enables any Configuration class to contain
    the definition of Spring Configuration. In this specific instance, we override
    a couple of methods to provide our specific Spring MVC configuration.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableWebSecurity`：此注解使任何配置类能够包含Spring配置的定义。在这种特定情况下，我们重写了一些方法，以提供我们特定的Spring
    MVC配置。'
- en: '`WebSecurityConfigurerAdapter`: This class provides a base class to create
    a Spring configuration (`WebSecurityConfigurer`).'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebSecurityConfigurerAdapter`：此类提供了创建Spring配置（`WebSecurityConfigurer`）的基类。'
- en: '`protected void configure(HttpSecurity http)`: This method provides the security
    needs for different URLs.'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected void configure(HttpSecurity http)`: 此方法为不同URL提供安全需求。'
- en: '`antMatchers("/*secure*/**").access("hasRole(''USER'')")`: You would need a
    role of USER to access any URL containing the sub-string `secure`.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`antMatchers("/*secure*/**").access("hasRole(''USER'')"`: 您需要具有用户角色才能访问包含子字符串`secure`的任何URL。'
- en: '`antMatchers("/login").permitAll()`: Permits access to the login page to all
    users.'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`antMatchers("/login").permitAll()`: 允许所有用户访问登录页面。'
- en: '`public void configureGlobalSecurity(AuthenticationManagerBuilder auth)`: In
    this example, we are using in-memory authentication. This can be used to connect
    to a database (`auth.jdbcAuthentication()`), or an LDAP(`auth.ldapAuthentication()`),
    or a custom authentication provider (created extending `AuthenticationProvider`).'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void configureGlobalSecurity(AuthenticationManagerBuilder auth)`: 在此示例中，我们使用内存身份验证。这可以用于连接到数据库（`auth.jdbcAuthentication()`），或LDAP（`auth.ldapAuthentication()`），或自定义身份验证提供程序（扩展`AuthenticationProvider`创建）。'
- en: '`withUser("firstuser").password("password1")`: Configures an in-memory valid
    user ID and password combination.'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withUser("firstuser").password("password1")`: 配置内存中有效的用户ID和密码组合。'
- en: '`.roles("USER", "ADMIN")`: Assigns roles to the user.'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.roles("USER", "ADMIN")`: 为用户分配角色。'
- en: When we try to access any secure URLs, we will be redirected to a login page.
    Spring Security provides ways of customizing the Logic page as well as the redirection.
    Only authenticated users with the right roles will be allowed to access the secured
    application pages.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试访问任何安全的URL时，我们将被重定向到登录页面。Spring Security提供了自定义逻辑页面以及重定向的方式。只有具有正确角色的经过认证的用户才能访问受保护的应用程序页面。
- en: Logout
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注销
- en: 'Spring Security provides features to enable a user to log out and be redirected
    to a specified page. The URI of the `LogoutController` is typically mapped to
    the Logout link in the UI. The complete listing of `LogoutController` is as follows:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security提供了功能，使用户能够注销并被重定向到指定页面。`LogoutController`的URI通常映射到UI中的注销链接。`LogoutController`的完整列表如下：
- en: '[PRE76]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Things to note are as follows:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是：
- en: '`if (auth != null)`: If there is a valid authentication, then end the session'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (auth != null)`: 如果有有效的认证，那么结束会话'
- en: '`new SecurityContextLogoutHandler().logout(request, response, auth)`: `SecurityContextLogoutHandler`
    performs a logout by removing the authentication information from `SecurityContextHolder`'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new SecurityContextLogoutHandler().logout(request, response, auth)`: `SecurityContextLogoutHandler`通过从`SecurityContextHolder`中删除认证信息来执行注销'
- en: '`return "redirect:/secure/welcome"`: Redirects to the secure welcome page'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return "redirect:/secure/welcome"`: 重定向到安全的欢迎页面'
- en: Summary
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the basics of developing web applications with
    Spring MVC. We also discussed implementing exception handling, internationalization
    and securing our applications with Spring Security.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用Spring MVC开发Web应用程序的基础知识。我们还讨论了实现异常处理、国际化以及使用Spring Security保护我们的应用程序。
- en: Spring MVC can also be used to build REST services. We will discuss that and
    more related to REST services in the subsequent chapters.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC也可以用来构建REST服务。我们将在接下来的章节中讨论与REST服务相关的内容。
- en: In the next chapter, we will shift our attention toward microservices. We will
    try to understand why the world is looking keenly at microservices. We will also
    explore the importance of applications being Cloud-Native.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把注意力转向微服务。我们将尝试理解为什么世界对微服务如此关注。我们还将探讨应用程序成为云原生的重要性。
