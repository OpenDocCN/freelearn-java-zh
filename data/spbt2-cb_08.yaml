- en: Spring Boot DevTools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot DevTools
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Adding Spring Boot DevTools to a project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Spring Boot DevTools添加到项目中
- en: Configuring LiveReload
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置LiveReload
- en: Configuring dynamic application restart triggers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置动态应用程序重启触发器
- en: Using Remote Update
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程更新
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In a world of DevOps, agile software development practices, the introduction
    of microservices, and with more and more teams doing continuous development and
    deployment, it becomes even more important to be able to quickly see the code
    changes to an application without going through the whole process of re-compiling
    the entire project, rebuilding, and restarting the application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevOps、敏捷软件开发实践、微服务的引入以及越来越多的团队进行持续开发和部署的世界中，能够快速看到应用程序的代码更改，而不必经历整个重新编译整个项目、重建和重启应用程序的过程，这一点变得更加重要。
- en: The arrival of containerization services such as Docker has also presented a
    challenge in terms of access to the actual application running environment. It
    has changed the notion of a machine by abstracting and encapsulating the runtime
    environment, removing the ability to use any port to get access.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化服务如Docker的出现，在访问实际应用程序运行环境方面也提出了挑战。它通过抽象和封装运行时环境改变了机器的概念，移除了使用任何端口来获取访问的能力。
- en: Spring Boot DevTools provides the ability to do selective class reloading and
    debugging applications running inside Docker containers using HTTP remote debug
    tunnel, in order to give developers a quick feedback loop to see their changes
    reflected in the running application without long rebuild and restart cycles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot DevTools提供了使用HTTP远程调试隧道进行选择性地重新加载类和调试运行在Docker容器中的应用程序的能力，以便为开发者提供一个快速反馈循环，以便在运行中的应用程序中看到他们的更改，而无需经历长时间的重构建和重启周期。
- en: Adding Spring Boot DevTools to a project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Spring Boot DevTools添加到项目中
- en: Starting with Spring Boot 1.3, we have the ability to take advantage of DevTools
    components in our projects to enable things like automatic application restarts
    upon code change, reloading the browser windows for the UI, or remotely reloading
    applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从Spring Boot 1.3版本开始，我们能够在项目中利用DevTools组件，以实现诸如代码更改时自动重启应用程序、重新加载浏览器窗口以更新UI或远程重新加载应用程序等功能。
- en: The DevTools module is available for both Maven and Gradle, and works nicely
    with either Eclipse or IntelliJ IDEA editors.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DevTools模块适用于Maven和Gradle，并且与Eclipse或IntelliJ IDEA编辑器配合良好。
- en: In this chapter, we will cover integration with Gradle and IntelliJ IDEA, but
    for detailed information about using Spring Boot DevTools, take a look at the
    documentation at [http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html](http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍与Gradle和IntelliJ IDEA的集成，但有关使用Spring Boot DevTools的详细信息，请参阅[http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html](http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html)上的文档。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Continuing with our `BookPub` project, we will be adding a DevTools module
    to the main build configuration by performing the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的`BookPub`项目，我们将通过以下步骤将DevTools模块添加到主构建配置中：
- en: 'Add the following content to the `build.gradle` file located at the root of
    the project:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到位于项目根目录的`build.gradle`文件中：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Start the application by running `./gradlew clean bootRun`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`./gradlew clean bootRun`来启动应用程序。
- en: 'After application startup, you might notice in the console log an output warning
    about the inability to register with Spring Boot admin (unless you have one running)
    that looks like this: Failed to register application as Application.... Let''s
    make a live change to the `application.properties` file located in the `build/resources/main`
    directory from the root of our project and add a property entry with the following
    content:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序启动后，你可能会在控制台日志中注意到关于无法注册Spring Boot admin（除非你有一个正在运行的）的输出警告，如下所示：Failed
    to register application as Application.... 让我们从项目根目录下的`build/resources/main`目录中的`application.properties`文件进行实时更改，并添加以下内容的属性条目：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Without doing anything else, upon saving the file, we should see the console
    log showing us that the application context is being restarted.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不进行其他操作的情况下，保存文件后，我们应该看到控制台日志显示应用程序上下文正在重启。
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you have probably learned by now, when we add a `spring-boot-devtools` module
    as a dependency there is some autoconfiguration magic that takes place to add
    a number of components. A number of listeners and autoconfigurations extend the
    application context to handle the code changes and do appropriate restarts and
    reloads, both local and remote.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经了解的那样，当我们将 `spring-boot-devtools` 模块作为依赖项添加时，会发生一些自动配置的魔法，以添加许多组件。一些监听器和自动配置扩展了应用程序上下文，以处理代码更改并执行适当的重启和重新加载，包括本地和远程。
- en: In our recipe, we did a quick test to make sure the restart functionality worked
    and everything had been configured by making a property change in the `application.properties`
    file. You have probably noticed that instead of making the change in `src/main/resources/application.properties`,
    we made the change to the compiled version located under the `build/resources/main`
    directory. The reason for this was because of the property placeholder replacements
    for the `info.` block that we used during the Gradle build phase. If we were to
    only make a change in the original file and use the IntelliJ compile option, it
    would not perform the required replacements and thus result in a restart failure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中，我们进行了一个快速测试，以确保重启功能正常工作，并且通过在 `application.properties` 文件中更改属性来确保一切已配置。您可能已经注意到，我们不是在
    `src/main/resources/application.properties` 中进行更改，而是在位于 `build/resources/main`
    目录下的编译版本中进行更改。这样做的原因是因为我们在 Gradle 构建阶段使用的 `info.` 块的属性占位符替换。如果我们只更改原始文件并使用 IntelliJ
    编译选项，它将不会执行所需的替换，从而导致重启失败。
- en: When the DevTools are enabled, the application after being started, begins to
    monitor the classpath for changes to the classes that are on that classpath. When
    any class or a resource changes, it will serve as a trigger for DevTools to reload
    the application by refreshing the classloader containing the project's codebase
    (which is not the same classloader that holds the classes from the static dependency
    artifacts).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 DevTools 启用时，启动后的应用程序开始监视类路径上的类更改。当任何类或资源更改时，它将作为 DevTools 通过刷新包含项目代码库的类加载器（这不是包含静态依赖项工件类的类加载器）来重新加载应用程序的触发器。
- en: 'See the detailed explanation of the inner workings at the following link:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接提供了详细的工作原理解释：
- en: '[http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart](http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[Spring Boot DevTools 使用参考](http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html#using-boot-devtools-restart)'
- en: After the reloadable classloader has completed the refresh, the application
    context gets restarted automatically, thus effectively causing the application
    restart.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在可重新加载的类加载器完成刷新后，应用程序上下文会自动重启，从而有效地导致应用程序重启。
- en: Configuring LiveReload
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 LiveReload
- en: Those who work on frontend web applications will probably agree that being able
    to automatically reload the page once the backend code or resource change has
    taken place will save a few clicks and prevent situations where a forgotten reload
    leads to wasteful debugging efforts and chasing an error that does not exist.
    Thankfully, DevTools comes to the rescue by providing a LiveReload server implementation,
    which can be used together with a LiveReload browser extention to automatically
    reload the page when the backend change occurs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从事前端Web应用程序的人来说，可能会同意，一旦后端代码或资源发生更改，能够自动重新加载页面将节省几个点击，并防止忘记重新加载导致浪费调试努力和追逐不存在的错误的情况。幸运的是，DevTools
    通过提供 LiveReload 服务器实现来救命，该实现可以与 LiveReload 浏览器扩展一起使用，在后台更改发生时自动重新加载页面。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'If the DevTools module is added to the build dependencies, the LiveReload server
    has been automatically started. We do, however, need to install and enable the
    browser extensions by performing the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 DevTools 模块添加到构建依赖项中，LiveReload 服务器已自动启动。然而，我们确实需要通过执行以下步骤来安装和启用浏览器扩展：
- en: Unless the browser already has the LiveReload extension installed, go to [http://livereload.com/extensions/](http://livereload.com/extensions/)
    and install the appropriate extension for your browser of choice (Firefox, Safari,
    and Chrome are supported).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非浏览器已经安装了 LiveReload 扩展，否则请访问 [http://livereload.com/extensions/](http://livereload.com/extensions/)
    并为您的浏览器选择合适的扩展（Firefox、Safari 和 Chrome 都受支持）。
- en: For Internet Explorer users, there is a third-party extension available that
    can be found at [https://github.com/dvdotsenko/livereload_ie_extension/downloads](https://github.com/dvdotsenko/livereload_ie_extension/downloads).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Internet Explorer 用户，有一个第三方扩展可以在[https://github.com/dvdotsenko/livereload_ie_extension/downloads](https://github.com/dvdotsenko/livereload_ie_extension/downloads)找到。
- en: After the extension is installed, it typically needs to be enabled on the page
    by clicking a button in the toolbar. This is what it would look like in the Chrome
    browser:![](img/8114390a-7101-4692-b995-d33a1fe19d56.png)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装扩展后，通常需要在页面上通过点击工具栏中的按钮来启用它。在 Chrome 浏览器中，它看起来是这样的：![](img/8114390a-7101-4692-b995-d33a1fe19d56.png)
- en: After enabling the extension, we can go ahead and make another change as we
    did in the previous recipe (or any other code or resource change), or simply execute
    the `touch build/resources/main/application.properties` command. We should see
    the application reload taking place on the backend as well as the browser page
    reloading after.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用扩展后，我们可以继续进行另一个更改，就像在之前的菜谱中做的那样（或任何其他代码或资源更改），或者简单地执行`touch build/resources/main/application.properties`命令。我们应该在后台看到应用程序重新加载，以及浏览器页面在之后重新加载。
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With the addition of the LiveReload browser extension, and a running LiveReload
    server embedded into our `BookPub` application, the browser is now capable of
    connecting to the backend server using a web socket to monitor changes. When the
    Spring Boot DevTools detects a change that should trigger a reload, it will trigger
    the reload as well as send a notification to the browser to reload the page as
    well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 LiveReload 浏览器扩展，并将 LiveReload 服务器嵌入到我们的`BookPub`应用程序中，现在浏览器能够通过 WebSocket
    连接到后端服务器以监控更改。当 Spring Boot DevTools 检测到应该触发重新加载的更改时，它将触发重新加载，并向浏览器发送通知以重新加载页面。
- en: If there is ever a need to disable the LiveReload part of the DevTools functionality,
    it can easily be achieved by adding the  `spring.devtools.livereload.enabled=false`
    property via any of the supported configuration options, be that a property file,
    environment variable, or a system property.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要禁用 DevTools 功能中的 LiveReload 部分，可以通过添加`spring.devtools.livereload.enabled=false`属性通过任何支持的配置选项轻松实现，无论是属性文件、环境变量还是系统属性。
- en: Configuring dynamic application restart triggers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置动态应用程序重启触发器
- en: In the previous recipes, we have looked into the basic capabilities of DevTools
    when it comes to restarting the application upon code or resource change and communicating
    to the browser to reload the page. This section will address the various configuration
    options that we can leverage to indicate to Spring Boot DevTools exactly what
    we want those events to be triggered by, and when.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们已经探讨了 DevTools 在代码或资源更改后重启应用程序以及与浏览器通信以重新加载页面时的基本功能。本节将介绍我们可以利用的各种配置选项，以向
    Spring Boot DevTools 准确指示我们希望由哪些事件触发，以及何时触发。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'By default, adding a DevTools module to a project will make it monitor all
    the classes or resources, which could become undesired behavior, especially when
    it comes to multi-module repositories. This becomes true when building and launching
    projects from within an IDE like IntelliJ or Eclipse. We need to tell DevTools
    to exclude the `db-count-starter` sub-module in our project from the watch list
    by adjusting the configuration settings:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，将 DevTools 模块添加到项目中将使其监控所有类或资源，这可能会变成不希望的行为，尤其是在多模块仓库中。当在 IntelliJ 或 Eclipse
    等IDE中构建和启动项目时，这一点尤为明显。我们需要通过调整配置设置来告诉 DevTools 排除我们项目中的`db-count-starter`子模块从监视列表：
- en: 'Let''s create a file named `spring-devtools.properties` under the `db-count-starter/src/main/resources/META-INF`
    directory from the root of our project with the following content:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在项目根目录下的`db-count-starter/src/main/resources/META-INF`目录中创建一个名为`spring-devtools.properties`的文件，并包含以下内容：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next we need to launch our application from within an IDE by opening the `BookPubApplication`
    class located under the `src/main/java/com/example/bookpub` directory from the
    root of our project and starting the `main(String[] args)` method either in **run**
    or **debug** mode
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 IDE 中启动我们的应用程序，通过打开位于项目根目录下的`src/main/java/com/example/bookpub`目录中的`BookPubApplication`类，并在**运行**或**调试**模式下启动`main(String[]
    args)`方法。
- en: With the `db-count-starter` module excluded, we can safely make a change to
    a file, for example a `spring.factories` resource located under the `db-count-starter/build/resources/main/META-INF`
    directory from the root of our project, only to see the application not being
    restarted
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排除`db-count-starter`模块后，我们可以安全地更改一个文件，例如位于项目根目录下的`db-count-starter/build/resources/main/META-INF`目录中的`spring.factories`资源文件，结果却看到应用程序没有被重新启动
- en: 'If we want to completely disable the restart capability, we can do so by adding
    the following property to `application.properties` located under the `src/main/resources`
    directory from the root of our project:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要完全禁用重启功能，我们可以通过向位于项目根目录下的`src/main/resources`目录中的`application.properties`文件添加以下属性来实现：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After relaunching our application, even the changes to the `build/resources/main/application.properties`
    file, which is what's being loaded from the classpath, will not trigger the application
    restart
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重新启动我们的应用程序后，即使是`build/resources/main/application.properties`文件的更改，也就是从类路径中加载的内容，也不会触发应用程序重启
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we have looked at a number of different reload trigger configurations,
    so let''s look at each of them individually to understand where best to use them:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们查看了一些不同的重新加载触发配置，因此让我们逐个查看它们，以了解在哪里最好使用它们：
- en: '`spring.devtools.restart.enabled`: This property offers the simplest of controls,
    fully enabling or disabling the restart functionality of DevTools. With the value
    of `false`, no restart of the application will take place, regardless of the class
    or resource changes on the classpath.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.devtools.restart.enabled`：此属性提供了最简单的控制，完全启用或禁用DevTools的重启功能。当值为`false`时，无论类路径上的类或资源发生何种更改，都不会重新启动应用程序。'
- en: '`spring.devtools.restart.exclude`: This property provides an ability to stop
    specific classpaths from being reloaded. This property accepts values in a comma-separated
    form using the Ant Path matching pattern style. The default exclude value is `"META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties"`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.devtools.restart.exclude`：此属性提供了一种停止特定类路径重新加载的能力。此属性接受使用Ant路径匹配模式风格的逗号分隔值。默认排除值是`"META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties"`。'
- en: '`spring.devtools.restart.additional-exclude`: This property provides the convenience
    of being able to add to the default excludes list without having to copy/paste
    the default values, but rather simply adding to them while retaining the original
    defaults. It takes the same comma-separated Ant Path matching pattern style of
    input.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.devtools.restart.additional-exclude`：此属性提供了在不复制/粘贴默认值的情况下向默认排除列表添加的便利性，而是简单地添加到它们，同时保留原始默认值。它采用相同的逗号分隔Ant路径匹配模式风格输入。'
- en: '`spring.devtools.restart.additional-paths`: This property provides the ability
    to watch for resources that are outside of the classpath. For example, this could
    be a `config` directory that gets loaded at application startup, and you want
    to restart the application if the config entry changes. It takes a comma-separated
    list of absolute file paths.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.devtools.restart.additional-paths`：此属性提供了监视类路径之外资源的能力。例如，这可能是应用程序启动时加载的`config`目录，如果配置条目发生变化，则希望重新启动应用程序。它接受绝对文件路径的逗号分隔列表。'
- en: '`spring.devtools.restart.poll-interval`: This property specifies how long to
    pause, in milliseconds, between checking for classpath changes. The default value
    is `1000` milliseconds, but if there is a need to save some CPU cycles, this will
    do the trick.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.devtools.restart.poll-interval`：此属性指定在检查类路径更改之间暂停多长时间，以毫秒为单位。默认值为`1000`毫秒，但如果需要节省一些CPU周期，这将有效。'
- en: '`spring.devtools.restart.quiet-period`: This property controls how much time
    should pass, in milliseconds, without any changes to the classpath before the
    restart will take place. This is needed to ensure the restarts don''t get overwhelming
    if there are continuous changes taking place. The default value is `400` milliseconds,
    but it can be changed if needed.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.devtools.restart.quiet-period`：此属性控制在重启发生之前，在类路径没有任何更改的情况下应经过多少毫秒。这是确保如果发生连续更改，重启不会变得压倒性的必要条件。默认值为`400`毫秒，但如有需要可以更改。'
- en: '`spring.devtools.restart.trigger-file`: This property provides explicit control
    over when a restart happens by watching a `trigger` file for change. This is useful
    for situations where the classpath gets continuously changed, and you don''t want
    to get caught in a restart loop.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring.devtools.restart.trigger-file`：此属性通过监视`trigger`文件的变化来提供对何时重新启动的显式控制。这在类路径持续变化的情况下很有用，你不想陷入重新启动循环。'
- en: All the preceding property settings listed are usually shared between all the
    application projects that developers work on, so DevTools provides the ability
    to have global properties defined in this, making it convenient to share the development
    configurations across many projects without having to copy/paste the same values
    in all the different codebases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所列出的所有先前属性设置通常在开发人员工作的所有应用程序项目中共享，因此DevTools提供了在此处定义全局属性的能力，这使得在多个项目中共享开发配置变得方便，无需在所有不同的代码库中复制/粘贴相同的值。
- en: Internally, this capability is implemented as `PropertySource`, which gets added
    to the top of the configuration precedence hierarchy. This means that not only
    the `spring.devtools` configuration family, but any property added to the global
    file will be applied to all applications using DevTools.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，此功能作为`PropertySource`实现，并将其添加到配置优先级层次结构的顶部。这意味着不仅`spring.devtools`配置家族，任何添加到全局文件的属性都将应用于所有使用DevTools的应用程序。
- en: Another way to control reload triggers is with the use of `META-INF/spring-devtools.properties`
    with the `restart.exclude.<name>` and `restart.include.<name>` configurations
    inside them. By default, the restart of the application only gets triggered by
    changes to the actual classes or resources that are directly on the classpath
    and not bundled into JARs. This allows you to keep the majority of the classes
    in the non-reloadable base classloader, greatly limiting the number of entries
    that need to be monitored for changes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 控制重新加载触发器的一种方法是使用`META-INF/spring-devtools.properties`，其中包含`restart.exclude.<name>`和`restart.include.<name>`配置。默认情况下，应用程序的重新启动仅由实际类或资源的变化触发，这些类或资源位于类路径上且未打包到JAR文件中。这允许你将大多数类保留在不可重新加载的基本类加载器中，从而大大减少了需要监控变化条目数量。
- en: In situations where developers work with multiple projects that are dependent
    on each other, or work in a multi-module repository, like the `BookPub` one, it
    might be desirable to add some JARs into a reloadable classloader and watch them
    for change. This would typically be applied to dependencies that point to the `build/libs`
    or `target` directories, where the JARs inside them are a direct result of a build
    task execution and typically get rebuilt frequently.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发人员与相互依赖的多个项目一起工作或在一个多模块仓库（如`BookPub`）中工作的场合，可能希望将一些JAR文件添加到可重新加载的类加载器中，并监视它们的变化。这通常适用于指向`build/libs`或`target`目录的依赖项，其中它们内部的JAR文件是构建任务执行的直接结果，并且通常频繁重建。
- en: Another use case, which we explored in this recipe, is the inclusion or exclusion
    of `build/classes` or `target/classes` from the watch list. If a multi-module
    project is loaded in an IDE, it is common for the classpath to contain direct
    reference to the build directories of the sub-modules instead of the compiled
    JAR artifact, and depending on the use case, we might or might not choose to include
    or exclude those from triggering the reload.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例，我们在本食谱中探讨了，是包含或排除`build/classes`或`target/classes`从监视列表中。如果一个多模块项目在IDE中加载，类路径通常包含对子模块构建目录的直接引用，而不是编译的JAR工件，根据用例，我们可能选择包含或排除这些内容以触发重新加载。
- en: The `<name>` part of the keys is not important as long as it is unique, because
    all the `META-INF/spring-devtools.properties` files will be loaded as composites,
    regardless whether if they live inside the JARs or right in the project. The suggested
    approach is to use a sub-module/artifact name, as it will typically ensure uniqueness.
    If more than one pattern applies, the name can be appended with a sequence number,
    for example `restart.exclude.db-count-starter-1` and `restart.exclude.db-count-starter-2`.
    The value of each key should contain a valid regex pattern that can be evaluated
    against every entry in the classpath to determine whether that particular classpath
    URL should go into the reloadable or base classloader.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 键的`<name>`部分并不重要，只要它是唯一的即可，因为所有的`META-INF/spring-devtools.properties`文件都将被加载为组合文件，无论它们是否位于JAR文件内部还是直接在项目中。建议的方法是使用子模块/工件名称，因为它通常可以确保唯一性。如果有多个模式适用，则可以在名称后附加一个序列号，例如`restart.exclude.db-count-starter-1`和`restart.exclude.db-count-starter-2`。每个键的值应包含一个有效的正则表达式模式，可以针对类路径中的每个条目进行评估，以确定特定的类路径URL是否应该进入可重新加载或基本类加载器。
- en: Using Remote Update
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程更新
- en: With the growing popularity of Docker, more and more applications are being
    built and deployed as Docker containers. One of the great features of Docker is
    the isolation of the runtime environment from the host OS, but that same isolation
    makes it difficult to make continuous changes and test your application in a true
    environment. Each time there is a change to a property file or a Java class, one
    needs to rebuild everything, create a new Docker image, restart the container,
    and so on. That's a lot of work to be doing for every change.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Docker的日益流行，越来越多的应用程序被构建和部署为Docker容器。Docker的一个伟大特性是将运行时环境与宿主操作系统隔离开来，但这种隔离也使得在真实环境中对应用程序进行持续更改和测试变得困难。每次属性文件或Java类的更改，都需要重新构建一切，创建新的Docker镜像，重启容器等等。对于每一次更改，这都是一大堆工作。
- en: Even though, unfortunately, as of version 2.0, Spring Boot has removed the capability
    of doing a remote debug, there is still the very helpful ability to remotely reload
    the code changes from within your IDE as you work on the code, without the need
    to at least rebuild the application JAR and Docker image.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不幸的是，从2.0版本开始，Spring Boot已经移除了远程调试的能力，但仍然有一个非常有用的功能，可以在你编写代码时，从IDE中远程重新加载代码更改，而无需至少重新构建应用程序JAR和Docker镜像。
- en: The **Remote Restart** capability provides a solution for better continuous
    development and makes it possible to do dynamic application restarts remotely,
    as if it were on a local machine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程重启**功能为更好的持续开发提供了解决方案，使得可以在远程进行动态应用程序重启，就像它是在本地机器上一样。'
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'As you have probably guessed, Remote Restart involves an agent running locally
    and sending instructions to the remote client. DevTools provides an implementation
    of such an agent—`RemoteSpringApplication`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，远程重启涉及一个在本地运行的代理，并向远程客户端发送指令。DevTools提供了一个这样的代理实现——`RemoteSpringApplication`：
- en: 'In order to enable Remote Restart, we need to add a property to `application.properties`
    located under the `src/main/resources` directory from the root of our project
    with the following content:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了启用远程重启功能，我们需要在项目根目录下的`src/main/resources`目录中添加一个名为`application.properties`的属性文件，内容如下：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next step would be to create a Java application launch configuration for
    the `RemoteSpringApplication` class in the IDE.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在IDE中为`RemoteSpringApplication`类创建一个Java应用程序启动配置。
- en: It is important to make sure the program arguments field has the base URL of
    the application you are trying to debug together with the port. Ensure that the
    working directory points to the main project, and the classpath of the module
    is pointing to the main project module as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 确保程序参数字段包含你试图调试的应用程序的基本URL以及端口非常重要。确保工作目录指向主项目，并且模块的类路径指向主项目模块。
- en: The figure on the next page shows what such a configuration would look like
    in IntelliJ IDEA. The Eclipse IDE would have a similar form as well.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下页的图显示了在IntelliJ IDEA中此类配置的外观。Eclipse IDE也会有类似的形式。
- en: '![](img/7503253b-f437-48e8-a5be-cbd5facb2aea.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7503253b-f437-48e8-a5be-cbd5facb2aea.png)'
- en: 'After filling out all the fields, we need to start `RemoteSpringApplication`
    from within our IDE by clicking Run. If all has been configured correctly, we
    should see a similar output in the log:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写完所有字段后，我们需要通过点击运行来在IDE中启动`RemoteSpringApplication`。如果一切配置正确，我们应该在日志中看到类似的输出：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To simulate remoteness, we will launch the application in a separate command
    shell, executing the `./gradlew clean bootJar` command followed by executing `./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了模拟远程操作，我们将在一个单独的命令行中启动应用程序，执行`./gradlew clean bootJar`命令，然后执行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`。
- en: 'Once the application has started, take a look at one of the last lines in the
    log that should look something like the following:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序启动，查看日志中的最后一行，它应该看起来像以下内容：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The property value of `my.config.value` is not being set, because we don't have
    one defined in our `application.properties ` file, and we didn't use any environment
    variables or startup system property settings to set it.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`my.config.value`的属性值没有被设置，因为我们没有在我们的`application.properties`文件中定义它，并且我们没有使用任何环境变量或启动系统属性设置来设置它。'
- en: 'Let''s pretend we need to do a live change and modify our `application.properties`
    file located under the `build/resources/main` directory from the root of our project
    with the following content:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们假设我们需要进行实时更改，并从项目根目录下的`build/resources/main`目录修改`application.properties`文件，内容如下：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we should see in the console that our application has automatically restarted
    and, after all is done, we should see something similar to the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该在控制台中看到我们的应用程序已经自动重启，一切完成后，我们应该看到类似以下的内容：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It might look like voodoo magic, but the science behind the Remote Restart functionality
    is pretty straightforward. Under the hood, when a DevTools module is included,
    the HTTP endpoint handler for `/.~~spring-boot!~/restart` automatically gets added.
    This allows the `RemoteSpringApplication` process to send the code change payload
    via an HTTP tunnel to the remote application and back.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来像是巫术魔法，但远程重启功能背后的科学相当简单。在底层，当包含DevTools模块时，`/.~~spring-boot!~/restart`的HTTP端点处理器会自动添加。这允许`RemoteSpringApplication`进程通过HTTP隧道将代码更改有效载荷发送到远程应用，并返回。
- en: To make sure that no malicious outside debug connection gets to connect to our
    remote application, the value of the `spring.devtools.remote.secret` property
    gets sent across and verified to establish the authenticity of the request.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保没有恶意的外部调试连接能够连接到我们的远程应用程序，`spring.devtools.remote.secret`属性的值会被发送并验证，以建立请求的真实性。
- en: In *step 2* of the recipe, we launched the `RemoteSpringApplication` process
    with a program arguments value of `http://127.0.0.1:8080`, which is how `RemoteSpringApplication`
    knows how to communicate with our remote application. The `RemoteSpringApplication` class
    itself scans for the local file changes from an IDE by monitoring the classpath.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱的*第2步*中，我们使用`http://127.0.0.1:8080`作为程序参数值启动了`RemoteSpringApplication`进程，这是`RemoteSpringApplication`知道如何与我们的远程应用通信的方式。`RemoteSpringApplication`类本身通过监控类路径来扫描本地文件更改。
- en: In *step 6* of the recipe, when we added the property to our config in the code,
    it is very important to note that we made the change to the `application.properties`
    file located in the running classpath of the `RemoteSpringApplication` class not
    under `src/main/resources`, but under the `build/resources/main` directory, where
    Gradle has placed all the compiled files—hopefully that's the same directory your
    IDE is using as a classpath to run `RemoteSpringApplication`. If that's not the
    path your IDE is using, you should make the change in the appropriate folder,
    where the IDE has compiled the classes—for IntelliJ IDEA that would be the `out/production/resources`
    directory by default.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱的*第6步*中，当我们向代码中的配置添加属性时，非常重要的一点是要注意，我们对`application.properties`文件进行了更改，该文件位于`RemoteSpringApplication`类的运行类路径中，而不是在`src/main/resources`下，而是在`build/resources/main`目录下，这是Gradle放置所有编译文件的目录——希望这是你的IDE用作运行`RemoteSpringApplication`的类路径的相同目录。如果这不是你的IDE使用的路径，你应该在IDE编译类的相应文件夹中进行更改——对于IntelliJ
    IDEA，默认情况下将是`out/production/resources`目录。
- en: 'If DevTools needs to be enabled inside an application running as a Docker container,
    we need to explicitly configure the `build` script to do so by adding the following
    to the `build.gradle` file in the main project:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在作为Docker容器运行的应用程序中启用DevTools，我们需要明确配置`build`脚本，通过在主项目的`build.gradle`文件中添加以下内容来实现：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The reason we need to do this is because, by default, when a Spring Boot application
    gets re-packaged for production deployment, which is the case when building a
    Docker container image, the DevTools module is excluded from the classpath during
    build time. To prevent this from happening, we need to tell the build system to
    not exclude the module in order to take advantage of its capabilities, namely
    the Remote Restart.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这样做的原因是，默认情况下，当Spring Boot应用程序被重新打包用于生产部署时，这在构建Docker容器镜像时是常见的情况，DevTools模块在构建时会从类路径中排除。为了防止这种情况发生，我们需要告诉构建系统不要排除该模块，以便利用其功能，即远程重启。
