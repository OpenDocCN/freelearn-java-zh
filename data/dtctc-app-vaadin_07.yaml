- en: Implementing CRUD User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现CRUD用户界面
- en: Most business applications have to deal with data manipulation. Users are able
    to see, change, delete, and add data. All these actions are executed according
    to and in the context of a set of rules dictated by the business. In its more
    fundamental form, business applications include graphical user interfaces to perform
    CRUD actions over the data. **CRUD** is an acronym for **Create, Read, Update,
    and Delete**. This chapter explores the design and implementation of CRUD views.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数商业应用程序必须处理数据操作。用户能够查看、更改、删除和添加数据。所有这些操作都是根据业务规定的一组规则在上下文中执行的。在其更基本的形式中，商业应用程序包括图形用户界面来执行对数据的CRUD操作。**CRUD**是**创建、读取、更新和删除**的缩写。本章探讨了CRUD视图的设计和实现。
- en: We'll start with a quick discussion about CRUD views from a **User Experience**
    (**UX**) perspective. Then, we will move on to how to design and implement CRUD
    user interfaces using two different UI designs. This chapter also explains the
    basics of data binding, shows how to use the Java Bean Validation API, and demonstrates
    how to render UI components inside `Grid` components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从从**用户体验**（**UX**）的角度对CRUD视图进行简要讨论。然后，我们将继续探讨如何使用两种不同的UI设计来设计和实现CRUD用户界面。本章还解释了数据绑定的基础知识，展示了如何使用Java
    Bean验证API，并演示了如何在`Grid`组件内部渲染UI组件。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: CRUD user interface design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRUD用户界面设计
- en: Data binding
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Validating with JSR-303
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSR-303进行验证
- en: Grid renderers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格渲染器
- en: Filtering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要拥有Java SE开发工具包和Java EE SDK版本8或更高版本。你还需要Maven版本3或更高版本。建议使用具有Maven支持的Java IDE，如IntelliJ
    IDEA、Eclipse或NetBeans。最后，为了使用本书的Git仓库，你需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-07](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-07)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-07](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-07)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码的实际效果：
- en: '[https://goo.gl/szGaRy](https://goo.gl/szGaRy)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/szGaRy](https://goo.gl/szGaRy)'
- en: CRUD user interface design
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD用户界面设计
- en: UX in the context of **user interfaces** (**UI**) refers to the degree of quality
    in the interaction between the user and the UI. An application designed with UX
    in mind enhances the user satisfaction by improving its usability. Simplicity
    is key in the process of UX design, but avoid falling into a minimalistic design,
    which may otherwise spoil usability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在**用户界面**（**UI**）的上下文中，UX（用户体验）指的是用户与UI之间交互的质量程度。一个考虑到UX的应用程序通过提高其可用性来增强用户满意度。在UX设计过程中，简洁是关键，但应避免陷入极简主义设计，否则可能会损害可用性。
- en: You can find more information about simplicity, minimalism, and general myths
    about UX design at [http://uxmyths.com](http://uxmyths.com).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://uxmyths.com](http://uxmyths.com)上找到更多关于简洁、极简主义以及UX设计的一般神话的信息。
- en: UX design may include several disciplines, including wireframing, prototyping,
    testing, and validating designs. In this section, we'll explore variations of
    typical CRUD views. Examples of this kind of views are the admin views for managing
    registered users, views for internal application configuration, or views used
    by **DevOps** members.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: UX设计可能包括多个学科，包括线框图、原型设计、测试和验证设计。在本节中，我们将探讨典型CRUD视图的变体。这类视图的例子包括管理注册用户的管理员视图、内部应用程序配置视图或**DevOps**成员使用的视图。
- en: DevOps is a softwares engineering discipline that unifies software development
    and software operation (deployment and infrastructure management).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps是一种软件开发学科，它统一了软件开发和软件操作（部署和基础设施管理）。
- en: We'll avoid the term CRUD for more sophisticated views that might include all
    of the CRUD operations. In general, these views are business-specific, and developers
    should design them according to the particularities of each case.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将避免使用CRUD这个术语，因为它可能包括所有的CRUD操作。一般来说，这些视图是业务特定的，开发者应根据每个案例的特定情况来设计它们。
- en: 'CRUD views are about *record* editing. Records are items that are usually understood
    as a whole. Some are suitable for tabular presentation, while others are not;
    for example, events on a calendar. When designing a CRUD view, think about the
    following factors:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 视图关乎**记录**编辑。记录通常被理解为整体的项目。有些适合表格展示，而有些则不适合；例如，日历上的事件。在设计 CRUD 视图时，考虑以下因素：
- en: '**Record complexity**: How many fields does the record contain? Do the fields
    change depending on the state of other fields? Are there any complex fields such
    as maps or calendars? How complex are the validation rules?'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录复杂性**：记录包含多少字段？字段是否会根据其他字段的状态而变化？是否存在如地图或日历等复杂字段？验证规则有多复杂？'
- en: '**Editing frequency**: How often do users need to edit the record? Do they
    need a quick way to edit certain fields?'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑频率**：用户需要多频繁地编辑记录？他们是否需要快速编辑某些字段的方法？'
- en: '**Context awareness**: Do users need extra data when editing a record? Do they
    need, or would they benefit from, seeing other records when editing one?'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文感知**：在编辑记录时，用户是否需要额外的数据？他们是否需要，或者从查看其他记录中获益？'
- en: As a rule of thumb, think about how frequently users will perform the actions
    on the view, and if they can benefit from seeing many records at a time or not.
    If the frequency is high for any operation, and they won't benefit from seeing
    other records in the view, don't use a *generic* CRUD interface. Implement the
    view tailored to the use case.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验法则，考虑用户将如何频繁地在视图中执行操作，以及他们是否可以从一次看到多个记录中受益。如果任何操作的频率都很高，并且他们不会从在视图中看到其他记录中受益，那么不要使用*通用*
    CRUD 接口。实现针对用例定制的视图。
- en: 'Let''s analyze three CRUD user interface designs: in-place fields, modal pop-up
    windows, and hierarchical menus.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析三种 CRUD 用户界面设计：原位字段、模态弹出窗口和分层菜单。
- en: In-place fields
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原位字段
- en: 'With this design, users can activate a field to edit a single value. Data can
    be presented in a tabular format, in which case, clicking a cell would activate
    an input field, which would allow the user to directly edit the value. The following
    figure shows an example of this kind of interface:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设计，用户可以激活一个字段来编辑单个值。数据可以以表格格式呈现，在这种情况下，点击单元格将激活一个输入字段，允许用户直接编辑值。以下图显示了这种类型界面的一个示例：
- en: '![](img/35e20d1c-121d-4f7a-865b-c0e31333f633.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35e20d1c-121d-4f7a-865b-c0e31333f633.jpg)'
- en: 'The **Vaadin Framework** allows this through the `Grid.addComponentColumn`
    method. The following line adds a `Button` to an existing `Grid`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vaadin 框架**通过`Grid.addComponentColumn`方法允许这样做。以下行向现有的`Grid`添加了一个`Button`：'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are advantages and disadvantages of using this option. The main advantage
    is speed. Users can quickly edit a value, and there's no need to navigate to other
    views in order to edit the data; however, implementing the `add` operation requires
    extra considerations. When the user clicks the Add button, a new empty row is
    added; however, it's not easy to know when the row can be saved (in a database,
    for example). Is a completely empty row a valid record? One way of solving this
    is by only persisting the record when all the values in it are valid. Another
    disadvantage is evident when the record has many fields, which, in this case,
    means a grid with many columns. Editing the data in columns that are scrolled
    out of the view requires extra interaction from the user, which wipes out the
    advantage of editing data quickly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此选项有优点和缺点。主要优点是速度。用户可以快速编辑一个值，而且无需导航到其他视图来编辑数据；然而，实现`添加`操作需要额外的考虑。当用户点击添加按钮时，会添加一个新空行；然而，很难知道何时可以保存该行（例如，在数据库中）。一个完全空的行是否是一个有效的记录？解决这一问题的方法之一是在所有值都有效时才持久化记录。另一个缺点是当记录包含许多字段时明显，在这种情况下，意味着一个有许多列的网格。在滚动出视图的列中编辑数据需要用户进行额外的交互，这抵消了快速编辑数据的优势。
- en: Modal pop-up windows
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态弹出窗口
- en: 'This kind of user interface shows a modal window anytime the user wants to
    create, modify, or delete a record. A first approach to this is to combine in-place
    editors with modal windows. When the user clicks or double-clicks a row, an editor
    is placed on top of the row, showing all the input fields required to edit the
    data, and the buttons to cancel the action or save the data. This is exactly what
    `Grid` editors are in Vaadin Framework, as shown in the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用户界面在用户想要创建、修改或删除记录时始终显示一个模态窗口。对此的一种方法是结合原地编辑器和模态窗口。当用户点击或双击一行时，编辑器会放置在该行上方，显示所有用于编辑数据的输入字段以及取消操作或保存数据的按钮。这正是
    Vaadin 框架中的 `Grid` 编辑器，如下面的截图所示：
- en: '![](img/5610e18f-b17c-404e-9a2c-b708baebb7d1.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5610e18f-b17c-404e-9a2c-b708baebb7d1.png)'
- en: 'This is enabled as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下方式实现：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A second approach is to actually show a modal window that blocks any other
    interaction with other parts of the page. The following is a figure of this kind
    of interface:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是实际显示一个阻止与页面其他部分任何其他交互的模态窗口。以下是这样一种界面的图示：
- en: '![](img/3182171e-c5c3-4372-9ada-b3202220c36c.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3182171e-c5c3-4372-9ada-b3202220c36c.png)'
- en: There are several advantages of this approach. The window allows any kind of
    design for the form it contains. Input fields can be grouped if they are related,
    help text or instructions can be added, and validation errors can be shown in
    multiple ways. It is also an intuitive *dead-end view*; users cannot navigate
    anywhere else but back, which makes it an easy-to-use interaction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个优点。窗口允许对包含的表单进行任何类型的设计。如果输入字段相关，则可以分组；可以添加帮助文本或说明，并且可以通过多种方式显示验证错误。它也是一个直观的**死胡同视图**；用户无法导航到任何其他地方，只能返回，这使得它易于使用。
- en: Hierarchical menus
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层菜单
- en: 'When data can be represented in a hierarchical way, it can serve as the *Read*
    part in CRUD, and as a navigation tool. The following figure shows a CRUD of *Organizations*,
    *Departments*, and *Employees* records:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据可以以分层的方式表示时，它可以作为 CRUD 中的**读取**部分，以及作为导航工具。以下图显示了**组织**、**部门**和**员工**记录的
    CRUD：
- en: '![](img/92892c05-ea83-4a83-a2a4-b677f87b11b9.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92892c05-ea83-4a83-a2a4-b677f87b11b9.jpg)'
- en: A key element in this kind of design is the use of most of the available space
    for the forms containing the input fields. Forms are shown in *view mode,* and
    are made editable when the user clicks an edit button. In the preceding figure,
    a short representation of the records appears in the navigation menu itself. In
    order to edit one record, the user can click it from the menu. When a record can
    be associated with one or many records of another type, they are grouped and shown
    in a hierarchical fashion in the menu. Top-level items in the menu don't necessarily
    need to be records themselves, since they can serve as a different kind of grouping.
    For example, a top item could show the Organizations option having all the actual
    organization records as *children*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的关键元素是使用大部分可用空间来容纳包含输入字段的表单。表单以**查看模式**显示，并在用户点击编辑按钮时变为可编辑。在前面的图中，记录的简短表示出现在导航菜单本身中。为了编辑一条记录，用户可以从菜单中点击它。当一条记录可以与另一类型的记录中的一个或多个记录相关联时，它们会被分组并以分层的方式在菜单中显示。菜单中的顶级项不一定是记录本身，因为它们可以作为不同类型的分组。例如，顶级项可以显示包含所有实际组织记录的**子项**。
- en: This kind of design works well for configuration options; however, it has the
    disadvantage of showing many options at the same time, which might cause a distraction
    for end users. For example, a user might forget to click the **Save** button after
    editing some fields.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计对于配置选项来说效果很好；然而，它同时显示许多选项的缺点可能会分散最终用户的注意力。例如，用户在编辑了一些字段之后可能会忘记点击**保存**按钮。
- en: The domain model
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域模型
- en: 'The following sections show how to implement CRUD views using two different
    designs: a `Grid` in editable mode, and modal windows. But first, we need to implement
    a **domain model**. We''ll use JPA and *repository classes*, which we explained
    in the previous chapters. The domain model consists of simple classes to model
    a role-based schema: `User`, and `Role`. It also includes the corresponding `UserRepository`
    and `RoleRepository` classes.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分展示了如何使用两种不同的设计实现 CRUD 视图：可编辑模式的 `Grid` 和模态窗口。但首先，我们需要实现一个**领域模型**。我们将使用
    JPA 和*仓库类*，这在之前的章节中已经解释过。领域模型由简单的类组成，用于建模基于角色的模式：`User`和`Role`。它还包括相应的`UserRepository`和`RoleRepository`类。
- en: 'Let''s start with the simplest of the classes, `Role`. The following is the
    full implementation of this class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的类`Role`开始。以下是这个类的完整实现：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Besides the usual JPA configuration stuff (such as the `@Entity`, `@Id`, and
    `@GeneratedValue` annotations), the most interesting thing in this class is that
    there are no `getters` and `setters`. Nevertheless, `getters` and `setters` for
    each Java field in the class exist! This is thanks to *Project Lombok*, a library
    that reduces the amount of boilerplate code needed in Java programs. Lombok generates
    code at the class level. In the previous class, we used the `@Data` annotation
    in order to tell Lombok to generate `getters` and `setters`, and `toString`, `equals`,
    and `hashCode` methods. Since the `toString` method generated by Lombok doesn't
    fit our requirements, we override it and provided a custom one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通常的JPA配置内容（如`@Entity`、`@Id`和`@GeneratedValue`注解）之外，这个类中最有趣的事情是它没有`getters`和`setters`。尽管如此，类中每个Java字段的`getters`和`setters`都存在！这要归功于*Project
    Lombok*，这是一个减少Java程序中所需样板代码量的库。Lombok在类级别生成代码。在前一个类中，我们使用了`@Data`注解来告诉Lombok生成`getters`和`setters`、`toString`、`equals`和`hashCode`方法。由于Lombok生成的`toString`方法不符合我们的要求，我们重写了它并提供了自定义的一个。
- en: 'In order to use Lombok, you need to install it in your IDE, and add the dependency
    to the `pom.xml` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Lombok，你需要在你的IDE中安装它，并将依赖项添加到`pom.xml`文件中：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can find installation instructions for IntelliJ IDEA, NetBeans, Eclipse,
    and other IDEs at: [https://projectlombok.org](https://projectlombok.org). After
    installing Lombok, you''ll be able to use `autocomplete` and any other features
    of your IDE in order to use the generated code, even when you don''t see it in
    the Java class. For example, the following screenshot shows **IntelliJ IDEA**
    suggesting the generated `getName` method when using the autocomplete feature:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://projectlombok.org](https://projectlombok.org)找到关于IntelliJ IDEA、NetBeans、Eclipse和其他IDE的安装说明。安装Lombok后，你将能够使用IDE的自动完成和其他功能来使用生成的代码，即使你不在Java类中看到它。例如，以下截图显示了**IntelliJ
    IDEA**在使用自动完成功能时建议生成的`getName`方法：
- en: '![](img/4cec7d32-4af6-48de-9fb3-8c93a3ded99a.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cec7d32-4af6-48de-9fb3-8c93a3ded99a.png)'
- en: You can use your own implementations for the `getters`, `setters`, `equals`,
    and `hashCode` instead of using Lombok. Most IDEs, if not all of them have features
    to generate these methods at the source code level; however, Lombok source files
    become much shorter, making them easier to maintain in most cases. `@Data` is
    not the only useful annotation offered by Lombok. See the documentation at [https://projectlombok.org](https://projectlombok.org)
    for more information about its features.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用自己的实现来编写`getters`、`setters`、`equals`和`hashCode`方法，而不是使用Lombok。大多数IDE（如果不是所有IDE）都有在源代码级别生成这些方法的功能；然而，使用Lombok的源代码文件会变得非常短，这在大多数情况下使得它们更容易维护。`@Data`不是Lombok提供的唯一有用的注解。有关其功能的更多信息，请参阅[https://projectlombok.org](https://projectlombok.org)的文档。
- en: 'The following is the implementation of the `User` class, which uses Lombok
    as well:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`User`类的实现，它也使用了Lombok：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice the `@ManyToMany` annotation in the `roles` field. What's the difference
    between `@ManyToMany` and `@OneToMany`? The `-ToMany` part means that every `User`
    can be associated with many `Role` objects. The `@Many-` part means that every
    `Role` can have many `User` instances. If `@OneToMany` was used, the `@One-` part
    would mean that every `Role` can be associated with only one `User`, which is
    clearly not what we want in this model.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`roles`字段中的`@ManyToMany`注解。`@ManyToMany`和`@OneToMany`之间有什么区别？`-ToMany`部分意味着每个`User`都可以与多个`Role`对象相关联。`@Many-`部分意味着每个`Role`可以有多个`User`实例。如果使用`@OneToMany`，则`@One-`部分将意味着每个`Role`只能与一个`User`相关联，这显然不是我们在这个模型中想要的。
- en: Why does the `@ManyToMany` annotation specify `FetchType.EAGER` for the fetch
    strategy? Hibernate uses `Fetch.LAZY` by default, which might cause a `LazyInitializationException`.
    `Lazy` fetch can be useful if you want to load the data when it is actually needed.
    This, however, requires an open Hibernate session when the collection is accessed.
    In a web environment, the session is usually closed after the request is handled.
    Since we need to show `Role` data in the views, the best approach is to eagerly
    fetch the data. A common practice in many applications is to use the *Open Session
    in View* pattern; however, this might as well be considered an anti-pattern. Always
    consider using DTO projections instead of the Open Session in the View pattern.
    For a more detailed discussion about this topic, visit [https://vladmihalcea.com/2016/05/30/the-open-session-in-view-anti-pattern](https://vladmihalcea.com/2016/05/30/the-open-session-in-view-anti-pattern).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `@ManyToMany` 注解为获取策略指定了 `FetchType.EAGER`？Hibernate 默认使用 `Fetch.LAZY`，这可能会导致
    `LazyInitializationException`。如果想在实际需要时加载数据，则 `Lazy` 获取可能很有用。然而，这需要在访问集合时有一个打开的
    Hibernate 会话。在 Web 环境中，通常在处理请求后关闭会话。由于我们需要在视图中显示 `Role` 数据，最佳方法是积极获取数据。在许多应用程序中，使用
    *Open Session in View* 模式是一种常见做法；然而，这也可能被视为一种反模式。始终考虑使用 DTO 投影而不是在视图中打开会话模式。有关此主题的更详细讨论，请访问
    [https://vladmihalcea.com/2016/05/30/the-open-session-in-view-anti-pattern](https://vladmihalcea.com/2016/05/30/the-open-session-in-view-anti-pattern)。
- en: 'The last part of the domain model is the repository classes. For the `RoleRepository`
    class, we only need a method to find all the `Role` objects, and another to save
    a new one, as shown in the following snippet of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型的最后一部分是仓库类。对于 `RoleRepository` 类，我们只需要一个方法来查找所有的 `Role` 对象，以及另一个方法来保存一个新的对象，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And for completeness, the following are the methods in the `UserRepository`
    class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，以下是在 `UserRepository` 类中的方法：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The actual implementation of the methods is omitted here for simplicity, but
    you can find the complete source code of this chapter's example in the `Data-centric-Applications-with-Vaadin-8\chapter-07`
    Maven project of the source code that accompanies this book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，这里省略了方法的实际实现，但你可以在这个章节的示例的源代码中找到完整的源代码，该源代码位于 `Data-centric-Applications-with-Vaadin-8\chapter-07`
    Maven 项目中。
- en: Implementing a CRUD using an editable Grid component
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可编辑的 `Grid` 组件实现 CRUD
- en: 'In this section, we''ll implement a component containing an editable `Grid`.
    The following is a screenshot of the application showing the `Grid` component
    in edit mode:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个包含可编辑 `Grid` 的组件。以下是一个显示编辑模式的 `Grid` 组件的应用程序截图：
- en: '![](img/caefa9c4-cd6c-404b-aeac-ec0e398d1191.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/caefa9c4-cd6c-404b-aeac-ec0e398d1191.png)'
- en: 'For simplicity, in this example, we''ll omit the *add* and the *delete* CRUD
    operations for now. Let''s start by creating a class to encapsulate the component
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，在这个例子中，我们将暂时省略 *add* 和 *delete* CRUD 操作。让我们首先创建一个类来封装组件，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The class, which extends `Composite`, declares a `Grid` to show `User` instances.
    There are several constructors available in the `Grid` class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `Composite` 的类声明了一个 `Grid` 来显示 `User` 实例。`Grid` 类中有几个构造函数可用：
- en: '`Grid()`: Creates a new `Grid`, without columns. Columns have to be manually
    added.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid()`: 创建一个新的 `Grid`，没有列。列需要手动添加。'
- en: '`Grid(String caption)`: The same as `Grid()`, but sets a caption.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid(String caption)`: 与 `Grid()` 相同，但设置了一个标题。'
- en: '`Grid(Class<T> beanType)`: Creates a new `Grid` and automatically creates columns
    for each property (having a `getter` and a `setter`) in the specified class. Columns
    can be retrieved by a name using the `getColumn(String)` method.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid(Class<T> beanType)`: 创建一个新的 `Grid`，并自动为指定类中的每个属性（具有 `getter` 和 `setter`）创建列。可以通过
    `getColumn(String)` 方法按名称检索列。'
- en: '`Grid(DataProvider<T, ?> dataProvider)`: Creates a new `Grid` without columns.
    It accepts a `DataProvider`, which is an abstraction to provide data from any
    kind of backend. You can implement this interface, or use the implementations
    available in the framework. If you are not familiar with data providers, refer
    to the official documentation at: [https://vaadin.com/docs/v8/framework/datamodel/datamodel-providers.html](https://vaadin.com/docs/v8/framework/datamodel/datamodel-providers.html).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid(DataProvider<T, ?> dataProvider)`: 创建一个新的 `Grid`，没有列。它接受一个 `DataProvider`，这是一个抽象，用于从任何类型的后端提供数据。你可以实现这个接口，或者使用框架中可用的实现。如果你不熟悉数据提供者，请参阅官方文档：[https://vaadin.com/docs/v8/framework/datamodel/datamodel-providers.html](https://vaadin.com/docs/v8/framework/datamodel/datamodel-providers.html)。'
- en: '`Grid(String caption, DataProvider<T, ?> dataProvider)`: The same as `Grid(DataProvider)`,
    but sets a caption.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid(String caption, DataProvider<T, ?> dataProvider)`: 与 `Grid(DataProvider)`
    相同，但设置一个标题。'
- en: '`Grid(String caption, Collection<T> items)`: Creates a new `Grid` without columns,
    and sets a caption. The provided collection is used to fetch the data that is
    going to be rendered in the `Grid` (a `DataProvider` is used behind the scenes).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Grid(String caption, Collection<T> items)`: 创建一个新的没有列的 `Grid` 并设置一个标题。提供的集合用于获取将要渲染在
    `Grid` 中的数据（在幕后使用 `DataProvider`）。'
- en: At this point, we have a `Grid` component without columns and without rows (data).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个没有列和行（数据）的 `Grid` 组件。
- en: Implementing the read operation
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现读取操作
- en: The *read* CRUD operation can be thought of as the action of showing all the
    `User` instances inside the `Grid`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 *读取* CRUD 操作视为在 `Grid` 中显示所有 `User` 实例的动作。
- en: 'Since the `Grid` doesn''t have any columns at this point, adding rows to it
    won''t make any difference, so let''s start by adding columns. The easiest way
    to add columns to a `Grid` is by passing the type of the bean (`User`) to the
    `Grid` constructor:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Grid` 目前没有任何列，向其中添加行不会产生任何影响，所以让我们先添加列。向 `Grid` 添加列的最简单方法是将 bean 的类型（`User`）传递给
    `Grid` 构造函数：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After this, we can add columns by using the property names in the bean. For
    example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以通过使用 bean 中的属性名来添加列。例如：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, this is not type-safe. When manually adding columns to a `Grid`, a
    better approach is not to use the `Grid(Class<T> beanType)` constructor, and instead
    use a `ValueProvider`. Let''s do this in the example application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不类型安全。当手动向 `Grid` 添加列时，更好的方法不是使用 `Grid(Class<T> beanType)` 构造函数，而是使用 `ValueProvider`。让我们在示例应用程序中这样做：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is a better approach, since it''s completely type-safe. The `addColumn`
    method accepts a `ValueProvider`, a functional interface compatible with any getter
    in the bean type. The `addColumn` method returns an instance of `Grid.Column`,
    from which we can configure any additional properties for it. In the previous
    snippet of code, we configured the column''s caption. All the `setXX` methods
    return the same instance of `Column`, which allows you to chain calls to further
    configure the column. For example, you can set the column''s caption and width
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好的方法，因为它完全类型安全。`addColumn` 方法接受一个 `ValueProvider`，这是一个与 bean 类型中任何 getter
    兼容的功能接口。`addColumn` 方法返回一个 `Grid.Column` 实例，我们可以从中配置任何额外的属性。在上面的代码片段中，我们配置了列的标题。所有的
    `setXX` 方法都返回相同的 `Column` 实例，这允许你链式调用以进一步配置列。例如，你可以设置列的标题和宽度如下：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the columns in place, we can now add rows to the `Grid`. This is as simple
    as calling the `setItems(Collection)` method, and passing a `Collection` of `User`
    instances. Since we will need to reload the content of the `Grid` after editing
    a row, it''s a good idea to encapsulate the call to `setItems` as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在列就位后，我们现在可以向 `Grid` 中添加行。这就像调用 `setItems(Collection)` 方法，并传递一个 `User` 实例的 `Collection`。由于我们将在编辑行后需要重新加载
    `Grid` 的内容，所以将 `setItems` 的调用封装起来是一个好主意：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There''s a slight security problem at this point, and by "slight", I mean "major".
    Passwords are shown in plain text in the `Grid`. We want to keep the Password
    column, so that it plays nice with the `Grid` editor later, but we want to show
    a series of asterisks (`********`) instead of the actual passwords. This can be
    done through the `Renderer` interface. A `Renderer` is an extension that *draws*
    client-side representations of a value. We can use the provided `TextRenderer`
    implementation to change the text shown in the Password column as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前存在一个轻微的安全问题，而且我所说的“轻微”实际上是“重大”。密码在 `Grid` 中以纯文本形式显示。我们希望保留密码列，以便它与 `Grid`
    编辑器良好地协同工作，但我们希望显示一系列星号（`********`）而不是实际的密码。这可以通过 `Renderer` 接口来完成。`Renderer`
    是一个扩展，它 *绘制* 值的客户端表示。我们可以使用提供的 `TextRenderer` 实现来更改密码列中显示的文本，如下所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `setRenderer` method accepts a `ValueProvider` and a `Renderer`. Instead
    of returning `user.getPassword()`, we return the `"********"` string, no matter
    what the value of the password is. `TextRenderer` will take the string, and *draw*
    it as text. There are many other `Renderers` that would take the value and draw
    it in many other forms; for example, as a `Button` or `HTML`. The following figure
    shows the implementations included with the framework:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`setRenderer`方法接受一个`ValueProvider`和一个`Renderer`。我们不再返回`user.getPassword()`，而是无论密码的值是什么，都返回`"********"`字符串。`TextRenderer`将接受这个字符串，并将其作为文本绘制出来。还有许多其他的`Renderer`可以接受值并以多种形式绘制；例如，作为一个`Button`或`HTML`。以下图显示了框架中包含的实现：'
- en: '![](img/651f918f-6f97-4382-80fa-86657a9b8d0b.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/651f918f-6f97-4382-80fa-86657a9b8d0b.png)'
- en: Implementing the update operation
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现更新操作
- en: 'The update CRUD operation is implemented through the `Grid.Editor` class. Enabling
    the editor is as easy as calling the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更新CRUD操作是通过`Grid.Editor`类实现的。启用编辑器就像调用以下代码一样简单：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, the `Editor` needs a way to know what kind of input component to use
    for each column, and also where to get the values for these input components,
    and how to set the values back in the bean once the user edits them. This is done
    with the help of two methods: `Grid.Editor.getBinder` , and `Grid.Column.setEditorBinding`.
    You should be familiar with the `Binder` class in the Vaadin Framework; it is
    a utility class that allows you to connect `setters` and `getters` with input
    components, as well as validators, converters, and other configurations for *data-binding*.
    You can get the `Binder` instance by calling the `getBinder` method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Editor`需要一种方式来知道每个列应该使用哪种输入组件，以及如何获取这些输入组件的值，以及用户编辑后如何将这些值设置回对象中。这是通过两个方法完成的：`Grid.Editor.getBinder`和`Grid.Column.setEditorBinding`。你应该熟悉Vaadin框架中的`Binder`类；它是一个实用工具类，允许你将`setters`和`getters`与输入组件以及验证器、转换器和其他数据绑定配置连接起来。你可以通过调用`getBinder`方法来获取`Binder`实例：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The basic idea of the `Binder` class is that you can specify an input component
    and bind a getter and a setter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Binder`类的基本思想是你可以指定一个输入组件，并绑定一个获取器和设置器：'
- en: '`binder.bind(textField, User::getFirstName, User::setLastName);`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`binder.bind(textField, User::getFirstName, User::setLastName);`。'
- en: 'If you are not familiar with the `Binder` class, go through the must-read documentation
    at: [https://vaadin.com/docs/v8/framework/datamodel/datamodel-forms.html](https://vaadin.com/docs/v8/framework/datamodel/datamodel-forms.html).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉`Binder`类，请阅读以下必读文档：[https://vaadin.com/docs/v8/framework/datamodel/datamodel-forms.html](https://vaadin.com/docs/v8/framework/datamodel/datamodel-forms.html)。
- en: 'With the `Editor` enabled, we can set an input component for each column. For
    example, we can use a `TextField` for the First Name column using the `setEditorBinding`
    method as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`Editor`后，我们可以为每一列设置一个输入组件。例如，我们可以使用`setEditorBinding`方法将`TextField`用于“名字”列，如下所示：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `setEditorBinding` accepts a `Binding` instance that we can easily get from
    the `binder`. We use the `forField` method in the `Binder` to specify a new `TextField`,
    and the `bind` method, which returns an instance of `Binding`, to configure the
    corresponding `getter` and setter in the `User` bean. The end result is that when
    you double-click a row in the `Grid`, the `Editor` will present a new `TextField`
    in the first name cell, which will set its value to what `User::getFirstName`
    returns, and will call `User::setFirstName`, passing the value in the `TextField`
    when you click the Save button.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`setEditorBinding`接受一个`Binding`实例，我们可以很容易地从`binder`中获取它。我们使用`Binder`中的`forField`方法指定一个新的`TextField`，并使用返回`Binding`实例的`bind`方法来配置`User`对象中的相应`getter`和`setter`。最终结果是，当你双击`Grid`中的行时，`Editor`将在名字单元格中呈现一个新的`TextField`，并将其值设置为`User::getFirstName`返回的值，并在点击保存按钮时调用`User::setFirstName`，传递`TextField`中的值。'
- en: Be careful when you set several editor bindings and copy/paste code. You might
    forget to change one of the three method references, which would result in strange
    behaviors, such as values not being updated or values being updated in wrong fields
    in the bean.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置多个编辑器绑定并复制粘贴代码时，请注意。你可能会忘记更改三个方法引用中的一个，这会导致出现奇怪的行为，例如值没有更新或值在对象中更新到错误的字段。
- en: 'In order to persist the edited `User` instance, we need to add an `EditorSaveListener`,
    which, conveniently, is a functional interface. We add this listener using the
    `addSaveListener` as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持久化编辑后的`User`实例，我们需要添加一个`EditorSaveListener`，它方便地是一个函数式接口。我们使用`addSaveListener`方法添加此监听器，如下所示：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `save` method can be simply implemented as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`方法可以简单地实现如下：'
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Adding Bean Validation with JSR-303
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSR-303添加Bean验证
- en: 'JSR-303 is the specification for **Java Bean Validation**. It makes it possible
    to use annotations such as `@NotNull`, `@Email`, and `@Size` to indicate constraints
    in a Java Bean. Java Bean Validation is a specification and there are several
    implementations for it, two of the most popular ones being **Hibernate Validation**
    and *Apache Bean Validation*. Since we are already using Hibernate in this chapter''s
    example, it makes sense to use Hibernate Validation as well. This is done by adding
    the `hibernate-validator` dependency in the `pom.xml` file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: JSR-303是**Java Bean验证**的规范。它使得使用`@NotNull`、`@Email`和`@Size`等注解来指示Java Bean中的约束成为可能。Java
    Bean验证是一个规范，并且有几种实现，其中两个最受欢迎的是**Hibernate Validation**和*Apache Bean Validation*。由于我们已经在本章的示例中使用了Hibernate，因此使用Hibernate
    Validation也是合理的。这是通过在`pom.xml`文件中添加`hibernate-validator`依赖项来完成的：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After this, we can use the annotations available in the `javax.validation.constraints`
    package in the `User` class. The following code adds *not-null* constraints to
    the `firstName`, `lastName`, and `password` fields, an *email-format* constraint
    to the `email` field, and a *size* (or length) constraint to the `password` field:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以在`User`类中使用`javax.validation.constraints`包中可用的注解。以下代码为`firstName`、`lastName`和`password`字段添加了*非空*约束，为`email`字段添加了*电子邮件格式*约束，以及为`password`字段添加了*大小*（或长度）约束：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to make it work with the `Editor`, we need to add `BeanValidators`
    to its `Binder`. The following snippet of code shows how to add it to the First
    Name column:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其与`Editor`一起工作，我们需要将其`Binder`中的`BeanValidators`添加。以下代码片段显示了如何将其添加到第一个名称列：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we also called `withNullRepresentation`. This allows us to use an
    empty `String` on the client side, and interpret them as null values on the server
    side. The `BeanValidator` implementation is provided by the framework, and will
    take care of running validations for each JavaBean Validation annotation in the
    `User` class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还调用了`withNullRepresentation`。这允许我们在客户端使用空`String`，并在服务器端将它们解释为null值。`BeanValidator`的实现由框架提供，并将负责为`User`类中的每个JavaBean验证注解运行验证。
- en: Unfortunately, you have to specify the name of the property as a `String` literal,
    which is not type-safe, and might lead to problems if you forget to update it
    when you refactor the name of the property. On the other hand, modern IDEs are
    capable of suggesting such changes when you use the tools for refactoring Java
    identifiers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你必须指定属性的名称为一个`String`字面量，这并不是类型安全的，如果在重构属性名称时忘记更新它，可能会导致问题。另一方面，现代IDE能够在你使用Java标识符重构的工具时建议这样的更改。
- en: You can use the same approach to configure the `Editor` for the rest of the
    columns in the `Grid`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的方法来配置`Grid`中其余列的`Editor`。
- en: As an exercise, try implementing the `add` operation by creating a button to
    add a new empty row. When the button is clicked, you can create and persist a
    new `User` (you will have to set default values for the `firstName`, `lastName`,
    and `password` fields of the `User` class), refresh the `Grid`, and open the editor
    for the new `User` using the `grid.getEditor().editRow(rowIndex)` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试通过创建一个按钮来添加一个新空行来实现`add`操作。当按钮被点击时，你可以创建并持久化一个新的`User`（你将不得不为`User`类的`firstName`、`lastName`和`password`字段设置默认值），刷新网格，并使用`grid.getEditor().editRow(rowIndex)`方法打开新`User`的编辑器。
- en: Implementing a CRUD using Grids and forms
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格和表单实现CRUD
- en: 'In this section, we''ll develop a CRUD user interface using modal pop-up windows
    to show a form for adding and editing `User` instances. The following is a screenshot
    of the finished form:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个使用模态弹出窗口显示添加和编辑`User`实例表单的CRUD用户界面。以下是为完成表单的截图：
- en: '![](img/d395e297-9851-40f4-9c87-9285f41a0285.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d395e297-9851-40f4-9c87-9285f41a0285.png)'
- en: 'Let''s start with the following component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下组件开始：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are a few things to take notice of here. We are using the `Grid(Class<T>
    beanType)` constructor, which means columns are created automatically, and we''ll
    be able to reference them later by name. We are using the `VaadinIcons` class
    to set icons instead of text for the refresh (read), add, and update buttons.
    This class is included in the Vaadin Framework. Finally, we are using a `CssLayout`
    with the `LAYOUT_COMPONENT_GROUP` style, which makes the buttons look like a toolbar.
    The following is a screenshot of the component at this point:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有一些需要注意的事情。我们使用 `Grid(Class<T> beanType)` 构造函数，这意味着列是自动创建的，我们稍后可以通过名称引用它们。我们使用
    `VaadinIcons` 类为刷新（读取）、添加和更新按钮设置图标而不是文本。这个类包含在 Vaadin 框架中。最后，我们使用具有 `LAYOUT_COMPONENT_GROUP`
    样式的 `CssLayout`，这使得按钮看起来像工具栏。以下是这个组件的截图：
- en: '![](img/b8903e5b-b814-4ae9-80be-64cb58039c36.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8903e5b-b814-4ae9-80be-64cb58039c36.png)'
- en: Implementing the read operation
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现读取操作
- en: 'We can start by configuring the columns we actually want to show in the `Grid`.
    Since the columns were automatically created by the constructor, we can set their
    visibility by name using the `setColumns` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先配置我们实际上想在 `Grid` 中显示的列。由于列是由构造函数自动创建的，我们可以使用 `setColumns` 方法按名称设置它们的可见性：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In contrast to the previous editable `Grid`, we don't need the *Password* column
    here, since we are not using an `Editor`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的可编辑 `Grid` 相比，这里我们不需要 *密码* 列，因为我们没有使用 `Editor`。
- en: 'We can continue by adding a click listener to the `refresh` button, and implementing
    the `refresh` method. This is pretty straightforward:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续通过向 `refresh` 按钮添加点击监听器并实现 `refresh` 方法。这相当直接：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We introduced a new `updateHeader` method to enable or disable the `edit` button
    depending on the selection state in the `Grid`. It makes sense to have the `edit`
    button enabled only when there's a row selected. We need to call this method when
    we refresh the list and when the value selected in the `Grid` changes (see the
    `Grid.addValueChangeListener` method).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个新的 `updateHeader` 方法，用于根据 `Grid` 中的选择状态启用或禁用 `edit` 按钮。只有当有行被选中时，启用 `edit`
    按钮才有意义。我们需要在刷新列表和 `Grid` 中选中的值发生变化时调用此方法（参见 `Grid.addValueChangeListener` 方法）。
- en: Implementing the create and update operations
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现创建和更新操作
- en: 'The *create* CRUD operation starts when the user clicks the `add` button. Similarly,
    the *update* CRUD operation starts when the user clicks the `update` button. We
    need the following *infrastructur**e* code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建* CRUD 操作在用户点击 `add` 按钮时开始。同样，*更新* CRUD 操作在用户点击 `update` 按钮时开始。我们需要以下 *基础设施*
    代码：'
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When any of the buttons is clicked, we show a `UserFormindow` (implemented
    shortly). For the `add` button, we pass a new `User` instance. For the `update`
    button, we pass the `User` instance selected in the `Grid`. We can implement `UserWindow`
    as an inner class inside `CustomCrud`. We''ll omit the details of the layout configuration,
    and focus on the data binding part. Let''s start with the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何按钮被点击时，我们会显示一个 `UserFormindow`（稍后实现）。对于 `add` 按钮，我们传递一个新的 `User` 实例。对于 `update`
    按钮，我们传递在 `Grid` 中选中的 `User` 实例。我们可以在 `CustomCrud` 内部实现 `UserWindow` 作为内部类。我们将省略布局配置的细节，并专注于数据绑定部分。让我们从以下内容开始：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All the input fields in the form are members of the `UserFormWindow` class,
    and are added to some sort of layout in the `initLayout` method (not shown). The
    `initBehaviour` method should configure the data binding between the `User` instance
    and the input fields. It also should add behavior to the `cancel` and `save` buttons.
    Let''s think about what''s required before we start coding:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表单中的所有输入字段都是 `UserFormWindow` 类的成员，并在 `initLayout` 方法（未显示）中添加到某种布局中。`initBehaviour`
    方法应配置 `User` 实例和输入字段之间的数据绑定。它还应向 `cancel` 和 `save` 按钮添加行为。在我们开始编码之前，让我们考虑一下需要什么：
- en: We need data-binding. In the Vaadin Framework, that usually means using a `Binder`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要数据绑定。在 Vaadin 框架中，这通常意味着使用 `Binder`。
- en: We need to bind the fields in the `UserFormWindow` class to the fields in the
    `User` class.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将 `UserFormWindow` 类中的字段绑定到 `User` 类中的字段。
- en: We need to make sure that the input fields show the correct values initially.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保输入字段最初显示正确的值。
- en: We need to make sure that the values in the input fields are written in the
    `User` instance when the save button is clicked.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保在点击保存按钮时，输入字段的值被写入 `User` 实例。
- en: We need to make sure no values are written in the `User` instance when the cancel
    button is clicked.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保在点击取消按钮时，`User` 实例中没有写入任何值。
- en: 'Now, we can start coding:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编码了：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Two important things happen in the previous code: one) all the Java fields
    that are also input fields in the `UserFormWindow` class are bound to the Java
    fields in the `User` class (with the `bindIntanceFields` call); and two), all
    the values in the Java fields of the `User` class are set to the corresponding
    input fields in the `UserFormWindow` class (with the `readBean` call).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中发生了两件重要的事情：一是 `UserFormWindow` 类中也是输入字段的 Java 字段都绑定到了 `User` 类中的 Java
    字段（通过 `bindIntanceFields` 调用）；二是 `User` 类中的所有值都设置到了 `UserFormWindow` 类中相应的输入字段（通过
    `readBean` 调用）。
- en: 'Finally, the following code adds the behavior to the buttons:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码为按钮添加了行为：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The listener on the `cancel` button only has to call `Window.close()` (inherited).
    The listener on the `save` button calls `writeBean` in order to write the values
    in the input fields in the `user` instance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancel` 按钮的监听器只需调用 `Window.close()`（继承）。`save` 按钮的监听器调用 `writeBean` 以将输入字段中的值写入
    `user` 实例。'
- en: 'Notice that `writeBean` throws a `ValidationException`. There are no validations
    at the moment, though. Adding the JavaBean Validation constraints we have in the
    `User` class is as simple as changing the `Binder` implementation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`writeBean` 会抛出 `ValidationException`。目前还没有验证。添加 `User` 类中已有的 JavaBean 验证约束与更改
    `Binder` 实现一样简单。
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementing the delete operation
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现删除操作
- en: 'Let''s implement the *delete* CRUD operation using a different approach. Instead
    of simply adding one single button for the operation, we''ll add a delete button
    on each row in the `Grid`. The simplest way of adding a UI component inside a
    `Grid` is by using the `addComponentColumn` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用不同的方法来实现 *删除* CRUD 操作。而不是简单地添加一个用于操作的单独按钮，我们将在 `Grid` 的每一行上添加一个删除按钮。在 `Grid`
    中添加 UI 组件的最简单方法是通过使用 `addComponentColumn` 方法：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `addComponentColumn` method accepts a `ValueProvider` used to get a UI component.
    The constructor used to create the `Button` accepts a click listener that, in
    turn, calls the `showRemoveWindow` method, passing the `User` instance corresponding
    to the row where the button resides. The actual implementation of the `RemoveWindow`
    class is left as an exercise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`addComponentColumn` 方法接受一个 `ValueProvider`，用于获取 UI 组件。创建 `Button` 时使用的构造函数接受一个点击监听器，该监听器反过来调用
    `showRemoveWindow` 方法，并传递按钮所在的行对应的 `User` 实例。`RemoveWindow` 类的实际实现留作练习。'
- en: The `addComponentColumn` method is a shortcut to `addColumn(user -> new Button("Delete",
    e -> deleteClicked(user)), new ComponentRenderer())`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`addComponentColumn` 方法是 `addColumn(user -> new Button("Delete", e -> deleteClicked(user)),
    new ComponentRenderer())` 的快捷方式。'
- en: Using the Crud UI add-on
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Crud UI 插件
- en: 'Thanks to its open source nature, there are hundreds of third-party components
    and utilities published available at: [https://vaadin.com/directory](https://vaadin.com/directory).
    One of them does almost all the work we have done in this chapter. The following
    class shows how to implement a CRUD user interface using the `Crud UI add-on`
    available at [https://vaadin.com/directory/component/crud-ui-add-on](https://vaadin.com/directory/component/crud-ui-add-on),
    which is maintained by the author of this book:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其开源性质，有数百个第三方组件和实用工具在 [https://vaadin.com/directory](https://vaadin.com/directory)
    上发布可用。其中之一几乎完成了本章中我们所做的大部分工作。以下类展示了如何使用在 [https://vaadin.com/directory/component/crud-ui-add-on](https://vaadin.com/directory/component/crud-ui-add-on)
    可用的 `Crud UI 插件` 来实现 CRUD 用户界面，该插件由本书的作者维护：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The add-on offers several configuration options, such as the possibility to
    configure a layout, set field providers, and use JavaBean Validation. It also
    delegates the CRUD operations to your own code, allowing you to use any kind of
    Java backend technology. The following is a screenshot of the CRUD component created
    with the Crud UI add-on:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件提供了一些配置选项，例如配置布局、设置字段提供者以及使用 JavaBean 验证。它还将 CRUD 操作委托给您的代码，允许您使用任何类型的 Java
    后端技术。以下是用 Crud UI 插件创建的 CRUD 组件的截图：
- en: '![](img/09d24af9-0ffb-409c-bc9d-cfffc25b8d59.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09d24af9-0ffb-409c-bc9d-cfffc25b8d59.png)'
- en: Filtering
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: 'Filtering can be implemented by adding UI components such as a `TextField`
    and a `ComoboBox` with value listeners on them. When the user changes the filtering
    components, the value listeners update the data by passing their values to the
    backend and updating the view accordingly. For example, in order to filter by
    last name, the `UserRepository.findAll` method should accept a string with the
    value to match:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤可以通过添加UI组件来实现，例如带有值监听器的`TextField`和`ComoboBox`。当用户更改过滤组件时，值监听器通过将它们的值传递到后端并相应地更新视图来更新数据。例如，为了按姓氏过滤，`UserRepository.findAll`方法应该接受一个包含要匹配值的字符串：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Always keep in mind that `findAll` methods are useful and safe to use when they
    return a small number of results. When this is not the case, you should add *lazy
    loading* capabilities like the ones discussed in [Chapter 9](a297744e-ca27-423b-96a2-b28326405871.xhtml),
    *Lazy Loading*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住，当`findAll`方法返回少量结果时，它们是有用且安全的。当这种情况不成立时，你应该添加像在第9章中讨论的*延迟加载*能力。
- en: 'Assuming there is a `lastNameFilter` input component (of type `TextField`,
    for example), the `Grid` should be populated using the new method, and passing
    the value in the filter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个`lastNameFilter`输入组件（例如，类型为`TextField`），`Grid`应该使用新方法填充，并传递过滤中的值：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned how to implement *generic* CRUD user interfaces.
    We studied three different UI designs for CRUD user interfaces: in-place fields,
    modal pop-up windows, and hierarchical menus. We learned about Project Lombok,
    which allows us to reduce the amount of boilerplate code needed in Java programs,
    and we implemented a domain model using JPA and JavaBean Validation constraints.
    We also covered data binding with the `Binder` class, `Grid` renderers, and filtering.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何实现*通用* CRUD用户界面。我们研究了三种不同的CRUD用户界面的UI设计：原地字段、模态弹出窗口和分层菜单。我们了解了Project
    Lombok，它允许我们在Java程序中减少所需的样板代码量，并使用JPA和JavaBean验证约束实现了领域模型。我们还涵盖了使用`Binder`类、`Grid`渲染器和过滤的数据绑定。
- en: 'In the next chapter, we''ll explore another interesting topic that is useful
    in many business applications: generating and visualizing reports.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个在许多商业应用中非常有用的有趣主题：生成和可视化报告。
