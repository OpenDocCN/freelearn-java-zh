- en: '*Chapter 13*: Functional Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 13 章*：函数式编程'
- en: This chapter brings you into the world of functional programming. It explains
    what a functional interface is, provides an overview of the functional interfaces
    that come with JDK, and defines and demonstrates Lambda expressions and how to
    use them with functional interfaces, including using **method reference**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带你进入函数式编程的世界。它解释了什么是函数式接口，概述了随 JDK 一起提供的函数式接口，并定义和演示了 Lambda 表达式以及如何使用函数式接口使用它们，包括使用**方法引用**。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is functional programming?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: Standard functional interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准函数式接口
- en: Functional pipelines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能型管道
- en: Lambda expression limitations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式限制
- en: Method reference
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法引用
- en: By the end of the chapter, you will be able to write functions and use them
    for Lambda expressions in order to pass them as method parameters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够编写函数并将它们用于 Lambda 表达式，以便将它们作为方法参数传递。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够执行本章提供的代码示例，你需要以下内容：
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台装有 Microsoft Windows、Apple macOS 或 Linux 操作系统的计算机
- en: Java SE version 17 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE 版本 17 或更高版本
- en: An IDE or any code editor you prefer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你喜欢的 IDE 或任何代码编辑器
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. The files with the code examples for this chapter are available on GitHub
    at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the `examples/src/main/java/com/packt/learnjava/ch13_functional` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 1 章*](B18388_01_ePub.xhtml#_idTextAnchor015)，“开始使用 Java 17”中，提供了如何设置 Java
    SE 和 IntelliJ IDEA 编辑器的说明。本章的代码示例文件可在 GitHub 上找到，网址为 [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)，在
    `examples/src/main/java/com/packt/learnjava/ch13_functional` 文件夹中。
- en: What is functional programming?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: Before we provide the definition, let us revisit the code with elements of functional
    programming that we have used already in the preceding chapters. All these examples
    give you a pretty good idea of how a function can be constructed and passed around
    as a parameter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提供定义之前，让我们回顾一下在前几章中已经使用过的具有函数式编程元素的代码。所有这些示例都给你一个很好的想法，了解一个函数是如何构建并作为参数传递的。
- en: 'In [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures,
    Generics, and Popular Utilities*, we talked about the `Iterable` interface and
    its `default void forEach (Consumer<T> function)` method, and provided the following
    example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 6 章*](B18388_06_ePub.xhtml#_idTextAnchor141)，“数据结构、泛型和常用工具”中，我们讨论了 `Iterable`
    接口及其 `default void forEach (Consumer<T> function)` 方法，并提供了以下示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can see how a `Consumer e -> System.out.print(e + " ")` function is passed
    into the `forEach()` method and applied to each element flowing into this method
    from the list. We will discuss the `Consumer` function shortly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一个 `Consumer e -> System.out.print(e + " ")` 函数是如何传递到 `forEach()` 方法并应用于从列表流入此方法的每个元素的。我们将在稍后讨论
    `Consumer` 函数。
- en: 'We also mentioned two methods of the `Collection` interface that accept a function
    as a parameter too:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了 `Collection` 接口接受函数作为参数的两个方法：
- en: The `default boolean remove(Predicate<E> filter)` method attempts to remove
    all the elements that satisfy the given predicate from the collection; a `Predicate`
    function accepts an element of the collection and returns a Boolean value.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default boolean remove(Predicate<E> filter)` 方法尝试从集合中删除所有满足给定谓词的元素；一个 `Predicate`
    函数接受集合中的一个元素并返回一个布尔值。'
- en: The `default T[] toArray(IntFunction<T[]> generator)` method returns an array
    of all the elements of the collection, using the provided `IntFunction` generator
    function to allocate the returned array.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default T[] toArray(IntFunction<T[]> generator)` 方法返回一个包含集合中所有元素的数组，使用提供的
    `IntFunction` 生成器函数来分配返回的数组。'
- en: 'In the same chapter, we also mentioned the following method of the `List` interface:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一章中，我们还提到了 `List` 接口的方法：
- en: '`default void replaceAll(UnaryOperator<E> operator)`: This replaces each element
    of the list with the result of applying the provided `UnaryOperator` to that element;
    `UnaryOperator` is one of the functions we are going to review in this chapter.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default void replaceAll(UnaryOperator<E> operator)`: 这会将列表中的每个元素替换为应用提供的 `UnaryOperator`
    到该元素的结果；`UnaryOperator` 是我们将在本章中要审查的函数之一。'
- en: 'We described the `Map` interface, its `default V merge(K key, V value, BiFunction<V,V,V>
    remappingFunction)` method, and how it can be used for concatenating the `String`
    values: `map.merge(key, value, String::concat)`. `BiFunction<V,V,V>` takes two
    parameters of the same type and returns the value of the same type as well. The
    `String::concat` construct is called a **method reference** and will be explained
    in the *Method references* section.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了 `Map` 接口，其 `default V merge(K key, V value, BiFunction<V,V,V> remappingFunction)`
    方法，以及它如何用于连接 `String` 值：`map.merge(key, value, String::concat)`。`BiFunction<V,V,V>`
    接受两个相同类型的参数，并返回相同类型的值。`String::concat` 构造称为 **方法引用**，将在 *方法引用* 部分进行解释。
- en: 'We provided the following example of passing a `Comparator` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了以下传递 `Comparator` 函数的示例：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It takes two `String` parameters, then compares the first one to `null`. If
    the first parameter is `null`, the function returns `-1`; otherwise, it compares
    the first parameter and the second one using the `compareTo()` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受两个 `String` 参数，然后比较第一个参数与 `null`。如果第一个参数是 `null`，则函数返回 `-1`；否则，它使用 `compareTo()`
    方法比较第一个参数和第二个参数。
- en: 'In [*Chapter 11*](B18388_11_ePub.xhtml#_idTextAnchor247), *Network Programming*,
    we looked at the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第11章*](B18388_11_ePub.xhtml#_idTextAnchor247)，*网络编程* 中，我们查看以下代码：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `BodyHandler` object (a function) is generated by the `BodyHandlers.ofString()`
    factory method and passed into the `send()` method as a parameter. Inside the
    method, the code calls its `apply()` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`BodyHandler` 对象（一个函数）由 `BodyHandlers.ofString()` 工厂方法生成，并作为参数传递给 `send()`
    方法。在方法内部，代码调用其 `apply()` 方法：'
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, in [*Chapter 12*](B18388_12_ePub.xhtml#_idTextAnchor266), *Java GUI
    Programming*, we used an `EventHandler` function as a parameter in the following
    code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 [*第12章*](B18388_12_ePub.xhtml#_idTextAnchor266)，*Java GUI 编程* 中，我们使用了 `EventHandler`
    函数作为以下代码片段的参数：
- en: '[PRE19]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first function is `EventHandler<ActionEvent>`. This prints a message and
    forces the application to exit. The second is the `EventHandler<WindowEvent>`
    function. This just prints the message.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是 `EventHandler<ActionEvent>`。这个函数会打印一条消息并强制应用程序退出。第二个是 `EventHandler<WindowEvent>`
    函数。它只是打印一条消息。
- en: This ability to pass a function as a parameter constitutes functional programming.
    It is present in many programming languages and does not require the managing
    of object states. The function is stateless. Its result depends only on the input
    data, no matter how many times it is called. Such coding makes the outcome more
    predictable, which is the most attractive aspect of functional programming.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为参数传递的能力构成了函数式编程。这在许多编程语言中都有体现，并且不需要管理对象状态。函数是无状态的。它的结果仅取决于输入数据，无论调用多少次。这种编码使得结果更加可预测，这是函数式编程最具吸引力的方面。
- en: The area that benefits the most from such a design is parallel data processing.
    Functional programming allows for shifting the responsibility for parallelism
    from the client code to the library. Before that, in order to process elements
    of Java collections, the client code had to iterate over the collection and organize
    the processing. In Java 8, new (default) methods were added that accept a function
    as a parameter and then apply it to each element of the collection, in parallel
    or not, depending on the internal processing algorithm. So, it is the library’s
    responsibility to organize parallel processing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从这种设计中获得最大好处的是并行数据处理。函数式编程允许将并行责任从客户端代码转移到库。在此之前，为了处理 Java 集合的元素，客户端代码必须遍历集合并组织处理。在
    Java 8 中，添加了新的（默认）方法，这些方法接受一个函数作为参数，然后将其应用于集合的每个元素，是否并行取决于内部处理算法。因此，组织并行处理的责任在于库。
- en: What is a functional interface?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是函数式接口？
- en: When we define a function, we provide an implementation of an interface that
    has only one abstract method. That is how the Java compiler knows where to put
    the provided functionality. The compiler looks at the interface (`Consumer`, `Predicate`,
    `Comparator`, `IntFunction`, `UnaryOperator`, `BiFunction`, `BodyHandler`, and
    `EventHandler` in the preceding examples), sees only one abstract method there,
    and uses the passed-in functionality as the method implementation. The only requirement
    is that the passed-in parameters must match the method signature. Otherwise, the
    compile-time error is generated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个函数时，我们提供了一个只包含一个抽象方法的接口实现。这就是Java编译器知道将提供的功能放在哪里的方式。编译器查看接口（如前例中的`Consumer`、`Predicate`、`Comparator`、`IntFunction`、`UnaryOperator`、`BiFunction`、`BodyHandler`和`EventHandler`），在那里只看到一个抽象方法，并使用传入的功能作为方法实现。唯一的要求是传入的参数必须与方法签名匹配。否则，将生成编译时错误。
- en: 'That is why any interface that has only one abstract method is called a **functional
    interface**. Please note that the requirement of having **only one abstract method**
    includes the method inherited from the parent interface. For example, consider
    the following interfaces:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，任何只有一个抽象方法的接口都被称为**函数式接口**。请注意，**只有一个抽象方法**的要求包括从父接口继承的方法。例如，考虑以下接口：
- en: '[PRE25]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `A` interface is a functional interface because it has only one abstract
    method, `method1()`. The `B` interface is a functional interface too because it
    has only one abstract method—the same one inherited from the `A` interface. The
    `C` interface is a functional interface because it has only one abstract method,
    `method1()`, which overrides the abstract method of the parent interface, `A`.
    The `D` interface cannot be a functional interface because it has two abstract
    methods—`method1()` from the parent interface, `A`, and `method5()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`A`接口是一个函数式接口，因为它只有一个抽象方法`method1()`。`B`接口也是一个函数式接口，因为它只有一个抽象方法——从`A`接口继承的同一个方法。`C`接口是一个函数式接口，因为它只有一个抽象方法`method1()`，它覆盖了父接口`A`的抽象方法。`D`接口不能是一个函数式接口，因为它有两个抽象方法——从父接口`A`继承的`method1()`和`method5()`。'
- en: To help avoid runtime errors, the `@FunctionalInterface` annotation was introduced
    in Java 8\. It tells the compiler about the intent so the compiler can check and
    see whether there is truly only one abstract method in the annotated interface.
    This annotation also warns a programmer, who reads the code, that this interface
    has only one abstract method intentionally. Otherwise, a programmer may waste
    time adding another abstract method to the interface only to discover at runtime
    that it cannot be done.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助避免运行时错误，Java 8中引入了`@FunctionalInterface`注解。它告诉编译器意图，以便编译器可以检查并查看注解接口中是否确实只有一个抽象方法。此注解还警告阅读代码的程序员，这个接口有意只有一个抽象方法。否则，程序员可能会浪费时间向接口添加另一个抽象方法，结果在运行时发现无法实现。
- en: 'For the same reason, the `Runnable` and `Callable` interfaces, which have existed
    in Java since its early versions, were annotated in Java 8 as `@FunctionalInterface`.
    This distinction is made explicit and serves as a reminder to users that these
    interfaces can be used to create a function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原因，自Java早期版本以来就存在的`Runnable`和`Callable`接口在Java 8中被标注为`@FunctionalInterface`。这种区分是明确的，并作为对用户的提醒，这些接口可以用来创建函数：
- en: '[PRE43]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As with any other interface, the functional interface can be implemented using
    the `anonymous` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他接口一样，函数式接口可以使用`匿名类`来实现：
- en: '[PRE51]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'An object created this way can later be used as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建的对象可以后来按以下方式使用：
- en: '[PRE57]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If we look closely at the preceding code, we notice that there is unnecessary
    overhead. First, there is no need to repeat the interface name, because we declared
    it already as the type for the object reference. And, second, in the case of a
    functional interface that has only one abstract method, there is no need to specify
    the method name that has to be implemented. The compiler and Java runtime can
    figure it out. All we need is to provide the new functionality. The Lambda expressions
    were introduced especially for this purpose.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看前面的代码，我们会注意到存在不必要的开销。首先，没有必要重复接口名称，因为我们已经将其声明为对象引用的类型。其次，对于只有一个抽象方法的函数式接口，没有必要指定必须实现的方法名称。编译器和Java运行时可以自己推断出来。我们需要的只是提供新的功能。Lambda表达式正是为了这个目的而引入的。
- en: What is a Lambda expression?
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Lambda表达式？
- en: The term **Lambda** comes from *lambda calculus*—a universal model of computation
    that can be used to simulate any Turing machine. It was introduced by mathematician
    Alonzo Church in the 1930s. A **Lambda expression** is a function, implemented
    in Java as an anonymous method. It also allows for the omitting of modifiers,
    return types, and parameter types. That makes for a very compact notation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **Lambda** 来自于 *lambda 演算*——一种通用的计算模型，可以用来模拟任何图灵机。它在 20 世纪 30 年代由数学家 Alonzo
    Church 提出。**Lambda 表达式**是一个函数，在 Java 中实现为匿名方法。它还允许省略修饰符、返回类型和参数类型。这使得符号非常紧凑。
- en: 'The syntax of the Lambda expression includes the list of parameters, an arrow
    token (`->`), and a body. The list of parameters can be empty, such as `()`, without
    parentheses (if there is only one parameter), or a comma-separated list of parameters
    surrounded by parentheses. The body can be a single expression or a statement
    block inside braces (`{}`). Let’s look at a few examples:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式的语法包括参数列表、箭头符号 (`->`) 和主体。参数列表可以是空的，例如 `()`，如果没有括号（如果只有一个参数），或者是一个用括号包围的、以逗号分隔的参数列表。主体可以是一个单独的表达式，或者是一个花括号
    `{}` 内的语句块。让我们看看几个例子：
- en: '`() -> 42;` always returns `42`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`() -> 42;` 总是返回 `42`。'
- en: '`x -> x*42 + 42;` multiplies the `x` value by `42`, then adds `42` to the result
    and returns it.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x -> x*42 + 42;` 将 `x` 的值乘以 `42`，然后将 `42` 添加到结果中并返回。'
- en: '`(x, y) -> x * y;` multiplies the passed-in parameters and returns the result.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(x, y) -> x * y;` 将传入的参数相乘并返回结果。'
- en: '`s -> "abc".equals(s);` compares the value of the `s` variable and literal
    `"abc"`; it returns a Boolean result value.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s -> "abc".equals(s);` 比较 `s` 变量和字面量 `"abc"` 的值；它返回一个布尔结果值。'
- en: '`s -> System.out.println("x=" + s);` prints the `s` value with the prefix `"x="`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s -> System.out.println("x=" + s);` 打印带有前缀 `"x="` 的 `s` 值。'
- en: '`(i, s) -> { i++; System.out.println(s + "=" + i); };` increments the input
    integer and prints the new value with the prefix `s + "="`, with `s` being the
    value of the second parameter.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(i, s) -> { i++; System.out.println(s + "=" + i); };` 增加输入整数，并使用前缀 `s +=`
    打印新的值，其中 `s` 是第二个参数的值。'
- en: Without functional programming, the only way to pass some functionality as a
    parameter in Java would be by writing a class that implements an interface, creating
    its object, and then passing it as a parameter. But even the least-involved style
    using an `anonymous` class requires writing too much boilerplate code. Using functional
    interfaces and Lambda expressions makes the code shorter, clearer, and more expressive.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有函数式编程的情况下，Java 中传递某些功能作为参数的唯一方法是通过编写一个实现接口的类，创建其对象，然后将其作为参数传递。但即使是使用匿名类这种最少介入的风格，也需要编写太多的样板代码。使用函数式接口和
    Lambda 表达式可以使代码更短、更清晰、更具表现力。
- en: 'For example, Lambda expressions allow us to reimplement our preceding example
    with the `Runnable` interface, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Lambda 表达式允许我们使用 `Runnable` 接口重新实现前面的例子，如下所示：
- en: '[PRE58]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, creating a functional interface is easy, especially with Lambda
    expressions. But before doing that, consider using one of the 43 functional interfaces
    provided in the `java.util.function` package. This will not only allow you to
    write less code but will also help other programmers who are familiar with the
    standard interfaces to understand your code better.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，创建一个函数式接口很容易，尤其是在使用 Lambda 表达式时。但在这样做之前，考虑使用 `java.util.function` 包中提供的
    43 个函数式接口之一。这不仅可以让你的代码更简洁，而且还能帮助熟悉标准接口的其他程序员更好地理解你的代码。
- en: The local variable syntax for Lambda parameters
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda 参数的局部变量语法
- en: 'Until the release of Java 11, there were two ways to declare parameter types—explicitly
    and implicitly. Here is an explicit version:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 Java 11 的发布，声明参数类型有两种方式——显式和隐式。以下是一个显式版本：
- en: '[PRE59]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following is an implicit parameter type definition:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个隐式参数类型定义：
- en: '[PRE62]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding code, the compiler infers the type of the parameters from the
    interface definition.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，编译器从接口定义中推断参数的类型。
- en: In Java 11, another method of parameter type declaration was introduced using
    the `var` type holder, which is similar to the `var` local variable type holder
    introduced in Java 10 (see [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015),
    *Getting Started with Java 17*).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 11 中，引入了另一种使用 `var` 类型持有器的参数类型声明方法，这与 Java 10 中引入的 `var` 局部变量类型持有器类似（参见
    [*第 1 章*](B18388_01_ePub.xhtml#_idTextAnchor015)，*Java 17 入门*）。
- en: 'The following parameter declaration is syntactically exactly the same as the
    implicit one before Java 11:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参数声明在Java 11之前的语法上与隐式声明完全相同：
- en: '[PRE64]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The new local variable-style syntax allows us to add annotations without defining
    the parameter type explicitly. Let’s add the following dependency to the `pom.xml`
    file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 新的局部变量样式语法允许我们在不显式定义参数类型的情况下添加注解。让我们将以下依赖项添加到`pom.xml`文件中：
- en: '[PRE67]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'It allows us to define passed-in variables as non-null:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们定义传入的变量为非空：
- en: '[PRE72]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'An annotation communicates to the compiler the programmer’s intent, so it can
    warn the programmer during compilation or execution if the declared intent is
    violated. For example, we have tried to run the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注解向编译器传达程序员的意图，因此它可以在编译或执行期间警告程序员如果声明的意图被违反。例如，我们尝试运行以下代码：
- en: '[PRE78]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'It failed with `NullPointerException` at runtime. Then, we have added the annotation
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它在运行时失败，抛出`NullPointerException`。然后，我们按照以下方式添加了注解：
- en: '[PRE80]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The result of running the preceding code looks like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面代码的结果看起来像这样：
- en: '[PRE83]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The Lambda expression was not even executed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式甚至没有被执行。
- en: 'The advantage of the local variable syntax in the case of Lambda parameters
    becomes clear if we need to use annotations when the parameters are the objects
    of a class with a really long name. Before Java 11, the code might have looked
    like the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是具有非常长的类名的对象，我们需要在参数上使用注解时，Lambda参数的局部变量语法的优势就变得明显了。在Java 11之前，代码可能看起来像以下这样：
- en: '[PRE95]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We had to declare the type of the variable explicitly because we wanted to
    add annotations, and the following implicit version would not even compile:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须显式声明变量的类型，因为我们想添加注解，而以下隐式版本甚至无法编译：
- en: '[PRE99]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'With Java 11, the new syntax allows us to use the implicit parameter type inference
    using the `var` type holder:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java 11，新的语法允许我们使用`var`类型持有者进行隐式参数类型推断：
- en: '[PRE102]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: That is the advantage of and the motivation behind introducing the local variable
    syntax for the Lambda parameter’s declaration. Otherwise, consider staying away
    from using `var`. If the type of the variable is short, using its actual type
    makes the code easier to understand.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是引入Lambda参数声明的局部变量语法的优势所在。否则，考虑远离使用`var`。如果变量的类型很短，使用其实际类型可以使代码更容易理解。
- en: Standard functional interfaces
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准函数式接口
- en: 'Most of the interfaces provided in the `java.util.function` package are specializations
    of the following four interfaces: `Consumer<T>`, `Predicate<T>`, `Supplier<T>`,
    and `Function<T,R>`. Let’s review them and then look at a short overview of the
    other 39 standard functional interfaces.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function`包中提供的接口大多是以下四个接口的特化：`Consumer<T>`、`Predicate<T>`、`Supplier<T>`和`Function<T,R>`。让我们回顾它们，然后简要了解一下其他39个标准函数式接口。'
- en: Consumer<T>
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Consumer<T>
- en: 'By looking at the `Consumer<T>` interface definition, `<indexentry content="standard
    functional interfaces:Consumer">`, you can already guess that this interface has
    an abstract method that accepts a parameter of type `T` and does not return anything.
    Well, when only one type is listed, it may define the type of the return value,
    as in the case of the `Supplier<T>` interface. But the interface name serves as
    a clue: the `consumer` name indicates that the method of this interface just takes
    the value and returns nothing, while `supplier` returns the value. This clue is
    not precise but helps to jog the memory.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`Consumer<T>`接口定义，`<indexentry content="standard functional interfaces:Consumer">`，你可以猜出这个接口有一个接受类型为`T`的参数且不返回任何内容的抽象方法。嗯，当只列出一个类型时，它可能定义了返回值的类型，例如`Supplier<T>`接口的情况。但接口名称是一个线索：`consumer`名称表明这个接口的方法只是接受值并返回空，而`supplier`返回值。这个线索并不精确，但有助于唤起记忆。
- en: 'The best source of information about any functional interface is the `java.util.function`
    package API documentation ([https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html)).
    If we read it, we learn that the `Consumer<T>` interface has one abstract and
    one default method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 关于任何函数式接口的最佳信息来源是`java.util.function`包的API文档([https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html))。如果我们阅读它，我们会了解到`Consumer<T>`接口有一个抽象方法和一个默认方法：
- en: '`void accept(T t)`: Applies the operation to the given argument'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void accept(T t)`: 对给定的参数应用操作'
- en: '`default Consumer<T> andThen(Consumer<T> after)`: Returns a composed `Consumer`
    function that performs, in sequence, the current operation followed by the `after`
    operation'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default Consumer<T> andThen(Consumer<T> after)`: 返回一个组合的 `Consumer` 函数，它按顺序执行当前操作后跟
    `after` 操作'
- en: 'It means that, for example, we can implement and then execute it as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，例如，我们可以这样实现并执行：
- en: '[PRE105]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We can also have a factory method that creates the function, for example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以有一个创建函数的工厂方法，例如：
- en: '[PRE108]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now, we can use it as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样使用它：
- en: '[PRE111]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'To demonstrate the `andThen()` method, let’s create the `Person` class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 `andThen()` 方法，让我们创建 `Person` 类：
- en: '[PRE114]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'You may have noticed that `record` is the only property that has a setting.
    We will use it to set a personal record in a consumer function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`record` 是唯一一个可以设置的属性。我们将使用它在消费者函数中设置个人记录：
- en: '[PRE129]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `setRecord` function takes the values of the `Person` object properties
    and some data from an external source and sets the resulting value as the `record`
    property value. Obviously, it could be done in several other ways, but we do it
    for demo purposes. Let’s also create a function that prints the `record` property:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`setRecord` 函数接受 `Person` 对象的属性值和一些来自外部源的数据，并将结果值设置为 `record` 属性值。显然，这也可以用其他几种方式完成，但我们这样做是为了演示目的。让我们也创建一个打印
    `record` 属性值的函数：'
- en: '[PRE133]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The composition of these two functions can be created and executed as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的组合可以创建并执行如下所示：
- en: '[PRE135]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This way, it is possible to create a whole processing pipe of the operations
    that transform the properties of an object that is passed through the pipe.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，就可以创建一个整个处理管道的操作，这些操作会转换通过管道传递的对象的属性。
- en: Predicate<T>
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Predicate<T>
- en: 'This functional interface, `Predicate<T>`, has one abstract method, five defaults,
    and a static method that allows predicates chaining:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数式接口，`Predicate<T>`，有一个抽象方法，五个默认方法，和一个静态方法，允许谓词链式连接：
- en: '`boolean test(T t)`: Evaluates the provided parameter to see whether it meets
    the criteria or not'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean test(T t)`: 评估提供的参数是否满足条件'
- en: '`default Predicate<T> negate()`: Returns the negation of the current predicate'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default Predicate<T> negate()`: 返回当前谓词的否定'
- en: '`static <T> Predicate<T> not(Predicate<T> target)`: Returns the negation of
    the provided predicate'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static <T> Predicate<T> not(Predicate<T> target)`: 返回提供的谓词的否定'
- en: '`default Predicate<T> or(Predicate<T> other)`: Constructs a logical `OR` from
    this predicate and the provided one'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default Predicate<T> or(Predicate<T> other)`: 从这个谓词和提供的谓词构建一个逻辑“或”'
- en: '`default Predicate<T> and(Predicate<T> other)`: Constructs a logical `AND`
    from this predicate and the provided one'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default Predicate<T> and(Predicate<T> other)`: 从这个谓词和提供的谓词构建一个逻辑“与”'
- en: '`static <T> Predicate<T> isEqual(Object targetRef)`: Constructs a predicate
    that evaluates whether or not two arguments are equal according to `Objects.equals(Object,
    Object)`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static <T> Predicate<T> isEqual(Object targetRef)`: 构建一个谓词，用于评估两个参数是否根据 `Objects.equals(Object,
    Object)` 相等'
- en: 'The basic use of this interface is pretty straightforward:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的基本用法相当简单：
- en: '[PRE139]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We can also combine it with the previously created `printWithPrefixAndPostfix(String
    pref, String postf)` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将它与之前创建的 `printWithPrefixAndPostfix(String pref, String postf)` 函数结合使用：
- en: '[PRE142]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The other methods (also called **operations**) can be used for creating operational
    chains (also called **pipelines**), and can be seen in the following examples:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法（也称为**操作**）可用于创建操作链（也称为**管道**），以下是一些示例：
- en: '[PRE149]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The `predicate` objects can be chained into more complex logical statements
    and include all necessary external data, as was demonstrated before.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`predicate` 对象可以被链入更复杂的逻辑语句，并包含所有必要的外部数据，正如之前所演示的那样。'
- en: Supplier<T>
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Supplier<T>
- en: 'This functional interface, `Supplier<T>`, has only one abstract method, `T
    get()`, which returns a value. The basic usage can be seen as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数式接口，`Supplier<T>`，只有一个抽象方法，`T get()`，它返回一个值。基本用法如下所示：
- en: '[PRE182]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'It can be chained with the functions discussed in the preceding sections:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以与前面章节中讨论的函数链式连接：
- en: '[PRE184]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: The `Supplier<T>` function is typically used as an entry point of data going
    into a processing pipeline.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`Supplier<T>` 函数通常用作数据处理管道的数据入口点。'
- en: Function<T, R>
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Function<T, R>
- en: The notation of this and other functional interfaces that return values includes
    the listing of the return type as the last in the list of generics (`R` in this
    case) and the type of the input data in front of it (an input parameter of type
    `T` in this case). So, the `Function<T, R>` notation means that the only abstract
    method of this interface accepts an argument of type `T` and produces a result
    of type `R`. Let’s look at the online documentation ([https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/Function.html](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/Function.html)).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这种和其它返回值的函数接口的表示法包括将返回类型作为泛型列表中的最后一个（在这种情况下是 `R`）和在其前面（在这种情况下是一个类型为 `T` 的输入参数）列出输入数据类型。所以，`Function<T,
    R>` 表示法意味着该接口的唯一抽象方法接受类型为 `T` 的参数并产生类型为 `R` 的结果。让我们看看在线文档（[https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/Function.html](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/Function.html)）。
- en: 'The `Function<T, R>` interface has one abstract method, `R apply(T)`, and two
    methods for operations chaining:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function<T, R>` 接口有一个抽象方法 `R apply(T)` 和两个用于链式操作的方法：'
- en: '`default <V> Function<T,V> andThen(Function<R, V> after)`: Returns a composed
    function that first applies the current function to its input, and then applies
    the `after` function to the result'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default <V> Function<T,V> andThen(Function<R, V> after)`: 返回一个组合函数，它首先将当前函数应用于其输入，然后将
    `after` 函数应用于结果'
- en: '`default <V> Function<V,R> compose(Function<V, T> before)`: Returns a composed
    function that first applies the `before` function to its input, and then applies
    the current function to the result'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default <V> Function<V,R> compose(Function<V, T> before)`: 返回一个组合函数，它首先将 `before`
    函数应用于其输入，然后将当前函数应用于结果'
- en: 'There is also an `identity()` method:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个 `identity()` 方法：
- en: '`static <T> Function<T,T> identity()`: Returns a function that always returns
    its input argument'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static <T> Function<T,T> identity()`: 返回一个总是返回其输入参数的函数'
- en: 'Let’s review all these methods and how they can be used. Here is an example
    of the basic usage of the `Function<T,R>` interface:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾所有这些方法以及它们的使用方式。以下是对 `Function<T,R>` 接口基本使用的示例：
- en: '[PRE193]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'We can also chain it with all the functions we have discussed in the preceding
    sections:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将其与前面章节中讨论的所有函数链式连接：
- en: '[PRE195]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'The `andThen()` method allows constructing a complex function from simpler
    ones. Notice the `divideByTwo.andThen()` line in the following code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`andThen()` 方法允许从更简单的函数构建复杂函数。注意以下代码中的 `divideByTwo.andThen()` 行：'
- en: '[PRE202]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: It describes the sequence of the operations applied to the input value. Notice
    how the return type of the `divideByTwo()` function (`Long`) matches the input
    type of the `incrementAndCreateString()` function.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 它描述了对输入值应用的运算序列。注意 `divideByTwo()` 函数的返回类型（`Long`）与 `incrementAndCreateString()`
    函数的输入类型相匹配。
- en: 'The `compose()` method accomplishes the same result, but in reverse order:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose()` 方法以相反的顺序完成相同的结果：'
- en: '[PRE211]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Now, the sequence of composition of the complex function does not match the
    sequence of the execution. It may be very convenient in the case where the `divideByTwo()`
    function is not created yet and you would like to create it in-line. Then, the
    following construct will not compile:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，复杂函数的组合序列与执行序列不匹配。在 `divideByTwo()` 函数尚未创建且你希望内联创建它的情况下，这可能会非常方便。然后，以下构造将无法编译：
- en: '[PRE216]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'The following line will compile just fine:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将编译无误：
- en: '[PRE219]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: It allows for more flexibility while constructing a functional pipeline, so
    you can build it in a fluent style without breaking the continuous line when creating
    the next operations.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 它在构建函数管道时提供了更多的灵活性，因此你可以在创建下一个操作时以流畅的风格构建它，而不会打断连续行。
- en: 'The `identity()` method is useful when you need to pass in a function that
    matches the required function signature but does nothing. But, it can substitute
    only a function that returns the same type as the input type, as shown in this
    example:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要传入一个与所需函数签名匹配但不起作用的函数时，`identity()` 方法很有用。但是，它只能替换返回类型与输入类型相同的函数，如下例所示：
- en: '[PRE222]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'To demonstrate its usability, let’s assume we have the following processing
    pipeline:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示其可用性，让我们假设我们有一个以下处理管道：
- en: '[PRE226]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Then, we decide that, under certain circumstances, the `multiplyByTwo()` function
    should do nothing. We could add to it a conditional close that turns it on/off.
    But, if we want to keep the function intact or if this function is passed to us
    from third-party code, we can just do the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们决定在某种情况下，`multiplyByTwo()` 函数应该不执行任何操作。我们可以在其中添加一个条件关闭来打开或关闭它。但是，如果我们想保持函数完整或如果这个函数是从第三方代码传递给我们的，我们只需做以下操作：
- en: '[PRE232]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: As you can see, the `multiplyByTwo()` function now does nothing, and the final
    result is different.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`multiplyByTwo()` 函数现在不执行任何操作，最终结果也不同。
- en: Other standard functional interfaces
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他标准函数式接口
- en: 'The other 39 functional interfaces in the `java.util.function` package are
    variations of the four interfaces we have just reviewed. These variations are
    created in order to achieve one or any combination of the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function` 包中的其他 39 个函数式接口是我们刚刚审查的四个接口的变体。这些变体是为了实现以下一个或多个目标而创建的：'
- en: Better performance by avoiding autoboxing and unboxing via the explicit usage
    of `int`, `double`, or `long` primitives
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过显式使用 `int`、`double` 或 `long` 原始类型来避免自动装箱和拆箱，从而提高性能
- en: Allowing two input parameters and/or a shorter notation
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许两个输入参数和/或简短的表达方式
- en: 'Here are just a few examples:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只是几个例子：
- en: '`IntFunction<R>` with the `R apply(int)` method provides a shorter notation
    (without generics for the input parameter type) and avoids autoboxing by requiring
    the primitive `int` as a parameter.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntFunction<R>` 具有带有 `R apply(int)` 方法的 `R`，提供了一种更简短的表达方式（对于输入参数类型没有泛型），并通过要求原始
    `int` 作为参数来避免自动装箱。'
- en: '`BiFunction<T,U,R>` with the `R apply(T,U)` method allows two input parameters;
    `BinaryOperator<T>` with the `T apply(T,T)` method allows two input parameters
    of type `T` and returns a value of the same type, `T`.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BiFunction<T, U, R>` 具有带有 `R apply(T, U)` 方法的 `R` 类型的参数，允许两个输入参数；`BinaryOperator<T>`
    具有带有 `T apply(T, T)` 方法的 `T` 类型的参数，允许两个 `T` 类型的输入参数，并返回相同类型的值，`T`。'
- en: '`IntBinaryOperator` with the `int applAsInt(int,int)` method accepts two parameters
    of the `int` type and returns the value of the `int` type, too.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntBinaryOperator` 具有带有 `int applAsInt(int, int)` 方法的 `int` 类型的参数，并且也返回 `int`
    类型的值。'
- en: If you are going to use functional interfaces, we encourage you to study the
    API of the interfaces of the `java.util.functional` package ([https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html)).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算使用函数式接口，我们鼓励您研究 `java.util.functional` 包的接口 API ([https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/function/package-summary.html)).
- en: Lambda expression limitations
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式限制
- en: 'There are two aspects of a Lambda expression that we would like to point out
    and clarify:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个关于 Lambda 表达式的方面我们想要指出并澄清：
- en: If a Lambda expression uses a local variable created outside it, this local
    variable has to be final or effectively final (not reassigned in the same context).
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个 Lambda 表达式使用了其外部创建的局部变量，那么这个局部变量必须是 final 或实际上是 final（在同一上下文中不会被重新赋值）。
- en: The `this` keyword in a Lambda expression refers to the enclosing context, not
    the Lambda expression itself.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式中的 `this` 关键字指向封装上下文，而不是 Lambda 表达式本身。
- en: 'As in an `anonymous` class, the variable created outside and used inside a
    Lambda expression becomes effectively final and cannot be modified. The following
    is an example of an error caused by the attempt to change the value of an initialized
    variable:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 与匿名类一样，在 Lambda 表达式外部创建并在其中使用的变量成为实际上是 final 的，并且不能被修改。以下是一个尝试更改初始化变量值的错误示例：
- en: '[PRE242]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: The reason for this restriction is that a function can be passed around and
    executed in different contexts (different threads, for example), and an attempt
    to synchronize these contexts would defeat the original idea of the stateless
    function and the evaluation of the expression, depending only on the input parameters,
    not on the context variables. That is why all the local variables used in the
    Lambda expression have to be effectively final, meaning that they can either be
    *declared* final explicitly or *become* final by virtue of not changing the value.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制的原因是函数可以在不同的上下文中传递和执行（例如不同的线程），而尝试同步这些上下文将违背无状态函数的原始想法和表达式的评估，评估仅依赖于输入参数，而不是上下文变量。这就是为什么
    Lambda 表达式中使用的所有局部变量都必须是实际上是 final 的，这意味着它们要么可以显式地声明为 final，要么通过不改变值而成为 final。
- en: 'There is one possible workaround for this limitation though. If the local variable
    is of a reference type (but not a `String` or primitive wrapping type), it is
    possible to change its state, even if this local variable is used in the Lambda
    expression:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这种限制，但有一个可能的解决方案。如果局部变量是引用类型（但不是 `String` 或原始包装类型），则可以更改其状态，即使这个局部变量在 Lambda
    表达式中使用：
- en: '[PRE245]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: This workaround should be used with care because of the danger of unexpected
    side effects if this Lambda is executed in a different context.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种 Lambda 在不同上下文中执行可能存在意外副作用的风险，因此应谨慎使用此解决方案。
- en: The `this` keyword inside an `anonymous` class refers to the instance of the
    `anonymous` class. By contrast, inside the Lambda expression, the `this` keyword
    refers to the instance of the class that surrounds the expression, also called
    an **enclosing instance**, **enclosing context**, or **enclosing scope**.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`anonymous` 类内部的 `this` 关键字指向 `anonymous` 类的实例。相比之下，在 Lambda 表达式中，`this` 关键字指向表达式周围的类实例，也称为
    **封装实例**、**封装上下文** 或 **封装作用域**。'
- en: 'Let’s create a `ThisDemo` class that illustrates the difference:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `ThisDemo` 类来展示这种差异：
- en: '[PRE253]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'If we execute the preceding methods, the output will be as shown in the following
    code comments:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行前面的方法，输出将如下所示（代码注释）：
- en: '[PRE271]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: As you can see, the `this` keyword inside the `anonymous` class refers to the
    `anonymous` class instance, while `this` in a Lambda expression refers to the
    enclosing class instance. A Lambda expression just does not (and cannot) have
    a field. A Lambda expression is not a class instance and cannot be referred to
    by `this`. According to Java’s specifications, such an approach *allows more flexibility
    for implementations* by treating `this` the same as the surrounding context.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`anonymous` 类内部的 `this` 关键字指向 `anonymous` 类实例，而 Lambda 表达式中的 `this` 指向封装类实例。Lambda
    表达式根本不（也不能）有字段。Lambda 表达式不是一个类实例，不能通过 `this` 来引用。根据 Java 的规范，这种做法通过将 `this` 视为周围上下文来提供更多的灵活性。
- en: Method references
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法引用
- en: 'So far, all our functions were short one-liners. Here is another example:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的函数都是简短的单一行。这里有一个例子：
- en: '[PRE274]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'If the function consists of two or more lines, we could implement them as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数由两行或多行组成，我们可以这样实现：
- en: '[PRE285]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'When the size of a function implementation grows beyond several lines of code,
    such a code layout may not be easy to read. It may obscure the overall code structure.
    To avoid this issue, it is possible to move the function implementation into a
    method and then refer to this method in the Lambda expression. For example, let’s
    add one static and one instance method to the class where the Lambda expression
    is used:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数实现的规模超过几行代码时，这种代码布局可能不易阅读。它可能会掩盖整体代码结构。为了避免这个问题，可以将函数实现移动到方法中，然后在 Lambda
    表达式中引用这个方法。例如，让我们向使用 Lambda 表达式的类中添加一个静态方法和一个实例方法：
- en: '[PRE307]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: 'Also, to demonstrate the variety of possibilities, let’s create another class,
    with one static method and one instance method:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了展示各种可能性，让我们创建另一个类，包含一个静态方法和一个实例方法：
- en: '[PRE315]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: 'Now, we can rewrite our last example as follows:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将最后一个示例重写如下：
- en: '[PRE325]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: As you can see, even if each function consists of many lines of code, such a
    structure keeps the code easy to read. Yet, when a one-line Lambda expression
    consists of a reference to an existing method, it is possible to further simplify
    the notation by using a method reference without listing the parameters.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使每个函数由许多行代码组成，这种结构仍然使代码易于阅读。然而，当一行 Lambda 表达式包含对现有方法的引用时，可以通过不列出参数来进一步简化表示法，使用方法引用。
- en: 'The syntax of the method reference is `Location::methodName`, where `Location`
    indicates in which object or class the `methodName` method belongs, and the two
    colons (`::`) serve as a separator between the location and the method name. Using
    method reference notation, the preceding example can be rewritten as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用的语法是 `Location::methodName`，其中 `Location` 表示 `methodName` 方法属于哪个对象或类，而两个冒号
    (`::`) 作为位置和方法名之间的分隔符。使用方法引用表示法，前面的示例可以重写如下：
- en: '[PRE335]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: You have probably noticed that we have intentionally used different locations,
    two instance methods, and two static methods in order to demonstrate the variety
    of possibilities. If it feels like too much to remember, the good news is that
    a modern IDE (IntelliJ IDEA is one example) can do it for you and convert the
    code you are writing to the most compact form. You just have to accept the IDE’s
    suggestion.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们有意使用了不同的位置，两个实例方法，和两个静态方法，以展示各种可能性。如果感觉太多难以记住，好消息是现代IDE（IntelliJ
    IDEA就是一个例子）可以为你完成这项工作，并将你正在编写的代码转换为最紧凑的形式。你只需接受IDE的建议即可。
- en: Summary
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to functional programming by explaining and demonstrating
    the concept of functional interfaces and Lambda expressions. The overview of standard
    functional interfaces that comes with JDK helps you to avoid writing custom code,
    while the method reference notation allows you to write well-structured code that
    is easy to understand and maintain.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过解释和演示函数式接口和Lambda表达式的概念，向你介绍了函数式编程。JDK附带的标准函数式接口概述可以帮助你避免编写自定义代码，而方法引用符号允许你编写结构良好、易于理解和维护的代码。
- en: Now, you are able to write functions and use them for Lambda expressions in
    order to pass them as a method parameter.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你能够编写函数并将它们用于Lambda表达式，以便将它们作为方法参数传递。
- en: In the next chapter, we will talk about data stream processing. We will define
    what data streams are, and look at how to process their data and how to chain
    stream operations in a pipeline. Specifically, we will discuss the streams’ initialization
    and operations (methods), how to connect them in a fluent style, and how to create
    parallel streams.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论数据流处理。我们将定义什么是数据流，并探讨如何处理它们的数据以及如何在管道中链式操作流操作。具体来说，我们将讨论流的初始化和操作（方法），如何以流畅的方式连接它们，以及如何创建并行流。
- en: Quiz
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: 'What is a functional interface? Select all that apply:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是函数式接口？选择所有适用的：
- en: A collection of functions
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数集合
- en: An interface that has only one method
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有一个方法的接口
- en: Any interface that has only one abstract method
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何只有一个抽象方法的接口
- en: Any library written in Java
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何用Java编写的库
- en: 'What is a Lambda expression? Select all that apply:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Lambda表达式？选择所有适用的：
- en: A function, implemented as an anonymous method without modifiers, return types,
    and parameter types
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个作为匿名方法实现的函数，没有修饰符、返回类型和参数类型
- en: A functional interface implementation
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式接口的实现
- en: Any implementation in a Lambda calculus style
  id: totrans-508
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何以Lambda计算风格实现的实现
- en: A notation that includes the list of parameters, an arrow token (->), and a
    body that consists of a single statement or a block of statements
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种包含参数列表、箭头符号（->）和由单个语句或语句块组成的主体符号的表示法
- en: How many input parameters does the implementation of the `Consumer<T>` interface
    have?
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Consumer<T>`接口的实现有多少个输入参数？'
- en: What is the type of the return value in the implementation of the `Consumer<T>`
    interface?
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Consumer<T>`接口的实现中返回值的类型是什么？'
- en: How many input parameters does the implementation of the `Predicate<T>` interface
    have?
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Predicate<T>`接口的实现有多少个输入参数？'
- en: What is the type of the return value in the implementation of the `Predicate<T>`
    interface?
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Predicate<T>`接口的实现中返回值的类型是什么？'
- en: How many input parameters does the implementation of the `Supplier<T>` interface
    have?
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Supplier<T>`接口的实现有多少个输入参数？'
- en: What is the type of the return value in the implementation of the `Supplier<T>`
    interface?
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Supplier<T>`接口的实现中返回值的类型是什么？'
- en: How many input parameters does the implementation of the `Function<T,R>` interface
    have?
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Function<T,R>`接口的实现有多少个输入参数？'
- en: What is the type of the return value in the implementation of the `Function<T,R>`
    interface?
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Function<T,R>`接口的实现中返回值的类型是什么？'
- en: In a Lambda expression, what does the `this` keyword refer to?
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Lambda表达式中，`this`关键字指的是什么？
- en: What is method reference syntax?
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法引用语法是什么？
