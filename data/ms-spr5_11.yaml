- en: Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: In the previous chapter, we discussed implementing typical data flow use cases
    with microservices using Spring cloud data flow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们讨论了使用Spring Cloud Data Flow在微服务中实现典型的数据流使用案例。
- en: Functional Programming marks a shift from traditional imperatives to a more
    declarative style of programming. Reactive programming builds on top of functional
    programming to provide an alternative style.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程标志着从传统的命令式编程转向更声明式的编程风格。响应式编程建立在函数式编程之上，提供了一种替代的风格。
- en: In this chapter, we will discuss the basics of reactive programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论响应式编程的基础知识。
- en: 'The microservice architecture promotes message-based communication. One important
    tenet of reactive programming is building applications around events (or messages).
    Some of the important questions we need to answer include the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构促进基于消息的通信。响应式编程的一个重要原则是围绕事件（或消息）构建应用程序。我们需要回答一些重要的问题，包括以下内容：
- en: What is reactive programming?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是响应式编程？
- en: What are the typical use cases?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 典型的使用案例是什么？
- en: What kind of support does Java provide for it?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java为响应式编程提供了什么样的支持？
- en: What are the reactive features in Spring WebFlux?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring WebFlux中的响应式特性是什么？
- en: The Reactive Manifesto
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式宣言
- en: 'Most applications from a few years back had the luxury of the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前的大多数应用程序都有以下的奢侈条件：
- en: Multi-second response times
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多秒级的响应时间
- en: Multiple hours of offline maintenance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个小时的离线维护
- en: Smaller volumes of data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较小的数据量
- en: 'Times have changed. New devices (mobiles, tablets, and so on) and newer approaches
    (cloud-based) have emerged. In today''s world, we are talking about:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 时代已经改变。新设备（手机、平板等）和新的方法（基于云的）已经出现。在今天的世界中，我们正在谈论：
- en: Sub-second response times
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚秒级的响应时间
- en: 100% availability
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100%的可用性
- en: An exponential increase in data volumes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据量呈指数增长
- en: Different approaches have emerged during the last few years to meet these emerging
    challenges. While reactive programming is not really a new phenomenon, it is one
    of the approaches that have been successful in dealing with these challenges.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中出现了不同的方法来应对这些新兴挑战。虽然响应式编程并不是一个真正新的现象，但它是成功应对这些挑战的方法之一。
- en: The Reactive Manifesto ([http://www.reactivemanifesto.org](http://www.reactivemanifesto.org))
    aims to capture common themes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式宣言（[http://www.reactivemanifesto.org](http://www.reactivemanifesto.org)）旨在捕捉共同的主题。
- en: 'We believe that a coherent approach to systems architecture is needed, and
    we believe that all necessary aspects are already recognised individually: we
    want systems that are Responsive, Resilient, Elastic and Message Driven. We call
    these Reactive Systems.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信需要一个连贯的系统架构方法，并且我们相信所有必要的方面已经被单独认可：我们希望系统具有响应性、弹性、弹性和消息驱动。我们称这些为响应式系统。
- en: Systems built as Reactive Systems are more flexible, loosely coupled, and scalable.
    This makes them easier to develop and amenable to change. They are significantly
    more tolerant of failure, and when failure does occur, they meet it with elegance
    rather than disaster. Reactive Systems are highly responsive, giving users effective
    interactive feedback.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 构建为响应式系统的系统更加灵活、松散耦合和可扩展。这使得它们更容易开发和适应变化。它们对故障更具有容忍性，当故障发生时，它们以优雅的方式而不是灾难性地应对。响应式系统具有高度的响应性，为用户提供有效的交互反馈。
- en: While the Reactive Manifesto clearly states the characteristics of responsive
    systems, it is not as clear on how Reactive Systems are built.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然响应式宣言清楚地阐述了响应式系统的特性，但对于响应式系统的构建方式并不是很清晰。
- en: Characteristics of Reactive Systems
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式系统的特点
- en: 'The following figure shows the important characteristics of Reactive Systems:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了响应式系统的重要特点：
- en: '![](img/9d3c539b-22ee-49c8-a5e4-6b23bd5a740c.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d3c539b-22ee-49c8-a5e4-6b23bd5a740c.png)'
- en: 'The important characteristics are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要特点如下：
- en: '**Responsive**: Systems respond in a timely manner to their users. Clear response
    time requirements are set, and the system meets them in all situations.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：系统对用户做出及时的响应。设置了明确的响应时间要求，并且系统在所有情况下都满足这些要求。'
- en: '**Resilient**: Distributed systems are built using multiple components. Failures
    can occur in any of these components. Reactive Systems should be designed to contain
    failures within a localized space, for example, within each component. This prevents
    the entire system from going down in cases of local failure.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：分布式系统是使用多个组件构建的。任何一个组件都可能发生故障。响应式系统应该被设计成在局部空间内包含故障，例如在每个组件内。这可以防止整个系统在局部故障的情况下崩溃。'
- en: '**Elastic**: Reactive Systems stay responsive under varying loads. When under
    heavy load, these systems can add additional resources while releasing them when
    the load goes down. Elasticity is achieved using commodity hardware and software.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：响应式系统在不同负载下保持响应。在高负载下，这些系统可以添加额外的资源，而在负载减少时释放资源。弹性是通过使用通用硬件和软件实现的。'
- en: '**Message driven**: Reactive Systems are driven by messages (or events). This
    ensures low coupling between components. This guarantees that the different components
    of the system can be scaled independently. Using non-blocking communication ensures
    that threads are alive for a shorter period of time.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：响应式系统由消息（或事件）驱动。这确保了组件之间的低耦合。这保证了系统的不同组件可以独立扩展。使用非阻塞通信确保线程的生存时间更短。'
- en: 'Reactive Systems are responsive to different kinds of stimulus. A few examples
    are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式系统对不同类型的刺激做出响应。一些例子如下：
- en: '**React to events**: Built based on message passing, Reactive Systems respond
    quickly to events.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对事件做出反应**：基于消息传递构建，响应式系统对事件做出快速响应。'
- en: '**React to load**: Reactive Systems stay responsive under varying loads. They
    use more resources under high loads and release them under lesser loads.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对负载做出反应**：响应式系统在不同负载下保持响应。在高负载下使用更多资源，在较低负载下释放资源。'
- en: '**React to failures**: Reactive Systems can handle failures gracefully. Components
    of Reactive Systems are built to localize failures. External components are used
    to monitor the availability of components and have the capability to replicate
    components when needed.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对故障做出反应**：反应式系统可以优雅地处理故障。反应式系统的组件被构建为局部化故障。外部组件用于监视组件的可用性，并在需要时复制组件。'
- en: '**React to users**: Reactive Systems are responsive to users. They do not waste
    time performing additional processing when consumers are not subscribed to specific
    events.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对用户做出反应**：反应式系统对用户做出响应。当消费者未订阅特定事件时，它们不会浪费时间执行额外的处理。'
- en: Reactive use case - a stock price page
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式用例 - 股票价格页面
- en: While the Reactive Manifesto helps us understand the characteristics of a Reactive
    System, it does not really help with understanding how Reactive Systems are built.
    To understand this, we will consider the traditional approach to building a simple
    use case and compares it with the reactive approach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然反应式宣言帮助我们理解反应式系统的特性，但它并不能真正帮助我们理解反应式系统是如何构建的。为了理解这一点，我们将考虑构建一个简单用例的传统方法，并将其与反应式方法进行比较。
- en: The use case we want to build is a stock price page that displays the price
    of a specific stock. As long as the page remains open, we want to update the latest
    price of the stock on the page.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要构建的用例是一个显示特定股票价格的股票价格页面。只要页面保持打开状态，我们希望在页面上更新股票的最新价格。
- en: The traditional approach
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统方法
- en: 'The traditional approach uses polling to check whether the stock price has
    changed. The following sequence diagram shows the traditional approach of building
    such a use case:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 传统方法使用轮询来检查股票价格是否发生变化。以下的序列图展示了构建这样一个用例的传统方法：
- en: '![](img/e04c7836-703e-4344-a494-edd4c03f1f71.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e04c7836-703e-4344-a494-edd4c03f1f71.png)'
- en: Once the page is rendered, it sends AJAX requests to the stock price service
    for the latest price at regular intervals. These calls have to be done irrespective
    of whether the stock price has changed since the web page does not have any knowledge
    of the stock price change.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 页面渲染后，会定期向股票价格服务发送获取最新价格的AJAX请求。这些调用必须进行，无论股票价格是否发生变化，因为网页不知道股票价格的变化。
- en: The reactive approach
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式方法
- en: Reactive approaches involve connecting the different components involved to
    be able to react to events as they occur.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式方法涉及连接不同的组件，以便能够对事件做出反应。
- en: 'When the stock price web page is loaded, the web page registers for events
    from the stock price service. When the stock price change event occurs, an event
    is triggered. The latest stock price is updated on the web page. The following
    sequence diagram shows the reactive approach of building the stock price page:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当股票价格网页加载时，网页会注册股票价格服务的事件。当股票价格变化事件发生时，会触发一个事件。最新的股票价格会更新在网页上。以下的序列图展示了构建股票价格页面的反应式方法：
- en: '![](img/47c7ae5a-4b29-4a4c-b5f7-276764b31395.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47c7ae5a-4b29-4a4c-b5f7-276764b31395.png)'
- en: 'The reactive approach typically involves three steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式方法通常包括三个步骤：
- en: Subscribing to events.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅事件。
- en: Occurrence of events.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件的发生。
- en: Unregistering.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注销。
- en: When the stock price web page is initially loaded, it will subscribe to the
    stock price change event. The way you subscribe is different based on the reactive
    framework and/or the message broker (if any) that you use.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当股票价格网页最初加载时，它会订阅股票价格变化事件。订阅的方式根据使用的反应式框架和/或消息代理（如果有）而有所不同。
- en: When the stock price change event for a specific stock occurs, a new event is
    triggered for all the subscribers of the event. The listener ensures that the
    web page is updated with the latest stock price.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当特定股票的股票价格变化事件发生时，会为所有订阅者触发一个新的事件。监听器确保网页上显示最新的股票价格。
- en: Once the web page is closed (or refreshed), an unregister request is sent out
    by the subscriber.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦网页关闭（或刷新），订阅者会发送注销请求。
- en: Comparison between the traditional and reactive approaches
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统方法和反应式方法之间的比较
- en: The traditional approach is very simple. The reactive approach needs to implement
    a reactive subscribe and event chain. If the event chain involves a message broker,
    it becomes even more complex.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 传统方法非常简单。反应式方法需要实现反应式订阅和事件链。如果事件链涉及消息代理，它会变得更加复杂。
- en: In the traditional approach, we poll for changes. This means that the entire
    sequence is triggered every minute (or the specified interval) irrespective of
    whether there is a change in the stock price. In the reactive approach, once we
    register for the event, the sequence is triggered only when the stock price changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统方法中，我们轮询变化。这意味着每分钟（或指定的间隔）都会触发整个序列，无论股票价格是否发生变化。在反应式方法中，一旦我们注册了事件，只有当股票价格发生变化时才会触发序列。
- en: The lifetime of the threads in the traditional approach is longer. All resources
    used by the thread are locked for a longer duration. Considering the big picture
    of a server serving multiple requests at the same time, there will be more contention
    for threads and their resources. In the reactive approach, threads live for a
    short span and hence there is less contention for resources.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 传统方法中线程的生命周期更长。线程使用的所有资源会被锁定更长时间。考虑到服务器同时为多个请求提供服务的整体情况，线程和它们的资源会有更多的竞争。在反应式方法中，线程的生命周期较短，因此资源的竞争较少。
- en: 'Scaling in the traditional approach involves scaling up the database and creating
    more web servers. Because of the small lifetime of threads, the same infrastructure
    can handle more users in the reactive approach. While the reactive approach has
    all the options of scaling of the traditional approach, it provides more distributed
    options. For example, the triggering of the stock price change event can be communicated
    to the application through a message broker, as shown in the following figure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 传统方法中的扩展涉及扩展数据库并创建更多的Web服务器。由于线程的寿命很短，反应式方法可以处理更多用户。虽然反应式方法具有传统方法的所有扩展选项，但它提供了更多的分布式选项。例如，股价变动事件的触发可以通过消息代理与应用程序通信，如下图所示：
- en: '![](img/35f65ad1-5374-4f11-ae12-452937d91766.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35f65ad1-5374-4f11-ae12-452937d91766.png)'
- en: This means that the web application and the stock price change-triggered application
    can be scaled independently of each other. This gives more options in scaling
    up quickly when the need arises.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Web应用程序和股价变动触发的应用程序可以独立扩展。这在需要时提供了更多的扩展选项。
- en: Reactive programming in Java
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的反应式编程
- en: Java 8 does not have any built-in support for reactive programming. A number
    of frameworks provide reactive features. We will discuss Reactive Streams, Reactor,
    and Spring WebFlux in subsequent sections.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8没有内置对反应式编程的支持。许多框架提供了反应式功能。我们将在后续章节中讨论反应式流、Reactor和Spring WebFlux。
- en: Reactive streams
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式流
- en: Reactive Streams is an initiative to provide a standard for asynchronous stream
    processing with non-blocking back pressure. This encompasses efforts aimed at
    runtime environments (JVM and JavaScript) as well as network protocols.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式流是一项旨在提供异步流处理和非阻塞背压标准的倡议。这包括针对运行时环境（JVM和JavaScript）以及网络协议的努力。
- en: 'A few important things to note are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: Reactive streams aim to define a minimal set of interfaces, methods, and protocols
    to enable reactive programming
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式流旨在定义一组最小的接口、方法和协议，以实现反应式编程
- en: Reactive streams aim to be a language-neutral approach with implementation in
    the Java (JVM-based) and JavaScript languages
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式流旨在成为一种与语言无关的方法，实现在Java（基于JVM）和JavaScript语言中
- en: Multiple transport streams (TCP, UDP, HTTP, and WebSockets) are supported
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个传输流（TCP、UDP、HTTP和WebSockets）
- en: 'Maven dependencies for Reactive Streams are shown as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式流的Maven依赖关系如下所示：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A few of the important interfaces defined in Reactive Streams are shown as
    follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reactive Streams中定义的一些重要接口如下所示：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A few important things to note are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要事项如下：
- en: '**Interface Publisher**: `Publisher` provides a stream of elements in response
    to the demand received from its Subscriber(s). A Publisher can serve any number
    of subscribers. The subscriber count might vary with time.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口发布者**：`Publisher`根据其订阅者的需求提供元素流。一个发布者可以为任意数量的订阅者提供服务。订阅者数量可能会随时间变化。'
- en: '**Interface Subscriber** : `Subscriber` registers to listen to the stream of
    events. Subscribing is a two-step process. The first step is calling Publisher.subscribe(Subscriber).
    The second step involves making a call to Subscription.request(long). Once these
    steps are completed, the subscriber can start processing notifications using the
    `onNext(T t)` method. The `onComplete()` method signals the end of notifications.
    Demand can be signaled via Subscription.request(long) whenever the `Subscriber`
    instance is capable of handling more.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口订阅者**：`Subscriber`注册以监听事件流。订阅是一个两步过程。第一步是调用Publisher.subscribe(Subscriber)。第二步涉及调用Subscription.request(long)。完成这些步骤后，订阅者可以使用`onNext(T
    t)`方法开始处理通知。`onComplete()`方法表示通知的结束。每当`Subscriber`实例能够处理更多时，可以通过Subscription.request(long)发出需求信号。'
- en: '**Interface Subscription** : `Subscription` represents the link between one
    `Subscriber` and its `Publisher`. A subscriber can request more data using `request(long
    n)`. It can cancel the subscription to notifications using the `cancel()` method.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口订阅**：`Subscription`表示`Subscriber`和其`Publisher`之间的链接。订阅者可以使用`request(long
    n)`请求更多数据。它可以使用`cancel()`方法取消通知的订阅。'
- en: Reactor
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactor
- en: Reactor is a reactive framework from the Spring Pivotal team. It builds on top
    of Reactive Streams. As we will discuss later in this chapter, Spring Framework
    5.0 uses the Reactor framework to enable reactive web features.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor是Spring Pivotal团队的一个反应式框架。它建立在Reactive Streams之上。正如我们将在本章后面讨论的那样，Spring
    Framework 5.0使用Reactor框架来实现反应式Web功能。
- en: 'Dependencies for Reactor are shown as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor的依赖关系如下所示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Reactor adds in a couple of important things on top of the `Subscriber`, `Consumer`,
    and `Subscriptions` terminology introduced by Reactive Streams.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor在`Subscriber`、`Consumer`和`Subscriptions`术语的基础上增加了一些重要的内容。
- en: '**Flux**: Flux represents a Reactive Stream that emits 0 to *n* element'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flux**：Flux表示发出0到*n*个元素的反应式流'
- en: '**Mono**: Mono represents a Reactive Stream that emits either no elements or
    one element'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mono**：Mono表示发出零个或一个元素的反应式流'
- en: In subsequent examples, we will create stub Mono and Flux objects, which would
    be pre-configured to emit elements at specific intervals. We will create Consumers
    (or Observers) to listen to these events and react to them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的示例中，我们将创建存根Mono和Flux对象，这些对象将预先配置为在特定时间间隔内发出元素。我们将创建消费者（或观察者）来监听这些事件并对其做出反应。
- en: Mono
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mono
- en: Creating a Mono is very simple. The following Mono emits one element after a
    delay of 5 seconds.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Mono非常简单。以下Mono在5秒延迟后发出一个元素。
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We want to listen to the events from Mono and log them to the console. We can
    do that using the statement specified here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从Mono中监听事件并将其记录到控制台。我们可以使用此处指定的语句来实现：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, if you run the program with the two preceding statements in a `Test`
    annotation as shown in the following code, you would see that nothing is printed
    to the console:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您在以下代码中以`Test`注释运行程序，并运行前面两个语句，您会发现控制台上没有打印任何内容：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Nothing is printed to the console because the `Test` execution ends before
    the Mono emits the element after 5 seconds. To prevent this, let''s delay the
    execution of `Test` using `Thread.sleep`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Test`执行在Mono在5秒后发出元素之前结束，因此不会打印任何内容到控制台。为了防止这种情况，让我们使用`Thread.sleep`延迟`Test`的执行：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we create a subscriber using `stubMonoWithADelay.subscribe(System.out::println)`,
    we are using the functional programming feature introduced in Java 8\. `System.out::println`
    is a method definition. We are passing the method definition as a parameter to
    a method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`stubMonoWithADelay.subscribe(System.out::println)`创建一个订阅者时，我们使用了Java 8引入的函数式编程特性。`System.out::println`是一个方法定义。我们将方法定义作为参数传递给一个方法。
- en: 'This is possible because of a specific functional interface called `Consumer`.
    A functional interface is an interface with only one method. The `Consumer` functional
    interface is used to define an operation that accepts a single input argument
    and returns no result. An outline of the `Consumer` interface is shown in the
    following snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为有一个特定的函数接口叫做`Consumer`。函数接口是只有一个方法的接口。`Consumer`函数接口用于定义接受单个输入参数并返回无结果的操作。`Consumer`接口的概要显示在以下代码片段中：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead of using a lambda expression, we can explicitly define `Consumer` as
    well. The following code snippet shows the important details:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以明确定义`Consumer`，而不是使用lambda表达式。以下代码片段显示了重要细节：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A couple of important things to note are as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要事项如下：
- en: '`class SystemOutConsumer implements Consumer<String>`: We create a `SystemOutConsumer`
    class that implements the functional interface `Consumer`. The type of input is
    `String`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class SystemOutConsumer implements Consumer<String>`：我们创建了一个实现函数接口`Consumer`的`SystemOutConsumer`类。输入类型为`String`。'
- en: '`public void accept(String t)`: We define the accept method to print the content
    of the string to the console.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void accept(String t)`：我们定义accept方法来将字符串的内容打印到控制台。'
- en: '`stubMonoWithADelay.subscribe(new SystemOutConsumer())`: We create an instance
    of `SystemOutConsumer` to subscribe the events.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stubMonoWithADelay.subscribe(new SystemOutConsumer())`：我们创建了一个`SystemOutConsumer`的实例来订阅事件。'
- en: 'The output is shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在以下截图中：
- en: '![](img/3b65fe68-87d9-492d-92c8-e84f58c56aa0.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/3b65fe68-87d9-492d-92c8-e84f58c56aa0.png)
- en: 'We can have multiple subscribers listening on events from a Mono or Flux. The
    following snippet shows how we can create an additional subscriber:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有多个订阅者监听来自Mono或Flux的事件。以下代码片段显示了如何创建额外的订阅者：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A couple of important things to note are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要事项如下：
- en: '`class WelcomeConsumer implements Consumer<String>`: We are creating another
    Consumer class, `WelcomeConsumer`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class WelcomeConsumer implements Consumer<String>`：我们正在创建另一个Consumer类，`WelcomeConsumer`'
- en: '`stubMonoWithADelay.subscribe(new WelcomeConsumer())`: We are adding an instance
    of `WelcomeConsumer` as a subscriber to the events from Mono'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stubMonoWithADelay.subscribe(new WelcomeConsumer())`：我们将`WelcomeConsumer`的一个实例添加为Mono事件的订阅者'
- en: 'The output is shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在以下截图中：
- en: '![](img/7891d557-00d5-4703-8345-60f1c0a992c7.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/7891d557-00d5-4703-8345-60f1c0a992c7.png)
- en: Flux
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux
- en: 'Flux represents a reactive stream emitting 0 to *n* elements. The following
    snippet shows a simple Flux example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Flux代表一个发出0到*n*个元素的响应流。以下代码片段显示了一个简单的Flux示例：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A couple of important things to note are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要事项如下：
- en: '`Flux<String> stubFluxStream = Flux.just("Jane", "Joe")`: We are creating a
    Flux using the `Flux.just` method. It can create simple streams with hardcoded
    elements.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux<String> stubFluxStream = Flux.just("Jane", "Joe")`：我们使用`Flux.just`方法创建了一个Flux。它可以创建包含硬编码元素的简单流。'
- en: '`stubFluxStream.subscribe(new SystemOutConsumer())`: We are registering an
    instance of `SystemOutConsumer` as a subscriber on Flux.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stubFluxStream.subscribe(new SystemOutConsumer())`：我们在Flux上注册了一个`SystemOutConsumer`的实例作为订阅者。'
- en: 'The output is shown in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在以下截图中：
- en: '![](img/f724d985-4bd0-47c0-8f7e-d1557589bc63.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f724d985-4bd0-47c0-8f7e-d1557589bc63.png)
- en: 'The following snippet shows a more complex example of a Flux with two subscribers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个具有两个订阅者的Flux的更复杂的示例：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A few important things to note are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要事项如下：
- en: '`Flux.fromIterable(streamOfNames).delayElements(Duration.ofMillis(1000))`:
    Creates a Flux from the specified list of strings. Elements are emitted at the
    specified delay of 1000 milliseconds.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.fromIterable(streamOfNames).delayElements(Duration.ofMillis(1000))`：从指定的字符串列表创建一个Flux。元素在指定的1000毫秒延迟后发出。'
- en: '`stubFluxWithNames.subscribe(new SystemOutConsumer())` and `stubFluxWithNames.subscribe(new
    WelcomeConsumer())`: We are registering two subscribers on Flux.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stubFluxWithNames.subscribe(new SystemOutConsumer())`和`stubFluxWithNames.subscribe(new
    WelcomeConsumer())`：我们在Flux上注册了两个订阅者。'
- en: '`Thread.sleep(10000)`: Similar to the first Mono example, we introduce sleep
    to make the program wait until all elements from the Flux are emitted.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.sleep(10000)`：与第一个Mono示例类似，我们引入了sleep来使程序等待直到Flux发出的所有元素都被发出。'
- en: 'The output is shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在以下截图中：
- en: '![](img/b955cd0f-3580-4d92-8759-2b6755b67939.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/b955cd0f-3580-4d92-8759-2b6755b67939.png)
- en: Spring Web Reactive
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Web Reactive
- en: '**Spring Web Reactive** is one of the important new features in Spring Framework
    5\. It brings in reactive capabilities for web applications.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Web Reactive**是Spring Framework 5中的一个重要新功能。它为Web应用程序带来了响应式能力。'
- en: 'Spring Web Reactive is based on the same fundamental programming model as Spring
    MVC. The following table provides a quick comparison of the two frameworks:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Web Reactive基于与Spring MVC相同的基本编程模型。以下表格提供了两个框架的快速比较：
- en: '| . | **Spring MVC** | **Spring Web Reactive** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| . | **Spring MVC** | **Spring Web Reactive** |'
- en: '| **Use** | Traditional web application | Reactive web applications |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **用途** | 传统的Web应用程序 | 响应式Web应用程序 |'
- en: '| **Programming Model** | `@Controller` with `@RequestMapping` | The same as
    Spring MVC |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **编程模型** | `@Controller` with `@RequestMapping` | 与Spring MVC相同 |'
- en: '| **Base API** | The Servlet API | Reactive HTTP |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **基本API** | Servlet API | 响应式HTTP |'
- en: '| **Runs on** | Servlet Containers | Servlet Containers(>3.1), Netty, and Undertow
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **运行在** | Servlet容器 | Servlet容器（>3.1）、Netty和Undertow |'
- en: In the subsequent steps, we want to implement a simple use case for Spring Web
    Reactive.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的步骤中，我们希望为Spring Web Reactive实现一个简单的用例。
- en: 'The following are the important steps involved:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是涉及的重要步骤：
- en: Creating a project using Spring Initializr
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Initializr创建项目
- en: Creating a Reactive Controller returning an event stream (Flux)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建返回事件流（Flux）的反应式控制器
- en: Creating an HTML view
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建HTML视图
- en: Creating a project using Spring Initializr
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Initializr创建项目
- en: 'Let''s start with creating a new project using Spring Initializr ([http://start.spring.io/](http://start.spring.io/)).
    The following screenshot shows the details:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用Spring Initializr（[http://start.spring.io/](http://start.spring.io/)）创建一个新项目开始。以下屏幕截图显示了详细信息：
- en: '![](img/52db8feb-2324-4a34-b015-2a5662b71f89.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52db8feb-2324-4a34-b015-2a5662b71f89.png)'
- en: 'A few things to note are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几点如下：
- en: 'Group: `com.mastering.spring.reactive`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：`com.mastering.spring.reactive`
- en: 'Artifact: `spring-reactive-example`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Artifact：`spring-reactive-example`
- en: 'Dependencies : `ReactiveWeb` (to build a reactive web application) and `DevTools`
    (for auto-reload when the application code is changed)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项：`ReactiveWeb`（用于构建反应式Web应用程序）和`DevTools`（用于在应用程序代码更改时进行自动重新加载）
- en: Download the project and import it into your IDE as a Maven project.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下载项目并将其作为Maven项目导入到您的IDE中。
- en: 'Important dependencies in the `pom.xml` file are shown as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`pom.xml`文件中的重要依赖项如下所示：'
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `spring-boot-starter-webflux` dependency is the most important dependency
    for Spring Web Reactive. A quick look at the `pom.xml` file of `spring-boot-starter-webflux`
    reveals the building blocks of Spring Reactive--`spring-webflux`, `spring-web`,
    and `spring-boot-starter-reactor-netty`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-webflux`依赖项是Spring Web Reactive的最重要的依赖项。快速查看`spring-boot-starter-webflux`的`pom.xml`文件，可以看到Spring
    Reactive的构建块--`spring-webflux`、`spring-web`和`spring-boot-starter-reactor-netty`。'
- en: '**Netty** is the default embedded reactive server. The following snippet shows
    the dependencies:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Netty**是默认的嵌入式反应式服务器。以下代码段显示了依赖项：'
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating a Reactive Controller
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个反应式控制器
- en: 'Creating a Spring Reactive Controller is very similar to creating a Spring
    MVC Controller. The basic constructs are the same: `@RestController` and the different
    `@RequestMapping` annotations. The following snippet shows a simple reactive controller
    named `StockPriceEventController`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Spring Reactive Controller与创建Spring MVC Controller非常相似。基本结构相同：`@RestController`和不同的`@RequestMapping`注解。以下代码段显示了一个名为`StockPriceEventController`的简单反应式控制器：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A few important things to note are as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几点如下：
- en: '`@RestController and @GetMapping("/stocks/price/{stockCode}")`: Basic constructs
    are the same as Spring MVC. We are creating a mapping to the specified URI.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RestController`和`@GetMapping("/stocks/price/{stockCode}")`：基本结构与Spring MVC相同。我们正在创建一个映射到指定URI的映射。'
- en: '`Flux<String> retrieveStockPriceHardcoded(@PathVariable("stockCode") String
    stockCode)`: Flux represents a stream of 0 to *n* elements. The return type `Flux<String>`
    indicates that this method returns a stream of values representing the current
    price of a stock.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux<String> retrieveStockPriceHardcoded(@PathVariable("stockCode") String
    stockCode)`：Flux表示0到*n*个元素的流。返回类型`Flux<String>`表示该方法返回表示股票当前价格的值的流。'
- en: '`Flux.interval().map(l -> getCurrentDate() + " : " + getRandomNumber(100, 125))`:
    We are creating a hardcoded Flux returning a stream of random numbers.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.interval().map(l -> getCurrentDate() + " : " + getRandomNumber(100, 125))`：我们正在创建一个硬编码的Flux，返回一系列随机数。'
- en: '`Duration.ofSeconds(5)`: Stream elements are returned every 5 seconds.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Duration.ofSeconds(5)`: 每5秒返回一次流元素。'
- en: '`Flux.<<****>>.log()`: Invoking the `log()` method on Flux helps observe all
    Reactive Streams signals and trace them using Logger support.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flux.<<****>>.log()`: 在Flux上调用`log()`方法有助于观察所有Reactive Streams信号并使用Logger支持对其进行跟踪。'
- en: '`private String getCurrentDate()`: Returns the current time as a string.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private String getCurrentDate()`：将当前时间作为字符串返回。'
- en: '`private int getRandomNumber(int min, int max)`: Returns a random number between
    `min` and `max`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private int getRandomNumber(int min, int max)`：返回`min`和`max`之间的随机数。'
- en: Creating an HTML view
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTML视图
- en: In the previous step, Creating a Reactive Controller, we mapped a Flux stream
    to the `"/stocks/price/{stockCode}"` URL. In this step, let's create a view to
    show the current value of the stock on the screen.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步中，我们将Flux流映射到`"/stocks/price/{stockCode}"` URL。在这一步中，让我们创建一个视图来在屏幕上显示股票的当前价值。
- en: 'We will create a simple static HTML page (`resources/static/stock-price.html`)
    with a button to start retrieving from the stream. The following snippet shows
    the HTML:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的静态HTML页面（`resources/static/stock-price.html`），其中包含一个按钮，用于开始从流中检索。以下代码段显示了HTML：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We want to create a JavaScript method to register with the stream and append
    new elements to a specific div. The following snippet shows the JavaScript method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个JavaScript方法来注册到流中，并将新元素附加到特定的div。以下代码段显示了JavaScript方法：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `EventSource` interface is used to receive server-sent events. It connects
    to a server over HTTP and receives events in a text/event-stream format. When
    it receives an element, the `onmessage` method is called.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSource`接口用于接收服务器发送的事件。它通过HTTP连接到服务器，并以text/event-stream格式接收事件。当它接收到一个元素时，将调用`onmessage`方法。'
- en: 'The following snippet shows the code to register the onclick event for the
    get latest IBM price button:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段显示了注册获取最新IBM价格按钮的onclick事件的代码：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Launching SpringReactiveExampleApplication
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动SpringReactiveExampleApplication
- en: 'Launch the application class `SpringReactiveExampleApplication` as a Java application.
    One of the last messages you would see in the startup log is `Netty started on
    port(s): 8080`. Netty is the default embedded server for Spring Reactive.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '将应用类`SpringReactiveExampleApplication`作为Java应用程序启动。在启动日志中，您将看到的最后一条消息之一是`Netty
    started on port(s): 8080`。Netty是Spring Reactive的默认嵌入式服务器。'
- en: 'The following screenshot shows the browser when you navigate to the `localhost:8080/static/stock-price.html`
    URL:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当您导航到`localhost:8080/static/stock-price.html` URL时，以下屏幕截图显示了浏览器：
- en: '![](img/e5a1fb94-6573-425e-a03e-2efad2b35747.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5a1fb94-6573-425e-a03e-2efad2b35747.png)'
- en: When the Get Latest IBM Price button is clicked, `EventSource` kicks in and
    registers for events from `"/stocks/price/IBM"`. As soon as an element is received,
    it is shown on the screen.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击“获取最新的IBM价格”按钮时，`EventSource`开始注册从`"/stocks/price/IBM"`接收事件。一旦接收到元素，它就会显示在屏幕上。
- en: 'The following screenshot shows the screen after a few events are received.
    You can observe that an event is received every 5 seconds:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了在接收到一些事件后屏幕上的情况。您可以观察到每隔5秒接收到一个事件：
- en: '![](img/25d0acd5-4d9f-44b8-b61d-1dc74e9bc9ad.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25d0acd5-4d9f-44b8-b61d-1dc74e9bc9ad.png)'
- en: 'The next screenshot shows an extract from the log after the browser window
    is closed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了在关闭浏览器窗口后日志中的一部分内容：
- en: '![](img/f6cdc3b3-48f9-4155-b2e3-364ead91bfa5.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6cdc3b3-48f9-4155-b2e3-364ead91bfa5.png)'
- en: You can observe a sequence of `onNext` method calls, which are triggered as
    soon as the element is available. When the browser window is closed, the `cancel()`
    method is called to terminate the stream.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到一系列`onNext`方法调用，这些调用会在元素可用时触发。当关闭浏览器窗口时，将调用`cancel()`方法来终止流。
- en: In this example, we created a controller returning an event stream (as `Flux`)
    and a web page registering to the event stream using `EventSource`. In the next
    example, let's take a look at extending the reach of an event stream to the database.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个控制器返回一个事件流（作为`Flux`），并且一个网页使用`EventSource`注册到事件流。在下一个例子中，让我们看看如何将事件流的范围扩展到数据库。
- en: Reactive databases
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式数据库
- en: All normal databases operations are blocking; that is, the thread waits until
    a response is received from the database.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有普通数据库操作都是阻塞的；也就是说，线程会等待直到从数据库接收到响应。
- en: To fully benefit from Reactive Programming, end-to-end communication has to
    be reactive, that is, based on event streams.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用响应式编程，端到端的通信必须是响应式的，也就是基于事件流的。
- en: '**ReactiveMongo** is designed to be reactive and avoid blocking operations.
    All operations, including select, update, or delete, return immediately. Data
    can be streamed into and out of the database using event streams.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**ReactiveMongo**旨在是响应式的，避免阻塞操作。所有操作，包括选择、更新或删除，都会立即返回。数据可以使用事件流流入和流出数据库。'
- en: In this section, we will use the Spring Boot Reactive MongoDB starter to create
    a simple example connecting to ReactiveMongo.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Spring Boot响应式MongoDB启动器创建一个简单的示例，连接到ReactiveMongo。
- en: 'The following steps are involved:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及以下步骤：
- en: Integrating Spring Boot Reactive MongoDB Starter.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成Spring Boot响应式MongoDB启动器。
- en: Creating a model object the stock document.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建股票文档的模型对象。
- en: Creating `reactiveCrudRepository`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`reactiveCrudRepository`。
- en: Initialising stock data using Command-line Runner.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行运行器初始化股票数据。
- en: Creating Reactive methods in Rest Controller.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Rest Controller中创建响应式方法。
- en: Updating the view to subscribe to the event stream.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新视图以订阅事件流。
- en: Integrating Spring Boot Reactive MongoDB Starter
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Spring Boot响应式MongoDB启动器
- en: 'To connect to the ReactiveMongo database, Spring Boot provides a starter project--Spring
    Boot Reactive MongoDB Starter. Let''s add this to our the `pom.xml` file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到ReactiveMongo数据库，Spring Boot提供了一个启动项目--Spring Boot响应式MongoDB启动器。让我们将其添加到我们的`pom.xml`文件中：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `spring-boot-starter-data-mongodb-reactive` starter brings in the `spring-data-mongodb`,
    `mongodb-driver-async`, and `mongodb-driver-reactivestreams` dependencies. The
    following snippet shows the important dependencies in the `spring-boot-starter-data-mongodb-reactive`
    starter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-data-mongodb-reactive`启动器引入了`spring-data-mongodb`、`mongodb-driver-async`和`mongodb-driver-reactivestreams`依赖项。以下代码片段显示了`spring-boot-starter-data-mongodb-reactive`启动器中的重要依赖项：'
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `EnableReactiveMongoRepositories` annotation enables ReactiveMongo features.
    The following snippet shows it being added to the `SpringReactiveExampleApplication`
    class:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`EnableReactiveMongoRepositories`注解启用了ReactiveMongo的功能。以下代码片段显示了它被添加到`SpringReactiveExampleApplication`类中：'
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating a model object - a stock document
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模型对象 - 一个股票文档
- en: 'We will create the `Stock` document class, as shown in the following code.
    It contains three member variables--`code`, `name`, and `description`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`Stock`文档类，如下所示。它包含三个成员变量--`code`、`name`和`description`：
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating a ReactiveCrudRepository
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个ReactiveCrudRepository
- en: 'Traditional Spring Data Repositories are blocking. Spring Data introduces a
    new repository for interaction with reactive databases. The following code shows
    some of the important methods declared in the `ReactiveCrudRepository` interface:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的Spring Data存储库是阻塞的。Spring Data引入了一个新的存储库用于与响应式数据库交互。以下代码显示了`ReactiveCrudRepository`接口中声明的一些重要方法：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All the methods in the preceding interface are non-blocking. They return either
    Mono or Flux, which can be used to retrieve elements when events are triggered.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的接口中的所有方法都是非阻塞的。它们返回的是Mono或Flux，可以在触发事件时用来检索元素。
- en: 'We want to create a Repository for the Stock Document object. The following
    snippet shows the definition of `StockMongoReactiveCrudRepository`. We extend
    `ReactiveCrudRepository` with `Stock` as the document being managed and a key
    of type `String`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要为股票文档对象创建一个存储库。以下代码片段显示了`StockMongoReactiveCrudRepository`的定义。我们使用`Stock`作为被管理的文档，并且键的类型为`String`来扩展`ReactiveCrudRepository`：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Initialising stock data using the Command Line Runner
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行运行器初始化股票数据
- en: 'Let''s use the Command-line Runner to insert some data into ReactiveMongo.
    The following snippet shows the details added to `SpringReactiveExampleApplication`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用命令行运行器向ReactiveMongo插入一些数据。以下代码片段显示了添加到`SpringReactiveExampleApplication`的详细信息：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `mongoRepository.save()` method is used to save the `Stock` document to
    ReactiveMongo. The `block()` method ensures that the save operation is completed
    before the next statement is executed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`mongoRepository.save()`方法用于将`Stock`文档保存到ReactiveMongo。`block()`方法确保在执行下一条语句之前保存操作已完成。'
- en: Creating Reactive methods in Rest Controller
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rest Controller中创建响应式方法
- en: 'We can now add in the controller methods to retrieve details using `StockMongoReactiveCrudRepository`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加控制器方法来使用`StockMongoReactiveCrudRepository`检索详细信息：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A few important things to note are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要事项需要注意：
- en: '`private final StockMongoReactiveCrudRepository repository`: `StockMongoReactiveCrudRepository`
    is injected in using the constructor injection.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private final StockMongoReactiveCrudRepository repository`：`StockMongoReactiveCrudRepository`通过构造函数注入。'
- en: '`@GetMapping("/stocks") Flux<Stock> list()`: Exposes a `GET` method to retrieve
    a list of stocks. Returns a Flux indicating that this would be a stream of stocks.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GetMapping("/stocks") Flux<Stock> list()`：公开一个`GET`方法来检索股票列表。返回一个Flux，表示这将是一个股票流。'
- en: '`@GetMapping("/stocks/{code}") Mono<Stock> findById(@PathVariable("code") String
    code)`: `findById` returns a Mono, indicating that it would return 0 or 1 stock
    element(s).'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GetMapping("/stocks/{code}") Mono<Stock> findById(@PathVariable("code") String
    code)`：`findById`返回一个Mono，表示它将返回0或1个股票元素。'
- en: Updating the view to subscribe to the event stream
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新视图以订阅事件流
- en: 'We want to update the view with new buttons to trigger events to list all stocks
    and show the details of a specific stock. The following snippet shows the code
    to be added to `resources\static\stock-price.html`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望更新视图，添加新按钮来触发事件以列出所有股票并显示特定股票的详细信息。以下代码显示了要添加到`resources\static\stock-price.html`的代码：
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following snippet enables click events on the new buttons, trigger connection
    with their respective events:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段启用了新按钮的点击事件，触发与它们各自事件的连接：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Launching SpringReactiveExampleApplication
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动SpringReactiveExampleApplication
- en: 'Launch MongoDB and the `SpringReactiveExampleApplication` class. The following
    screenshot shows the screen loading the page at `http://localhost:8080/static/stock-price.html`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 启动MongoDB和`SpringReactiveExampleApplication`类。以下截图显示了在`http://localhost:8080/static/stock-price.html`加载页面时的屏幕：
- en: '![](img/199706d3-6975-4d2b-b217-cdb3cb27bfb5.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/199706d3-6975-4d2b-b217-cdb3cb27bfb5.png)'
- en: 'The following screenshot shows the screen when the stock list is clicked on:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了单击股票列表时的屏幕：
- en: '![](img/4ceb45db-e838-4032-9e23-feda1864ec97.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ceb45db-e838-4032-9e23-feda1864ec97.png)'
- en: 'The following screenshot shows the screen when the `Show IBM Details button`
    is clicked on:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了单击`显示IBM详细信息按钮`时的屏幕：
- en: '![](img/90b80425-9787-40f4-b9c4-a9fd336c9ad2.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90b80425-9787-40f4-b9c4-a9fd336c9ad2.png)'
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a quick peek into the world of Reactive Programming.
    We discussed the important frameworks in the Java Reactive world--Reactive Streams,
    Reactor, and Spring Web Flux. We implemented a simple web page using event streams.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速了解了响应式编程的世界。我们讨论了Java响应式世界中的重要框架--Reactive Streams、Reactor和Spring Web
    Flux。我们使用事件流实现了一个简单的网页。
- en: Reactive Programming is not a silver bullet. While it might not be the correct
    option for all use cases, it is a possible option you should evaluate. Its language,
    framework support, and the use of Reactive Programming are in the initial stages
    of evolution.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程并非万能之策。虽然它可能并非所有用例的正确选择，但它是您应该评估的可能选择。它的语言、框架支持和响应式编程的使用处于初期阶段。
- en: In the next chapter, we will move on to discuss best practices in developing
    applications using Spring Framework.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论使用Spring Framework开发应用程序的最佳实践。
