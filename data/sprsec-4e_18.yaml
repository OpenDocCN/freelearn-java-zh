- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Single Sign-On with the Central Authentication Service
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中央认证服务实现单点登录
- en: In this chapter, we’ll examine the use of the **Central Authentication Service**
    (**CAS**) as a **Single Sign-On** (**SSO**) portal for Spring Security-based applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨将**中央认证服务**（**CAS**）用作基于Spring Security的应用程序的**单点登录**（**SSO**）门户。
- en: 'During the course of this chapter, we’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的讨论过程中，我们将涵盖以下主题：
- en: Learning about **CAS**, its architecture, and how it benefits system administrators
    and organizations of any size
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**CAS**、其架构以及它如何为任何规模的系统管理员和组织带来好处
- en: Understanding how Spring Security can be reconfigured to handle the interception
    of authentication requests and redirect them to **CAS**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何重新配置Spring Security以处理认证请求的拦截并将它们重定向到**CAS**
- en: Configuring the **JBCP Calendar** application to utilize CAS SSO
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置**JBCP日历**应用程序以利用CAS SSO
- en: Gaining an understanding of how the **Single Logout** feature can be implemented,
    and configuring our application to support it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何实现**单点登出**功能，并配置我们的应用程序以支持它
- en: Discussing how to use **CAS** proxy ticket authentication for services, and
    configuring our application to utilize proxy ticket authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论如何使用**CAS**代理票据认证服务，并配置我们的应用程序以利用代理票据认证
- en: Discussing how to customize the out-of-the-box **JA-SIG CAS** server using the
    recommended war overlay approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论如何使用推荐的war覆盖方法自定义开箱即用的**JA-SIG CAS**服务器
- en: Integrating the **CAS** server with **LDAP**, and passing data from **LDAP**
    to **Spring Security** via **CAS**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**CAS**服务器与**LDAP**集成，并通过**CAS**将数据从**LDAP**传递到**Spring Security**
- en: 'This chapter’s code in action link is here: [https://packt.link/lFJjp](https://packt.link/lFJjp).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码示例链接在此：[https://packt.link/lFJjp](https://packt.link/lFJjp)。
- en: Introducing the Central Authentication Service
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍中央认证服务
- en: '**CAS** is an open source, SSO server that provides centralized access control
    and authentication to web-based resources within an organization. The benefits
    of **CAS** for administrators are numerous, and it supports many applications
    and diverse user communities. These benefits are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAS**是一个开源的SSO服务器，为组织内的基于Web的资源提供集中的访问控制和认证。**CAS**对管理员的好处众多，它支持许多应用程序和多样化的用户社区。以下是一些好处：'
- en: Individual or group access to resources (applications) can be configured in
    one location
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在一个位置配置对资源（应用程序）的个体或组访问
- en: Broad support for a wide variety of authentication stores (to centralize user
    management) provides a single point of authentication and control in widely distributed
    cross-machine environments
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛支持各种认证存储（以集中用户管理），在广泛分布的跨机环境中提供单一的认证和控制点
- en: Broad authentication support is provided for web-based and non-web-based Java
    applications through **CAS** client libraries
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**CAS**客户端库为基于Web和非基于Web的Java应用程序提供广泛的认证支持
- en: A single point of reference for user credentials (via **CAS**) is provided so
    that **CAS** client applications are not required to have any knowledge of the
    user’s credentials, or knowledge of how to verify them
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个用户凭据的单一点参考（通过**CAS**），这样**CAS**客户端应用程序就不需要了解用户的凭据，或者了解如何验证它们
- en: In this chapter, we’ll not focus much on the management of **CAS**, but on authentication
    and how **CAS** can act as an authentication point for the users of our site.
    Although **CAS** is commonly seen in intranet environments for enterprises or
    educational institutions, it can also be found in use at high-profile locations
    such as Sony Online Entertainment’s public-facing site.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不会过多关注**CAS**的管理，而是关注认证以及**CAS**如何作为我们网站用户的认证点。尽管**CAS**通常在企业或教育机构的内网环境中使用，但它也可以在高调的位置，如索尼在线娱乐的公共网站中使用。
- en: High-level CAS authentication flow
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级**CAS**认证流程
- en: 'At a high level, **CAS** is composed of a **CAS** server, which is the central
    web application for determining authentication, and one or more **CAS** services,
    which are distinct web applications that use the CAS server to get authenticated.
    The basic authentication flow of **CAS** proceeds via the following actions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，**CAS**由一个**CAS**服务器组成，它是确定认证的中心Web应用程序，以及一个或多个**CAS**服务，它们是使用CAS服务器进行认证的独立Web应用程序。**CAS**的基本认证流程通过以下操作进行：
- en: The user attempts to access a protected resource on the website.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户尝试访问网站上的受保护资源。
- en: The user is redirected through the browser from the **CAS** service to the **CAS**
    server to request a login.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户通过浏览器从 **CAS** 服务重定向到 **CAS** 服务器以请求登录。
- en: The **CAS** server is responsible for user authentication. If the user is not
    already authenticated to the **CAS** server, then the latter requests credentials
    from the user. As shown in the following diagram, the user is presented with a
    login page.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CAS** 服务器负责用户认证。如果用户尚未在 **CAS** 服务器上认证，则后者会请求用户的凭证。如图所示，用户会看到一个登录页面。'
- en: The user submits their credentials (that is, the username and password).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户提交他们的凭证（即用户名和密码）。
- en: If the user’s credentials are valid, the **CAS** server responds with a redirect
    through the browser with a service ticket. A service ticket is a one-time use
    token used to identify a user.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户的凭证有效，**CAS** 服务器将通过浏览器重定向响应一个服务票据。服务票据是一个一次性使用的令牌，用于识别用户。
- en: The **CAS** service calls the **CAS** server back to verify that the ticket
    is valid, has not expired, and so on. Note that this step does not occur through
    the browser.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CAS** 服务调用 **CAS** 服务器以验证票据是否有效、是否已过期等。请注意，这一步骤不是通过浏览器进行的。'
- en: The **CAS** server responds with an assertion indicating that trust has been
    established. If the ticket is acceptable, trust has been established and the user
    may proceed via normal authorization checking.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CAS** 服务器响应一个断言，表明信任已经建立。如果票据是可接受的，则信任已经建立，用户可以通过正常的授权检查继续操作。'
- en: 'This behavior is illustrated visually in the following diagram:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种行为在以下图中进行了视觉展示：
- en: '![Figure 18.1 – High-level CAS authentication flow](img/B21757_18_1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.1 – 高级 CAS 认证流程](img/B21757_18_1.jpg)'
- en: Figure 18.1 – High-level CAS authentication flow
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1 – 高级 CAS 认证流程
- en: We can see that there is a high level of interaction between the **CAS** server
    and the secured application, with several data-exchange handshakes required before
    trust in the user can be established. We assume other network security precautions,
    such as the use of **Secure Sockets Layer** (**SSL**) and network monitoring,
    are in place.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 **CAS** 服务器与受保护应用之间有高度的交互，在建立对用户的信任之前需要几个数据交换握手。我们假设其他网络安全预防措施，如使用 **安全套接字层**（**SSL**）和网络监控，已经到位。
- en: The result of this complexity is a SSO protocol that is quite hard to spoof
    through common techniques.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂性的结果是，一个很难通过常见技术欺骗的 SSO 协议。
- en: Now that we understand how **CAS** authentication works in general, let’s see
    how it applies to Spring Security.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 **CAS** 认证的一般工作原理，让我们看看它如何应用于 Spring Security。
- en: Spring Security and CAS
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 和 CAS
- en: Spring Security has a strong integration capability with **CAS**, although it’s
    not as tightly integrated into the security namespace style of configuration as
    the **OAuth2** and **LDAP** integrations that we’ve explored thus far in the latter
    part of this book. Instead, much of the configuration relies on bean wiring and
    configuration by reference from the security namespace elements to bean declarations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 与 **CAS** 具有强大的集成能力，尽管它不像我们在本书后半部分所探讨的 **OAuth2** 和 **LDAP**
    集成那样紧密地集成到安全命名空间风格的配置中。相反，大部分配置依赖于通过安全命名空间元素到 Bean 声明的 Bean 连接和引用配置。
- en: 'The two basic pieces of **CAS** authentication when using Spring Security involve
    the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Spring Security 时，**CAS** 认证的两大基本组成部分包括以下内容：
- en: Replacement of the standard `AuthenticationEntryPoint` implementation, which
    typically handles redirection of unauthenticated users to the login page with
    an implementation that redirects the user to the CAS server instead
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换标准的 `AuthenticationEntryPoint` 实现，该实现通常处理将未认证用户重定向到登录页面的操作，而这里使用的是将用户重定向到
    CAS 服务器的实现
- en: Processing the service ticket when the user is redirected back from the **CAS**
    server to the protected resource, through the use of a custom servlet filter
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户从 **CAS** 服务器重定向回受保护资源时，通过使用自定义的 Servlet 过滤器处理服务票据
- en: An important thing to understand about **CAS** is that in typical deployments,
    **CAS** is intended to replace all the alternative login mechanisms in our application.
    As such, once we configure **CAS** for Spring Security, our users must use **CAS**
    exclusively as the authentication mechanism for our application. In most cases,
    this is not a problem; as we discussed in the previous section, **CAS** is designed
    to proxy authentication requests to one or more authentication stores (just as
    Spring Security does when delegating to a database or **LDAP** for authentication).
    From the previous diagram (*Figure 18**.1*), we can see that our application is
    no longer checking its own authentication store to validate users. Instead, it
    authenticates the user with service tickets. However, as we will discuss in the
    *Getting the UserDetails object from a CAS assertion* section, initially, Spring
    Security still needs a data store to determine the user’s authorization. We will
    discuss how to remove this restriction later in the chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**CAS**的一个重要理解是，在典型部署中，**CAS**旨在替换我们应用程序中所有替代登录机制。因此，一旦我们为Spring Security配置了**CAS**，我们的用户必须仅使用**CAS**作为我们应用程序的认证机制。在大多数情况下，这不会成为问题；正如我们在上一节中讨论的，**CAS**被设计为代理认证请求到一个或多个认证存储（正如Spring
    Security在委托到数据库或**LDAP**进行认证时所做的）。从之前的图（*图18.1*）中，我们可以看到我们的应用程序不再检查其自己的认证存储来验证用户。相反，它使用服务票据来认证用户。然而，正如我们将在*从CAS断言获取UserDetails对象*部分中讨论的，最初，Spring
    Security仍然需要一个数据存储来确定用户的授权。我们将在本章后面讨论如何去除这个限制。
- en: After completing the basic **CAS** integration with Spring Security, we can
    remove the login link from the home page and enjoy automatic redirection to **CAS**’s
    login screen, where we attempt to access a protected resource. Of course, depending
    on the application, it can also be beneficial to still allow the user to explicitly
    log in (so that they can see customized content, among other things).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成基本的Spring Security与**CAS**集成后，我们可以从主页上删除登录链接，并享受自动重定向到**CAS**的登录屏幕，在那里我们尝试访问受保护资源。当然，根据应用程序的不同，仍然允许用户明确登录（这样他们可以看到定制的内容等）也是有益的。
- en: Required dependencies
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必需的依赖项
- en: 'Before we go too far, we should ensure that our dependencies are updated. The
    following is a list of the dependencies that we have added with comments on when
    they are needed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们走得太远之前，我们应该确保我们的依赖项已更新。以下是我们添加的依赖项列表，并附有它们何时需要的注释：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing and configuring CAS
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置CAS
- en: '**CAS** has the benefit of having an extremely dedicated team behind it that
    has done an excellent job of developing both quality software and accurate, straightforward
    documentation on how to use it. Should you choose to follow along with the examples
    in this chapter, you are encouraged to read the appropriate getting started manual
    for your **CAS** platform. You can find this manual at [https://apereo.github.io/cas/](https://apereo.github.io/cas/).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAS**的好处是有一个极其专注的团队支持它，这个团队在开发高质量的软件和如何使用它的准确、简洁的文档方面做得非常出色。如果您选择跟随本章中的示例，我们鼓励您阅读您**CAS**平台的适当入门手册。您可以在[https://apereo.github.io/cas/](https://apereo.github.io/cas/)找到此手册。'
- en: In order to make integration as simple as possible, we have included a **CAS**
    server application for this chapter that can be deployed in Eclipse or IntelliJ,
    along with the calendar application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使集成尽可能简单，我们为本章包含了一个**CAS**服务器应用程序，该应用程序可以在Eclipse或IntelliJ中部署，以及日历应用程序。
- en: For the examples in this chapter, we will assume that `https://localhost:9443/cas/`
    and the calendar application is deployed at `https://localhost:8443/`. To work,
    **CAS** requires the use of HTTPS.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的示例，我们将假设`https://localhost:9443/cas/`和日历应用程序部署在`https://localhost:8443/`。为了正常工作，**CAS**需要使用HTTPS。
- en: Important note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The examples in this chapter were written using the most recent available version
    of the `CAS` server, `7.0.1` at the time of writing, which requires Java 21\.
    So, if you are on an earlier version of the server, these instructions may be
    slightly or significantly different for your environment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例是使用当时可用的最新版本的`CAS`服务器编写的，即写作时的`7.0.1`版本，该版本需要Java 21。因此，如果您使用的是早期版本的服务器，这些说明可能对您的环境略有不同，或者可能显著不同。
- en: Let’s go ahead and configure the components required for CAS authentication.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续配置CAS认证所需的组件。
- en: Important note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start the chapter off with the source in `chapter18.00-calendar`
    and `chapter18.00-cas-server`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter18.00-calendar`和`chapter18.00-cas-server`的源开始。
- en: 'To start the CAS server, run the following command from the `chapter18.00-cas-server`
    project:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动CAS服务器，请从`chapter18.00-cas-server`项目运行以下命令：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We use the following default CAS login/password for this example: `casuser`/`Mellon`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下默认CAS登录/密码作为此示例：`casuser`/`Mellon`。
- en: In the **JBCP Calendar** application, we should be able to use the same credentials
    to log in. Note that the user has admin rights.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在**JBCP日历**应用程序中，我们应该能够使用相同的凭据登录。请注意，用户具有管理员权限。
- en: 'For the next steps, we need to do the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的步骤，我们需要执行以下操作：
- en: 'Import the CAS SSL certificate inside the `chapter18.00-cas-server/src/main/resources/etc/cas`:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`chapter18.00-cas-server/src/main/resources/etc/cas`内部导入CAS SSL证书：
- en: '[PRE2]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To check the import is done successfully, run the following command. If you
    are asked for the password the keystore password, the default one is *change it*.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查导入是否成功，请运行以下命令。如果您被要求输入keystore密码，默认密码是*更改它*。
- en: '[PRE3]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output should be similar to the following:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '[PRE4]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: $CAS_JAVA_HOME variable is the JVM used by the CAS server.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$CAS_JAVA_HOME`变量是CAS服务器使用的JVM。'
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To check the import is done successfully, you can run the following command.
    If you are asked for the password the keystore password, the default one is *change
    it*:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查导入是否成功，您可以运行以下命令。如果您被要求输入keystore密码，默认密码是*更改它*：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should be similar to following:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`$JBCP_JAVA_HOME` represents the path of *Java* used by the `cacerts` file
    is the following by default: `$$JBCP_JAVA_HOME/lib/security/cacerts`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`$JBCP_JAVA_HOME`代表`cacerts`文件使用的*Java*路径，默认如下：`$$JBCP_JAVA_HOME/lib/security/cacerts`。'
- en: '`$CAS_JAVA_HOME` represents the path of *Java* used by the `cacerts` file is
    the following by default: `$CAS_JAVA_HOME/lib/security/cacerts`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`$CAS_JAVA_HOME`代表`cacerts`文件使用的*Java*路径，默认如下：`$CAS_JAVA_HOME/lib/security/cacerts`。'
- en: This path should be adapted to your current `cacerts` file location if you are
    not relying on the default JDK `cacerts` file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不依赖于默认的JDK `cacerts`文件，则应将此路径调整为您的当前`cacerts`文件位置。
- en: To adapt the command to Windows, you need to replace the `$JBCP_JAVA_HOME` Unix/Linux
    environment variable syntax with the `%JBCP_JAVA_HOME%` Windows syntax. In this
    command, `%JBCP_JAVA_HOME%` is assumed to be a Windows environment variable pointing
    to the Java installation directory. Make sure to replace it with the actual path
    in your system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要将命令适配到Windows，您需要将`$JBCP_JAVA_HOME` Unix/Linux环境变量语法替换为`%JBCP_JAVA_HOME%` Windows语法。在此命令中，`%JBCP_JAVA_HOME%`假定是一个指向Java安装目录的Windows环境变量。请确保将其替换为您系统中的实际路径。
- en: 'If you didn’t import both the *CAS server SSL certificate* into the *JBCP Calendar
    JVM*, and *JBCP Calendar SSL Certificate* into the *CAS server JVM*, you will
    get the following error in the logs:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有将*CAS服务器SSL证书*导入到*JBCP日历JVM*，以及*JBCP日历SSL证书*导入到*CAS服务器JVM*，您将在日志中看到以下错误：
- en: '`javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException:
    unable to find valid certification path to` `requested target`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`javax.net.ssl.SSLHandshakeException: PKIX路径构建失败：sun.security.provider.certpath.SunCertPathBuilderException：无法找到到请求目标的有效证书路径`'
- en: Configuring basic CAS integration
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基本的CAS集成
- en: Since the Spring Security namespace does not support CAS configuration, there
    are quite a few more steps that we need to implement to get a basic working setup.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring Security命名空间不支持CAS配置，我们需要实施更多步骤才能获得基本的工作设置。
- en: Configuring the CAS properties
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置CAS属性
- en: 'The Spring Security setup relies on an `o.s.s.cas.ServiceProperties` bean in
    order to store common information about `ServiceProperties` object plays a role
    in coordinating the data exchange between the various **CAS** components—it is
    used as a data object to store CAS configuration settings that are shared (and
    are expected to match) by the varying participants in the **Spring CAS** stack.
    You can view the configuration included in the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security设置依赖于一个`o.s.s.cas.ServiceProperties`豆来存储关于`ServiceProperties`对象的一般信息，它在协调各种**CAS**组件之间的数据交换中发挥作用——它用作数据对象来存储由**Spring
    CAS**堆栈中不同的参与者共享（并期望匹配）的CAS配置设置。您可以在以下代码片段中查看包含的配置：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You probably noticed that we leveraged system properties to use variables named
    `${cas.base.url}` and `${service.base.url}`. Both values can be included in your
    application, and Spring will automatically replace them with the values provided
    in the `PropertySources` configuration. This is a common strategy when deploying
    a `https://localhost:9443/cas` by default for the `https://localhost:8443` for
    the calendar application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们利用系统属性来使用名为`${cas.base.url}`和`${service.base.url}`的变量。这两个值都可以包含在您的应用程序中，Spring会自动将它们替换为`PropertySources`配置中提供的值。这是一种常见的策略，当默认部署到`https://localhost:9443/cas`时，对于日历应用程序，它将部署到`https://localhost:8443`。
- en: This configuration can be overridden using a system argument when the application
    is taken to production. Alternatively, the configuration can be externalized into
    a Java properties file. Either mechanism allows us to externalize our configuration
    properly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置可以在应用程序投入生产时使用系统参数进行覆盖。或者，配置可以外部化到一个Java属性文件中。这两种机制都允许我们正确地外部化我们的配置。
- en: 'You can make the following updates to your `application.yml` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对您的`application.yml`文件进行以下更新：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding the CasAuthenticationEntryPoint object
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加CasAuthenticationEntryPoint对象
- en: 'As we briefly mentioned in the *Spring Security and CAS* section, `Spring Security`
    uses an `o.s.s.web.AuthenticationEntryPoint` interface to request credentials
    from the user. Typically, this involves redirecting the user to the login page.
    With `service` parameter that indicates where the `o.s.s.cas.web.CasAuthenticationEntryPoint`
    object, which is specifically designed for this purpose. The configuration that
    is included in the example application is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*Spring Security和CAS*部分简要提到的，`Spring Security`使用一个`o.s.s.web.AuthenticationEntryPoint`接口从用户请求凭证。通常，这涉及到将用户重定向到登录页面。通过`service`参数指示`o.s.s.cas.web.CasAuthenticationEntryPoint`对象的位置，该对象专门为此目的而设计。示例应用程序中包含的配置如下：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `CasAuthenticationEntryPoint` object uses the `ServiceProperties` class
    to specify where to send the service ticket once the user is authenticated. CAS
    allows for the selective granting of access per user, per application, based on
    configuration. We’ll examine the particulars of this URL in a moment when we configure
    the servlet filter that is expected to process it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`CasAuthenticationEntryPoint`对象使用`ServiceProperties`类指定用户认证后服务票据的发送位置。CAS允许根据配置对每个用户、每个应用程序进行选择性授权。我们将在配置预期处理该URL的servlet过滤器时，稍后检查这个URL的细节。'
- en: 'Next, we will need to update Spring Security to utilize the bean with the `casAuthentication`
    **EntryPoint** ID. Make the following update to our `SecurityConfig.java` file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新Spring Security以利用具有`casAuthentication` **入口点** ID的bean。对我们的`SecurityConfig.java`文件进行以下更新：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Enabling CAS ticket verification
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用CAS票据验证
- en: Referring to the diagram that we saw earlier (*Figure 18**.1*), we can see that
    Spring Security is responsible for identifying an unauthenticated request and
    redirecting the user to CAS via the `FilterSecurityInterceptor` class. Adding
    the `CasAuthenticationEntryPoint` object has overridden the standard redirect
    to the login page functionality and provided the expected redirection from the
    application to the CAS server. Now, we need to configure things so that, once
    authenticated to CAS, the user is properly authenticated to the application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 参考我们之前看到的图表（*图18.1*），我们可以看到Spring Security负责识别未认证的请求，并通过`FilterSecurityInterceptor`类将用户重定向到CAS。添加`CasAuthenticationEntryPoint`对象已覆盖了标准重定向到登录页面的功能，并提供了从应用程序到CAS服务器的预期重定向。现在，我们需要配置一些设置，以便一旦用户在CAS上认证成功，用户就能正确地认证到应用程序。
- en: If you remember from [*Chapter 9*](B21757_09.xhtml#_idTextAnchor295), *Opening
    up to OAuth2*, **OAuth2** uses a similar redirection approach by redirecting unauthenticated
    users to the **OAuth2** provider for authentication, and then back to the application
    with verifiable credentials. CAS differs from **OAuth2**. In the **CAS** protocol,
    upon the user’s return to the application, the application is expected to call
    back the **CAS** server to explicitly validate that the credentials provided are
    valid and accurate. Compare this with **OAuth2**, which uses the presence of a
    date-based nonce and key-based signature so that the credentials passed by the
    **OAuth2** provider can be independently verified.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得[第9章](B21757_09.xhtml#_idTextAnchor295)中的内容，即**OAuth2的开放**，**OAuth2**使用类似的重定向方法，通过将未经认证的用户重定向到**OAuth2**提供者进行认证，然后带着可验证的凭证返回到应用程序。与**OAuth2**不同，**CAS**协议在用户返回应用程序时，应用程序预期会回调**CAS**服务器，明确验证提供的凭证是否有效和准确。与使用基于日期的nonce和基于密钥的签名来独立验证**OAuth2**提供者传递的凭证相比，这是一个区别。
- en: 'The benefit of the `CasConfig.java` file, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`CasConfig.java`文件的好处如下：'
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we need to update Spring Security to utilize the bean with the `CasAuthenticationFilter`
    bean. Make the following update to our `SecurityConfig.java` file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新Spring Security以利用带有`CasAuthenticationFilter` Bean的Bean。请更新我们的`SecurityConfig.java`文件如下：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last thing to do is to remove the existing `formLogin` `Spring Security`
    definition in the `SecurityFilterChain` Bean, as we will rely on **CAS** login
    forms for user authentication.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是删除`SecurityFilterChain` Bean中现有的`formLogin` `Spring Security`定义，因为我们将会依赖**CAS**登录表单进行用户认证。
- en: Important note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should look like that in `chapter18.01-calendar`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该看起来像`chapter18.01-calendar`中的那样。
- en: At this point, we should be able to start both the `https://localhost:8443/`
    and select `casuser` and the password `Mellon`. Upon successful authentication,
    you will be redirected back to the **JBCP Calendar** application. Excellent job!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该能够启动`https://localhost:8443/`，并选择`casuser`用户和密码`Mellon`。认证成功后，您将被重定向回**JBCP日历**应用程序。做得好！
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are experiencing issues, it is most likely due to **an improper SSL configuration**.
    Ensure that you have import the CAS SSL certificate inside the JRE keystore of
    your **JBCP** **Calendar** application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到问题，最可能的原因是**不正确的SSL配置**。请确保您已将CAS SSL证书导入到您的**JBCP日历**应用程序的JRE密钥库中。
- en: Now that we have covered the basics of CAS configuration in the introduction,
    we will proceed to delve deeper into **Single Logout**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了CAS配置的基础知识，我们将进一步深入探讨**单点注销**。
- en: Single Logout
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单点注销
- en: You may notice that if you log out of the application, you get a logout confirmation
    page. However, if you click on a protected page, such as the **My Events** page,
    you are still authenticated. The problem is that the logout is only occurs locally.
    So, when you request another protected resource in the **JBCP Calendar** application,
    a login is requested from the **CAS** server. Since the user is still logged in
    to the **CAS** server, it immediately returns a service ticket and logs the user
    back into the **JBCP** **Calendar** application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，如果您注销应用程序，您会看到一个注销确认页面。然而，如果您点击一个受保护的页面，例如**我的事件**页面，您仍然处于认证状态。问题是注销只发生在本地。因此，当您在**JBCP日历**应用程序中请求另一个受保护的资源时，会从**CAS**服务器请求登录。由于用户仍然登录到**CAS**服务器，它立即返回一个服务票据并将用户重新登录到**JBCP日历**应用程序。
- en: This also means that if the user had signed in to other applications using the
    **CAS** server, they would still be authenticated to those applications, since
    our calendar application does not know anything about the other applications.
    Fortunately, **CAS** and Spring Security offer a solution to this problem. Just
    as we can request a login from the **CAS** server, we can also request a logout.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，如果用户使用**CAS**服务器登录了其他应用程序，他们仍然会认证到那些应用程序，因为我们的日历应用程序对其他应用程序一无所知。幸运的是，**CAS**和Spring
    Security提供了解决这个问题的方案。正如我们可以从**CAS**服务器请求登录一样，我们也可以请求注销。
- en: 'You can see a high-level diagram of how logging out works within **CAS**, as
    follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter18.01-calendar`中看到如何注销**CAS**的高级示意图：
- en: '![Figure 18.2 – CAS Single Logout](img/B21757_18_2.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图18.2 – CAS单点注销](img/B21757_18_2.jpg)'
- en: Figure 18.2 – CAS Single Logout
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2 – CAS单点注销
- en: 'The following steps explain how the **Single Logout** functionality works:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤解释了**单点注销**功能是如何工作的：
- en: The user requests to log out of the web application.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户请求从网络应用程序登出。
- en: The web application then requests to log out of CAS by sending a redirect through
    the browser to the CAS server.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络应用程序随后通过浏览器发送重定向请求到CAS服务器，请求从CAS登出。
- en: The CAS server recognizes the user and then sends a logout request to each CAS
    service that was authenticated. Note that these logout requests do not occur through
    the browser.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAS服务器识别用户，然后向每个已认证的CAS服务发送登出请求。请注意，这些登出请求不是通过浏览器发生的。
- en: The CAS server indicates which user should log out by providing the original
    service ticket that was used to log the user in. The application is then responsible
    for ensuring that the user is logged out.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAS服务器通过提供用于登录用户的原始服务票据来指示哪个用户应该登出。然后应用程序负责确保用户已登出。
- en: The CAS server displays the logout success page to the user.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CAS服务器向用户显示登出成功页面。
- en: Configuring Single Logout
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置单点登出
- en: 'The configuration for a **Single Logout** is relatively simple:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**单点登出**的配置相对简单：'
- en: 'First, make the following updates to your `application.yml` file, adding the
    **CAS** logout URL:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新你的 `application.yml` 文件，添加**CAS**登出URL：
- en: '[PRE14]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first step is to specify a `logout-success-url` attribute to be the logout
    URL of the `SecurityConfig.java` file. This means that after we log out locally,
    we will automatically redirect the user to the **CAS** server’s logout page:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是指定一个`logout-success-url`属性，使其成为`SecurityConfig.java`文件的登出URL。这意味着在我们本地登出后，我们将自动将用户重定向到**CAS**服务器的登出页面：
- en: '[PRE15]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since we only have one application, this is all we need to make it appear as
    though a single logout is occurring. This is because we log out of our calendar
    application before redirecting to the `LogoutFilter` to `CasConfig.java`, as follows:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们只有一个应用程序，这就足够让它看起来像发生了单点登出。这是因为我们在重定向到`CasConfig.java`的`LogoutFilter`之前登出了我们的日历应用程序，如下所示：
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If there were multiple applications and the user logged out of another application,
    the `SingleSignoutFilter` object. Then we need to make Spring Security aware of
    the `singleLogoutFilter` object in our `SecurityConfig.java`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有多个应用程序，并且用户从另一个应用程序登出，则需要创建一个`SingleSignoutFilter`对象。然后我们需要让Spring Security意识到我们的`SecurityConfig.java`中的`singleLogoutFilter`对象。
- en: 'Place the **Single Logout** filter before the regular logout to ensure that
    it receives the logout events, as follows:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将**单点登出**过滤器放在常规登出之前，以确保它接收登出事件，如下所示：
- en: '[PRE17]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Go ahead and start up the application and try logging out now. You will observe
    that you are logged out.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续启动应用程序并尝试现在登出。你会观察到你已经登出。
- en: Now, try logging back in and visiting the `https://localhost:9443/cas/logout`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试重新登录并访问`https://localhost:9443/cas/logout`。
- en: Now, try to visit the **JBCP Calendar** application. You will observe that you
    are unable to access the application without authenticating again. This demonstrates
    that the **Single Logout** functionality is operational.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试访问**JBCP日历**应用程序。你会注意到，除非再次进行身份验证，否则你无法访问该应用程序。这表明**单点登出**功能是可操作的。
- en: Important note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should look like that in `chapter18.02-calendar`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter18.02-calendar`中的那样。
- en: In this section, we covered the **Single Logout** implementation with **CAS**.
    Next, we will move on to discuss clustered environments.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了使用**CAS**的**单点登出**实现。接下来，我们将讨论集群环境。
- en: Clustered environments
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群环境
- en: 'One of the things that we failed to mention in our initial diagram of `HttpSession`
    as an in-memory map. This means that **Single Logout** will not work properly
    within a clustered environment:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最初将 `HttpSession` 作为内存映射的图示中，我们未能提及的一件事。这意味着在集群环境中**单点登出**将无法正常工作：
- en: '![Figure 18.3 – CAS authentication in a clustered environment](img/B21757_18_3.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图18.3 – 集群环境中的CAS身份验证](img/B21757_18_3.jpg)'
- en: Figure 18.3 – CAS authentication in a clustered environment
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3 – 集群环境中的CAS身份验证
- en: 'Consider the following situation in the context of the preceding diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况，在先前的图示背景下：
- en: The user logs in to **Cluster** **Member A**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户登录到**集群成员A**。
- en: '**Cluster Member A** validates the service ticket.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**集群成员A**验证服务票据。'
- en: It then stores in memory, the mapping of the service ticket to the user’s session.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它在内存中存储服务票据到用户会话的映射。
- en: The user requests to log out from the **CAS** server.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户请求从**CAS**服务器登出。
- en: The **CAS** server sends a logout request to the **CAS** service, but **Cluster
    Member B** receives the logout request. It looks in its memory but does not find
    a session for **Service Ticket A**, because it only exists in **Cluster Member
    A**. This means the user will not be logged out successfully.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAS**服务器向**CAS**服务发送注销请求，但**集群成员B**接收到了注销请求。它在内存中查找，但没有找到**Service Ticket
    A**的会话，因为它只存在于**集群成员A**中。这意味着用户将无法成功注销。'
- en: Proxy ticket authentication for stateless services
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态服务的代理票据认证
- en: 'Centralizing our authentication using **CAS** seems to work rather well for
    web applications, but what if we want to call a web service using **CAS**? In
    order to support this, CAS has a notion of **proxy tickets** (**PT**). The following
    is a diagram of how it works:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**CAS**集中我们的认证对于Web应用来说似乎工作得相当好，但如果我们想使用**CAS**调用Web服务怎么办？为了支持这一点，CAS有一个**代理票据**（**PT**）的概念。以下是如何工作的示意图：
- en: '![Figure 18.4 – CAS proxy ticket authentication](img/B21757_18_4.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图18.4 – CAS代理票据认证](img/B21757_18_4.jpg)'
- en: Figure 18.4 – CAS proxy ticket authentication
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4 – CAS代理票据认证
- en: 'The flow is the same as standard **CAS** authentication until the following
    things take place:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 流程与标准**CAS**认证相同，直到以下事情发生：
- en: The **Service Ticket** is validated when an additional parameter is included
    called the proxy ticket callback URL (**PGT URL**).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当包含一个名为代理票据回调URL（**PGT URL**）的附加参数时，**Service Ticket**将被验证。
- en: The **CAS** server calls the **PGT URL** over **HTTPS** to validate that the
    **PGT URL** is what it claims to be. Like most of the processes in a CAS, this
    is done by performing an SSL handshake to the appropriate URL.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CAS**服务器通过**HTTPS**调用**PGT URL**以验证**PGT URL**确实是它所声称的。像CAS中的大多数过程一样，这是通过执行适当的URL的SSL握手来完成的。'
- en: The **CAS** server submits the **Proxy Granting Ticket** (**PGT**) and the **Proxy
    Granting Ticket I Owe You** (**PGTIOU**) to the **PGT URL** over **HTTPS** to
    ensure that the tickets are submitted to the source they claim to be.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CAS**服务器通过**HTTPS**将**Proxy Granting Ticket**（**PGT**）和**Proxy Granting Ticket
    I Owe You**（**PGTIOU**）提交到**PGT URL**，以确保票据被提交到它们声称的来源。'
- en: The **PGT URL** receives the two tickets and must store an association of the
    **PGTIOU** to the **PGT**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PGT URL**接收两个票据，并必须存储**PGTIOU**到**PGT**的关联。'
- en: The **CAS** server finally returns a response to the request in *step 1* that
    includes the username and the **PGTIOU**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CAS**服务器最终返回一个包含用户名和**PGTIOU**的响应到*步骤1*。'
- en: The **CAS** service can look up the **PGT** using the **PGTIOU**.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CAS**服务可以使用**PGTIOU**查找**PGT**。'
- en: Configuring proxy ticket authentication
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置代理票据认证
- en: 'Now that we know how **PT** authentication works, we will update our current
    configuration to obtain a **PGT** by performing the following steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了**PT**认证的工作原理，我们将通过以下步骤更新我们的当前配置以获取一个**PGT**：
- en: 'The first step is to add a reference to a `ProxyGrantingTicketStorage` implementation.
    Go ahead and add the following code to our `CasConfig.java` file:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是添加对`ProxyGrantingTicketStorage`实现的引用。请将以下代码添加到我们的`CasConfig.java`文件中：
- en: '[PRE18]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `ProxyGrantingTicketStorageImpl` implementation is an in-memory mapping
    of the **PGTIOU** to a **PGT**. Just as with logging out, this means we would
    have problems in a clustered environment using this implementation. Refer to the
    JA-SIG documentation to determine how to set this up in a clustered environment:
    [https://apereo.github.io/cas/7.0.x/high_availability/High-Availability-Guide.xhtml](https://apereo.github.io/cas/7.0.x/high_availability/High-Availability-Guide.xhtml).'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProxyGrantingTicketStorageImpl`实现是将**PGTIOU**映射到**PGT**的内存映射。就像注销一样，这意味着我们会在集群环境中使用此实现时遇到问题。请参考JA-SIG文档以确定如何在集群环境中设置它：[https://apereo.github.io/cas/7.0.x/high_availability/High-Availability-Guide.xhtml](https://apereo.github.io/cas/7.0.x/high_availability/High-Availability-Guide.xhtml)。'
- en: We also need to periodically clean `ProxyGrantingTicketStorage` by invoking
    its `cleanUp()` method. As you can see, Spring’s task abstraction makes this very
    simple. You may consider tweaking the configuration to clear the tickets in a
    separate thread pool that makes sense for your environment. For more information,
    refer to the *Task Execution and Scheduling* section of the Spring Framework Reference
    documentation at [https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml](https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要定期通过调用其`cleanUp()`方法来清理`ProxyGrantingTicketStorage`。如您所见，Spring的任务抽象使这变得非常简单。您可以考虑调整配置，以便在适合您环境的单独线程池中清除票据。有关更多信息，请参阅Spring框架参考文档的*任务执行和调度*部分，网址为[https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml](https://docs.spring.io/spring-framework/reference/integration/scheduling.xhtml)。
- en: 'Now we need to use `ProxyGrantingTicketStorage`, which we have just created.
    We just need to update the `ticketValidator` method to refer to our storage and
    to know the `CasConfig.java`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要使用我们刚刚创建的`ProxyGrantingTicketStorage`。我们只需要更新`ticketValidator`方法，使其引用我们的存储，并了解`CasConfig.java`：
- en: '[PRE19]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we need to update the `application.yml` file by adding the proxy callback
    URL:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要通过添加代理回调URL来更新`application.yml`文件：
- en: '[PRE20]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last update we need to make is to our `CasAuthenticationFilter` object,
    to store the `ProxyGrantingTicketStorage` implementation when the `proxyReceptorUrl`
    attribute matches the `proxyCallbackUrl` attribute of the `Cas20ProxyTicketValidator`
    object to ensure that the `CasConfig.java`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一个更新是对我们的`CasAuthenticationFilter`对象，当`proxyReceptorUrl`属性与`Cas20ProxyTicketValidator`对象的`proxyCallbackUrl`属性匹配时，存储`ProxyGrantingTicketStorage`实现，以确保`CasConfig.java`：
- en: '[PRE21]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have a **PGT**, what do we do with it? A service ticket is a single-use
    token. However, a **PGT** can be used to produce a **PT**. Let’s see how we can
    create a **PT** using a **PGT**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了**PGT**，我们该如何使用它？服务票据是一个一次性令牌。然而，**PGT**可以用来生成**PT**。让我们看看我们如何使用**PGT**来创建**PT**。
- en: Important note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the `application.yml` configuration file, we can observe that the `proxyCallBackUrl`
    attribute matches the absolute path of our context-relative `proxyReceptorUrl`
    attribute path. Since we are deploying our base application to `${service.base.url}`,
    the full path of our `proxyReceptor` URL will be `${service.base.url}/pgtUrl`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`application.yml`配置文件中，我们可以观察到`proxyCallBackUrl`属性与我们的上下文相关`proxyReceptorUrl`属性路径的绝对路径相匹配。由于我们将基础应用程序部署到`${service.base.url}`，我们的`proxyReceptor`
    URL的完整路径将是`${service.base.url}/pgtUrl`。
- en: Following this examination of the configuration on a **CAS** Server clustered
    environments, we will next delve into the detailed utilization of CAS proxy tickets.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在对**CAS**服务器集群环境中的配置进行此检查之后，我们将深入了解CAS代理票据的详细使用。
- en: Using proxy tickets
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理票据
- en: 'We can now use our `EchoController` class that we have included in the code
    for this chapter. You can see the relevant portions of it in the following code
    snippet. For additional details, refer to the example source code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们包含在本章代码中的`EchoController`类。您可以在下面的代码片段中看到它的相关部分。有关更多详细信息，请参阅示例源代码：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This controller is a contrived example that will obtain a `EchoController` object
    is actually making a RESTful call to the `MessagesController` object that is in
    the same application. This means that the calendar application makes a RESTful
    call to itself.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器是一个虚构的例子，它将获取一个`EchoController`对象，实际上是在对同一应用程序中的`MessagesController`对象进行RESTful调用。这意味着日历应用程序正在对自己进行RESTful调用。
- en: Go ahead and visit `https://localhost:8443/echo` to see it in action. The page
    looks a lot like the **CAS** login page (minus the CSS). This is because the controller
    attempts to echo our **My Events** page, and our application does not yet know
    how to authenticate a **PT**. This means it is redirected to the **CAS** login
    page. Let’s see how we can authenticate proxy tickets.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`https://localhost:8443/echo`查看其效果。页面看起来非常像**CAS**登录页面（除了CSS）。这是因为控制器试图回显我们的**我的事件**页面，而我们的应用程序还不知道如何验证**PT**。这意味着它被重定向到**CAS**登录页面。让我们看看我们如何验证代理票据。
- en: Important note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should look like that in `chapter18.03-calendar`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该看起来像`chapter18.03-calendar`中的那样。
- en: Authenticating proxy tickets
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证代理票据
- en: 'Let’s look at the following steps to learn about authenticating proxy tickets:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤来了解如何验证代理票据：
- en: 'We first need to tell the `ServiceProperties` object that we want to authenticate
    all of the tickets and not just those submitted to the `filterProcessesUrl` attribute.
    Make the following updates to `CasConfig.java`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要告诉 `ServiceProperties` 对象，我们想要验证所有票据，而不仅仅是提交给 `filterProcessesUrl` 属性的票据。请对
    `CasConfig.java` 进行以下更新：
- en: '[PRE23]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then need to update our `CasAuthenticationFilter` object for it to know
    that we want to authenticate all artifacts (that is, tickets) instead of only
    listening to a specific URL. We also need to use an `AuthenticationDetailsSource`
    interface that can dynamically provide the CAS service URL when validating proxy
    tickets on arbitrary URLs. This is important because when a CAS service asks whether
    a ticket is valid or not, it must also provide the CAS service URL that was used
    to create the ticket. Since proxy tickets can occur for any URL, we must be able
    to dynamically discover this URL. This is done by leveraging the `ServiceAuthenticationDetailsSource`
    object, which will provide the current URL from the HTTP request:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要更新我们的 `CasAuthenticationFilter` 对象，使其知道我们想要验证所有工件（即票据），而不仅仅是监听特定 URL。我们还需要使用一个
    `AuthenticationDetailsSource` 接口，该接口可以在验证任意 URL 上的代理票据时动态提供 CAS 服务 URL。这很重要，因为当
    CAS 服务询问票据是否有效时，它还必须提供用于创建票据的 CAS 服务 URL。由于代理票据可能出现在任何 URL 上，我们必须能够动态发现此 URL。这是通过利用
    `ServiceAuthenticationDetailsSource` 对象来完成的，该对象将提供 HTTP 请求中的当前 URL：
- en: '[PRE24]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will also need to ensure that we are using the `Cas30ProxyTicketValidator`
    object and not the `Cas30ServiceTicketValidator` implementation, and indicate
    which proxy tickets we will accept. We will configure our `Cas30ProxyTicketValidator`
    to accept a proxy ticket from any CAS service. In a production environment, you
    will want to consider restricting yourself to only those CAS services that are
    trusted:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要确保我们正在使用 `Cas30ProxyTicketValidator` 对象，而不是 `Cas30ServiceTicketValidator`
    实现，并指出我们将接受哪些代理票据。我们将配置我们的 `Cas30ProxyTicketValidator` 以接受来自任何 CAS 服务的代理票据。在生产环境中，您可能希望仅限于信任的
    CAS 服务：
- en: '[PRE25]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lastly, we want to provide a cache for our `CasAuthenticationProvider` object
    so that we do not need to hit the CAS service for every call made to our service.
    To do this, we need to configure a `StatelessTicketCache` as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望为我们的 `CasAuthenticationProvider` 对象提供一个缓存，这样我们就不需要为每次调用我们的服务而击中 CAS 服务。为此，我们需要配置一个
    `StatelessTicketCache`，如下所示：
- en: '[PRE26]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Important note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don’t forget the `@EnableCaching` in the `CasConfig.java`, so that caching can
    automatically enabled by Spring.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `CasConfig.java` 中添加 `@EnableCaching`，以便 Spring 可以自动启用缓存。
- en: 'As you might have suspected, the Spring cache can rely on external implementations
    including `EhCache`. Go ahead and start the application back up and visit `https://localhost:8443/echo`
    again. This time, you should see a response to calling our **My** **Events** page:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所怀疑的，Spring 缓存可以依赖于外部实现，包括 `EhCache`。请继续启动应用程序并再次访问 `https://localhost:8443/echo`。这次，您应该看到对调用我们的
    **我的** **事件** 页面的响应：
- en: '![Figure 18.5 – Authenticating proxy tickets response](img/B21757_18_5.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.5 – 验证代理票据响应](img/B21757_18_5.jpg)'
- en: Figure 18.5 – Authenticating proxy tickets response
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.5 – 验证代理票据响应
- en: Important note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should look like that in `chapter18.04-calendar`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该看起来像 `chapter18.04-calendar` 中的那样。
- en: After using proxy tickets, we’ll next explore the process of customizing the
    **CAS** server.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用代理票据之后，我们将接下来探讨定制 **CAS** 服务器的过程。
- en: Customizing the CAS server
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制 CAS 服务器
- en: 'All the changes in this section will be made to the **CAS** server and not
    the calendar application. This section is only meant to be an introduction to
    configuring the **CAS** server, as a detailed setup is certainly beyond the scope
    of this book. Just as with the changes made to the calendar application, we encourage
    you to follow along with the changes in this chapter. For more information, you
    can refer to the **CAS Aperero** documentation: https://apereo.github.io/cas.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的所有更改都将应用于 **CAS** 服务器，而不是日历应用程序。本节仅旨在介绍配置 **CAS** 服务器的过程，因为详细的设置显然超出了本书的范围。就像对日历应用程序所做的更改一样，我们鼓励您跟随本章中的更改。有关更多信息，您可以参考
    **CAS Aperero** 文档：https://apereo.github.io/cas。
- en: CAS WAR overlay
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CAS WAR 透明覆盖
- en: The preferred way to customize `cas-server-webapp`, as a dependency, and then
    provide additional files that will be merged with the existing **WAR overlay**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为依赖项，首选的定制 `cas-server-webapp` 的方式，然后提供将合并到现有 **WAR 透明覆盖** 中的额外文件。
- en: How does the CAS internal authentication work?
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CAS 内部认证是如何工作的？
- en: 'Before we jump into CAS configuration, we’ll briefly illustrate the standard
    behavior of CAS authentication processing. The following diagram should help you
    follow the configuration steps required to allow CAS to talk to our embedded LDAP
    server:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到 CAS 配置之前，我们将简要说明 CAS 认证处理的标准行为。以下图表应有助于您跟随允许 CAS 与我们的嵌入式 LDAP 服务器通信所需的配置步骤：
- en: '![Figure 18.6 – CAS internal authentication flow](img/B21757_18_6.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.6 – CAS 内部认证流程](img/B21757_18_6.jpg)'
- en: Figure 18.6 – CAS internal authentication flow
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.6 – CAS 内部认证流程
- en: While the preceding diagram describes the internal flow of authentication within
    the **CAS** server itself, it is likely that if you are implementing an integration
    between Spring Security and **CAS**, you will need to adjust the configuration
    of the **CAS** server as well. It’s important, therefore, that you understand
    how **CAS** authentication works at a high level.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的图描述了 **CAS** 服务器内部的认证流程，但如果你正在实现 Spring Security 和 **CAS** 之间的集成，你可能需要调整
    **CAS** 服务器的配置。因此，了解 **CAS** 认证在高级别上是如何工作的是非常重要的。
- en: The `org.apereo.cas.authentication.AuthenticationManager` interface (not to
    be confused with the Spring Security interface of the same name) is responsible
    for authenticating the user based on the provided credentials. In Spring Security,
    the actual processing of the credentials is delegated to one (or more) processing
    class implementing the `org.apereo.cas.authentication.AuthenticationHandler` interface.
    We recognize that the analogous interface in `Spring Security` would be `AuthenticationProvider`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.apereo.cas.authentication.AuthenticationManager` 接口（不要与同名的 Spring Security
    接口混淆）负责根据提供的凭据对用户进行认证。在 Spring Security 中，凭据的实际处理委托给一个（或多个）实现 `org.apereo.cas.authentication.AuthenticationHandler`
    接口的处理类。我们认识到 `Spring Security` 中的类似接口将是 `AuthenticationProvider`。'
- en: While not a full review of the behind-the-scenes functionality of the **CAS**
    server, this should help you understand the configuration steps in the next several
    exercises. We encourage you to read the source code for **CAS** and consult the
    web-based documentation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是对 CAS 服务器背后功能的全面审查，但这应该有助于您理解接下来几个练习中的配置步骤。我们鼓励您阅读 **CAS** 的源代码并参考基于网络的文档。
- en: Configuring CAS to connect to our embedded LDAP server
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 CAS 连接到我们的嵌入式 LDAP 服务器
- en: '**CAS** verifies a username/password by authenticating against an LDAP directory,
    such as Active Directory or OpenLDAP. There are various directory architectures,
    and we offer configuration options for four common scenarios.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAS** 通过对 Active Directory 或 OpenLDAP 等LDAP 目录进行认证来验证用户名/密码。存在各种目录架构，我们为四种常见场景提供了配置选项。'
- en: It’s important to note that **CAS** automatically generates the necessary components
    internally based on the specified settings. If you want to authenticate against
    multiple LDAP servers, you can increment the index and specify the settings for
    the next LDAP server.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，**CAS** 会根据指定的设置自动内部生成必要的组件。如果您想对多个 LDAP 服务器进行认证，您可以增加索引并指定下一个 LDAP
    服务器设置。
- en: Additionally, please be aware that attributes obtained during **LDAP** authentication
    are combined with attributes from other attribute repository sources, if applicable.
    Attributes obtained directly through **LDAP** authentication take precedence over
    all other attributes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在 **LDAP** 认证期间获得的属性，如果适用，将与来自其他属性存储源的属性结合。直接通过 **LDAP** 认证获得的属性优先于所有其他属性。
- en: You can find the available settings and properties in the CAS documentation
    ([https://apereo.github.io/cas/](https://apereo.github.io/cas/)).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 CAS 文档中找到可用的设置和属性（[https://apereo.github.io/cas/](https://apereo.github.io/cas/))。
- en: 'Let’s take a look at the following steps to configure an embedded LDAP server
    with **CAS**:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤来配置带有 **CAS** 的嵌入式 LDAP 服务器：
- en: 'First, we update the `build.gradle` dependencies of the `chapter18.00-cas-server`
    project. We enable the CAS LDAP support and add the `spring-security` built-in
    support for the embedded LDAP server:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们更新 `chapter18.00-cas-server` 项目的 `build.gradle` 依赖项。我们启用 CAS LDAP 支持，并添加嵌入式
    LDAP 服务器的 `spring-security` 内置支持：
- en: '[PRE27]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we need to add the following sections to our `application.yml` file with
    the connection parameters for the embedded LDAP server:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要在我们的 `application.yml` 文件中添加以下部分，包含嵌入式 LDAP 服务器的连接参数：
- en: '[PRE28]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For this exercise, we will be using an LDIF file created for this book, intended
    to capture many of the common configuration scenarios with LDAP and Spring Security
    (just as we did in [*Chapter 6*](B21757_06.xhtml#_idTextAnchor180), *LDAP Directory
    Services*). Copy the provided LDIF file to the following project location: `src/main/resources/ldif/calendar.ldif`.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将使用为本书创建的 LDIF 文件，旨在捕获许多与 LDAP 和 Spring Security 的常见配置场景（就像我们在 [*第
    6 章*](B21757_06.xhtml#_idTextAnchor180)，*LDAP 目录服务*）中所做的那样）。将提供的 LDIF 文件复制到以下项目位置：`src/main/resources/ldif/calendar.ldif`。
- en: 'Finally, we need to configure the `CasOverlayOverrideConfiguration.java` as
    follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要按照以下方式配置 `CasOverlayOverrideConfiguration.java`：
- en: '[PRE29]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Important note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should look like that in `chapter18.05-cas-server` and `chapter18.05-calendar`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像 `chapter18.05-cas-server` 和 `chapter18.05-calendar` 中的那样。
- en: So, now we’ve configured basic `admin1@example.com/admin` or `user1@example.com/user1`.
    Go ahead and try it to check whether it works. If it does not work, try checking
    the logs and comparing your configuration with the example configuration.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经配置了基本的 `admin1@example.com/admin` 或 `user1@example.com/user1`。尝试运行它以检查是否正常工作。如果不起作用，请检查日志并比较您的配置与示例配置。
- en: Following the customization of the `UserDetails` object from a **CAS** assertion.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在从 **CAS** 断言对 `UserDetails` 对象进行自定义之后。
- en: Getting the UserDetails object from a CAS assertion
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 CAS 断言中获取 UserDetails 对象
- en: Up until this point, we have been authenticating with `InMemoryUserDetailsManager`
    object. However, we can create the `UserDetails` object from the **CAS** assertion
    just as we did with **OAuth2**. The first step is to configure the **CAS** server
    to return the additional attributes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用 `InMemoryUserDetailsManager` 对象进行身份验证。然而，我们可以像使用 **OAuth2** 一样从
    **CAS** 断言中创建 `UserDetails` 对象。第一步是配置 **CAS** 服务器以返回额外的属性。
- en: Returning LDAP attributes in the CAS response
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 CAS 响应中返回 LDAP 属性
- en: We know that **CAS** can return the username in the **CAS** response, but it
    can also return arbitrary attributes in the **CAS** response. Let’s see how we
    can update the CAS server to return additional attributes. Again, all the changes
    in this section are in the *CAS server and not in the* *calendar application*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 **CAS** 可以在 **CAS** 响应中返回用户名，但它也可以在 **CAS** 响应中返回任意属性。让我们看看如何更新 CAS 服务器以返回额外的属性。同样，本节的所有更改都在
    *CAS 服务器中，而不是在* *日历应用程序中*。
- en: Mapping LDAP attributes to CAS attributes
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 LDAP 属性映射到 CAS 属性
- en: The first step requires us to map `GrantedAuthority`).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步需要我们将 `GrantedAuthority` 映射。
- en: 'We’ll add another bit of configuration to the CAS `application.yml` file. This
    new bit of configuration is required to instruct `Principal` object to the `principalAttributeList`,
    which will ultimately be serialized as part of ticket validation. The configuration
    should be declared as follows in the `chapter18.06-cas-server` project:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 CAS 的 `application.yml` 文件中添加更多的配置。这个新的配置项是为了指导 `Principal` 对象到 `principalAttributeList`，这将最终作为票据验证的一部分进行序列化。该配置应在
    `chapter18.06-cas-server` 项目中如下声明：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The functionality behind the scenes here is confusing—essentially, the purpose
    of this class is to map `org.apereo.cas.authentication.principal.Principal` back
    to the LDAP directory. The provided `baseDN` Java bean property is searched using
    the LDAP query (`uid=user1@example.com`), and attributes are read from the matching
    entry. The attributes are mapped back to `org.apereo.cas.authentication.principal.Principal`
    using the key/value pairs in the `principalAttributeList` property. We recognize
    that LDAP’s `cn` and `sn` attributes are mapped to meaningful names, and the `description`
    attribute is mapped to the role that will be used for determining the authorization
    of our user.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 背后的功能有些令人困惑——本质上，这个类的目的是将 `org.apereo.cas.authentication.principal.Principal`
    映射回 LDAP 目录。使用 LDAP 查询（`uid=user1@example.com`）搜索提供的 `baseDN` Java 实体属性，并从匹配条目中读取属性。这些属性使用
    `principalAttributeList` 属性中的键/值对映射回 `org.apereo.cas.authentication.principal.Principal`。我们认识到
    LDAP 的 `cn` 和 `sn` 属性被映射到有意义的名称，而 `description` 属性被映射到用于确定我们用户授权的角色。
- en: Last, we would love to set up the same type of query in `Principal` to a full
    LDAP-distinguished name, and then use that `uniqueMember` attribute of a `groupOfUniqueNames`
    entry. Unfortunately, the CAS LDAP code doesn’t have this flexibility yet, leading
    to the conclusion that more advanced **LDAP** mapping will require extensions
    to base classes in **CAS**.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望将相同类型的查询设置在`Principal`上，到一个完整的LDAP唯一名称，然后使用`groupOfUniqueNames`条目的`uniqueMember`属性。不幸的是，CAS
    LDAP代码还没有这种灵活性，这导致我们得出结论，更高级的**LDAP**映射将需要在**CAS**的基类中进行扩展。
- en: Acquiring a UserDetails from CAS
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从CAS获取UserDetails
- en: When we first set up `UserDetailsByNameServiceWrapper`, which simply translated
    the username presented to `UserDetails` object from `UserDetailsService`, which
    we had referenced. Now that `LdapUserDetailsService` as we discussed at the tail
    end of [*Chapter 6*](B21757_06.xhtml#_idTextAnchor180), *LDAP Directory Services*,
    and things will work just fine.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初设置`UserDetailsByNameServiceWrapper`时，它只是将呈现给`UserDetails`对象的用户名转换为`UserDetailsService`中引用的对象。现在，正如我们在[*第6章*](B21757_06.xhtml#_idTextAnchor180)的末尾讨论的，*LDAP目录服务*，一切都会顺利。
- en: Note that in the next section, we will switch back to modifying the *calendar
    application and not the* *CAS server*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在下一节中，我们将切换回修改*日历应用程序而不是* *CAS服务器*。
- en: The GrantedAuthorityFromAssertionAttributesUser object
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GrantedAuthorityFromAssertionAttributesUser对象
- en: Now that we have modified the `UserDetails` from the `AuthenticationUserDetailsService`
    implementation to the
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经修改了`AuthenticationUserDetailsService`实现中的`UserDetails`，将其从`AuthenticationUserDetailsService`实现修改为
- en: '`o.s.s.cas.userdetails.GrantedAuthorityFromAssertionAttributesUser` **DetailsService**
    object, whose job it is to read the `GrantedAuthority` object for the user. Let’s
    assume that there is an attribute-entitled role that will be returned with the
    assertion. We simply configure a new `authenticationUserDetailsService` bean (be
    sure to replace the previously defined `authenticationUserDetailsService` bean)
    in the `CaseConfig.java` file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`o.s.s.cas.userdetails.GrantedAuthorityFromAssertionAttributesUser` **DetailsService**对象，其任务是读取用户的`GrantedAuthority`对象。假设有一个属性为role的属性将随断言返回。我们只需在`CaseConfig.java`文件中配置一个新的`authenticationUserDetailsService`
    bean（确保替换之前定义的`authenticationUserDetailsService` bean）：'
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Important note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should look like that in `chapter18.06-cas-server` and `chapter18.06-calendar`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该看起来像`chapter18.06-cas-server`和`chapter18.06-calendar`中的那样。
- en: How is attribute retrieval useful?
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性检索有什么用？
- en: Remember that **CAS** provides a layer of abstraction for our application, removing
    the ability for our application to directly access the user repository, and instead
    forcing all such access to be performed through **CAS** as a proxy.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，**CAS**为我们提供了一个抽象层，消除了我们的应用程序直接访问用户存储库的能力，并强制所有此类访问都通过**CAS**作为代理进行。
- en: This is extremely powerful! It means that our application no longer cares what
    kind of repository the users are stored in, nor does it have to worry about the
    details of how to access them. This confirms that authentication with **CAS**
    is sufficient to prove that a user should be able to access our application. For
    system administrators, this means that should an LDAP server be renamed, moved,
    or otherwise adjusted, they only need to reconfigure it in a single location—**CAS**.
    Centralizing access through **CAS** allows for a high level of flexibility and
    adaptability in the overall security architecture of the organization.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常强大！这意味着我们的应用程序不再关心用户存储在哪种类型的存储库中，也不必担心如何访问它们的细节。这证实了使用**CAS**进行身份验证足以证明用户应该能够访问我们的应用程序。对于系统管理员来说，这意味着如果LDAP服务器被重命名、移动或进行其他调整，他们只需要在单个位置重新配置它——**CAS**。通过**CAS**集中访问允许组织整体安全架构具有高度的灵活性和适应性。
- en: Now all applications authenticated through **CAS** have the same view of a user
    and can consistently display information across any **CAS**-enabled environment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有通过**CAS**进行身份验证的应用程序对用户都有相同的视图，并且可以在任何**CAS**启用环境中一致地显示信息。
- en: Be aware that, once authenticated, Spring Security does not require the `Authentication`
    object may become stale over time, and possibly out of sync with the source **CAS**
    server. Take care to set session timeouts appropriately to avoid this potential
    issue!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦经过身份验证，Spring Security不需要`Authentication`对象可能会随着时间的推移而变得过时，并且可能与源**CAS**服务器不同步。请妥善设置会话超时，以避免此潜在问题！
- en: Additional CAS capabilities
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加CAS功能
- en: '**CAS** offers additional advanced configuration capabilities outside of those
    that are exposed through the Spring Security **CAS** wrappers. Some of these include
    the following capabilities:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAS**提供了超出通过Spring Security **CAS**包装器公开的配置功能。以下是一些这些功能：'
- en: Providing transparent SSO for users who are accessing multiple **CAS**- secured
    applications within a configurable time window on the **CAS** server.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在**CAS**服务器上配置的时间窗口内访问多个**CAS**受保护应用程序的用户提供透明的SSO。
- en: Applications can force users to authenticate to `renew` property to `true` on
    `TicketValidator`; you may want to conditionally set this property in some custom
    code in the event that the user attempts to access a highly secured area of the
    application.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以强制用户在`TicketValidator`上`renew`属性设置为`true`进行身份验证；你可能希望在用户尝试访问应用程序的高安全区域时，在某些自定义代码中条件性地设置此属性。
- en: A **RESTful API** for obtaining service tickets.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取服务票据的**RESTful API**。
- en: The Aperero CAS server can also act as an **OAuth2** server. If you think about
    it, this makes sense, since **CAS** is very similar to **OAuth2**.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aperero CAS服务器也可以充当**OAuth2**服务器。如果你这么想，这很有道理，因为**CAS**与**OAuth2**非常相似。
- en: Providing **OAuth** support for the **CAS** server so that it can obtain access
    tokens to a delegate OAuth provider (that is, Google), or so the CAS server can
    be the OAuth server itself.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为**CAS**服务器提供**OAuth**支持，以便它可以获取访问令牌到代理OAuth提供者（即，Google），或者使**CAS**服务器本身成为OAuth服务器。
- en: We’d encourage you to explore the full capabilities of the CAS client and server
    as well as ask any questions to the helpful folks in the **CAS Aperero** community
    forums!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您探索CAS客户端和服务器全部功能，并向**CAS Aperero**社区论坛中的热心人士提出任何问题！
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the **CAS** SSO portal and how it can be integrated
    with Spring Security, and we also covered the **CAS** architecture and communication
    paths between actors in a **CAS**-enabled environment. We also saw the benefits
    of **CAS**-enabled applications for application developers and system administrators.
    We also learned about configuring the **JBCP Calendar** application to interact
    with a basic **CAS** installation. We also covered the use of **CAS**’s **Single**
    **Logout** support.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了**CAS** SSO门户以及它如何与Spring Security集成，我们还介绍了**CAS**架构以及**CAS**启用环境中参与者之间的通信路径。我们还看到了**CAS**启用应用程序对应用程序开发人员和系统管理员的益处。我们还学习了如何配置**JBCP
    Calendar**应用程序与基本**CAS**安装交互。我们还介绍了**CAS**的**单点****注销**支持。
- en: We also saw how proxy ticket authentication works and how to leverage it to
    authenticate stateless services.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何实现代理票据身份验证以及如何利用它来验证无状态服务。
- en: We also covered the tasks of updating **CAS** to interact with **LDAP** and
    sharing **LDAP** data with our **CAS**-enabled application. We even learned about
    implementing attribute exchange with the industry-standard **SAML** protocol.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何将**CAS**更新为与**LDAP**交互以及如何与我们的**CAS**启用应用程序共享**LDAP**数据。我们甚至学习了如何使用行业标准**SAML**协议实现属性交换。
- en: We hope this chapter was an interesting introduction to the world of SSO. There
    are many other SSO systems on the market, mostly commercial, but **CAS** is one
    of the leaders of the open source SSO world and offers an excellent platform to
    build out **SSO** capability in any organization.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这一章能成为对SSO世界有趣介绍的入门。市场上有很多其他SSO系统，大多是商业性的，但**CAS**是开源SSO领域的领导者之一，并为任何组织构建**SSO**能力提供了一个卓越的平台。
- en: For the last chapter, we’ll learn more on building GraalVM native images.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将学习更多关于构建GraalVM本地图像的内容。
