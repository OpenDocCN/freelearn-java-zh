- en: Event-Driven Architectures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构
- en: '**Event-driven architectures** (**EDA**) are based on commands and events that
    are created each time an application changes state. According to Martin Fowler,
    there are four patterns that are used to build software systems using this approach.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动架构**（**EDA**）基于每次应用程序更改状态时创建的命令和事件。根据Martin Fowler的说法，有四种模式用于使用这种方法构建软件系统。'
- en: In this chapter, we are going to learn about these four patterns and look at
    how messaging can be tied together to take full advantage of a programming model
    based on messages. Even when it's not a requirement, messaging can be used to
    add more capabilities into applications that are built using an event-driven architectural
    style.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习这四种模式，并看看如何将消息传递联系在一起，以充分利用基于消息的编程模型。即使这不是一个要求，消息传递也可以用来为使用基于事件驱动的架构风格构建的应用程序增加更多功能。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: 'Underlying concepts and key aspects associated with event-driven architectures:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动架构的基本概念和关键方面：
- en: Commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: 'Common patterns used within event-driven architectures:'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件驱动架构中使用的常见模式：
- en: Event notification
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件通知
- en: Event-carried state transfer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件携带状态传输
- en: Event sourcing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件溯源
- en: CQRS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS
- en: Underlying concepts and key aspects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本概念和关键方面
- en: Before looking into the details of event-driven architectures, we are going
    to start by learning about some key aspects surrounding them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解事件驱动架构的细节之前，我们将首先学习一些围绕它们的关键方面。
- en: 'The applications created using this approach are developed with two different
    but related concepts in mind:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法创建的应用程序是根据两个不同但相关的概念开发的：
- en: Commands
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Events
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Let's look at a brief definition of each of these concepts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要定义一下这些概念。
- en: Command
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: A command is an operation performed within an application that emits one or
    more events as the result of a successful or failed execution. We can think about
    these as operations that are intended to modify the state of a system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是在应用程序中执行的操作，作为成功或失败执行的结果会发出一个或多个事件。我们可以将这些操作看作是旨在修改系统状态的操作。
- en: 'Commands are called actions. This makes a lot of sense if we take their intended
    use into consideration. The following list shows some examples of such commands:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 命令被称为操作。如果我们考虑到它们的预期用途，这是非常合理的。以下列表显示了一些此类命令的示例：
- en: Transfer money
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转账
- en: Update user information
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新用户信息
- en: Create an account
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个账户
- en: It's highly recommended that you use present tense verbs for naming commands,
    as demonstrated with these examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您使用现在时态的动词来命名命令，就像这些例子所示。
- en: Event
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: An event is the result of a command execution within an application. These are
    used as a notification mechanism for subscribers who are interested in receiving
    them. Events are immutable and should not be modified, as they are designed to
    keep a log that keeps information on how the application state has mutated over
    time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是应用程序中命令执行的结果。这些事件用作订阅者接收通知的机制。事件是不可变的，不应该被修改，因为它们被设计为保留应用程序状态如何随时间变化的日志信息。
- en: 'When it comes to naming events, the rule of thumb is to use past tense, such
    as the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名事件时，经验法则是使用过去时态，例如以下内容：
- en: Money transferred
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资金转移
- en: User information updated
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户信息已更新
- en: Account created
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户已创建
- en: Events are not concerned with what actions will be performed after their creation.
    This makes it possible to decouple a system but still notify the subscribers. In
    this way, we can decouple applications because the subscribers are responsible
    for executing one or more operations, depending on what is needed when they have
    been notified of an event's creation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 事件不关心它们创建后将执行什么操作。这使得可以解耦系统但仍通知订阅者。这样，我们可以解耦应用程序，因为订阅者负责根据需要执行一个或多个操作，一旦他们被通知事件的创建。
- en: At this point, we can conclude that we can decouple applications because the
    subscribers are responsible for executing one or more operations, depending on
    what is needed when they have been notified of an event's creation. We can also
    infer that events are an excellent way to reverse dependencies by delegating responsibilities
    to other systems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以得出结论，我们可以解耦应用程序，因为订阅者负责根据需要执行一个或多个操作，一旦他们被通知事件的创建。我们还可以推断，事件是通过将责任委托给其他系统来逆转依赖关系的绝佳方式。
- en: 'The following diagram shows how a command emits events and how the subscribers
    to these events are notified:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了命令如何发出事件以及这些事件的订阅者如何被通知：
- en: '![](img/8ddc799d-645a-4f18-b6ba-1a55ee131efb.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ddc799d-645a-4f18-b6ba-1a55ee131efb.png)'
- en: Events creation and propagation
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的创建和传播
- en: Now that we have a better understanding of events, let's review the four patterns
    that we mentioned at the beginning of this chapter in order to create applications
    using an event-driven architectural style.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对事件有了更好的理解，让我们回顾一下本章开头提到的四种模式，以便使用基于事件驱动的架构风格创建应用程序。
- en: Patterns of event-driven architectures
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动架构的模式
- en: 'When people talk about event-driven architectures, they often refer to one
    of the following patterns:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们谈论事件驱动架构时，他们经常提到以下模式之一：
- en: Event notification
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件通知
- en: Event-carried state transfer
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件携带状态传输
- en: Event sourcing
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件溯源
- en: CQRS
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS
- en: At times, more than one of these are used together within the same system, depending
    on what the business requirements are. Let's review each of these patterns in
    order to identify the scenarios in which they can be used.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在同一系统中会同时使用多个模式，具体取决于业务需求。让我们回顾每种模式，以便确定可以使用它们的场景。
- en: Event notification
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件通知
- en: The event notification pattern works by emitting events to subscribers once
    a command is executed. This can be compared to the observer pattern in which you
    observe a subject that has a list of many listeners or subscribers that are automatically notified
    when the state of the observed object changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通知模式通过在执行命令后向订阅者发出事件来工作。这可以与观察者模式进行比较，观察者模式中，您观察到一个具有许多监听器或订阅者列表的主题，在观察对象的状态发生变化时会自动通知它们。
- en: 'This behavior is widely used by event bus libraries that allow publish-subscribe
    communication among the components that are part of an application. The most common
    use cases for these libraries are targeted towards the UI, but they are also applicable
    to other parts of the system in the backend. The following diagram demonstrates
    how an event is sent to the bus and then propagated to all subscribers, which
    were previously registered:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为被事件总线库广泛使用，允许应用程序中的组件之间进行发布-订阅通信。这些库的最常见用例是针对UI，但它们也适用于后端系统的其他部分。下图演示了事件如何发送到总线，然后传播到之前注册的所有订阅者：
- en: '![](img/a065abde-ec41-4828-ab21-9c8f33600082.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a065abde-ec41-4828-ab21-9c8f33600082.png)'
- en: Event bus
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线
- en: 'There are two main benefits to using this event-notification mechanism:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此事件通知机制有两个主要好处：
- en: Decoupled systems and functionalities
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦的系统和功能
- en: Inverted dependencies
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倒置的依赖关系
- en: 'To better understand these benefits, let''s imagine that we need to work on
    the following requirement of our banking application:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些好处，让我们想象一下我们的银行应用程序需要处理以下需求：
- en: '*The bank wants to offer customers who are using the mobile app the chance
    to transfer money. This will include either transferring **between accounts owned **by **our
    bank or transferring to external banks. Once this transaction is executed, we
    need to notify the customers about the transaction status using their preferred
    notification channels.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*银行希望为使用移动应用的客户提供转账的机会。这将包括在我们银行拥有的账户之间转账，或者转账到外部银行。一旦执行此交易，我们需要使用客户首选的通知渠道通知客户有关交易状态。*'
- en: '*The bank also has an application that is used by the call center staff that
    notifies our agents of our clients'' balance. When a client''s account balance
    is higher than a predetermined amount of money, the call center system will alert
    the agents, who will then call the clients to make them aware of the possibility
    of investing their money in the bank. Finally, if a transaction involves an external
    bank, we need to notify them about the transaction status too.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*银行还有一个应用程序，由呼叫中心工作人员使用，通知我们的代理客户的余额。当客户的账户余额高于预定金额时，呼叫中心系统将提醒代理，然后代理将致电客户，让他们意识到可以将他们的钱投资到银行。最后，如果交易涉及外部银行，我们也需要通知他们交易状态。*'
- en: 'Using a classic approach to write an application, we can correctly build a
    system where all the following postconditions listed in the requirements are executed
    within the transfer application boundaries after the money transfer occurs, as
    demonstrated in the following diagram:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用经典方法编写应用程序，我们可以正确构建一个系统，在转账发生后，所有在转账应用程序边界内列出的后置条件都得到执行，如下图所示：
- en: '![](img/c789f88c-e8ac-4e36-8e46-10290e86a8c9.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c789f88c-e8ac-4e36-8e46-10290e86a8c9.png)'
- en: Coupled transfer money application
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合的转账应用程序
- en: As we can see from the preceding diagram, the transfer money application needs
    to know about all the postconditions that have to be met once the transaction
    has occurred; using this approach, we will end up writing all the necessary code
    to interact with other systems, which leads us to couple the application with
    other systems.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从上图中看到的，转账应用程序需要知道一旦交易发生，必须满足的所有后置条件；使用这种方法，我们最终将编写所有必要的代码与其他系统进行交互，这将导致应用程序与其他系统耦合。
- en: 'On the other hand, using the event-notification pattern, we can decouple the
    transfer money application, as shown in the following diagram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用事件通知模式，我们可以解耦转账应用程序，如下图所示：
- en: '![](img/dc5708c0-6293-4467-bfa9-dc7c7be9cf3d.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc5708c0-6293-4467-bfa9-dc7c7be9cf3d.png)'
- en: Decoupled transfer money application
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦的转账应用程序
- en: In the preceding diagram, we can see that once the `<Transfer money>` command is
    executed, a `<Money transferred>` event is emitted, and all the subscribed systems
    are notified. By doing this, we can get rid of the coupling among the systems.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到一旦执行`<Transfer money>`命令，就会发出`<Money transferred>`事件，并通知所有订阅的系统。通过这样做，我们可以摆脱系统之间的耦合。
- en: The important thing to note here is that the money transfer application doesn't
    even need to know about the existence of other software systems, and all the postconditions
    are met out of the boundaries of this application. In other words, decoupled systems
    lead us to invert dependencies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要一点是，转账应用程序甚至不需要知道其他软件系统的存在，并且所有后置条件都在该应用程序的边界之外得到满足。换句话说，解耦的系统导致我们倒置依赖关系。
- en: Decoupled systems and inverted dependencies sound fantastic, but the implicit
    disadvantage of these is that you lose visibility. This is because the application
    emitting events doesn't know anything about the processes that are executed once
    the event is published, and there is no code for reading other systems.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦的系统和倒置的依赖关系听起来很棒，但这种方法的隐含缺点是您会失去可见性。这是因为发出事件的应用程序对于发布事件后执行的进程一无所知，也没有用于读取其他系统的代码。
- en: It is often impossible to identify dependencies downstream, and some techniques
    for correlating events across different logs are commonly used to relieve this
    nightmare.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常无法识别下游依赖关系，并且通常使用一些技术来在不同日志之间关联事件，以减轻这一噩梦。
- en: Coupled systems give all the information regarding downstream dependencies,
    and are hard to evolve. Conversely, decoupled systems know nothing about downstream
    dependencies, but they offer the chance to evolve systems independently.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合的系统提供有关下游依赖的所有信息，并且难以演变。相反，解耦的系统对下游依赖一无所知，但它们提供了独立演变系统的机会。
- en: 'Now that we have learned of the underlying concepts that are supporting the
    event-notification pattern, we can say that the most visible technology for implementing
    this kind of application is the use of messaging systems such as RabbitMQ, AWS
    SQS/SNS, MSMQ, and so on. These are supported by Spring under the Spring Cloud
    Stream project umbrella. In our case, we are going to use RabbitMQ, which can
    be supported by adding the following dependency:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了支持事件通知模式的基本概念，我们可以说，实现这种应用程序最显而易见的技术是使用RabbitMQ、AWS SQS/SNS、MSMQ等消息系统。这些都是Spring
    Cloud Stream项目下的Spring支持的。在我们的案例中，我们将使用RabbitMQ，可以通过添加以下依赖来支持：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to make the setup process of RabbitMQ accessible, the code provided
    for this book in this chapter includes a Docker Compose file that should be executed
    using the `docker-compose up `command*. *We will look at what Docker Compose is
    and how it works in [Chapter 10](8762b4ca-6a2e-4b00-acf3-3f8f5e2f00b9.xhtml),
    *Containerizing your Applications*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使RabbitMQ的设置过程可访问，本章提供的代码包括一个Docker Compose文件，应使用`docker-compose up`命令执行。我们将在[第10章](8762b4ca-6a2e-4b00-acf3-3f8f5e2f00b9.xhtml)中看到Docker
    Compose是什么以及它是如何工作的，*容器化您的应用程序*。
- en: 'Spring Cloud Stream is built on the top of Spring Integration and offers the
    chance to produce and consume messages easily, as well as the chance to use all
    the built-in functionalities of Spring Integration. We are going to use this project
    to implement the example of the banking application mentioned earlier, so we will
    need to add the following dependency:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream建立在Spring Integration之上，提供了轻松生产和消费消息的机会，以及使用Spring Integration的所有内置功能的机会。我们将使用这个项目来实现前面提到的银行应用程序的示例，因此我们需要添加以下依赖项：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The transfer money application will expose an endpoint to allow the transferring
    of money. Once this transaction is done, an event notification needs to be sent
    to the other apps. Spring Cloud Stream makes it possible to define messaging channels
    with the use of the `@Output` annotation, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 转账应用程序将公开一个端点，允许转账。一旦完成这笔交易，就需要向其他应用程序发送事件通知。Spring Cloud Stream使得可以使用`@Output`注解定义消息通道，如下所示：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This interface can be annotated and used wherever you want. Let''s look at
    how to use this in the controller, which exposes the functionality to transfer
    money:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口可以被注释并在任何地方使用。让我们看看如何在控制器中使用它，以公开转账功能：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One thing to keep in mind when we are using the event-notification pattern is
    that the application that is emitting events simply provides very basic information
    regarding the executed command. In this case, the `<Money Transferred>` event
    contains the client ID that should be used later to query more information and
    determine whether or not additional operations need to be executed. This process
    always involves one or more additional interactions with other systems, databases,
    and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用事件通知模式时要记住的一件事是，发出事件的应用程序只提供关于执行的命令的非常基本的信息。在这种情况下，<转账完成>事件包含应该稍后用于查询更多信息并确定是否需要执行其他操作的客户端ID。这个过程总是涉及与其他系统、数据库等的一个或多个额外交互。
- en: 'The subscribers can take advantage of Spring Cloud Stream as well. In this
    case, the `@Input` annotation should be used as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者也可以利用Spring Cloud Stream。在这种情况下，应该使用`@Input`注解如下：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using Spring Integration, a complete integration flow can be executed to process
    the incoming message in this way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Integration，可以执行完整的集成流程来处理传入的消息：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once the message is retrieved, it should be used to query additional information
    regarding the transaction and determine whether a notification should be sent
    to external banks. This approach is useful for reducing the size of the payload.
    It also helps to avoid sending information that is often unnecessary and useless
    for other systems, but which increases the traffic retrieved by the source application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检索到消息，就应该用它来查询有关交易的其他信息，并确定是否应该向外部银行发送通知。这种方法有助于减少有效负载的大小。它还有助于避免发送通常是不必要的和对其他系统无用的信息，但会增加源应用程序检索的流量。
- en: 'In worst-case scenarios, every single event produced will retrieve at least
    one additional request asking for the transaction details, as shown in the following
    diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，每个产生的事件都将至少检索一个额外的请求，要求交易详情，如下图所示：
- en: '![](img/b81c2556-b001-40b5-9827-887c498492a8.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b81c2556-b001-40b5-9827-887c498492a8.png)'
- en: Downstream dependencies requesting transaction details
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下游依赖请求交易详情
- en: In our example, we will have at least three other requests from the dependent
    systems for each event produced.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，每个产生的事件都将至少有三个来自依赖系统的其他请求。
- en: Event-carried state transfer
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件携带状态传输
- en: The event-carried state transfer pattern has a minor variation in comparison
    to the event-notification pattern discussed earlier. Here, the event contains
    very basic information related to the executed command. In this case, the event
    contains all of the information regarding the executed command that is used to
    avoid contacting the source application to perform further processing by the dependent
    systems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前讨论的事件通知模式相比，事件携带状态传输模式有一个小的变化。在这里，事件包含与执行的命令相关的非常基本的信息。在这种情况下，事件包含有关执行的命令的所有信息，用于避免通过依赖系统进一步处理而联系源应用程序。
- en: 'This pattern brings the following benefits to the table:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式为我们带来了以下好处：
- en: Improves application performance
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高应用程序性能
- en: Reduces the load on the source application
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少源应用程序的负载
- en: Increases the availability of the system
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加系统的可用性
- en: Let's talk about each of these points in the following sections.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的部分讨论每个要点。
- en: Improving application performance
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高应用程序性能
- en: In the previous example, once the event was produced and retrieved by the downstream
    systems, an additional operation needed to be executed in order to obtain the
    details associated with the transaction. This determined what action needed have
    to been performed as part of the process. This additional operation involved establishing
    a communication with the source application. This step could take only a few milliseconds
    in some cases, but the response time could take longer depending on the network
    traffic and latency. This would then influence the performance of the dependent
    systems.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，一旦事件被下游系统产生和检索，就需要执行额外的操作来获取与交易相关的详细信息。这决定了作为流程的一部分需要执行的操作。这个额外的操作涉及与源应用程序建立通信。在某些情况下，这一步可能只需要几毫秒，但响应时间可能会更长，这取决于网络流量和延迟。这将影响依赖系统的性能。
- en: As a result, the size of the payload provided by the source application increases,
    but less traffic is required.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，源应用程序提供的负载大小增加，但需要的流量减少。
- en: Reducing the load on the source application
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少对源应用程序的负载
- en: Since all the information associated with the executed command is included as
    part of the produced event, there is no need to ask for more information about
    the source application. Consequently, there are fewer requests, reducing the load
    retrieved by the source application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于作为产生事件的一部分包含了与执行命令相关的所有信息，因此无需再向源应用程序请求更多信息。因此，请求减少，减轻了源应用程序的负载。
- en: The relationship between the produced events and the requests retrieved once
    the event is emitted is 1:1 in the best-case scenarios. In other words, one request
    will produce one event, but this could be even worse depending on how many dependent
    systems need to ask for additional information when the event is retrieved.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在最佳情况下，产生的事件与检索到的请求之间的关系是1:1。换句话说，一个请求会产生一个事件，但根据依赖系统需要在检索事件时请求多少额外信息，情况可能更糟。
- en: 'To avoid this extra load, all downstream systems often have their own data
    storage in which the events information is persisted, as shown by the following
    diagram:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种额外负载，所有下游系统通常都有自己的数据存储，其中事件信息被持久化，如下图所示：
- en: '![](img/94465532-3b0f-4da2-816a-c233a82f9d2c.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94465532-3b0f-4da2-816a-c233a82f9d2c.png)'
- en: Downstream dependencies persisting events data
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下游依赖持久化事件数据
- en: When using this approach, each one of the downstream systems only stores the
    data that is relevant to itself, and the rest of the information provided is ignored
    because it is useless for the system, and won't be used at all.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法时，每个下游系统只存储与自身相关的数据，提供的其余信息会被忽略，因为对于系统来说是无用的，根本不会被使用。
- en: Increasing the availability of the system
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加系统的可用性
- en: After removing the need to ask for additional data once the event has been retrieved,
    it's natural to assume that the availability of the system has increased as, no
    matter whether the other systems are available or not, the event will be processed.
    An indirect consequence of introducing this benefit is the eventual consistency
    that is now part of the system.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在消除了一旦检索到事件就需要请求额外数据的需要之后，可以自然地假设系统的可用性已经提高，因为无论其他系统是否可用，事件都将被处理。引入这一好处的间接后果是现在系统中的最终一致性。
- en: Eventual consistency is a model that is used to achieve high availability in
    the systems where, if no new updates are made to the given data, once a piece
    of information has been retrieved, all instances of accessing that data will eventually
    return the last updated value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最终一致性是一种模型，用于在系统中实现高可用性，如果给定数据没有进行新的更新，一旦检索到一条信息，所有访问该数据的实例最终将返回最新更新的值。
- en: 'The following diagram shows how a system changes its data without propagating
    these changes to the downstream dependencies:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了系统如何在不将这些更改传播到下游依赖项的情况下改变其数据：
- en: '![](img/ee803ce8-493c-4991-9b50-5f7e8bdb2b73.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee803ce8-493c-4991-9b50-5f7e8bdb2b73.png)'
- en: Data updates are not propagated
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数据更新不会传播
- en: 'To change the preceding example so that it follows this approach, we only need
    to include additional information as part of the payload. Previously, we just sent
    a `String` with the `clientId`; now we are going to cover the complete `TransactionMoneyDetails`
    in the following way:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的例子遵循这种方法，我们只需要在负载的一部分中包含额外的信息。以前，我们只发送了一个带有`clientId`的`String`；现在我们将以以下方式涵盖完整的`TransactionMoneyDetails`：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Message` class can support any kind of object that should be specified
    within `<>`, since this class is implemented using the generic types feature from
    Java.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message`类可以支持任何应该在`<>`中指定的对象，因为这个类是使用Java的泛型类型特性实现的。'
- en: 'The downstream-dependent systems should also be modified to make them able
    to retrieve an object instead of a simple string. Since the `Handler` to process
    incoming messages also supports generics, we can implement this feature with a
    small change in the code, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下游依赖系统也应该被修改，使它们能够检索对象而不是简单的字符串。由于处理传入消息的`Handler`也支持泛型，我们可以通过对代码进行小的更改来实现这个功能，如下所示：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Event sourcing
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源
- en: Event sourcing is another way to implement applications using an event-driven
    approach, where the core of the functionality is based on the use of commands
    that produce events that change the system state once they have been processed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源是另一种使用基于事件驱动方法实现应用程序的方式，其中功能的核心基于产生事件的命令，一旦处理完毕，这些事件将改变系统状态。
- en: 'We can think of a command as the result of a transaction executed within the
    system. This transaction would be different depending on factors such as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将命令看作是在系统内执行的交易的结果。这个交易会因以下因素而不同：
- en: User actions
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户操作
- en: Messages received from other applications
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自其他应用程序的消息
- en: Scheduled tasks performed
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行的定期任务
- en: Applications created using an event-sourcing approach store the events associated
    with the executed commands. It's also worth storing the commands that produced events.
    This makes it possible to correlate all of them in order to get an idea of the
    boundaries that were created.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件源方法创建的应用程序存储与执行命令相关的事件。还值得存储产生事件的命令。这样可以将它们全部相关联，以便了解所创建的边界。
- en: The main reason to store events is to use them whenever you want to rebuild
    the system state at any point in time. A way to make this task easier is by periodically generating
    backups for the database that stores the system state, which is helpful for avoiding
    the need to reprocess all the events that were created since the application started
    to work. Instead, we will just need to process the set of events that were executed
    after the database snapshot was generated.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 存储事件的主要原因是在任何时间点重建系统状态时使用它们。使这项任务变得更容易的方法是定期为存储系统状态的数据库生成备份，这有助于避免重新处理应用程序开始工作以来创建的所有事件的需要。相反，我们只需要处理在生成数据库快照之后执行的事件集。
- en: 'Let''s review the following set of diagrams to understand how this works. The
    first diagram shows that once `Command A` is executed, three `Events` are created,
    and a new `State` is generated after each one of them is processed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾以下一系列图表，以了解这是如何工作的。第一个图表显示一旦执行“Command A”，就会创建三个“事件”，并且在处理每个事件后生成一个新的“状态”：
- en: '![](img/f6c21ae3-3c05-481c-9dd0-bdad5e083381.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6c21ae3-3c05-481c-9dd0-bdad5e083381.png)'
- en: Events and application states generated once Command A is executed
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行Command A，生成的事件和应用程序状态
- en: 'The following diagram represents quite a similar process. In this case, two
    `Events` were created as a result of the `Command B` execution:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表代表了一个相似的过程。在这种情况下，由于“Command B”的执行，创建了两个“事件”：
- en: '![](img/ec22155e-8a04-4229-8737-b9c760246dfa.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec22155e-8a04-4229-8737-b9c760246dfa.png)'
- en: Events and application states generated as the result of the Command B execution
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Command B执行的结果生成的事件和应用程序状态
- en: 'So far, our application has five states:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序有五个状态：
- en: State A
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态A
- en: State B
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态B
- en: State C
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态C
- en: State D
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态D
- en: State E
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态E
- en: 'Let''s say we are interested in debugging `Event b-1` because, when it was
    executed, the application crashed. To achieve this goal, we have two options:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对“事件b-1”感兴趣，因为在执行时应用程序崩溃了。为了实现这个目标，我们有两个选择：
- en: 'Process the events one by one and study the application behavior during the
    `Event b-1` execution, as shown in the following diagram:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐个处理事件，并在“事件b-1”执行期间研究应用程序行为，如下图所示：
- en: '![](img/f60ed164-0460-4e56-b547-166613859f2a.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f60ed164-0460-4e56-b547-166613859f2a.png)'
- en: Rebuilding the application state processing all the events
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 处理所有事件重建应用程序状态
- en: 'Process the rest of the events after restoring a database snapshot and study
    the application behavior during the `Event b-1` execution, as shown in the following
    diagram:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在恢复数据库快照后处理其余事件，并在“事件b-1”执行期间研究应用程序行为，如下图所示：
- en: '![](img/f946d555-0508-4806-9395-bfc09324b89a.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f946d555-0508-4806-9395-bfc09324b89a.png)'
- en: Rebuilding the application state from a database snapshot
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库快照重建应用程序状态
- en: Obviously, the second approach is much more efficient. Scheduled tasks are often
    in charge of creating database snapshots after a certain period of time, and a
    policy should be established to manage the existing snapshots. For example, you
    can establish a policy to create a new snapshot every single day at midnight and
    get rid of old snapshots after the most convenient period of time for your business.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，第二种方法更有效。定期任务通常负责在一定时间后创建数据库快照，并且应该建立一个管理现有快照的策略。例如，您可以建立一个策略，在每天午夜创建一个新的快照，并在最适合您业务的时间后清除旧的快照。
- en: 'As you may have realized, the source of truth for our system is the events
    storage, which allows us to rebuild the application state at any time. Since the
    events are being used to generate the system state, we can 100% rely on the events
    storage. However, we should also consider the fact that an event execution within
    a system would also require interaction with another application. In this case,
    if you replay that event, you should think about how the other system(s) will
    be affected. Here, we would end up with one of the two following scenarios:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经意识到的那样，我们系统的真相来源是事件存储，这使我们能够随时重建应用程序状态。由于事件被用来生成系统状态，我们可以完全依赖事件存储。然而，我们还应该考虑一个事实，即系统内的事件执行也需要与另一个应用程序进行交互。在这种情况下，如果重放该事件，您应该考虑其他系统将如何受到影响。在这里，我们将得到以下两种情况之一：
- en: The operations executed in the other application(s) are idempotent
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他应用程序中执行的操作是幂等的
- en: The other application(s) will be affected because a new transaction will be
    generated
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他应用程序将受到影响，因为将生成新的事务
- en: In the first case, since the operations are idempotent, we don't have to be
    worried at all. This is because another execution will not affect the other system(s).
    In the second case, we should consider a way to create compensation operations
    or a way to ignore these interactions to avoid affecting the other systems.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，由于操作是幂等的，我们根本不必担心。这是因为另一个执行不会影响其他系统。在第二种情况下，我们应该考虑创建补偿操作的方法或者忽略这些交互的方法，以避免影响其他系统。
- en: 'The inherent benefits that we are going to have after following this approach
    are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循这种方法后，我们将获得以下固有的好处：
- en: A data store that can be used for auditing purposes
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于审计目的的数据存储
- en: An excellent logging level
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个很好的日志级别
- en: It will be easier to debug an application
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试应用程序将更容易
- en: A historic state
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史状态
- en: The ability to go back in time to a previous version of the state
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回到以前的状态的能力
- en: The quintessential example for event-sourcing applications is version control
    systems (VCS) such as Git, Apache subversion, CVS, or any other version control
    system where all the changes that are applied in the source code files are stored.
    Furthermore, the commits represent the events that allow us to undo/redo changes
    when required.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源应用程序的典型示例是版本控制系统（VCS），如Git、Apache子版本、CVS或任何其他版本控制系统，其中存储了应用于源代码文件的所有更改。此外，提交代表了允许我们在需要时撤消/重做更改的事件。
- en: In order to make it as simple as possible to understand, you can think of an
    event-sourcing application as something that manages data changes in the same
    way that a version control system manages file changes. You can also think about
    a `git push` operation as a command in an event-sourcing system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能简单地理解，您可以将事件溯源应用程序视为以与版本控制系统管理文件更改相同的方式管理数据更改。您还可以将`git push`操作视为事件溯源系统中的命令。
- en: Now that we have explained the underlying concepts behind event sourcing, it's
    time to dive into details that will allow us to understand how to implement a
    system following this approach. Although there are different ways to create event-sourcing
    applications, I'll explain a generic way to do it here. It is important that you
    keep in mind that this approach should be changed depending on the particular
    needs or assumptions that you need for your business.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了事件溯源背后的概念，是时候深入了解允许我们理解如何按照这种方法实现系统的细节了。虽然有不同的方法来创建事件溯源应用程序，但我将在这里解释一种通用的方法。重要的是要记住，这种方法应根据您的业务的特定需求或假设进行更改。
- en: 'We mentioned that an event-sourcing system should have *at least* two places
    in which to store the data. One of these will be used to save event and command
    information and the other one will be used to save the application state—we say *at
    least two* because more than one storage option is sometimes needed to persist
    the system state of an application. Since the input retrieved by the system to
    perform their business processes are very different from each other, we should
    consider using a database that supports the ability to store data using a JSON
    format. Following this approach, the most basic data that should be stored as
    part of a command that is executed within an event-sourcing system is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到事件溯源系统应该*至少*有两个存储数据的地方。其中一个将用于保存事件和命令信息，另一个将用于保存应用程序状态——我们说*至少两个*，因为有时需要多个存储选项来持久化应用程序的系统状态。由于系统检索的输入以执行其业务流程非常不同，我们应该考虑使用支持使用JSON格式存储数据的数据库。按照这种方法，应作为事件溯源系统中执行的命令的一部分存储的最基本数据如下：
- en: Unique identifier
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一标识符
- en: Timestamp
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Input data retrieved in JSON format
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以JSON格式检索的输入数据
- en: Any additional data to correlate commands
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于关联命令的任何附加数据
- en: 'On the other hand, the recommended data that should be stored for an event
    is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，应存储的建议数据事件如下：
- en: Unique identifier
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一标识符
- en: Timestamp
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Relevant data for the event in JSON format
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件的相关数据以JSON格式
- en: Identifier of the command that generated the event
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成事件的命令的标识符
- en: As we mentioned earlier, depending on your business needs, you would need to
    add more fields, but the ones mentioned earlier are necessary in any case. The
    key here is to make sure that your data will be able to be processed later to
    recreate the application state when that's needed. Almost any NoSQL database has
    support to store data as JSON, but some SQL databases, such as PostgreSQL, can also deal
    with data in this format very well.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，根据您的业务需求，您可能需要添加更多字段，但前面提到的字段在任何情况下都是必要的。关键在于确保您的数据稍后能够被处理以在需要时重新创建应用程序状态。几乎任何NoSQL数据库都支持将数据存储为JSON，但一些SQL数据库，如PostgreSQL，也可以很好地处理这种格式的数据。
- en: On the subject of the system state, the decision of choosing an SQL or NoSQL
    technology should completely depend on your business; you don't have to change
    your mind just because the application will be built using an event-sourcing approach.
    Furthermore, the structure of your data model should also depend on the business
    itself rather than on the events and commands that generate the data that will
    be stored there. It is also worth mentioning that one event will generate data
    that will be stored in one or more tables of the system state data model, and
    there are no restrictions at all in these terms.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 关于系统状态的决定，选择SQL或NoSQL技术完全取决于您的业务；您不必因为应用程序将使用事件溯源方法而改变主意。此外，您的数据模型结构也应该取决于业务本身，而不是取决于生成将存储在那里的数据的事件和命令。还值得一提的是，一个事件将生成将存储在系统状态数据模型的一个或多个表中的数据，并且在这些方面根本没有限制。
- en: When we think about commands, events, and states, a question that is usually raised is
    with regards to the order in which the information is persisted. This point would
    be an interesting discussion, but you don't have to worry too much about the order
    in which the data was persisted. You can choose to persist the data synchronously
    or asynchronously in any of the data storage instances.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑命令、事件和状态时，通常会提出一个问题，即信息持久化的顺序。这一点可能是一个有趣的讨论，但您不必太担心数据持久化的顺序。您可以选择在任何数据存储实例中同步或异步地持久化数据。
- en: An asynchronous approach sometimes leads us to think that we will end up having inconsistent
    information, but the truth is that both approaches could lead us to that point.
    Instead of thinking about synchronous or asynchronous processing, we should consider
    mechanisms to recover our app from these crashes, such as proper logging, for
    example. Good logging would be helpful for recovering the data of our systems
    in exactly the same way as we do for applications that are built using any approach
    other than event sourcing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法有时会让我们认为我们最终会得到不一致的信息，但事实是两种方法都可能导致这一点。我们应该考虑从这些崩溃中恢复我们的应用程序的机制，例如适当的日志记录。良好的日志记录对于恢复我们系统的数据非常有帮助，就像我们为使用事件源以外的任何方法构建的应用程序一样。
- en: 'Now it''s time to review some code to put the concepts that we discussed previously into
    practice. Let''s build an application that allows us to open a new bank account.
    The input data required will be as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回顾一些代码，把我们之前讨论过的概念付诸实践了。让我们构建一个应用程序，允许我们开设一个新的银行账户。所需的输入数据如下：
- en: Customer name
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户姓名
- en: Customer last name
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户姓氏
- en: An initial amount of money to open the account
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开设账户的初始金额
- en: Account type (savings/current)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户类型（储蓄/活期）
- en: After creating the account, our application state should reflect one new customer
    and a new bank account that has been created.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建账户后，我们的应用程序状态应该反映出一个新的客户和一个新创建的银行账户。
- en: 'As part of our application, we will have one command: `CreateCustomerCommand`.
    This will generate two events, named `CustomerCreated` and `AccountCreated`, as
    shown in the following diagram:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们应用程序的一部分，我们将有一个命令：`CreateCustomerCommand`。这将生成两个事件，名为`CustomerCreated`和`AccountCreated`，如下图所示：
- en: '![](img/5fed95d8-d882-458b-95b7-a620e8cca665.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fed95d8-d882-458b-95b7-a620e8cca665.png)'
- en: Command execution
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行
- en: 'Once this command is executed, a few things need to happen:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，需要发生一些事情：
- en: The command should be saved
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应保存命令
- en: The aforementioned events should be created with the relevant information for
    them
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述事件应该使用相关信息创建
- en: The events should be saved
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应保存事件
- en: The events should be processed
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应处理事件
- en: 'The relevant code for this process is shown in the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的相关代码如下所示：
- en: '[PRE8]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the events are handled, the system state should be generated. In this
    case, it means a new customer and a new account should be created, as shown in
    the following diagram:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理完毕后，应生成系统状态。在这种情况下，意味着应创建一个新的客户和一个新的账户，如下图所示：
- en: '![](img/81d1803c-8298-447b-8c39-f0c895be5c6b.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81d1803c-8298-447b-8c39-f0c895be5c6b.png)'
- en: System state generated after processing the events
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 处理事件后生成的系统状态
- en: 'To achieve this goal, we have a pretty basic implementation that, depending
    on `event name`, executes code instructions, as shown in the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们有一个非常基本的实现，根据`事件名称`执行代码指令，如下所示：
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you want to see how the application works, you can execute the following
    `CURL` command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看看应用程序的工作原理，可以执行以下`CURL`命令：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will see the following messages in the console :'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在控制台中看到以下消息：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can check the system state by executing SQL statements in the H2 web console
    available in the URL: `http://localhost:8080/h2-console`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在URL：`http://localhost:8080/h2-console`中使用H2 web控制台执行SQL语句来检查系统状态。
- en: 'The following screenshot shows the result of querying the Account table:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了查询账户表的结果：
- en: '![](img/6d25011b-0d29-4562-ae98-4001cb3b9e9a.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d25011b-0d29-4562-ae98-4001cb3b9e9a.png)'
- en: Query result from the Account table
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从账户表中查询结果
- en: 'The following screenshot shows the result of querying the Customer table:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了查询客户表的结果：
- en: '![](img/3b0f50a8-6983-46bb-aaf7-caef238a3c68.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b0f50a8-6983-46bb-aaf7-caef238a3c68.png)'
- en: Query result from the Customer table
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户表中查询结果
- en: 'The most crucial test for an event-sourcing application is the ability to recreate
    the `state` once the data is deleted. You can run this test by deleting the data
    from the table using the following SQL statements:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源应用程序的最关键测试是在数据被删除后能够重新创建`状态`。您可以通过使用以下SQL语句从表中删除数据来运行此测试：
- en: '[PRE12]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After executing these operations in the H2 console, you can recreate the state
    by running the following `CURL` command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在H2控制台中执行这些操作后，可以通过运行以下`CURL`命令重新创建状态：
- en: '[PRE13]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that you will need to replace the `<EVENT_ID>` listed in the preceding
    URL with the values listed in the console when the command was executed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要用前面URL中列出的`<EVENT_ID>`替换控制台中执行命令时列出的值。
- en: CQRS
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS
- en: '**Command-Query Responsibility Segregation** (**CQRS**) is a pattern in which
    the main idea is to create separate data structures and operations to read and
    write data by creating segregated interfaces to interact with the system''s data
    storage.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令查询职责分离**（**CQRS**）是一种模式，其主要思想是通过创建分离的接口来与系统的数据存储交互，从而创建用于读取和写入数据的分离数据结构和操作。'
- en: 'CQRS is not really based on events, but since it''s often used in conjunction
    with event-sourcing implementations, it is worth mentioning the scenarios in which
    it would be applied. There are three main use cases where the segregation of interfaces
    to process and query information would be useful:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS实际上并不是基于事件，但由于它经常与事件源实现一起使用，因此值得提到它适用的场景。有三种主要用例，其中处理和查询信息的接口分离将会很有用：
- en: Complex domain model
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的领域模型
- en: Distinct paths to query and persist information
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询和持久化信息的不同路径
- en: Independent scaling
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立扩展
- en: Complex domain models
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂的领域模型
- en: This scenario refers to systems where the inputs retrieved are simple to manage
    and persist in the database. However, before delivering information to users,
    many transformations are needed to make the data useful and comprehensive for
    the business.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情景指的是检索到的输入在数据库中简单管理和持久化的系统。然而，在将信息提供给用户之前，需要进行许多转换，使数据对业务有用和全面。
- en: Imagine a system where the code is comprised of a large set of entity objects
    mapping database tables to persist information using an ORM framework. This kind
    of system involves many writes and read operations that are executed using the
    ORM and some operations that run as part of the system to transform the retrieved
    data—in the form of entity objects—into data transfer objects (DTOs) to provide
    information in a meaningful way for the business.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个系统，其中代码由大量实体对象组成，这些对象使用ORM框架将数据库表映射为持久化信息。这种系统涉及许多使用ORM执行的写入和读取操作，以及作为系统一部分运行的一些操作，用于将检索到的数据（以实体对象的形式）转换为数据传输对象（DTO），以便以有意义的方式为业务提供信息。
- en: 'The following diagram shows the dataflow from the database to the business
    services that is designed to follow this approach:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了从数据库到业务服务的数据流，设计遵循这种方法：
- en: '![](img/c07aa513-2d26-423b-a48a-81d0d1bb2d37.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c07aa513-2d26-423b-a48a-81d0d1bb2d37.png)'
- en: Dataflow using entity objects and DTOs
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实体对象和DTO的数据流
- en: Transforming data is not a big deal. In systems using an ORM, the biggest problem arises
    when entity objects bring columns containing useless information that is ignored
    during the transformation process, introducing an unnecessary overhead on the
    database and the network. On the other hand, in the preceding diagram, we can
    see that a big process is needed to map the database tables as objects before actually
    getting the requested data. A good approach to getting rid of this problem is
    to replace the read operations executed by the ORM frameworks with stored procedures
    or plain query statements to retrieve only the required data from the database.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 转换数据并不是什么大问题。在使用ORM的系统中，最大的问题是实体对象带来包含在转换过程中被忽略的无用信息的列，这会给数据库和网络带来不必要的开销。另一方面，在上图中，我们可以看到在实际获取所请求的数据之前，需要一个大的过程将数据库表映射为对象。解决这个问题的一个好方法是用存储过程或纯查询语句替换ORM框架执行的读操作，从数据库中仅检索所需的数据。
- en: 'The following diagram shows how entity objects can be replaced with DOTs:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了如何用DOTs替换实体对象：
- en: '![](img/08280105-b441-4ee5-b9e8-7e9b1a1d03eb.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08280105-b441-4ee5-b9e8-7e9b1a1d03eb.png)'
- en: Data flow using DTOs
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DTO的数据流
- en: It's evident that this approach is much more simple and easy to accomplish.
    Even the amount of code required is drastically reduced. I'm not concluding that
    ORM frameworks are bad—actually, many of them are awesome, and projects such as
    Spring Data provide tons of built-in features. However, depending on the business
    requirements, plain JDBC operations are sometimes much more beneficial for the
    system.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这种方法更简单，更容易实现。所需的代码量甚至大大减少。我并不是在得出ORM框架不好的结论——实际上，其中许多都非常棒，像Spring Data这样的项目提供了大量内置功能。然而，根据业务需求，纯JDBC操作有时对系统更有益。
- en: Distinct paths to query and persist information
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询和持久化信息的不同路径
- en: When we are building applications, it's quite common to find ourselves writing
    tons of validations on the retrieved input before using the provided information
    in the system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，我们经常发现自己在使用系统提供的信息之前对检索到的输入进行大量验证。
- en: 'Common validations applied to the retrieved data include the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于检索数据的常见验证包括以下内容：
- en: Verification for non-null values
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证非空值
- en: Specific text formats, such as emails
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定文本格式，如电子邮件
- en: Checks to validate string lengths
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查以验证字符串长度
- en: The maximum quantity of decimals allowed in numbers
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字中允许的最大小数位数
- en: There are many mechanisms available for implementing this kind of validation
    within our code. The most popular of these are based on third-party libraries
    that rely on annotations that can be extended using regular expressions for specific
    scenarios. There is even a specification that is part of the platform that can
    be used to validate class fields called Bean Validation. This is currently part
    of the **Java Specification Request** (**JSR**) **380** ([http://beanvalidation.org/](http://beanvalidation.org/)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多机制可用于在我们的代码中实现这种验证。其中最流行的是基于第三方库的，依赖于可以使用正则表达式进行扩展以适用于特定场景的注解。甚至有一个作为平台的一部分可以用于验证类字段的规范，称为Bean
    Validation。这目前是**Java规范请求**（**JSR**）**380**的一部分（[http://beanvalidation.org/](http://beanvalidation.org/)）。
- en: While it is essential to have all these validations when users or external systems
    provide the data, there is no need to keep performing these checks when the information
    is read from the database and returned to the user. Furthermore, in some cases,
    such as event sourcing, once the data is retrieved, some commands are executed,
    events are created, and at the end, the information is persisted.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户或外部系统提供数据时，有必要进行所有这些验证，但是当从数据库中读取信息并返回给用户时，就没有必要继续执行这些检查。此外，在某些情况下，例如事件溯源，一旦检索到数据，会执行一些命令，创建事件，最终持久化信息。
- en: In these scenarios, it is apparent that the processes to persist and read information
    are different, and they need separate paths in order to accomplish their goals.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中，显然持久化和读取信息的过程是不同的，它们需要分开的路径来实现它们的目标。
- en: 'The following diagram shows how an application uses different paths to persist
    and retrieve data:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了应用程序如何使用不同路径来持久化和检索数据：
- en: '![](img/7abf67f1-4d20-4321-a20c-9d332f8adaf3.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7abf67f1-4d20-4321-a20c-9d332f8adaf3.png)'
- en: Data persisted and queried using different paths
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同路径持久化和查询的数据
- en: From the preceding diagram, we can quickly note how much processing is avoided
    because it is absolutely unnecessary. Furthermore, the domain models used to query
    and process the information are often different because they are tailored to accomplish
    different goals.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图可以快速注意到有多少处理是不必要的，因为它绝对是不必要的。此外，用于查询和处理信息的领域模型通常不同，因为它们旨在实现不同的目标。
- en: Independent scaling
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立扩展
- en: Today, it's common to hear developers, software architects, and technical people
    in general talking about creating separate services to solve different needs.
    Creating separate services supports the independent scaling approach because it
    makes it possible to scale the created services separately.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，常常听到开发人员、软件架构师和技术人员讨论创建独立服务来解决不同的需求。创建独立服务支持独立扩展的方法，因为它使得可以分别扩展创建的服务。
- en: The main idea, in this case, is creating separate systems that can be built
    and deployed independently. The source of data for these different applications
    can either be the same or different, depending on what the requirements are. The
    most common scenario here is where the same data storage is used for both systems
    because the applied changes should be immediately reflected. Otherwise, delayed
    data could cause confusion or errors during the normal operation of an application.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，主要的想法是创建可以独立构建和部署的独立系统。这些不同应用程序的数据源可以是相同的，也可以是不同的，这取决于需求是什么。这里最常见的情况是两个系统使用相同的数据存储，因为应用的更改应该立即反映出来。否则，延迟的数据可能会在应用程序的正常运行过程中引起混乱或错误。
- en: Let's think about an online store. Imagine that you added many items to your
    shopping cart, and after checking out your order, you realize you paid a lower
    amount of money than required because not all items were considered during the
    check-out process. This is undesired behavior within an application.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个在线商店。假设你向购物车中添加了许多商品，在结账后，你意识到支付的金额比所需的金额要低，因为在结账过程中并未考虑所有商品。这是应用程序中不希望出现的行为。
- en: On the other hand, in some cases, it is okay to use different data storage because
    retrieving data that is delayed by hours or days is enough to solve the business
    needs associated with an application. Imagine that you are tasked with creating
    a report showing the months when people tend to request vacations. Of course,
    a database that does not have the latest changes, and is a bit behind the current
    state of the application, will work perfectly. When we have this kind of requirement, we
    can use reporting databases (see [https://martinfowler.com/bliki/ReportingDatabase.html](https://martinfowler.com/bliki/ReportingDatabase.html)
    for more details) to retrieve the information. This approach is often taken when
    an application is intended to provide executive reporting information for taking
    strategic decisions rather than getting a list of all the existing records in
    the database tables.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在某些情况下，使用不同的数据存储是可以接受的，因为检索延迟数小时或数天的数据已足以满足应用程序相关的业务需求。想象一下，你的任务是创建一个报告，显示人们倾向于在哪些月份请假。当然，一个数据库如果没有最新的更改，稍微落后于应用程序的当前状态，也可以完美地工作。当我们有这种需求时，我们可以使用报告数据库（有关更多详细信息，请参见[https://martinfowler.com/bliki/ReportingDatabase.html](https://martinfowler.com/bliki/ReportingDatabase.html)）来检索信息。这种方法通常用于当应用程序旨在提供执行报告信息以做出战略决策时，而不是获取数据库表中所有现有记录的列表。
- en: Having separate systems to query and process information gives us the benefit
    of independent scaling capabilities on both systems. This is useful when one of
    the systems requires many more resources for processing. Let's take the example of
    the online store mentioned previously—people are always looking for items to buy,
    making comparisons, checking sizes, prices, brands, and so on.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有独立的系统来查询和处理信息使我们能够在两个系统上实现独立的扩展能力。当其中一个系统需要更多资源进行处理时，这是非常有用的。让我们以前面提到的在线商店为例，人们总是在寻找要购买的商品，进行比较，检查尺寸、价格、品牌等等。
- en: In the preceding example, the number of requests to check out orders is less
    than the number of requests to check for item information. So, in this case, having
    separate systems allows us to avoid unnecessarily wasting resources and allows
    us to only add more resources or instances of the service that has the highest
    volume of traffic.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，检查订单的请求次数少于检查商品信息的请求次数。因此，在这种情况下，拥有独立的系统可以避免不必要地浪费资源，并且可以只增加更多资源或服务实例，以处理流量最大的服务。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered event-driven architectures and the four common patterns
    that are used to implement applications using this architectural style. We explained
    each of these patterns in detail, and wrote some code to understand how they can
    be implemented using Spring Framework. At the same time, we looked at some use
    cases where they can be utilized, and learned how they help us to reduce the complexity
    that is introduced as part of the system requirements that we would eventually
    have.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了事件驱动架构以及用于实现使用这种架构风格的应用程序的四种常见模式。我们详细解释了每种模式，并编写了一些代码来理解它们如何使用Spring
    Framework实现。同时，我们还研究了一些可以利用它们的用例，并学习了它们如何帮助我们减少作为系统需求一部分引入的复杂性。
- en: As part of these patterns, we talked about event sourcing, which is getting
    more and more popular within the microservices world, and which we will learn
    about later in [Chapter 8](7c38500a-5a66-422b-a41b-21f4fd18de51.xhtml), *Microservices*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些模式的一部分，我们谈到了事件溯源，在微服务世界中越来越受欢迎，我们将在《微服务》的第8章中学习更多相关内容。
