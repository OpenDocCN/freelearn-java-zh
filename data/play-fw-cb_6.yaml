- en: Chapter 6. Practical Module Examples
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 实际模块示例
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Integrating a Play application with message queues
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Play 应用程序与消息队列集成
- en: Integrating a Play application with ElasticSearch
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Play 应用程序与 ElasticSearch 集成
- en: Implementing token authentication using JWT
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JWT 实现令牌认证
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will look further into integrating a Play application with
    other essential services and tools for the modern web application. Specifically,
    we will look into how we can integrate an external message queue service with
    a Play plugin. We will use the popular cloud service **IronMQ** for this.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步探讨将 Play 应用程序与现代网络应用程序的必要服务和工具集成。具体来说，我们将探讨如何使用 Play 插件集成外部消息队列服务。我们将使用流行的云服务
    **IronMQ**。
- en: We will also look into integrating a full text search engine service with a
    Play application using **ElasticSearch** and **Docker**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨如何使用 **ElasticSearch** 和 **Docker** 将全文搜索引擎服务与 Play 应用程序集成。
- en: Finally, we will implement our own Play wrappers for the integration of token
    authentication using **JSON Web Tokens** (**JWT**).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现自己的 Play 包装器，用于使用 **JSON Web Tokens**（**JWT**）进行令牌认证的集成。
- en: Integrating a Play application with message queues
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Play 应用程序与消息队列集成
- en: 'In this recipe, we will explore how to use Play 2.0 to integrate with IronMQ,
    a popular cloud message queue service. We will use IronMQ''s Java libraries, which
    can be found here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨如何使用 Play 2.0 集成 IronMQ，这是一个流行的云消息队列服务。我们将使用 IronMQ 的 Java 库，可以在以下位置找到：
- en: '[https://github.com/iron-io/iron_mq_java](https://github.com/iron-io/iron_mq_java)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/iron-io/iron_mq_java](https://github.com/iron-io/iron_mq_java)'
- en: We will use a Play plugin to initialize our IronMQ client and queue objects,
    and will expose helper methods to send and retrieve messages. We will then use
    this plugin in a Play controller that will allow clients to post messages and
    retrieve messages using the HTTP method, `GET`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个 Play 插件来初始化我们的 IronMQ 客户端和队列对象，并公开发送和检索消息的辅助方法。然后，我们将在这个 Play 控制器中使用此插件，允许客户端使用
    HTTP 方法 `GET` 发布和检索消息。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For Java, we need to perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java，我们需要执行以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行 `foo_java` 应用程序：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create an IronMQ account on [http://www.iron.io/](http://www.iron.io/) and create
    an IronMQ project; make a note of your project ID and token
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [http://www.iron.io/](http://www.iron.io/) 上创建 IronMQ 账户并创建 IronMQ 项目；记下您的项目
    ID 和令牌
- en: 'Import the official IronMQ java libraries as app dependencies in `build.sbt`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.sbt` 中将官方 IronMQ Java 库作为应用程序依赖项导入：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the plugins package inside `foo_java/app`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/app` 内创建插件包：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create our plugin class, MQPlugin, in the `foo_java/app/plugins` directory:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_java/app/plugins` 目录中创建我们的插件类，MQPlugin：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Modify `conf/application.conf` and add your IronMQ project ID and token:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `conf/application.conf` 并添加您的 IronMQ 项目 ID 和令牌：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Initialize the MQPlugin by declaring it in the `conf/play.plugins` file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `conf/play.plugins` 文件中声明来初始化 MQPlugin：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a `Messenger` controller class in `app/controllers`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/controllers` 中创建 `Messenger` 控制器类：
- en: '[PRE6]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add new routes for the `Messenger` controller actions:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Messenger` 控制器操作添加新路由：
- en: '[PRE7]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using `curl`, let''s send and retrieve messages:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `curl` 发送和检索消息：
- en: '[PRE8]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the IronMQ Web Console, you can also confirm the queue message size to confirm
    that we were able to post a message:![](img/CiOxgcxa.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IronMQ 网络控制台中，您还可以确认队列消息大小，以确认我们能够发布消息！![图片](img/CiOxgcxa.jpg)
- en: 'For Scala, we need to perform the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Scala，我们需要执行以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行 `foo_scala` 应用程序：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create an IronMQ account on [http://www.iron.io/](http://www.iron.io/) and create
    an IronMQ project; make a note of your project ID and token.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 [http://www.iron.io/](http://www.iron.io/) 上创建 IronMQ 账户并创建 IronMQ 项目；记下您的项目
    ID 和令牌。
- en: 'Import the official IronMQ java libraries as app dependencies in `build.sbt`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.sbt` 中将官方 IronMQ Java 库作为应用程序依赖项导入：
- en: '[PRE10]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create the plugins package in `foo_scala/app`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_scala/app` 中创建插件包：
- en: '[PRE11]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create our plugin class, MQPlugin, in the `foo_scala/app/plugins` directory:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foo_scala/app/plugins` 目录中创建我们的插件类，MQPlugin：
- en: '[PRE12]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Modify `conf/application.conf` and add your IronMQ project ID and token:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `conf/application.conf` 并添加您的 IronMQ 项目 ID 和令牌：
- en: '[PRE13]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Initialize the MQPlugin by declaring it in the `conf/play.plugins` file:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `conf/play.plugins` 文件中声明来初始化 MQPlugin：
- en: '[PRE14]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a `Messenger` controller class in `app/controllers`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/controllers` 中创建 `Messenger` 控制器类：
- en: '[PRE15]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add new routes for the `Messenger` controller actions:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Messenger`控制器动作添加新路由：
- en: '[PRE16]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using `curl`, let''s send and retrieve messages:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`发送和检索消息：
- en: '[PRE17]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the IronMQ Web Console, you can also check the queue message size to confirm
    that we were able to post a message:![](img/CZSpoQpf.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IronMQ Web控制台中，您还可以检查队列消息大小以确认我们能够发布消息：![图片](img/CZSpoQpf.jpg)
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we set up the message queue plugin by first importing the official
    IronMQ Java library to `build.sbt`. We will also need to log in to IronMQ to create
    our IronMQ project and to retrieve our project tokens:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们首先通过将官方IronMQ Java库导入到`build.sbt`中来设置消息队列插件。我们还需要登录IronMQ来创建我们的IronMQ项目和检索我们的项目令牌：
- en: '![](img/RBXJtXDJ.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/RBXJtXDJ.jpg)'
- en: 'We configured the Play application by adding our IronMQ credentials to `conf/application.conf`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将IronMQ凭据添加到`conf/application.conf`来配置Play应用程序：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then implemented the `MQPlugin` class by retrieving the project ID and token
    from the config file and passing that to an instance of `io.iron.ironmq.Client`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过从配置文件中检索项目ID和令牌并将它们传递给`io.iron.ironmq.Client`实例来实现`MQPlugin`类：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We created our dynamic message queue in the `onStart` method as well, passing
    a `UUID` parameter as the default queue name:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`onStart`方法中创建了我们的动态消息队列，并将`UUID`参数作为默认队列名称传递：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then declared the two methods that will facilitate message sending and retrieval:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明了两个将促进消息发送和检索的方法：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We wanted to be able to remove read messages from the queue and run an asynchronous
    function to delete them here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够从队列中删除已读消息并在此处运行一个异步函数来删除它们：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For Java, deleting the message will happen synchronously:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，删除消息将同步发生：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lastly, we implement the endpoints by creating the controller class, `Messenger`,
    which exposes two actions; one for message retrieval and another for messaging
    posting:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过创建控制器类`Messenger`来实现端点，该类公开两个动作；一个用于检索消息，另一个用于发布消息：
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And finally, add the respective routes to `conf/routes`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将相应的路由添加到`conf/routes`：
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Integrating a Play application with ElasticSearch
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Play应用程序与ElasticSearch集成
- en: In this recipe, we will create a very common web application functionality to
    create, index, and search, in our case, products. We will use ElasticSearch as
    our search service. We will use Docker to create our local ElasticSearch container
    and to run all search operations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将创建一个非常常见的Web应用程序功能，用于创建、索引和搜索，在我们的案例中是产品。我们将使用ElasticSearch作为我们的搜索服务。我们将使用Docker创建我们的本地ElasticSearch容器并运行所有搜索操作。
- en: 'A prerequisite for this recipe is having access to an ElasticSearch instance,
    either local or remote, in our recipe, as well as having Docker installed in the
    local development machine:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的先决条件是能够访问ElasticSearch实例，无论是本地还是远程，在我们的配方中，以及在本地的开发机器上安装Docker：
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We used Docker to deploy our local ElasticSearch instance using the command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Docker使用以下命令部署我们的本地ElasticSearch实例：
- en: '[PRE27]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding command instructs `docker` to run the `elasticsearch` container
    as a detached service and that ports `9200` and `9300` in the container should
    be accessible from the corresponding ports in the host.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此前命令指示`docker`以分离服务运行`elasticsearch`容器，并且容器中的端口`9200`和`9300`应可以从主机中的相应端口访问。
- en: We will use an open source Play module, **play2-elasticsearch**, to wrap our
    calls to the ElasticSearch instance. This recipe assumes some familiarity in Docker
    and full-text searching services. More information about play2-elasticsearch can
    be found at [https://github.com/cleverage/play2-elasticsearch](https://github.com/cleverage/play2-elasticsearch).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个开源的Play模块，**play2-elasticsearch**，来包装我们对ElasticSearch实例的调用。此配方假设对Docker和全文搜索服务有一定的了解。有关play2-elasticsearch的更多信息，请参阅[https://github.com/cleverage/play2-elasticsearch](https://github.com/cleverage/play2-elasticsearch)。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information regarding Docker and how to install it, please refer to
    their online documentation at [https://docs.docker.com/installation/](https://docs.docker.com/installation/).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Docker及其安装的更多信息，请参阅他们的在线文档[https://docs.docker.com/installation/](https://docs.docker.com/installation/)。
- en: How to do it…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For Java, we need to perform the following steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要执行以下步骤：
- en: 'First, let''s fire up a local ElasticSearch container using Docker:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用Docker启动一个本地的ElasticSearch容器：
- en: '[PRE28]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用启用热重载的`foo_java`应用程序：
- en: '[PRE29]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the play2-elasticsearch dependency in `build.sbt`. It is important to note
    that as of writing this, support for Play 2.3.x has not been released for play2-elasticsearch,
    hence, the need to exclude dependencies to older Play libraries:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中添加play2-elasticsearch依赖。需要注意的是，截至编写本文时，play2-elasticsearch尚未发布对Play
    2.3.x的支持，因此需要排除旧版Play库的依赖：
- en: '[PRE30]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Declare the play2-elasticsearch plugin in `conf/play.plugins`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`conf/play.plugins`中声明play2-elasticsearch插件：
- en: '[PRE31]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add play2-elasticsearch configuration parameters to `conf/application.conf`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将play2-elasticsearch配置参数添加到`conf/application.conf`：
- en: '[PRE32]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create the product model in `app/models/Product.java`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/models/Product.java`中创建产品模型：
- en: '[PRE33]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, create the products endpoint that will serve the creation and searching
    of products in `app/controllers/Products.java`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`app/controllers/Products.java`中创建将提供产品创建和搜索的产品端点：
- en: '[PRE34]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s also add the `Search` class from the helper class to `app/controllers/Search.java`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也将辅助类中的`Search`类添加到`app/controllers/Search.java`中：
- en: '[PRE35]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, let''s add the routes to the product controller actions to `conf/routes`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将产品控制器操作的路由添加到`conf/routes`中：
- en: '[PRE36]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using `curl`, we can test product creation and indexing as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`，我们可以如下测试产品创建和索引：
- en: '[PRE37]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also use `curl` to execute product searches:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以使用`curl`来执行产品搜索：
- en: '[PRE38]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For Scala, we need to perform the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要执行以下步骤：
- en: 'First, let''s fire up a local ElasticSearch container using Docker:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用Docker启动一个本地的ElasticSearch容器：
- en: '[PRE39]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行`foo_scala`应用程序：
- en: '[PRE40]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the play2-elasticsearch dependency in `build.sbt`. It is important to note
    that as of writing this, support for Play 2.3.x has not been released for play2-elasticsearch,
    hence the need to exclude dependencies from older Play libraries:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中添加play2-elasticsearch依赖。需要注意的是，截至编写本文时，play2-elasticsearch尚未发布对Play
    2.3.x的支持，因此需要排除旧版Play库的依赖：
- en: '[PRE41]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Declare the play2-elasticsearch plugin in `conf/play.plugins`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`conf/play.plugins`中声明play2-elasticsearch插件：
- en: '[PRE42]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add play2-elasticsearch configuration parameters to `conf/application.conf`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将play2-elasticsearch配置参数添加到`conf/application.conf`：
- en: '[PRE43]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create our product model and the `ProductManager` class in `app/models/Product.scala`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/models/Product.scala`中创建我们的产品模型和`ProductManager`类：
- en: '[PRE44]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, create the products endpoint that will serve the creation and searching
    of products in `app/controllers/Products.scala`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`app/controllers/Products.scala`中创建将提供产品创建和搜索的产品端点：
- en: '[PRE45]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, let''s add the routes to the product controller actions to `conf/routes`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将产品控制器操作的路由添加到`conf/routes`中：
- en: '[PRE46]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Using `curl`, we can test product creation and indexing as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`，我们可以如下测试产品创建和索引：
- en: '[PRE47]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can also use `curl` to execute product searches:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以使用`curl`来执行产品搜索：
- en: '[PRE48]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作……
- en: 'In this recipe, we created endpoints for product creation and product search
    utilizing ElasticSearch as the underlying search service. A prerequisite for this
    recipe is having access to an ElasticSearch instance, either local or remote,
    in our recipe, as well as having Docker installed in the local development machine:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们利用ElasticSearch作为底层搜索服务，创建了产品创建和产品搜索的端点。这个菜谱的前提条件是能够访问到ElasticSearch实例，无论是本地还是远程，在我们的菜谱中，以及在本地的开发机器上安装了Docker：
- en: '[PRE49]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We used Docker to deploy our local ElasticSearch instance using the following
    command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令使用Docker部署我们的本地ElasticSearch实例：
- en: '[PRE50]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding command instructs `docker` to run the `elasticsearch` container
    as a detached service and that ports `9200` and `9300` in the container should
    be accessible from the corresponding ports in the host.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令指示`docker`以分离服务的方式运行`elasticsearch`容器，并且容器中的端口`9200`和`9300`应该可以从主机的相应端口访问。
- en: 'We start by importing an open source play module, play2-elasticsearch, by declaring
    it in the `build.sbt` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过在`build.sbt`文件中声明它来导入开源play模块play2-elasticsearch：
- en: '[PRE51]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We activate the plugin in `conf/play.plugins` and specify the configuration
    parameters in `conf/application.conf`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`conf/play.plugins`中激活插件，并在`conf/application.conf`中指定配置参数：
- en: '[PRE52]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then created our product model, extending the play2-elasticsearch class,
    Indexable, and a search manager class, which extends the play2-elasticsearch IndexableManager
    class. We wrote a helper method to execute a multifield query to search the title
    and description fields by keyword:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了我们的产品模型，它扩展了play2-elasticsearch类、Indexable，以及一个搜索管理类，它扩展了play2-elasticsearch的IndexableManager类。我们编写了一个辅助方法来执行多字段查询，通过关键词搜索标题和描述字段：
- en: '[PRE53]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, in our controller class, `Products`, we invoked the appropriate product
    manager methods for the creation and search actions:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的控制器类`Products`中，我们调用了创建和搜索操作的相关产品管理方法：
- en: '[PRE54]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Upon the web application''s start up or reload, you will be able to see logging
    information regarding the initialization of the play2-elasticsearch plugin:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当Web应用程序启动或重新加载时，您将能够看到有关play2-elasticsearch插件初始化的日志信息：
- en: '[PRE55]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Implementing token authentication using JWT
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现使用JWT的令牌认证
- en: In this recipe, we integrate the widely-used user authentication strategy, Token
    authentication, with authenticate requests to protected Play actions and endpoints.
    We will use the open source library, **nimbus-jose-jwt**, by Connect2Id to sign-in
    and verify JWT for successful user logins.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将广泛使用的用户认证策略，令牌认证，与认证请求到受保护的Play操作和端点集成。我们将使用Connect2Id的开源库**nimbus-jose-jwt**来进行登录和验证JWT以成功登录用户。
- en: Subsequent requests to other protected endpoints and actions will now only require
    the JWT to be added to the request header using the authorization header. Signed
    JWTs will, however, have a prescribed expiration date and we will ensure that
    we validate this for each JWT signed request.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的请求到其他受保护的端点和操作现在将仅需要将JWT添加到请求头中的授权头。然而，已签名的JWT将有一个规定的过期日期，我们将确保为每个签名的JWT请求验证这一点。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information about Connect2id and nimbus-jose-jwt can be found here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Connect2id和nimbus-jose-jwt的信息请在此处查看：
- en: '[http://connect2id.com/products/nimbus-jose-jwt](http://connect2id.com/products/nimbus-jose-jwt)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://connect2id.com/products/nimbus-jose-jwt](http://connect2id.com/products/nimbus-jose-jwt)'
- en: 'More information about JWT is available here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JWT的更多信息请在此处查看：
- en: '[http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html)'
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For Java, we need to perform the following steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java，我们需要执行以下步骤：
- en: 'Run the `foo_java` application with Hot-Reloading enabled:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以启用热重载的方式运行`foo_java`应用程序：
- en: '[PRE56]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the `nimbus-jose-jwt` dependency in `build.sbt`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.sbt`中添加`nimbus-jose-jwt`依赖项：
- en: '[PRE57]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Using `activator`, generate a new application secret, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`activator`生成一个新的应用程序密钥，如下所示：
- en: '[PRE58]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add the required configuration parameters to `conf/application.conf` using
    the generated secret from the previous step as the value for `jwt.sharedSecret`.
    As for issuer and audience, based on the JWT spec, the issuer is the principal
    issuing the token and the audience is the intended recipient of the token:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一步生成的密钥作为`jwt.sharedSecret`的值，将所需的配置参数添加到`conf/application.conf`中。至于发行者和受众，根据JWT规范，发行者是签发令牌的实体，而受众是令牌的预期接收者：
- en: '[PRE59]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create the JWT Plugin class in `app/plugins/JWTPlugin.java`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/plugins/JWTPlugin.java`中创建JWT插件类：
- en: '[PRE60]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Initialize the JWT Plugin in `conf/play.plugins`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`conf/play.plugins`中初始化JWT插件：
- en: '[PRE61]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create an action class inheriting from the `Simple Action` class that we will
    use to secure actions with JWT in `app/controllers/JWTSigned.java`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/controllers/JWTSigned.java`中创建一个继承自`Simple Action`类的操作类，我们将使用它来使用JWT保护操作：
- en: '[PRE62]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create our test actions for logging in and token signing, and another action
    to be secured with `JWTSigned` in `app/controllers/Application.java`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/controllers/Application.java`中创建用于登录和令牌签名的测试操作，以及另一个使用`JWTSigned`进行安全保护的操作：
- en: '[PRE63]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We also need to create the `Login` model used during user authentication in
    `app/controllers/Login.java`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在`app/controllers/Login.java`中创建用于用户认证的`Login`模型：
- en: '[PRE64]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we add the necessary entries to `conf/routes` for our new actions:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将必要的条目添加到`conf/routes`中，以支持我们的新操作：
- en: '[PRE65]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Using `curl`, let''s verify that the `/admin` route is gated and secured by
    `JWTSigned`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`验证`/admin`路由是否由`JWTSigned`保护：
- en: '[PRE66]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, let''s sign in and make a note of the returned token in the response
    body:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们登录并注意响应体中返回的令牌：
- en: '[PRE67]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, let''s request the `/admin` route again, but this time, by adding
    the signed token using the authorization header, prefixed with `Bearer`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们再次请求`/admin`路由，但这次，通过在授权头中添加已签名的令牌，前面加上`Bearer`：
- en: '[PRE68]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can also verify that the JWTPlugin handles token expiration correctly by
    running the previous request again after the expiration is set in the token, and
    it should result in something like this:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过在令牌中设置过期时间后再次运行之前的请求来验证JWTPlugin是否正确处理了令牌过期，它应该导致类似以下的结果：
- en: '[PRE69]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For Scala, we need to perform the following steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Scala，我们需要执行以下步骤：
- en: 'Run the `foo_scala` application with Hot-Reloading enabled:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 Hot-Reloading 运行 `foo_scala` 应用程序：
- en: '[PRE70]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add the `nimbus-jose-jwt` dependency to `build.sbt`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `nimbus-jose-jwt` 依赖项添加到 `build.sbt` 文件中：
- en: '[PRE71]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Using `activator`, generate a new application secret as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `activator` 生成新的应用程序密钥，如下所示：
- en: '[PRE72]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Add the required configuration parameters to `conf/application.conf` using
    the generated secret from the previous step as the value for `jwt.sharedSecret`.
    As for the issuer and audience, based on the JWT spec, the issuer is the principal
    issuing the token and audience is the intended recipient of the token:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一步生成的密钥作为 `jwt.sharedSecret` 的值，将所需的配置参数添加到 `conf/application.conf` 文件中。至于发行者和受众，根据
    JWT 规范，发行者是发行令牌的实体，受众是令牌的预期接收者：
- en: '[PRE73]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create the JWT Plugin class in `app/plugins/JWTPlugin.scala`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/plugins/JWTPlugin.scala` 中创建 JWT 插件类：
- en: '[PRE74]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Initialize the JWTPlugin in `conf/play.plugins`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `conf/play.plugins` 中初始化 JWTPlugin：
- en: '[PRE75]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create an `ActionBuilder` class that we will use to secure actions with JWT
    in `app/controllers/JWTSigned.scala`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/controllers/JWTSigned.scala` 中创建一个 `ActionBuilder` 类，我们将使用它来使用 JWT 保护操作：
- en: '[PRE76]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Create test actions for logging in and token signing, and another action to
    be secured with `JWTSigned` in `app/controllers/Application.scala`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/controllers/Application.scala` 中创建用于登录和令牌签名的测试操作，以及另一个需要用 `JWTSigned`
    保护的操作：
- en: '[PRE77]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, we add the necessary entries to `conf/routes` for our new actions:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将必要的条目添加到 `conf/routes` 文件中，以支持我们的新操作：
- en: '[PRE78]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Using `curl`, let''s verify that the `/admin` route is gated and secured by
    `JWTSigned`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `curl` 验证 `/admin` 路由是否由 `JWTSigned` 保护：
- en: '[PRE79]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, let''s sign in and make a note of the returned token in the response
    body:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们登录并记录响应体中返回的令牌：
- en: '[PRE80]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, let''s request the `/admin` route again, but this time, adding the
    signed token using the authorization header, prefixed with `Bearer`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们再次请求 `/admin` 路由，但这次，在授权头中添加已签名的令牌，前缀为 `Bearer`：
- en: '[PRE81]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can also verify that the JWTPlugin handles token expiration correctly by
    running the previous request again after the expiration set in the token, and
    should result in something like this:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以通过在令牌过期后再次运行之前的请求来验证 JWTPlugin 是否正确处理令牌过期，应该得到类似以下的结果：
- en: '[PRE82]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How it works…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we implemented the signing and verification of JWT for the purpose
    of securing Play actions with token authentication.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们实现了 JWT 的签名和验证，目的是使用令牌身份验证来保护 Play 操作。
- en: 'We created a Play plugin, `JWTPlugin`, which will load the configurations from
    the `conf/application.conf` file and also contain method definitions for signing,
    decoding, and verifying JWTs using Connect2id''s nimbus-jose-jwt library:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 Play 插件，`JWTPlugin`，它将从 `conf/application.conf` 文件中加载配置，并包含使用 Connect2id
    的 nimbus-jose-jwt 库进行签名、解码和验证 JWT 的方法定义：
- en: '[PRE83]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the preceding code, you will notice that we are utilizing HMAC using SHA-256
    as the default hash algorithm.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你会注意到我们正在使用 SHA-256 作为默认的哈希算法来利用 HMAC。
- en: 'For Java, add the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java，添加以下代码：
- en: '[PRE84]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'For Scala, add the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Scala，添加以下代码：
- en: '[PRE85]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For signing, we build the Claim Set, which is the standard set of token metadata
    according to the JWT spec: you can refer to the following link:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于签名，我们构建了声明集，这是根据 JWT 规范的标准令牌元数据集：你可以参考以下链接：
- en: '[http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#Claims](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#Claims)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#Claims](http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#Claims)'
- en: 'With the appropriate parameter values and adding the user information as the
    claim subject, we then sign and serialize it to a `String`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的参数值，并将用户信息作为声明主题添加，然后我们对其进行签名并将其序列化为 `String`：
- en: '[PRE86]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To verify, we get the passed token decoded and verified and then proceed to
    verifying parts of the Claim Set. It returns the Boolean value `true` only when
    the token has passed all verification tests:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证，我们获取传递的已解码和验证的令牌，然后继续验证声明集的部分。只有当令牌通过所有验证测试时，它才返回布尔值 `true`：
- en: '[PRE87]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We then created a `Simple Action` / `Action Builder` class that will do the
    actual JWT verification:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个 `Simple Action` / `Action Builder` 类，它将执行实际的 JWT 验证：
- en: '[PRE88]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The preceding code will only invoke the next request block if the token passes
    the verification test. It will return an **Http Status Forbidden** error for unsuccessful
    verifications and an **Http Status Unauthorized** error for requests that do not
    have the authorization header set.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只有在令牌通过验证测试的情况下才会调用下一个请求块。对于验证失败的情况，它将返回一个**Http状态禁止**错误，对于没有设置授权头的请求，则返回一个**Http状态未授权**错误。
- en: 'We are now able to secure Play controller actions using the JWTSigned `ActionBuilder`
    class:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 JWTSigned `ActionBuilder` 类来保护 Play 控制器操作：
- en: '[PRE89]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Finally, what we have is a Play action returning serialized, signed JWTs, and
    an action utilizing the JWTSigned `ActionBuilder` class that secures the action
    from unauthenticated and unauthorized requests:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到的是一个返回序列化、签名 JWT 的 Play 动作，以及一个使用 JWTSigned `ActionBuilder` 类来保护操作免受未经认证和未经授权请求的
    Play 动作：
- en: '[PRE90]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
