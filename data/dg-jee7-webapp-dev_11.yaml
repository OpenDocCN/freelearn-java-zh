- en: Appendix B. From Request to Response
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 从请求到响应
- en: During the job interviews for a software developer role, many people are frequently
    asked to describe how the web actually works behind the scenes. A candidate that
    can explain well the architectural layers of a software application to an interviewer
    may give the impression of a so-called full stack developer. However, it can be
    surprising how many candidates have just plausible knowledge of this topic, especially
    if they purport to work professionally in the digital domain. This appendix provides
    a concise and definitive description of the modern issues. The digital developers
    ought to be able to sketch and effectively document their current working architecture.
    So let's start with HTTP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '在软件开发者角色的职位面试中，许多人经常被要求描述网络背后实际是如何工作的。一个能够向面试官很好地解释软件应用程序架构层的候选人可能会给人留下所谓的全栈开发者的印象。然而，令人惊讶的是，有多少候选人对此主题只有合理的了解，尤其是如果他们声称在数字领域专业工作的话。本附录提供了一个简洁且权威的现代问题描述。数字开发者应该能够绘制并有效地记录他们当前的工作架构。那么，让我们从HTTP开始。 '
- en: HTTP
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP
- en: HTTP is a fundamental stateless protocol designed to transport hypermedia between
    a server and client. HTTP 1.1 supports the fine-grained caching of resources and
    the ability to retain persistent connections and chunked transfer encoding. HTTP
    1.1 was created in 1999 (refer to the superseded RFC [https://tools.ietf.org/html/rfc2068](https://tools.ietf.org/html/rfc2068)).
    To cope with the modern demand and usage patterns, the HTTP now supports the WebSocket
    handshaking and upgrade requests ([https://tools.ietf.org/html/rfc6455](https://tools.ietf.org/html/rfc6455)).
    The next HTTP 2.0 standard will provide the multiplexing of streams over a single
    client server channel. There are exciting possibilities for Java EE 8 (expected
    by May/June 2017) and the HTTP 2.0 support in the Java Servlet 4.0 specification.
    For more details, see RFC 7540 ([http://www.rfc-editor.org/rfc/rfc7540.txt](http://www.rfc-editor.org/rfc/rfc7540.txt))
    and JSR 369 ([https://www.jcp.org/en/jsr/detail?id=369](https://www.jcp.org/en/jsr/detail?id=369)).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一个基本的无状态协议，旨在在服务器和客户端之间传输超媒体。HTTP 1.1支持资源的细粒度缓存和保留持久连接以及分块传输编码的能力。HTTP
    1.1是在1999年创建的（参考已取代的RFC [https://tools.ietf.org/html/rfc2068](https://tools.ietf.org/html/rfc2068)）。为了应对现代需求和用法模式，HTTP现在支持WebSocket握手和升级请求（[https://tools.ietf.org/html/rfc6455](https://tools.ietf.org/html/rfc6455)）。下一个HTTP
    2.0标准将为单个客户端服务器通道提供流的多路复用。对于Java EE 8（预计2017年5/6月发布）和Java Servlet 4.0规范中的HTTP
    2.0支持，这提供了令人兴奋的可能性。有关更多详细信息，请参阅RFC 7540 ([http://www.rfc-editor.org/rfc/rfc7540.txt](http://www.rfc-editor.org/rfc/rfc7540.txt))和JSR
    369 ([https://www.jcp.org/en/jsr/detail?id=369](https://www.jcp.org/en/jsr/detail?id=369))。
- en: An HTTP request
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个HTTP请求
- en: An HTTP request consists of a payload with a header and then body content. The
    header information contains the URI request, HTTP method, agent information, request
    parameters, and cookies. For the POST and PUT requests, it may also contain the
    form encoded properties with names and values.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个HTTP请求由一个带有头部和正文内容的有效载荷组成。头部信息包含URI请求、HTTP方法、代理信息、请求参数和cookies。对于POST和PUT请求，它还可能包含带有名称和值的表单编码属性。
- en: 'The four basic HTTP methods that every digital engineer ought to understand
    are GET, POST, PUT, and DELETE. They are described in the following list:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数字工程师都应该了解的四个基本HTTP方法分别是GET、POST、PUT和DELETE。它们在以下列表中描述：
- en: '**GET**: This request fetches the contents of the resources associated with
    a given URL'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**：这个请求获取与给定URL关联的资源内容'
- en: '**POST**: This creates a brand new resource with a payload (body content) that
    specifies the data for the new resource'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST**：这会创建一个新的资源，其有效载荷（正文内容）指定了新资源的数据'
- en: '**PUT**: This updates an existing resource with a payload that specifies some
    or all of the data that is being replaced'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**：这通过指定被替换的一些或全部数据来更新现有资源'
- en: '**DELETE**: This is a request to delete the specified resource association
    with the URL'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**：这是一个请求，用于删除与URL关联的指定资源关联'
- en: 'The following are the rare HTTP methods that are also used in special circumstances:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在特殊情况下也使用的罕见HTTP方法：
- en: '**HEAD**: This performs an acknowledgement of the resources associated with
    a given URL by just retrieving the headers. This request is similar to the GET
    request but without the body content.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HEAD**：这个请求通过仅检索头部来确认与给定URL关联的资源。这个请求与GET请求类似，但没有正文内容。'
- en: '**OPTION**: This retrieves the application server features or web container
    capabilities.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OPTION**：此操作检索应用服务器功能或Web容器能力。'
- en: '**TRACE**: This request allows the infrastructure to find out the network hops
    between the client and servers and therefore validates the latency, availability,
    and performance.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TRACE**：此请求允许基础设施找出客户端和服务器之间的网络跳数，从而验证延迟、可用性和性能。'
- en: An HTTP response
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP响应
- en: The HTTP response consists of the header information and payload data (the body
    content). The header contains the HTTP status code, MIME type, data length, last
    modified date, character set encoding, cookie parameters, and cache information
    of the resource. The header may also contain the authentication data. The body
    content is the data returned that is the client's request.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应由头部信息和有效载荷数据（即主体内容）组成。头部包含HTTP状态码、MIME类型、数据长度、最后修改日期、字符集编码、cookie参数和资源的缓存信息。头部还可能包含认证数据。主体内容是返回给客户端请求的数据。
- en: The HTTP Status codes are defined by the W3C. These are integer codes with ranges.
    Generally, the status codes 100-199 are informational messages, 200-299 represent
    the successful outcomes, 300-399 represent the redirection requests, 400-499 are
    server side errors, and the 500-599 status codes represent the authentication
    failures. Hence, the HTTP OK 200 and 404 NOT FOUND status codes are well-known
    to developers outside the digital domain. You can find all of them listed in the
    RFC at [http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码由W3C定义。这些是具有范围的整数代码。通常，状态码100-199是信息性消息，200-299表示成功的结果，300-399表示重定向请求，400-499是服务器端错误，500-599状态码表示认证失败。因此，HTTP
    OK 200和404 NOT FOUND状态码对于数字领域外的开发者来说是众所周知的。您可以在RFC中找到所有这些状态码的列表：[http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。
- en: Java Enterprise Architectures
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java企业架构
- en: Applications in the digital domain share a common thread of architecture across
    multiple industrial sector domains. Obviously, they share and rely on the Java
    EE 7 standard platform and JVM in order to piggy-bank the development, various
    nonfunctional attributes, and enterprise application infrastructure. There are
    subtle differences in the building of the applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数字领域的应用在多个工业领域架构上具有共同的主线。显然，它们共享并依赖于Java EE 7标准平台和JVM，以便在开发、各种非功能性属性和企业应用基础设施上“搭便车”。在构建应用方面存在细微的差异。
- en: Standard Java EE web architecture
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准Java EE Web架构
- en: 'The standard Java EE web architecture is derived from the client-server models
    of the 1990s. The application server is the key component as it is responsible
    for three containers in the full Java EE 7 specification: Servlet, CDI, and EJB.
    Generally, we map these containers to the layer tier architecture for a monolithic
    web application. The idea of this architecture is to enhance the best practice
    from the point of view of solid software engineering. We want to maintain a separation
    of the concerns in the layers in order to avoid rigid coupling between layers
    and have a strong cohesion in the layers. The three layers are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Java EE Web架构源于20世纪90年代的客户端-服务器模型。应用服务器是关键组件，因为它负责Java EE 7完整规范中的三个容器：Servlet、CDI和EJB。通常，我们将这些容器映射到单体Web应用的层架构。这种架构的目的是从坚实的软件工程角度提升最佳实践。我们希望保持层之间的关注点分离，以避免层之间的刚性耦合，并在层之间保持强大的内聚性。以下是三个层：
- en: Presentation layer is strongly associated with code that depends and requires
    the Servlet container. FacesServlet is supplied as a part of the JSF. Alternative
    web application frameworks also have the idea of Front Controller that dispatches
    a request to the separate controllers. The presentation tier also contains the
    controllers and view templates.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示层与依赖于Servlet容器的代码紧密相关。FacesServlet作为JSF的一部分提供。替代的Web应用框架也有前端控制器（Front Controller）的概念，它将请求分发给单独的控制器。表示层还包含控制器和视图模板。
- en: Domain layer is associated with code that holds the business logic and projections
    of the persistence objects. It contains the application rules, business logic,
    and business process management. Domain objects may or may not be a part of a
    dependency injection. In most of the modern web applications, almost all the domain
    layer components and objects are a part of a dependency injection container. Therefore,
    domain layer is associated with the CDI container.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域层与包含业务逻辑和持久化对象投影的代码相关联。它包含应用程序规则、业务逻辑和业务流程管理。领域对象可能是也可能不是依赖注入的一部分。在大多数现代Web应用程序中，几乎所有的领域层组件和对象都是依赖注入容器的一部分。因此，领域层与CDI容器相关联。
- en: Integration layer is associated with the transportation of data from the application
    to the durable persistence or service areas of the system. This layer maps to
    a POJO that is a part of the EJB container. Usually, these objects handle the
    service calls from the application. As EJBs, they are transactional and not necessarily
    contextual, which is why they are not a part of the CDI container. These objects
    communicate with an external system like database through JPA and/or JDBC asynchronously
    to the other systems through a message over JMS or they can also synchronously
    (or asynchronously) invoke the remote web service endpoints through the REST or
    SOAP calls.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成层与从应用程序到系统的持久化或服务区域的传输数据相关联。这一层映射到一个EJB容器的一部分的POJO。通常，这些对象处理来自应用程序的服务调用。作为EJB，它们是事务性的，但不一定是上下文相关的，这就是为什么它们不是CDI容器的一部分。这些对象通过JPA和/或JDBC异步与外部系统（如数据库）通信，通过JMS消息与其他系统异步通信；它们也可以通过REST或SOAP调用同步（或异步）调用远程Web服务端点。
- en: 'The following diagram illustrates the architecture:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了架构：
- en: '![Standard Java EE web architecture](img/image00429.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![标准Java EE Web架构](img/image00429.jpeg)'
- en: The standard Java EE web architecture
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Java EE Web架构
- en: Extended architectures
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展架构
- en: From the standard Java web architecture, there are several adaptations. Organizations
    may choose to optimize their architecture in order to suit a particular trade-off.
    A trade-off might be performance versus scalability, which may mean restructuring
    the integration layer in order to use a NoSQL database over a particular RDMS
    solution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从标准的Java Web架构来看，存在几种适配方式。组织可以选择优化其架构以适应特定的权衡。一种权衡可能是性能与可扩展性之间的权衡，这可能意味着为了使用特定的关系型数据库管理系统（RDMS）解决方案而重构集成层以使用NoSQL数据库。
- en: In this section, we will examine availability versus performance for a particular
    customer. Availability is the degree of a system to be accessible. If the system
    is down, then it is not available. Performance is the ability of the system to
    carry out the required functionality in a target timeframe. So, this customer
    is truly interested in the uptime of the system because the downtime will cost
    money, but they also want a fixed quantum of throughput.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查特定客户的可用性与性能。可用性是系统可访问的程度。如果系统关闭，则不可用。性能是系统在目标时间内执行所需功能的能力。因此，这位客户真正关心的是系统的正常运行时间，因为停机时间将造成经济损失，但他们也希望有一个固定的吞吐量量。
- en: Which items can degrade the performance? If the application has too much sanity
    checking in the code (check pointing), then it will degrade the performance. If
    the performance is degraded, then it may also reduce availability. However, if
    you do not perform a sanity check for enough parameters, then a system will be
    culpable to errors. If a hacker finds a weakness in your security or your caseworkers
    enter the wrong data too often, then your availability is compromised because
    your business will suffer downtime to fix issues.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些项目会降低性能？如果应用程序代码中有太多的合理性检查（检查点），那么它将降低性能。如果性能降低，那么它也可能减少可用性。然而，如果您没有对足够的参数进行合理性检查，那么系统将因错误而受到指责。如果黑客发现您的安全漏洞，或者您的案件工作人员频繁输入错误数据，那么您的可用性将受到损害，因为您的业务将因修复问题而遭受停机时间。
- en: One solution is to split the architecture in two computation bunkers. We can
    take advantage of the modern power in smartphones, tablets, and desktop computers
    to render the content on the client side. Therefore, this architecture, suits
    rich clients and other suitable devices with enough GPU power.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是将架构分为两个计算堡垒。我们可以利用智能手机、平板电脑和桌面电脑的现代计算能力在客户端渲染内容。因此，这种架构适合具有足够GPU能力的富客户端和其他合适的设备。
- en: The code that has been sanity-checked and rendered is removed from the server
    side to a large degree. Depending on the architecture, we can use the JavaScript
    framework technologies that rely on **Model View ViewModel** (**MVVM**), which
    is supported by AngularJS. Based on the technology choice, we can use an alternative
    to JSF such as the upcoming Java EE 8 MVC or directly the JAX-RS endpoints. We
    must ensure that correct validation takes places on both the client and server
    sides. We must also design the REST API or other remote invocation between client
    and server to be secure, safe, and idempotent. Note that we still have the features
    such as CDI, EJB, JMS, and JPA available to us on the server side.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 经过合理性检查和渲染的代码在很大程度上从服务器端移除。根据架构的不同，我们可以使用依赖于**模型视图视图模型**（**MVVM**）的JavaScript框架技术，该技术由AngularJS支持。根据技术选择，我们可以使用JSF的替代品，如即将推出的Java
    EE 8 MVC或直接使用JAX-RS端点。我们必须确保客户端和服务器端都进行正确的验证。我们还必须设计安全的、安全的和幂等的REST API或其他客户端与服务器之间的远程调用。请注意，我们仍然在服务器端拥有CDI、EJB、JMS和JPA等特性。
- en: There are benefits in this extended Java EE 7 architecture that help in the
    performance versus scalability trade-off. If we introduce a caching layer of data,
    we will gain the ability to return the data that is mostly derived from static
    references or changes very infrequently or is requested most often. The key benefit
    of caching requests from the smart clients means that response times are minimized.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种扩展的Java EE 7架构中，有一些好处有助于在性能与可伸缩性之间的权衡。如果我们引入数据缓存层，我们将获得返回大多数来自静态引用或很少变化或最常请求的数据的能力。从智能客户端缓存请求的关键好处是响应时间最小化。
- en: Just after Java EE 7 was released in 2013, JCache temporary caching 1.0 final
    JSR 107 ([https://jcp.org/en/jsr/detail?id=107](https://jcp.org/en/jsr/detail?id=107))
    was released, which is now supported by brands such as HazelCast and Terracota.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在2013年Java EE 7发布之后，JCache临时缓存1.0最终JSR 107 ([https://jcp.org/en/jsr/detail?id=107](https://jcp.org/en/jsr/detail?id=107))
    也随之发布，现在它得到了HazelCast和Terracota等品牌的支持。
- en: 'This architecture suits a hybrid form that extends Java EE and goes beyond
    and outside the box of specifications. The Java EE 7 umbrella specification does
    not specify the orchestration of the servers, monitoring of servers or systems,
    deep authorization, and cloud provisioning. Let''s take a look at the following
    figure:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构适合一种混合形式，它扩展了Java EE，并超越了规格的框框。Java EE 7的规范并没有指定服务器的编排、服务或系统的监控、深度授权和云配置。让我们看看下面的图示：
- en: '![Extended architectures](img/image00430.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![扩展架构](img/image00430.jpeg)'
- en: An extended hybrid Java EE architecture that remedies performance versus availability
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一种扩展的混合Java EE架构，用于解决性能与可用性之间的平衡问题
- en: Containerless systems
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无容器系统
- en: There is another architecture that is popular with the leading edge businesses
    that favor continuous deployment and guerilla engineering. This is called containerless
    application, which is actually a misnomer. If we think about it, every entity
    system is contained in some abstract component from the highest level container
    and down to the hardware CPU. The operating system is constrained by the CPU,
    the JVM process is constrained by the operating system, and the application server
    contains the deployed Java EE application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种架构在那些偏好持续部署和游击式工程的前沿企业中很受欢迎。这被称为无容器应用程序，实际上这是一个误称。如果我们仔细思考，每个实体系统都包含在从最高级容器到硬件CPU的某个抽象组件中。操作系统受CPU的限制，JVM进程受操作系统的限制，而应用程序服务器包含部署的Java
    EE应用程序。
- en: Technical architects make trade-offs all the time. They may consider agility
    like time-to-market versus cost, innovation versus affordability, and politically,
    the integration of legacy systems with new technology, such as a containerless
    system. The proper name for the containerless application ought to be embedded
    application controlled server, which accurately describes the architecture. There
    are several Java EE application server providers that allow a standalone Java
    application to spin a fully embedded server from the `static void main()` entry
    point. Vendors such as JBoss's WildFly, Tomitribe's Tom EE, and of course, Oracle's
    GlassFish have nonstandard APIs for embedded execution. Some of the proprietary
    vendor solutions even allow the modular selection of the Java EE abilities in
    the runtime of the embedded server. An architect may thus pick and choose the
    provisioning of the JAX-RS, JSF, CDI, EJB, and JMS modules. A well-balanced and
    proficient developed team is able to circumvent the change management. The team
    operates *under the radar* by writing a Containerless solution instead of being
    told for the 100th time that they are not permitted to upgrade the IBM WebSphere
    7 application server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 技术架构师总是在进行权衡。他们可能会考虑敏捷性如上市时间与成本、创新与可负担性之间的对比，在政治上，则是将遗留系统与新技术的集成，例如无容器系统。无容器应用程序的正确名称应该是嵌入式应用程序控制服务器，这准确地描述了架构。有几个Java
    EE应用程序服务器提供商允许从`static void main()`入口点启动一个完全嵌入的服务器。例如，JBoss的WildFly、Tomitribe的Tom
    EE，以及当然，Oracle的GlassFish都提供了非标准的嵌入式执行API。一些专有供应商解决方案甚至允许在嵌入式服务器的运行时模块化选择Java EE功能。因此，架构师可以选择和选择JAX-RS、JSF、CDI、EJB和JMS模块的提供。一个平衡且熟练的开发团队能够绕过变更管理。该团队通过编写无容器解决方案来“隐秘操作”，而不是第100次被告知他们不允许升级IBM
    WebSphere 7应用程序服务器。
- en: Therefore, embedded servers are popular for the beginning of building the microservices
    architecture across several concerns. Allowing the application to control the
    start up and halting of the embedded servers means that these archetypes play
    well with the modern DevOps movement (Developers/Operations team) and the concepts
    around the automatic configuration management control.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，嵌入式服务器在构建跨多个关注点的微服务架构的初期非常受欢迎。允许应用程序控制嵌入式服务器的启动和停止意味着这些原型与现代DevOps运动（开发者/运维团队）以及自动配置管理控制的概念相得益彰。
- en: The clear disadvantage of the containerless solution is that the building of
    the development tools for the traditional WAR deployment does not understand this
    mode. So, a digital engineer may lose the interactive and fast turnaround of increment
    engineering using a Java EE solution. However, it might be a short-term issue
    as the Java IDE makers are fairly good at picking up trends in engineering. We
    can hope that the Java EE technical leaders, architects, and the wider community
    voice their support for the specification to include a containerless API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 无容器解决方案的明显缺点是，为传统WAR部署构建的开发工具不理解这种模式。因此，数字工程师可能会失去使用Java EE解决方案进行增量工程的交互性和快速迭代。然而，这可能是一个短期问题，因为Java
    IDE制造商在捕捉工程趋势方面相当出色。我们可以希望Java EE技术领导者、架构师和更广泛的社区表达他们对包括无容器API的规范的支持。
- en: 'With an embedded server, engineering teams have the responsibility to ensure
    that the infrastructure is correctly set up. The technical architects gain the
    benefit of precisely controlling the external integration points and this is useful
    for the security, authorization and authentication, monitoring and logging, and
    persistent access. However, going from request to the response is exactly the
    same as in the standard Java web architecture. Let''s have a look at the following
    screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌入式服务器，工程团队有责任确保基础设施正确设置。技术架构师通过精确控制外部集成点获得好处，这对于安全性、授权和身份验证、监控和日志记录以及持久访问很有用。然而，从请求到响应的过程与标准Java
    Web架构完全相同。让我们看看下面的截图：
- en: '![Containerless systems](img/image00431.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![无容器系统](img/image00431.jpeg)'
- en: Containerless Java EE architecture diagram
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无容器Java EE架构图
- en: Although there is no standardization on Java EE 8 for the embedded server application
    architecture, other developers have at least precipitated some innovations in
    order to move the community in this direction. There is the Apache Delta Spike
    CDI Container Control ([https://deltaspike.apache.org/documentation/container-control.html](https://deltaspike.apache.org/documentation/container-control.html))
    that currently provides a cross server library to start and stop the CDI container
    in a standalone Java SE environment. Delta Spike is an award-winning open source
    project that has specialist modules for Bean Validation, CDI, Data, Security,
    and Servlets as well as container management. It is worth keeping an eye on this
    project because some of their innovations have made it to the Java EE 8 standard.
    The `@javax.transactional.Transational` annotation that allows CDI managed beans
    take part in Container Managed Transactions (Java EE 7 and JTA 1.2) was first
    proposed and developed in project Delta Spike.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在嵌入式服务器应用架构方面Java EE 8没有标准化，但其他开发者至少已经推动了一些创新，以便将社区引导到这个方向。有Apache Delta Spike
    CDI容器控制（[https://deltaspike.apache.org/documentation/container-control.html](https://deltaspike.apache.org/documentation/container-control.html)），它目前提供了一个跨服务器库，可以在独立的Java
    SE环境中启动和停止CDI容器。Delta Spike是一个获奖的开源项目，它有专门针对Bean Validation、CDI、数据、安全和Servlets以及容器管理的模块。值得密切关注这个项目，因为其中一些创新已经成为了Java
    EE 8标准的一部分。允许CDI管理豆参与容器管理事务（Java EE 7和JTA 1.2）的`@javax.transactional.Transational`注解最初是在Delta
    Spike项目中提出和开发的。
- en: Microservices
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务
- en: The embedded application controlled server is a gateway to the Java-based microservices
    architecture. These microservices are a style of designing an enterprise architecture
    where each component solves and operates one requirement of the overall system.
    These key drivers are the nonfunctional requirements and can be any combination
    of Availability, Flexibility, Maintainability, Networkability, Performance, Robustness
    and Scalability. Of these, the original requirements for businesses to choose
    this style over the traditional monolithic architecture were Availability and
    Scalability.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式应用控制的服务器是Java微服务架构的入口。这些微服务是一种设计企业架构的风格，其中每个组件解决和操作整个系统的一个需求。这些关键驱动因素是非功能性需求，可以是可用性、灵活性、可维护性、网络性、性能、鲁棒性和可伸缩性的任何组合。在这些中，企业选择这种风格而不是传统单体架构的原始需求是可用性和可伸缩性。
- en: 'Architects see certain advantages in microservices: these components follow
    the UNIX architectural principle of *do one thing and do it well* and the ability
    to chop and change the component at will. The microservices style enables the
    language agnostic communications; therefore, the implementer has the freedom to
    write a component in Java, Groovy, or Scala or even in a non-JVM language such
    as C++. This architecture strongly favors JSON or XML over REST; however, there
    is nothing to stop a software shop from using SOAP and XML. Technically, microservices
    are some of the most exciting digital projects on the planet today; because of
    these investments, some businesses have clear distinct commercial advantages.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师在微服务中看到了某些优势：这些组件遵循UNIX架构原则“只做一件事，做好一件事”以及随意切割和更换组件的能力。微服务风格使得语言无关的通信成为可能；因此，实施者有自由选择在Java、Groovy或Scala中编写组件，甚至可以在非JVM语言如C++中编写。这种架构强烈倾向于JSON或XML而不是REST；然而，没有任何阻止软件店使用SOAP和XML。从技术上讲，微服务是目前地球上一些最激动人心的数字项目之一；由于这些投资，一些企业已经获得了明显的商业优势。
- en: The cost of microservices is the networking complexity that includes payload
    sizes, monitoring (heart-beating), logging, and fault tolerance with redundancy
    management and service routing. There are ancillary costs that business managers
    and stakeholders should be aware of, namely time-to-marketing, training, information
    silos, and of course, change culture.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的成本是网络复杂性，包括有效载荷大小、监控（心跳）、日志记录和容错，以及冗余管理和服务路由。还有一些额外的成本，商业经理和利益相关者应该注意，即市场时间、培训、信息孤岛，当然还有变革文化。
- en: 'As with many movements, there is also a spectrum of effort, ability, and feasibility.
    A business may not necessarily have to give up on the monolith architecture completely,
    especially if scalability and high availability are not a high priority. There
    is certainly a route for the componentized services architecture for the majority
    of the digital business, which takes the best of the monolith—transactions, persistence,
    and configuration—and radically employs as much of the styles of the microservices
    as possible. Therefore, an embedded server dedicated for order management should
    not have code that is relevant to the payment processing in it. Rather, the order
    management component should invoke the payment processing component externally.
    Let''s have a look at the following figure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多运动一样，也存在一个关于努力、能力和可行性的范围。一个企业可能并不一定完全放弃单体架构，尤其是当可扩展性和高可用性不是首要任务时。对于大多数数字业务来说，组件化服务架构确实是一条可行的路线，它吸取了单体架构的最佳部分——事务、持久性和配置——并且尽可能多地采用了微服务风格。因此，专门用于订单管理的嵌入式服务器不应该包含与支付处理相关的代码。相反，订单管理组件应该在外部调用支付处理组件。让我们看看下面的图示：
- en: '![Microservices](img/image00432.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![微服务](img/image00432.jpeg)'
- en: An evolution of a Java EE monolith to a microservices architecture
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE单体架构向微服务架构的演变
- en: The preceding illustration shows a decomposition of the standard Java EE web
    architecture into a hybrid component architecture and then an evolution to a full
    microservice.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述插图显示了标准Java EE Web架构分解为混合组件架构，然后演变为完整的微服务架构。
- en: 'There are many ways to go from the request and then back to the response. In
    addition to where do we go as a team in order to get there? We must ask ourselves
    the key questions: how do we get there? Why do we want to get there?'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从请求到响应的路径有很多种。除了作为一个团队我们应该如何到达那里之外，我们还必须问自己关键问题：我们如何到达那里？我们为什么想要到达那里？
- en: To be full stack or not
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是否要成为全栈开发者
- en: Is it important to be known as a full stack developer? The consultant's typical
    answer is that it always depends on the context. Some cynics might say that the
    term full stack is a loaded marketing term, but then these same people may also
    suggest that digital is likewise. Obviously, there is more meaning to the term
    than the thoughts that are recurring through some poor recruitment consultant's
    brain. There is a lot to be desired for large organizations that claim and advertise
    that they want to recruit only full stack developers. Are they cutting corners?
    Or are they genuinely interested in getting the best programming talent?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为全栈开发者是否重要？顾问的典型回答是这总是取决于上下文。一些愤世嫉俗者可能会说“全栈”是一个充满营销意味的术语，但同样这些人也可能认为数字也是如此。显然，这个术语的含义远不止于一些糟糕的招聘顾问脑海中反复出现的想法。对于声称并宣传他们只想招聘全栈开发者的大型组织来说，还有很多需要改进的地方。他们是走捷径吗？还是他们真正对获得最好的编程人才感兴趣？
- en: That said, from the discussion in this appendix, it is important to know the
    architecture of a project to a certain degree. For a couple of decades already,
    it has been impossible to be a jack of all trades in the software business and
    therefore, an engineer will specialize in a certain environment, field, role,
    or system. It is no longer possible to live completely closeted in an underground
    silo and resolutely say, *all I want to know is Java on the server side because
    it is the only skill that I care about and it will always be that way*. Decent
    professional engineers must be sympathetic to the other staff members including
    front-end developers, back-end developers, interface and UX designers, testers,
    stakeholders, and management. Everyone has an ultimate stakeholder and therefore
    they share the ultimate responsibility with accountability. Whether this means
    full stack or not depends largely on your attitude towards working life and knowing
    about and respecting the modern web architecture around you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，从本附录的讨论中可以看出，了解项目的架构在一定程度上是很重要的。几十年来，在软件行业中成为万事通已经不可能了，因此，工程师将专门从事某个环境、领域、角色或系统。不再可能完全隐藏在地下的小隔间中，坚决地说：“我只想知道服务器端的Java，因为这是我唯一关心的技能，而且它将永远如此”。合格的专业工程师必须对其他团队成员表示同情，包括前端开发者、后端开发者、界面和UX设计师、测试人员、利益相关者和管理层。每个人都有最终的利益相关者，因此他们与利益相关者共享最终责任并承担相应的责任。这到底是全栈还是不是，很大程度上取决于你对工作生活的态度，以及你对周围现代Web架构的了解和尊重。
