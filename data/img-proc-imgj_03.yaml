- en: Chapter 3. Advanced Image Processing with ImageJ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 使用ImageJ的高级图像处理
- en: 'The previous chapter showed you how to load and view images in ImageJ and how
    to make basic alterations to image intensity and pixel values. This chapter will
    deal with the techniques used to preprocess images. We will prepare them for image
    analysis and measurements. This chapter will apply some of the techniques we examined
    in the earlier chapters. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您展示了如何在ImageJ中加载和查看图像，以及如何对图像强度和像素值进行基本修改。本章将讨论预处理图像所使用的技巧。我们将为图像分析和测量做准备。本章将应用我们在前几章中探讨的一些技巧。我们将涵盖以下主题：
- en: Correcting images
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纠正图像
- en: Z-stack processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z栈处理
- en: Time series processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列处理
- en: Image and stack calculations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像和栈计算
- en: Correcting images
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纠正图像
- en: In order to analyze images, we sometimes need to correct the problems that were
    present during acquisition. Problems such as noise, uneven illumination, and background
    fluorescence can cause many issues during image analysis. I will provide a little
    technical background on the sources of these problems and then follow this up
    with how they can be corrected in ImageJ.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析图像，我们有时需要纠正采集过程中出现的问题。例如噪声、不均匀的照明和背景荧光等问题，在图像分析过程中可能会引起许多问题。我将简要介绍这些问题的来源，然后说明如何在ImageJ中纠正这些问题。
- en: Technical background
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术背景
- en: 'Of the many sources of noise that exist in imaging, a few can be corrected
    with correct acquisition settings. Others are inherent in the electronics and
    physical properties of the camera, and cannot be easily fixed. I will first deal
    with the source of noise that can be remedied with optimizing acquisition: **Shot**
    or **Poisson** noise. Next, we will look at **Electronic** or **Dark** noise.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在成像中存在的许多噪声来源中，一些可以通过正确的采集设置来纠正。其他噪声则存在于相机的电子和物理特性中，并且难以修复。我将首先处理可以通过优化采集来修复的噪声来源：**随机**或**泊松**噪声。接下来，我们将探讨**电子**或**暗**噪声。
- en: Correcting Shot noise
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纠正随机噪声
- en: 'Shot noise is caused by the physical properties of light; light can be seen
    as packages of light or photons. The number of photons that are collected by each
    photo-detector site on the camera determines the final pixel intensity. If only
    a few photons hit the detector at any time, the differences in the number of photons
    could be large. This is called a Poisson process, and the signal-to-noise ratio
    can be expressed as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随机噪声是由光的物理特性引起的；光可以被看作是光束或光子。每个相机光电探测器的像素收集到的光子数量决定了最终的像素强度。如果在任何时刻只有少数光子击中探测器，光子数量的差异可能会很大。这被称为泊松过程，信噪比可以表示如下：
- en: '![Correcting Shot noise](img/Insert_image_4909_03_17.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![纠正随机噪声](img/Insert_image_4909_03_17.jpg)'
- en: This means that the **signal-to-noise ratio** (**SNR**) will get larger as the
    number of photons (*N*) increases. By increasing the exposure time or the illumination
    intensity, the number of photons per pixel and the SNR will increase. A low SNR
    cannot be fixed with processing techniques in software.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着随着光子数量（N）的增加，**信噪比**（SNR）将增大。通过增加曝光时间或照明强度，每个像素的光子数量和SNR将增加。低信噪比不能通过软件处理技术来修复。
- en: Correcting dark noise
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纠正暗噪声
- en: 'Another source of noise is called dark noise or dark current. This source of
    noise comes from the electronics in the camera and can be visualized by taking
    an image with the camera without illumination. In digital consumer cameras, exposing
    the image while the lens is completely covered can easily do this. You can even
    try it with the camera of your phone. Just cover the lens tightly and take a picture
    (make sure the flash is disabled!). As an example, the following figure shows
    a small region of an image taken by two different cameras, both with the same
    settings. The left-hand image is a small region of an image taken with a Sony
    α6000 (2014), while the image on the right-hand side is from a Canon EOS 550D
    (2010). The orange bar is there to delineate them:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种噪声来源被称为暗噪声或暗电流。这种噪声来源来自相机中的电子元件，可以通过在不照明的情况下拍摄图像来可视化。在数字消费相机中，当镜头完全覆盖时曝光图像可以轻松实现这一点。您甚至可以用手机的相机尝试。只需紧紧覆盖镜头并拍照（确保闪光灯已关闭！）！例如，以下图显示了由两个不同相机拍摄的一小部分图像，它们的设置相同。左侧图像是使用索尼α6000（2014）拍摄的小区域图像，而右侧图像来自佳能EOS
    550D（2010）。橙色条用来区分它们：
- en: '![Correcting dark noise](img/Insert_image_4909_03_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![纠正暗噪声](img/Insert_image_4909_03_01.jpg)'
- en: 'The intensities of each image were equalized to show the pattern, and only
    the green channel is shown in this example. The settings for both cameras were
    as follows: 1/10sec exposure, ƒ5.6, and ISO 200\. It is clear from these images
    that the noise level from the electronics is quite different between the two camera
    sensors. Note that most scientific cameras, especially cooled **EM-CCD** (**Electron-Multiplying
    CCD**) cameras, have far lower levels of electronic noise. This allows some EM-CCD
    cameras to detect single photons and even count them.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示图案，每个图像的强度都被均衡了，在这个例子中只显示了绿色通道。两个相机的设置如下：1/10秒曝光，ƒ5.6，ISO 200。从这些图像中可以看出，两个相机传感器之间的电子噪声水平相当不同。请注意，大多数科学相机，尤其是冷却的**EM-CCD**（**电子倍增电荷耦合器件**）相机，电子噪声水平要低得多。这使得一些EM-CCD相机能够检测单个光子，甚至计数它们。
- en: In order for the subtraction of the dark noise signal to work, the exposure
    duration needs to be identical to the exposure time during the acquisition to
    get the same level of dark noise. The duration of the exposure is directly linked
    to the amount of noise. A longer exposure results in more dark noise. This type
    of noise can be easily fixed in ImageJ using the image calculator that will be
    introduced a little later in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使暗噪声信号的减法工作，曝光时间需要与获取时的曝光时间相同，以获得相同的暗噪声水平。曝光时间直接与噪声量相关。较长的曝光时间会导致更多的暗噪声。这种噪声可以通过稍后在本章中介绍的图像计算器在ImageJ中轻松修复。
- en: 'To determine the noise level of your own camera, take a picture with the lens
    covered (make sure it is completely blocked from all light). Ideally, you should
    do this with your camera capturing images as RAW files. When a camera acquires
    images as JPEG files, the camera already performs some noise reduction on the
    image. If you can only capture images in JPEG, check to see whether there is an
    option to switch off the noise reduction. Now, open the image in ImageJ, as was
    illustrated in the previous chapter, and follow these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定你自己的相机的噪声水平，用镜头盖住相机拍照（确保它完全被所有光线遮挡）。理想情况下，你应该使用你的相机以RAW文件格式捕获图像。当相机以JPEG文件格式获取图像时，相机已经对图像进行了某些噪声降低处理。如果你只能以JPEG格式捕获图像，请检查是否有选项可以关闭噪声降低。现在，打开图像在ImageJ中，如前一章所述，并按照以下步骤操作：
- en: Select your darkshot image window by clicking on it, making it active. In ImageJ,
    most commands will operate on the active image, or the last opened image. By clicking
    on an image window, that image becomes the active image.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击它来选择你的暗光图像窗口，使其处于活动状态。在ImageJ中，大多数命令将作用于活动图像或最后打开的图像。通过点击一个图像窗口，该图像就变成了活动图像。
- en: In order to determine the noise level, we can select an area that we want to
    measure. We will create a rectangle by specifying it by entering the specific
    values. To do this, go to **Edit** | **Selection** | **Specify…** and select the
    **Centered** checkbox, before entering `512` for the width and height. For the
    **X coordinate** and **Y coordinate**, enter half the width and height of your
    image (indicated in the image subtitle) and click on **OK**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确定噪声水平，我们可以选择一个我们想要测量的区域。通过输入特定的值来指定它，我们将创建一个矩形。为此，转到**编辑** | **选择** | **指定…**，然后选中**居中**复选框，输入`512`作为宽度和高度。对于**X坐标**和**Y坐标**，输入图像宽度的一半和高度的一半（在图像副标题中指示）并点击**确定**。
- en: Make sure that the measurements are set to standard deviation. This can be done
    by going to **Analyze** | **Set Measurements** and selecting the **Standard deviation**
    checkbox. Selecting other parameters for measurement is fine, and in the output
    below **Area**, **Mean gray value** and **Min & max gray value** were also selected.
    For this exercise, the **Standard deviation** option is the only relevant parameter
    that is required.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保测量设置为标准差。这可以通过转到**分析** | **设置测量**并选中**标准差**复选框来完成。选择其他测量参数是可以的，在下面的输出中**面积**、**平均灰度值**和**最小和最大灰度值**也被选中。对于这个练习，**标准差**选项是唯一需要的相关参数。
- en: Perform the measurement by pressing *Ctrl* + *M* or by going to **Analyze**
    | **Measure**. You can measure regions immediately after placing them, or you
    can add them to the **ROI Manager** (see the next chapter for more details) before
    measuring them.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *M*或转到**分析** | **测量**来执行测量。你可以在放置区域后立即测量它们，或者你可以在测量之前将它们添加到**ROI管理器**（下一章将详细介绍）中。
- en: 'The results should now be visible in a new window labeled **Results**. Depending
    on which parameters you selected, the results in this window might deviate from
    the one shown here (I have included area and the minimum and maximum values):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的结果应该在新窗口**结果**中可见。根据你选择的参数，此窗口中的结果可能与这里显示的不同（我包括了区域和最小值和最大值）：
- en: '![Correcting dark noise](img/Insert_image_4909_03_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![校正暗噪声](img/Insert_image_4909_03_02.jpg)'
- en: The first line contains the results from the α6000 camera, and the second line
    contains the results from the EOS 550D camera. The area is identical (*512 x 512
    = 262144 pixels*) for both measurements, but the standard deviation (a measure
    of the noise) is lower for the first camera by a factor of 6.3\. Also, the mean
    of the first camera is closer to 0, as you would expect the value to be when there
    is no light hitting the sensor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含α6000相机的结果，第二行包含EOS 550D相机的结果。两个测量的区域相同（*512 x 512 = 262144像素*），但第一台相机的标准偏差（噪声的度量）比第二台相机低6.3倍。此外，第一台相机的平均值更接近0，正如你所预期的，当没有光线击中传感器时，值应该是这样的。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Cameras can have pixels that no longer work (**dead pixels**). Dead pixels will
    show as black pixels in bright areas and always occur at the same location. The
    opposite can also happen. Very bright pixels in dark areas are called **hot pixels**.
    Hot pixels do not have to occur at the same location every time and are more common
    with very long exposure times. For EMCCD cameras, there is another source of bright
    pixels, which is caused by cosmic rays hitting the image sensor. These events
    are relatively common in long time series, and present themselves as very bright
    regions for only a single frame. The removal of dead and hot pixels follows the
    same methodology as the dark noise removal.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相机可能会有不再工作的像素（**死像素**）。死像素在明亮区域会显示为黑色像素，并且总是出现在相同的位置。相反的情况也可能发生。在暗区域非常明亮的像素被称为**热像素**。热像素不必每次都出现在相同的位置，并且在使用非常长的曝光时间时更为常见。对于EMCCD相机，还有一个导致明亮像素的来源，这是由宇宙射线撞击图像传感器造成的。这些事件在长时间序列中相对常见，表现为仅在一帧中非常明亮的区域。去除死像素和热像素的方法与暗噪声去除相同。
- en: For most type of exposures, these levels of noise are so small that they do
    not cause degradation of your pictures. A picture at the beach with the sun in
    the sky will not require correction. With the enormous amount of light that is
    detected, the electronic noise is drowned out completely. However, one field of
    image acquisition where dark noise is a substantial factor is in the field of
    astrophotography or night-time photography. Whenever long exposures are required
    for image acquisition, the electronic noise becomes a substantial factor that
    can degrade your image.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数曝光类型，这些噪声级别非常小，不会导致你的照片质量下降。海滩上的照片，天空中有太阳，不需要校正。由于检测到的光量巨大，电子噪声被完全淹没。然而，在图像采集领域，暗噪声是一个重要因素的是天体摄影或夜间摄影。每当需要长时间曝光进行图像采集时，电子噪声就会成为一个重要因素，可能会降低你的图像质量。
- en: 'To reduce the effects of sensor noise in low-light conditions, you need to
    change the way you acquire your image slightly: instead of a single exposure,
    you need multiple exposures in quick succession. Some cameras support this automatically,
    using names such as handheld twilight (Sony) or multi-frame noise reduction (Pentax,
    Olympus etc.). In this mode you take 2 or more pictures in rapid succession and
    the final image is an average of the series of images. You can also do something
    like this in ImageJ by using the following procedure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少低光条件下传感器噪声的影响，你需要稍微改变你获取图像的方式：不是单次曝光，而是需要连续多次曝光。一些相机支持这种自动模式，例如手持黄昏模式（索尼）或多帧降噪模式（宾得、奥林巴斯等）。在此模式下，你将快速连续拍摄2张或多张照片，最终图像是这些图像的平均值。你还可以在ImageJ中使用以下步骤进行类似操作：
- en: Open the multiple images that you acquired in succession (make sure there are
    no other images opened!)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你连续获取的多张图像（确保没有其他图像打开！）
- en: Select **Image** | **Stacks** | **Images to Stack** from the menu. You will
    now have a single window where every slice represents one image that you took.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**图像** | **堆栈** | **图像堆栈**。现在你将有一个单独的窗口，其中每个切片代表你拍摄的一张图像。
- en: Create the noise-reduction image by selecting **Image** | **Stacks** | **Z Project…**
    from the menu and use Average Intensity as the projection type.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从菜单中选择**图像** | **堆栈** | **Z投影…**来创建降噪图像，并使用平均强度作为投影类型。
- en: 'A thing to keep in mind is the following: when anything moves between the individual
    exposures, this method will not provide good results. It is possible to correct
    for simple shifts, but this only works in the simplest of cases.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是：当任何东西在个别曝光之间移动时，这种方法将不会提供良好的结果。它可以纠正简单的位移，但这仅在最简单的情况下有效。
- en: Uneven illumination – background subtraction
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不均匀照明 – 背景减法
- en: When an image is acquired under difficult lighting conditions, it can sometimes
    occur that the illumination is not even across the image sensor. This effect of
    uneven illumination is something that can easily be corrected in ImageJ. To show
    how this is done, we will take an image acquired with brightfield illumination
    on an inverted microscope using **Differential Interference Contrast** (**DIC**)
    optics.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当在困难的光照条件下获取图像时，有时可能会出现图像传感器上的照明不均匀。这种不均匀照明的效果是可以在ImageJ中轻松纠正的。为了展示如何进行这一操作，我们将使用带有**微分干涉对比度**（**DIC**）光学系统的倒置显微镜获取的明场照明图像。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: DIC images provide contrast by looking at the difference in thickness of your
    specimen. A single light wave is split into two separate rays that are slightly
    separated but parallel and with the same phase. When one ray goes through an object
    with higher density than the parallel ray, the waves will shift out of phase.
    When they are recombined, the out-of-phase rays will partially cancel each other
    out (interference). This results in less light on the camera pixel, making the
    pixel darker. For cells, the strongest interference can be found close to the
    membrane of the cell. One ray will pass through the cell, while the parallel ray
    will pass through the water outside the cell.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DIC图像通过观察样品厚度的差异来提供对比度。一束光波被分成两束稍微分离但平行且具有相同相位的单独光束。当一束光通过比平行光束密度更高的物体时，波将移出相位。当它们重新组合时，出相位的射线将部分相互抵消（干涉）。这导致相机像素上的光减少，使像素变暗。对于细胞，最强的干涉可以在细胞膜附近找到。一束光将穿过细胞，而平行光束将穿过细胞外的水。
- en: 'The image shows the effect of uneven illumination. The left-hand side of the
    frame is darker than the middle, and the gradient runs along the frame in a slightly
    diagonal direction. It is also clear that the field is not going in one direction.
    The middle is the brightest and the two edges, left and right, are darker:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该图像显示了不均匀照明的影响。画框的左侧比中间暗，梯度沿着画框以略微斜向的方向运行。很明显，场域不是向一个方向移动。中间是最亮的，而两个边缘，左侧和右侧，则较暗：
- en: '![Uneven illumination – background subtraction](img/Insert_image_4909_03_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![不均匀照明 – 背景减法](img/Insert_image_4909_03_03.jpg)'
- en: 'As a first attempt, we will use the background subtraction method to see whether
    this will fix the problem. To do so, we need to go to **Process** | **Subtract
    Background…** and use the following settings:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一次尝试，我们将使用背景减法方法来查看这能否解决问题。为此，我们需要进入**处理** | **减去背景…**并使用以下设置：
- en: '![Uneven illumination – background subtraction](img/Insert_image_4909_03_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![不均匀照明 – 背景减法](img/Insert_image_4909_03_04.jpg)'
- en: 'After applying the background subtraction, the image is altered, but the effect
    of the uneven background is still not fixed. The image is actually a little darker
    on the left-bottom side, and also the middle did not decrease in intensity that
    much (see the left-hand-side image). Note that when the **Light background** option
    was selected (see the right-hand-side image), there is a strong over compensation
    on both the left and right-hand sides. Not only is the contrast reduced on those
    sides, but also the illumination is now more uneven than it was before the correction:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用背景减法后，图像发生了变化，但背景不均匀的效果仍未得到纠正。实际上，图像的左下角稍微暗一些，而且中间的强度也没有减少很多（参见左侧图像）。请注意，当选择了**光背景**选项（参见右侧图像）时，左右两侧都有强烈的过度补偿。不仅这些侧面的对比度降低了，而且照明现在比校正前更加不均匀：
- en: '![Uneven illumination – background subtraction](img/Insert_image_4909_03_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![不均匀照明 – 背景减法](img/Insert_image_4909_03_05.jpg)'
- en: 'Disabling the **Sliding paraboloid** option also caused artifacts that were
    even more artificial and incorrect. The problem with this type of background subtraction
    is that it assumes a homogeneously decreasing change in background. This means
    that the changes in background should be smooth and go from high to low in a single
    direction (left to right, diagonal, and so on.). However, DIC images such as this
    one have a tendency to have a background that has more of a U-shape: high at the
    edges and low in the middle, or vice versa. Therefore, this method is unsuitable
    for this type of image, and other methods need to be explored to fix this problem.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用**滑动抛物面**选项也导致了更加不自然和错误的伪影。这种类型背景减法的问题在于它假设背景有一个均匀递减的变化。这意味着背景的变化应该是平滑的，并且从高到低在一个方向上（例如从左到右、对角线等）进行。然而，像这样的DIC图像往往有一个更类似于U形的背景：边缘高而中间低，或者相反。因此，这种方法不适用于这种类型的图像，需要探索其他方法来解决这个问题。
- en: 'Next, we will try to eliminate the background using a method called pseudo-flatfield
    correction. This method is based on filtering the image using a Gaussian filter
    that blurs the details. This filter will capture the uneven illumination and separate
    it from the objects in the frame. The basis of how these filters work will be
    discussed in the next chapter in more detail. Let''s create the background image
    that we will use to correct the uneven illumination. You need to perform the following
    steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试使用伪平面场校正法来消除背景。这种方法基于使用高斯滤波器对图像进行过滤，该滤波器会模糊细节。这个过滤器将捕捉到不均匀的照明并将其从帧中的物体中分离出来。这些过滤器如何工作的基础将在下一章中更详细地讨论。让我们创建一个背景图像，我们将用它来校正不均匀的照明。你需要执行以下步骤：
- en: First, we want to duplicate the image so that we keep the original image for
    subtraction. To do so, we will go to **Image** | **Duplicate…** or use *Ctrl*
    + *Shift* + *D* and name the duplicate image `background`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们想要复制图像，以便保留原始图像用于减法。为此，我们将转到**图像** | **复制…**或使用*Ctrl* + *Shift* + *D*，并将复制的图像命名为`background`。
- en: To create a Gaussian low-pass filter, we will select the background image and
    go to **Process | Filters | Gaussian Blur…**, entering a value of `150` for the
    sigma (radius). When you check the preview checkbox, you will see that the image
    will look like it is defocused. You can see that the objects can no longer be
    distinguished, and what is left is the diagonal background illumination.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建高斯低通滤波器，我们将选择背景图像并转到**处理 | 滤镜 | 高斯模糊…**，为sigma（半径）输入`150`的值。当你勾选预览复选框时，你会看到图像看起来像是失焦的。你可以看到物体已经无法区分，剩下的只是对角线背景照明。
- en: We can now subtract this background from the original image to correct the uneven
    illumination. To do this, we will start the image calculator by going to **Process**
    | **Image Calculator…** from the menu. Then, we will select the original image
    as **Image1** and the background image as **Image2**. Set the operation to **Subtract**
    and check the **Create new window** and **32-bit (float) result** checkboxes.
    The following image shows the effect of the subtraction and how it corrected the
    uneven illumination:![Uneven illumination – background subtraction](img/Insert_image_4909_03_06.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从原始图像中减去这个背景来校正不均匀的照明。为此，我们将通过从菜单中选择**处理** | **图像计算器…**来启动图像计算器。然后，我们将原始图像选为**Image1**，背景图像选为**Image2**。将操作设置为**减去**，并勾选**创建新窗口**和**32位（浮点）结果**复选框。以下图像显示了减法的效果以及它是如何校正不均匀照明的：![不均匀照明
    – 背景减法](img/Insert_image_4909_03_06.jpg)
- en: Image normalization
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像归一化
- en: 'To enhance the contrast of an underexposed image, you can go to **Process |
    Enhance Contrast…** option, and select the **Normalize** checkbox. This stretches
    the gray values over the entire range of an 8-bit or 16-bit image. It does not
    work on RGB images. The following image shows the effect of the normalization,
    with the original image on the left-hand side and the normalized image on the
    right-hand side:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要增强曝光不足的图像的对比度，你可以转到**处理 | 增强对比度…**选项，并选择**归一化**复选框。这将在整个8位或16位图像的范围内拉伸灰度值。它不适用于RGB图像。以下图像显示了归一化的效果，原始图像在左侧，归一化图像在右侧：
- en: '![Image normalization](img/Insert_image_4909_03_07.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图像归一化](img/Insert_image_4909_03_07.jpg)'
- en: This also works for stacks or time series, where the normalization can be done
    for each frame separately. A similar effect can be obtained using the **Auto**
    option in the **Brightness/Contrast** window, as described in the previous chapter.
    Note that the normalization is applied to the image and modifies the pixel values
    irreversibly. If the signal should not change over time, this should not pose
    a big problem for measurements. However, for intensity changes over time, this
    method will distort or remove the changes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于堆叠或时间序列，其中可以对每个帧分别进行归一化。使用**亮度/对比度**窗口中的**自动**选项可以获得类似的效果，如前一章所述。请注意，归一化应用于图像并不可逆地修改像素值。如果信号不应随时间变化，这不会对测量造成大问题。然而，对于随时间变化的强度变化，这种方法将扭曲或去除这些变化。
- en: Bleach correction
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漂白校正
- en: 'When imaging fluorescence, the illumination can cause the bleaching of the
    fluorophore under investigation. This effect is well established and is related
    to the intensity of the excitation light. To avoid this effect, it is better to
    use a long exposure with low intensity light. However, this may not always be
    possible. The amount of bleaching is related to the intensity at the beginning
    and decreases in an exponential fashion. To see whether an image series is affected
    by bleaching, we can make a quick measurement on the entire image for each frame
    to see what the mean intensity is. Note that if there are changes in illumination
    or background signal in individual frames, the results might not look like a smooth
    curve. To make a quick measurement, press *Ctrl* + *A* to select the entire frame
    and then press *Ctrl* + *M* to measure the intensity. Repeat the measurement for
    each frame and plot the mean intensity values against the frame number (or time,
    if you know the interval) in your favorite graphics program. In this case, I used
    **MATLAB** to create the plot, although you could also create the plot by selecting
    **Image** | **Stacks** | **Plot Z-axis Profile** from the menu in ImageJ. Here
    is an example of a bleaching curve:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在成像荧光时，照明可能会引起研究中的荧光素的漂白。这种效应已经得到很好的建立，并且与激发光的强度有关。为了避免这种效应，最好使用长时间曝光和低强度光。然而，这并不总是可能的。漂白的量与初始强度有关，并以指数方式减少。为了判断图像序列是否受到漂白的影响，我们可以对每个帧的整个图像进行快速测量，以查看平均强度。请注意，如果单个帧中存在照明或背景信号的变化，结果可能看起来不是一个平滑的曲线。为了快速测量，请按*Ctrl*
    + *A*选择整个帧，然后按*Ctrl* + *M*测量强度。对每个帧重复测量，并在您喜欢的图形程序中将平均强度值与帧号（或如果您知道间隔，则为时间）绘制成图。在这种情况下，我使用了**MATLAB**来创建图表，尽管您也可以通过从ImageJ的菜单中选择**图像**
    | **堆叠** | **绘制Z轴轮廓**来创建图表。以下是一个漂白曲线的示例：
- en: '![Bleach correction](img/Insert_image_4909_03_08.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![漂白校正](img/Insert_image_4909_03_08.jpg)'
- en: This collection of points seems to follow a trend that is close to either a
    straight line or an exponential curve, although the trend in the first 2 seconds
    seems more exponential than linear.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这组数据点似乎遵循一个接近直线或指数曲线的趋势，尽管前2秒的趋势似乎更接近指数而非线性。
- en: 'In order to perform bleach correction, you can select the correction plugin
    in Fiji by going to **Image** | **Adjust** | **Bleach Correction**. There are
    three methods for correction:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行漂白校正，您可以通过在Fiji中选择**图像** | **调整** | **漂白校正**来选择校正插件。漂白校正有三种方法：
- en: Simple ratio
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单比例
- en: Exponential fit
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数拟合
- en: Histogram matching
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直方图匹配
- en: Simple ratio is the best method if the decrease in intensity does not follow
    a regular shape, such as an exponential decay function. For most fluorescence
    imaging, this method yields good results and can be combined with fluorescence
    measurements. The histogram matching method performs better with noisy images,
    but is less suitable for intensity measurements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果强度的减少不遵循规则形状，例如指数衰减函数，那么简单比例是最好的方法。对于大多数荧光成像，这种方法可以得到良好的结果，并且可以与荧光测量相结合。直方图匹配方法在噪声图像上表现更好，但不太适合强度测量。
- en: 'Since our trend looked more like an exponential decay model, we selected the
    second method, which fits a single exponential function to the data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的趋势看起来更像是指数衰减模型，我们选择了第二种方法，即对数据进行单指数函数拟合：
- en: '![Bleach correction](img/Insert_image_4909_03_09.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![漂白校正](img/Insert_image_4909_03_09.jpg)'
- en: 'This plot was generated using the parameters obtained by the **bleach correction**
    command and entering them in MATLAB. The ImageJ command itself also generates
    a plot with the data and the fitted curve. However, the axes are labeled *X* and
    *Y*. So, for the purpose of clarity, I have recreated the plot with the correct
    labels. The red line indicates the fitted function, which matches the curve with
    an R² value of .9954 (a very good fit). The model consists of three parameters,
    labeled *a*, *b*, and *c*. The value of *a* indicates how much above the asymptote,
    indicated by the *c* value, the first point lies. The asymptote is the value to
    which this exponential curve will go when given infinite time. The value of *b*
    indicates the rate at which the curve decays. If you want to know the time it
    takes to lose half of the initial fluorescence, you can use the following formula,
    using the *b* value from the fitting:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此图是使用**漂白校正**命令获得的参数生成的，并将它们输入MATLAB中。ImageJ命令本身也会生成带有数据和拟合曲线的图表。然而，轴被标记为*X*和*Y*。因此，为了清晰起见，我已重新创建了带有正确标签的图表。红色线表示拟合函数，它与曲线匹配，R²值为.9954（一个非常好的拟合）。该模型由三个参数组成，标记为*a*、*b*和*c*。*a*的值表示第一个点位于由*c*值指示的渐近线之上的程度。渐近线是这个指数曲线在给定无限时间时将趋近的值。*b*的值表示曲线衰减的速度。如果您想知道失去初始荧光一半所需的时间，您可以使用以下公式，使用拟合中的*b*值：
- en: '![Bleach correction](img/Insert_image_4909_03_18.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![漂白校正](img/Insert_image_4909_03_18.jpg)'
- en: The preceding formula gives you the half-time of the fluorescence loss. Note
    that the *b* parameter for the fit is expressed in frames and not time. So, when
    using the preceding formula, you need to multiply the result with your frame interval
    to get the value in seconds (or minutes). In the graph shown earlier, the half-time
    is 30.587 seconds (using the formula with a *b* value of 0.0028327 and a frame
    interval of 0.125 seconds).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的公式给出了荧光衰减的半衰期。请注意，拟合的*b*参数是以帧为单位表示的，而不是时间。因此，在使用前面的公式时，您需要将结果乘以您的帧间隔以获得以秒（或分钟）为单位的价值。在前面显示的图表中，半衰期为30.587秒（使用*b*值为0.0028327和帧间隔为0.125秒的公式）。
- en: Stack processing
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈处理
- en: 'ImageJ is very suitable to process information that has more than two dimensions:
    data acquired at different Z-levels or at different time points. We have already
    seen an example of stack processing in the section on noise correction. The next
    section will deal with time series consisting of frames. However, first, we will
    explore more options when dealing with image stacks containing slices (Z-stacks).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ImageJ非常适合处理具有超过两个维度的信息：在不同Z层或不同时间点获取的数据。我们已经在噪声校正部分的示例中看到了堆栈处理的例子。下一节将处理由帧组成的时序。然而，首先，我们将探索处理包含切片（Z堆栈）的图像堆栈时更多的选项。
- en: Processing Z-stacks
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理Z堆栈
- en: Z-stacks are series of 2D images that were acquired at different heights or
    distances. In a microscope, this is done by moving the objective or the stage
    up or down and acquiring an image at specific intervals. In **Magnetic** **Resonance
    Imaging** (**MRI**), this is done by moving the patient through the center of
    the scanner. The scanner then creates an image for each position using radio pulses
    that create fluctuations in the magnetic field. These fluctuations can be measured
    by the detector in an MRI machine. This results in a single slice that can be
    combined into a single file. Some of the processing that you may want to perform
    on this type of image involves creating projections or 3D renders of the volume.
    We will first examine the projections that you can create. Then, you will understand
    why you would create them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Z堆栈是在不同高度或距离处获取的一系列二维图像。在显微镜中，这是通过上下移动物镜或载物台并在特定间隔获取图像来实现的。在**磁共振成像**（**MRI**）中，这是通过将患者通过扫描仪中心移动来实现的。扫描仪然后使用产生磁场波动的无线电脉冲为每个位置创建图像。这些波动可以通过MRI机器中的探测器来测量。这导致一个可以组合成单个文件的单一切片。您可能想要对这类图像执行的一些处理包括创建体积的投影或3D渲染。我们首先将检查您可以创建的投影。然后，您将理解为什么您会创建它们。
- en: Stack projections
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈投影
- en: We have already seen an example of a Z-projection in the section on noise cancellation.
    In the previous section, we used the projection to create an average intensity
    for each pixel over the frames. For images that contain slices (Z-information),
    an average projection is usually not the most useful projection. However, there
    are other Z-projections available in ImageJ that are more applicable for Z-stacks.
    The following sections will deal with some examples of these projections.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在噪声消除部分的章节中看到了Z投影的一个例子。在前一节中，我们使用投影为每个像素的帧创建平均强度。对于包含切片（Z信息）的图像，平均投影通常不是最有用的投影。然而，ImageJ中还有其他适用于Z堆栈的Z投影。以下几节将处理这些投影的一些示例。
- en: Maximum projection
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最大投影
- en: 'A maximum projection uses the maximum intensity of each pixel across the slices.
    If a stack has 20 slices, then each pixel will contain the maximum value across
    the 20 slices. This type of projection can be helpful to reduce the third dimension
    of a Z-stack in order to create a two-dimensional representation of the data.
    This type of projection essentially flattens the image. When used on fluorescence
    images with sparse signal (few bright pixels) at the same location, this projection
    has the effect of showing all the objects in a single frame. It is also useful
    for fluorescent images that have thin objects that are in focus in different slices
    at different positions. By flattening the Z-stack, all the in-focus parts will
    be visible in one continuous shape. You can visualize this as a flight of stairs.
    Each step has a different Z-position, but if you would flatten the steps (assuming
    that the steps do not overlap), you would get a rectangular board. If you have
    an image that is not sparse, then this projection would be of little use. To demonstrate
    this projection, open the **Confocal Series** image from the sample images. Go
    to **Image** | **Stacks** | **Z Project…** and choose **Max Intensity** as the
    projection type. The following image shows the result of this projection:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最大投影使用每个像素在切片中的最大强度。如果一个堆栈有20个切片，那么每个像素将包含这20个切片中的最大值。这种类型的投影有助于减少Z堆栈的第三维度，以便创建数据的二维表示。这种投影本质上会平坦化图像。当用于具有稀疏信号（在同一位置少量明亮像素）的荧光图像时，这种投影的效果是显示单个帧中的所有物体。它也适用于具有薄物体且在不同切片的不同位置聚焦的荧光图像。通过平坦化Z堆栈，所有聚焦的部分将在一个连续的形状中可见。你可以将此想象为一组楼梯。每个台阶有不同的Z位置，但如果你将台阶平坦化（假设台阶不重叠），你会得到一块矩形板。如果你有一个非稀疏的图像，那么这种投影就几乎没有用处。为了演示这种投影，请从样本图像中打开**共聚焦系列**图像。转到**图像**
    | **堆栈** | **Z投影…**并选择**最大强度**作为投影类型。以下图像显示了这种投影的结果：
- en: '![Maximum projection](img/Insert_image_4909_03_10.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![最大投影](img/Insert_image_4909_03_10.jpg)'
- en: As is visible in the preceding image, the maximum intensity projection shows
    the entire shape of the cell, but some information was lost. Specifically, the
    small details in the first frames are drowned out by the intense pixels from the
    middle of the volume. For some representations, this is fine. For some Z-stacks,
    the rough shape of the total volume is unclear in the individual slices, but the
    maximum projection shows the general shape.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，最大强度投影显示了整个细胞的形状，但一些信息丢失了。具体来说，第一帧中的小细节被体积中间的强烈像素淹没。对于某些表示，这是可以的。对于某些Z堆栈，单个切片中总体积的粗略形状不清楚，但最大投影显示了总体形状。
- en: 'To demonstrate this effect, we will open the **Bat Cochlea Volume** image by
    going to **File** | **Open Samples**. Looking at a few slices from this volume
    gives very little information about the shape of this sensory organ (the numbers
    indicate the slice number):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这种效果，我们将通过转到**文件** | **打开样本**打开**蝙蝠耳蜗体积**图像。查看这个体积的几个切片几乎无法提供有关这个感觉器官（数字表示切片编号）的形状信息：
- en: '![Maximum projection](img/Insert_image_4909_03_11.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![最大投影](img/Insert_image_4909_03_11.jpg)'
- en: 'When we create a maximum intensity projection, the general shape of this organ
    becomes much more obvious: it is shaped like a twisted spiral (the cochlea is
    the shell-shaped cavity that is used for hearing). When you also open the **Bat
    Cochlea Renderings** image by going to **File** | **Open Samples**, you see the
    3D rendering of the volume:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建最大强度投影时，这个器官的一般形状变得更加明显：它呈扭曲螺旋状（耳蜗是用于听力的壳形腔室）。当你通过转到**文件** | **打开样本**打开**蝙蝠耳蜗渲染**图像时，你会看到体积的3D渲染：
- en: '![Maximum projection](img/Insert_image_4909_03_12.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![最大投影](img/Insert_image_4909_03_12.jpg)'
- en: The image on the left-hand side shows the maximum projection of the Z-stack,
    while the images on the right-hand side show the rendered volumes. From this image,
    it is clear that the maximum projection provides more information than the individual
    slices. However, some of the details are still lost in the process. In particular
    the top-left part of the cochlea is very unclear in the maximum projection. The
    start of the spiral is obscured because of the loop behind it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的图像显示了Z堆栈的最大投影，而右侧的图像显示了渲染的体积。从这个图像中可以看出，最大投影比单个切片提供了更多信息。然而，在处理过程中，一些细节仍然丢失。特别是耳蜗的左上部分在最大投影中非常不清楚。螺旋的开始被它后面的环所遮挡。
- en: 'Fiji has an option that allows you to create a maximum projection that contains
    more information: depth coding. Depth coding assigns a color to the Z-location
    of a pixel, resulting in different colors for different slices. To do so in Fiji,
    go to **Image** | **Hyperstacks** | **Temporal-Color Code** and select **Grays**
    for the LUT. This results in the middle representation in the preceding image
    (not exactly, but very similar). Note that you will get a message that the slices
    and frames were swapped. This is done because this plugin is designed for time
    series and not Z-stacks. The right image in the preceding figure is a 3D rendering
    of the volume, which will be covered in the next section.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Fiji有一个选项允许你创建包含更多信息的最投影：深度编码。深度编码将颜色分配给像素的Z位置，导致不同切片有不同的颜色。要在Fiji中这样做，转到**图像**
    | **超堆栈** | **时间-颜色编码**，并选择**灰度**作为LUT。这会导致前一张图像中的中间表示（不是完全一样，但非常相似）。请注意，你会收到一个消息，切片和帧已被交换。这是由于这个插件是为时间序列设计的，而不是Z堆栈。前一张图中的右图是体积的3D渲染，将在下一节中介绍。
- en: Volume viewing and rendering
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 体积查看和渲染
- en: 'When images are acquired over a range of depths, the goal is usually to view
    this collection of images as a 3D volume. Another useful viewing aspect is to
    take a 3-dimensional volume, cut it along the *z* axis, and view the volume from
    the side. This latter view cannot be obtained from the two-dimensional images.
    For this example, we will use two different stacks from the sample images. Let''s
    start with viewing the volume of an MRI stack. To open the image, go to **File**
    | **Open Samples** and select **MRI stack**. This is an MRI stack where every
    slice is at a different level through the head (the numbers indicate the slice
    number):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当在深度范围内获取图像时，通常的目标是将这些图像集合作为3D体积查看。另一个有用的查看方面是取一个三维体积，沿着z轴切割，并从侧面查看体积。这种后视图不能从二维图像中获得。对于这个例子，我们将使用样本图像的两个不同的堆栈。让我们从查看MRI堆栈的体积开始。要打开图像，转到**文件**
    | **打开样本**并选择**MRI堆栈**。这是一个MRI堆栈，其中每个切片都位于头部不同水平（数字表示切片号）：
- en: '![Volume viewing and rendering](img/Insert_image_4909_03_13.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![体积查看和渲染](img/Insert_image_4909_03_13.jpg)'
- en: The eyes are clearly visible in slice number 6 as two dark orbs on the top of
    the image. Slice 11 shows the brain within the skull, and frame 16 shows the ventricles
    as black holes in the middle of the head. Slice 26 shows the top of the head.
    The area is much smaller indicating that the crown of the head is being reached.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在切片6中，眼睛清晰可见，图像顶部有两个暗色的球体。切片11显示了头骨内的脑部，而帧16显示了头部中间的黑洞，即脑室。切片26显示了头顶。该区域较小，表明头部顶部正在接近。
- en: 'A lot of information is already present in the slices. The eyes can clearly
    be seen, as well as the sinuses and the nose (slice 1). The information in these
    slices is not complete, however. We lack shape along the *z* axis. To view the
    three-dimensional shape of this volume, we can use a viewer that comes with Fiji.
    Go to **Plugins** | **Volume Viewer** with the MRI stack selected. If you have
    the standard ImageJ, the **Volume Viewer** plugin can be downloaded and installed
    from the plugins page. Then, the following window will open:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 切片中已经包含了很多信息。眼睛、鼻窦和鼻子（切片1）都可以清晰地看到。然而，这些切片中的信息并不完整。我们在z轴方向上缺少形状。要查看这个体积的三维形状，我们可以使用Fiji附带的三维查看器。选择MRI堆栈后，转到**插件**
    | **体积查看器**。如果你有标准的ImageJ，可以从插件页面下载并安装**体积查看器**插件。然后，将打开以下窗口：
- en: '![Volume viewing and rendering](img/Insert_image_4909_03_14.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![体积查看和渲染](img/Insert_image_4909_03_14.jpg)'
- en: 'This is **Volume** **Viewer**, which is included in Fiji and available as a
    plugin for ImageJ. On the left-hand side, there are three images that show different
    views of the volume: an **xy** slice (this is the top view for this stack), a
    **yz** slice (this is a side view for this stack), and finally, an **xz** slice
    (this is a front view for this stack). The large image in the middle of the viewer
    is the current selected view, in this case, the *xz* slice view. The position
    of this slice is indicated in the overview images on the left-hand side by the
    cyan (*xy*) and green (**yz**) lines. Note that I adjusted the **z-Aspect** by
    entering `5` and pressing *Enter* instead of the value of `1` based on the current
    calibration. The volume, otherwise, looks very squashed. The squashed appearance
    is caused by the fact that this image was not calibrated. Each voxel (a contraction
    of volume and pixel) is 1 x 1 x 1, without a unit. A typical value for the voxel
    size in MRI images is 1.5 x 1.5 x 3.0 mm, which can be set using the image properties
    as described in the previous chapter. We can now change the view by selecting
    the view buttons at the bottom of the viewer. The **yz** button will give us a
    side view of this volume. It is also possible to rotate the volume by clicking
    and dragging the mouse.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**体积查看器**，它是Fiji的一部分，并且作为ImageJ的插件可用。在左侧，有三个图像显示了体积的不同视图：一个**xy**切片（这是这个堆栈的顶部视图），一个**yz**切片（这是这个堆栈的侧面视图），最后是一个**xz**切片（这是这个堆栈的前视图）。查看器中间的大图像是当前选定的视图，在这种情况下，是*xz*切片视图。这个切片的位置在左侧的概述图像中由青色(*xy*)和绿色(**yz**)线条指示。请注意，我通过输入`5`并按*Enter*键而不是基于当前校准的值来调整**z-Aspect**。否则，体积看起来非常扁平。这种扁平的外观是由于这幅图像没有校准。每个体素（体积和像素的缩写）是1
    x 1 x 1，没有单位。MRI图像中体素大小的典型值是1.5 x 1.5 x 3.0 mm，这可以通过上一章中描述的图像属性来设置。现在我们可以通过选择查看器底部的视图按钮来更改视图。**yz**按钮将给我们这个体积的侧面视图。也可以通过点击并拖动鼠标来旋转体积。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The size of the volume viewer window has a minimum size of ±1024 x 768 pixels.
    This can mean that depending on the pixel dimensions of your monitor, some of
    the controls might fall off the screen. For most modern displays, this should
    not be an issue. However, for some small screens or beamers, this can be a problem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 体积查看器窗口的大小至少为±1024 x 768像素。这意味着根据您监视器的像素尺寸，一些控件可能超出屏幕。对于大多数现代显示器，这应该不会成为问题。然而，对于一些小屏幕或投影仪，这可能会成为一个问题。
- en: 'Next, we will look at a different type of image: a Z-stack of a fly brain using
    fluorescent imaging. To open the image, go to **File** | **Open Samples** and
    select the **Fly Brain** image. The Z-stack will open, and you can go through
    the slices:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看不同类型的图像：使用荧光成像的果蝇大脑的Z堆栈。要打开图像，转到**文件** | **打开样本**并选择**果蝇大脑**图像。Z堆栈将打开，你可以浏览切片：
- en: '![Volume viewing and rendering](img/Insert_image_4909_03_15.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![体积查看和渲染](img/Insert_image_4909_03_15.jpg)'
- en: The first slice contains no bright pixels, but as you move through the stack,
    the brain of the fruit fly starts to show defined features. This stack shows the
    brain from a (rotated) front view in contrast to the MRI stack, which was displayed
    as a top view. We will use the volume viewer to examine the entire volume and
    use it to create a short movie of the volume turning. To start, select the **Fly
    Brain** stack and go to **Plugins** | **Volume Viewer**. The initial image will
    be a slice view, but for this example, we want to switch to a different mode.
    Select **Volume (4)** mode using the selector at the top of the viewer. We will
    set the interpolation to **Tricubic sharp (3)** using the drop-down selector.
    On the right-hand side of the viewer, we will modify the transfer function to
    **2D Grad** to create a slightly more pleasing view. Next, we will set the rotation
    for *X*, *Y*, and *Z* at the bottom of the volume viewer to -90, 30, and 180 respectively.
    This will provide a side view of the brain.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一层切片中没有明亮的像素，但随着你在堆栈中移动，果蝇的大脑开始显示出定义明确的特点。这个堆栈显示了大脑的（旋转）前视图，与之前显示为顶视图的MRI堆栈形成对比。我们将使用体积查看器来检查整个体积，并用它来创建一个体积旋转的短片。首先，选择**果蝇大脑**堆栈，然后转到**插件**
    | **体积查看器**。初始图像将是一个切片视图，但在这个例子中，我们想要切换到不同的模式。使用查看器顶部的选择器选择**体积（4）**模式。我们将使用下拉选择器将插值设置为**三阶锐化（3）**。在查看器的右侧，我们将修改传输函数为**2D渐变**以创建一个稍微更令人愉悦的视图。接下来，我们将体积查看器底部的旋转设置为*X*、*Y*和*Z*分别为-90、30和180。这将提供一个大脑的侧面视图。
- en: By pressing the **Snapshot** button (top right) in the viewer, we will get a
    picture of the current view. Next, we will increase the value for the *Y* rotation
    with 10-degree increments and take a snapshot every time until you have reached
    210 degrees. We now made snapshots of the brain from one side of the brain to
    the other side (180 degrees). To turn this into an animation, all we have to do
    is go to **Image** | **Stacks** | **Images to Stack**. If you close the original
    stack, you only have to press OK in the dialog. Otherwise, you would have to enter
    `Volume_Viewer` in the **Title contains** field. You will now have a stack that
    can be played and saved as a movie for presentation purposes. For this example,
    we used increments of 10 degrees for the rotation, which gives an adequate result.
    However, if you take smaller increments, the result will look much smoother. Feel
    free to modify the angles at which you view the volume for different results as
    well as experiment with the other settings available within the volume viewer.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在查看器中按下**快照**按钮（右上角），我们将获得当前视图的图片。接下来，我们将以10度的增量增加*Y*旋转的值，并在每次达到210度时拍摄快照。我们现在从大脑的一侧到另一侧（180度）拍摄了大脑的快照。要将这些转换为动画，我们只需转到**图像**
    | **堆栈** | **图像到堆栈**。如果您关闭原始堆栈，您只需在对话框中按确定即可。否则，您必须在**标题包含**字段中输入`Volume_Viewer`。现在您将有一个可以播放并保存为电影以供演示目的的堆栈。在这个例子中，我们使用了10度的增量进行旋转，这给出了足够的结果。然而，如果您使用更小的增量，结果看起来会更平滑。您可以自由地修改观察体积的角度以获得不同的结果，也可以在体积查看器中实验其他设置。
- en: The volume viewer is a very powerful function in ImageJ that allows for the
    investigation and visualization of 3D objects. Use the **Slice (0)** mode to examine
    the volume as a cross-section and the **Volume (4)** mode to see a solid model.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 体积查看器是ImageJ中的一个非常强大的功能，它允许调查和可视化3D对象。使用**切片（0）**模式来检查体积作为横截面，使用**体积（4）**模式来查看实体模型。
- en: Processing time series
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理时间序列
- en: 'Time series consists of images acquired over time, usually with a fixed interval.
    Movies can also be seen as time series with a fixed interval of 24 or 25 frames
    per second (**fps**). Processing of time series mostly focuses on two areas: fluctuations
    in intensity over time and background reduction and normalization. Fluctuations
    in intensity have been covered in the previous section where we looked at bleach
    correction. In the following section, we will look at ways to normalize the time
    series data.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列由随时间获取的图像组成，通常具有固定的间隔。电影也可以被视为具有每秒24或25帧（**fps**）固定间隔的时间序列。时间序列的处理主要关注两个领域：随时间的强度波动和背景减少及标准化。强度波动已在之前的章节中介绍，其中我们讨论了漂白校正。在下一节中，我们将探讨标准化时间序列数据的方法。
- en: Normalizing time series data
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准化时间序列数据
- en: 'Normalizing time series data will help in further analysis by providing a correction
    for the baseline intensity. Many times, the goal of time series is to look at
    changes in intensity or movement over time. Normalizing will yield cleaner time
    series data relative to the resting or baseline state. A very simple normalization
    is to calculate ΔF over F0 (dFF0). The basis for this metric is that the baseline
    fluorescence can be different between time series, but the changes in intensity
    *relative to the baseline* are similar. It is calculated using the following formula:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化时间序列数据将有助于进一步分析，因为它提供了对基线强度的校正。很多时候，时间序列的目标是观察强度或随时间的变化。标准化将产生相对于静息或基线状态更干净的时间序列数据。一个非常简单的标准化方法是计算ΔF相对于F0（dFF0）。这个指标的基础是基线荧光在不同时间序列之间可能不同，但相对于基线的强度变化是相似的。它使用以下公式进行计算：
- en: '![Normalizing time series data](img/Insert_image_4909_03_19.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![标准化时间序列数据](img/Insert_image_4909_03_19.jpg)'
- en: The numerator is the difference between the current frame (Ft) and the baseline
    (F0). The baseline is the average of the first *n* frames. A value of *dFF0* larger
    than 1 indicates the signal increased relative to the baseline, while a value
    less than 1 indicates a decrease relative to the baseline. It is possible to perform
    this calculation only on the measured values of a time series (in Excel or MATLAB),
    but you can also transform the time series directly. I will now show you how to
    do this in ImageJ using the Z projection, image duplication, and image calculator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 分子是当前帧（Ft）与基线（F0）之间的差值。基线是前*n*帧的平均值。*dFF0*的值大于1表示信号相对于基线增加，而小于1表示相对于基线减少。这种计算只能在时间序列的测量值上执行（在Excel或MATLAB中），但你也可以直接转换时间序列。我现在将向您展示如何在ImageJ中使用Z投影、图像复制和图像计算器来完成这项操作。
- en: 'To get started, we will open the `timeseries_events.tif` image, which is available
    in the online resources with this book. This is a time series of vesicles in a
    cell that are transported and fuse when the cell is stimulated with electrodes.
    It contains two channels: one with a red fluorescent marker and the other with
    a green fluorescent marker. The red marker is fluorescent at all times until the
    vesicle fuses, at which point it disappears. The green marker is not fluorescent
    while the cargo is within the vesicle, but as soon as it fuses, it becomes bright.
    To start the processing, we first want to split the channels into two different
    time series. To do this, select the time series and go to **Image** | **Color**
    | **Split Channels** to generate two time series: one for each channel. We will
    select the green channel, which was labeled `C1_timeseries_events.tif`, using
    the **split channels** command.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将打开`timeseries_events.tif`图像，该图像可在本书的在线资源中找到。这是一组细胞中囊泡的时间序列，当细胞用电极刺激时，囊泡会被运输并融合。它包含两个通道：一个带有红色荧光标记，另一个带有绿色荧光标记。红色标记在囊泡融合之前始终是荧光的，此时它会消失。绿色标记在货物位于囊泡内时不是荧光的，但一旦融合，它就会变亮。为了开始处理，我们首先想要将通道分成两个不同的时间序列。为此，选择时间序列，转到**Image**
    | **Color** | **Split Channels**以生成两个时间序列：每个通道一个。我们将使用**split channels**命令选择绿色通道，其标记为`C1_timeseries_events.tif`。
- en: 'We can now start with the first step in the creation of the `dFF0` time series:
    creating the baseline frame. We will go to **Image** | **Stacks** | **Z Project…**
    and set the method to **Average Intensity** and **Stop slice:** to `5`. What we
    do here is create an average of the first five frames. This effectively reduces
    the noise in the individual frames by averaging it out while leaving the bright
    objects present in the first frames intact. Let''s rename the resulting image
    to make it easier to identify later on. Right-click on the average image and select
    **Rename…** from the context menu. Rename the image to `F0` so that it will be
    easy to select later on.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始创建`dFF0`时间序列的第一步：创建基线帧。我们将转到**Image** | **Stacks** | **Z Project…**并设置方法为**Average
    Intensity**和**Stop slice:**为`5`。我们在这里所做的就是创建前五帧的平均值。这实际上通过平均减少了单个帧中的噪声，同时保留了第一帧中存在的明亮物体。让我们将生成的图像重命名，以便稍后更容易识别。右键单击平均图像，从上下文菜单中选择**Rename…**。将图像重命名为`F0`，以便稍后更容易选择。
- en: For the next step, we will create the ΔF image. As explained at the beginning
    of this section, this image is the raw image minus the baseline image. To get
    this image, we will use the image calculator by going to **Process** | **Image
    Calculator** from the **ImageJ** menu. Select the original time series as `Image1`
    and the **F0** image as `Image2`. Then, set the method to **Subtract**. Make sure
    that the **Create new window** option is selected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一步，我们将创建ΔF图像。正如本节开头所解释的，这个图像是原始图像减去基线图像。为了得到这个图像，我们将通过**ImageJ**菜单中的**Process**
    | **Image Calculator**来使用图像计算器。选择原始时间序列为`Image1`和**F0**图像为`Image2`。然后，将方法设置为**Subtract**。确保已选中**Create
    new window**选项。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order of the images is very important when one of them is a stack or time
    series and the other is a single frame. The stack always needs to be set at the
    `Image1` position if you wish to modify each slice or frame. For subtraction,
    this is usually obvious, but for multiplication, the order of the operation would
    not be important from a mathematical perspective (*A × B equals B × A*). However,
    if you place the time series or stack on `Image2` and the single frame on `Image1`,
    only the current slice or frame is used for the calculation!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当其中一个图像是堆栈或时间序列，而另一个是单个帧时，图像的顺序非常重要。如果你希望修改每个切片或帧，堆栈始终需要设置在`Image1`位置。对于减法，这通常是显而易见的，但对于乘法，从数学角度来看操作顺序并不重要（*A
    × B 等于 B × A*）。然而，如果你将时间序列或堆栈放在`Image2`上，而单个帧放在`Image1`上，则只有当前切片或帧用于计算！
- en: We now have the ΔF stack, so let's rename it to make it easier. Right-click
    on the new time series, select **Rename…**, and enter `deltaF` as the new name.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了ΔF堆栈，所以让我们重命名它以使其更容易识别。右键单击新的时间序列，选择**重命名…**，并输入`deltaF`作为新名称。
- en: Now, we can create the final time series that is normalized to the baseline.
    Note that the `deltaF` series by itself already provides an improvement over the
    original time series as it is corrected for the initial static background. To
    create the *dFF0* image, we will use the Image Calculator again. This time, we
    will select `deltaF` as `Image1` and `F0` as `Image2` and the **Divide** operation.
    Select the **Create new window** and **32-bit (float) result** options.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建最终的时间序列，并将其归一化到基线。请注意，`deltaF`序列本身已经比原始时间序列有所改进，因为它已经校正了初始静态背景。要创建*dFF0*图像，我们将再次使用图像计算器。这次，我们将选择`deltaF`作为`Image1`，`F0`作为`Image2`，并选择**除法**操作。选择**创建新窗口**和**32位（浮点）结果**选项。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This time, the 32-bit result option is useful. As we noted earlier, in the definition
    of the calculation, we expected the results to be between 0 and infinity. This
    is denoted as *[0, ∞]* in mathematical notation. This means that that any value,
    including 0 and infinity, are within the range of possible values. When this option
    is not selected during the calculation, all the values below 1 will be rounded
    to 0, and information about these events are lost. Note that for the example used
    here, the events we wish to see will have a value larger than 1\. So, in this
    particular case, it is not crucial.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，32位结果选项很有用。正如我们之前提到的，在计算定义中，我们期望结果在0到无穷大之间。这在数学符号中表示为*[0, ∞]*。这意味着任何值，包括0和无穷大，都在可能值的范围内。当在计算过程中未选择此选项时，所有低于1的值都将被舍入到0，这些事件的信息将丢失。请注意，对于这里使用的示例，我们希望看到的事件值将大于1。因此，在这种情况下，这并不重要。
- en: 'The new image is now the dFF0 image, which has been corrected for the baseline
    and normalized to the initial baseline intensity. The following image shows the
    effect of this normalization (second row), compared to the original images (first
    row):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 新图像现在是dFF0图像，它已经校正了基线并归一化到初始基线强度。以下图像显示了这种归一化的效果（第二行），与原始图像（第一行）相比：
- en: '![Normalizing time series data](img/Insert_image_4909_03_16.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![归一化时间序列数据](img/Insert_image_4909_03_16.jpg)'
- en: The clearest difference that can be seen is that the images before frame **300**
    are nearly black, indicating that nothing is happening relative to the baseline
    situation. At frame **300** and beyond, the increase in signal at different locations
    is very clear, indicating that the signal has increased in these locations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到的最明显差异是，在帧**300**之前的图像几乎是黑色的，这表明相对于基线情况没有发生任何事情。在帧**300**及以后，不同位置的信号增加非常明显，这表明这些位置的信号已经增加。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we investigated the processing of different types of images.
    We looked at different sources of noise that can corrupt images and degrade their
    quality. You learned how to apply different corrections to the images to fix these
    problems. We then looked at processing steps specifically aimed at Z-stacks and
    time series.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了不同类型图像的处理过程。我们探讨了可能导致图像损坏并降低其质量的噪声来源。你学习了如何应用不同的校正方法来修复这些问题。然后，我们查看针对Z堆栈和时间序列的特定处理步骤。
- en: In the next chapter, we will see how to separate pixels into different groups
    and how to clean up and filter the result for further processing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何将像素分成不同的组，以及如何清理和过滤结果以进行进一步处理。
