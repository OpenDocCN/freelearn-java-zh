- en: Loggers and Performances – A Trade-Off
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录器和性能——一种权衡
- en: Logs are probably one of the most important parts of an application, whatever
    technology it uses. Why is that? Because without logs, you have no idea what your
    application is doing or why your application is behaving in a particular way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 日志可能是应用程序最重要的部分之一，无论它使用什么技术。为什么是这样？因为没有日志，你不知道应用程序在做什么，也不知道为什么应用程序以某种特定方式表现。
- en: Of course, we saw in [Chapter 3](c4d7d24f-3ce9-428c-915c-04296a2c3a85.xhtml), *Monitor
    Your Application*, how to instrument the application to get some monitoring information
    about the JVM and application, but it was very technical and mainly performance
    or tracking oriented. This is important but rarely enough and generally not helpful
    enough for operation and support teams who generally prefer a higher level view
    of application tracing. This is where logging enters into the game. However, it
    is important that you correctly use it and configure it, so that you do not impact
    your application performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在[第3章](c4d7d24f-3ce9-428c-915c-04296a2c3a85.xhtml)，“监控您的应用程序”，中看到了如何对应用程序进行配置以获取有关JVM和应用程序的一些监控信息，但这非常技术性，主要是性能或跟踪导向的。这很重要，但通常不足以帮助操作和支持团队，他们通常更喜欢从更高层次查看应用程序跟踪。这就是日志记录介入的地方。然而，正确使用和配置它是很重要的，这样你就不影响应用程序的性能。
- en: You may think that Java EE and logging are not directly related, but actually
    it is probably way more important to ensure you understand what logging is doing
    in an EE context. The main things you get from an EE container are services. Services
    are code and therefore have the same kind of constraints as your own code. You
    can take any Java EE library, and most services, if not all, will use some logger
    to let you understand what happens without having to look into the code. There
    are even some coding practices of some vendors that require you to log each time
    a method starts and stops. Long story short, loggers and log statements are everywhere,
    whether you wrote it yourself in your codebase or not because they are present
    in a library codebase.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为Java EE和日志记录没有直接关系，但实际上，确保你理解在EE环境中日志记录正在做什么可能更为重要。从EE容器中获得的主要东西是服务。服务是代码，因此具有与你的代码相同的约束。你可以使用任何Java
    EE库，大多数服务，如果不是所有服务，都会使用一些日志记录器来让你了解发生了什么，而无需查看代码。甚至有些供应商的编码实践要求你在每次方法开始和结束时都进行日志记录。简而言之，日志记录器和日志语句无处不在，无论你是否在自己的代码库中编写了它们，因为它们存在于库代码库中。
- en: 'Therefore, in this chapter, we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖：
- en: When to use logging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用日志记录
- en: The work implied by a logging statement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志语句所暗示的工作
- en: Some common and useful performance-related logging patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些常见且有用的与性能相关的日志记录模式
- en: Some well-known logging libraries and how to configure them in EE land
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些知名的日志记录库以及如何在EE环境中配置它们
- en: I log, you log, they log
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我记录，你记录，他们记录
- en: When do we use logging? This very technically-oriented question should be rephrased
    this way: *when do we provide information about what the application is doing?* This
    is exactly what logging is used for; it lets the user know what the application
    did at some point.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们何时使用日志记录？这个非常技术性的问题应该这样重新表述：*我们何时提供有关应用程序正在做什么的信息？*这正是日志记录所用的；它让用户知道应用程序在某个时刻做了什么。
- en: This is something we, as developers, often forget because we are focused on
    the feature we are implementing. But if the application intends to hit production,
    it is crucial to not forget to make sure the operation teams can work with it
    very efficiently as well. Don't forget that if the development takes six months,
    the production will probably last for some years and the cost of an incident is
    way higher than a small delay before the production is launched. Therefore, investing
    in a system communicating enough information is often worth it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们作为开发者经常忘记的事情，因为我们专注于我们正在实现的功能。但如果应用程序打算投入生产，确保操作团队能够非常高效地与之合作是至关重要的。不要忘记，如果开发需要六个月，那么生产可能持续几年，而事故的成本远远高于生产启动前的微小延迟。因此，投资于一个能够传达足够信息的系统通常是值得的。
- en: 'However, logging is not a trivial task to underestimate. All the difficulty
    is about:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记录日志并不是一个可以轻视的任务。所有的困难都关于：
- en: Designing messages that are meaningful for someone with poor—or without—knowledge
    of the code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计对代码知识贫乏的人——或者没有——有意义的消息
- en: Ensuring the message is logged, whatever happens
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保无论发生什么情况，消息都被记录下来
- en: Log error cases which can be *invisible* in the code by default
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录默认情况下在代码中可能*不可见*的错误情况
- en: 'Let''s just take a moment on this last case to deal with a more and more common
    use case in EE applications, particularly in microservice environments—an HTTP
    client in a REST endpoint:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间来处理这个最后的情况，因为它在EE应用中越来越常见，尤其是在微服务环境中——一个REST端点中的HTTP客户端：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a very common pattern used in microservice infrastructure, a service
    calling another one. This particular implementation is a flat proxy (no additional
    logic), but it can be used to hide some machine to machine credential or security
    mechanisms, for instance. What is important to identify here is that a JAX-RS
    client is called in a JAX-RS endpoint (`getQuote`). Now, when you think about
    error handling, what can happen with such code?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在微服务基础设施中非常常见的模式，一个服务调用另一个服务。这个特定的实现是一个扁平代理（没有额外的逻辑），但它可以用来隐藏一些机器到机器的凭证或安全机制，例如。在这里需要确定的是，一个JAX-RS客户端在JAX-RS端点（`getQuote`）中被调用。现在，当你考虑错误处理时，这样的代码可能会发生什么？
- en: If the client call fails because the server returns an error (let's consider
    an HTTP 404 as the ID is invalid), then the client `get()` invocation will throw
    a `javax.ws.rs.NotFoundException`. Since there is no exception handling around
    the client invocation, your endpoint will throw the same exception, which means
    an HTTP 404 for JAX-RS on the server side, and thus, your own endpoint will throw
    the same exception.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端调用失败是因为服务器返回错误（让我们假设HTTP 404是因为ID无效），那么客户端`get()`调用将抛出`javax.ws.rs.NotFoundException`。由于客户端调用周围没有异常处理，你的端点将抛出相同的异常，这意味着服务器端的JAX-RS将是一个HTTP
    404，因此，你的端点将抛出相同的异常。
- en: It can be what you want—in the case of a proxy, for instance—but it is not very
    good in terms of implementation because when you get HTTP 404 responses on the
    client side (final client, not the endpoint client), then how do you know whether
    your endpoint or the remote service is broken?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能正是你想要的——例如，在代理的情况下——但在实现方面并不很好，因为当你从客户端（最终客户端，而不是端点客户端）收到HTTP 404响应时，你如何知道是端点还是远程服务出了问题？
- en: 'A way to mitigate that side effect is to change the implementation of the endpoint
    a bit, as in the following snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过稍微改变端点的实现来减轻这种副作用的方法，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is not a perfect implementation, but at least now, in the server logs,
    you will be able to identify that the invocation failed due to an error on the
    remote service. And that is already better than being silent. In real life, you
    can notify the final client that the error is not your fault and either use another
    status code or add a header, allowing the client to identify it depending on the
    type of service you implement. However, what doesn't change is that, at least,
    logging the error is allowing your application to give enough information for
    you to investigate where the issue comes from. Then, all the enrichments you can
    do on top of it (logging format, MDC, and so on) are mainly about making the information
    easy to find and fast to analyze.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完美的实现，但至少现在，在服务器日志中，你将能够识别出调用失败是由于远程服务上的错误。这已经比沉默好多了。在现实生活中，你可以通知最终客户端错误不是你的责任，或者使用另一个状态码或添加一个头信息，允许客户端根据你实现的服务类型来识别它。然而，不变的是，至少记录错误允许你的应用程序提供足够的信息，以便你调查问题的来源。然后，你可以在其基础上进行的所有增强（日志格式、MDC等）主要是为了让信息更容易找到和快速分析。
- en: 'Logging is a simple way—probably the simplest—to communicate from the JVM to
    outside of it. This is also probably why it is so widely used in all layers of
    any application. You can be sure that most (if not all) libraries and containers
    rely on a logger, somewhere. Generally, this is also the first contact you get
    with your container. When you start it as *empty*, the first thing you see is
    this output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志是一种简单的方式——可能也是最简单的方式——从JVM向其外部进行通信。这也可能是为什么它在任何应用的各个层都得到了广泛使用。你可以确信，大多数（如果不是所有）库和容器都依赖于某个日志记录器。通常，这也是你与容器的第一次接触。当你以*空状态*启动它时，你首先看到的是以下输出：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What is important here is not really the content of the output, but more that
    you can control it from the logging configuration. Java EE containers are not
    uniform on the implementation they use, but most of them rely on **Java Util Logging**
    (**JUL**), which is the Java standard logging solution. We will get back to the
    logger implementations later. But just to continue giving you an idea of why it
    is not directly done with console output or file management, we will open the
    GlassFish configuration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正重要的是不是输出的内容，而是你能够从日志配置中控制它。Java EE容器在实现上并不统一，但大多数都依赖于**Java Util Logging**（**JUL**），这是Java标准日志解决方案。我们稍后会回到日志实现。但为了继续给你一个为什么不是直接通过控制台输出或文件管理来做的概念，我们将打开GlassFish配置。
- en: 'GlassFish, relying on JUL, uses a `logging.properties` configuration. If you
    use the default GlassFish domain, you will find it in the `glassfish/domains/domain1/config/logging.properties`
    file. If you open this file, you will see these lines:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: GlassFish，依赖于JUL，使用`logging.properties`配置文件。如果你使用默认的GlassFish域，你将在`glassfish/domains/domain1/config/logging.properties`文件中找到它。如果你打开这个文件，你会看到以下这些行：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will not enter into the way JUL is configured here, but what we can identify
    from this snippet is that the logging abstraction allows us to:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里进入JUL的配置方式，但我们可以从这个片段中识别出，日志抽象允许我们：
- en: Configure where the logs (messages) are going. We can see that `GFFileHandler`
    is pointing to the `server.log` file for instance, but that the `ConsoleHandler`
    is also set, which is consistent with the fact that we see the logs in the console.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置日志（消息）的去向。我们可以看到`GFFileHandler`指向`server.log`文件，例如，但`ConsoleHandler`也被设置了，这与我们在控制台中看到日志的事实是一致的。
- en: Configure the log level, which is something we will detail a bit more later;
    very high level, it allows you to select the logs you want to keep or not
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置日志级别，我们稍后会详细说明这一点；在非常高的层面上，它允许你选择你想要保留或不要的日志。
- en: If the implementation didn't use a logger abstraction, you wouldn't have the
    choice of the output (handler) and the level selection would be per case (not
    standardized), which would make the work of the operation teams way harder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现没有使用日志抽象，你就没有选择输出的（处理程序）和级别选择将是针对每个案例的（不是标准化的），这将使操作团队的工作变得更加困难。
- en: Logging frameworks and concepts
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志框架和概念
- en: There are lots of logging frameworks and this is probably one challenge integrators
    have, since the more you integrate libraries, the more you will need to ensure
    loggers are consistent and potentially go to the same output. However, they all
    share the same basic concepts, which are important to understand to know how to
    properly use loggers and how they can impact the application performance in a
    bad way if you don't take care of their usages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多日志框架，这可能是一个集成者面临的挑战，因为当你集成的库越多，你就越需要确保日志记录器是一致的，并且可能需要将它们输出到同一个地方。然而，它们都共享相同的基本概念，这些概念对于了解如何正确使用日志记录器以及如果不注意它们的用法，它们如何以不好的方式影响应用程序性能是非常重要的。
- en: 'These concepts can be differently named depending on the framework, but to
    identify them, we will use the JUL names in this book:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念在不同的框架中可能有不同的名称，但为了识别它们，我们将在这本书中使用JUL的名称：
- en: Logger
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录器
- en: Logger Factory
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录器工厂
- en: LogRecord
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LogRecord
- en: Handler
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序
- en: Filter
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器
- en: Formatter
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化器
- en: Level
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别
- en: Logger
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录器
- en: 'The logger is the entry point of the logging framework. This is the instance
    you use to *write* messages. The API has, generally, a set of helper methods but
    the requisite API elements are:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器是日志框架的入口点。这是你用来*写入*消息的实例。API通常有一组辅助方法，但必需的API元素包括：
- en: To allow passing a level with the message.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许将级别与消息一起传递。
- en: To allow passing a precomputed message of what is needed to compute a message
    (it can be a pattern with some variables or a `Supplier<>` as of Java 8). In this
    last case, the goal is to not evaluate/interpolate the message if not needed and
    avoid paying the cost of that computation if the message is *hidden*.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许传递一个预先计算的消息，该消息是计算所需消息的（它可以是一个带有一些变量的模式或Java 8的`Supplier<>`）。在后一种情况下，目标是如果不需要就不评估/插值消息，如果消息是*隐藏的*，就避免支付这种计算的代价。
- en: To allow association with an `Exception` (mainly for error cases) to the message.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许将`Exception`（主要针对错误情况）与消息关联。
- en: 'The most common example of a logger usage will probably be:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器使用的最常见例子可能是：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This logger invocation is equivalent to the following line, but avoids the
    concatenation if not needed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个日志调用与以下行等价，但避免了如果不需要就进行连接：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, it will also trigger the sending of the message (`String`) to the final
    output (console, file, and so on). It may not look that important, but think how
    many logger invocations you can have in a single request with the multiple and
    complex layers we saw in [Chapter 2](f9d9ccb7-8c28-4f87-9642-8c62a05fa856.xhtml),
    *Looking Under the Cover – What is This EE Thing?*. It can be important to avoid
    all these small operations, particularly because in general, you don't have just
    a simple concatenation but multiple ones on complex objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它还会触发将消息（`String`）发送到最终输出（控制台、文件等）。这可能看起来并不重要，但想想在[第2章](f9d9ccb7-8c28-4f87-9642-8c62a05fa856.xhtml)中看到的多个和复杂的层中，你可以在单个请求中调用多少个日志记录器。避免所有这些小操作可能很重要，尤其是在一般情况下，你不仅仅是一个简单的连接，而是在复杂对象上有多个连接。
- en: Logger Factory
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志工厂
- en: The Logger Factory is generally a utility method (`static`) giving you a logger
    instance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 日志工厂通常是一个实用方法（静态），为你提供一个日志记录器实例。
- en: 'Most of the time, it looks like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，它看起来像这样：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Logger Factory is either a specific class or the `Logger` class itself depending
    on the logging framework, but in all cases, it gives you a `Logger` instance.
    The parameter of this factory method can change, but generally leads to a `String`
    (a lot of libraries allow a `Class` shortcut) which can be used to configure the
    log level as we saw earlier in the JUL configuration file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 根据日志框架，日志工厂要么是一个特定的类，要么是`Logger`类本身。但在所有情况下，它都为你提供了一个`Logger`实例。这个工厂方法的参数可能会变化，但通常是一个`String`（许多库允许`Class`快捷方式），可以用来配置日志级别，就像我们在前面的JUL配置文件中看到的那样。
- en: 'Why do logger frameworks need a factory and why don''t they allow you to instantiate
    the logger yourself with a plain `new`? Because the way the logger instance is
    resolved can depend on the environment. Don''t forget that most of the logger
    consumers (the code using a logger) can be deployed in a lot of environments,
    such as:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么日志框架需要一个工厂，为什么不允许你使用普通的`new`来实例化日志记录器？因为日志记录器实例的解析方式可能取决于环境。不要忘记，大多数日志消费者（使用日志的代码）可以部署在许多环境中，例如：
- en: A standalone application with a flat classpath
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有平坦类路径的独立应用程序
- en: A JavaEE container with a hierarchic classloader (tree)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有分层类加载器（树）的JavaEE容器
- en: An OSGI container with a graph classloading
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有图类加载的OSGI容器
- en: It is always possible, in all logging frameworks, to configure the way the configuration
    is resolved and thus how the loggers are instantiated. Specially, as soon as you
    have a container, you will want to handle a global—container—configuration and
    a *per application* configuration to be able to make one application configuration
    more specific than the default one. To do that, containers  (or logging frameworks
    when the implementation is generic enough) will implement a custom configuration
    resolution and let the logging framework instantiate a logger with this configuration.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有日志框架中，总是可以配置配置解析的方式，从而确定日志记录器的实例化方式。特别地，一旦你有一个容器，你将想要处理全局容器配置和*每个应用程序*配置，以便使一个应用程序配置比默认配置更具体。为此，容器（或当实现足够通用时为日志框架）将实现自定义配置解析，并让日志框架使用此配置实例化一个日志记录器。
- en: Typically, in an EE container, you will get a different logging configuration
    per application. And if the application doesn't provide any configuration, then
    the container configuration will be used. If you take Apache Tomcat implementation
    for instance, it will read `conf/logging.properties` by default, and for each
    application, it will try to read `WEB-INF/logging.properties` if the file exists.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在一个EE容器中，你将得到每个应用程序不同的日志配置。如果应用程序没有提供任何配置，则将使用容器配置。以Apache Tomcat实现为例，它默认会读取`conf/logging.properties`，而对于每个应用程序，如果该文件存在，它将尝试读取`WEB-INF/logging.properties`。
- en: LogRecord
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LogRecord
- en: 'The `LogRecord` is the logging message structure. It encapsulates more data
    than just the `String` message you passed, allowing you to get the information
    we often see in the log messages, such as:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogRecord`是日志消息结构。它封装了比你传递的`String`消息更多的数据，允许你获取我们经常在日志消息中看到的信息，例如：'
- en: The log level
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志级别
- en: Optionally, a log sequence number
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的，一个日志序列号
- en: The source class name
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源类名
- en: The source method name
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源方法名
- en: The message indeed
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息确实
- en: The thread (often identified by its identifier rather than its name but this
    last one is not always unique)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程（通常通过其标识符而不是其名称来识别，但最后一个并不总是唯一的）
- en: The logger invocation date (often in milliseconds as of 1970)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志调用日期（通常自1970年以来以毫秒为单位）
- en: Optionally, an exception associated with the logger invocation
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，与日志调用关联的异常
- en: The logger name
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录器名称
- en: Optionally, a resource bundle if the logger supports internationalization
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，如果日志记录器支持国际化，则可以是一个资源包
- en: Optionally, a call context such as a set of contextual data based on custom
    values (MDC) or the current HTTP request, for instance
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，一个调用上下文，例如基于自定义值（MDC）或当前HTTP请求的一组上下文数据
- en: In this list, we find the information we see (such as the message) but also
    all the metadata associated with the logger call such as the caller of the logger
    (class and method), the call context (its date and thread for instance), and so
    on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们找到我们看到的信息（如消息），但还包括与日志调用关联的所有元数据，例如调用者（类和方法）、调用上下文（例如日期和线程），等等。
- en: Thus, it is this *record* which is passed into the logging chain, as we will
    see next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们将看到的，是这条`*记录*`被传递到日志链中。
- en: Handler
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理程序
- en: Sometimes called `Appender`, the handlers are the output implementations. They
    are the ones receiving the `LogRecord` of the previous part and doing *something* with
    it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时称为`Appender`，处理程序是输出实现。它们是接收上一部分的`LogRecord`并对其进行某种操作的那些。
- en: 'The most common implementations are:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的实现包括：
- en: 'The `FileHandler` : Outputs the messages in a file.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileHandler`：将消息输出到文件中。'
- en: 'A `MailHandler` : Sends the messages by mail. This is a particular handler
    that should not be used for a high volume of messages but it can be used with
    a *particular* logger dedicated to sending some messages under specific circumstances.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`MailHandler`：通过邮件发送消息。这是一个特定的处理程序，不应用于大量消息，但它可以与一个`*特定*`的日志记录器一起使用，该日志记录器专门用于在特定情况下发送一些消息。
- en: The `ConsoleHandler` to output messages into the console.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConsoleHandler`用于将消息输出到控制台。'
- en: There are more, such as `JMSHandler`, `ElasticsearchHandler`, `HTTPHandler`,
    and so on.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多，例如`JMSHandler`、`ElasticsearchHandler`、`HTTPHandler`等。
- en: In any case, the handlers are sending data to a *backend* which can be anything,
    and the logging framework always ensures you can plug in your own implementation
    if you need to extend the default handlers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，处理程序都将数据发送到`*backend*`，它可以是一切，并且日志框架始终确保您可以在需要扩展默认处理程序时插入自己的实现。
- en: Filter
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器
- en: A `Filter` is simply a class allowing you to let the `LogRecord` be passed or
    not. In the Java 8 ecosystem, it can be seen as a `Predicate<LogRecord>`; this
    class has been in Java since its 1.4 version, far before `Predicate` was created.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Filter`是一个简单的类，允许您让`LogRecord`通过或不通过。在Java 8生态系统中，它可以被视为一个`Predicate<LogRecord>`；这个类自从Java
    1.4版本以来就在Java中，远在`Predicate`被创建之前。
- en: It is often bound to a particular `Handler`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常与特定的`Handler`绑定。
- en: Formatter
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化器
- en: A `Formatter` is a class taking a `LogRecord` and converting it into a `String`.
    It is the one responsible for preparing the content to be sent to the backend.
    The idea is to separate the *writing* and *formatting* concerns, allowing you
    to reuse one part without having to create a new `Handler`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Formatter`是一个接受`LogRecord`并将其转换为`String`的类。它负责准备要发送到后端的内容。想法是将`*写作*`和`*格式化*`关注点分开，允许您重用一部分而无需创建一个新的`Handler`。
- en: Again, it is often bound to a particular `Handler`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，它通常与特定的`Handler`绑定。
- en: Level
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级别
- en: '`Level` is a simple concept. It is the metadata of the log record but also
    most of the logging components we just looked at. The main idea is to be able
    to compare the log record level to the level of the component the record goes
    through to skip the message if it is not compatible. The common (sorted) logging
    levels are:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`级别`是一个简单的概念。它是日志记录的元数据，也是我们刚刚查看的大多数日志组件。主要思想是能够将日志记录级别与记录通过的组件级别进行比较，如果不兼容则跳过消息。常见的（排序）日志级别包括：'
- en: '`OFF`: Not directly used by the log record, but generally used only by other
    components, it disables any log message.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OFF`：不直接用于日志记录，但通常仅由其他组件使用，它禁用任何日志消息。'
- en: '`SEVERE` (or `ERROR`): The highest log level. It is intended to be used when
    something bad occurs. A record is logged if the component level is not `OFF`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEVERE`（或`ERROR`）：最高的日志级别。它旨在在发生严重问题时使用。如果组件级别不是`OFF`，则记录条目将被记录。'
- en: '`WARNING`: Generally used when something wrong happened (but is not preventing
    the application to work); a record is logged if the level of the components is
    not `OFF` or `SEVERE`.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING`：通常在发生错误时使用（但不会阻止应用程序工作）；如果组件级别不是`OFF`或`SEVERE`，则记录条目将被记录。'
- en: '`INFO`: The default logging level of a lot of applications, it is used to notify
    us that something normal but interesting happened.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO`：许多应用程序的默认日志级别，用于通知我们发生了正常但有趣的事情。'
- en: '`CONFIG`: Not the most used level, it is intended to be used for messages related
    to the configuration. In practice, applications and libraries often use `INFO`
    or `FINE` instead.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG`：不是最常用的级别，它旨在用于与配置相关的消息。在实践中，应用程序和库通常使用`INFO`或`FINE`。'
- en: '`FINE`,`FINER`,`FINEST`,`DEBUG`: These levels are intended to give low granularity
    information about the application. The message computing can be costly and it
    is not intended to be turned on in production in general. However, it can be a
    very useful piece of information when investigating an issue.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FINE`,`FINER`,`FINEST`,`DEBUG`：这些级别旨在提供关于应用程序的低粒度信息。消息计算可能很昂贵，通常不打算在生产环境中启用。然而，当调查问题时，它可能是一个非常有用的信息。'
- en: '`ALL`: Not used for the log record itself but only for component levels, it
    lets any message be logged.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALL`：不用于日志记录本身，但仅用于组件级别，它允许记录任何消息。'
- en: The log levels are sorted (associated with an integer) and a log record level
    is *active* if all the component levels are lower than the log record level. For
    instance, a `WARNING` message will be logged if the component levels are `INFO`
    or `FINE`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 日志级别按顺序排序（与整数相关联），如果所有组件级别都低于日志记录级别，则日志记录级别是*活动*的。例如，如果组件级别是`INFO`或`FINE`，则将记录`WARNING`消息。
- en: Logging invocations
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志调用
- en: Before looking at how to properly integrate loggers into your application using
    some common patterns, let's see what a logger invocation will trigger.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看如何使用一些常见模式将记录器正确集成到您的应用程序之前，让我们看看记录器调用将触发什么。
- en: 'A simple logger invocation, like  `logger.info(message)` , can be inspected
    to be represented as equivalent to the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的记录器调用，如`logger.info(message)`，可以检查以表示为以下步骤的等价：
- en: Check if the level of the logger is active; if not, exit
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查记录器级别是否处于活动状态；如果不是，则退出
- en: Create a log record (set the message and level, initialize the source of the
    log, class, method, and so on)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建日志记录（设置消息和级别，初始化日志源、类、方法等）
- en: Check if the message is filtered with a `Filter`; if the filter filters it,
    then exit
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查消息是否被`Filter`过滤；如果过滤器过滤了它，则退出
- en: 'For all handlers, publish the log record to the handler:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有处理器，将日志记录发布到处理器：
- en: 'Check the level of the handler versus the log record level, if not compatible
    then exit (note: this check is often done multiple times; it is fast because it
    is just an integer comparison)'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查处理器级别与日志记录级别的匹配情况，如果不兼容则退出（注意：此检查通常执行多次；因为它只是一个整数比较，所以很快）
- en: Format the log record (convert it to a `String`)
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化日志记录（将其转换为`String`）
- en: Write the formatted message to the actual backend (file, console, and so on)
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将格式化后的消息写入实际的后端（文件、控制台等）
- en: This high-level drilling down of a single logger invocation shows many interesting
    things about the loggers. The first one is that using a logger and having levels
    in all logging components allows the logging framework to bypass a lot of logic
    if the levels are not compatible. This is true at the logger level, and potentially
    at the filter level, and finally at the handler level. Then, we can identify that
    there are two layers where the logic depends on the configuration, and the processing
    time will be the function of the complexity of these elements, the filtering and
    the formatting. Lastly, the actual work—and generally the slowest part of the
    chain—is the backend interaction. Concretely, writing a line in a file is slow
    compared to the rest of the chain as it interacts with some hardware (your hard
    disk).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对单个记录器调用的逐层深入分析显示了关于记录器的许多有趣之处。首先，使用记录器并在所有日志组件中设置级别，允许日志框架在级别不兼容的情况下绕过大量逻辑。这在记录器级别是正确的，可能在过滤器级别，最终在处理器级别。然后，我们可以确定有两个层次，逻辑依赖于配置，处理时间将是这些元素复杂性的函数，包括过滤和格式化。最后，实际工作——通常链中最慢的部分——是与后端交互。具体来说，与硬件（你的硬盘）交互时，在文件中写入一行比链中的其他部分要慢。
- en: Filters
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器
- en: 'In JUL, there is no default filter implementation. But some common filters
    you can find in other frameworks or JUL extensions are:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUL中，没有默认的过滤器实现。但您可以在其他框架或JUL扩展中找到一些常见的过滤器：
- en: 'A time-based filter:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的过滤器：
- en: If the log message is outside a time range, then skip it
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果日志消息不在时间范围内，则跳过它
- en: If a log message is older than some configured duration, then skip it (can be
    useful depending on the work done before the filter in the chain and if the machine
    has a hot peak)
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果日志消息的年龄超过一些配置的持续时间，则跳过它（这取决于链中过滤器之前的工作以及机器是否有热点峰值）
- en: 'A **Mapped Diagnostic Context** (**MDC**) based filter: Typically, if an MDC
    value is matched (for example if MDC[''tenant''] is *hidden_customer),* then skip
    the message'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于**映射诊断上下文（MDC**）的过滤器：通常，如果MDC值匹配（例如，如果MDC['tenant']是*hidden_customer*），则跳过该消息
- en: 'Throttling: If you know you use a handler that can''t support more than 1,000
    messages/seconds—or if the actual backend, such as a database, can''t support
    more—then you can use a filter to enforce that limitation'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节流：如果你知道你使用的手柄无法支持每秒超过1,000条消息，或者如果实际的后端，例如数据库，无法支持更多，那么你可以使用过滤器来强制执行这个限制
- en: 'Regex-based: If the message doesn''t (or does) match a regex, then it is skipped'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于正则表达式的：如果消息不匹配（或匹配）正则表达式，则跳过
- en: These examples are just a short list of potential filters you can encounter,
    but it illustrates the fact that the complexity can be more or less important
    and thus the execution duration of the filter layer can be more or less fast.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子只是你可能会遇到的潜在过滤器的一个简短列表，但它说明了复杂性可能重要或不太重要，因此过滤器层的执行时间可能快或慢。
- en: Formatters
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化器
- en: 'As for filters, there are several formatters, and since it is really about
    how to convert the log record—the logging API—to the backend representation (String),
    then it can be more or less pricey. To get a high-level idea about that, here
    are some examples:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于过滤器，有几个格式化器，并且由于它实际上关于如何将日志记录——日志API——转换为后端表示（字符串），所以它可能更昂贵或更便宜。为了获得一个高级的概念，这里有一些例子：
- en: 'XML: Convert the log record to an XML representation; it generally uses string
    concatenation and logs all the record information (logger, thread, message, class,
    and so on).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML：将日志记录转换为XML表示形式；它通常使用字符串连接并记录所有记录信息（记录器、线程、消息、类等）。
- en: 'Simple: Just the log level and the message.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单：只是日志级别和消息。
- en: 'Pattern: Based on a configured pattern, the output is computed. Generally,
    the logging frameworks allows you to include, in this pattern, the thread identifier
    or name, the message, the log level, the class, the method, the exception if there
    is one, and so on.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式：基于配置的模式，输出被计算。通常，日志框架允许你在该模式中包含线程标识符或名称、消息、日志级别、类、方法、如果有异常则包括异常，等等。
- en: 'The default JUL pattern is `%1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s%n%4$s:
    %5$s%6$s%n`. This pattern leads to this sort of output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '默认的JUL模式是`%1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s%n%4$s: %5$s%6$s%n`。这个模式导致这种类型的输出：'
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will not detail the syntax here, but it reuses the Java `java.util.Formatter`
    syntax behind the `SimpleFormatter` which was used for that output. This implementation
    passes, to the formatter, the following parameters:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细说明语法，但它重用了`SimpleFormatter`背后的Java `java.util.Formatter`语法，该语法用于输出。此实现将以下参数传递给格式化器：
- en: Date of the log event
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志事件的日期
- en: Source of the log event (`class method`)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志事件的来源（`类方法`）
- en: Logger name
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录器名称
- en: Level
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别
- en: Message
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息
- en: Exception
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: 'What is interesting with this last type of formatter is that it lets you customize
    the output and change its formatting depending on your needs. For instance, instead
    of using the default format on two lines, you could set the format to be `%1$tb
    %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s %4$s: %5$s%6$s%n`, then the output would
    be:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '关于这种最后一种格式化器的有趣之处在于，它允许你自定义输出并根据自己的需求更改其格式。例如，你可以在两行上使用默认格式，但你也可以设置格式为`%1$tb
    %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s %4$s: %5$s%6$s%n`，然后输出将会是：'
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The big advantage is to really customize the output to your needs and potentially
    match a log forwarder like Splunk or Logstash.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的优势是真正根据你的需求自定义输出，并可能匹配像Splunk或Logstash这样的日志转发器。
- en: To activate this pattern with JUL, you need to set the system property `"-Djava.util.logging.SimpleFormatter.format=<the
    pattern>"`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要在JUL中激活此模式，你需要设置系统属性`"-Djava.util.logging.SimpleFormatter.format=<the pattern>"`。
- en: Using handlers
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用处理器
- en: When dealing with performance, it is important to define the trade-off you want
    in terms of logging. An interesting metric can be to compare the application without
    any active logging statement versus the ones you want to keep (for production).
    If you identify that the performance drastically decreases with logging activated,
    then you probably have a configuration issue, either in one of the logging layers
    or—more commonly—with the backend usage (such as overusing a remote database).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理性能问题时，定义你希望在日志方面做出的权衡是很重要的。一个有趣的指标可以是将没有任何活动日志语句的应用程序与你想保留的（用于生产）进行比较。如果你发现启用日志后性能急剧下降，那么你可能有一个配置问题，要么是在日志层中，要么更常见的是在与后端的使用（如过度使用远程数据库）有关。
- en: The handler, being the part *exiting* the application, is the one requiring
    most of the attention. This doesn't mean other layers are not important, but they
    are generally faster to check since they often lead to a constant evaluation time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器，作为退出应用程序的部分，是需要最多关注的。这并不意味着其他层不重要，但它们通常检查起来更快，因为它们往往会导致恒定的评估时间。
- en: There are several implementations of handlers, but it is not rare to have specific
    ones in companies because you want to target a specific backend or you want custom
    integration. In these cases, you have to make sure it doesn't introduce some bottleneck
    or performance issues. To illustrate that statement, we will use a case where
    you want to send the log records to an HTTP server in JSON format. For each message,
    if you send a request, then you can send many requests as threads in parallel
    and you will pay the HTTP latency for each logger invocation. When you think that
    a method can have multiple logger invocations and that a logger can have multiple
    handlers (you can log the same messages in the console and a file and a server),
    then you quickly understand this synchronous *per message* first implementation
    will not scale for very long.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的实现有几种，但在公司中拥有特定实现并不罕见，因为你可能想要针对特定的后端或进行定制集成。在这些情况下，你必须确保它不会引入一些瓶颈或性能问题。为了说明这一点，我们将使用一个例子，其中你想要以
    JSON 格式将日志记录发送到 HTTP 服务器。对于每条消息，如果你发送一个请求，那么你可以并行发送多个请求作为线程，并且你将为每个日志调用支付 HTTP
    延迟。当你想到一个方法可以有多个日志调用，并且一个日志可以有多个处理器（你可以在控制台、文件和服务器中记录相同的消息），那么你很快就会理解这种按消息同步 *首次*
    实现不会长期扩展。
- en: This is why all the backend integrations, which are implying remote operations,
    are using alternative implementations and generally support some bulking of the
    messages to send them in chunks (multiple messages at once). Then, the handler
    reception of the message just triggers an addition in a *stack*, and later, another
    condition will trigger the actual request (HTTP request in our previous case).
    In terms of performance, we converted a high latency implementation in a low latency
    operation, as the operation is as fast as adding an object to a queue.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为所有后端集成，它们都暗示着远程操作，所以都在使用替代实现，并且通常支持将消息批量发送（一次发送多个消息）。然后，处理器的消息接收只是触发在 *栈*
    中的添加，稍后，另一个条件将触发实际请求（在我们之前的例子中是 HTTP 请求）。在性能方面，我们将高延迟实现转换为低延迟操作，因为操作的速度就像将对象添加到队列中一样快。
- en: Logging components and Java EE
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志组件和 Java EE
- en: 'It can be tempting to reuse Java EE to implement logging components. It is
    not impossible, but there are some points to consider before doing so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java EE 来实现日志组件可能会有诱惑力。虽然并非不可能，但在这样做之前，有一些要点需要考虑：
- en: JUL doesn't always support the loading of classes with the container or application
    classloader, so you may need a facade implementation that contextually loads the
    container or application classes. In other words, you will not always be able
    to programmatically depend on CDI, but you may need some reflection which has
    a cost you want to minimize. So, make sure to keep the results of your CDI lookup
    if you can.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUL 并不总是支持使用容器或应用程序类加载器加载类，因此你可能需要一个上下文加载容器或应用程序类的门面实现。换句话说，你并不总是能够程序化地依赖于 CDI，但你可能需要一些反射，而这会带来你想要最小化的成本。所以，如果你能的话，确保保留你的
    CDI 查找结果。
- en: In the first chapters, we looked at the Java EE layers. Make sure you don't
    rely on something too heavy for a logger implementation to avoid being impacted
    by all this work and to avoid hiding the fact that you have *an application under
    the application* through your loggers.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前几章中，我们探讨了Java EE层。确保你不会依赖于对日志实现来说过于沉重的某些东西，以避免受到所有这些工作的影响，并避免通过你的记录器隐藏你有一个*应用程序下的应用程序*的事实。
- en: Logging context is not controlled. Generally, you don't know when a logger is
    used. So, if you implement a component using CDI, make sure you use features available
    only in all contexts. Concretely, don't use `@RequestScoped` if you don't use
    the `RequestContextController` to activate the scope yourself. Also, ensure you
    have configured the *EE* component on a logger only, used in an EE context.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志上下文不受控制。通常，你不知道何时使用记录器。因此，如果你使用CDI实现一个组件，确保你使用所有上下文都有的功能。具体来说，如果你没有使用`RequestContextController`来激活作用域，就不要使用`@RequestScoped`。此外，确保你只在一个用于EE上下文的记录器上配置了*EE*组件。
- en: It is not impossible to do a logging-EE bridge, but for logging, we generally
    want to be very efficient and as raw as possible. See it more as a potential fallback
    if you can't modify the application than the opposite by default. In a realistic
    manner, it is better to send an EE event you observe and call a logger from an
    observer, than the opposite.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个日志-EE桥接不是不可能的，但对于日志记录，我们通常希望非常高效且尽可能原始。更确切地说，它更像是一个潜在的回退方案，如果你不能修改应用程序的话，而不是默认的相反方案。从现实的角度来看，最好发送你观察到的EE事件，并从观察者那里调用记录器，而不是相反。
- en: Logging patterns
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志模式
- en: There are but a few important logging patterns you can utilize to try to minimize
    the logging overhead implied, without any benefit from a functional point of view.
    Let's go through the most common ones.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要的日志模式你可以利用来尝试最小化隐含的日志开销，而不会从功能角度获得任何好处。让我们来看看最常见的几个。
- en: Testing your level
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的级别
- en: The most important thing about a log message is its level. It is the information
    allowing you to efficiently ignore the messages - and their formatting/templating
    - if they will be ignored later anyway.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于日志消息最重要的东西是其级别。这是允许你高效忽略消息——以及它们的格式化/模板化——的信息，如果它们最终会被忽略的话。
- en: 'For instance, take this method that relies on loggers at different levels:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个依赖于不同级别日志记录器的这个方法：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method is mixing *debug* and *info* log messages. Nevertheless, it is very
    likely that the *debug* messages will not be activated in production, but *info *messages
    will be if you use the *info* level as optional messages, then do the same reasoning
    with the *warning* level. For that reason, it is pointless to log the *debug*
    messages in most cases. It is also useless to compute the concatenations of these
    messages as they will not be logged.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法混合了*调试*和*信息*日志消息。尽管如此，在大多数情况下，*调试*消息不太可能被激活，但如果你将*信息*级别作为可选消息使用，那么对*警告*级别进行相同的推理。因此，在大多数情况下记录*调试*消息是没有意义的。同样，计算这些消息的连接也是无用的，因为它们不会被记录。
- en: 'To avoid these computations—and don''t forget a `toString()` can be complex
    in some cases or at least `long` to compute—a common pattern is to test the log
    level in the application yourself, instead of waiting for the logging framework
    to do it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些计算——别忘了在某些情况下`toString()`可能很复杂，或者至少计算起来`long`——一个常见的模式是自己在应用程序中测试日志级别，而不是等待日志框架去完成：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Simply wrapping the rarely logged messages in a `isLoggable()` conditional block
    will do a quick test against the logger level and bypass the message computation,
    and all the logging chains most of the time, ensuring the performance is not too
    affected by debug statements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将很少记录的消息包裹在`isLoggable()`条件块中，将对日志记录器级别进行快速测试，并绕过消息计算，以及大多数情况下绕过所有日志链，确保性能不会因调试语句而受到太大影响。
- en: 'Since Java 8, there has been an alternative to that pattern which is quite
    interesting: using `Supplier<>` to create the message. It provides a way to compute
    the message rather than the message itself. This way, the code is more condensed
    thanks to the lambda which is compatible with the related signatures. But the
    cost of the string evaluation is not paid anyway:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 8以来，有一个有趣的替代模式：使用`Supplier<>`来创建消息。它提供了一种计算消息而不是消息本身的方法。这样，由于lambda与相关签名兼容，代码更加紧凑。但无论如何，字符串评估的成本并没有支付：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we passed a lambda computing the actual message only if the log statement
    passed the first test, which is about the log level of the logger. This is really
    close to the previous pattern but still a bit more costly than an integer test
    which is generally the `isLoggable()` implementation. Yet, the overhead is not
    that significant and the code is less verbose, but generally efficient enough.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递了一个lambda表达式，仅在日志语句通过了第一个测试（即日志记录器的日志级别）时才计算实际的消息。这确实非常接近之前的模式，但仍然比通常的`isLoggable()`实现中的整数测试要昂贵一些。然而，开销并不大，代码也更简洁，但通常足够高效。
- en: If you use the same log level multiple times, it can be worth factorizing the
    log level check a single time at the beginning of the method, instead of calling
    it multiple times in the same methods. The more you use a logger abstraction,
    and therefore go through layers, the more it will be true. Since it is a very
    simple optimization—your IDE can even suggest you to do it for you—you shouldn't
    hesitate to do it. Though, don't do it at class level (such as storing the loggable
    test in a `@PostConstruct`; since most logger implementations support dynamic
    levels; you could break that feature).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次使用相同的日志级别，在方法开始时一次性将日志级别检查因式分解可能是有价值的，而不是在相同的方法中多次调用它。你使用日志抽象越多，因此经过的层级越多，这一点就越正确。由于这是一个非常简单的优化——你的IDE甚至可以建议你这样做——你不应该犹豫去实施它。尽管如此，不要在类级别（例如，将可记录的测试存储在`@PostConstruct`中）这样做，因为大多数日志实现都支持动态级别；你可能会破坏该功能）。
- en: Using templates in your messages
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的消息中使用模板
- en: In the previous section, we looked at how to bypass the logging of a message.
    With JUL, it is often done with the methods called log levels, but there is a
    more generic log method  called `log`, which can take the level, the message (or
    a key in a resource bundle if you internationalize the messages), and an object
    array parameter. This type of method exists in all frameworks and most of them
    will also provide some particular signatures with one, two, or more parameters
    to make it smoother to use.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了如何绕过消息的日志记录。在JUL中，这通常是通过调用具有日志级别的日志方法来完成的，但有一个更通用的日志方法称为`log`，它可以接受级别、消息（如果你对消息进行国际化，则是一个资源包中的键）以及一个对象数组参数。此类方法存在于所有框架中，其中大多数也会提供一些特定的签名，具有一个、两个或更多参数，以使其使用更加流畅。
- en: 'In any case, the idea is to use the message as a pattern and the parameters
    to valorize some variables of the message. This is the feature this log pattern
    uses:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，想法是使用消息作为模式，并使用参数来赋值消息中的某些变量。这正是此日志模式使用的功能：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This log statement will replace the `{i}` templates with the i^(th) value in
    the `Object[]` array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此日志语句将用`Object[]`数组中的第i个值替换`{i}`模板。
- en: Using this pattern is interesting as it avoids computing the actual string value
    if not needed. This solution seems better than the previous `isLoggable()` check
    in terms of code impact, right? It actually depends on the logger implementation.
    JUL doesn't support it. But for the frameworks supporting parameters without arrays,
    they can have some optimization, which would make this assumption right. However,
    for JUL or all the cases where you have enough parameters to require an array
    creation, it is not right. The fact that you have to create an array is impactful
    and therefore it is better to skip it if you don't need it, which means to fallback
    on the previous pattern or the `Supplier<>` based API.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模式很有趣，因为它避免了在不需要时计算实际的字符串值。从代码影响的角度来看，这似乎比之前的`isLoggable()`检查要好，对吧？实际上，这取决于日志实现。JUL不支持它。但是，对于支持参数而不使用数组的框架，它们可以进行一些优化，从而使这个假设成立。然而，对于JUL或所有需要创建数组以存储足够参数的情况，这是不正确的。你必须创建数组的事实具有影响，因此如果你不需要它，最好是跳过它，这意味着回退到之前的模式或基于`Supplier<>`的API。
- en: Asynchronous or not?
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步或非异步？
- en: Due to modern requirements in terms of scaling, the loggers needed to be enhanced
    to support a higher message rate, but still needed to be less impactful on the
    application performance itself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现代对扩展性的要求，需要增强日志记录器以支持更高的消息速率，但仍然需要减少对应用程序性能本身的影响。
- en: The first step to reduce the latency of a logger is to make the handlers asynchronous.
    This is not yet standard with JUL but you can find some libraries providing that
    feature—some containers like Apache TomEE even provide it out of the box. The
    idea is exactly the one we described in the section about handlers, compute the
    minimum context for the log record and push the record in a *queue* in the caller
    thread, then actually *store*/publish the message in another thread (or threads
    depending on the backend).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 减少日志记录延迟的第一步是使处理程序异步。在 JUL 中这还不是标准功能，但你可以找到一些提供该功能的库——一些容器，如 Apache TomEE，甚至提供开箱即用的功能。这个想法与我们关于处理程序的章节中描述的完全一样，计算日志记录的最小上下文，然后在调用者线程中的
    *队列* 中推送记录，然后在另一个线程（或线程，取决于后端）中实际 *存储/发布* 消息。
- en: This pattern already solves most of the logger impact in terms of performance,
    but some logging frameworks (such as Log4j2) go further, making the loggers themselves
    asynchronous. Since the filtering (and sometimes formatting) is now fully asynchronously
    done, then the caller duration is way smaller and the performance impact is reduced
    a lot (still, considering, you have enough CPU to handle this additional work
    as you execute more code in parallel).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式已经解决了大多数关于性能的日志记录器影响，但一些日志框架（如 Log4j2）更进一步，使日志记录器本身异步。由于过滤（有时还有格式化）现在是完全异步完成的，因此调用者的持续时间大大缩短，性能影响也大大降低（仍然，考虑到你有足够的
    CPU 来处理这个额外的工作，因为你并行执行更多的代码）。
- en: If you add some modern implementation to the asynchronous handling, based on
    the ring buffer pattern, as Log4j2 did using the disruptor ([https://lmax-exchange.github.io/disruptor/](https://lmax-exchange.github.io/disruptor/))
    library, then you have a solution scaling very well. More you will have threads,
    more the impact of such an implementation will be significative, even compared
    to an asynchronous handler (appender for log4j2).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加一些基于环形缓冲区模式的现代实现来处理异步，就像 Log4j2 使用 disruptor ([https://lmax-exchange.github.io/disruptor/](https://lmax-exchange.github.io/disruptor/))
    库所做的那样，那么你将有一个非常可扩展的解决方案。线程越多，这种实现的冲击力就越显著，甚至与异步处理程序（log4j2 的追加器）相比。
- en: Logging implementations – which one to pick
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志实现 – 选择哪一个
- en: Logging is one of the oldest topics you can encounter in computer science, but
    it is also one that has been solved many times. Understand that you will find
    lots of frameworks about logging. Let's have a quick look at them and see how
    they can sometimes relate.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是你在计算机科学中可以遇到的最早的话题之一，但它也是被多次解决的问题之一。理解你将找到许多关于日志的框架。让我们快速看一下它们，看看它们有时是如何相关的。
- en: Logging facade – the good bad idea
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志门面 – 好坏参半的想法
- en: Logging facades are frameworks such as SLF4J ([https://www.slf4j.org/](https://www.slf4j.org/)),
    commons-logging, jboss-logging, or more recently, the log4j2 API ([https://logging.apache.org/log4j/2.x/](https://logging.apache.org/log4j/2.x/)).
    They intend to provide a uniform API usable with any sort of logging implementation.
    You must really see it as an API (as Java EE is an API), and the logging frameworks
    as implementations (as GlassFish, WildFly, or TomEE are Java EE implementations).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 日志门面是像 SLF4J ([https://www.slf4j.org/](https://www.slf4j.org/))、commons-logging、jboss-logging
    或更近期的 log4j2 API ([https://logging.apache.org/log4j/2.x/](https://logging.apache.org/log4j/2.x/))
    这样的框架。它们的目的是提供一个统一的 API，可以与任何类型的日志实现一起使用。你必须真正将其视为一个 API（就像 Java EE 是一个 API 一样），而日志框架则是实现（就像
    GlassFish、WildFly 或 TomEE 是 Java EE 实现）。
- en: 'These facades need a way to find the implementation they have to use. You can
    encounter several strategies, such as the following ones:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些门面需要一种方式来找到它们必须使用的实现。你可能遇到几种策略，如下所示：
- en: SLF4J, for instance, will look up a particular class all implementations provide
    in their distribution (called *bindings* for SLF4J), and once instantiated it
    will give SLF4J API the link with the final implementation (JUL, Log4J, Logback,
    and so on). The issue here is that you cannot have multiple implementations in
    the same classloader and you cannot just configure the one you want.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，SLF4J 将查找所有实现在其分发中提供的特定类（在 SLF4J 中称为 *绑定*），一旦实例化，它将给 SLF4J API 提供与最终实现（JUL、Log4J、Logback
    等）的链接。这里的问题是，你无法在同一个类加载器中拥有多个实现，你也不能只配置你想要的那个。
- en: Commons-logging will read a configuration file to know which implementation
    to pick.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Commons-logging 将读取配置文件以确定选择哪个实现。
- en: A global system property-based configuration with a hardcoded default allowing
    to select the implementation to use.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于全局系统属性配置的硬编码默认值，允许选择要使用的实现。
- en: Using a logging facade is generally a good idea as it allows your code, or the
    code of the libraries you use, to be decoupled from the logging implementation,
    delegating the choice of that implementation to the application packager or the
    deployer. It allows you to run it in all circumstances without you having to care
    about it during development.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志外观通常是一个好主意，因为它允许你的代码，或者你使用的库的代码，与日志实现解耦，将实现的选择委托给应用程序打包者或部署者。它允许你在所有情况下运行它，而无需你在开发期间关心它。
- en: Even ignoring the fact that there are multiple implementations of such an API,
    which makes things complicated already, their usage is not that elegant depending
    on the implementation you use. Several implementations will need to fill some
    parameters that are costly to evaluate.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 即使忽略存在多个此类API实现的事实，这已经使事情变得复杂，但根据你所使用的实现，它们的用法并不那么优雅。一些实现将需要填写一些代价高昂的参数。
- en: The best example is the computation of the source class and method. In several
    implementations, it will be done by creating an `Exception` to get its associated
    stack trace and, after having dropped the known caller of the logging framework,
    will deduce the business caller. In a Java EE environment, and due to the stacks
    it uses to provide a simple programming model, the exception stack can be huge
    and *slow* to compute and fill (allocate the array). This means that each log
    message will be slowed down a bit to implement the bridge between this facade
    API and the actual logger implementation you use.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的例子是计算源类和方法。在几个实现中，这将通过创建一个 `Exception` 来获取其关联的堆栈跟踪，并在丢弃已知的日志框架调用者之后，推断出业务调用者。在Java
    EE环境中，由于它使用的堆栈以提供简单的编程模型，异常堆栈可能非常大且 *慢*（分配数组）。这意味着每个日志消息都会稍微减慢一点，以实现这个外观API和实际使用的日志实现之间的桥梁。
- en: 'For that reason, it can be worth checking the implementation you use with such
    a facade. For the most common one, SLF4J, there are two well-known implementations
    very well integrated with the API:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，检查你使用的此类外观实现可能是有价值的。对于最常见的一个，SLF4J，有两个非常知名的实现与API紧密结合：
- en: 'Logback: A native implementation of the API'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Logback：API的本地实现
- en: 'Log4j2: Has got an SLF4J direct implementation (binding)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Log4j2：具有SLF4J直接实现（绑定）
- en: Logging frameworks
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志框架
- en: 'As mentioned, there are several logging frameworks you can encounter. The most
    famous, and the ones you have probably already heard about, are:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可能会遇到几个日志框架。最著名的是，你可能已经听说过的，包括：
- en: 'Log4j1: The historical standard de facto, slowly replaced by log4j2.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Log4j1：历史上事实上的标准，逐渐被log4j2取代。
- en: 'Log4j2: Probably one of the most advanced implementations today. Supports asynchronous
    loggers and has a ring buffer integration.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Log4j2：可能是今天最先进的实现之一。支持异步日志记录和环形缓冲区集成。
- en: 'Logback: The native SLF4J implementation. It was probably the best choice before
    log4j2 was done.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Logback：SLF4J的本地实现。在log4j2完成之前，这可能是最佳选择。
- en: 'Java Util Logging: The JVM standard logging API. Not the most evolved API,
    but it works and doesn''t require any dependency, though, you may need some custom
    integrations (handlers) for production. Check out your server which can already
    provide some solutions here.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java Util Logging：JVM标准日志API。虽然不是最先进的API，但它可以工作，并且不需要任何依赖项，尽管如此，你可能需要一些自定义集成（处理程序）以用于生产。检查你的服务器，它可能已经提供了一些解决方案。
- en: Each of these share the concepts we just went through, but may have some small
    differences. To let you work faster with them, we will quickly go through these
    implementations to define the semantics used by the framework and show you how
    to configure each of them. When you do some benchmarks, it is very important to
    know how to configure the logging and guarantee it doesn't slow down your performance
    due to a bad configuration.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都共享我们刚刚讨论过的概念，但可能有一些小的差异。为了让你更快地使用它们，我们将快速浏览这些实现，以定义框架使用的语义，并展示如何配置每个实现。当你进行基准测试时，了解如何配置日志并确保它不会因为配置不当而减慢性能是非常重要的。
- en: Log4j
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Log4j
- en: 'Logj4 (1.x) uses the `org.apache.log4j` base package. Here are the logging
    concepts we talked about adapted to log4j1 semantic:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Logj4 (1.x) 使用 `org.apache.log4j` 基础包。以下是针对 log4j1 语义调整的我们讨论过的日志概念：
- en: '| **Concept** | **Name** |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **概念** | **名称** |'
- en: '| Logger | Logger |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 记录器 | 记录器 |'
- en: '| Logger Factory | Logger |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 日志工厂 | 记录器 |'
- en: '| Handler | Appender |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 处理程序 | 追加器 |'
- en: '| Filter | Filter |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 过滤器 | 过滤器 |'
- en: '| Formatter | Layout |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 格式化器 | 布局 |'
- en: '| Level | Level |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 级别 | 级别 |'
- en: Most of the concepts are the same as in JUL, but with a few different names.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数概念与JUL相同，但有一些不同的名称。
- en: 'In terms of usage, it is the same as in JUL, except it uses another package:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用方面，它与JUL相同，除了它使用另一个包：
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What is a bit different is the configuration. It uses a `log4j.properties`
    or `log4j.xml` in the classpath (by default) which looks like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的不同之处在于配置。它使用类路径中的`log4j.properties`或`log4j.xml`（默认情况下），其外观如下：
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this sample configuration the root logger (default) level is `DEBUG` and
    it will use a `stdout` appender. The appender is using `ConsoleAppender`; it will
    log the messages on the `System.out` and uses a pattern layout with a custom pattern
    (`ConversionPattern`). The package `com.packt.quote` log level is set to `WARN`.
    So, loggers using this name or a sub-name of this package will only log `WARN`
    and `ERROR` messages.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此示例配置，根日志记录器（默认）级别为`DEBUG`，它将使用`stdout`追加器。追加器使用`ConsoleAppender`；它将在`System.out`上记录消息，并使用自定义模式（`ConversionPattern`）的格式布局。`com.packt.quote`包的日志级别设置为`WARN`。因此，使用此名称或此包子名称的日志记录器将仅记录`WARN`和`ERROR`消息。
- en: Log4j2
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Log4j2
- en: 'Log4j2 was obviously inspired by Log4j1 but was completely rewritten. It still
    has some differences and it is completely different in terms of behavior and performance.
    Here is the concept mapping for log4j2:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Log4j2明显受到了Log4j1的启发，但被完全重写。它在行为和性能方面仍然有一些差异。以下是log4j2的概念映射：
- en: '| **Concept** | **Name** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **概念** | **名称** |'
- en: '| Logger | Logger |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 日志记录器 | 日志记录器 |'
- en: '| Logger Factory | LoggerManager |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 日志工厂 | 日志管理器 |'
- en: '| Handler | Appender |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 处理器 | 追加器 |'
- en: '| Filter | Filter |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 过滤器 | 过滤器 |'
- en: '| Formatter | Layout |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 格式化器 | 布局 |'
- en: '| Level | Level |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 级别 | 级别 |'
- en: 'The configuration has some fallbacks, but the default file is looked up in
    the classpath and is called `log4j2.xml`. It uses a different syntax than the
    XML version of Log4j1, based on the new plugin system of Log4j2, to have a nicer
    syntax (less technical):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 配置有一些回退，但默认文件在类路径中查找，并称为`log4j2.xml`。它使用与Log4j1的XML版本不同的语法，基于Log4j2的新插件系统，以获得更简洁的语法（更少的技术性）：
- en: '[PRE15]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the same sort of configuration as the one in the previous section, but
    it uses this new syntax that relies on the plugin names (`Console` is the name
    of the console appender in log4j2 for instance). Nevertheless, we still have the
    same structure where loggers are defined in a loggers block with the specific
    root logger, and where appenders have their own block linked to the loggers through
    a reference/idenfitier (`ref`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一节中的配置类似，但它使用这种新的语法，该语法依赖于插件名称（例如，在log4j2中，`Console`是控制台追加器的名称）。尽管如此，我们仍然有相同的结构，其中日志记录器在日志记录器块中定义，具有特定的根日志记录器，并且追加器有自己的块，通过引用/标识符（`ref`）与日志记录器链接。
- en: Log4j2 has other nice features such as the hot reloading of the configuration,
    JMX extensions, and so on, which can be worth a look. It can help you change the
    logging configuration without restarting the application during your benchmarks.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Log4j2具有其他一些不错的功能，如配置的热重载、JMX扩展等，这些都值得一看。它可以帮助你在基准测试期间更改日志配置而无需重新启动应用程序。
- en: Logback
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Logback
- en: 'Logback is a native implementation of SLF4J and an advanced logging implementation.
    Here is its mapping with the concepts we talked about:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Logback是SLF4J的原生实现，是一个高级日志实现。以下是它与我们所讨论的概念的映射：
- en: '| **Concept** | **Name** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **概念** | **名称** |'
- en: '| Logger | Logger (from SLF4J) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 日志记录器 | 日志记录器（来自SLF4J） |'
- en: '| Logger Factory | LoggerFactory (from SLF4J) |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 日志工厂 | 日志工厂（来自SLF4J） |'
- en: '| Handler | Appender |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 处理器 | 追加器 |'
- en: '| Filter | Filter |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 过滤器 | 过滤器 |'
- en: '| Formatter | Encoder/Layout |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 格式化器 | 编码器/布局 |'
- en: '| Level | Level |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 级别 | 级别 |'
- en: Note that logback also has the concept of `Encoder` to link the messages to
    `byte[]`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，logback还有将消息链接到`byte[]`的`Encoder`概念。
- en: 'The configuration relies, by default, on a `logback.xml` file in the classpath,
    looking like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，配置依赖于类路径中的`logback.xml`文件，其外观如下：
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a configuration close to the previous one (log4j1, log4j2) and recognizes
    the same kind of configuration, except the `encoder` layer wrapping the `pattern`.
    This is mainly because the encoder will pass a `byte[]` value to the appender
    and the pattern will pass a `String` to the encoder, allowing the implementation
    to be more easily composed, even if rarely used.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种接近之前配置（log4j1，log4j2）的配置，并识别相同类型的配置，除了`encoder`层包裹`pattern`。这主要是因为编码器将传递一个`byte[]`值给追加器，而模式将传递一个`String`给编码器，这使得实现更容易组合，即使很少使用。
- en: JUL
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUL
- en: We used JUL to name the concepts we talked about, so we don't need a mapping
    table for the concept. Yet, it is interesting to see how JUL is configured since
    it is used in lots of containers.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用JUL来命名我们讨论的概念，因此我们不需要为概念创建映射表。然而，了解JUL的配置方式很有趣，因为它被广泛应用于许多容器中。
- en: Very high-level JUL uses a `LogManager`, which is the Logger Factory (hidden
    behind the `Logger.getLogger(...)`Logger Factory).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 高级的JUL使用一个`LogManager`，这是记录器工厂（隐藏在`Logger.getLogger(...)`记录器工厂后面）。
- en: The `LogManager` is instantiated from the class passed to the `java.util.logging.config.class` system
    property. If not set, the default implementation will be used, but note that most
    EE containers will override it to support additional features such as a configuration
    per application, for instance, or a custom configuration, generally dynamic and
    managed through a nice UI.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogManager`是从传递给`java.util.logging.config.class`系统属性的类实例化的。如果没有设置，将使用默认实现，但请注意，大多数EE容器会覆盖它以支持额外的功能，例如每个应用程序的配置，例如，或自定义配置，通常是动态的，并通过一个很好的UI进行管理。'
- en: 'The configuration is located with the system property `java.util.logging.config.file`
    or falls back on `${java.jre.home}/lib/logging.properties`—note that Java 9 used
    the folder `conf` instead of `lib`. The syntax of this properties file is the
    same as we saw earlier:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 配置位于系统属性`java.util.logging.config.file`中，或者回退到`${java.jre.home}/lib/logging.properties`——请注意，Java
    9使用了`conf`文件夹而不是`lib`。此属性文件的语法与我们之前看到的相同：
- en: '[PRE17]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At the end of the snippet, we identify how to set a level to a package (the
    key is just suffixed by `.level` and the value is the level name). The same sort
    of logic applies to the default logger, which has an empty name, so its level
    is set using the `.level` key directly. The `handlers` key gets a list of handlers
    to configure (comma separated). It is generally a fully qualified name of a handler.
    Then, the two blocks in the middle, starting with handler names, are the handler
    configurations. It generally uses a dotted notation (`<handler class>.<configuration>
    = <value>`), but there is no obligation since the handler has access to all the
    properties through the `LogManager`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段的末尾，我们确定了如何为包设置级别（键只是后缀为`.level`，值是级别名称）。同样的逻辑也适用于默认的记录器，它有一个空的名字，因此其级别是通过`.level`键直接设置的。`handlers`键获取要配置的处理程序列表（以逗号分隔）。它通常是处理程序的完全限定名。然后，中间的两个块，从处理程序名称开始，是处理程序配置。它通常使用点分表示法（`<handler
    class>.<configuration> = <value>`），但这是可选的，因为处理程序可以通过`LogManager`访问所有属性。
- en: Apache Tomcat/TomEE `ClassLoaderLogManager` allows you to prefix the handler
    with a custom prefix value starting with a number. It enables you to define N
    times the same handler with different configuration, which is not supported out
    of the box by JUL, which can only define a handler once.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Tomcat/TomEE的`ClassLoaderLogManager`允许你使用一个以数字开头的自定义前缀值来前缀处理程序。它使你能够定义N次相同的处理程序，具有不同的配置，这是JUL默认不支持的功能，JUL只能定义一个处理程序一次。
- en: Choosing an implementation
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择实现
- en: If you can choose your implementation, you should check where you want to send
    your logs and pick the implementation already doing what you need, or the implementation
    which has a very close feature. Then, if multiple implementations fit your requirements,
    you need to check which one is the fastest.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以选择你的实现，你应该检查你想要发送日志的地方，并选择已经做了你所需要的工作的实现，或者具有非常接近功能的实现。然后，如果有多个实现符合你的要求，你需要检查哪一个是最快的。
- en: Starting from log4j2 or logback is generally a good choice. Yet, in practice,
    you rarely have the choice and part of your stack is imposed by your environment
    (dependencies and containers). Thus, it is highly probable you will need to configure
    JUL as well. In such a case, a good option is to check if you can reuse your container
    backbone without being dependent on your container in terms of code (that is,
    you can use the JUL API and delegate, to your container, the JUL configuration
    for instance). Then, you need to evaluate if JUL will fit your runtime needs in
    terms of performance. JUL gets lots of bad reviews on the internet, but it is
    more than sufficient for a lot of applications asynchronously logging into a file.
    Don't disregard it without evaluating it against your concrete needs. It can avoid
    configuration headaches and dependencies in a lot of cases.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从log4j2或logback开始通常是不错的选择。然而，在实践中，您很少有这样的选择，您的一部分堆栈是由您的环境（依赖项和容器）强加的。因此，您很可能还需要配置JUL。在这种情况下，一个好的选择是检查您是否可以重用您的容器骨干，而无需在代码上依赖于您的容器（也就是说，您可以使用JUL
    API并委托给容器，例如JUL配置）。然后，您需要评估JUL是否满足您在性能方面的运行时需求。JUL在互联网上收到了很多负面评价，但它对于许多异步将日志记录到文件的应用程序来说已经足够了。在没有评估您具体需求的情况下，不要忽视它。它可以在很多情况下避免配置头痛和依赖。
- en: Another criteria can be the easiness to redirect all logs to the same logging
    stack. One of the best ones in that area is log4j2, which supports pretty much
    all integrations (SLF4J, commons-logging, log4j1, log4j2, and so on).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个标准可以是将所有日志重定向到同一日志堆栈的简便性。在这方面最好的之一是log4j2，它几乎支持所有集成（SLF4J，commons-logging，log4j1，log4j2，等等）。
- en: 'If you use file-based handlers/appenders, probably the most common use case,
    you should also have a look at the rotation policies. It is generally configurable
    and the most common strategies are:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用基于文件的处理器/追加器，这可能是最常见的情况，您还应该查看轮换策略。这通常是可配置的，最常见的方法包括：
- en: 'Per day: Each day, you get a new log file for the handler (mylog.2017-11-14.log, mylog.2017-11-15.log,
    and so on).'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每日：每天，处理器都会为新的日志文件创建一个新的日志文件（例如，mylog.2017-11-14.log，mylog.2017-11-15.log，等等）。
- en: 'At restart: Each time the server is restarted, a new log file is created. Note
    this strategy doesn''t work well except for batch instances or no long running
    instances.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重启时：每次服务器重启时，都会创建一个新的日志文件。请注意，这种策略对于批处理实例或没有长时间运行的实例除外。
- en: 'Per size: If the log file size exceeds some disk space, then create a new one.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按大小：如果日志文件大小超过某些磁盘空间，则创建一个新的文件。
- en: Note that all these strategies can often be mixed or accumulated. Only JUL will
    not support it out of the box, but containers often try to fill that gap. It is
    not because your container uses JUL that you don't have this feature. Don't hesitate
    to have a look at your container logging configuration and investigate it before
    rejecting JUL as an API.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些策略通常可以混合或累积。只有JUL不支持这一点，但容器通常会尝试填补这一空白。并不是因为您的容器使用JUL，您就没有这个功能。在拒绝JUL作为API之前，不要犹豫去查看您的容器日志配置并对其进行调查。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at why logging is important to get a good and easy
    monitoring level. We also saw that a logging statement must be as minimally impactful
    on performance as possible so as not to defeat the optimization and coding you
    may have done elsewhere in your application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了为什么日志记录对于获得良好且易于监控的级别很重要。我们还看到，日志语句必须尽可能减少对性能的影响，以免抵消您在应用程序的其他部分可能已经进行的优化和编码。
- en: This chapter gave you some common and simple patterns that can help you to rely,
    as much as possible, on the logging framework to make sure you maintain good performance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了一些常见且简单的模式，可以帮助您尽可能依赖日志框架，以确保您保持良好的性能。
- en: Finally, we saw that several implementations may need to be configured in your
    applications, but that they will all share the same concepts, and that it is possible
    to rely on a single API, or even a single implementation from multiple APIs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们注意到在您的应用程序中可能需要配置多个实现，但它们都将共享相同的概念，并且可以依赖于单个API，甚至来自多个API的单个实现。
- en: At this point of the book, you know what Java EE does and how to code and monitor
    an application. Now it is time to look at how you should approach a benchmark.
    This will be the topic of our next chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，您已经了解了Java EE的功能以及如何编码和监控应用程序。现在，是时候看看您应该如何对待基准测试了。这将是下一章的主题。
