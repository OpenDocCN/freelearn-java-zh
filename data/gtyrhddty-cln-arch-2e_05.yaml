- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Implementing a Use Case
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用例
- en: Let’s finally look at how we can manifest the architecture we have discussed
    in actual code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最终看看我们如何能在实际代码中实现所讨论的架构。
- en: Since the application, web, and persistence layers are so loosely coupled in
    our architecture, we’re totally free to model our domain code as we see fit. We
    can do **Domain-Driven Design** (**DDD**), implement a rich or anemic domain model,
    or invent our own way of doing things.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在我们的架构中，应用程序、Web和持久化层耦合得非常松散，我们可以完全自由地以我们觉得合适的方式对领域代码进行建模。我们可以进行**领域驱动设计**（**DDD**），实现一个丰富的或贫血的领域模型，或者发明我们自己的做事方式。
- en: This chapter describes an opinionated way of implementing use cases within the
    Hexagonal Architecture style we introduced in previous chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了在之前章节中引入的六边形架构风格中实现用例的一种有见地的方法。
- en: As is fitting for a domain-centric architecture, we’ll start with a domain entity
    and then build a use case around it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以领域为中心的架构来说，我们将从一个领域实体开始，然后围绕它构建一个用例。
- en: Implementing the domain model
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现领域模型
- en: 'We want to implement the use case of sending money from one account to another.
    One way to model this in an object-oriented fashion is to create an `Account`
    entity that allows us to withdraw money from a source account and deposit it into
    a target account:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望实现将资金从一个账户发送到另一个账户的用例。以面向对象的方式建模的一种方法是为允许我们从源账户取款并将资金存入目标账户创建一个`Account`实体：
- en: '![](img/code-5.1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![代码5.1](img/code-5.1.jpg)'
- en: The `Account` entity provides the current snapshot of an actual account. Every
    withdrawal from and deposit to an account is captured in an `Activity` entity.
    Since it would not be wise to always load all activities of an account into memory,
    the `Account` entity only holds a window of the last few days or weeks of activities,
    captured in the `ActivityWindow` value object.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account`实体提供了实际账户的当前快照。每次从账户取款和存款都会在`Activity`实体中捕获。由于始终将账户的所有活动加载到内存中并不明智，`Account`实体只保留最近几天或几周的活动窗口，这些活动被捕获在`ActivityWindow`值对象中。'
- en: To still be able to calculate the current account balance, the `Account` entity
    additionally has the `baselineBalance` attribute, representing the balance the
    account had just before the first activity of the activity window. The total balance,
    then, is the baseline balance plus the balance of all activities in the window.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仍然能够计算当前账户余额，`Account`实体额外具有`baselineBalance`属性，表示活动窗口的第一个活动之前账户所拥有的余额。因此，总余额是基线余额加上窗口中所有活动的余额。
- en: With this model, withdrawing and depositing money into an account is a matter
    of adding a new activity to the activity window, as is done in the `withdraw()`
    and `deposit()` methods. Before we can withdraw, we check the business rule that
    says that we cannot overdraw an account.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个模型，将取款和存款到账户的操作变成在活动窗口中添加一个新的活动，就像在`withdraw()`和`deposit()`方法中所做的那样。在我们能够取款之前，我们检查业务规则，该规则规定我们不能透支账户。
- en: Now that we have an `Account` that allows us to withdraw and deposit money,
    we can move outward to build a use case around it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了允许我们取款和存款的`Account`，我们可以向外扩展，围绕它构建一个用例。
- en: A use case in a nutshell
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例的要点
- en: 'First, let’s discuss what a use case actually does. Usually, it follows these
    steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下用例实际上做什么。通常，它遵循以下步骤：
- en: Take the input.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取输入。
- en: Validate the business rules.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证业务规则。
- en: Manipulate the model state.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作模型状态。
- en: Return the output.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回输出。
- en: A use case takes input from an incoming adapter. You might wonder why I didn’t
    call the first step *Validate input*. The answer is that I believe use case code
    should only be concerned with domain logic and we shouldn’t pollute it with input
    validation. So, we’ll do input validation somewhere else, as we’ll see shortly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 用例从传入的适配器获取输入。你可能想知道为什么我没有将第一步称为“验证输入”。答案是，我相信用例代码应该只关注领域逻辑，我们不应该让它受到输入验证的污染。所以，我们将输入验证放在其他地方，就像我们很快就会看到的那样。
- en: The use case is, however, responsible for validating business rules. It shares
    this responsibility with the domain entities. We’ll discuss the distinction between
    **input validation** and **business rule validation** later in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用例负责验证业务规则。它与领域实体共同承担这一责任。我们将在本章后面讨论**输入验证**和**业务规则验证**之间的区别。
- en: If the business rules were satisfied, the use case then manipulates the state
    of the model in one way or another, based on the input. Usually, it will change
    the state of a domain object and pass this new state to a port implemented by
    the persistence adapter to be persisted. If the use case drives other side effects
    than persistence, it invokes an appropriate adapter for each side effect.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果业务规则得到满足，用例就会根据输入以某种方式操纵模型的状态。通常，它将改变领域对象的状态，并将这个新状态传递给由持久化适配器实现的端口以进行持久化。如果用例驱动其他比持久化更广泛的影响，它将调用适当的适配器以处理每个副作用。
- en: The last step is to translate the return value from the outgoing adapter into
    an output object, which will be returned to the calling adapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将输出适配器的返回值转换为输出对象，该对象将被返回给调用适配器。
- en: With these steps in mind, let’s see how we can implement our *Send money* use
    case.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些步骤，让我们看看我们如何实现我们的 *发送金钱* 用例。
- en: To avoid the problem of broad services discussed in [*Chapter 2*](B19916_05.xhtml),
    *What’s Wrong with Layers?*, we’ll create a separate service class for each use
    case instead of putting all use cases into a single service class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在 [*第 2 章*](B19916_05.xhtml) 中讨论的广泛服务问题，我们将为每个用例创建一个单独的服务类，而不是将所有用例放入一个单一的服务类中。
- en: 'Here’s a teaser:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个预告：
- en: '![](img/code-5.2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-5.2.jpg)'
- en: The service implements the `SendMoneyUseCase` incoming port interface and calls
    the `Load` **AccountPort** outgoing port interface to load an account and the
    `UpdateAccountState` **Port** port to persist an updated account state in the
    database.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务实现了 `SendMoneyUseCase` 输入端口接口，并调用 `Load` **AccountPort** 输出端口接口来加载一个账户，以及
    `UpdateAccountState` **端口** 端口以在数据库中持久化更新的账户状态。
- en: The service also sets the boundary for a database transaction, as implied by
    the `@Transactional` annotation. More about this in [*Chapter 7*](B19916_07.xhtml#_idTextAnchor062)*,
    Implementing a* *Persistence Adapter*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 服务还设置了数据库事务的边界，如 `@Transactional` 注解所暗示的。更多关于这一点的内容请参阅 [*第 7 章*](B19916_07.xhtml#_idTextAnchor062)*，实现*
    *持久化适配器*。
- en: '*Figure 5**.1* provides a visual overview of the relevant components:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5**.1* 提供了相关组件的视觉概述：'
- en: '![Figure 5.1 – A service implements a use case, modifies the domain model,
    and calls an outgoing port to persist the modified state](img/Figure_05.01_B19916.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 一个服务实现一个用例，修改领域模型，并调用输出端口以持久化修改后的状态](img/Figure_05.01_B19916.jpg)'
- en: Figure 5.1 – A service implements a use case, modifies the domain model, and
    calls an outgoing port to persist the modified state
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 一个服务实现一个用例，修改领域模型，并调用输出端口以持久化修改后的状态
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`UpdateAccountStatePort` and `LoadAccountPort`, in this example, are port interfaces
    implemented by a persistence adapter. If they are often used together, we could
    also combine them into a broader interface. We could even call that interface
    `AccountRepository` to stick with the DDD language. In this example, and in the
    rest of the book, I chose to use the name “Repository” only in the persistence
    adapter, but you may choose different names!'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`UpdateAccountStatePort` 和 `LoadAccountPort` 是由持久化适配器实现的端口接口。如果它们经常一起使用，我们也可以将它们合并到一个更广泛接口中。我们甚至可以将该接口命名为
    `AccountRepository` 以保持 DDD 语言的连贯性。在这个例子以及本书的其余部分，我选择仅在持久化适配器中使用“Repository”这个名字，但你也可以选择不同的名字！
- en: Let’s take care of those `TODO` comments we left in the preceding code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来处理我们在前面的代码中留下的那些 `TODO` 注释。
- en: Validating input
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证输入
- en: Now, we’re talking about validating input, even though I just claimed that it’s
    not the responsibility of a use case class. I still think, however, that it belongs
    in the application layer, so this is the place to discuss it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在讨论验证输入，尽管我刚刚声称这不是用例类的责任。然而，我认为它属于应用层，所以这就是讨论它的地方。
- en: Why not let the calling adapter validate the input before sending it to the
    use case? Well, do we want to trust the caller to have validated everything as
    needed for the use case? Also, the use case might be called by more than one adapter,
    so the validation would have to be implemented by each adapter, and one might
    get it wrong or forget it altogether.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不让调用适配器在将输入发送到用例之前进行验证呢？好吧，我们是否希望信任调用者已经验证了用例所需的全部内容？此外，用例可能被多个适配器调用，因此验证必须由每个适配器实现，而且可能会出错或完全忘记。
- en: The application layer should care about input validation because, well, otherwise
    it might get invalid input from outside the application core. This might cause
    damage to the state of our model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序层应该关心输入验证，因为，否则它可能会从应用程序核心外部获得无效输入。这可能会损害我们模型的状态。
- en: But where do we put the input validation if not in the use case class?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果不在用例类中，我们将输入验证放在哪里？
- en: 'We’ll let the input model take care of it. For the *Send money* use case, the
    input model is the `SendMoneyCommand` class we have already seen in the previous
    code example. More precisely, we’ll do the validation within the constructor:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让输入模型来处理这个问题。对于 *Send money* 用例，输入模型是我们之前在代码示例中已经看到的 `SendMoneyCommand` 类。更确切地说，我们将在构造函数中进行验证：
- en: '![](img/code-5.3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-5.3.jpg)'
- en: To send money, we need the IDs of the source and target account and the amount
    of money that is to be transferred. None of the parameters may be `null` and the
    amount must be greater than zero. If any of these conditions is violated, we simply
    refuse object creation by throwing an exception during construction.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送金钱，我们需要源账户和目标账户的 ID 以及要转移的金额。这些参数都不能为 `null`，金额必须大于零。如果任何这些条件被违反，我们将在构造过程中抛出异常，简单地拒绝对象创建。
- en: By using a `SendMoneyCommand`, we make it **immutable**. So, once constructed
    successfully, we can be sure that the state is valid and cannot be changed to
    something invalid.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `SendMoneyCommand`，我们使其 **不可变**。因此，一旦成功构建，我们可以确信状态是有效的，并且不能被改变为无效状态。
- en: Since `SendMoneyCommand` is part of the use cases’ API, it’s located in the
    incoming port package. Thus, the validation remains in the core of the application
    (at the edge of the hexagon of our architecture) but does not pollute the sacred
    use case code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `SendMoneyCommand` 是用例 API 的一部分，它位于传入端口包中。因此，验证仍然位于应用程序的核心（在我们架构六边形的边缘），但不会污染神圣的用例代码。
- en: But do we really want to implement each validation check by hand when there
    are libraries that can do the dirty work for us? I have often heard statements
    such as “You shouldn’t use libraries in your model classes.” There’s wisdom in
    reducing dependencies to a minimum, of course, but if we can get away with a small-footprint
    dependency that saves us time, then why not use it? Let’s explore what this might
    look like with Java’s Bean Validation API.[1](#footnote-021)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当有库可以为我们完成这项脏活时，我们真的想手动实现每个验证检查吗？我经常听到这样的说法：“你不应该在模型类中使用库。”当然，减少依赖到最小是明智的，但如果我们可以使用一个小型依赖项来节省我们的时间，那么为什么不使用它呢？让我们通过
    Java 的 Bean Validation API 探索一下这可能会是什么样子。[1](#footnote-021)
- en: '[1](#footnote-021-backlink) Bean Validation: [https://beanvalidation.org/](https://beanvalidation.org/).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-021-backlink) Bean Validation: [https://beanvalidation.org/](https://beanvalidation.org/).'
- en: 'Bean Validation allows us to express the validation rules we need as annotations
    on the fields of a class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 允许我们在类的字段上使用注解来表示所需的验证规则：
- en: '![](img/code-5.4.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-5.4.jpg)'
- en: The class `Validator` provides the method `validate()`, which we simply call
    as the last statement in the constructor. This will evaluate the Bean Validation
    annotations on the fields (`@NotNull`, in this case) and throw an exception in
    case of a violation. If the default Bean Validation annotations are not expressive
    enough for a certain validation, we can implement our own annotations and validators
    as we did with the `@``PositiveMoney` annotation.[2](#footnote-020)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validator` 类提供了 `validate()` 方法，我们只需在构造函数的最后一句调用它。这将评估字段上的 Bean Validation
    注解（在这种情况下是 `@NotNull`），并在违反时抛出异常。如果默认的 Bean Validation 注解对于某些验证来说不够表达，我们可以像对 `@PositiveMoney`
    注解那样实现我们自己的注解和验证器。[2](#footnote-020)'
- en: '[2](#footnote-020-backlink) You can find the full code implementing the `@PositiveMoney`
    annotation and validator in the GitHub repository at [https://github.com/thombergs/buckpal](https://github.com/thombergs/buckpal).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-020-backlink) 你可以在 GitHub 仓库 [https://github.com/thombergs/buckpal](https://github.com/thombergs/buckpal)
    中找到实现 `@PositiveMoney` 注解和验证器的完整代码。'
- en: 'The implementation of the `Validator` class might look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validator` 类的实现可能看起来像这样：'
- en: '![](img/code-5.5.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-5.5.jpg)'
- en: With validation located in the input model, we have created an **anti-corruption
    layer** around our use case implementations. This is not a layer in the sense
    of a layered architecture, calling the next layer below it, but instead a thin,
    protective screen around our use cases that bounces bad input back to the caller.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将验证定位在输入模型中，我们在用例实现周围创建了一个**反腐败层**。这不是指分层架构中的层，而是指围绕我们的用例的一个薄薄的、保护性的屏幕，将不良输入弹回调用者。
- en: Note that the term “command,” as used in the `SendMoneyCommand` class, does
    not match the common interpretation of the “command pattern.”[3](#footnote-019)
    In the `execute()` that actually invokes the use case. In our case, the command
    is just a data transfer object that transfers the required parameters to the use
    case service that executes the command. We could call it `SendMoneyDTO` instead,
    but I like the term “command” to make it very clear that we’re changing the model
    state with this use case.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`SendMoneyCommand`类中使用的“命令”一词并不符合“命令模式”的常见解释。[3](#footnote-019) 在实际调用用例的`execute()`方法中。在我们的例子中，命令只是一个数据传输对象，它将所需的参数传递给执行命令的用例服务。我们可以称它为`SendMoneyDTO`，但我喜欢使用“命令”这个词，以使其非常清楚地表明我们正在通过这个用例改变模型状态。
- en: '[3](#footnote-019-backlink) Command pattern: [https://en.wikipedia.org/wiki/Command_pattern](https://en.wikipedia.org/wiki/Command_pattern).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-019-backlink) 命令模式：[https://zh.wikipedia.org/wiki/命令模式](https://zh.wikipedia.org/wiki/命令模式)。'
- en: The power of constructors
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数的力量
- en: Our `SendMoneyCommand`, puts a lot of responsibility on its constructor. Since
    the class is immutable, the constructor’s argument list contains a parameter for
    each attribute of the class. And since the constructor also validates the parameters,
    it’s not possible to create an object with an invalid state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SendMoneyCommand`将很多责任放在了构造函数上。由于该类是不可变的，构造函数的参数列表包含了一个对应于类每个属性的参数。并且由于构造函数还验证参数，因此不可能创建一个无效状态的对象。
- en: 'In our case, the constructor has only three parameters. What if we had more
    parameters? Couldn’t we use the builder pattern to make it more convenient to
    use? We could make the constructor with the long parameter list private and hide
    the call to it in the `build()` method of our builder. Then, instead of having
    to call a constructor with 20 parameters, we could build an object like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，构造函数只有三个参数。如果我们有更多的参数会怎样？我们能不能使用构建器模式使其使用更加方便？我们可以将具有长参数列表的构造函数设为私有，并在构建器的`build()`方法中隐藏对其的调用。然后，我们就不必调用一个带有20个参数的构造函数，而可以构建一个像这样的对象：
- en: '![](img/code-5.6.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-5.6.jpg)'
- en: We can still let our constructor do the validation so that the builder cannot
    construct an object with an invalid state.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以让构造函数进行验证，这样构建器就不能构建一个无效状态的对象。
- en: Sound good? Think about what happens if we have to add another field to `SendMoneyCommandBuilder`
    (which will happen quite a few times in the lifetime of a software project). We
    add the new field to the constructor and to the builder. Then, a colleague (or
    a phone call, an email, a butterfly…) interrupts our train of thought. After the
    break, we go back to coding and forget to add the new field to the code that calls
    the builder to create an object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来不错？想想如果我们不得不向`SendMoneyCommandBuilder`（在软件项目的生命周期中这种情况会发生很多次）添加另一个字段会发生什么。我们将新字段添加到构造函数和构建器中。然后，一个同事（或者一个电话，一封电子邮件，一只蝴蝶……）打断我们的思路。休息后，我们回到编码，忘记将新字段添加到调用构建器以创建对象的代码中。
- en: We don’t get a word of warning from the compiler about trying to create an immutable
    object in an invalid state! Sure, at runtime – hopefully in a unit test – our
    validation logic will still kick in and throw an error because we missed a parameter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试创建一个无效状态的不变对象时，编译器不会给出任何警告！当然，在运行时——希望是在单元测试中——我们的验证逻辑仍然会起作用，并抛出一个错误，因为我们遗漏了一个参数。
- en: But if we use the constructor directly instead of hiding it behind a builder,
    each time a new field is added or an existing field is removed, we can just follow
    the trail of compile errors to reflect that change in the rest of the code base.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们直接使用构造函数而不是通过构建器隐藏它，每次添加新字段或删除现有字段时，我们都可以通过跟踪编译错误来反映代码库中其他部分的更改。
- en: 'Long parameter lists can even be formatted nicely, and good IDEs help with
    parameter name hints:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 长参数列表甚至可以格式化得很好，并且好的集成开发环境（IDE）可以帮助提供参数名称提示：
- en: "![Figure 5.2 – The IDE shows parameter name hints in parameter lists to help\
    \ us \uFEFFto not get lost](img/Figure_05.02_B19916.jpg)"
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – IDE在参数列表中显示参数名称提示，帮助我们避免迷失方向](img/Figure_05.02_B19916.jpg)'
- en: Figure 5.2 – The IDE shows parameter name hints in parameter lists to help us
    to not get lost
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – IDE在参数列表中显示参数名称提示，帮助我们避免迷失方向
- en: To make the preceding code even more readable and safer to work with, we can
    introduce immutable `Address` value object, for example, because they belong together.
    We could even go a step further and create `City` and `ZipCode` value objects,
    for example. This would reduce the chance of confusing one `String` parameter
    with another, because the compiler would complain if we tried to pass a `City`
    into a `ZipCode` parameter and vice versa.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的代码更加易于阅读和操作，我们可以引入不可变的`Address`值对象，例如，因为它们属于一起。我们甚至可以更进一步，创建`City`和`ZipCode`值对象，例如。这将减少将一个`String`参数与另一个参数混淆的可能性，因为如果我们将`City`传递给`ZipCode`参数或反之亦然，编译器会报错。
- en: There are cases where a builder may be the better solution, though. If some
    parameters in `ClassWithManyFields` from the preceding example were optional,
    for example, we would have to pass `null` values into the constructor, which is
    ugly at best. A builder would allow us to define only the required parameters.
    But if using builders, we should make very sure that the `build()` method fails
    loudly when we forget to define a required parameter because the compiler doesn’t
    check that for us!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些情况下，构建器可能是更好的解决方案。例如，如果前一个示例中的`ClassWithManyFields`的一些参数是可选的，我们就必须将`null`值传递给构造函数，这最多是丑陋的。构建器允许我们仅定义所需的参数。但如果我们使用构建器，我们必须非常确保在忘记定义一个必需参数时，`build()`方法会大声失败，因为编译器不会为我们检查这一点！
- en: Different input models for different use cases
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同用例的输入模型
- en: We might be tempted to use the same input model for different use cases. Let’s
    consider the *Register account* and *Update account details* use cases. Both will
    initially need almost the same input, namely some account details, such as a username
    and email address.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会倾向于为不同的用例使用相同的输入模型。让我们考虑*注册账户*和*更新账户详情*用例。这两个用例最初几乎需要相同的输入，即一些账户详情，例如用户名和电子邮件地址。
- en: The *Update* use case will need the ID of the account that needs to be updated,
    however, while the *Register* use case does not. If both use cases use the same
    input model, we will always have to pass a `null` account ID into the *Register*
    use case. This is annoying at best, and detrimental at worst, because both use
    cases are coupled to evolve together now.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*更新*用例需要需要更新的账户的ID，而*注册*用例则不需要。如果这两个用例使用相同的输入模型，我们总是必须将一个`null`账户ID传递给*注册*用例。这最多是令人烦恼的，最坏的情况是，因为这两个用例现在必须一起演变。'
- en: Allowing `null` as a valid state of a field in our immutable command object
    is a code smell by itself. But more importantly, how are we handling input validation
    now? Validation has to be different for the *Register* and *Update* use cases
    since one needs an ID and the other doesn’t. We’d have to build custom validation
    logic into the use cases themselves, polluting our sacred business code with input
    validation concerns.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的不可变命令对象中允许`null`作为字段的有效状态本身就是一种代码异味。但更重要的是，我们现在是如何处理输入验证的？由于一个需要ID而另一个不需要，验证对于*注册*和*更新*用例必须不同。我们必须将自定义验证逻辑构建到用例本身中，这将污染我们神圣的业务代码，使其充满输入验证问题。
- en: Also, what do we do if the account ID field accidentally has a non-null value
    in the *Register account* use case? Do we throw an error? Do we simply ignore
    it? These are the questions the maintenance engineers – including future us –
    will ask when seeing the code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果在*注册账户*用例中账户ID字段意外地有一个非空值，我们该怎么办？我们是抛出错误吗？还是简单地忽略它？这些问题是维护工程师（包括未来的我们）在看到代码时会提出的问题。
- en: A dedicated input model for each use case makes the use case much clearer and
    also decouples it from other use cases, preventing unwanted side effects. It comes
    at a cost, however, because we have to map incoming data to different input models
    for different use cases. We’ll discuss this mapping strategy along with other
    mapping strategies in [*Chapter 9*](B19916_09.xhtml#_idTextAnchor081), *Mapping*
    *between Boundaries*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个用例创建一个专门的输入模型可以使用例更加清晰，并且将其与其他用例解耦，防止出现不希望的结果。然而，这也有代价，因为我们必须将传入的数据映射到不同用例的不同输入模型。我们将在[*第9章*](B19916_09.xhtml#_idTextAnchor081)“边界之间的映射”中讨论这种映射策略以及其他映射策略。
- en: Validating business rules
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证业务规则
- en: While validating input is not part of the use case logic, validating business
    rules definitely is. Business rules are the core of the application and should
    be handled with appropriate care. But when are we dealing with input validation
    and when are we dealing with a business rule?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然验证输入不是用例逻辑的一部分，但验证业务规则绝对是的。业务规则是应用程序的核心，应该得到适当的关注。但我们在什么时候处理输入验证，在什么时候处理业务规则呢？
- en: A very pragmatic distinction between the two is that validating a business rule
    requires access to the current state of the domain model while validating input
    does not. Input validation can be implemented declaratively, as we did with the
    `@NotNull` annotations previously, while a business rule needs more context.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间一个非常实际的区分是，验证业务规则需要访问领域模型当前状态，而验证输入则不需要。输入验证可以声明式地实现，就像我们之前用`@NotNull`注解做的那样，而业务规则则需要更多的上下文。
- en: We might also say that input validation is a syntactic validation, while a business
    rule is a semantic validation in the context of a use case.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以说，输入验证是一种语法验证，而业务规则在用例的上下文中是一种语义验证。
- en: Let’s take the rule *the source account must not be overdrawn*. As per the previous
    definition, this is a business rule since it needs access to the current state
    of the model to check the balance of the source account.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以规则“源账户不得透支”为例。根据之前的定义，这是一个业务规则，因为它需要访问模型当前状态来检查源账户的余额。
- en: In contrast, the rule *the transfer amount must be greater than zero* can be
    validated without access to the model and thus can be implemented as part of the
    input validation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，规则“转账金额必须大于零”可以在不访问模型的情况下进行验证，因此可以作为输入验证的一部分实现。
- en: I’m aware that this distinction may be subject to debate. You might argue that
    the transfer amount is so important that validating it should be considered a
    business rule in any case.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这种区分可能会引起争议。你可能会争辩说，转账金额如此重要，验证它无论如何都应该被视为一项业务规则。
- en: The distinction helps us, however, to place certain validations within the code
    base and easily find them again later on. It’s as simple as answering the question
    of whether the validation needs access to the current model state or not. This
    not only helps us to implement the rule in the first place but it also helps the
    future maintenance engineer to find it again. It’s also a great example of my
    claim from [*Chapter 1*](B19916_01.xhtml#_idTextAnchor014), *Maintainability*,
    that maintainability supports decision-making.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种区分有助于我们将某些验证放置在代码库中，并在以后轻松地再次找到它们。这就像回答验证是否需要访问当前模型状态的问题一样简单。这不仅帮助我们首先实施规则，而且也有助于未来的维护工程师再次找到它。这也是我[第1章](B19916_01.xhtml#_idTextAnchor014)中提出的“可维护性”主张的一个很好的例子，即可维护性支持决策。
- en: So, how do we implement a business rule?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现业务规则呢？
- en: 'The best way is to put the business rules into a domain entity as we did for
    the rule *the source account must not* *be overdrawn*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的办法是将业务规则放入领域实体中，就像我们对规则“源账户不得透支”所做的那样：
- en: '![](img/code-5.7.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-5.7.jpg)'
- en: This way, the business rule is easy to locate and reason about because it’s
    right next to the business logic that requires this rule to be honored.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，业务规则就很容易定位和推理，因为它紧挨着需要遵守此规则的业务逻辑。
- en: 'If it’s not feasible to validate a business rule in a domain entity, we can
    do it in the use case code before it starts working on the domain entities:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在领域实体中验证业务规则不可行，我们可以在用例代码开始处理领域实体之前进行验证：
- en: '![](img/code-5.8.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-5.8.jpg)'
- en: We call a method that does the actual validation and throws a dedicated exception
    if this validation fails. The adapter interfacing with the user can then display
    this exception to the user as an error message or handle it in any other way it
    deems fit.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用一个执行实际验证的方法，并在验证失败时抛出一个专门的异常。然后，与用户交互的适配器可以将此异常显示为错误消息或以任何其他它认为合适的方式处理。
- en: In the preceding case, the validation simply checks whether the source and target
    accounts actually exist in the database. More complex business rules might require
    us to load the domain model from the database first and then do some checks on
    its state. If we have to load the domain model anyway, we should implement the
    business rule in the domain entities themselves, as we did with the rule *the
    source account must not* *be overdrawn*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，验证只是检查源账户和目标账户是否实际上存在于数据库中。更复杂的业务规则可能需要我们首先从数据库中加载领域模型，然后对其状态进行一些检查。如果我们无论如何都必须加载领域模型，我们应该在领域实体本身中实现业务规则，就像我们之前对规则“源账户不得”*透支*”所做的那样。
- en: Rich versus anemic domain model
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丰富的领域模型与贫血领域模型
- en: Our architecture style leaves open how to implement our domain model. This is
    a blessing because we can do what seems right in our context, and a curse because
    we don’t have any guidelines to help us.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建筑风格留出了如何实现我们的领域模型的空间。这既是福也是祸，因为我们可以在我们的环境中做我们认为正确的事情，但同时也因为没有任何指导方针来帮助我们而感到苦恼。
- en: A frequent discussion is whether to implement a **rich domain model** following
    the DDD philosophy or an “**anemic**” **domain model**. Let’s discuss how each
    of these fits into our architecture.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的讨论是是否根据DDD哲学实现一个**丰富的领域模型**或一个“**贫血**”**领域模型**。让我们讨论每种方法如何适合我们的架构。
- en: In a rich domain model, as much of the domain logic as possible is implemented
    within the entities at the core of the application. The entities provide methods
    to change the state and only allow changes that are valid according to the business
    rules. This is the way we pursued the `Account` entity previously. Where is our
    use case implementation in this scenario?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个丰富的领域模型中，尽可能多的领域逻辑都实现在应用程序核心的实体中。实体提供更改状态的方法，并且只允许根据业务规则进行更改。这是我们之前追求“账户”实体的方式。在这种情况下，我们的用例实现在哪里？
- en: In this case, our use case serves as an entry point to the domain model. A use
    case then only represents the intent of the user and translates it into orchestrated
    method calls to the domain entities, which do the actual work. Many of the business
    rules are located in the entities instead of the use case implementation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的用例作为进入领域模型的入口点。用例仅仅代表了用户的意图，并将其转换为对领域实体的编排方法调用，这些实体实际完成工作。许多业务规则位于实体中而不是用例实现中。
- en: The *Send money* use case service would load the source and target account entities,
    call their `withdraw()` and `deposit()` methods, and send them back to the database.[4](#footnote-018)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: “发送金钱”用例服务将加载源账户和目标账户实体，调用它们的`withdraw()`和`deposit()`方法，并将它们发送回数据库。[4](#footnote-018)
- en: '[4](#footnote-018-backlink) Actually, the *Send Money* use case would also
    have to make sure that no other money transfer to and from the source and target
    account was happening at the same time to avoid overdrawing an account.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](#footnote-018-backlink) 实际上，“发送金钱”用例还必须确保在源账户和目标账户之间没有同时进行其他资金转账，以避免透支账户。'
- en: In an “anemic” domain model, the entities themselves are very thin. They usually
    only provide fields to hold the state and getter and setter methods to read and
    change the state. They don’t contain any domain logic.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个“贫血”的领域模型中，实体本身非常瘦。它们通常只提供用于存储状态的字段以及用于读取和更改状态的getter和setter方法。它们不包含任何领域逻辑。
- en: This means that the domain logic is implemented in the use case classes. They
    are responsible for validating business rules, changing the state of the entities,
    and passing them into the outgoing ports responsible for storing them in the database.
    The “richness” is contained within the use cases instead of the entities.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着领域逻辑是在用例类中实现的。它们负责验证业务规则，更改实体的状态，并将它们传递给负责将它们存储在数据库中的输出端口。“丰富性”包含在用例中而不是实体中。
- en: Either style, and any number of other styles, can be implemented using the architecture
    approach discussed in this book. Feel free to choose the one that fits your needs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是哪种风格，还是任何其他风格，都可以使用本书中讨论的架构方法来实现。请随意选择适合您需求的一种。
- en: Different output models for different use cases
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同用例的不同输出模型
- en: Once the use case has done its work, what should it return to the caller?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用例完成了其工作，它应该向调用者返回什么？
- en: Similar to the input, it has benefits if the output is as specific to the use
    case as possible. The output should only include the data that is really needed
    for the caller to work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与输入类似，如果输出尽可能具体到用例，那么它就有好处。输出应仅包括调用者实际需要的数据。
- en: In the example code of the *Send money* use case, we return a Boolean. This
    is the minimal and most specific value we could possibly return in this context.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在*发送金钱*用例的示例代码中，我们返回一个布尔值。这是我们在这个上下文中可能返回的最小和最具体的值。
- en: We might be tempted to return a complete `Account` with the updated entity to
    the caller. Perhaps the caller is interested in the new balance of the account.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会被诱惑将更新后的实体`Account`完整地返回给调用者。也许调用者对账户的新余额感兴趣。
- en: But do we really want to make the *Send money* use case return this data? Does
    the caller really need it? If so, shouldn’t we create a dedicated use case for
    accessing that data that can be used by different callers?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们真的希望让*发送金钱*用例返回这些数据吗？调用者真的需要它吗？如果是这样，我们是否应该创建一个专门用于访问这些数据的用例，以便不同的调用者可以使用？
- en: There is no single right answer to these questions. But we should ask them to
    try to keep our use cases as specific as possible. When in doubt, return as little
    as possible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些问题，没有唯一的正确答案。但我们应该提出这些问题，以尽量使我们的用例尽可能具体。如果有疑问，尽可能返回最少的。
- en: Sharing the same output model between use cases also tends to tightly couple
    those use cases. If one of the use cases needs a new field in the output model,
    the other use cases have to handle this field as well, even if it’s irrelevant
    to them. Shared models tend to grow tumorously for multiple reasons in the long
    run. Applying the Single Responsibility Principle and keeping models separated
    helps in decoupling use cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在用例之间共享相同的输出模型也往往会紧密耦合这些用例。如果一个用例需要在输出模型中添加新字段，其他用例也必须处理这个字段，即使它与它们无关。共享模型由于多种原因，在长期运行中往往会肿瘤般地增长。应用单一责任原则并保持模型分离有助于解耦用例。
- en: For the same reason, we might want to resist the temptation to use our domain
    entities as the output model. We don’t want our domain entities to change for
    more reasons than necessary. However, we’ll talk more about using entities as
    input or output models in [*Chapter 11*](B19916_11.xhtml#_idTextAnchor096), *Taking*
    *Shortcuts Consciously*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，我们可能想要抵制使用我们的领域实体作为输出模型的诱惑。我们不希望我们的领域实体在不必要的情况下发生变化。然而，我们将在[*第11章*](B19916_11.xhtml#_idTextAnchor096)中更多地讨论将实体用作输入或输出模型，*有意识地走捷径*。
- en: What about read-only use cases?
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，只读用例怎么办？
- en: As of now, we have discussed how we might implement a use case that modifies
    the state of our model. How do we go about implementing read-only cases? Let’s
    assume the UI needs to display the balance of an account. Do we create a specific
    use case implementation for this?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何实现可能修改我们模型状态的用例。我们如何处理只读用例？让我们假设UI需要显示账户余额。我们是否为这个用例创建一个特定的用例实现？
- en: It’s awkward to talk of use cases for read-only operations like this one. Sure,
    the UI needs the data for a use case we might call *View Account Balance*, but
    in some cases, calling this a “use case” is a bit artificial. If this is considered
    a use case in the context of the project, by all means, we should implement it
    just like the other ones.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种只读操作，谈论其用例可能会显得有些尴尬。当然，UI需要这些数据用于我们可能称之为*查看账户余额*的用例，但在某些情况下，将这称为“用例”可能有些人为。如果在这个项目的背景下，这被视为一个用例，那么我们应该像其他用例一样实施它。
- en: From the viewpoint of the application core, however, this is a simple query
    for data. So, if it’s not considered a use case in the context of the project,
    we can implement it as a query to set it apart from the real use cases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从应用程序核心的角度来看，这只是一个简单的数据查询。因此，如果在这个项目的背景下，这不被视为一个用例，我们可以将其实现为一个查询，以将其与真正的用例区分开来。
- en: One way of doing this within our architecture style is to create a dedicated
    incoming port for the query and implement it in a “query service:”
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的架构风格中，实现这一点的办法之一是为查询创建一个专门的输入端口，并在“查询服务”中实现它：
- en: '![](img/code-5.9.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/code-5.9.jpg)'
- en: The `GetAccountBalanceUseCase` and calls the outgoing port, `LoadAccountPort`,
    to actually load the data from the database. It’s using the `GetAccountBalanceQuery`
    type as its input model.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAccountBalanceUseCase`调用输出端口`LoadAccountPort`，从数据库实际加载数据。它使用`GetAccountBalanceQuery`类型作为其输入模型。'
- en: This way, read-only queries are clearly distinguishable from modifying use cases
    (or “commands”) in our code base. We just have to look at the names of the input
    types to know which we’re dealing with. This plays nicely with concepts such as
    **Command-Query Separation** (**CQS**) and **Command-Query Responsibility** **Segregation**
    (**CQRS**).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，只读查询在我们的代码库中可以清楚地与修改用例（或“命令”）区分开来。我们只需查看输入类型的名称，就能知道我们正在处理什么。这与**命令查询分离**（**CQS**）和**命令查询责任分离**（**CQRS**）等概念相得益彰。
- en: In the preceding code, the service doesn’t really do any work other than passing
    the query on to the outgoing port. If we use the same model across layers, we
    can take a shortcut and let the client call the outgoing port directly. We’ll
    talk about this shortcut in [*Chapter 11*](B19916_11.xhtml#_idTextAnchor096),
    *Taking* *Shortcuts Consciously*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，服务实际上并没有做任何工作，只是将查询传递到输出端口。如果我们跨层使用相同的模型，我们可以走捷径，让客户端直接调用输出端口。我们将在[*第11章*](B19916_11.xhtml#_idTextAnchor096)中讨论这个捷径，*有意识地走捷径*。
- en: How does this help me build maintainable software?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: Our architecture lets us implement the domain logic as we see fit, but if we
    model the input and output of our use cases independently, we avoid unwanted side
    effects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的架构允许我们根据需要实现领域逻辑，但如果我们独立地建模用例的输入和输出，我们可以避免不希望的副作用。
- en: Yes, it’s more work than just sharing models between use cases. We have to introduce
    a separate model for each use case and map between this model and our entities.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这比在用例之间共享模型要复杂得多。我们必须为每个用例引入一个单独的模型，并将此模型与我们的实体进行映射。
- en: But use case-specific models allow for a crisp understanding of a use case,
    making it easier to maintain in the long run. Also, they allow multiple developers
    to work on different use cases in parallel without stepping on each other’s toes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，针对特定用例的模型可以清晰地理解用例，从而在长期内更容易维护。此外，它们还允许多个开发者并行工作在不同的用例上，而不会相互干扰。
- en: Together with tight input validation, use case-specific input and output models
    go a long way toward a maintainable code base.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与严格的输入验证相结合，针对特定用例的输入和输出模型对于构建可维护的代码库大有裨益。
- en: In the next chapter, we’re taking a step “outward” from the center of our application
    and will explore building a web adapter that provides a channel for users to talk
    to our use case.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从应用程序的中心“向外迈出一步”，并探讨构建一个网络适配器，为用户提供与我们的用例进行交流的渠道。
