- en: Contexts and Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文和依赖注入
- en: '**Contexts** **and** **Dependency** **Injection** (**CDI**) was added to the
    Java EE specification in Java EE 6\. Java EE 8 includes a new version of CDI,
    which adds new features such as asynchronous events and event ordering. CDI provides
    several advantages that were previously unavailable to Java EE developers, such
    as allowing any JavaBean to be used as a JSF managed bean, including stateless
    and stateful session beans. As its name implies, CDI simplifies dependency injection
    in Java EE applications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**和**依赖注入**（**CDI**）在Java EE 6中被添加到Java EE规范中。Java EE 8包括CDI的新版本，它添加了新的功能，如异步事件和事件排序。CDI为Java
    EE开发者提供了之前不可用的几个优势，例如允许任何JavaBean用作JSF管理Bean，包括无状态和有状态的会话Bean。正如其名称所暗示的，CDI简化了Java
    EE应用程序中的依赖注入。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Named beans
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名Bean
- en: Dependency injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Scopes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: Qualifiers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化
- en: CDI events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI事件
- en: Named beans
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名Bean
- en: CDI provides us with the ability to name our beans via the `@Named` annotation.
    Named beans allow us to easily inject our beans into other classes that depend
    on them (see the next section), and to easily refer to them from JSF pages via
    the unified expression language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CDI通过`@Named`注解为我们提供了命名我们的Bean的能力。命名Bean允许我们轻松地将我们的Bean注入依赖于它们的其他类（参见下一节），并且可以通过统一表达式语言从JSF页面轻松地引用它们。
- en: 'The following example shows the `@Named` annotation in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了`@Named`注解的作用：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see, all we need to do to name our class is to decorate it with the
    `@Named` annotation. By default, the name of the bean will be the class name with
    its first letter switched to lowercase; in our example, the name of the bean would
    be `customer`. If we wish to use a different name, we can do so by setting the
    `value` attribute of the `@Named` annotation. For example, if we had wanted to
    use the name `customerBean` for the bean above, we could have done so by modifying
    the `@Named` annotation as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们只需要用`@Named`注解装饰我们的类来命名我们的类。默认情况下，Bean的名称将是类名，其首字母转换为小写；在我们的例子中，Bean的名称将是`customer`。如果我们希望使用不同的名称，我们可以通过设置`@Named`注解的`value`属性来实现。例如，如果我们想为上面的Bean使用名称`customerBean`，我们可以通过修改`@Named`注解如下：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or simply:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单地：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the `value` attribute name does not need to be specified, if we don't
    use an attribute name, then `value` is implied.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`value`属性名称不需要指定，如果我们不使用属性名称，则隐含`value`。
- en: 'This name can be used to access our bean from JSF pages using the unified expression
    language:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名称可以用来通过统一表达式语言从JSF页面访问我们的Bean：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, named beans are accessed from JSF pages exactly as standard JSF
    managed beans are. This allows JSF to access any named bean, decoupling the Java
    code from the JSF API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，命名Bean的访问方式与标准JSF管理Bean的访问方式完全相同。这允许JSF访问任何命名Bean，将Java代码与JSF API解耦。
- en: 'When deployed and executed, our simple application looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署和执行时，我们的简单应用程序看起来像这样：
- en: '![](img/71173338-a1f7-4e86-b055-90fda1e1e4a8.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71173338-a1f7-4e86-b055-90fda1e1e4a8.png)'
- en: Dependency injection
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '**Dependency injection** is a technique for supplying external dependencies
    to a Java class. Java EE 5 introduced dependency injection via the `@Resource`
    annotation, however, this annotation is limited to injecting resources such as
    database connections, JMS resources, and so on. CDI includes the `@Inject` annotation,
    which can be used to inject instances of Java classes into any dependent objects.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**是一种向Java类提供外部依赖的技术。Java EE 5通过`@Resource`注解引入了依赖注入，然而，这个注解仅限于注入资源，如数据库连接、JMS资源等。CDI包括`@Inject`注解，它可以用来将Java类的实例注入到任何依赖对象中。'
- en: 'JSF applications typically follow the **Model-View-Controller** (**MVC**) design
    pattern. As such, often some JSF managed beans take the role of controllers in
    the pattern, while others take the role of the model. This approach typically
    requires the controller managed bean to have access to one or more of the model-managed
    beans. CDI''s dependency injection capabilities make injecting beans into one
    another very simple, as illustrated in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: JSF应用程序通常遵循**模型-视图-控制器**（**MVC**）设计模式。因此，通常一些JSF管理Bean在模式中扮演控制器的角色，而其他则扮演模型的角色。这种方法通常要求控制器管理Bean能够访问一个或多个模型管理Bean。CDI的依赖注入功能使得将Bean注入到彼此中非常简单，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that all we had to do to initialize our `Customer` instance was to decorate
    it with the `@Inject` annotation. When the bean is constructed by the application
    server, an instance of the `Customer` bean is automatically injected into this
    field. Notice that the injected bean is used in the `saveCustomer()` method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们初始化`Customer`实例所需要做的只是用`@Inject`注解来装饰它。当Bean由应用服务器构建时，`Customer` Bean的实例会自动注入到这个字段中。注意，注入的Bean在`saveCustomer()`方法中被使用。
- en: Qualifiers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限定符
- en: In some instances, the type of bean we wish to inject into our code may be an
    interface or a Java superclass, but we may be interested in injecting a specific
    subclass or a class implementing the interface. For cases like this, CDI provides
    qualifiers we can use to indicate the specific type we wish to inject into our
    code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望注入到我们的代码中的Bean类型可能是一个接口或Java超类，但我们可能对注入特定的子类或实现接口的类感兴趣。对于这种情况，CDI提供了我们可以用来指示我们希望注入到我们的代码中的特定类型的限定符。
- en: A CDI qualifier is an annotation that must be decorated with the `@Qualifier`
    annotation. This annotation can then be used to decorate the specific subclass
    or interface implementation we wish to qualify. Additionally, the injected field
    in the client code needs to be decorated with the qualifier as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: CDI限定符是一个必须用`@Qualifier`注解装饰的注解。这个注解然后可以用来装饰我们希望限定的特定子类或接口实现。此外，客户端代码中的注入字段也需要用限定符来装饰。
- en: 'Suppose our application could have a special kind of customer; for example,
    frequent customers could be given the status of premium customers. To handle those
    premium customers, we could extend our `Customer` named bean and decorate it with
    the following qualifier:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序可能有一种特殊的客户类型；例如，常客可能会被赋予高级客户的地位。为了处理这些高级客户，我们可以扩展我们的`Customer`命名Bean并用以下限定符装饰它：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we mentioned before, qualifiers are standard annotations; they typically
    have retention of runtime and can target methods, fields, parameters, or types,
    as illustrated in the above example. The only difference between a qualifier and
    a standard annotation is that qualifiers are decorated with the `@Qualifier` annotation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，限定符是标准注解；它们通常具有运行时保留，可以针对方法、字段、参数或类型，如上例所示。限定符和标准注解之间的唯一区别是限定符被装饰了`@Qualifier`注解。
- en: 'Once we have our qualifier in place, we need to use it to decorate the specific
    subclass or interface implementation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了限定符，我们需要用它来装饰特定的子类或接口实现：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we have decorated the specific instance we need to qualify, we can use
    our qualifiers in the `client` code to specify the exact type of dependency we
    need:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们装饰了需要限定的特定实例，我们就可以在`client`代码中使用我们的限定符来指定确切的依赖类型：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since we used our `@Premium` qualifier to decorate the customer field, an instance
    of `PremiumCustomer` is injected into that field, as this class is also decorated
    with the `@Premium` qualifier.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们用`@Premium`限定符来装饰客户字段，因此`PremiumCustomer`的实例被注入到该字段中，因为这个类也被装饰了`@Premium`限定符。
- en: 'As far as our JSF pages go, we simply access our named bean as usual, using
    its name:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们的JSF页面而言，我们只需像往常一样通过其名称访问我们的命名Bean：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we are using the default name for our bean, which is the class
    name with the first letter switched to lowercase.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在使用Bean的默认名称，即类名首字母小写。
- en: 'Our simple application renders and acts just like a "plain" JSF application,
    as far as the user is concerned:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，我们的简单应用程序渲染和操作就像一个“普通”的JSF应用程序：
- en: '![](img/fcb8f159-b667-4101-9b0a-4d8d42b453ff.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcb8f159-b667-4101-9b0a-4d8d42b453ff.png)'
- en: Named bean scopes
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名Bean作用域
- en: Just like JSF managed beans, CDI named beans are scoped. This means that CDI
    beans are contextual objects. When a named bean is needed, either because of injection
    or because it is referred from a JSF page, CDI looks for an instance of the bean
    in the scope it belongs to and injects it into the dependent code. If no instance
    is found, one is created and stored in the appropriate scope for future use. The
    different scopes are the context in which the bean exists.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像JSF管理Bean一样，CDI命名Bean也有作用域。这意味着CDI Bean是上下文对象。当需要命名Bean时，无论是由于注入还是因为从JSF页面引用，CDI都会在其所属的作用域中寻找Bean的实例，并将其注入到依赖的代码中。如果没有找到实例，就会创建一个并存储在适当的作用域中供将来使用。不同的作用域是Bean存在上下文。
- en: 'The following table lists the different valid CDI scopes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了不同的有效CDI作用域：
- en: '| **Scope** | **Annotation** | **Description** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **作用域** | **注解** | **描述** |'
- en: '| Request | `@RequestScoped` | request-scoped beans are shared through the
    duration of a single request. A single request could refer to an HTTP request,
    an invocation to a method in an EJB, a web service invocation, or sending a JMS
    message to a message-driven bean. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 请求 | `@RequestScoped` | 请求作用域的bean在单个请求的持续期间共享。单个请求可能指的是HTTP请求、对EJB方法的方法调用、Web服务调用，或者向消息驱动bean发送JMS消息。|'
- en: '| Conversation | `@ConversationScoped` | The conversation scope can span multiple
    requests but is typically shorter than the session scope. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 对话 | `@ConversationScoped` | 对话作用域可以跨越多个请求，但通常比会话作用域短。|'
- en: '| Session | `@SessionScoped` | session-scoped beans are shared across all requests
    in an HTTP session. Each user of an application gets their own instance of a session
    scoped bean. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 会话 | `@SessionScoped` | 会话作用域的bean在HTTP会话的所有请求中共享。每个应用程序的用户都会获得自己的会话作用域bean实例。|'
- en: '| Application | `@ApplicationScoped` | application-scoped beans live through
    the whole application lifetime. Beans in this scope are shared across user sessions.
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 应用 | `@ApplicationScoped` | 应用作用域的bean在整个应用程序生命周期中存活。此作用域中的bean在用户会话之间共享。|'
- en: '| Dependent | `@Dependent` | dependent-scoped beans are not shared; any time
    a dependent scoped bean is injected, a new instance is created. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 依赖 | `@Dependent` | 依赖作用域的bean不共享；每次注入依赖作用域bean时，都会创建一个新的实例。|'
- en: As we can see, CDI includes most scopes supported by JSF, and also adds a couple
    of its own. CDI's **request scope** differs from JSF's request scope, in which
    a request does not necessarily refer to an HTTP request; it could simply be an
    invocation on an EJB method, a web service invocation, or sending a JMS message
    to a message-driven bean.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，CDI包括了JSF支持的大多数作用域，并添加了几个自己的作用域。CDI的**请求作用域**与JSF的请求作用域不同，其中请求不一定指的是HTTP请求；它可能只是对EJB方法的调用、Web服务调用，或者向消息驱动bean发送JMS消息。
- en: The **conversation scope** does not exist in JSF. This scope is similar to JSF's
    flow scope, since it is longer than the request scope but shorter than the session
    scope, and typically spans three or more pages. Classes wishing to access a conversation-scoped
    bean must have an instance of `javax.enterprise.context.Conversation` injected.
    At the point where we want to start the conversation, the `begin()` method must
    be invoked on this object. At the point where we want to end the conversation,
    the `end()` method must be invoked on it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**对话作用域**在JSF中不存在。这个作用域类似于JSF的流程作用域，因为它比请求作用域长，但比会话作用域短，通常跨越三个或更多页面。希望访问对话作用域bean的类必须注入`javax.enterprise.context.Conversation`的实例。在我们想要开始对话的点，必须在这个对象上调用`begin()`方法。在我们想要结束对话的点，必须在这个对象上调用`end()`方法。'
- en: CDI's **session scope** behaves just like its JSF counterpart. The lifecycle
    of session-scoped beans are tied to the life of an HTTP session.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CDI的**会话作用域**与JSF的对应作用域行为相同。会话作用域bean的生命周期与HTTP会话的生命周期绑定。
- en: CDI's **application scope** also behaves just like the equivalent scope in JSF.
    Application-scoped beans are tied to the life of an application. A single instance
    of each application-scoped bean exists per application, which means that the same
    instance is accessible to all HTTP sessions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: CDI的**应用作用域**也像JSF中的等效作用域一样行为。应用作用域bean与应用程序的生命周期绑定。每个应用作用域bean在每个应用程序中只有一个实例，这意味着相同的实例对所有HTTP会话都是可访问的。
- en: Just like the conversation scope, CDI's **dependent scope** does not exist in
    JSF. New dependent scope beans are instantiated every time it is needed; usually
    when it is injected into a class that depends on it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对话作用域一样，CDI的**依赖作用域**在JSF中不存在。每次需要时，都会实例化新的依赖作用域bean；通常是在将其注入依赖于它的类时。
- en: 'Suppose we wanted to have a user enter some data that would be stored in a
    single named bean, but that bean has several fields. Therefore, we would like
    to split the data entry into several pages. This is a fairly common situation
    and one that was not easy to handle using previous versions of Java EE (JSF 2.2
    added Faces Flows to solve this problem; refer to [Chapter 2](9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml),
    *JavaServer Faces* ), or the servlet API for that matter. The reason this situation
    was not easy to manage using those technologies is that you could either put a
    class in the request scope, in which case the class would be destroyed after every
    single request, losing its data in the process, or in the session scope, in which
    the class would stick around in memory long after it was needed. For cases like
    this, CDI''s conversation scope is a good solution:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要让用户输入一些将被存储在单个命名 bean 中的数据，但该 bean 有几个字段。因此，我们希望将数据输入分成几个页面。这是一个相当常见的情况，而且使用之前版本的
    Java EE（JSF 2.2 添加了 Faces Flows 来解决这个问题；请参阅 [第 2 章](9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml)，*JavaServer
    Faces*），或者就 servlet API 而言，这种情况并不容易管理。这种情况之所以难以管理，是因为你可以将一个类放在请求作用域中，在这种情况下，该类会在每次请求后销毁，从而在过程中丢失其数据，或者放在会话作用域中，在这种情况下，该类会在需要之后长时间留在内存中。对于这种情况，CDI
    的会话作用域是一个很好的解决方案：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We declare that our bean is conversation scoped by decorating it with the `@ConversationScoped`
    annotation. Conversation-scoped beans also need to implement `java.io.Serializable`.
    Other than those two requirements, there is nothing special about our code; it
    is a simple JavaBean with private properties and corresponding `getter` and `setter`
    methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `@ConversationScoped` 注解来声明我们的 bean 是会话作用域的。会话作用域的 bean 还需要实现 `java.io.Serializable`。除了这两个要求之外，我们的代码没有特别之处；它是一个简单的
    JavaBean，具有私有属性和相应的 `getter` 和 `setter` 方法。
- en: We are using the Apache `commons-lang` library in our code to easily implement
    a `toString()` method for our bean. `commons-lang` has several `utility` methods
    like this that implement frequently needed, tedious to code functionality. `commons-lang`
    is available in the central `Maven` repositories and at [http://commons.apache.org/lang](http://commons.apache.org/lang).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中使用 Apache `commons-lang` 库来轻松实现我们 bean 的 `toString()` 方法。`commons-lang`
    包含几个这样的 `utility` 方法，它们实现了频繁需要的、编写起来繁琐的功能。`commons-lang` 可在中央 `Maven` 仓库和 [http://commons.apache.org/lang](http://commons.apache.org/lang)
    获取。
- en: 'In addition to having our conversation-scoped bean injected, our client code
    must also have an instance of `javax.enterprise.context.Conversation` injected,
    as illustrated in the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注入我们的会话作用域 bean 之外，我们的客户端代码还必须注入一个 `javax.enterprise.context.Conversation`
    的实例，如下例所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Conversations can be either **long-running** or **transient**. Transient conversations
    end at the end of a request, while long-running conversations span multiple requests.
    In most cases, we use long-running conversations to hold a reference to a conversation-scoped
    bean across multiple HTTP requests in a web application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 会话可以是 **长时间运行** 或 **短暂的**。短暂的会话在请求结束时结束，而长时间运行的会话跨越多个请求。在大多数情况下，我们使用长时间运行的会话来在
    Web 应用程序中跨多个 HTTP 请求保持对会话作用域 bean 的引用。
- en: A long-running conversation starts when the `begin()` method is invoked in the
    injected `Conversation` instance, and it ends when we invoke the `end()` method
    on the same object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当在注入的 `Conversation` 实例上调用 `begin()` 方法时，开始一个长时间运行的会话，并且它在我们对该对象调用 `end()` 方法时结束。
- en: 'JSF pages simply access our CDI beans as usual:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 页面像往常一样访问我们的 CDI bean：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we navigate from one page to the next, we keep the same instance of our conversation-scoped
    bean; therefore, all user entered data remains. When the `end()` method is called
    on our conversation bean, the conversation ends and our conversation-scoped bean
    is destroyed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从一页导航到下一页时，我们保持我们的会话作用域 bean 的相同实例；因此，所有用户输入的数据都保持不变。当在会话 bean 上调用 `end()`
    方法时，会话结束，我们的会话作用域 bean 被销毁。
- en: 'Keeping our bean in the conversation scope simplifies the task of implementing
    *wizard-style* user interfaces, where data can be entered across several pages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的 bean 保持会话作用域简化了实现 *向导式* 用户界面的任务，其中数据可以跨多个页面输入：
- en: '![](img/f71e195a-79d1-4843-936e-68d055e382bb.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f71e195a-79d1-4843-936e-68d055e382bb.png)'
- en: 'In our example, after clicking the Next button on the first page, we can see
    our partially populated bean in the application server log:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，在第一页上点击“下一步”按钮后，我们可以在应用服务器日志中看到我们的部分填充的 bean：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, the second page in our simple wizard is displayed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们简单向导的第二页被显示：
- en: '![](img/5af93b45-060c-46d6-933e-8ab3f3a15e55.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5af93b45-060c-46d6-933e-8ab3f3a15e55.png)'
- en: 'When we click Next, we can see that additional fields are populated in our
    conversation-scoped bean:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“下一步”时，我们可以看到在我们的会话作用域bean中填充了额外的字段：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we submit the third page in our wizard (not shown), additional bean properties
    corresponding to the fields on that page are populated.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在向导的第三页提交时（未显示），将填充与该页面上字段对应的额外bean属性。
- en: 'When we are at the point where we don''t need to keep the customer information
    in memory anymore, we need to call the `end()` method on the `Conversation` bean
    that was injected into our code. This is exactly what we do in our code before
    displaying the confirmation page:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达不需要在内存中保留客户信息的时候，我们需要调用注入到我们代码中的`Conversation` bean上的`end()`方法。这正是我们在显示确认页面之前在代码中所做的：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After the request to show the confirmation page is completed, our conversation-scoped
    bean is destroyed, since we invoked the `end()` method in our injected `Conversation`
    class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成显示确认页面的请求后，我们的会话作用域bean被销毁，因为我们调用了注入的`Conversation`类中的`end()`方法。
- en: We should note that, since the conversation, scope requires an instance of `javax.enterprise.context.Conversation`
    to be injected, this scope requires that the action in the command button or link
    used to navigate between pages be an expression resolving to a named bean method.
    Using static navigation won't work, since the `Conversation` instance won't be
    injected anywhere.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，自从对话以来，范围需要注入一个`javax.enterprise.context.Conversation`实例，因此这个范围要求用于在页面之间导航的命令按钮或链接中的操作是一个解析为命名bean方法的表达式。使用静态导航将不会工作，因为`Conversation`实例不会被注入到任何地方。
- en: CDI events
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI事件
- en: CDI provides event handling facilities. Events allow loosely-coupled communication
    between different CDI beans. A CDI bean can fire an event, then one or more event
    listeners handle the event.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: CDI提供了事件处理功能。事件允许不同CDI bean之间的松散耦合通信。一个CDI bean可以触发一个事件，然后一个或多个事件监听器处理该事件。
- en: Firing CDI events
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发CDI事件
- en: 'The following example is a new version of the `CustomerInfoController` class
    we discussed in the previous section. The class has been modified to fire an event
    every time the user navigates to a new page:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是我们在上一节中讨论的`CustomerInfoController`类的新版本。该类已被修改为每次用户导航到新页面时触发一个事件：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we can see, to create an event, we inject an instance of `javax.enterprise.event.Event`.
    This class uses generics, therefore, we need to specify its type; the type of
    the `Event` class can be any class implementing `java.io.Serializable`. In our
    case, we are passing an instance of a simple POJO we wrote as the type parameter.
    Our POJO is called `NavigationInfo` and has two properties: one `Customer`type,
    and a `String` containing the page the user is navigating to. Recall from the
    previous sections that each of the methods on our `CustomerInfoController` class
    triggers navigation from one page in the application to another. In this version
    of the controller, a CDI event is fired every time we navigate to a new page.
    In each case, we create a new instance of `NavigationInfo`, populate it, then
    fire the event by invoking the `fire()` method on our instance of `javax.enterprise.event.Event`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，要创建一个事件，我们需要注入一个`javax.enterprise.event.Event`实例。这个类使用泛型，因此我们需要指定其类型；`Event`类的类型可以是实现`java.io.Serializable`接口的任何类。在我们的例子中，我们传递了一个简单的POJO实例作为类型参数。我们的POJO叫做`NavigationInfo`，有两个属性：一个`Customer`类型和一个包含用户正在导航到的页面的`String`。回想一下，在前面的章节中，我们`CustomerInfoController`类上的每个方法都会触发应用程序中一个页面到另一个页面的导航。在这个控制器的这个版本中，每次我们导航到新页面时都会触发一个CDI事件。在每种情况下，我们创建一个新的`NavigationInfo`实例，填充它，然后通过在我们的`javax.enterprise.event.Event`实例上调用`fire()`方法来触发事件。
- en: Handling CDI events
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理CDI事件
- en: 'To handle CDI events, the CDI bean handling the event needs to implement an
    `observer` method. The `observer` method accepts a parameter of the type that
    was used to fire the event, that is, the generic type used to create the event
    that was fired. In our example, the generic type of our event is an instance of
    a class named `NavigationInfo`, as can be seen in the declaration of our event
    in the preceding section. To handle the event, the observer method needs to annotate
    the corresponding parameter with the `@Observes` annotation, as illustrated in
    the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理 CDI 事件，处理事件的 CDI 实例需要实现一个 `observer` 方法。`observer` 方法接受一个参数类型，即用于触发事件的类型，即创建触发事件的泛型类型。在我们的示例中，事件泛型类型是一个名为
    `NavigationInfo` 的类的实例，如前一小节中我们事件声明所示。为了处理事件，观察者方法需要注解相应的参数为 `@Observes` 注解，以下示例进行了说明：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example event handler, the `handleNavigationEvent()` method takes an
    instance of `NavigationInfo` as a parameter. Notice that this parameter is annotated
    with `@Observes`; this causes the method to be invoked automatically by CDI every
    time a `NavigationInfo` type event is fired.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例的事件处理器中，`handleNavigationEvent()` 方法接受一个 `NavigationInfo` 实例作为参数。请注意，此参数被注解为
    `@Observes`；这会导致 CDI 在每次触发 `NavigationInfo` 类型事件时自动调用该方法。
- en: In our example, we have only one event listener, but in practice, we can have
    as many event listeners as we need.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只有一个事件监听器，但在实际应用中，我们可以根据需要拥有任意多个事件监听器。
- en: Asynchronous events
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步事件
- en: 'CDI 2.0 introduced the ability to fire events asynchronously. Firing events
    asynchronously can help with performance, since various observer methods can be
    invoked concurrently. Firing an event asynchronously is very similar to firing
    an event synchronously, the only difference is that, instead of invoking the `fire()`
    method in our `Event` instance, we invoke its `fireAsync()` method. The following
    example illustrates how to do this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 2.0 引入了异步触发事件的能力。异步触发事件可以帮助提高性能，因为各种观察者方法可以并发调用。异步触发事件与同步触发事件非常相似，唯一的区别是，我们不是在
    `Event` 实例中调用 `fire()` 方法，而是调用其 `fireAsync()` 方法。以下示例说明了如何实现这一点：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Observer methods to handle asynchronous events are identical to their synchronous
    counterparts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步事件的观察者方法与其同步对应者相同。
- en: Event ordering
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件排序
- en: 'Another new feature introduced in CDI 2.0 is the ability to specify in which
    order our `observer` methods handle CDI events. This can be accomplished via the
    `@Priority` annotation, as illustrated in the following example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 2.0 中引入的另一个新功能是能够指定 `observer` 方法处理 CDI 事件的顺序。这可以通过 `@Priority` 注解实现，以下示例进行了说明：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `@Priority` annotation takes an argument of type `int`. This argument specifies
    the priority for the `observer` method. The highest priority is defined by the
    `APPLICATION` constant defined in the `Interceptor.Priority` class. This is the
    priority we gave to the `observer` method in our example. Lower priority values
    take precedence; the default priority is `Interceptor.Priority.APPLICATION + 100`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Priority` 注解接受一个类型为 `int` 的参数。此参数指定了 `observer` 方法的优先级。最高优先级由 `Interceptor.Priority`
    类中定义的 `APPLICATION` 常量定义。这是我们给示例中的 `observer` 方法指定的优先级。较低的优先级值具有优先权；默认优先级是 `Interceptor.Priority.APPLICATION
    + 100`。'
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided an introduction to Contexts and Dependency Injection
    (CDI). We covered how JSF pages can access CDI named beans as if they were JSF
    managed beans. We also covered how CDI makes it easy to inject dependencies into
    our code via the `@Inject` annotation. Additionally, we explained how we can use
    qualifiers to determine which specific implementation of a dependency to inject
    into our code. Finally, we covered all the scopes that a CDI bean can be placed
    into, which include equivalents to all the JSF scopes, plus an additional two
    not included in JSF, namely, the conversation scope and the dependent scope.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了上下文和依赖注入（CDI）。我们介绍了 JSF 页面如何访问 CDI 命名豆，就像它们是 JSF 管理豆一样。我们还介绍了 CDI
    如何通过 `@Inject` 注解使代码注入依赖变得简单。此外，我们解释了如何使用限定符来确定要将哪个特定依赖项的实现注入到我们的代码中。最后，我们介绍了
    CDI 豆可以放置的所有作用域，这些作用域包括所有 JSF 作用域的等效作用域，另外还有两个不在 JSF 中包含的作用域，即会话作用域和依赖作用域。
