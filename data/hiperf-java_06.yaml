- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Strategic Object Creation and Immutability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 战略性对象创建和不可变性
- en: This chapter continues our quest to find ways to get the most performance out
    of our Java applications. Creating objects is a core part of all Java applications,
    so the goal is not to eradicate that; rather, it is to take a strategic approach
    to object creation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续我们的寻找方法，以从我们的Java应用程序中获得最佳性能。创建对象是所有Java应用程序的核心部分，因此目标不是消除它；而是采取战略性的对象创建方法。
- en: How and when we create objects can play a crucial role in application performance.
    Object creation impacts not only performance but also overall efficiency, garbage
    collection, and memory use. This chapter intends to provide you with the knowledge
    and skills you’ll need to implement an object creation strategy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何以及何时创建对象可能在应用程序性能中扮演关键角色。对象创建不仅影响性能，还影响整体效率、垃圾回收和内存使用。本章旨在为您提供实现对象创建策略所需的知识和技能。
- en: A core part of object creation strategies is the concept of object immutability.
    This chapter presents information and examples on how to make objects immutable
    and explains why you should consider it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对象创建策略的核心部分是对象不可变性的概念。本章提供了如何使对象不可变的信息和示例，并解释了为什么你应该考虑这一点。
- en: 'This chapter covers the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Minimizing object creation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化对象创建
- en: Object immutability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象不可变性
- en: Garbage collection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Design patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式
- en: By the end of this chapter, you should have an understanding and appreciation
    for the importance of strategic object creation and the powerful concept of object
    immutability. This understanding will help you improve the performance of your
    Java applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对战略性对象创建和对象不可变性的强大概念有一个理解和欣赏。这种理解将帮助你提高Java应用程序的性能。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples and instructions in this chapter, you will need to be
    able to load, edit, and run Java code. If you haven’t set up your development
    environment, please refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的示例和说明，你需要能够加载、编辑和运行Java代码。如果你还没有设置你的开发环境，请参阅[*第1章*](B21942_01.xhtml#_idTextAnchor014)。
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter06](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter06).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter06](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter06)。
- en: Minimizing object creation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化对象创建
- en: Minimizing object creation is a critical concern when we are striving for high-performance
    applications. Every time we create an object, we use memory and processing resources.
    Although modern systems have an impressive array of memory capacity and processing
    capabilities, they are not limitless.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在追求高性能应用程序时，最小化对象创建是一个关键关注点。每次我们创建一个对象，我们都会使用内存和处理资源。尽管现代系统拥有令人印象深刻的内存容量和处理能力，但它们并非无限。
- en: To ensure we handle this concern correctly, we should seek to understand the
    life cycle of a Java object, how object creation impacts memory, and what object
    pooling is. We should also experiment with different object initialization approaches
    and ways to reduce system overhead. That is the aim of this section. Let’s start
    our exploration of minimizing object creation by looking at the life cycle of
    Java objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们正确处理这个关注点，我们应该寻求理解Java对象的整个生命周期，对象创建如何影响内存，以及对象池是什么。我们还应该尝试不同的对象初始化方法和减少系统开销的方法。这就是本节的目标。让我们通过查看Java对象的整个生命周期来开始我们最小化对象创建的探索。
- en: Java object life cycle
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java对象生命周期
- en: 'The notion of an object in the Java programming language is nothing new. When
    considering high-performance Java applications, we need to consider the overall
    life cycle of our objects. The creation, use, and deletion of objects have a direct
    impact on the overall performance of our applications. The following figure depicts
    a typical object’s life cycle:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程语言中对象的概念并非新颖。在考虑高性能Java应用程序时，我们需要考虑我们对象的整个生命周期。对象的创建、使用和删除直接影响到我们应用程序的整体性能。以下图展示了典型对象的典型生命周期：
- en: '![Figure 6.1 – Java object life cycle](img/B21942_06_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – Java对象生命周期](img/B21942_06_1.jpg)'
- en: Figure 6.1 – Java object life cycle
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – Java对象生命周期
- en: 'As illustrated in *Figure 6**.1*, the first step of an object’s life cycle
    is object creation. When a new object is created, it is said to be `new` keyword
    to allocate memory on the heap so that we can store our object’s data:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图6**.1所示，对象生命周期的第一步是对象创建。当创建一个新对象时，它被称为使用`new`关键字在堆上分配内存，以便我们可以存储对象的数据：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The next phase of an object’s life cycle is its use and reference. This is where
    we execute the object’s methods and reference its properties.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对象生命周期的下一阶段是其使用和引用。这是执行对象方法并引用其属性的地方。
- en: The third phase is garbage collection. Once we stop using an object and it can
    no longer be referenced, the **Java Virtual Machine’s** (**JVM’s**) garbage collector
    will reclaim the memory the out-of-scope object is using.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个阶段是垃圾回收。一旦我们停止使用一个对象，并且它不能再被引用，Java虚拟机（**JVM**）的垃圾回收器将回收该对象使用的内存。
- en: The last phase of an object’s life cycle is when it is destroyed. The garbage
    collector takes care of this for us. Once the object is destroyed, it is no longer
    accessible to the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对象生命周期的最后阶段是它被销毁。垃圾回收器为我们处理这个问题。一旦对象被销毁，它就不再对应用程序可访问。
- en: Understanding an object’s life cycle is a prerequisite to being able to create
    and adopt an object creation strategy.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 理解对象的生命周期是能够创建和采用对象创建策略的先决条件。
- en: Memory
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存
- en: We implicitly understand that objects require memory to exist and that the more
    objects our applications use at one time, the more memory that is required. To
    support high performance, we should strive to understand how Java manages memory
    specific to object creation. To aid in our understanding, let’s look at three.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们隐含地理解到，对象的存在需要内存，并且我们的应用程序在某一时刻使用的对象越多，所需的内存就越多。为了支持高性能，我们应该努力理解Java如何管理特定于对象创建的内存。为了帮助我们的理解，让我们看看三个关键点。
- en: Stack versus heap memory
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈与堆内存
- en: '**Stacks** and **heaps** are both used for memory allocation, are used for
    different purposes, and behave differently. Let’s start by defining a stack.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈**和**堆**都用于内存分配，用于不同的目的，并且表现不同。让我们首先定义栈。'
- en: Stack
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 栈
- en: A stack is the region of memory where a static collection of elements using
    a **last in, first out** (**LIFO**) model is stored.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是内存区域，其中使用**后进先出**（**LIFO**）模型存储静态元素集合。
- en: Next, let’s look at what a heap is so that we can compare it to a stack and
    determine how both of them impact performance.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看堆是什么，以便我们可以将其与栈进行比较，并确定它们如何影响性能。
- en: Heap
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 堆
- en: A heap is an area of memory that’s used for dynamic memory allocation. Objects
    are allocated on the heap when we use the `new` keyword in our applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是用于动态内存分配的内存区域。当我们使用应用程序中的`new`关键字时，对象在堆上分配。
- en: Java uses both stacks and heaps and, as you’ve learned, they are used differently.
    Let’s look more deeply at stacks. We typically use stacks to store our application’s
    local variables, as well as reference information for our methods. Stacks use
    **LIFO** for efficient access to local variables and method calls. Limiting factors
    of stacks include their limited lifespan and size. This makes the use of stacks
    for long-term object storage impractical.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Java使用栈和堆，正如你所学的，它们的使用方式不同。让我们更深入地了解栈。我们通常使用栈来存储应用程序的局部变量，以及方法引用信息。栈使用**LIFO**以高效访问局部变量和方法调用。栈的限制因素包括其有限的生命周期和大小。这使得使用栈进行长期对象存储不切实际。
- en: We push objects onto the heap when we use Java’s `new` keyword. Heaps provide
    us with dynamic memory allocation. When we use a heap, our objects can exist outside
    the scope of the methods that created them. This necessitates the use of the JVM’s
    garbage collector to remove items from the heap that are unreachable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Java的`new`关键字时，我们将对象推入堆中。堆为我们提供动态内存分配。当我们使用堆时，我们的对象可以存在于创建它们的方法的范围之外。这需要使用JVM的垃圾回收器从堆中移除不可达的项。
- en: 'The following table summarizes the differences between stacks and heaps in
    Java:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了Java中栈和堆之间的差异：
- en: '| **Characteristic** | **Stack** | **Heap** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **特征** | **栈** | **堆** |'
- en: '| Storage | Local variables | Objects and their methods and properties |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 存储 | 局部变量 | 对象及其方法和属性 |'
- en: '| Memory management | LIFO order | Managed by the JVM garbage collector |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 内存管理 | LIFO顺序 | 由JVM垃圾回收器管理 |'
- en: '| Size | Limited | Larger than stacks |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | 有限 | 大于栈 |'
- en: '| Lifetime | Variables exist until the declaring method ends | Objects exist
    until they are no longer reachable |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 生命周期 | 变量存在直到声明它的方法结束 | 对象存在直到它们不再可达 |'
- en: '| Performance | Fast allocation and deallocation | Slower than stacks |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 快速分配和释放 | 比栈慢 |'
- en: Table 6.1 – Stack and heap comparison
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 – 栈和堆比较
- en: 'The key differences between stacks and heaps are their scope of use, how the
    memory is managed, access speed, and storage size. In addition, there are risks
    of errors at runtime. For example, a stack can run out of memory, which leads
    to a `StackOverflowError` error. If a heap runs out of memory, an `OutOfMemoryError`
    error can be thrown. We need to handle those errors. Let’s look at an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 栈和堆之间的关键区别在于它们的使用范围、内存管理方式、访问速度和存储大小。此外，还有运行时出错的风险。例如，栈可能会耗尽内存，导致`StackOverflowError`错误。如果堆耗尽内存，可能会抛出`OutOfMemoryError`错误。我们需要处理这些错误。让我们看一个例子：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we used `try`-`catch` blocks to trap the errors. Also, it is
    important to know that these errors are instances of `Error`, not `Exception`.
    So, these are indeed errors, not exceptions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用了`try`-`catch`块来捕获错误。此外，重要的是要知道这些错误是`Error`的实例，而不是`Exception`。因此，这些确实是错误，而不是异常。
- en: Memory management with garbage collection
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垃圾回收的内存管理
- en: One of the most prized features of the Java programming language is its **garbage
    collection**. This automatic memory deallocation can take a lot of responsibility
    off the developer’s shoulders, but there are some disadvantages as well. Let’s
    take a deeper look at Java’s seemingly straightforward garbage collection.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程语言中最受推崇的特性之一是其**垃圾回收**。这种自动内存释放可以减轻开发者的许多负担，但也有一些缺点。让我们更深入地了解一下Java看似简单的垃圾回收机制。
- en: Java’s garbage collector identifies objects that are no longer reachable in
    the application. Once identified, those objects are removed and the memory they
    used is deallocated, making it available to the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Java的垃圾回收器识别应用中不再可达的对象。一旦识别，这些对象将被移除，它们所使用的内存将被释放，使其可用于应用。
- en: While we can applaud the garbage collector’s efforts and appreciate the memory
    it frees up for our applications, there can be an impact on performance. When
    we have frequent garbage collection cycles, pauses and reduced responsiveness
    can be introduced at runtime. Mitigation strategies include minimizing object
    creation and implementing timely object disposal. These strategies can reduce
    the frequency of garbage collection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以赞扬垃圾回收器的努力，并感激它为我们的应用释放的内存，但它可能会对性能产生影响。当我们有频繁的垃圾回收周期时，运行时可能会引入暂停和响应速度降低。缓解策略包括最小化对象创建和及时处理对象。这些策略可以减少垃圾回收的频率。
- en: We will look at how to implement these strategies later in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论如何实现这些策略。
- en: Optimization techniques
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化技术
- en: 'There are several strategies that we can adopt to help optimize memory usage
    in our Java applications:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用几种策略来帮助优化Java应用程序中的内存使用：
- en: Limit object creation; only create them when absolutely needed
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制对象创建；仅在绝对需要时创建
- en: Avoid creating objects within loops
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在循环中创建对象
- en: Use local variables and object pooling (covered in [*Chapter 4*](B21942_04.xhtml#_idTextAnchor074))
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用局部变量和对象池（见[*第4章*](B21942_04.xhtml#_idTextAnchor074)）
- en: Implement object immutability (covered later in the *Object immutability* section
    of this chapter)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现对象不可变性（本章后面的*对象不可变性*部分将介绍）
- en: Use profiling tools for memory usage (see [*Chapter 14*](B21942_14.xhtml#_idTextAnchor250))
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能分析工具来监控内存使用（见[*第14章*](B21942_14.xhtml#_idTextAnchor250)）
- en: It is important to take a purposeful and informed approach to memory management
    in our Java applications. To do this, we need to understand memory limitations
    and how memory is allocated and deallocated.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Java应用程序中进行内存管理时，采取有目的和了解的方法是很重要的。为此，我们需要了解内存限制以及内存是如何分配和释放的。
- en: Object pooling
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象池
- en: As you may recall from [*Chapter 4*](B21942_04.xhtml#_idTextAnchor074), object
    pooling is an important design pattern we can use to create a set of objects that
    can be kept in a pool, ready for use, instead of allocating them when we need
    them and deallocating them when they go out of scope. Object pooling helps us
    to efficiently manage system resources by reusing objects. The benefits are especially
    noticeable when our objects are large and take significant time to create.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能从[*第4章*](B21942_04.xhtml#_idTextAnchor074)中回忆起，对象池是我们可以使用的重要设计模式，用于创建一组可以保存在池中、随时可供使用的对象，而不是在我们需要时分配它们，在它们超出作用域时释放它们。对象池通过重用对象帮助我们有效地管理系统资源。当我们的对象很大且创建需要花费大量时间时，这种方法的优点尤为明显。
- en: Initialization approaches
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化方法
- en: 'There is more than one way to create objects in Java and our initialization
    approach can significantly impact the overall performance of our Java applications
    and how our memory is used. Let’s look at four approaches: direct, lazy, pooling,
    and builder.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中创建对象有多种方式，我们的初始化方法可以显著影响Java应用程序的整体性能以及内存的使用方式。让我们看看四种方法：直接、懒加载、对象池和构建器。
- en: Direct initialization
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接初始化
- en: 'The most common method that’s used to create a new object is the **direct initialization**
    method. As shown in the following example, it’s straightforward. We use constructors
    or initializers with this method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新对象最常用的方法是**直接初始化**方法。如下面的示例所示，这种方法很简单。我们使用构造函数或初始化器来实现这种方法：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The benefits of this method are that it is easy to understand and program. It
    can also be used in many scenarios where objects need to be created. The disadvantages
    of this method include that it can lead to unnecessary object creation, which
    is the opposite of our goal to minimize object creation. This is especially evident
    when the direct initialization method is used inside loops or in methods that
    are called frequently. Another disadvantage is that the objects that are created
    using this method cannot be reused.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是易于理解和编程。它也可以用于许多需要创建对象的场景。这种方法的缺点包括可能导致不必要的对象创建，这与我们最小化对象创建的目标相反。这在使用直接初始化方法在循环或频繁调用的方法中尤为明显。另一个缺点是使用这种方法创建的对象不能被重用。
- en: Lazy initialization
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 懒加载初始化
- en: 'The strategy of delaying an object’s creation until it is needed by the application
    is referred to as **lazy initialization**. As illustrated in the following code
    snippet, the object isn’t created unless a specific condition exists:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象的创建推迟到应用程序需要时的策略被称为**懒加载初始化**。如下面的代码片段所示，除非存在特定条件，否则对象不会被创建：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An advantage of this method is that object creation is minimized until it is
    required. Additionally, memory usage is reduced when we conditionally create several
    objects. However, this strategy results in increased code complexity and can introduce
    synchronization issues when dealing with multi-threaded environments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是对象创建直到需要时才最小化。此外，当我们有条件地创建多个对象时，内存使用量会减少。然而，这种策略会导致代码复杂性增加，并且在处理多线程环境时可能会引入同步问题。
- en: Object pooling
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象池
- en: 'We can also use object pooling to create a pool of pre-initialized objects
    that can be used multiple times, taking them from and returning them to the pool
    as needed. The following code snippet shows how that code would be structured:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用对象池来创建一个预初始化的对象池，这些对象可以多次使用，根据需要从池中取出并返回。以下代码片段显示了这种代码的结构：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can revisit [*Chapter 4*](B21942_04.xhtml#_idTextAnchor074) for greater
    detail on object pooling.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以回顾[*第4章*](B21942_04.xhtml#_idTextAnchor074)以获取关于对象池的更多详细信息。
- en: Builder pattern
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建器模式
- en: 'Another increasingly popular method of object creation is using the builder
    pattern. This is a design pattern that treats object construction and its representation
    separately. This method empowers us to create multi-attribute objects one step
    at a time. The following code snippet illustrates the build pattern concept:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种越来越受欢迎的对象创建方法是使用构建器模式。这是一种将对象构建和其表示分别处理的设计模式。这种方法使我们能够逐步创建多属性对象。以下代码片段说明了构建器模式的概念：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One benefit of this method is that it introduces object construction flexibility.
    This can be very useful when you’re creating complex objects. Another benefit
    is that it permits us to set selected attributes by having a complex constructor.
    The primary disadvantage of the builder pattern method is that it requires us
    to define a separate builder class for each type of object that’s used in our
    applications. This can significantly increase our code’s complexity and decrease
    its readability and maintainability.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点之一是它引入了对象构造的灵活性。这在创建复杂对象时非常有用。另一个优点是它允许我们通过具有复杂构造函数来设置选定的属性。构建者模式方法的缺点之一是我们必须为应用程序中使用的每种类型的对象定义一个单独的构建器类。这可能会显著增加我们代码的复杂性，并降低其可读性和可维护性。
- en: Overhead reduction
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开销减少
- en: When we consider the goal of minimizing object creation, we should consider
    object pooling, object cloning, and object serialization. We touched on object
    pooling earlier in this chapter and provided in-depth coverage in [*Chapter 4*](B21942_04.xhtml#_idTextAnchor074).
    We will save our discussion on object cloning until later in this chapter. For
    now, know that it can be associated with overhead reduction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑最小化对象创建的目标时，我们应该考虑对象池、对象克隆和对象序列化。我们在本章前面提到了对象池，并在[*第4章*](B21942_04.xhtml#_idTextAnchor074)中提供了深入探讨。我们将把关于对象克隆的讨论留到本章的后面。现在，知道它可以与开销减少相关。
- en: The third concept is object serialization. Fortunately, Java allows us to convert
    objects to and from binary form. We typically use this for object persistence
    and can also use it to create copies of objects with reduced overhead.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个概念是对象序列化。幸运的是，Java允许我们将对象转换为二进制形式，也可以从二进制形式转换回对象。我们通常使用它进行对象持久化，也可以用它来创建具有减少开销的对象副本。
- en: 'Here’s an example of how we can serialize (convert into binary) and deserialize
    (convert back to an object):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，说明我们如何序列化（转换为二进制）和反序列化（转换回对象）：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Reducing overhead when creating objects should be a key consideration when our
    applications are expected to have high performance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建对象时减少开销应该是我们期望应用程序具有高性能时的一个关键考虑因素。
- en: Object immutability
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象不可变性
- en: Let’s continue learning how to minimize object creation to increase the performance
    of our Java applications. **Object immutability** refers to an object that cannot
    be modified once it has been instantiated. Immutability can be considered a property
    or characteristic of an object. The advantages of making objects **immutable**
    include system predictability and performance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续学习如何最小化对象创建，以提高我们的Java应用程序的性能。**对象不可变性**指的是一旦实例化后就不能被修改的对象。不可变性可以被视为对象的属性或特征。使对象**不可变**的优点包括系统可预测性和性能。
- en: Let’s start with a brief overview of object immutability.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从对象不可变性的简要概述开始。
- en: Immutability overview
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性概述
- en: Object immutability is not a new concept, but it is an important one. The general
    premise is that we create an object with all the desired attributes and behaviors,
    and then prevent it from being **mutated** (changed) throughout the object’s life
    cycle.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对象不可变性不是一个新概念，但它是非常重要的。一般前提是我们创建一个具有所有期望的属性和行为的对象，然后在整个对象的生命周期中防止它被**修改**（改变）。
- en: Immutable objects and considered safe because they cannot be changed. This means
    that we can share these objects in multi-threaded environments without the requirement
    for synchronization. So, concurrent programming is simplified. You will learn
    more about concurrency in [*Chapter 9*](B21942_09.xhtml#_idTextAnchor159).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象被认为是安全的，因为它们不能被改变。这意味着我们可以在多线程环境中共享这些对象，而不需要同步。因此，并发编程得到了简化。你将在[*第9章*](B21942_09.xhtml#_idTextAnchor159)中了解更多关于并发的内容。
- en: Immutable objects are known to have an immutable state, be safe for sharing,
    have predictable behavior, and align with functional programming principles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 已知不可变对象具有不可变状态、安全共享、可预测的行为，并与函数式编程原则一致。
- en: Best practices
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Creating immutable objects requires more than simply setting an attribute; it
    requires adherence to certain best practices. We want our immutable objects to
    be robust, the code to be maintainable, and positively contribute to the application’s
    overall performance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不可变对象不仅仅是设置一个属性；它需要遵循某些最佳实践。我们希望我们的不可变对象是健壮的，代码是可维护的，并且对应用程序的整体性能有积极贡献。
- en: Understanding these best practices is key to proper implementation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些最佳实践对于正确实施至关重要。
- en: Declare as final
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明为final
- en: 'The first best practice for creating immutable objects is to ensure all attributes
    are declared as `final`. The following code shows how to declare the class as
    `final`, as well as the two variables:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不可变对象的第一项最佳实践是确保所有属性都声明为`final`。以下代码展示了如何将类声明为`final`，以及两个变量：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adhering to this best practice ensures the attributes cannot be changed once
    the object is created. This can also help us detect any attempts to change the
    object at runtime.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这项最佳实践可以确保一旦对象创建，其属性就不能更改。这也有助于我们检测任何在运行时更改对象的尝试。
- en: Complete constructor
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整构造函数
- en: The second best practice is simply to ensure that all attributes of a class
    are initialized in the constructor. It is important to initialize all fields within
    the constructor. The goal is to ensure that the object is fully defined when it
    is created. Remember, we won’t be able to make changes to the object later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二项最佳实践仅仅是确保类的所有属性都在构造函数中初始化。在构造函数中初始化所有字段很重要。目标是确保对象在创建时完全定义。记住，我们以后将无法更改对象。
- en: Avoid setters
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免setter
- en: 'When you’ve been a Java developer for a considerable time, you’ll likely create
    setters and getters in your classes automatically. We don’t use a checklist; it
    just becomes a habit. In the case of immutable objects, we don’t want to give
    our applications the ability to call a setter since no changes should be made
    to the object after it’s created. The following code snippet shows how to create
    a standard class with a constructor. There is a getter method, but no setters:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你成为一名资深的Java开发者时，你可能会在类中自动创建setter和getter。我们不需要检查清单；这仅仅成为一种习惯。在不可变对象的情况下，我们不希望给我们的应用程序提供调用setter的能力，因为对象创建后不应对其进行任何更改。以下代码片段展示了如何创建一个带有构造函数的标准类。这里有一个getter方法，但没有setter：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since we shouldn’t be calling any setters on immutable objects, it’s important
    not to include them in our classes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不应该在不可变对象上调用任何setter，因此不包括它们在我们的类中是很重要的。
- en: Defensive copies
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防御性复制
- en: 'When we return a reference from an immutable object to an internal mutable
    object, it’s important to return a **defensive copy**. This prevents any external
    modification. The following code snippet demonstrates how we should implement
    this best practice:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从不可变对象返回一个指向内部可变对象的引用时，返回一个**防御性副本**是很重要的。这可以防止任何外部修改。以下代码片段演示了我们应该如何实现这项最佳实践：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using this approach helps ensure that the object’s state remains immutable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法有助于确保对象的状态保持不可变。
- en: Annotation
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注解
- en: 'Our last best practice when it comes to creating immutable objects is to use
    the `@Immutable` annotation. Here, we are using the **Project** **Lombok** library:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建不可变对象时，我们最后的最佳实践是使用`@Immutable`注解。在这里，我们使用的是**Lombok** **项目**库：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we use this annotation, we can benefit from auto-generated code making
    us more efficient. Note that this annotation may not be available in later versions
    of Lombok.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这个注解时，我们可以从自动生成的代码中受益，使我们更加高效。请注意，这个注解可能不会在Lombok的后续版本中可用。
- en: Performance advantages
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能优势
- en: 'As you have learned so far, object immutability offers several benefits to
    us and our applications. One category of benefits is performance. Here’s a list
    of performance advantages:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，对象的不可变性为我们和我们的应用程序提供了几个好处。其中一类好处是性能。以下是一个性能优势列表：
- en: '**Predicable state**: When using immutable objects, we can rely on their state
    to remain constant throughout their lifespan.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测状态**：当使用不可变对象时，我们可以依赖它们的状态在其生命周期内保持不变。'
- en: '**Garbage collection efficiency**: Using immutable objects reduces how often
    object collection and disposal functions have to run.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收效率**：使用不可变对象减少了对象收集和销毁函数需要运行的频率。'
- en: '**Safe caching**: We can safely cache immutable objects and even share them
    among multiple threads without data corruption concerns.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全缓存**：我们可以安全地缓存不可变对象，甚至可以在多个线程之间共享它们，而无需担心数据损坏。'
- en: '**Reduced overhead**: Because immutable objects are thread-safe, we don’t need
    to use synchronization mechanisms in multi-thread environments.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少开销**：因为不可变对象是线程安全的，所以我们不需要在多线程环境中使用同步机制。'
- en: '**Easier parallelization**: We can simplify concurrent programming and parallel
    programming when we use immutable objects.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于并行化**：当我们使用不可变对象时，可以简化并发编程和并行编程。'
- en: '**Functional programming advantage**: As mentioned previously, immutable objects
    align with functional programming. In that programming paradigm, functions produce
    predictable results without side effects.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式编程优势**：如前所述，不可变对象与函数式编程相一致。在该编程范式中，函数产生可预测的结果而没有副作用。'
- en: Understanding the performance advantages of using object immutability can encourage
    us to adopt this approach, which can result in sufficiently more performant Java
    applications.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 了解使用对象不可变性的性能优势可以鼓励我们采用这种方法，这可以导致Java应用程序的性能得到显著提升。
- en: Custom classes
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义类
- en: 'We previously reviewed best practices for implementing immutable objects. In
    addition to those best practices, we should implement the `equals` and `hashCode`
    methods. Let’s look at that in code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论了实现不可变对象的最佳实践。除了这些最佳实践之外，我们还应该实现`equals`和`hashCode`方法。让我们在代码中看看这一点：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, when we want to perform equality testing and ensure compatibility
    with certain data structures, we can override the `equals` and `hashCode` methods
    in our custom immutable classes. When we do this, we must ensure we consider all
    attributes that can contribute to equality.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当我们想要执行等性测试并确保与某些数据结构兼容时，我们可以在自定义不可变类中重写`equals`和`hashCode`方法。当我们这样做时，我们必须确保我们考虑了所有可能影响等性的属性。
- en: String classes
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串类
- en: As you likely know, strings are a commonly used data type and they are, by their
    very nature, immutable. Let’s look at how strings work as immutable objects so
    that we can better understand how to design immutable objects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，字符串是常用的数据类型，它们本质上就是不可变的。让我们看看字符串作为不可变对象是如何工作的，这样我们就能更好地理解如何设计不可变对象。
- en: 'Strings are indeed immutable and even when we think we are modifying them,
    Java is creating a new object. As an example, consider the following lines of
    code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串确实是不可变的，即使我们认为我们在修改它们，Java也会创建一个新的对象。例如，考虑以下代码行：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, when we call the `concat` method on the first string, a new
    string object is created.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当我们对第一个字符串调用`concat`方法时，会创建一个新的字符串对象。
- en: 'String immutability provides us with several advantages, such as thread safety,
    predictable behavior, and efficiency with string manipulations. Under the hood,
    Java maintains a string pool, also referred to as an intern pool, to store unique
    string literals. This is another advantage of string immutability. Let’s look
    at this in code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不可变性为我们提供了几个优势，例如线程安全、可预测的行为以及字符串操作的高效性。在底层，Java维护一个字符串池，也称为内部池，用于存储唯一的字符串字面量。这是字符串不可变性的另一个优势。让我们在代码中看看这一点：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A fifth advantage of string immutability is security. This means we can confidently
    use strings for sensitive data, such as banking information, passwords, and cryptographic
    keys, because unintentional modification is prevented.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不可变性的第五个优势是安全性。这意味着我们可以放心地使用字符串来存储敏感数据，例如银行信息、密码和加密密钥，因为无意中的修改被阻止了。
- en: Garbage collection
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: We have already established that memory management is important when our goal
    is to have our Java applications perform at a high level. We also looked at how
    garbage completion works and what its benefits are.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，当我们的目标是让Java应用程序以高水平运行时，内存管理很重要。我们还探讨了垃圾收集的工作原理及其好处。
- en: Garbage collection implications
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收的影响
- en: 'The automatic nature of Java’s garbage collection results in many developers
    ignoring it. They take garbage collection for granted and do not implement any
    best practices. This is okay for small projects that are not data- or memory-intensive.
    Let’s look at two ways that garbage collection can impact our applications and
    memory management:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Java垃圾回收的自动性导致许多开发者忽略了它。他们把垃圾回收视为理所当然，并且不实施任何最佳实践。对于小型项目来说，这没问题，因为这些项目不是数据密集型或内存密集型的。让我们看看垃圾回收如何影响我们的应用程序和内存管理：
- en: '**Application pauses**: Frequent garbage collection cycles can result in our
    application pausing. The type of garbage collection and heap size are key determiners
    for the length of these pauses.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序暂停**：频繁的垃圾回收周期可能导致我们的应用程序暂停。垃圾收集的类型和堆大小是决定这些暂停长度的重要因素。'
- en: '**Memory overhead**: Garbage collection increases memory overhead. CPU cycles
    and memory resources are impacted each time garbage collection runs.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：垃圾回收增加了内存开销。每次垃圾回收运行时，都会影响CPU周期和内存资源。'
- en: 'There are several approaches we can take to help mitigate the impact garbage
    collection has on our applications:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取几种方法来帮助减轻垃圾回收对我们应用程序的影响：
- en: Take a purposeful approach to managing the life cycle of our objects
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有目的地管理我们对象的生命周期
- en: Avoid unnecessary object creation
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免不必要的对象创建
- en: Reuse objects
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用对象
- en: Implement object pooling
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现对象池
- en: Use immutable objects
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变对象
- en: In the next section, we will look at how object cloning relates to garbage collection.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨对象拷贝如何与垃圾回收相关。
- en: Object cloning
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象拷贝
- en: 'As you might assume, **object cloning** is when we create a new object that
    is a duplicate of an existing one. Its relevance to garbage collection is due
    to its potential impact on how objects are managed and disposed of. The type of
    impact is influenced by the type of cloning used. Let’s look at two types of cloning:
    shallow and deep.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所假设的，**对象拷贝**是指我们创建一个与现有对象完全相同的新对象。它与垃圾回收的相关性在于它可能对对象的管理和处置方式产生影响。这种影响类型受所使用的拷贝类型的影响。让我们看看两种拷贝类型：浅拷贝和深拷贝。
- en: Shallow cloning
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浅拷贝
- en: 'The process of **shallow cloning** involves creating a new object by copying
    the contents of the original object. It’s important to note that if the original
    object contains any references to other objects, the clone will point to the same
    objects. This is an expected behavior; we are cloning all the objects so that
    they include references, but not the referenced objects. Let’s look at a brief
    example in code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**浅拷贝**的过程涉及通过复制原始对象的内容来创建一个新的对象。需要注意的是，如果原始对象包含对其他对象的引用，克隆将指向相同的对象。这是一个预期的行为；我们正在克隆所有对象，以便它们包含引用，但不包含被引用的对象。让我们通过一个简短的代码示例来看一下：'
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, when we clone a `Corgi` object, the new Corgi will share the
    same `authenticityCertificate` as the original. If that field is mutable, then
    changes that are made to it through one reference will take effect in both the
    original and cloned Corgi objects.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们克隆一个`Corgi`对象时，新的Corgi将共享与原始对象相同的`authenticityCertificate`。如果该字段是可变的，那么通过一个引用对其所做的更改将影响原始和克隆的Corgi对象。
- en: Deep cloning
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深拷贝
- en: 'When we create a **deep clone**, we still create a new object, but it also
    recursively copies all objects that are referenced by the original object. This
    method of cloning ensures that the new object and its sub-objects are independent
    of the original object. Let’s look at this in code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个**深拷贝**时，我们仍然创建一个新的对象，但它也会递归地复制原始对象引用的所有对象。这种拷贝方法确保新对象及其子对象与原始对象独立。让我们通过代码来看一下：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, when we clone a `Corgi` object, it is a new `Corgi` object and
    a new `Address` object is created. With this method, we can make changes to one
    object without impacting the other.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们克隆一个`Corgi`对象时，它是一个新的`Corgi`对象，并且创建了一个新的`Address`对象。使用这种方法，我们可以对其中一个对象进行更改，而不会影响另一个对象。
- en: Design patterns
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: 'Design patterns are time-tested solutions to common software problems. They
    can be considered a set of best practices and are widely used for Java development.
    Concerning strategic object creation and immutability, two design patterns deserve
    our attention:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是经过时间考验的常见软件问题的解决方案。它们可以被认为是一套最佳实践，并且在Java开发中被广泛使用。关于战略对象创建和不可变性，有两个设计模式值得我们关注：
- en: Singleton pattern
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: Factory pattern
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: What a design pattern is not
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是什么不是
- en: Design patterns are structured approaches to solving known problems. They are
    not algorithms, templates, libraries, or even code snippets. Instead, they offer
    high-level guidance that we can follow.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是解决已知问题的结构化方法。它们不是算法、模板、库，甚至不是代码片段。相反，它们提供了我们可以遵循的高级指导。
- en: Let’s look at each of these patterns so that we understand how their use can
    help improve the performance of our Java applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些模式，以便我们了解它们的使用如何帮助我们提高Java应用程序的性能。
- en: Singleton pattern
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: The **singleton design pattern** ensures that there is only one instance of
    a class and then provides global access to that instance. This pattern is often
    used when an application is managing database connections, resource management,
    logging, caching, or configuration settings.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**单例设计模式**确保只有一个类的实例，并提供对该实例的全局访问。当应用程序管理数据库连接、资源管理、日志记录、缓存或配置设置时，通常使用此模式。'
- en: 'Let’s look at a simple implementation approach for this pattern:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个模式的一个简单实现方法：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is a standard example. As you can see, this class prohibits
    more than one instance from being created. Additionally, the `getInstance()` method
    is how we provide global access to the instance of the `Singleton` class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个标准示例。正如您所看到的，这个类禁止创建多个实例。此外，`getInstance()` 方法是我们提供对 `Singleton` 类实例全局访问的方式。
- en: Factory pattern
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: 'The **factory design pattern** involves a superclass and an interface for creating
    objects in it. This pattern permits subclasses to alter what can be created. It
    promotes loose coupling between the superclass and the subclasses being created.
    The most common components of this pattern are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂设计模式**涉及一个超类和一个用于在其中创建对象的接口。此模式允许子类更改可以创建的内容。它促进了超类与正在创建的子类之间的松耦合。此模式最常见组件如下：'
- en: '**Abstract factory**: This is an interface that declares the method that’s
    used to create objects.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象工厂**: 这是一个声明用于创建对象的方法的接口。'
- en: '**Concrete factory**: This is a class that implements the abstract factory
    interface. It creates concrete objects.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体工厂**: 这是一个实现抽象工厂接口的类。它创建具体对象。'
- en: '**Product**: This is the object that’s created by the factory.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品**: 这是工厂创建的对象。'
- en: '**Concrete product**: This is the class that implements the product interface.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体产品**: 这是实现产品接口的类。'
- en: The advantages of using this pattern include separation of concerns, code reusability,
    flexibility, and encapsulation. Next, we will look at several code snippets that
    illustrate simple implementation examples.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模式的优势包括关注点的分离、代码的可重用性、灵活性和封装。接下来，我们将查看几个代码片段，以展示简单的实现示例。
- en: 'First, here is an example of an abstract product:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一个抽象产品的示例：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s look at an example of concrete products:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看具体产品的示例：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code snippet illustrates how to implement an abstract factory:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了如何实现抽象工厂：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lastly, the following code demonstrates how to implement concrete factories:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码演示了如何实现具体工厂：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The factory pattern can be a valuable tool when you need flexibility when it
    comes to creating objects based on specific requirements or conditions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要根据特定要求或条件创建对象时的灵活性时，工厂模式可以成为一个有价值的工具。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on strategic object creation and immutability, two closely
    related and equally important topics. We looked at various aspects of these topics
    to help improve the performance of our Java applications. Specifically, we looked
    at minimizing object creation, object immutability, garbage collection, and design
    patterns. You should now have a better understanding and deep appreciation for
    the importance of strategic object creation, as well as its best practices and
    implementation strategies. You should also have a firm grasp of the concept of
    object immutability.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了策略性对象创建和不可变性，这两个密切相关且同等重要的主题。我们研究了这些主题的各个方面，以帮助提高我们的 Java 应用程序的性能。具体来说，我们研究了最小化对象创建、对象不可变性、垃圾回收和设计模式。现在，您应该对策略性对象创建的重要性以及其实践和实现策略有更好的理解和深刻的认识。您也应该对对象不可变性的概念有牢固的掌握。
- en: In the next chapter, *String Objects*, we will take a deeper look into string
    objects while covering topics such as proper string pooling, lazy initialization,
    and string operation strategies.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，*字符串对象*，我们将深入探讨字符串对象，同时涵盖诸如适当的字符串池、延迟初始化和字符串操作策略等主题。
