- en: Chapter 2. Mapping Entity Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. 映射实体类
- en: In [Chapter 1](ch01.html "Chapter 1. Your First Application"), *Your First Application*,
    we used core Hibernate ORM to map an entity class to a database table, and then
    we used Hibernate Search to map two of its fields to a Lucene index. By itself,
    this provides a lot of search functionality that would be very cumbersome to code
    from scratch.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.html "第 1 章. 你的第一个应用")，*你的第一个应用*中，我们使用了核心 Hibernate ORM 来将一个实体类映射到数据库表，然后使用
    Hibernate Search 将它的两个字段映射到一个 Lucene 索引。仅凭这一点，就提供了很多搜索功能，如果从头开始编写将会非常繁琐。
- en: However, real-world applications usually involve numerous entities, many of
    which should be available for searching. Entities may be associated with each
    other, and our queries need to understand those associations so that we can search
    across multiple entities at once. We might want to declare that some mappings
    are more relevant to a search than others, or we might want to skip indexing data
    under certain conditions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际应用通常涉及许多实体，其中许多应该可供搜索使用。实体可能相互关联，我们的查询需要理解这些关联，这样我们才能一次性搜索多个实体。我们可能希望声明某些映射对于搜索来说比其他映射更重要，或者在某些条件下我们可能希望跳过索引数据。
- en: In this chapter, we will start to dive deeper into the options that Hibernate
    Search makes available for mapping entities. As a first step, we must take a look
    at the API options available in Hibernate ORM. How we map our entity classes to
    the database influences how Hibernate Search maps them to Lucene.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始深入探讨 Hibernate Search 为映射实体提供的选项。作为一个第一步，我们必须查看 Hibernate ORM 中的 API
    选项。我们如何将实体类映射到数据库，这将影响 Hibernate Search 如何将它们映射到 Lucene。
- en: Choosing an API for Hibernate ORM
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择 Hibernate ORM 的 API
- en: 'When the Hibernate Search documentation mentions different APIs for Hibernate
    ORM, it can be confusing. In some cases, this might refer to whether database
    queries are performed using an `org.hibernate.Session` or a `javax.persistence.EntityManager`
    object (an important part of the next chapter). However, in the context of entity
    mapping, this refers to the three different approaches offered by Hibernate ORM:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Hibernate Search 文档提到 Hibernate ORM 的不同 API 时，可能会令人困惑。在某些情况下，这可能指的是是否使用 `org.hibernate.Session`
    或者 `javax.persistence.EntityManager` 对象（下一章的重要部分）来执行数据库查询。然而，在实体映射的上下文中，这指的是 Hibernate
    ORM 提供的三种不同的方法：
- en: Annotation-based mapping with classic Hibernate-specific annotations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用经典 Hibernate 特定注解的基于注解的映射
- en: Annotation-based mapping with the Java Persistence API (JPA 2.0)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Java 持久化 API（JPA 2.0）的基于注解的映射
- en: XML-based mapping with `hbm.xml` files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `hbm.xml` 文件的基于 XML 的映射
- en: If you have only used Hibernate ORM with its classic annotations or XML-based
    mappings, or if you are new to Hibernate altogether, then this may be your first
    exposure to JPA. In a nutshell, JPA is a specification intended to serve as the
    official standard for object-relational mapping and similar features.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只使用过 Hibernate ORM 的经典注解或基于 XML 的映射，或者如果你是 Hibernate 的新手，那么这可能是你第一次接触到 JPA。简而言之，JPA
    是一个规范，旨在作为对象关系映射和其他类似功能的官方标准。
- en: The idea is to provide for ORM what JDBC provides for low-level database connectivity.
    Once a developer has learned JDBC, they can quickly work with any database driver
    that implements the API (for example, Oracle, PostgreSQL, MySQL, and so on). Likewise,
    if you understand JPA, then you should be able to easily switch between ORM frameworks,
    such as Hibernate, EclipseLink, and Apache OpenJPA.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是提供 ORM 所需的类似于 JDBC 提供的低级数据库连接。一旦开发者学会了 JDBC，他们就可以快速使用任何实现 API 的数据库驱动程序（例如，Oracle、PostgreSQL、MySQL
    等）。同样，如果你理解了 JPA，那么你应该能够轻松地在 Hibernate、EclipseLink 和 Apache OpenJPA 等 ORM 框架之间切换。
- en: In practice, different implementations often have their own quirks and proprietary
    extensions, which can cause transition headaches. However, a common standard does
    reduce the pain and learning curve dramatically.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，不同的实现通常有自己的怪癖和专有扩展，这可能会导致过渡性头痛。然而，一个共同的标准可以大大减少痛苦和学习曲线。
- en: 'A comparison of using the Hibernate ORM native API versus using JPA for entity
    mapping is shown in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Hibernate ORM 原生 API 与使用 JPA 进行实体映射的比较如下图所示：
- en: '![Choosing an API for Hibernate ORM](img/9205_01_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![选择 Hibernate ORM 的 API](img/9205_01_01.jpg)'
- en: The good news for long-time Hibernate developers is that JPA entity mapping
    annotations are remarkably similar to Hibernate's own annotations. In fact, the
    founder of Hibernate worked on the committee that developed JPA, and these two
    APIs have strongly influenced each other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对长期使用Hibernate的开发人员来说好消息是，JPA实体映射注解与Hibernate自己的注解非常相似。实际上，Hibernate的创始人参与了JPA委员会的开发，这两个API相互之间有很强的影响。
- en: The less-good news, depending on your perspective, is that Hibernate ORM 4.x
    deprecates its own mapping annotations in favor of their JPA counterparts. Those
    older annotations are targeted for removal in Hibernate ORM 5.x.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于你的观点，不那么好的消息是Hibernate ORM 4.x弃用自己的映射注解，以支持其JPA对应物。这些较旧的注解计划在Hibernate ORM
    5.x中删除。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It doesn't make sense to write a new code today using this deprecated approach,
    so we will disregard Hibernate-specific mapping annotations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如今使用这种已弃用的方法编写新代码没有意义，因此我们将忽略Hibernate特定的映射注解。
- en: The third option, XML-based mapping, is still commonly found in legacy applications.
    It is falling out of favor, and the Hibernate Search documentation jokes about
    XML being unfit for the 21st century! Of course, that is somewhat tongue-in-cheek,
    considering that basic Hibernate configuration still lives in a `hibernate.cfg.xml`
    or `persistence.xml` file. Still, the clear trend with most Java frameworks is
    to use annotations for configuration that is tied to a particular class, and to
    use some form of text file for global configuration.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选择，基于XML的映射，在遗留应用程序中仍然很常见。它正在失去青睐，Hibernate Search文档甚至开玩笑说XML不适合21世纪！当然，这有点开玩笑，考虑到基本的Hibernate配置仍然存储在`hibernate.cfg.xml`或`persistence.xml`文件中。尽管如此，大多数Java框架的趋势很明显，对于与特定类绑定的配置使用注解，对于全局配置使用某种形式的文本文件。
- en: Even if you are using `hbm.xml` files to map your entities to the database,
    you can still use the Hibernate Search annotations to map those entities to Lucene
    indexes. The two are perfectly compatible. This is convenient if you want to add
    Hibernate Search to a legacy application with minimal effort, or if you have a
    philosophical preference for `hbm.xml` files even when developing new applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你使用`hbm.xml`文件将实体映射到数据库，你仍然可以使用Hibernate Search注解将这些实体映射到Lucene索引。这两个完全兼容。如果你想在最小努力的情况下将Hibernate
    Search添加到遗留应用程序中，或者即使在开发新应用程序时也有哲学上的偏好使用`hbm.xml`文件，这很方便。
- en: 'The sample code for this book includes three versions of the VAPORware Marketplace
    application for this chapter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含VAPORware Marketplace应用程序的三种版本示例代码：
- en: The `chapter2` subdirectory continues where [Chapter 1](ch01.html "Chapter 1. Your
    First Application"), *Your First Application* left off, using JPA annotations
    for mapping entities to both the database and Lucene.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter2`子目录继续[第1章](ch01.html "第1章 你的第一个应用程序"), *你的第一个应用程序*的讲解，使用JPA注解将实体同时映射到数据库和Lucene。'
- en: The `chapter2-xml` subdirectory is a variant of the same code, modified to mix
    XML-based database mapping with JPA-based Lucene mapping.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter2-xml`子目录是相同代码的一个变体，修改为将基于XML的数据库映射与基于JPA的Lucene映射混合。'
- en: The `chapter2-mapping` subdirectory uses a special API to avoid annotations
    altogether. This is discussed further in the *Programmatic Mapping API* section
    near the end of this chapter.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chapter2-mapping`子目录使用一个特殊的API来完全避免注解。这在本章末尾的*程序化映射API*部分中进一步讨论。'
- en: You should explore all of this example code in detail to understand the available
    options. However, unless otherwise noted, the code examples in this book will
    focus on JPA annotations for both database and Lucene mapping.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该详细探索这些示例代码，以了解可用的选项。然而，除非另有说明，本书中的代码示例将重点介绍使用JPA注解对数据库和Lucene进行映射。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When JPA annotations are used for database mapping, Hibernate Search automatically
    creates a Lucene identifier for fields annotated with `@Id`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JPA注解进行数据库映射时，Hibernate Search会自动为用`@Id`注解的字段创建一个Lucene标识符。
- en: For whatever reason, Hibernate Search cannot do the same with Hibernate ORM's
    own mapping API. So when you are not using JPA to map entities to the database,
    you must also add the `@DocumentId` annotation to fields that should be used as
    Lucene identifiers (entities are known as **documents** in Lucene terminology).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 出于某种原因，Hibernate Search无法与Hibernate ORM自身的映射API相同。因此，当你不使用JPA将实体映射到数据库时，你也必须在应该用作Lucene标识符的字段上添加`@DocumentId`注解（在Lucene术语中，实体被称为**文档**）。
- en: Field mapping options
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段映射选项
- en: In [Chapter 1](ch01.html "Chapter 1. Your First Application"), *Your First Application*,
    we saw that member variables on a Hibernate-managed class are made searchable
    with the `@Field` annotation. Hibernate Search will put information about annotated
    fields into one or more Lucene indexes, using some sensible defaults.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章 你的第一个应用")*你的第一个应用*中，我们看到了Hibernate管理的类上的成员变量可以通过`@Field`注解变得可搜索。Hibernate
    Search会将关于注解字段的信息放入一个或多个Lucene索引中，使用一些合理的默认值。
- en: 'However, you can customize indexing behavior in numerous ways, some of which
    are optional elements in the `@Field` annotation itself. Most of these elements
    will be explored further throughout this book, but we will briefly introduce them
    here in one centralized list:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以以无数种方式自定义索引行为，其中一些是`@Field`注解本身的可选元素。本书将进一步探讨这些元素，但在这里我们将简要介绍它们：
- en: '`analyze`: This tells Lucene whether to store the field''s data as is, or put
    it through analysis, parsing, and processing it in various ways. It can be set
    to `Analyze.YES` (the default) or `Analyze.NO`. We will see this again in [Chapter
    3](ch03.html "Chapter 3. Performing Queries"), *Performing Queries*.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`analyze`：这告诉Lucene是存储字段数据原样，还是将其进行分析、解析，并以各种方式处理。它可以设置为`Analyze.YES`（默认）或`Analyze.NO`。我们将在[第3章](ch03.html
    "第3章 执行查询")*执行查询*中再次看到这一点。'
- en: '`index`: This controls whether or not the field should be indexed by Lucene.
    It can be set to `Index.YES` (the default) or `Index.NO`. It may sound nonsensical
    to use the `@Field` annotation and then not index the field, but this will make
    more sense after seeing projection-based searches in [Chapter 5](ch05.html "Chapter 5. Advanced
    Querying"), *Advanced Querying*.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：这控制是否由Lucene索引字段。它可以设置为`Index.YES`（默认）或`Index.NO`。在[第5章](ch05.html
    "第5章 高级查询")*高级查询*中介绍基于投影的搜索后，使用`@Field`注解但不索引字段听起来可能没有意义，但这将更有意义。'
- en: '`indexNullAs`: This declares how to handle null field values. By default, null
    values will simply be ignored and excluded from Lucene indexes. However, with
    this element fully covered in [Chapter 4](ch04.html "Chapter 4. Advanced Mapping"),
    *Advanced Mapping*, you can force null fields to be indexed with some default
    value instead.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexNullAs`：这声明了如何处理空字段值。默认情况下，空值将被简单忽略并从Lucene索引中排除。然而，在[第4章](ch04.html
    "第4章 高级映射")*高级映射*中，你可以强制将空字段索引化为某个默认值。'
- en: '`name`: This is a custom name, describing this field in the Lucene indexes.
    By default, Hibernate Search will use the name of the annotated member variable.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是一个自定义名称，用于描述字段在Lucene索引中的名称。默认情况下，Hibernate Search将使用注解的成员变量的名称。'
- en: '`norms`: This determines whether or not to store index-time information used
    for boosting, or adjusting the default relevance of search results. It can be
    set to `Norms.YES` (the default) or `Norms.NO`. Index-time boosting will appear
    in [Chapter 4](ch04.html "Chapter 4. Advanced Mapping"), *Advanced Mapping*.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`norms`：这决定了是否存储用于提升（boosting）或调整搜索结果默认相关性的索引时间信息。它可以设置为`Norms.YES`（默认）或`Norms.NO`。索引时间提升将在[第4章](ch04.html
    "第4章 高级映射")*高级映射*中介绍。'
- en: '`store`: Normally, fields are indexed in a manner optimized for searching,
    but this might not make it possible to retrieve the data in its original form.
    This option causes the raw data to be stored in such a way that you can later
    retrieve it directly from Lucene, rather than the database. It can be set to `Store.NO`
    (the default), `Store.YES`, or `Store.COMPRESS`. We will use this with projection-based
    searches in [Chapter 5](ch05.html "Chapter 5. Advanced Querying"), *Advanced Querying*.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store`：通常，字段以优化搜索的方式进行索引，但这可能不允许以原始形式检索数据。此选项使原始数据以这种方式存储，以至于你可以在稍后直接从Lucene而不是数据库中检索它。它可以设置为`Store.NO`（默认）、`Store.YES`或`Store.COMPRESS`。我们将在[第5章](ch05.html
    "第5章 高级查询")*高级查询*中与基于投影的搜索一起使用这个选项。'
- en: Multiple mappings for the same field
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相同字段的多重映射
- en: Sometimes, you need to use one set of options to do certain things with a field,
    and other set of options to do other things. We will see this later in [Chapter
    3](ch03.html "Chapter 3. Performing Queries"), *Performing Queries* when we make
    a field both searchable and sortable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要用一组选项对字段进行某些操作，用另一组选项进行其他操作。我们将在[第3章](ch03.html "第3章 执行查询")*执行查询*中看到这一点，当我们使一个字段既可搜索又可排序。
- en: 'For the time being, suffice it to say that you can have as many custom mappings
    as you wish for the same field. Just include multiple `@Field` annotations, wrapped
    within the plural `@Fields`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时先说这么多，你可以在同一个字段上有尽可能多的自定义映射。只需包含多个 `@Field` 注解，用复数的 `@Fields` 包裹起来即可：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don't worry too much about this example right now. Just note that when you create
    more than one mapping for the same field, you need to give them distinct names
    with the `name` element, so that you can later reference the correct mapping.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不用担心这个例子。只需注意，当你为同一个字段创建多个映射时，你需要通过 `name` 元素给它们赋予不同的名称，这样你以后才能正确引用。
- en: Mapping numeric fields
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值字段映射
- en: In [Chapter 1](ch01.html "Chapter 1. Your First Application"), *Your First Application*,
    our entity mapping examples dealt exclusively with string properties. It is likewise
    perfectly fine to use the same `@Field` annotation with other basic data types
    as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 你的第一个应用程序")，*你的第一个应用程序*中，我们的实体映射示例仅涉及字符串属性。同样，使用相同的 `@Field`
    注解与其他基本数据类型也是完全没问题的。
- en: However, fields mapped this way are indexed by Lucene in string format. That
    is very inefficient for techniques that we will explore later, such as sorting
    and querying over a range.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方式映射的字段被 Lucene 以字符串格式索引。这对于我们稍后探讨的技术（如排序和范围查询）来说非常低效。
- en: To improve the performance of such operations, Hibernate Search offers a specialized
    data structure for indexing numeric fields. This option is available when mapping
    fields of type `Integer`, `Long`, `Float`, and `Double` (or their primitive counterparts).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高此类操作的性能，Hibernate Search 提供了一个用于索引数值字段的特殊数据结构。当映射 `Integer`、`Long`、`Float`
    和 `Double`（或它们的原始类型）类型的字段时，此选项是可用的。
- en: 'To use this optimized data structure for a numeric field, you simply add the
    `@NumericField` annotation in addition to the normal `@Field`. As an example,
    let''s give the `App` entity in our VAPORware Marketplace application a field
    for price:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要为数值字段使用这个优化的数据结构，你只需在正常的 `@Field` 注解之外添加 `@NumericField` 注解。作为一个例子，让我们在 VAPORware
    Marketplace 应用程序的 `App` 实体中添加一个价格字段：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are applying this annotation to a property that has been mapped multiple
    times with `@Fields`, you must specify *which* of those mappings should use the
    specialized data structure. This is done by giving the `@NumericField` annotation
    an optional `forField` element, set to the same name as the desired `@Field`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此注解应用于已经多次映射到 `@Fields` 的属性，你必须指定*哪个*映射应使用特殊的数据结构。这通过给 `@NumericField` 注解一个可选的
    `forField` 元素来实现，该元素设置为所需 `@Field` 的相同名称。
- en: Relationships between entities
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体间的关系
- en: Every time an entity class is annotated with `@Indexed`, by default Hibernate
    Search will create a Lucene index just for that class. We can have as many entities,
    and as many separate indexes, as we wish. However, searching each index separately
    would be a very awkward and cumbersome approach.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个实体类被 `@Indexed` 注解标记时，默认情况下 Hibernate Search 将为该类创建一个 Lucene 索引。我们可以有尽可能多的实体和单独的索引。然而，单独搜索每个索引将是一种非常笨拙和繁琐的方法。
- en: Most Hibernate ORM data models already capture the various associations between
    entity classes. When we search an entity's Lucene index, shouldn't Hibernate Search
    follow those associations? In this section we will see how to make it do just
    that.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Hibernate ORM 数据模型已经捕捉了实体类之间的各种关联。当我们搜索实体的 Lucene 索引时，Hibernate Search 难道不应该跟随这些关联吗？在本节中，我们将了解如何使其这样做。
- en: Associated entities
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联实体
- en: So far, the entity fields in our example application have been simple data types.
    The `App` class represents a table named `APP`, and its member variables map to
    columns in that table. Now let's add a complex type field, for a second database
    table that is associated through a foreign key.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们示例应用程序中的实体字段一直是很简单的数据类型。`App` 类代表了一个名为 `APP` 的表，它的成员变量映射到该表的列。现在让我们添加一个复杂类型的字段，用于关联第二个数据库表的一个外键。
- en: Online app stores usually support a range of different hardware devices. So
    we will create a new entity called `Device`, representing devices for which an
    `App` entity is available.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在线应用商店通常支持一系列不同的硬件设备。因此，我们将创建一个名为 `Device` 的新实体，代表有 `App` 实体可用的设备。
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most details of this class should be familiar from [Chapter 1](ch01.html "Chapter 1. Your
    First Application"), *Your First Application*. `Device` is annotated with `@Entity`,
    so Hibernate Search will create a Lucene index just for it. The entity class contains
    searchable fields for device name, and manufacturer name.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此类的大多数细节应该从[第1章](ch01.html "第1章 你的第一个应用程序") *你的第一个应用程序* 中熟悉。`Device`用`@Entity`注解标记，因此Hibernate
    Search将为它创建一个Lucene索引。实体类包含可搜索的设备名称和制造商名称字段。
- en: However, the `supportedApps` member variable introduces a new annotation, for
    making the association between these two entities bidirectional. An `App` entity
    will contain a list of all its supported devices, and a `Device` entity will contain
    a list of all its supported apps.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`supportedApps`成员变量引入了一个新注解，用于实现这两个实体之间的双向关联。一个`App`实体将包含一个它所支持的所有设备的列表，而一个`Device`实体将包含一个它所支持的所有应用的列表。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If for no other reason, using bidirectional associations improves the reliability
    of Hibernate Search.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有其他原因，使用双向关联可以提高Hibernate Search的可靠性。
- en: A Lucene index contains denormalized data from associated entities, but those
    entities are still primarily tied to their own Lucene indexes. To cut a long story
    short, when the association between two entities is bidirectional, and changes
    are set to cascade, then you can count on both indexes being updated when either
    entity changes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Lucene索引包含来自关联实体的非规范化数据，但这些实体仍然主要与它们自己的Lucene索引相关联。长话短说，当两个实体的关联是双向的，并且变化被设置为级联时，那么当任一实体发生变化时，您都可以确信两个索引都会被更新。
- en: The Hibernate ORM reference manual describes several bidirectional mapping types
    and options. Here we are using `@ManyToMany`, to declare a many-to-many relationship
    between the `App` and `Device` entities. The `cascade` element is set to ensure
    that changes on this end of the association properly update the other side.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate ORM参考手册描述了几种双向映射类型和选项。在这里我们使用`@ManyToMany`，以声明`App`和`Device`实体之间的多对多关系。`cascade`元素被设置以确保此端关联的变化正确地更新另一端。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Normally, Hibernate is "lazy". It doesn't actually fetch associated entities
    from the database until they are needed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Hibernate是“懒加载”的。它实际上直到需要时才从数据库中检索关联实体。
- en: However, here we are writing a multi-tiered application, and the controller
    servlet has already closed the Hibernate session by the time our search results
    JSP receives these entities. If a view tries to fetch associations after the session
    has closed, errors will occur.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里我们正在编写一个多层应用程序，当我们的搜索结果JSP接收到这些实体时，控制器servlet已经关闭了Hibernate会话。如果视图尝试在会话关闭后检索关联，将会发生错误。
- en: There are several ways around this problem. For simplicity, we are also adding
    a `fetch` element to the `@ManyToMany` annotation, changing the fetch type from
    "lazy" to "eager". Now when we retrieve a Device entity, Hibernate will immediately
    fetch all the associated `App` entities while the session is still open.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有几个解决方法。为了简单起见，我们还在`@ManyToMany`注解中添加了一个`fetch`元素，将检索类型从“懒加载”更改为“ eager”。现在当我们检索一个Device实体时，Hibernate会在会话仍然开启时立即获取所有关联的`App`实体。
- en: Eager fetching is very inefficient with large amounts of data, however, so in
    [Chapter 5](ch05.html "Chapter 5. Advanced Querying"), *Advanced Querying*, we
    will explore a more advanced strategy for handling this.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大量数据的情况下，积极检索是非常低效的，因此，在[第5章](ch05.html "第5章 高级查询") *高级查询* 中，我们将探讨一个更高级的策略来处理这个问题。
- en: Everything about `supportedApps` discussed so far has been in the realm of Hibernate
    ORM. So last but not least, we will add the Hibernate Search `@ContainedIn` annotation,
    declaring that `App`'s Lucene index should contain data from `Device`. Hibernate
    ORM already saw these two entities as being associated. The Hibernate Search `@ContainedIn`
    annotation sets up a bidirectional association from Lucene's perspective too.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，关于`supportedApps`的一切都是在Hibernate ORM的范畴内。所以最后但并非最不重要的是，我们将添加Hibernate Search的`@ContainedIn`注解，声明`App`的Lucene索引应包含来自`Device`的数据。Hibernate
    ORM已经将这两个实体视为有关联。Hibernate Search的`@ContainedIn`注解也为Lucene设置了双向关联。
- en: The other half of the bidirectional association involves giving the `App` entity
    class a list of supported `Device` entity classes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 双向关联的另一面涉及向`App`实体类提供一个支持`Device`实体类的列表。
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is very similar to the `Device` side of the association, except that the
    `@IndexedEmbedded` annotation here serves as the counterpoint to `@ContainedIn`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这与关联的`Device`方面非常相似，不同之处在于这里的`@IndexedEmbedded`注解是`@ContainedIn`的反向。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your associated objects contain other associated objects themselves, then
    you might end up indexing a lot more data than you wanted. Even worse, you could
    run into problems with circular dependencies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的关联对象本身就包含其他关联对象，那么你可能会索引比你想要的更多的数据。更糟糕的是，你可能会遇到循环依赖的问题。
- en: To safeguard against this, set the `@IndexEmbedded` annotation's optional `depth`
    element to a max limit. When indexing objects, Hibernate Search will go no further
    than the specified number of levels.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，将`@IndexEmbedded`注解的可选`depth`元素设置为一个最大限制。在索引对象时，Hibernate Search将不会超过指定层数。
- en: The previous code specifies a depth of one level. This means that an app will
    be indexed with information about its supported devices, but *not* information
    about a device's other supported apps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码指定了一层深度。这意味着一个应用将带有关于它支持设备的信息进行索引，但*不包括*设备支持的其他应用的信息。
- en: Querying associated entities
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询关联实体
- en: 'Once associated entities have been mapped for Hibernate Search, it is easy
    to include them in search queries. The following code snippet updates `SearchServlet`
    to add `supportedDevices` to the list of fields searched:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为Hibernate Search映射了关联实体，它们很容易被包含在搜索查询中。以下代码片段更新了`SearchServlet`以将`supportedDevices`添加到搜索字段列表中：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Complex types are a bit different from the simple data types we have worked
    with so far. With complex types, we are not really interested in the field itself,
    because the field is actually just an object reference (or a collection of object
    references).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂类型与我们迄今为止处理过的简单数据类型略有不同。对于复杂类型，我们实际上并不太关心字段本身，因为字段实际上只是一个对象引用（或对象引用的集合）。
- en: What we really want our searches to match are the simple data type fields within
    the complex type. In other words, we want to search the `Device` entity's `name`
    field. So, as long as an associated class field has been indexed (that is, with
    the `@Field` annotation), it can be queried with a [entity field].[nested field]
    format, such as `supportedDevices.name` in the previous code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正希望搜索匹配的是复杂类型中的简单数据类型字段。换句话说，我们希望搜索`Device`实体的`name`字段。因此，只要关联类字段已被索引（即使用`@Field`注解），它就可以使用[实体字段].[嵌套字段]格式进行查询，例如之前的代码中的`supportedDevices.name`。
- en: In the sample code for this chapter, `StartupDataLoader` has been expanded to
    save some `Device` entities in the database, and associate them with the `App`
    entities. One of these test devices is named xPhone. When we run the VAPORware
    Marketplace application and search for this keyword, the search results will include
    apps that are compatible with the xPhone, even if that keyword doesn't appear
    in the name or description of the app itself.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例代码中，`StartupDataLoader`已经扩展以在数据库中保存一些`Device`实体并将它们与`App`实体关联。这些测试设备中的一个名为xPhone。当我们运行VAPORware
    Marketplace应用并搜索这个关键词时，搜索结果将包括与xPhone兼容的应用，即使这个关键词没有出现在应用的名称或描述中。
- en: Embedded objects
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入对象
- en: Associated entities are full-blown entities in their own right. They typically
    correspond to a database table and Lucene index of their own, and may stand apart
    from their associations. For example, if we delete an app entity that is supported
    on the xPhone, that doesn't mean we want to delete the xPhone `Device` too.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关联实体是完整的实体。它们通常对应自己的数据库表和Lucene索引，并且可以独立于它们的关联存在。例如，如果我们删除了在xPhone上支持的应用实体，那并不意味着我们想要删除xPhone的`Device`。
- en: There is a different type of association, in which the lifecycle of associated
    objects depends on the entity that contains them. If the VAPORware Marketplace
    apps had customer reviews, and an app was permanently deleted from the database,
    then we would probably expect all its customer reviews to be removed along with
    it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种不同的关联类型，其中关联对象的生存周期取决于包含它们的实体。如果VAPORware Marketplace应用有客户评论，并且一个应用从数据库中被永久删除，那么我们可能期望与它一起删除所有客户评论。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Classic Hibernate ORM terminology refers to such objects as **components** (or
    sometimes **elements** ). In the newer JPA jargon, they are known as **embedded
    objects**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 经典Hibernate ORM术语将这些对象称为**组件**（有时也称为**元素**）。在新版JPA术语中，它们被称为**嵌入对象**。
- en: Embedded objects are not entities themselves. Hibernate Search does not create
    separate Lucene indexes for them, and they cannot be searched outside the context
    of the entity containing them. Otherwise, they look and feel quite similar to
    associated entities.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入对象本身并不是实体。Hibernate Search不会为它们创建单独的Lucene索引，并且它们不能在没有包含它们的实体的上下文中被搜索。否则，它们在外观和感觉上与关联实体非常相似。
- en: Let's give the example application an embedded object type for customer reviews.
    A `CustomerReview` instance will consist of the username of the person submitting
    the review, the rating they gave (for example, five stars), and any additional
    comments they wrote.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给示例应用程序添加一个客户评论的嵌入对象类型。`CustomerReview`实例将包括提交评论的人的用户名，他们给出的评分（例如，五颗星），以及他们写的任何附加评论。
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This class is annotated with `@Embeddable` rather than the usual `@Entity` annotation,
    telling Hibernate ORM that the lifecycle of a `CustomerReview` instance is dependent
    on whichever entity object contains it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被注解为`@Embeddable`而不是通常的`@Entity`注解，告诉Hibernate ORM`CustomerReview`实例的生命周期取决于包含它的哪个实体对象。
- en: The `@Field` annotation is applied to searchable fields as before. However,
    Hibernate Search will not create a standalone Lucene index just for `CustomerReview`.
    This annotation only adds information to the indexes of other entities that contain
    this embeddable class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Field`注解仍然应用于可搜索的字段。然而，Hibernate Search不会为`CustomerReview`创建独立的Lucene索引。这个注解只是向包含这个嵌入类其他实体的索引中添加信息。'
- en: 'In our case, the containing class will be `App`. Let''s give it a set of customer
    reviews as a member variable:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，包含类将是`App`。给它一个客户评论作为成员变量：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Rather than one of the usual JPA relationship annotations (for example, `@OneToOne`,
    `@ManyToMany`, and so on), this field is annotated as a JPA `@ElementCollection`.
    If this field were a single object, no annotation would be necessary. JPA would
    simply figure it out based on that object class having the `@Embeddable` annotation.
    However, the `@ElementCollection` annotation is necessary when dealing with collections
    of embeddable elements.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用通常的JPA关系注解（例如，`@OneToOne`，`@ManyToMany`等），此字段被注解为JPA `@ElementCollection`。如果这个字段是一个单一对象，则不需要任何注解。JPA会简单地根据该对象类具有`@Embeddable`注解来推断出来。然而，当处理嵌入元素的集合时，需要`@ElementCollection`注解。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When using classic XML-based Hibernate mapping, the `hbm.xml` file equivalents
    are `<component>` for single instances, and `<composite-element>` for collections.
    See the `chapter2-xml` variant of the downloadable sample application source.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于经典XML的Hibernate映射时，`hbm.xml`文件等效物是`<component>`用于单个实例，`<composite-element>`用于集合。请参阅可下载示例应用程序源代码的`chapter2-xml`变体。
- en: The `@ElementCollection` annotation has a `fetch` element set to use eager fetching,
    for the same reasons discussed earlier in this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ElementCollection`注解有一个`fetch`元素设置为使用 eager fetching，原因与本章前面讨论的原因相同。'
- en: On the next line we use the Hibernate-specific `@Fetch` annotation, to ensure
    that the `CustomerReview` instances are fetched through multiple `SELECT` statements
    rather than a single `OUTER JOIN`. This avoids duplication of customer reviews,
    due to Hibernate ORM quirks that are discussed further in comments within the
    downloadable source code. Unfortunately, this mode is inefficient when dealing
    with very large collections, so you may wish to consider another approach in such
    cases.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们使用Hibernate特定的`@Fetch`注解，以确保通过多个`SELECT`语句而不是单个`OUTER JOIN`来获取`CustomerReview`实例。这避免了由于Hibernate
    ORM的怪癖而在下载源代码中的注释中进一步讨论而导致的客户评论重复。不幸的是，当处理非常大的集合时，这种模式效率低下，因此在这种情况下你可能希望考虑另一种方法。
- en: 'Querying embedded objects is the same as with associated entities. Here is
    the query code snippet from `SearchServlet`, modified to also search against the
    comments fields of the embedded `CustomerReview` instances:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查询嵌入对象与关联实体相同。以下是从`SearchServlet`中修改的查询代码片段，以针对嵌入的`CustomerReview`实例的注释字段进行搜索：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we have a query that is really doing some searching! The `chapter2` version
    of `StartupDataLoader` has been extended to load some customer reviews for all
    of the test apps. Searches will now produce results when a match is found in a
    customer review, even though the keyword doesn't otherwise appear in the `App`
    itself.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个真正进行搜索的查询！`chapter2`版本的`StartupDataLoader`已扩展以加载所有测试应用的客户评论。当在客户评论中找到匹配项时，搜索现在将产生结果，尽管关键词本身没有出现在`App`中。
- en: 'The HTML in the VAPORware Marketplace application has also been updated. Now
    each search result has a **Full Details** button, which pops-up a modal box with
    supported devices and customer reviews for that app. Notice that the search keyword
    in this screenshot is matched against a customer review rather the actual app
    description:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 市场应用中的VAPORware HTML也得到了更新。现在每个搜索结果都有一个**完整详情**按钮，它会弹出一个包含支持设备和对该应用的客户评论的模态框。注意在这个截图中，搜索关键词是与客户评论相匹配，而不是与实际的应用描述相匹配：
- en: '![Embedded objects](img/9205_02_02.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入对象](img/9205_02_02.jpg)'
- en: Partial indexing
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分索引
- en: Associated entities each have their own Lucene index, and also store some data
    in each other's indexes. With embedded objects, search information is stored *exclusively*
    in the containing entity's index.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关联实体每个都有自己的Lucene索引，并在彼此的索引中存储一些数据。对于嵌入对象，搜索信息存储在*专有*的包含实体的索引中。
- en: However, bear in mind that these classes may be associated or embedded in more
    than one place. For example, if you had the `Customer` and `Publisher` entities
    in your data model, both of them might have an embedded object of type `Address`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，这些类可能在不止一个地方被关联或嵌入。例如，如果你的数据模型中有`Customer`和`Publisher`实体，它们可能都有一个`Address`类型的嵌入对象。
- en: Normally, we use the `@Field` annotation to tell Hibernate Search which fields
    should be indexed and searchable. However, what if we want this to vary with associated
    or embedded objects? What if we want a field to be indexed, or not indexed, depending
    on which other entity contains it? Hibernate Search provides this ability through
    an optional element in the `@IndexedEmbedded` annotation. This `includePaths`
    element indicates that within the Lucene index for *this* containing entity, only
    certain fields of the associated entity or embedded object should be included.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用`@Field`注解来告诉Hibernate Search哪些字段应该被索引和搜索。但是，如果我们想要这个字段随着相关或嵌入的对象而变化呢？如果我们想要一个字段根据包含它的其他实体是否被索引呢？Hibernate
    Search通过`@IndexedEmbedded`注解的可选元素提供了这种能力。这个`includePaths`元素表明在*这个*包含实体的Lucene索引中，只应该包含关联实体或嵌入对象的某些字段。
- en: 'In our example application, the `CustomerReview` class has both its `username`
    and `comments` variable annotated as searchable fields. However, let''s say that
    for the `customerReviews` embedded within `App`, we only care about searching
    on comments. The change to `App` looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，`CustomerReview`类将其`username`和`comments`变量都注解为可搜索的字段。然而，假设对于`App`内的`customerReviews`，我们只关心在评论上进行搜索。`App`的变化如下所示：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Even though `CustomerReview.username` is annotated with `@Field`, that field
    will not be added to the Lucene index for `App`. This saves space, and improves
    performance by not making Lucene work hard on unnecessary indexing. The only trade-off
    is that to prevent errors, we must remember to avoid using any non-included fields
    in our query code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`CustomerReview.username`被注解为`@Field`，但这个字段不会添加到`App`的Lucene索引中。这节省了空间，通过不必要的索引来提高性能。唯一的权衡是，为了防止错误，我们必须记得在我们的查询代码中避免使用任何未包含的字段。
- en: The programmatic mapping API
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序化映射API
- en: In the beginning of this chapter we said that even when you map entities to
    the database with `hbm.xml` files, you can still use Hibernate Search annotations
    mapping to Lucene. However, if you really want to avoid putting annotations in
    your entity classes altogether, there is an API available for declaring your Lucene
    mappings programmatically at runtime.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我们说过，即使你使用`hbm.xml`文件将实体映射到数据库，你仍然可以使用Hibernate Search注解映射到Lucene。然而，如果你真的想完全避免在实体类中放置注解，有一个API可以在运行时以程序化的方式声明你的Lucene映射。
- en: This might come in handy if your search configuration needs to change at runtime
    based on some circumstances. It is also the only approach available if you cannot
    alter your entity classes for some reason, or if you are a hard-line believer
    in separating your configuration from your POJO's.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在运行时根据某些情况更改搜索配置，这可能会有所帮助。这也是如果你不能出于某种原因更改实体类，或者如果你是坚定的配置与POJO分离主义者，这是唯一可用的方法。
- en: The heart of the programmatic mapping API is the `SearchMapping` class, which
    stores the Hibernate Search configuration that is normally pulled from annotations.
    Typical usage looks like the query DSL code that we saw in the previous chapter.
    You call a method on a `SearchMapping` object, call a method on the object returned,
    and so on in a long nested series.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化映射API的核心是`SearchMapping`类，它存储了通常从注解中提取的Hibernate Search配置。典型的使用方式看起来像我们在前一章看到的查询DSL代码。你在`SearchMapping`对象上调用一个方法，然后调用返回对象上的方法，以此类推，形成一个长长的嵌套系列。
- en: The methods available at each step of the way intuitively resemble the search
    annotations that you have already seen. The `entity()` method replaces the `@Entity`
    annotation, `indexed()` replaces `@Indexed`, `field()` replaces `@Field`, and
    so on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步可用的方法都直观地类似于你已经见过的搜索注解。`entity()`方法替代了`@Entity`注解，`indexed()`替代了`@Indexed`，`field()`替代了`@Field`，等等。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to use the programmatic mapping API in an application, then you
    can find more details in *Reference Manual* and *Javadocs*, both available at
    [http://www.hibernate.org/subprojects/search/docs](http://www.hibernate.org/subprojects/search/docs).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在应用程序中使用程序化映射API，那么你可以在[http://www.hibernate.org/subprojects/search/docs](http://www.hibernate.org/subprojects/search/docs)找到更多详细信息，该链接提供了*参考手册*和*Javadocs*，它们都可供查阅。
- en: The starting point in Javadocs is the `org.hibernate.search.cfg.SearchMapping`
    class, and the other relevant classes are all in the `org.hibernate.search.cfg`
    package as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Javadocs的起点是`org.hibernate.search.cfg.SearchMapping`类，其他相关的类也都位于`org.hibernate.search.cfg`包中。
- en: In the downloadable source code available from the Packt Publishing website,
    the `chapter2-mapping` subdirectory contains a version of the VAPORware Marketplace
    application that uses the programmatic mapping API.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从Packt Publishing网站下载的源代码中，`chapter2-mapping`子目录包含了一个使用程序化映射API的VAPORware Marketplace应用程序版本。
- en: 'This version of the example application includes a factory class, with a method
    that configures and returns a `SearchMapping` object upon demand. It doesn''t
    matter what you name the class or the method, so long as the method is annotated
    with `@org.hibernate.search.annotations.Factory`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应用的版本包含一个工厂类，其中有一个方法根据需求配置并返回一个`SearchMapping`对象。无论你给这个类或方法起什么名字，只要这个方法用`@org.hibernate.search.annotations.Factory`注解标记即可：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that this factory method is only three lines long, strictly speaking.
    The bulk of it is one continuous line of chained method calls, originating from
    the `SearchMapping` object, that map our three persistent classes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个工厂方法严格来说只有三行长。它的主要部分是一个从`SearchMapping`对象开始的连续一行链式方法调用，这个调用将我们的三个持久化类映射到Lucene。
- en: 'To integrate the mapping factory into Hibernate Search, we add a property to
    the main `hibernate.cfg.xml` configuration file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将映射工厂集成到Hibernate Search中，我们在主要的`hibernate.cfg.xml`配置文件中添加了一个属性：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, whenever Hibernate ORM opens a `Session`, Hibernate Search and all of the
    Lucene mappings come along for the ride!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论何时Hibernate ORM打开一个`Session`，Hibernate Search以及所有的Lucene映射都会随之而来！
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we expanded our knowledge of how to map classes for searching.
    We can now use Hibernate Search to map entities and other classes to Lucene, regardless
    of how Hibernate ORM maps them to the database. If we ever need to map classes
    to Lucene without adding annotations, we can use a programmatic mapping API to
    handle this at runtime.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了如何为搜索映射类的知识。现在，我们可以使用Hibernate Search将实体和其他类映射到Lucene，无论Hibernate
    ORM如何将它们映射到数据库。如果我们任何时候需要将类映射到Lucene而不添加注解，我们可以在运行时使用程序化映射API来处理。
- en: We have now seen how to manage Hibernate Search across associated entities,
    as well as embedded objects whose lifecycle depend on their containing entity.
    In both cases, we covered some obscure quirks that can trip up developers. Finally,
    we learned how to control which fields of an associated or embedded class are
    indexed, depending on which entity contains them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经知道了如何跨相关实体以及其生命周期依赖于包含实体的嵌入对象管理Hibernate Search。在这两种情况下，我们都涵盖了一些可能会让开发者绊倒的隐蔽怪癖。最后，我们学习了如何根据包含它们的实体来控制关联或嵌入类的哪些字段被索引。
- en: In the next chapter, we will use these mappings in a variety of search query
    types, and explore some important features common to all of them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用这些映射来处理各种搜索查询类型，并探索它们都共有的重要特性。
