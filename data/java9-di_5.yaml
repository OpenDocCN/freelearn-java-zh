- en: Scopes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: On this journey, we've learned dependency injection concepts in Java 9, Spring,
    and Google Guice, with the help of examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次旅程中，我们通过示例学习了Java 9、Spring和Google Guice中的依赖注入概念。
- en: In [Chapter 3](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16), *Dependency
    Injection with Spring*, and [Chapter 4](part0096.html#2RHM00-255b24dd0eb24162a557b7d0d84b0b16), *Dependency
    Injection with Google Guice,* we came across the word scope,which is a very important
    element of Spring beans and Google Guice. So, let's understand what a scope is,
    and why it is important when talking about dependency injection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16)的*使用Spring进行依赖注入*和[第4章](part0096.html#2RHM00-255b24dd0eb24162a557b7d0d84b0b16)的*使用Google
    Guice进行依赖注入*中，我们遇到了作用域这个词，它是Spring beans和Google Guice的一个重要元素。因此，让我们了解什么是作用域，以及为什么在讨论依赖注入时它很重要。
- en: 'In this chapter, we will first learn about various scopes provided by Spring,
    and how they can be defined for Spring beans. We will also learn the relation
    between bean scope and dependency injection. Finally, we will look into the scopes
    available in Google Guice. The topics we are going to cover are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先了解Spring提供的各种作用域，以及它们如何为Spring beans定义。我们还将了解bean作用域与依赖注入之间的关系。最后，我们将探讨Google
    Guice中可用的作用域。我们将讨论的主题如下：
- en: Introduction to bean scopes in Spring
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring中bean作用域的介绍
- en: How to define a bean scope
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义bean作用域
- en: Dependency injection and bean scopes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入和bean作用域
- en: How to choose a bean scope
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择bean作用域
- en: Scopes in Google Guice
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Guice中的作用域
- en: Introduction to bean scopes in Spring
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中bean作用域的介绍
- en: In [Chapter 3](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16), *Dependency
    Injection with Google Guice,* we learned about different Spring modules along
    with dependency injection. In Spring, beans are the backbone of an application,
    and they are managed by a Spring IOC container. A bean is a class or object that
    is created using the configuration of metadata that we can pass to an IOC container.
    Before learning about scope, let's define a bean in Spring.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16)的*使用Google Guice进行依赖注入*中，我们学习了与依赖注入一起的不同Spring模块。在Spring中，bean是应用程序的骨干，由Spring
    IOC容器管理。bean是使用我们可以传递给IOC容器的元数据配置创建的类或对象。在学习作用域之前，让我们在Spring中定义一个bean。
- en: Bean definition
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean定义
- en: 'The metadata of a **bean** has its own properties with independent bean definitions.
    Some of these bean definitions are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**bean**的元数据具有其自己的属性，这些属性具有独立的bean定义。以下是一些这些bean定义的例子：'
- en: '**Class**: This will be used to create a bean, and it is mandatory to mention
    a class name for which we are supposed to create a bean.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：这将用于创建bean，我们必须指定一个类名，为该类创建bean。'
- en: '**Name**: If we want to define different aliases for the bean, then we use
    the `name` attribute, with the help of a separator, such as a comma (`,`) or semicolon
    (`;`). When we have XML-based configuration, we can use the `name` and/or `id`
    attribute as an identifier for a bean. A bean with an `id` attribute is preferred,
    because it is mapped with an actual XML ID element.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：如果我们想为bean定义不同的别名，那么我们使用`name`属性，借助分隔符，例如逗号（`,`）或分号（`;`）。当我们有基于XML的配置时，我们可以使用`name`和/或`id`属性作为bean的标识符。具有`id`属性的bean更受欢迎，因为它与实际的XML
    ID元素相映射。'
- en: '**Constructor-arg**: A constructor argument is used to inject dependencies
    by passing a parameter as an argument in a constructor, which we saw in [Chapter
    3](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16), *Dependency Injection
    with Spring*.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数参数**：构造函数参数用于通过在构造函数中传递参数作为参数来注入依赖项，这在[第3章](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16)中看到，*使用Spring进行依赖注入*。'
- en: '**Properties**: We can directly pass properties with key-value pairs in a Spring
    bean for injecting. This is useful sometimes if we need to pass certain fixed
    values to a bean.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：我们可以在Spring bean中直接通过键值对传递属性以进行注入。如果我们需要将某些固定值传递给bean，这有时是有用的。'
- en: '**Autowiring mode**: Autowiring can be used to reduce the use of properties
    and constructor arguments. To enable autowiring mode, we need to use the `autowire`
    attribute in a Spring bean. Attributes can have values such as `byName`, `byType`,
    and `constructor`*.*'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动装配模式**：自动装配可以用来减少属性和构造函数参数的使用。要启用自动装配模式，我们需要在Spring bean中使用`autowire`属性。属性可以具有`byName`、`byType`和`constructor`*等值*。'
- en: '**Lazy initialization mode**: By default, a Spring bean is created with a singleton
    scope, which initializes all the properties in eager mode. If a bean is defined
    with lazy mode, then an IOC container creates a bean instance the first time the
    request comes, rather than during the startup process.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**懒加载初始化模式**：默认情况下，Spring bean以单例作用域创建，以贪婪模式初始化所有属性。如果bean以懒加载模式定义，则IOC容器会在第一次请求到来时创建bean实例，而不是在启动过程中。'
- en: '**Initialization method**: Spring initialization works after all the properties
    are set by an IOC container. In XML-based configuration, we can define an `init`
    method by defining an `init-method` attribute. The `init` method should be void,
    and without arguments. A `@PostConstruct` annotation can be used for initializing
    methods.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化方法**：Spring初始化在IOC容器设置所有属性之后进行。在基于XML的配置中，我们可以通过定义`init-method`属性来定义`init`方法。`init`方法应该是void类型，且没有参数。可以使用`@PostConstruct`注解来初始化方法。'
- en: '**Destruction method**: On completion of a bean lifecycle, if we have to close
    resources or want to perform actions before destruction of a bean, we can use
    the `destroy-method` attribute of a bean in XML configuration. The `@PreDestroy`
    annotation is also used instead of the XML attribute.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**销毁方法**：在bean生命周期结束时，如果我们需要关闭资源或想在bean销毁前执行操作，我们可以使用XML配置中bean的`destroy-method`属性。也可以使用`@PreDestroy`注解代替XML属性。'
- en: 'The following configuration file contains different types of bean definition syntax
    and for that, the `application-context.xml` file could be:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配置文件包含不同类型的bean定义语法，因此`application-context.xml`文件可能如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Lazy instantiation is most effective when the scope is **singleton**. With the **prototype**
    scope, a bean initializes with lazy mode by default.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当作用域是**单例**时，懒加载最有效。对于**原型**作用域，bean默认以懒加载模式初始化。
- en: Spring scopes
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring作用域
- en: 'We have understood how a bean definition works with different attributes, and
    **s****cope** is one of the attributes in a bean definition. Before going on to
    learn about scope types, one question comes to mind: what are scopes?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了bean定义如何使用不同的属性，**作用域**是bean定义中的一个属性。在继续学习作用域类型之前，一个问题浮现在脑海中：什么是作用域？
- en: If we look from a Spring perspective, the meaning of **scope** is, *to characterize
    the life cycle of a bean and define visibility of that bean within a specific
    context in which the bean is utilized*. When the scope of the object ends, it
    will be considered **out of scope** and can no longer be injected into different instances.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从Spring的角度来看，**作用域**的意义是，*定义bean的生命周期并在bean使用的特定上下文中定义该bean的可见性*。当对象的作用域结束时，它将被视为**超出作用域**，并且不能再注入到不同的实例中。
- en: From the **The Oxford English Dictionary**, scope means "*the extent of the
    area or subject matter that something deals with or to which it is relevant*."
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**牛津高阶英汉双解大词典**，作用域意味着“*某事物处理或与之相关的区域或主题范围*。”
- en: 'Spring has seven scopes, and out of them, five are used for web application
    development. The following is a diagram of **Bean Scopes**:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Spring有七个作用域，其中五个用于Web应用程序开发。以下是一个**Bean作用域**的图示：
- en: '![](img/00031.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00031.jpeg)'
- en: Singleton scope
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例作用域
- en: Each bean created by a Spring container has a default **Singleton** scope; Spring
    treats it as one instance of the bean, and it is served for each request for that
    bean from the cache inside the container. In dependency injection, a bean defined
    as a singleton is injected as a shared bean from the cache.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring容器创建的每个bean都有一个默认的单例作用域；Spring将其视为bean的一个实例，并为容器内缓存中的每个对该bean的请求提供服务。在依赖注入中，定义为单例的bean作为共享bean从缓存中注入。
- en: A **Singleton** bean scope is restricted to the Spring container, compared to
    this Singleton pattern in Java, where only one instance of a specific class will
    ever be created per `ClassLoader`. This scope is useful in web applications as
    well as standalone applications, and stateless beans can also utilize a **Singleton**
    scope.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**单例**bean作用域限制在Spring容器内，与Java中的单例模式相比，Java中的单例模式在每个`ClassLoader`中只会创建特定类的一个实例。此作用域在Web应用程序以及独立应用程序中都很有用，无状态bean也可以利用**单例**作用域。'
- en: 'On the off chance that three beans have distinctive IDs but the same class
    with a **Singleton** scope, at that point, three instances will be made of that
    class and in terms of bean ID, as only one instance of the singleton bean is made:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有三个bean具有不同的ID但具有相同的**单例**作用域，那么将创建该类的三个实例，在bean ID方面，因为单例bean只有一个实例被创建：
- en: '![](img/00032.gif)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.gif)'
- en: Prototype scope
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型作用域
- en: When we need to create multiple instances of a bean, then we use the prototype
    scope. A `prototype` scoped bean is mostly used for stateful beans. So, on each
    and every request, a new instance of the bean will be created by the IoC container.
    This bean can be injected into another bean, or used by calling a `getBean()`
    method of a container.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要创建多个bean实例时，我们使用原型作用域。原型作用域的bean主要用于有状态的bean。因此，在每次请求时，IoC容器都会创建bean的新实例。这个bean可以被注入到另一个bean中，或者通过调用容器的`getBean()`方法来使用。
- en: 'But, a container does not maintain the record of a `prototype` bean after initialization.
    We have to implement a custom `BeanPostProcessor` to release the resources occupied
    by the prototype bean. A `destroy` method of the life cycle is not called in the
    case of a prototype scope, only initial `call-back` methods are called for all
    the objects irrespective of scope:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，容器在初始化后不会维护原型bean的记录。我们必须实现一个自定义的`BeanPostProcessor`来释放原型bean占用的资源。在原型作用域的情况下，不会调用生命周期中的`destroy`方法，而是对所有对象调用初始的回调方法，无论作用域如何：
- en: '![](img/00033.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: So far, we have seen **Singleton** and Prototype scopes. Both can be used in
    standalone and web applications, but there are five more scopes that only work
    in web applications. If we used these scopes with `ClassPathXmlApplicationContext`,
    then it will throw an `IllegalStateException` for an unknown scope.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了**单例**和原型作用域。两者都可以用于独立和Web应用程序，但还有五个更多的作用域仅在Web应用程序中工作。如果我们使用这些作用域与`ClassPathXmlApplicationContext`一起，那么它将抛出一个`IllegalStateException`，表示未知的作用域。
- en: To use the request, session, global session, application, and websocket scopes,
    we need to use a web-aware application context implementation (`XmlWebApplicationContext`).
    Let's look at all the web scopes in detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用请求、会话、全局会话、应用程序和websocket作用域，我们需要使用一个感知网络的上下文实现（`XmlWebApplicationContext`）。让我们详细看看所有这些网络作用域。
- en: Request scope
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求作用域
- en: 'In a web application, every HTTP request from a client gets a new bean instance
    if the bean is scoped as a **request**. On an HTTP request completion, a bean
    will immediately be considered out of scope, and memory will be released. If a
    server has 100 concurrent requests, then there will be 100 distinct instances
    of a bean class available. If there is any change in one instance, it will not
    affect other instances. Following is an image of the request scope:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，如果bean的作用域被定义为**请求**，则客户端的每个HTTP请求都会得到一个新的bean实例。在HTTP请求完成时，bean将立即被视为超出作用域，并将释放内存。如果服务器有100个并发请求，那么将有100个不同的bean类实例可用。如果一个实例发生变化，它不会影响其他实例。以下是请求作用域的图像：
- en: '![](img/00034.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: Session scope
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话作用域
- en: A **session** is a group of interactive information, also known as a *conversion*
    between client and server within a specific time frame on a website. In an **Apache
    Tomcat** server, the default time frame of one session is 30 minutes, which includes
    all the operations made by a user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话**是一组交互式信息，也称为在网站特定时间框架内客户端和服务器之间的*转换*。在**Apache Tomcat**服务器中，一个会话的默认时间框架是30分钟，包括用户所做的所有操作。'
- en: 'The Spring session bean scope is similar to an HTTP session; an IoC container
    creates a new instance of a bean for each user session. On user logout, its session
    bean will be out of scope. Like a request, if 50 users are concurrently using
    a website, then a server has 50 active sessions, and a Spring container also has
    50 different instances of a bean class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Spring会话bean作用域类似于HTTP会话；IoC容器为每个用户会话创建一个bean的新实例。在用户登出时，其会话bean将超出作用域。就像请求一样，如果有50个用户同时使用一个网站，那么服务器将有50个活跃会话，Spring容器也将有50个不同的bean类实例：
- en: '![](img/00035.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: The previous image illustrates that all HTTP requests from the user are included
    in a single session, and all requests may have lifetime access of a single bean
    instance in that session scope. Session instances are destroyed, as before long,
    the session is destroyed/quit on the server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图像说明了所有用户的HTTP请求都包含在一个会话中，并且所有请求在该会话作用域中可能都有单个bean实例的生存期访问。会话实例将被销毁，就像之前一样，会话在服务器上被销毁/退出。
- en: Application scope
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序作用域
- en: 'The application scope only works on a web application. An IoC container creates
    single instances of bean definitions per web application during runtime. Following
    are two ways to define the application scope:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序作用域仅在Web应用程序中工作。在运行时，IoC容器为每个Web应用程序创建单个bean定义的实例。以下定义应用程序作用域的两种方式：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the same as the Singleton scope, but the main difference is that a Singleton
    scope bean is worked as a Singleton per `ApplicationContext`, whereas an application
    scope bean is worked as Singleton per `ServletContext`. These beans are stored
    as attributes in `ServletContext`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这与单例范围相同，但主要区别在于单例范围bean在每个`ApplicationContext`中作为单例工作，而应用范围bean在每个`ServletContext`中作为单例工作。这些bean存储在`ServletContext`的属性中。
- en: Global session scope
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局会话范围
- en: A **global session scope** is similar to a session scope. The only difference
    is that it will be used in a Portlet application. Global sessions can be used
    when we have an application that is built on the JSR-168, JSR-286, and JSR-362
    portal specifications. There will be multiple sites/applications that work under
    a single portlet container.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局会话范围**类似于会话范围。唯一的区别是它将在组件应用程序中使用。当我们的应用程序基于JSR-168、JSR-286和JSR-362门户规范构建时，可以使用全局会话。将会有多个站点/应用程序在单个组件容器下工作。'
- en: 'Portlet containers have different portlets, and all have their own portlet
    context, as well as portlet session. Portlet sessions work with the portlet boundary,
    but when we have to share common information between multiple sites, then we can
    define beans with a `globalSession` scope. Spring has separate portlet MVC modules
    for portal applications:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 组件容器有不同的组件，每个都有自己的组件上下文和组件会话。组件会话与组件边界一起工作，但当我们需要在多个站点之间共享共同信息时，我们可以定义具有`globalSession`范围的bean。Spring为门户应用程序提供了独立的组件MVC模块：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Consider an intranet application that consists of server sites. Users could
    be members of multiple sites. In such scenarios, user preferences with common
    information can be stored as global sessions for the logged-in user, and the same
    will be utilized between multiple sites and portlets. The following image shows
    how G**lobal Sessions** are shared between portlet containers:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个由服务器站点组成的内部网络应用程序。用户可以是多个站点的成员。在这种情况下，具有共同信息的用户偏好可以存储为登录用户的全局会话，并且将在多个站点和组件之间使用。以下图像显示了全局会话如何在组件容器之间共享：
- en: '![](img/00036.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00036.jpeg)'
- en: websocket scope
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket范围
- en: This scope is used when two-way communication between a customer and remote
    site is enabled using the **websocket** protocol. It is mainly useful when applications
    are used by multiple users with simultaneous actions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用WebSocket协议启用客户与远程站点之间的双向通信时，将使用此范围。它主要适用于多个用户同时执行操作的应用程序。
- en: 'Here, an HTTP request is used to do an initial handshake, and once it is established,
    the TCP port remains open for a client and server for communication. The websocket
    bean is similar to a singleton, and injected into Spring controllers. The life
    of a websocket bean is longer compared to a typical websocket session. The following
    example shows how a websocket is declared using Scope annotation and traditional
    XML configuration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用HTTP请求进行初始握手，一旦建立，TCP端口将保持打开状态，以便客户端和服务器进行通信。WebSocket组件类似于单例，并注入到Spring控制器中。与典型的WebSocket会话相比，WebSocket组件的生命周期更长。以下示例显示了如何使用范围注解和传统的XML配置声明WebSocket：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to define a bean scope
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何定义bean范围
- en: So, we understand the different scopes and their usage. Now it is time to see
    how we can use them in coding. We will mainly look at singleton and prototype
    bean scopes with examples.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们了解了不同的范围及其用法。现在，让我们看看如何在编码中使用它们。我们将主要通过示例查看单例和原型bean范围。
- en: 'Spring provides two different ways to write an application: one is traditional
    XML metadata configuration, and the second is Java configuration using annotations.
    Let''s look at how XML configuration is used.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了两种不同的方式来编写应用程序：一种是通过传统的XML元数据配置，另一种是使用注解的Java配置。让我们看看XML配置是如何使用的。
- en: XML metadata configuration
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML元数据配置
- en: In Spring, bean configuration is declared in an XML file of our choice. This
    file is used by an IoC container to initialize the application context, and at
    the same time, all bean definitions are initialized based on the provided attribute.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，bean配置是在我们选择的XML文件中声明的。该文件由IoC容器用于初始化应用程序上下文，同时，所有bean定义都是基于提供的属性初始化的。
- en: Using the singleton scope
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单例范围
- en: 'The singleton scope is a very common scope used in major applications. Here,
    we will start to use the singleton scope. First, we will create a bean class named
    `EmailService`, which consists of a simple `getter/setter` method and `Constructor`
    method with a `print` statement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 单例作用域是在主要应用程序中非常常见的作用域。在这里，我们将开始使用单例作用域。首先，我们将创建一个名为`EmailService`的bean类，它包含一个简单的`getter/setter`方法和一个带有`print`语句的构造方法：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Every Spring application requires a context file that describes the configuration
    of the beans. Configuration of the previously mentioned bean class can be written
    as follows in `application-context.xml`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Spring应用程序都需要一个上下文文件来描述bean的配置。之前提到的bean类的配置可以如下在`application-context.xml`中编写：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, in the bean definition, we have mentioned `emailService` as an ID attribute,
    and a class name provided as `com.packt.springbean.EmailService` to point our
    bean class to the package path. For learning purposes, we have used a `scope`
    attribute with a `singleton` value.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在bean定义中，我们已经将`emailService`作为ID属性，并提供了`com.packt.springbean.EmailService`作为类名，以指向我们的bean类所在的包路径。为了学习目的，我们使用了具有`singleton`值的`scope`属性。
- en: 'If the `scope` attribute is not defined in the bean definition, then by default,
    a Spring IoC container creates an instance of the bean with a singleton scope.
    Now, let''s check what will happen if we try to access the `EmailService` bean
    two times. For that, let''s use the `SpringBeanApplication.java` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在bean定义中没有定义`scope`属性，那么默认情况下，Spring IoC容器将使用单例作用域创建bean的实例。现在，让我们检查如果我们尝试两次访问`EmailService`
    bean会发生什么。为此，让我们使用`SpringBeanApplication.java`类：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In a standalone application, the Spring context is acquired using `ClassPathXMLApplicationContext`
    by passing a context file as a parameter in a String array. A Spring IoC container
    initializes the application context, and returns an object of it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个独立的应用程序中，使用`ClassPathXMLApplicationContext`通过传递一个字符串数组中的上下文文件作为参数来获取Spring上下文。Spring
    IoC容器初始化应用程序上下文，并返回它的一个对象。
- en: A bean is retrieved by passing a bean `name` in the form of an argument in the `getBean()`
    method. In the preceding example, we get two instances of the `EmailService` bean
    using the `getBean()` method. But, the first time we are only setting the value
    into a bean and we are getting the same by writing `printing message`. Even a
    constructor creates an object of bean only once.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`getBean()`方法中以参数形式传递一个bean `name`来检索bean。在先前的例子中，我们使用`getBean()`方法获取了两个`EmailService`
    bean的实例。但是，第一次我们只是将值设置到一个bean中，并且通过写入`打印消息`来获取相同的值。甚至构造函数也只创建bean对象一次。
- en: 'So, when we run `SpringBeanApplication`, the output would be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们运行`SpringBeanApplication`时，输出将如下所示：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since the `EmailService` bean has the Singleton scope, the second instance of `emailServiceInstanceB`
    prints the message with a value set by `emailServiceInstanceA` as well, even though
    it is `get` by a new `getBean()` method. The Spring IoC container creates and
    maintains only a single instance of a bean per container; no matter how many times
    you reclaim it with `getBean()`, it will continuously return the same instance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`EmailService` bean具有单例作用域，因此第二个实例`emailServiceInstanceB`打印的消息将包含由`emailServiceInstanceA`设置的值，即使它是通过一个新的`getBean()`方法获取的。Spring
    IoC容器为每个容器创建并维护一个bean的单例实例；无论你使用`getBean()`多少次回收它，它都将持续返回相同的实例。
- en: Using the prototype scope
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原型作用域
- en: 'As we have seen, the **prototype scope** is used to get a new instance of a
    bean every time when requested. To understand prototype, we will take the same
    bean class, `EmailService`, and we just need to change the value of the scope
    attribute for the `emailService` bean in `application-context.xml`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，原型作用域用于每次请求时获取一个新实例的bean。为了理解原型作用域，我们将使用相同的bean类，`EmailService`，并且我们只需要更改`application-context.xml`中`emailService`
    bean的作用域属性值：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code used for the singleton scope will the same as before, while the output
    of the preceding code will be as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用于单例作用域的代码将与之前相同，而前述代码的输出将如下所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From output, the `EmailService` constructor is called two times, and gets a
    new instance for each `getBean()` method called. For the second instance, `emailServiceInstanceB`,
    we get a `null` value, because we haven't set any value for that.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，`EmailService`构造函数被调用了两次，并且每次调用`getBean()`方法时都会获取一个新的实例。对于第二个实例，`emailServiceInstanceB`，我们得到一个`null`值，因为我们还没有为它设置任何值。
- en: Java configuration using annotations
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用注解的Java配置
- en: Once annotation was introduced in `Java 1.5`, Spring Framework also added support
    for annotations in version 2.5.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 `Java 1.5` 中引入了注解，Spring 框架也在 2.5 版本中添加了对注解的支持。
- en: Spring provides several standard annotations, which are used on stereotype classes
    in the application. By using such annotations, we don't need to maintain bean
    definitions in XML files. We just need to write one line, `<context:component-scan>`,
    in the Spring XML configuration for a scanning component, and the Spring IoC container
    scans the defined package to register all the annotated classes and their bean
    definitions in the application context.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了几个标准注解，这些注解用于应用程序中的.stereotype 类。通过使用这些注解，我们不需要在 XML 文件中维护 bean 定义。我们只需要在
    Spring XML 配置中写一行 `<context:component-scan>`，Spring IoC 容器就会扫描定义的包，并在应用程序上下文中注册所有注解类及其
    bean 定义。
- en: Specifically, `@Component` and `@Service` are used to scan beans in the provided
    package. Here, we will use `@Service` annotation, because the `@Service` annotation
    is too specialized for the `@Component` annotation. It doesn’t give us any extra
    behavior than the `@Component` explanation, but it’s better to choose `@Service`
    over `@Component` in service-layer classes, since it indicates expectations way
    better.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，`@Component` 和 `@Service` 用于扫描提供的包中的 beans。在这里，我们将使用 `@Service` 注解，因为 `@Service`
    注解比 `@Component` 注解更专业。它并没有比 `@Component` 解释提供任何额外的行为，但最好在服务层类中选择 `@Service` 而不是
    `@Component`，因为它能更好地表明期望。
- en: 'For singleton and prototype beans, our `application-context.xml` file will
    be the same, and looks as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单例和原型 beans，我们的 `application-context.xml` 文件将相同，如下所示：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Singleton scope with annotation
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带注解的单例范围
- en: '`@Scopes` annotation is used to indicate the scope of a bean, either singleton, prototype, request,
    session, or a few custom scopes.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Scopes` 注解用于指示 bean 的范围，无论是单例、原型、请求、会话还是一些自定义范围。'
- en: 'To make the `EmailService` bean class a singleton, we need to annotate the
    class with `@Scope` and `@Service`. So, our `EmailService` class will look as
    follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `EmailService` bean 类成为单例，我们需要用 `@Scope` 和 `@Service` 注解该类。因此，我们的 `EmailService`
    类将如下所示：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will use the same `SpringBeanApplication.java` class to test our annotation
    changes, and the output will also be the same as the XML configuration example.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的 `SpringBeanApplication.java` 类来测试我们的注解更改，输出也将与 XML 配置示例相同。
- en: Prototype scope with annotation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带注解的原型范围
- en: 'To use prototype scope with annotations, we only need to mention `prototype` in
    the `@Scope` annotation instead of `singleton`. So, our `EmailService.java` class
    will be the same, except we change the annotation value, and it will look as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用注解的原型范围，我们只需要在 `@Scope` 注解中提及 `prototype` 而不是 `singleton`。因此，我们的 `EmailService.java`
    类将保持不变，除了我们更改注解值，它将如下所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As like the XML example output, this will also create a new instance each time
    it is called. In a similar way, we can use other scopes, such as request, session,
    application, and global session, using XML metadata or annotations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与 XML 示例输出类似，每次调用时它也会创建一个新的实例。以类似的方式，我们可以使用其他范围，如请求、会话、应用程序和全局会话，使用 XML 元数据或注解。
- en: Dependency injection and the bean scope
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入和 bean 范围
- en: We understand each scope has a different boundary. Now, we will write one REST
    controller to understand how different scope beans are injected to other reference
    beans by writing simple Spring boot applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解每个范围都有不同的边界。现在，我们将编写一个 REST 控制器，通过编写简单的 Spring Boot 应用程序来了解不同的范围 beans 如何通过其他引用
    beans 注入。
- en: 'In the following diagram, the **StudentController** has injected the reference
    to all other classes. The `ClassDetail` class with the `session` scope has two
    references to singleton and prototype, and the student application contains a
    few other associations between classes as well. **Autowired** annotation is utilized
    to fulfill dependency between beans. Just to clarify, Spring controllers are always
    created with the singleton scope:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，**StudentController** 注入了所有其他类的引用。具有 `session` 范围的 `ClassDetail` 类有两个单例和原型的引用，学生应用程序还包含一些其他类之间的关联。使用
    **Autowired** 注解来满足 beans 之间的依赖关系。为了澄清，Spring 控制器始终以单例范围创建：
- en: '![](img/00037.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: 'As we are writing a Spring boot application with REST. Will will have to create
    a maven project and the configuration of `pom.xml` file would be:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在编写一个带有 REST 的 Spring Boot 应用程序。我们需要创建一个 Maven 项目，`pom.xml` 文件的配置将是：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We start with the `StudentController` class, injected with four beans that
    have different scopes defined:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`StudentController`类开始，注入了四个具有不同作用域定义的bean：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To understand each scope, I have created simple interfaces with scope names
    for better visualization, and this will also help when we add the dependency of
    one bean into another bean. `@Scope` annotation is utilized to mention the `StudentDetail`
    bean as a singleton and it is implementing the `SingletonBeanScope` interface.
    This class has been injected with a `PrototypeBeanScope` bean. Moreover, we are
    printing incremental values of the static integer variable` increment`  to track
    how many times the singleton bean is initialized in the constructor. The same
    is written for all other bean classes. `StudentDetail.java` will be as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地可视化每个作用域，我创建了具有作用域名称的简单接口，这也有助于我们在一个bean中添加另一个bean的依赖项时。使用`@Scope`注解将`StudentDetail`bean指定为单例，并且它实现了`SingletonBeanScope`接口。这个类已经被注入了一个`PrototypeBeanScope`bean。此外，我们正在打印静态整型变量`increment`的增量值，以跟踪单例bean在构造函数中初始化的次数。其他所有bean类都有相同的写法。`StudentDetail.java`将如下所示：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`SubjectPreference.java` is defined with a prototype bean scope as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`SubjectPreference.java`被定义为原型bean作用域如下：'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The request scope and session scope are only worked in a web-aware application
    context. `Address.java` is annotated with the request scope:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域和会话作用域仅在具有web感知的应用程序上下文中工作。`Address.java`被注解为请求作用域：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the same way, the `session` scope is used in the `ClassDetail.java` class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`session`作用域在`ClassDetail.java`类中使用：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: An extra `proxyMode` attribute is utilized to make an intermediary, which will
    be injected as a dependency by Spring, and Spring starts the `target` bean when
    it's required. Note that there is no dynamic request when the web application setting
    is initialized.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用额外的`proxyMode`属性来创建一个中介，该中介将被Spring作为依赖项注入，并且当需要时Spring将启动`target`bean。注意，当初始化web应用程序设置时，没有动态请求。
- en: 'On a successful run, we will see the following console log:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功运行后，我们将看到以下控制台日志：
- en: '![](img/00038.gif)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.gif)'
- en: 'Following is the analysis of the output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的分析是输出：
- en: The `StudentDetail` bean is created only once, which is, at most, a singleton
    class, and it loads during application startup.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StudentDetail`bean只创建一次，它最多是一个单例类，并在应用程序启动时加载。'
- en: Subsequently, the `SubjectPreference` bean is created with the prototype scope.
    It is injected into the `StudentDetail` singleton bean and, because of that, it
    also initializes with it. Here, we all know that the prototype scope bean is created
    each time it is called.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随后，使用原型作用域创建了`SubjectPreference`对象。它被注入到`StudentDetail`单例bean中，因此它也与其一起初始化。在这里，我们都知道原型作用域bean每次被调用时都会被创建。
- en: Here, the `StudentDetail` singleton bean depends on `PrototypeBeanScope`, which
    is implemented by the `SubjectPreference` class, and dependencies are resolved
    at instantiation time. So, the first instance of `SubjectPreference` is created,
    and then it will be injected into the `StudentDetail` singleton bean.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，`StudentDetail`单例bean依赖于由`SubjectPreference`类实现的`PrototypeBeanScope`，依赖项在实例化时解决。因此，首先创建`SubjectPreference`的第一个实例，然后将其注入到`StudentDetail`单例bean中。
- en: The Spring container is initializing the `StudentController` class only one
    time because `controller` is, by default, a singleton.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring容器只初始化一次`StudentController`类，因为默认情况下`controller`是一个单例。
- en: As `StudentController`  has injected a reference of the `PrototypeBeanScope`,
    once again an instance of the `SubjectPreference` bean is created. Controllers
    also have a reference of the `SingletonbeanScope` bean, but an instance of that
    is not created again, because it is already loaded.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`StudentController`注入了`PrototypeBeanScope`的引用，因此再次创建了一个`SubjectPreference`bean的实例。控制器也有`SingletonbeanScope`bean的引用，但不会再次创建该实例，因为它已经加载。
- en: An instance of `SessionScopeBean` and `RequestScopeBean` is not created, because
    there is no HTTP request or HTTP session at this instant.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于此时没有HTTP请求或HTTP会话，因此没有创建`SessionScopeBean`和`RequestScopeBean`的实例。
- en: 'To check the `request` and `session` scope, go to `http://localhost:8080` in
    a browser and observe the console log:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`request`和`session`作用域，请在浏览器中访问`http://localhost:8080`并观察控制台日志：
- en: '![](img/00039.gif)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.gif)'
- en: The log shows that one instance each for the `ClassDetail` and `Address` classes
    are created because they define with the session and request scope respectively.
    Both the `ClassDetail` and `Address` classes also injected `PrototypeBeanScope`,
    and because of that, the `SubjectPreference` instance has been created two more
    times—a total of four times.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 日志显示，由于`ClassDetail`和`Address`类分别定义了会话和请求范围，因此为这两个类各创建了一个实例。`ClassDetail`和`Address`类也注入了`PrototypeBeanScope`，因此`SubjectPreference`实例被创建了两次，总共四次。
- en: 'Enter `http://localhost:8080 URL again`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次输入`http://localhost:8080 URL`：
- en: '![](img/00040.gif)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00040.gif)'
- en: It will create one more instance of the `Address` class, which is marked as
    a request scope, and a new instance of `SubjectPreference` class with prototype
    scope will be created. It will not create an instance of the `ClassDetail` class
    because we have not created a new session, our session is still going.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它将创建一个标记为请求范围的`Address`类的新实例，并且将创建一个具有原型范围的`SubjectPreference`类的新实例。它不会创建`ClassDetail`类的实例，因为我们没有创建新的会话，我们的会话仍在进行中。
- en: 'To initiate a new session, we need to close the browser and go to the URL.
    Open another browser, and go to the URL:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个新的会话，我们需要关闭浏览器并转到URL。打开另一个浏览器，并转到URL：
- en: '![](img/00041.gif)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00041.gif)'
- en: By doing this, two new sessions will be created, and a total of three instances
    are created for the  `ClassDetail` class, along with two instances of the `Address`
    class, and two instances of the `SubjectPreference` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，将创建两个新的会话，`ClassDetail`类将创建总共三个实例，以及两个`Address`类实例和两个`SubjectPreference`类实例。
- en: In the event that we need to inject a request scope bean into another bean of
    a longer-lived scope, you may select to inject an AOP proxy in the scoped bean.
    We require to injecting an intermediary object that exposes the same public interface
    as the scoped object. But that can recover the target object from the applicable
    scope and provide method calls onto the genuine object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将请求范围bean注入到具有更长生命周期的范围的另一个bean中，您可以选择在范围bean中注入AOP代理。我们需要注入一个中间对象，该对象公开与范围对象相同的公共接口。但可以从适用范围中恢复目标对象，并提供对真实对象的方法调用。
- en: Furthermore, the bean is going through an intermediate proxy that is serializable.
    The same bean subsequently can re-obtain the `target` singleton bean by doing
    deserialization. `<aop:scoped-proxy/>` is used by the beans that are marked as
    a singleton.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该bean正在通过一个可序列化的中间代理。相同的bean随后可以通过反序列化重新获取`target`单例bean。标记为单例的bean使用`<aop:scoped-proxy/>`。
- en: In the same way, when using the prototype bean scope, each method calls on the
    shared proxy will lead to the creation of a new target instance which the call
    is, at that point, being sent to.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当使用原型bean范围时，对共享代理的每次方法调用都会导致创建一个新的目标实例，此时调用将被发送到该实例。
- en: By default, a CGLIB-based class proxy is made when the Spring holder makes a proxy for
    a bean that is checked up with the `<aop:scoped-proxy/>` component.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring容器为经过`<aop:scoped-proxy/>`组件检查的bean创建代理时，默认情况下会创建一个基于CGLIB的类代理。
- en: How to choose a bean scope
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何选择bean范围
- en: Each scope in Spring has a different feature, and it falls to us as programmers
    to know how to utilize those scopes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Spring中的每个范围都有不同的特性，作为程序员，我们需要知道如何利用这些范围。
- en: In an application, if we have a stateless object and there is no impact on the
    object creation process then the use of a scope is unnecessary. In contrast, if
    an object has state then it is advisable to use a scope such as singleton.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个应用程序中，如果我们有一个无状态对象并且对对象创建过程没有影响，那么使用范围是不必要的。相反，如果一个对象有状态，那么建议使用单例等范围。
- en: 'When dependency injection is in business, then the singleton scope is not adding
    much value. In spite of the fact that singletons spare object creation (and afterward
    garbage collection), synchronization requires us to initialize a singleton bean.
    Singletons are most valuable for:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖注入在业务中使用时，单例范围并没有增加太多价值。尽管单例节省了对象创建（以及随后的垃圾收集），但同步需要我们初始化一个单例bean。单例最有价值的是：
- en: Configuration of stateful beans
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态ful bean的配置
- en: Lookup of objects that are costly to build
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找构建成本高昂的对象
- en: A database association pool object that is associated with resources
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与资源关联的数据库连接池对象
- en: If we consider concurrency, classes defined with a singleton or session scope
    must be thread-safe, and anything injected in these classes should be thread-safe.
    On the other hand, the request scope cannot be thread-safe.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑并发性，使用单例或会话作用域定义的类必须是线程安全的，并且注入到这些类中的任何内容也应该是线程安全的。另一方面，请求作用域不能是线程安全的。
- en: Scopes in Google Guice
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Guice中的作用域
- en: Most of the scopes we have seen for the Spring Framework similarly exist in
    Google Guice. Scope defines that code should work in a specific context, and in
    Guice, the Injector manages the scope context. **Default scope** (No Scope), **singleton**,
    **session**, and **request** are the main scopes in Guice.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Spring 框架中看到的大部分作用域在 Google Guice 中也存在。作用域定义了代码应在特定上下文中工作，在 Guice 中，注入器管理作用域上下文。**默认作用域**（无作用域）、**单例**、**会话**和**请求**是
    Guice 中的主要作用域。
- en: Default scope
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认作用域
- en: By default, Guice injects a new and separate instance of an object for each
    dependency (similar to the prototype scope in Spring), whereas Spring provides
    singletons by default.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Guice 为每个依赖项注入一个新的独立实例的对象（类似于 Spring 中的原型作用域），而 Spring 默认提供单例。
- en: 'Let us consider an example of a house that has a family with three people,
    all with their own personal car. Every time they call the `injector.getInstance()`
    method, a new instance of a car object is available for each family member:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个有三口之家且每人都有自己的私家车的房子的例子。每次他们调用`injector.getInstance()`方法时，每个家庭成员都可以获得一个新的汽车对象实例：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](img/00042.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: Singleton scope
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例作用域
- en: 'If we want to create only one instance of the class, then the `@Singleton`
    annotation can be used to mark the implementation class. As long as a the singleton
    object lives, the injector lives in context, but in the same application, it is
    possible to have multiple injectors, and in that case, each injector is associated
    with a different instance of a singleton-scoped object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想创建类的单个实例，那么可以使用`@Singleton`注解来标记实现类。只要单例对象存在，注入器就存在于上下文中，但在同一应用程序中，可能存在多个注入器，在这种情况下，每个注入器都与单例作用域对象的实例相关联：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another way to configure a scope is by using a bind statement in the module:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种配置作用域的方法是在模块中使用绑定语句：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we use linked binding in a module, then the scope only applies to binding
    the source, not to the `target`. For example, we have a class `UserPref` that
    implements both `Professor` and `Student` interfaces. This will create two instance
    of type: one for `Professor` and another one for `Student`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在模块中使用链接绑定时，作用域仅适用于绑定源，而不适用于`目标`。例如，我们有一个名为`UserPref`的类，它实现了`Professor`和`Student`接口。这将创建两个实例：一个用于`Professor`，另一个用于`Student`：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is because the singleton scope applies at the binding type level, which
    is `Professor` and `Student`, not at the target type, `UserPref`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为单例作用域应用于绑定类型级别，即`Professor`和`Student`，而不是目标类型`UserPref`。
- en: Eager singletons
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 急切单例
- en: 'Guice provides special syntax for making an object that has the singleton scope,
    and is initialized to eager mode rather than lazy mode. Following is the syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Guice 提供了特殊的语法来创建具有单例作用域的对象，并且初始化为急切模式而不是懒模式。以下是其语法：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Eager singletons uncover initialization issues sooner, and guarantee end users
    get a reliable, smart encounter. Lazy singletons empower a quicker edit-compile-run
    development cycle. We can utilize the stage enum to indicate which procedure ought
    to be utilized.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 热切的单例模式可以更快地发现初始化问题，并确保最终用户获得可靠、智能的体验。懒单例模式可以加速编辑-编译-运行的开发周期。我们可以利用阶段枚举来指示应该使用哪个过程。
- en: 'The following table defines stage-wise use of syntax of the singleton and supported
    object initialize mode:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格定义了单例和受支持对象初始化模式的语法阶段使用：
- en: '| **Syntax** | **PRODUCTION** | **DEVELOPMENT** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **语法** | **生产** | **开发** |'
- en: '| @Singleton | eager* | lazy |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| @Singleton | eager* | lazy |'
- en: '| .asEagerSingleton() | eager | eager |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| .asEagerSingleton() | eager | eager |'
- en: '| .in(Singleton.class) | eager | lazy |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| .in(Singleton.class) | eager | lazy |'
- en: '| .in(Scopes.SINGLETON) | eager | lazy |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| .in(Scopes.SINGLETON) | eager | lazy |'
- en: Guice eagerly creates singleton instances only for the modules that are defined
    as singleton.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Guice 仅对定义为单例的模块急切创建单例实例。
- en: '`@SessionScoped`  and `@RequestedScoped` scope functionality and behavior is
    the same as Spring in Guice, and it will only be applicable when used in a web
    application.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SessionScoped`和`@RequestedScoped`作用域的功能和行为在 Guice 中与 Spring 相同，并且仅在用于 Web
    应用程序时适用。'
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started the chapter with a Spring bean definition attribute, which is important
    to learn as the whole IoC container is a relay on bean initialization. After that
    we learned the classification of scope with syntax.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以Spring Bean定义属性开始本章，这是学习的重要部分，因为整个IoC容器依赖于Bean的初始化。之后，我们通过语法学习了作用域的分类。
- en: On our journey, we learned how scope is configured using XML metadata and Java
    configuration in Spring. Without dependency injection, we cannot complete the
    chapter. That's why, by writing a **Spring Boot** application, we try to understand
    how the main scopes work in standalone as well as in web applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的旅程中，我们学习了如何在Spring中使用XML元数据和Java配置来配置作用域。没有依赖注入，我们无法完成本章。这就是为什么，通过编写一个**Spring
    Boot**应用程序，我们试图理解主作用域在独立应用以及Web应用中的工作方式。
- en: We intentionally skipped the scope topic in [Chapter 4](part0096.html#2RHM00-255b24dd0eb24162a557b7d0d84b0b16),
    *Dependency Injection with Google Guice*. So, we have covered the Google Guice
    scope in this chapter with basic scopes. Spring and Google Guice have almost the
    same scope, but the default behavior of object initialization is different. Spring
    creates instances with the singleton, whereas Guice creates with the prototype
    scope.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意跳过了[第4章](part0096.html#2RHM00-255b24dd0eb24162a557b7d0d84b0b16)中的作用域主题，即*使用Google
    Guice进行依赖注入*。因此，在本章中，我们用基本作用域涵盖了Google Guice的作用域。Spring和Google Guice的作用域几乎相同，但对象初始化的默认行为不同。Spring使用单例创建实例，而Guice使用原型作用域创建。
- en: In the next chapter, we will look at an important feature called **aspect-oriented
    programming** in Spring.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Spring中一个重要的特性，称为**面向切面编程**。
