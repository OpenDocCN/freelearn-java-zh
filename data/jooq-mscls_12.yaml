- en: '*Chapter 9*: CRUD, Transactions, and Locking'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：CRUD、事务和锁定'
- en: In this chapter, we'll cover a must-know mix of fundamental notions about CRUD
    operations, transactions, and locking. These three topics are heavily exploited
    in almost any database application. In a common scenario, an application has a
    significant number of CRUD operations that are executed in explicitly demarcated
    logical transactions and, in certain cases, they also need to explicitly control
    the concurrent access to data to prevent **race conditions**, **lost updates**,
    and other **SQL phenomena** (or SQL anomalies).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍关于CRUD操作、事务和锁定的基本概念，这些概念在几乎任何数据库应用中都被广泛使用。在常见场景中，应用程序有大量的CRUD操作，这些操作在显式界定的逻辑事务中执行，并且在某些情况下，它们还需要显式控制对数据的并发访问，以防止**竞态条件**、**丢失更新**和其他**SQL现象**（或SQL异常）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: CRUD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRUD
- en: Navigating (updatable) records
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航（可更新）记录
- en: Transactions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务
- en: Locking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter09](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter09).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter09](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter09)。
- en: CRUD
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD
- en: Besides the awesome DSL-fluent API for expressing complex SQL, jOOQ can be used
    to express *everyday* SQL operations as well. These are known as `INSERT`), `SELECT`),
    `UPDATE`), and `DELETE`)), and jOOQ facilitates them via a dedicated API that
    involves `UpdatableRecord` types. In other words, the jOOQ Code Generator generates
    a `UpdatableRecord` (a record that can be fetched and stored again in the database)
    for each table that has a primary key (not just a simple unique key!). Tables
    without a primary key (`org.jooq.TableRecord`) are rightly considered non-updatable
    by jOOQ. You can easily recognize a jOOQ `UpdatableRecord` because it has to extend
    the `UpdatableRecordImpl` class (simply inspect your generated records from `jooq.generated.tables.records`).
    Next, jOOQ exposes a CRUD API that allows you to operate directly on these updatable
    records instead of writing DSL-fluent queries (which fits better for complex queries
    that involve more than one table).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于表达复杂SQL的出色的DSL流畅API之外，jOOQ还可以用于表达**日常**SQL操作。这些被称为`INSERT`（插入）、`SELECT`（选择）、`UPDATE`（更新）和`DELETE`（删除），jOOQ通过一个涉及`UpdatableRecord`类型的专用API来简化它们。换句话说，jOOQ代码生成器为每个具有主键的表生成一个`UpdatableRecord`（可以再次从数据库中检索和存储的记录），而不仅仅是简单唯一键的表！没有主键的表（`org.jooq.TableRecord`）被jOOQ正确地认为是不可更新的。你可以很容易地识别一个jOOQ
    `UpdatableRecord`，因为它必须扩展`UpdatableRecordImpl`类（只需检查你从`jooq.generated.tables.records`生成的记录）。接下来，jOOQ公开了一个CRUD
    API，允许你直接在这些可更新记录上操作，而不是编写DSL流畅查询（这对于涉及多个表的复杂查询更适合）。
- en: If you need a quick reminder about jOOQ records, please check out [*Chapter
    3*](B16833_03.xhtml#_idTextAnchor040), *jOOQ Core Concepts*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要关于jOOQ记录的快速提醒，请查看[*第3章*](B16833_03.xhtml#_idTextAnchor040)，*jOOQ核心概念*。
- en: Important Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The jOOQ CRUD API fits like a glove for **normalized** databases, so for tables
    that have primary keys (simple or composed) or unique lifespans, a primary key
    is inserted only once into a table. Once it's been inserted, it cannot be changed
    or re-inserted after being deleted.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ CRUD API非常适合**规范化**的数据库，因此对于具有主键（简单或复合）或唯一生命周期的表，主键只插入一次到表中。一旦插入，它就不能更改或删除后重新插入。
- en: However, as you know, jOOQ tries to greet you in any case you have, so if you
    need updatable primary keys, then rely on `Settings.updatablePrimaryKeys()`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所知，jOOQ试图在任何情况下都向你打招呼，所以如果你需要可更新的主键，那么请依赖`Settings.updatablePrimaryKeys()`。
- en: The jOOQ CRUD API facilitates several operations, including insert (`insert()`),
    update (`update()`), delete (`delete()`), merge (`merge()`) and the handy store
    (`store()`). Besides these operations, we have the well-known `selectFrom()`,
    which is useful for reading (`SELECT`) from a single table directly into a `Result`
    of updatable records.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ CRUD API简化了多个操作，包括插入（`insert()`）、更新（`update()`）、删除（`delete()`）、合并（`merge()`）以及方便的存储（`store()`）。除了这些操作之外，我们还有众所周知的`selectFrom()`，它对于直接从单个表读取到可更新记录的`Result`非常有用。
- en: However, before we look at several CRUD examples, is important to know about
    a set of methods that can influence the behavior of updatable records and CRUD
    operations. These methods are `attach()`, `detach()`, `original()`, `changed()`,
    `reset()`, and `refresh()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们查看几个 CRUD 示例之前，了解一组可以影响可更新记录和 CRUD 操作行为的方法是很重要的。这些方法是 `attach()`、`detach()`、`original()`、`changed()`、`reset()`
    和 `refresh()`。
- en: Attaching/detaching updatable records
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加/解除可更新记录
- en: Roughly, jOOQ updatable records are just Java objects that can live independently
    of the database and can be manipulated in memory. So long as an updatable record
    doesn't need to interact with the database, it can remain in the `Configuration`
    that, among other things, has the coordinates to connect to the database that
    this updatable record will interact with. After an updatable record has been attached,
    it will remain like this for as long as the corresponding `Configuration` lives
    or until it is explicitly detached by calling `detach()`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，jOOQ 的可更新记录只是可以独立于数据库存在的 Java 对象，并且可以在内存中进行操作。只要可更新记录不需要与数据库交互，它就可以保持在
    `Configuration` 中，`Configuration` 中包含连接到该可更新记录将要交互的数据库的坐标。一旦可更新记录被附加，它将保持这种状态，直到相应的
    `Configuration` 存活或被显式调用 `detach()` 解除。
- en: When we fetch updatable records from the database, jOOQ will automatically attach
    them to the currently used `Configuration` and implicitly to the involved database
    connection. This connection may be used internally for subsequent interactions
    with the fetched updatable records with the database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从数据库中检索可更新记录时，jOOQ 将自动将它们附加到当前使用的 `Configuration`，并隐式地附加到涉及的数据库连接。此连接可以用于内部后续与检索的可更新记录的数据库交互。
- en: Important Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To be precise, jOOQ doesn't hold references to a JDBC `Connection` but to `ConnectionProvider`
    from `Configuration`. In terms of transactions or connection pooling, this might
    be relevant. For instance, if we are using a Spring `TransactionAwareDataSourceProxy`,
    an attached record can be fetched in one transaction and stored in another transparently.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，jOOQ 并不持有 JDBC `Connection` 的引用，而是持有来自 `Configuration` 的 `ConnectionProvider`。在事务或连接池方面，这可能是相关的。例如，如果我们使用
    Spring 的 `TransactionAwareDataSourceProxy`，一个附加的记录可以在一个事务中检索并在另一个事务中透明地存储。
- en: 'Consider the following read operation:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下读取操作：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `sr` record was automatically attached by jOOQ to the `Configuration` part
    of `ctx`. Next, we can successfully execute other operations that interact with
    the database, such as `sr.update()`, `sr.delete()`, and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`sr` 记录被 jOOQ 自动附加到 `ctx` 的 `Configuration` 部分。接下来，我们可以成功执行其他与数据库交互的操作，例如 `sr.update()`、`sr.delete()`
    等。'
- en: 'Now, let''s consider a brand-new record that''s been created by the client,
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个由客户端创建的新记录，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Such records are not automatically attached to any existent `Configuration`.
    They haven''t been fetched from the database, so jOOQ will justifiably expect
    that you''ll explicitly/manually attach them to a `Configuration` whenever this
    is necessary (for instance, before calling `sr.insert()`). This can be done by
    explicitly calling the `DSLContext.attach()` or `UpdatableRecord.attach()` methods,
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的记录不会自动附加到任何现有的 `Configuration`。它们尚未从数据库中检索，因此 jOOQ 有理由期望你将在必要时（例如，在调用 `sr.insert()`
    之前）明确/手动将它们附加到 `Configuration`。这可以通过明确调用 `DSLContext.attach()` 或 `UpdatableRecord.attach()`
    方法来完成，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, to avoid the `attach()` explicit call, we can rely on the `DSLContext.newRecord()`
    alternative. Since `DSLContext` contains the `Configuration` part, jOOQ will do
    the attachment automatically. So, here, you should use the following code snippet
    (if you want to populate the record from a POJO, then use the `newRecord(Table<R>
    table, Object o)` flavor):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了避免显式调用 `attach()`，我们可以依赖 `DSLContext.newRecord()` 选项。由于 `DSLContext` 包含
    `Configuration` 部分，jOOQ 将自动执行附加。因此，这里你应该使用以下代码片段（如果你想从 POJO 中填充记录，则使用 `newRecord(Table<R>
    table, Object o)` 风味）：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once `srNew` has been attached, we can execute operations that interact with
    the database. Attempting to execute such operations on a detached updatable record
    will lead to an exception that states `org.jooq.exception.DetachedException`:
    *Cannot execute query. No Connection configured.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `srNew` 被附加，我们就可以执行与数据库交互的操作。尝试在解除附加的可更新记录上执行此类操作将导致一个异常，该异常声明 `org.jooq.exception.DetachedException`：*无法执行查询。未配置连接*。
- en: 'An updatable record can be explicitly detached with `UpdatableRecord.detach()`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可更新记录可以通过 `UpdatableRecord.detach()` 显式解除：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While an updatable record is serializable, the underlying `Connection` (or
    `DataSource`) of `Configuration` is non-serializable. Nevertheless, you don''t
    have to detach records before serialization. The internals of `DefaultConfiguration`
    ensure that anything that isn''t `Serializable` (for instance, `DefaultConnectionProvider`)
    isn''t serialized. Re-attaching will still be necessary after de-serialization,
    though. Support for serialization on jOOQ radar will eventually be deprecated:
    [https://github.com/jOOQ/jOOQ/issues/2359](https://github.com/jOOQ/jOOQ/issues/2359).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可更新的记录是可序列化的，但`Configuration`的底层`Connection`（或`DataSource`）是不可序列化的。尽管如此，在序列化之前不需要分离记录。`DefaultConfiguration`的内部确保任何不是`Serializable`的（例如，`DefaultConnectionProvider`）都不会被序列化。尽管如此，在反序列化之后仍然需要重新附加。jOOQ雷达上的序列化支持最终将被弃用：[https://github.com/jOOQ/jOOQ/issues/2359](https://github.com/jOOQ/jOOQ/issues/2359)。
- en: From this, don't conclude that serializing/de-serializing records is a day-to-day
    task. Most of the time, records are used to populate views (for instance, via
    Thymeleaf) or they are exported as CSV, JSON, HTML, and so on via jOOQ support,
    as you'll see in the next chapter. None of these actions requires an explicit
    detach.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点，不要得出序列化/反序列化记录是日常任务的结论。大多数时候，记录用于填充视图（例如，通过Thymeleaf）或通过jOOQ支持导出为CSV、JSON、HTML等，正如您将在下一章中看到的那样。这些操作都不需要显式分离。
- en: What's an original (updatable) record?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是原始（可更新）记录？
- en: Every (updatable) record holds a reference to its *current* values and its *original*
    values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个（可更新）记录都持有对其*当前*值和*原始*值的引用。
- en: 'If the record was fetched from the database, then the fetched values represent
    the *original* and the *current* values at the same time. Next, the *current*
    values can be modified in memory, while the *original* values remain in place.
    For example, let''s assume that the following query fetches the `SALE.FISCAL_YEAR`
    field, which is *2005* and that, after fetching it, we set it to *2002*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记录是从数据库中检索的，那么检索到的值同时代表*原始*和*当前*值。接下来，可以在内存中修改*当前*值，而*原始*值保持不变。例如，假设以下查询检索了`SALE.FISCAL_YEAR`字段，其值为*2005*，并且在检索后将其设置为*2002*：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, the *original* value of the fiscal year is *2005* and the *current*
    value is *2002*. After inserting/updating a record, the *current* values that
    have been inserted/updated become the *original* values. For instance, after updating
    `sr`, the *original* value of the fiscal year becomes *2002*, just like the *current*
    value. This way, `sr` mirrors the latest state of the database. So, after an update,
    the *original* values reflect only what has been sent to the database by default.
    Trigger-generated values are not fetched back by default. For that to work, `Settings.returnAllOnUpdatableRecord()`
    is required.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，财政年度的*原始*值是*2005*，而*当前*值是*2002*。在插入/更新记录后，已插入/更新的*当前*值成为*原始*值。例如，在更新`sr`后，财政年度的*原始*值变为*2002*，就像*当前*值一样。这样，`sr`反映了数据库的最新状态。因此，在更新后，*原始*值仅反映默认发送到数据库的内容。默认情况下，触发生成的值不会被检索回来。为了实现这一点，需要`Settings.returnAllOnUpdatableRecord()`。
- en: In the case of a new record, the *original* values are always `null` and remain
    like this until the record is inserted or updated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在新记录的情况下，*原始*值始终为`null`，并且直到记录被插入或更新之前保持这种状态。
- en: 'Whenever we need the *original* values, we can call `Record.original()`. Without
    arguments, the `original()` method returns a brand-new record that''s been populated
    with the *original* values. If `sr` is attached when calling `original()`, then
    `srOriginal` is attached as well; otherwise, it is detached:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要*原始*值时，我们可以调用`Record.original()`。如果没有参数，`original()`方法返回一个全新的记录，该记录已填充了*原始*值。如果在调用`original()`时附加了`sr`，则`srOriginal`也会附加；否则，它会被分离：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By specifying an argument as a `Field`, `Name`, `String`, or integer (index),
    we can extract the *original* value of a certain field. Here is a type-safe and
    a non-type-safe approach:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定一个`Field`、`Name`、`String`或整数（索引）作为参数，我们可以提取某个字段的*原始*值。以下是一个类型安全和类型不安全的示例：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Having the *current* and *original* values of a record in your hands can be
    useful for making decisions after comparing these values between them or with
    other values, for creating side-by-side views of original data and current data,
    and so on. In the bundled code, called *OriginalRecords* (available for MySQL),
    you can see an example of rendering a side-by-side view for a `PRODUCT` via Thymeleaf.
    The relevant Thymeleaf code is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有记录的*当前值*和*原始值*在手，可以在比较这些值之间或与其他值进行比较后做出决策，创建原始数据和当前数据的并排视图，等等。在捆绑的代码中，称为*OriginalRecords*（适用于MySQL），你可以看到一个通过Thymeleaf渲染`PRODUCT`并排视图的示例。相关的Thymeleaf代码如下：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You''ll see something similar to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到以下类似的内容：
- en: '![Figure 9.1 – Side-by-side view'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 并排视图'
- en: '](img/B16833_Figure_9.1.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 并排视图'
- en: Figure 9.1 – Side-by-side view
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 并排视图
- en: Next, let's focus on marking (updatable) records as changed/unchanged.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于标记（可更新的）记录为已更改/未更改。
- en: Marking (updatable) records as changed/unchanged
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记（可更新的）记录为已更改/未更改
- en: 'A record whose *original* values are exactly the same as the *current* values
    is considered *unchanged*. By calling the `Record.changed()` flag method, we can
    find out if a record is considered as *changed* or *unchanged* by jOOQ. For instance,
    a record that has been fetched from the database and never modified is *unchanged*:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*原始值*与*当前值*完全相同的记录被认为是*未更改*的。通过调用`Record.changed()`标志方法，我们可以找出jOOQ认为记录是*已更改*还是*未更改*。例如，一个从数据库中获取且从未修改过的记录是*未更改*的：
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Even if we set the same fiscal year that was fetched from the database (*2005*),
    this record is marked as *changed*. On the other hand, a brand-new record is considered
    *changed*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将从数据库中获取的相同财政年度（*2005*）设置，这条记录也被标记为*已更改*。另一方面，一个全新的记录也被认为是*已更改*：
- en: '[PRE30]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice that `changed()` operates at the field level since it''s a `BitSet`
    that''s the same length as the number of record fields. In other words, each field
    of a record has the `changed()` flag method. All we have to do is pass the field
    as an argument of `changed()` as a `Field`, `Name`, `String`, or `int` (representing
    the index):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`changed()`在字段级别操作，因为它是一个与记录字段数量相同的`BitSet`。换句话说，记录的每个字段都有一个`changed()`标志方法。我们只需要将字段作为`changed()`的参数传递，作为`Field`、`Name`、`String`或`int`（表示索引）：
- en: '[PRE37]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Whenever we attempt to insert or update a record, jOOQ inspects the *changed*
    flags to determine which fields should be part of the generated query. This is
    great, because by rendering only the *changed* fields, jOOQ allows *default* values
    (specified via `CREATE TABLE` DDL statements) to be set for the omitted fields.
    If none of the fields were *changed* then jOOQ can prevent an insert/update from
    being executed (we'll cover this in more detail later in this chapter).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们尝试插入或更新一个记录时，jOOQ会检查*已更改*标志以确定哪些字段应包含在生成的查询中。这很好，因为通过仅渲染*已更改*的字段，jOOQ允许为省略的字段设置*默认值*（通过`CREATE
    TABLE` DDL语句指定）。如果没有字段被*更改*，那么jOOQ可以防止执行插入/更新操作（我们将在本章后面更详细地介绍这一点）。
- en: 'However, we can enforce/suppress the execution of such statements by explicitly
    turning on (or off) the *changed* flag. We can do so by marking all the fields
    as *changed*/*unchanged*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过显式地打开（或关闭）*已更改*标志来强制/抑制此类语句的执行。我们可以通过将所有字段标记为*已更改*/*未更改*来实现：
- en: '[PRE39]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can also do the same by marking only certain fields:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过仅标记某些字段来完成同样的操作：
- en: '[PRE40]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Pay attention to how you juggle these flags since is quite easy to mess things
    up and render some unfortunate DML statements. Next, let's talk about resetting
    records.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何处理这些标志，因为很容易搞砸事情并生成一些不幸的DML语句。接下来，让我们谈谈重置记录。
- en: Resetting an (updatable) record
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置一个（可更新的）记录
- en: 'By resetting a record, we `false`. This can be accomplished without interacting
    with the database. We can reset all the fields by using `Record.reset()`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重置记录，我们`false`。这可以在不与数据库交互的情况下完成。我们可以通过使用`Record.reset()`来重置所有字段：
- en: '[PRE42]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can reset only certain fields by using `reset(Field`/`Name`/`String`/`int)`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`reset(Field`/`Name`/`String`/`int)`来仅重置某些字段：
- en: '[PRE43]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You'll see this method at work in the forthcoming sections. Finally, let's talk
    about how to refresh a record.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在接下来的章节中看到这个方法的应用。最后，让我们谈谈如何刷新记录。
- en: Refreshing an updatable record
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新一个可更新的记录
- en: 'By refreshing an updatable record, we synchronize the record''s original values
    with the database''s latest state, and we revert the currentvalues in case they
    had been set. Practically, `UpdatableRecord.refresh()` is materialized in a `SELECT`
    round trip that loads the data in the original values of the record and sets all
    the changed flags to `false`. Refreshing all the fields of the record can be done
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过刷新可更新记录，我们将记录的原始值与数据库的最新状态同步，并在它们已被设置的情况下撤销当前值。实际上，`UpdatableRecord.refresh()`
    在一个 `SELECT` 往返中实现，该往返加载记录的原始值并设置所有更改标志为 `false`。刷新记录的所有字段可以按以下方式完成：
- en: '[PRE45]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can partially refresh the updatable record using `refresh``(Field<?>...
    fields)` or `refresh``(Collection<? extends Field<?>> fields)`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `refresh``(Field<?>... fields)` 或 `refresh``(Collection<? extends Field<?>>
    fields)` 部分刷新可更新记录：
- en: '[PRE46]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this case, `SELECT` is rendered to fetch only the specified fields. As you'll
    see shortly, this `refresh()` method is quite useful when mixed with optimistic
    locking.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`SELECT` 被渲染以仅获取指定的字段。正如你很快就会看到的，这个 `refresh()` 方法与乐观锁定结合使用时非常有用。
- en: You can find these examples in *SimpleCRUDRecords* (available for MySQL and
    PostgreSQL). Next, let's talk about inserting updatable records.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *SimpleCRUDRecords* 中找到这些示例（适用于 MySQL 和 PostgreSQL）。接下来，让我们谈谈插入可更新记录。
- en: Inserting updatable records
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入可更新记录
- en: 'Just a quick note to be sure that this section is not misunderstood: `insert()`
    can be called on any `TableRecord`, not just the `UpdatableRecord` ones; no primary
    key is necessary for `insert()`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便一提，为了确保本节不被误解：`insert()` 可以在任意 `TableRecord` 上调用，而不仅仅是 `UpdatableRecord`；对于
    `insert()`，不需要主键。
- en: 'Now, inserting updatable records can be done via `UpdatableRecord.insert()`
    and its overloads. Typically, we insert brand-new records or records that have
    been loaded from POJOs (for instance, via the `from(POJO)` or `newRecord(Table<R>
    table, Object o)` methods) that are considered and treated by jOOQ as new records.
    Here is a simple and classical example of creating and inserting an updatable
    record:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以通过 `UpdatableRecord.insert()` 和其重载方法插入可更新记录。通常，我们插入全新的记录或从 POJOs（例如，通过
    `from(POJO)` 或 `newRecord(Table<R> table, Object o)` 方法）加载的记录，这些记录被 jOOQ 视为新记录。以下是一个创建和插入可更新记录的简单且经典的示例：
- en: '[PRE47]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, if you create it like so, then you need to explicitly call `attach()`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你这样创建它，那么你需要显式调用 `attach()`：
- en: '[PRE51]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: jOOQ generates and executes the `INSERT` statement. Moreover, by default, jOOQ
    tries to load any generated keys (the `IDENTITY`/`SEQUENCE` values, which are
    supported by most databases) from the database and turn them back into records
    that conform to the following note.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 生成并执行 `INSERT` 语句。此外，默认情况下，jOOQ 尝试从数据库中加载任何生成的键（`IDENTITY`/`SEQUENCE` 值，大多数数据库都支持）并将它们转换回符合以下说明的记录。
- en: Important Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The JDBC `getGeneratedKeys()` approach is only used when there's no better approach.
    In Db2, Firebird, MariaDB, Oracle, PostgreSQL, and, soon, H2, there is native
    `RETURNING` or `<data change delta table>` support that favors single round trips.
    Sometimes, if `getGeneratedKeys()` isn't supported, or only poorly, then an extra
    round trip may be needed with an extra `SELECT` statement. This is particularly
    true for many dialects when `Settings.returnAllOnUpdatableRecord()` is active.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC 的 `getGeneratedKeys()` 方法仅在没有更好的方法时使用。在 Db2、Firebird、MariaDB、Oracle、PostgreSQL
    以及不久的将来 H2 中，存在本地的 `RETURNING` 或 `<data change delta table>` 支持，这有利于单次往返。有时，如果
    `getGeneratedKeys()` 不受支持，或者支持得不好，那么可能需要额外的往返，并使用额外的 `SELECT` 语句。这在 `Settings.returnAllOnUpdatableRecord()`
    激活时尤其如此。
- en: So, calling `sr.getSaleId()` after `INSERT` will return the database-generated
    primary key.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `INSERT` 之后调用 `sr.getSaleId()` 将返回数据库生成的主键。
- en: Sometimes, you just need to re-insert the data that's contained in an updatable
    record. By default, since the record is *unchanged* after being inserted (`changed()`
    returns `false`), executing another `insert()` renders an `INSERT` of defaults
    (`INSERT INTO sale VALUES (default, default, ...)`). If the `CREATE TABLE` DDL
    doesn't provide default values for all the rendered defaults, then this will result
    in an error; that is, *Field 'foo' doesn't have a default value*. But, as you
    can see in the bundled code, this behavior can be controlled via `withInsertUnchangedRecords(false)`.
    Setting this flag to `false` will suppress any attempt to execute an `INSERT`
    of defaults.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能只需要重新插入一个可更新记录中包含的数据。默认情况下，由于记录在插入后没有改变（`changed()` 返回 `false`），执行另一个
    `insert()` 将导致默认值的 `INSERT`（`INSERT INTO sale VALUES (default, default, ...)`）。如果
    `CREATE TABLE` DDL 没有为所有渲染的默认值提供默认值，那么这将导致错误；即 *字段 'foo' 没有默认值*。但是，正如你在捆绑的代码中所看到的，这种行为可以通过
    `withInsertUnchangedRecords(false)` 来控制。将此标志设置为 `false` 将抑制执行默认值 `INSERT` 的任何尝试。
- en: 'To insert the same data without creating a new record, you can manually mark
    the record fields as changed (notice that we mark the primary key as *unchanged*,
    so it is omitted from the generated `INSERT` to avoid a duplicate key error):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入相同的数据而不创建新的记录，你可以手动将记录字段标记为已更改（注意，我们将主键标记为 *未更改*，因此它被省略在生成的 `INSERT` 中以避免重复键错误）：
- en: '[PRE56]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Of course, if you want to re-insert only certain fields, then mark only those
    fields as *changed*. On the other hand, if you want to re-insert the data and
    create a new record as well, then rely on the `UpdatableRecord.copy()` method.
    The `copy()` method is quite handy because it duplicates this record in memory,
    marks all fields as *changed*, and doesn''t copy the primary key or any other
    main unique key:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想重新插入仅某些字段，那么只标记那些字段为 *已更改*。另一方面，如果你想重新插入数据并创建一个新的记录，那么依赖于 `UpdatableRecord.copy()`
    方法。`copy()` 方法非常方便，因为它在内存中复制这个记录，将所有字段标记为 *已更改*，并且不复制主键或任何其他主要唯一键：
- en: '[PRE59]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: More examples, including inserting without returning the generated primary key
    and inserting and returning all fields, can be found in the bundled code, *SimpleCRUDRecords*
    (available for MySQL and PostgreSQL). Next, let's focus on updating records.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例，包括不返回生成的主键的插入和插入并返回所有字段，可以在捆绑的代码 *SimpleCRUDRecords* 中找到（适用于 MySQL 和 PostgreSQL）。接下来，让我们专注于更新记录。
- en: Updating updatable records (this sounds funny)
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新可更新记录（这听起来很滑稽）
- en: 'Typically, an updatable record is fetched from the database and is changed
    in memory. Subsequently, these changes are propagated to the database by calling
    `UpdatableRecord.update()` or its flavors, which allows us to nominate the fields
    that should be updated. Let''s fetch a record and change it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个可更新记录是从数据库中检索出来的，并在内存中进行更改。随后，通过调用 `UpdatableRecord.update()` 或其变体将这些更改传播到数据库，这允许我们指定应该更新的字段。让我们检索一个记录并更改它：
- en: '[PRE63]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we print `sr` at the console, then the result will look similar to the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在控制台上打印 `sr`，那么结果将类似于以下内容：
- en: '![Figure 9.2 – Displaying the modified record on the console'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – 在控制台上显示修改后的记录'
- en: '](img/B16833_Figure_9.2.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_9.2.jpg)'
- en: Figure 9.2 – Displaying the modified record on the console
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 在控制台上显示修改后的记录
- en: 'Notice that `fiscal_year` and `sale` are marked with an asterisk (`*`) by jOOQ.
    This asterisk highlights the fields that have been changed and that will participate
    in the following `UPDATE`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，jOOQ 将 `fiscal_year` 和 `sale` 用星号 (`*`) 标记。这个星号突出了将参与以下 `UPDATE` 的已更改字段：
- en: '[PRE67]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The rendered SQL in MySQL dialect is as follows (the rendered `UPDATE` relies
    on the primary key):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 方言中渲染的 SQL 如下（渲染的 `UPDATE` 依赖于主键）：
- en: '[PRE68]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: By default, updating a record that is already up to date has no effect. Of course,
    if you rely on `changed()` to mark all/some fields as *changed*, then you force
    jOOQ to execute the corresponding `UPDATE`. You can practice forcing an update
    via `Settings.withUpdateUnchangedRecords(UpdateUnchangedRecords)` in the bundled
    code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，更新一个已经是最新的记录没有任何效果。当然，如果你依赖 `changed()` 来标记所有/某些字段为 *已更改*，那么你将强制 jOOQ
    执行相应的 `UPDATE`。你可以在捆绑的代码中通过 `Settings.withUpdateUnchangedRecords(UpdateUnchangedRecords)`
    来练习强制更新。
- en: Deleting updatable records
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除可更新记录
- en: 'A fetched updatable record can be deleted via `UpdatableRecord.delete()`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `UpdatableRecord.delete()` 删除检索的可更新记录：
- en: '[PRE72]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As you can see, the rendered `DELETE` relies on the primary key (or main unique
    key). After deletion, all the fields of the deleted record are automatically marked
    as *changed*, so you can easily insert it again by calling `insert()`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，渲染的 `DELETE` 依赖于主键（或主要唯一键）。删除后，被删除记录的所有字段都会自动标记为 *已更改*，因此您可以轻松地通过调用 `insert()`
    再次插入它。
- en: Merging updatable records
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并可更新的记录
- en: 'Whenever we want to execute a `MERGE` statement for an updatable record (brand
    new or fetched from the database), we can call `UpdatableRecord.merge()`. In this
    case, jOOQ renders an `INSERT ... ON DUPLICATE KEY UPDATE` (this is emulated,
    depending on the used dialect), so it delegates the task of choosing between `INSERT`
    and `UPDATE` to the database. Here is an example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要对一个可更新的记录（全新或从数据库中检索到的）执行 `MERGE` 语句时，我们可以调用 `UpdatableRecord.merge()`。在这种情况下，jOOQ
    会渲染一个 `INSERT ... ON DUPLICATE KEY UPDATE`（这取决于使用的方言，是模拟的），因此它将选择在 `INSERT` 和
    `UPDATE` 之间的任务委托给数据库。以下是一个示例：
- en: '[PRE78]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In this case, `srNew` will be inserted. Here is another example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`srNew` 将被插入。以下是一个另一个示例：
- en: '[PRE82]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here, `srFetched` will be updated based on the primary key. Practically, jOOQ
    will render an SQL that updates the row, regardless of which (unique) key value
    is already present.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`srFetched` 将根据主键进行更新。实际上，jOOQ 将渲染一个更新行的 SQL 语句，无论哪个（唯一）键值已经存在。
- en: Storing updatable records
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储可更新的记录
- en: Storing an updatable record can be done by calling the `UpdatableRecord.store()`
    method. This method results in an `INSERT` or an `UPDATE`, depending on the primary
    key's state. The decision of rendering an `INSERT` or an `UPDATE` is made by jOOQ,
    not by the database, as in the case of `MERGE`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 存储可更新的记录可以通过调用 `UpdatableRecord.store()` 方法来完成。此方法根据主键的状态导致 `INSERT` 或 `UPDATE`。渲染
    `INSERT` 或 `UPDATE` 的决定由 jOOQ 而不是数据库做出，就像在 `MERGE` 的情况下一样。
- en: 'Typically, calling `store()` for new updatable records results in an `INSERT`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为新可更新的记录调用 `store()` 会导致一个 `INSERT`：
- en: '[PRE87]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If the updatable record was fetched from the database and its primary key was
    not changed, then jOOQ will render an `UPDATE`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可更新的记录是从数据库中检索的，并且其主键没有更改，那么 jOOQ 将渲染一个 `UPDATE`：
- en: '[PRE91]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If the updatable record was fetched from the database and its primary key was
    changed, then jOOQ will render an `INSERT`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可更新的记录是从数据库中检索的，并且其主键已更改，那么 jOOQ 将渲染一个 `INSERT`：
- en: '[PRE97]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'However, we can still force an `UPDATE` of the primary key via `withUpdatablePrimaryKeys(true)`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然可以通过 `withUpdatablePrimaryKeys(true)` 强制主键的 `UPDATE`：
- en: '[PRE99]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'However, as Lukas Eder shared: *"I think it''s worth mentioning that updating
    primary keys is very much against all principles of normalization. It was introduced
    for those cases where users have very good reasons to do so, and those reasons
    are very rare (usually data migrations or fixing broken data, but even then, they''re
    probably more likely to use SQL statements than updatable records)."*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如 Lukas Eder 分享的那样：“我认为值得指出的是，更新主键与所有规范化原则背道而驰。它是为了那些有很好的理由这样做的情况而引入的，而这些理由非常罕见（通常是数据迁移或修复损坏的数据，但即使在这种情况下，他们可能更倾向于使用
    SQL 语句而不是可更新的记录）。”
- en: You can see these examples in *SimpleCRUDRecords* (available for MySQL and PostgreSQL).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *SimpleCRUDRecords*（适用于 MySQL 和 PostgreSQL）中看到这些示例。
- en: On the other hand, if you prefer to work with POJOs and jOOQ's DAO, then you'll
    like to check out the examples from *SimpleDaoCRUDRecords* (available for MySQL
    and PostgreSQL). These examples relies on DAO's `insert()`, `update()`, `delete()`,
    and `merge()`. Moreover, you'll see the `withReturnRecordToPojo()` setting at
    work. Next, let's focus on using updatable records in web applications.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您更喜欢使用 POJO 和 jOOQ 的 DAO，那么您会想查看 *SimpleDaoCRUDRecords*（适用于 MySQL 和 PostgreSQL）中的示例。这些示例依赖于
    DAO 的 `insert()`、`update()`、`delete()` 和 `merge()`。此外，您将看到 `withReturnRecordToPojo()`
    设置在起作用。接下来，让我们专注于在 Web 应用程序中使用可更新的记录。
- en: Using updatable records in HTTP conversations
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 HTTP 会话中使用可更新的记录
- en: jOOQ's updatable records can be used in web applications or, in other words,
    in conversations that span across requests over the stateless HTTP protocol. Next,
    we'll develop several Spring Boot samples that are meant to highlight what we've
    learned so far.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 的可更新记录可用于 Web 应用程序，换句话说，在跨越无状态 HTTP 协议请求的会话中使用。接下来，我们将开发几个 Spring Boot
    示例，旨在强调我们迄今为止所学的内容。
- en: Using insert(), update(), and delete()
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 insert()、update() 和 delete()
- en: 'Let''s try to build a Spring Boot sample application that uses updatable records
    and `insert()`, `update()`, and `delete()`. While relying on the Spring MVC design
    pattern, let''s consider the following scenario: our main goal is to provide a
    list of all bank transactions (`BANK_TRANSACTION`) that belong to the same payment
    (`PAYMENT`) of a certain customer. The user should be able to insert a new bank
    transaction and delete or modify an existing one.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试构建一个使用可更新记录和`insert()`、`update()`和`delete()`的Spring Boot示例应用程序。在依赖Spring
    MVC设计模式的同时，让我们考虑以下场景：我们的主要目标是提供一个属于特定客户相同付款（`PAYMENT`）的所有银行交易（`BANK_TRANSACTION`）的列表。用户应该能够插入一个新的银行交易，并删除或修改现有的交易。
- en: Listing all bank transactions
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列出所有银行交易
- en: 'The page that displays the bank transactions should look as follows (*transactions.html*):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 显示银行交易的页面应如下所示（`transactions.html`）：
- en: '![Figure 9.3 – All bank transactions of a certain payment'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 某个付款的所有银行交易'
- en: '](img/B16833_Figure_9.3.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3](img/B16833_Figure_9.3.jpg)'
- en: Figure 9.3 – All bank transactions of a certain payment
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 某个付款的所有银行交易
- en: 'Let''s start from the controller endpoint, which should be accessed to produce
    the output shown in the preceding screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从控制器端点开始，该端点应被访问以生成前面截图所示的输出：
- en: '[PRE105]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In the highlighted code, we call the service that''s responsible for accessing
    the repository that executes the query for fetching all the transactions for a
    certain payment. This query is quite simple (of course, in reality, you won''t
    hardcode the values of `CUSTOMER_NUMBER` and `CHECK_NUMBER` – these can represent
    something such as the login payment credentials):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在高亮显示的代码中，我们调用负责访问执行查询以获取特定付款的所有交易的存储库的服务。这个查询相当简单（当然，在现实中，你不会硬编码`CUSTOMER_NUMBER`和`CHECK_NUMBER`的值——这些可以代表诸如登录付款凭证之类的信息）：
- en: '[PRE114]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Next, the fetched `Result<BankTransactionRecord>` is returned in the controller
    endpoint listed previously and stored in the model (Spring Boot''s `Model`) as
    a request attribute named `all` (`ALL_BANK_TRANSACTION_ATTR = "all"`). To render
    the page that''s returned from this controller endpoint (*transactions.html*)
    we can rely on the popular Thymeleaf template engine (of course, you can use any
    other template engine):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，从前面列出的控制器端点返回的`Result<BankTransactionRecord>`被存储在模型中（Spring Boot的`Model`）作为名为`all`的请求属性（`ALL_BANK_TRANSACTION_ATTR
    = "all"`）。要渲染从该控制器端点返回的页面（`transactions.html`），我们可以依赖流行的Thymeleaf模板引擎（当然，你可以使用任何其他模板引擎）：
- en: '[PRE121]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: From the returned page (*transactions.html*), we can choose to insert a new
    transaction or modify an existing one.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从返回的页面（`transactions.html`），我们可以选择插入一个新的交易或修改现有的交易。
- en: Inserting a new bank transaction
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插入一个新的银行交易
- en: 'Inserting a new bank transaction can be done by rendering the link like so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 插入一个新的银行交易可以通过以下方式渲染链接：
- en: '[PRE127]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This link reaches a controller endpoint that looks like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此链接到达一个控制器端点，其外观如下：
- en: '[PRE128]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'So, this controller endpoint creates a new `BankTransactionRecord` that is
    stored in the model via the `NEW_BANK_TRANSACTION_ATTR` request attribute. The
    returned page, *newtransaction.html*, is rendered like so:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此控制器端点创建了一个新的`BankTransactionRecord`，通过`NEW_BANK_TRANSACTION_ATTR`请求属性存储在模型中。返回的页面`newtransaction.html`被渲染如下：
- en: '![Figure 9.4 – Creating a new bank transaction'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 – 创建一个新的银行交易'
- en: '](img/B16833_Figure_9.4.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_9.4.jpg)'
- en: Figure 9.4 – Creating a new bank transaction
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 创建一个新的银行交易
- en: 'Pressing the *Save* button triggers a `POST` request that reaches the following
    controller endpoint (`/new`):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 点击*保存*按钮会触发一个`POST`请求，该请求到达以下控制器端点（`/new`）：
- en: '[PRE134]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'So, Spring Boot populates the `btr` record with the submitted data, and we
    insert it into the database (before inserting it, in the service method (not listed
    here), we associate this new transaction with the corresponding payment via `btr.setCustomerNumber()`
    and `btr.setCheckNumber()`):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Spring Boot使用提交的数据填充`btr`记录，并将其插入到数据库中（在插入之前，在服务方法（此处未列出）中，我们通过`btr.setCustomerNumber()`和`btr.setCheckNumber()`将这个新交易与相应的付款关联起来）：
- en: '[PRE143]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Since this is a new bank transaction, we must attach it before inserting it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个新的银行交易，我们必须在插入之前将其附加。
- en: Updating a bank transaction
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新银行交易
- en: Let's consider that updating a bank transaction implies a four-step wizard.
    In the case of simple wizards, we can use a single `<form/>` that is submitted
    at the last step of the wizard. However, in the case of dynamic wizards, we must
    use one `<form/>` per panel since we must submit the data at each step to decide
    which is going to be the next panel and what it will contain. So, in such cases,
    we must implement a long HTTP conversation that's capable of storing the user
    data while navigating back and forth between the panels. Commonly, this is done
    by storing data via the client's HTTP session.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑更新银行交易意味着一个四步向导。对于简单向导，我们可以在向导的最后一步提交一个单独的 `<form/>`。然而，对于动态向导，我们必须为每个面板使用一个
    `<form/>`，因为我们必须在每个步骤提交数据以决定下一个面板以及它将包含什么。因此，在这种情况下，我们必须实现一个能够存储用户数据并在面板之间来回导航的长
    HTTP 会话。通常，这是通过通过客户端的 HTTP 会话存储数据来完成的。
- en: 'Let''s keep it as simple as possible and assume that the four-step wizard looks
    as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尽可能保持简单，并假设四步向导看起来如下：
- en: '![Figure 9.5 – Four-step wizard'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – 四步向导'
- en: '](img/B16833_Figure_9.5.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_9.5.jpg)'
- en: Figure 9.5 – Four-step wizard
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 四步向导
- en: 'Before entering this wizard, we must click on the *Modify* link that corresponds
    to the bank transaction that we plan to edit. This will hit the following controller
    endpoint while sending the transaction ID:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入此向导之前，我们必须点击与我们要编辑的银行交易对应的 *修改* 链接。这将发送交易 ID 并达到以下控制器端点：
- en: '[PRE148]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '`BankTransactionRecord` can be fetched via the following repository method:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下存储库方法获取 `BankTransactionRecord`：
- en: '[PRE155]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Since this is the transaction that should live across our wizard panels, we
    must store it in the model via the session attribute, `BANK_TRANSACTION_ATTR =
    "bt"`. Next, we must return the first panel of the wizard.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个应该在向导面板之间持续存在的交易，我们必须通过会话属性 `BANK_TRANSACTION_ATTR = "bt"` 在模型中存储它。接下来，我们必须返回向导的第一个面板。
- en: Edit bank name
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑银行名称
- en: 'Once we''ve edited the bank name, we must click on *Next* to submit the data.
    This reaches the following controller endpoint:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编辑了银行名称，我们必须点击 *下一步* 提交数据。这将达到以下控制器端点：
- en: '[PRE160]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Here, we just allow Spring Boot to synchronize the `btr` session record with
    the submitted data. Next, we must return the second panel.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是允许 Spring Boot 同步 `btr` 会话记录与提交的数据。接下来，我们必须返回第二个面板。
- en: Edit IBAN
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑 IBAN
- en: 'Once we''ve edited the bank name, we must edit the IBAN and click *Next* (we
    can also click *Back* and edit the bank name again). After editing the IBAN, the
    submitted data hits the controller endpoint:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编辑了银行名称，我们必须编辑 IBAN 并点击 *下一步*（我们也可以点击 *上一步* 再次编辑银行名称）。 在编辑 IBAN 后，提交的数据达到控制器端点：
- en: '[PRE166]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Again, we allow Spring Boot to synchronize the `btr` session record with the
    submitted data. Next, we must return the third panel.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们允许 Spring Boot 同步 `btr` 会话记录与提交的数据。接下来，我们必须返回第三个面板。
- en: Edit the card type
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑卡片类型
- en: 'Once we''ve edited the bank''s IBAN, we must choose the card type and click
    *Next* (we can also click *Back* and edit the bank IBAN again). After choosing
    the card type, the submitted data hits the controller endpoint:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编辑了银行的 IBAN，我们必须选择卡片类型并点击 *下一步*（我们也可以点击 *上一步* 再次编辑银行 IBAN）。 在选择卡片类型后，提交的数据达到控制器端点：
- en: '[PRE172]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Again, we allow Spring Boot to synchronize the `btr` session record with the
    submitted data. Next, we must return the last panel.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们允许 Spring Boot 同步 `btr` 会话记录与提交的数据。接下来，我们必须返回最后一个面板。
- en: Edit the transferred amount
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑转账金额
- en: 'Finally, we must edit the transferred amount and submit it to the controller
    endpoint:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须编辑转账金额并将其提交到控制器端点：
- en: '[PRE178]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The `UPDATE` method is used in a repository method, as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库方法中使用了 `UPDATE` 方法，如下所示：
- en: '[PRE189]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Finally, we must clean up the HTTP session to remove the updatable record.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须清理 HTTP 会话以删除可更新的记录。
- en: Resetting the wizard data
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重置向导数据
- en: 'It is a common feature of any wizard to provide a *Reset* button for reverting
    the data from the current panel or from the entire wizard to the latest saved
    data. Our *Reset* button is relying on jOOQ''s `reset()` method to reset the wizard
    (all three panels):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 任何向导的常见功能是提供一个 *重置* 按钮来将当前面板或整个向导的数据重置为最新保存的数据。我们的 *重置* 按钮依赖于 jOOQ 的 `reset()`
    方法来重置向导（所有三个面板）：
- en: '[PRE193]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Of course, you can use `reset(Field`/`Name`/`String`/`int)` to implement a reset
    per panel feature. Finally, let's delete a bank transaction.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以使用 `reset(Field`/`Name`/`String`/`int)` 来实现按面板重置功能。最后，让我们删除一个银行交易。
- en: Deleting a bank transaction
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除银行交易
- en: 'As shown in *Figure 9.5*, each panel of our wizard contains a *Delete* button,
    which allows us to delete this bank transaction. The code for its controller endpoint
    is as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图9.5*所示，我们的向导中的每个面板都包含一个*删除*按钮，它允许我们删除这笔银行交易。其控制器端点的代码如下：
- en: '[PRE202]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'And the `DELETE` is rendered by a call of `delete()` in the following repository
    method:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下存储库方法中，`DELETE`是通过调用`delete()`来实现的：
- en: '[PRE213]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: The complete code is called *CRUDRecords*. If you prefer to use POJOs and jOOQ's
    DAO, then check out *DaoCRUDRecords* and the REST version (for Postman, ARC, and
    so on), which is called *DaoCRUDRESTRecords*. These three applications are available
    for MySQL. For brevity, we skipped any validation and error handling code.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码称为*CRUDRecords*。如果您更喜欢使用POJOs和jOOQ的DAO，请查看*DaoCRUDRecords*和REST版本（用于Postman、ARC等），该版本称为*DaoCRUDRESTRecords*。这三个应用程序都适用于MySQL。为了简洁，我们省略了任何验证和错误处理代码。
- en: Using merge() versus store()
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用merge()与store()的比较
- en: 'Let''s consider the following scenario: we have loaded and displayed the payments
    (`PAYMENT`) of a certain customer (for instance, `PAYMENT.CUSTOMER_NUMBER.eq(103L)`).
    The user should be able to insert new payments for this customer or update the
    amount of an existing payment. To solve this task, we have two approaches that
    are almost the same. These are shown in the following screenshot:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下场景：我们已经加载并显示了某个客户（例如，`PAYMENT.CUSTOMER_NUMBER.eq(103L)`）的付款（`PAYMENT`）。用户应该能够为此客户插入新的付款或更新现有付款的金额。为了解决这个问题，我们有两种几乎相同的方法。这些方法在下面的屏幕截图中显示：
- en: '![Figure 9.6 – Insert/update payment'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – 插入/更新付款'
- en: '](img/B16833_Figure_9.6.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_9.6.jpg)'
- en: Figure 9.6 – Insert/update payment
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 插入/更新付款
- en: Regarding the design on the left-hand side, to insert a new payment, we can
    simply type a new (unique) *Check Number* (for instance, received via SMS) and
    the corresponding *Invoice Amount*. To update the *Invoice Amount* of an existing
    payment, we must type its current *Check Number* from the bottom table (for instance,
    to update the second payment from the table, we must type the *Check Number* *JM555205*).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 关于左侧的设计，要插入一个新的付款，我们可以简单地输入一个新的（唯一的）*支票号码*（例如，通过短信接收）和相应的*发票金额*。要更新现有付款的*发票金额*，我们必须从底部表格中输入其当前的*支票号码*（例如，要更新表格中的第二个付款，我们必须输入*支票号码*
    *JM555205*）。
- en: Regarding the right-hand side design, to insert a new payment, we just type
    the *Invoice Amount*; the *Check Number* is auto-generated and pre-filled by the
    application. However, to update the *Invoice Amount* of an existing payment, we
    must load the payment first via the corresponding *Load* link in the bottom table.
    This will fetch the corresponding payment from the database so that we can type
    in the new amount value and update it.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 关于右侧设计，要插入一个新的付款，我们只需输入*发票金额*；*支票号码*由应用程序自动生成并预先填写。然而，要更新现有付款的*发票金额*，我们必须首先通过底部表格中的相应*加载*链接加载付款。这将从数据库中检索相应的付款，以便我们可以输入新的金额值并更新它。
- en: Implementing the left-hand side design via merge()
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过merge()实现左侧设计
- en: 'Let''s focus on the left-hand side design. After the user submits the payment
    form, Spring Boot creates a new `PaymentRecord` and populates it with the submitted
    data. Next, based on the submitted *Check Number*, we must determine if this is
    a new payment or an update of an existing payment to execute an `INSERT` or an
    `UPDATE`. So, it is time for `merge()` to do its job and render an SQL that delegates
    the task of choosing between `INSERT` and `UPDATE` to the database:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于左侧设计。在用户提交付款表单后，Spring Boot创建一个新的`PaymentRecord`并用提交的数据填充它。接下来，根据提交的*支票号码*，我们必须确定这是一笔新付款还是对现有付款的更新，以执行`INSERT`或`UPDATE`。因此，现在是`merge()`发挥作用并生成一个将选择`INSERT`或`UPDATE`的任务委托给数据库的SQL的时候了：
- en: '[PRE217]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: That's all the important code! Notice that, before merging, we need to attach
    the relevant `PaymentRecord`. Remember that Spring Boot has created this record,
    so it is not attached to any `Configuration`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是所有重要的代码！请注意，在合并之前，我们需要附加相关的`PaymentRecord`。请记住，Spring Boot已经创建了此记录，因此它没有附加到任何`Configuration`。
- en: Check out the complete application for this code, which is called *MergeRecords*.
    If you prefer to use POJOs and jOOQ's DAO, then check out *DaoMergeRecords*. Both
    applications are available for MySQL.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此代码的完整应用程序，该应用程序称为*MergeRecords*。如果您更喜欢使用POJOs和jOOQ的DAO，请查看*DaoMergeRecords*。这两个应用程序都适用于MySQL。
- en: Implementing the right-hand side design via store()
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过store()实现右侧设计
- en: 'If we wish to implement the right-hand side design, then we must start by preparing
    a brand-new `PaymentRecord` (for instance, we must generate the *Check Number*)
    and storing it via an HTTP session attribute (`PAYMENT_ATTR`). This `PaymentRecord`
    is returned to the user. However, if the user wants to update the *Invoice Amount*
    of an existing payment, then they have the option to click on the corresponding
    *Load* link in the bottom table. The following query can be used to fetch the
    relevant `RecordPayment`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望实现右侧设计，那么我们必须首先准备一个新的 `PaymentRecord`（例如，我们必须生成 *Check Number*）并通过 HTTP
    会话属性（`PAYMENT_ATTR`）存储它。这个 `PaymentRecord` 将返回给用户。然而，如果用户想要更新现有付款的 *Invoice Amount*，那么他们可以选择点击底部表格中的相应
    *Load* 链接。以下查询可以用来获取相关的 `RecordPayment`：
- en: '[PRE227]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'The fetched `PaymentRecord` overrides the one from the HTTP session and is
    returned to the user. When the user submits the data, Spring Boot synchronizes
    the `PaymentRecord` value that''s stored in `PAYMENT_ATTR` (which can be the new
    `PaymentRecord` or the fetched `PaymentRecord`) with the submitted data. This
    time, we can let jOOQ choose between `INSERT` and `UPDATE` via `store()` since
    this method distinguishes between a new `PaymentRecord` and a fetched `PaymentRecord`
    and acts accordingly:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 获取的 `PaymentRecord` 覆盖了来自 HTTP 会话的记录，并将其返回给用户。当用户提交数据时，Spring Boot 会将存储在 `PAYMENT_ATTR`（可以是新的
    `PaymentRecord` 或获取的 `PaymentRecord`）中的 `PaymentRecord` 值与提交的数据同步。这次，我们可以让 jOOQ
    通过 `store()` 方法在 `INSERT` 和 `UPDATE` 之间进行选择，因为此方法区分了新的 `PaymentRecord` 和获取的 `PaymentRecord`
    并相应地执行：
- en: '[PRE233]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: The application that uses `store()` is named *StoreRecords* (available for MySQL).
    Now, let's move on and talk about navigating (updatable) records.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `store()` 的应用程序名为 *StoreRecords*（适用于 MySQL）。现在，让我们继续讨论如何导航（可更新的）记录。
- en: Navigating (updatable) records
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航（可更新的）记录
- en: jOOQ exposes several navigation methods that can be used for attached (updatable)
    records only (`TableRecord` and `UpdatableRecord`). To use these methods, please
    consider the following note.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 提供了几个仅适用于附加（可更新的）记录的导航方法（`TableRecord` 和 `UpdatableRecord`）。要使用这些方法，请考虑以下注意事项。
- en: Important Note
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While these methods are very convenient/appealing, they are also a big N+1 risk.
    `UpdatableRecord` is great for CRUD, but if you aren't using CRUD, then you shouldn't
    use `UpdatableRecord`. It's better to project only the columns you need and try
    to use joins or other SQL utilities to fetch data from multiple tables.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些方法非常方便/吸引人，但它们也带来了很大的 N+1 风险。`UpdatableRecord` 对于 CRUD 非常好，但如果您不使用 CRUD，那么您不应该使用
    `UpdatableRecord`。最好只投影所需的列，并尝试使用连接或其他 SQL 工具从多个表中获取数据。
- en: 'These methods navigate based on the foreign key references. For instance, with
    an attached `DepartmentRecord`, we can navigate its parent (`OFFICE`) via `fetchParent(ForeignKey<R,
    O> key)`, as shown in the following example:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法基于外键引用进行导航。例如，附上 `DepartmentRecord` 后，我们可以通过 `fetchParent(ForeignKey<R,
    O> key)` 导航其父级（`OFFICE`），如下所示：
- en: '[PRE246]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'The `Keys.DEPARTMENT_OFFICE_FK` foreign key was generated by the jOOQ Code
    Generator based on our `CREATE TABLE` DDL. In terms of MySQL dialect, jOOQ renders
    the following SQL:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`Keys.DEPARTMENT_OFFICE_FK` 外键是由 jOOQ 代码生成器根据我们的 `CREATE TABLE` DDL 生成的。在 MySQL
    方言中，jOOQ 生成的 SQL 如下所示：'
- en: '[PRE251]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'You can also fetch `Table<OfficeRecord>` via `parent()`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过 `parent()` 方法获取 `Table<OfficeRecord>`：
- en: '[PRE259]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Next, with an attached `OfficeRecord`, we can fetch the employees (`EMPLOYEE`)
    via `fetchChildren(ForeignKey<O,R> key)`, as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，附上 `OfficeRecord` 后，我们可以通过 `fetchChildren(ForeignKey<O,R> key)` 获取员工（`EMPLOYEE`），如下所示：
- en: '[PRE263]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'This time, the SQL that''s rendered for the MySQL dialect is as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，为 MySQL 方言生成的 SQL 如下所示：
- en: '[PRE268]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'You can also fetch `Table<OfficeRecord>` via `children()` (using `children()`
    is often preferable to `fetchChildren()` because it encourages writing queries
    rather than navigating `UpdatableRecord` directly):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过 `children()` 方法获取 `Table<OfficeRecord>`（使用 `children()` 通常比 `fetchChildren()`
    更可取，因为它鼓励编写查询而不是直接导航 `UpdatableRecord`）：
- en: '[PRE276]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'Next, we can reuse `fetchChildren()` to fetch the customers (`CUSTOMER`) of
    a certain employee (`EmployeeRecord`). This will result in every `CustomerRecord`
    of that `EmployeeRecord`. Finally, with an attached `CustomerRecord`, we can fetch
    its details (`CUSTOMERDETAIL`) via `fetchChild(ForeignKey<O, R> key)`, as follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以重用 `fetchChildren()` 来获取特定员工（`EmployeeRecord`）的客户（`CUSTOMER`）。这将导致获取该
    `EmployeeRecord` 的所有 `CustomerRecord`。最后，附上 `CustomerRecord` 后，我们可以通过 `fetchChild(ForeignKey<O,
    R> key)` 获取其详细信息（`CUSTOMERDETAIL`），如下所示：
- en: '[PRE280]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'The rendered SQL for the MySQL dialect is as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 为 MySQL 方言生成的 SQL 如下所示：
- en: '[PRE284]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'In the bundled code (*NavigationRecords*, which is available for MySQL), you
    can see all these methods collaborating to obtain something similar to the following:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码（*NavigationRecords*，适用于 MySQL）中，你可以看到所有这些方法协同工作以获得类似以下的内容：
- en: '![Figure 9.7 – Navigating between records'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.7 – 在记录之间导航]'
- en: '](img/B16833_Figure_9.7.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_9.7.jpg]'
- en: Figure 9.7 – Navigating between records
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 在记录之间导航
- en: 'These methods are also quite handy for looping the parent/children of a record
    and taking some action. Here is an example of using `fetchParent()` to fetch the
    `EmployeeRecord` details of each `SaleRecord` that has less than *2,000* sales:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法对于循环处理记录的父/子关系并执行某些操作也非常方便。以下是一个使用 `fetchParent()` 来获取每个销售额少于 *2,000* 的
    `SaleRecord` 的 `EmployeeRecord` 详细信息的示例：
- en: '[PRE292]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'In the previous example, each call of `fetchParent()` executes a separate `SELECT`,
    which is far away from being a good choice. However, an interesting method that''s
    helpful in this case is `fetchParents()`, which can fetch all the parents of a
    list of records in a single `SELECT`. This means that we can rewrite the previous
    query like so:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，每次调用 `fetchParent()` 都会执行一个单独的 `SELECT`，这远远不是一个好的选择。然而，一个在这个情况下有帮助的有趣方法是
    `fetchParents()`，它可以一次性获取记录列表的所有父记录。这意味着我们可以将之前的查询重写如下：
- en: '[PRE298]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'If you need `Table<EmployeeRecord>`, then use `parents()`:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要 `Table<EmployeeRecord>`，则使用 `parents()`：
- en: '[PRE312]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: Important Note
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that these kinds of loops are really bad from a performance perspective!
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从性能角度来看，这类循环真的很糟糕！
- en: If there's no business logic in the client, it should be a single `DELETE` statement
    with a semi-join (for instance, an `IN` predicate). So, don't take these loop
    examples at face value. I know that this approach feels easier but I strongly
    recommend avoiding it. Don't implement such loops all over the application and
    then complain about jOOQ being slow, just like when people complain about Hibernate
    being slow when these navigational loops are simply wrong.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端没有业务逻辑，它应该是一个带有半连接（例如，一个 `IN` 谓词）的单个 `DELETE` 语句。因此，不要将这些循环示例当作字面意思来理解。我知道这种方法感觉更容易，但我强烈建议避免使用它。不要在应用程序中到处实现这样的循环，然后抱怨
    jOOQ 很慢，就像人们抱怨 Hibernate 很慢时这些导航循环只是错误的。
- en: The only reason why anyone should ever process data row by row is that each
    row requires very complex business logic that can't be expressed in SQL or otherwise
    pushed into the database. People get this wrong in all languages, including PL/SQL.
    They loop over rows because it's convenient and they prefer 3GLs over SQL-the-4GL,
    and then they run queries on a row-by-row basis because they can. So, to justify
    the previous loops, we need to at least add some `businessLogicHere(saleRecord)`
    method calls to hint at the row-by-row approach being necessary in this particular
    case.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都应该逐行处理数据的唯一原因是每一行都需要非常复杂的业务逻辑，这些逻辑无法用 SQL 表达或以其他方式推入数据库。人们在所有语言中都会犯这个错误，包括
    PL/SQL。他们循环遍历行是因为这样做方便，他们更喜欢 3GL 而不是 SQL-4GL，然后他们逐行运行查询，因为他们可以这样做。因此，为了证明之前的循环是合理的，我们至少需要添加一些
    `businessLogicHere(saleRecord)` 方法调用，以暗示在这个特定情况下逐行方法是有必要的。
- en: You can find these examples in *NavigationParentsRecords* (available for MySQL).
    Next, let's focus on using explicit transactions and jOOQ queries.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *NavigationParentsRecords*（适用于 MySQL）中找到这些示例。接下来，让我们专注于使用显式事务和 jOOQ 查询。
- en: Transactions
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: Among other benefits, transactions give us the ACID properties. We can distinguish
    between *read-only* and *read-write* transactions, different isolation levels,
    different propagation strategies, and so on. While Spring Boot supports a comprehensive
    transactional API (Spring TX) that's commonly used via `@Transactional` and `TransactionTemplate`,
    jOOQ comes with a simple transaction API (and an `org.jooq.TransactionProvider`
    SPI) that fits perfectly in the context of fluent style.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他好处中，事务为我们提供了 ACID 属性。我们可以区分 *只读* 和 *读写* 事务，不同的隔离级别，不同的传播策略等等。虽然 Spring Boot
    支持一个全面的交易 API（Spring TX），通常通过 `@Transactional` 和 `TransactionTemplate` 使用，但 jOOQ
    提供了一个简单的交易 API（以及一个 `org.jooq.TransactionProvider` SPI），它非常适合流畅风格的上下文。
- en: 'The following diagram highlights the main implementations of this SPI:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表突出了此 SPI 的主要实现：
- en: '![Figure 9.8 – jOOQ transaction providers'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.8 – jOOQ transaction providers]'
- en: '](img/B16833_Figure_9.8.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_9.8.jpg]'
- en: Figure 9.8 – jOOQ transaction providers
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – jOOQ 事务提供者
- en: Starting with jOOQ 3.17 we have support for transactions in R2DBC as well. So,
    jOOQ 3.17 come with support for reactive transactions.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 从jOOQ 3.17开始，我们支持R2DBC中的事务。因此，jOOQ 3.17带来了对反应式事务的支持。
- en: 'Mainly, the jOOQ API for blocking transactions can be used like so:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 主要地，jOOQ API用于阻塞事务的使用方式如下：
- en: '[PRE314]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: Here, we have `transaction(TransactionalRunnable)`, which returns `void` and
    `transactionResult(TransactionalCallable)` for returning a result. The former
    wraps the transactional code in jOOQ's `org.jooq.TransactionalRunnable` functional
    interface, while the latter wraps the transactional code in jOOQ's `org.jooq.TransactionalCallable`
    functional interface.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`transaction(TransactionalRunnable)`，它返回`void`，以及`transactionResult(TransactionalCallable)`用于返回结果。前者将事务性代码包装在jOOQ的`org.jooq.TransactionalRunnable`函数式接口中，而后者将事务性代码包装在jOOQ的`org.jooq.TransactionalCallable`函数式接口中。
- en: Important Note
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Pay attention to the fact that, inside a jOOQ transaction, you must use `DSLContext`
    that's been obtained from the given (`configuration`, not `ctx` (the injected
    `DSLContext`).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在jOOQ事务内部，您必须使用从给定（`configuration`，而不是`ctx`（注入的`DSLContext`））获得的`DSLContext`。
- en: SpringTransactionProvider
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SpringTransactionProvider
- en: In terms of Spring Boot's context, jOOQ delegates the task of handling the transactions
    (*begin*, *commit*, and *rollback*) to `SpringTransactionProvider`, an implementation
    of the `org.jooq.TransactionProvider` SPI that's meant to allow Spring Transaction
    to be used with JOOQ. By default, you'll get a *read-write* transaction with no
    name (`null`) whose propagation is set to `PROPAGATION_NESTED`, and the isolation
    level is set to the default isolation level of the underlying database; that is,
    `ISOLATION_DEFAULT`.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot的上下文中，jOOQ将处理事务（*开始*、*提交*和*回滚*）的任务委托给`SpringTransactionProvider`，这是`org.jooq.TransactionProvider`
    SPI的一个实现，旨在允许Spring事务与JOOQ一起使用。默认情况下，您将获得一个没有名称（`null`）的*读写*事务，其传播行为设置为`PROPAGATION_NESTED`，隔离级别设置为底层数据库的默认隔离级别；即`ISOLATION_DEFAULT`。
- en: 'If you ever want to decouple `SpringTransactionProvider` (for instance, to
    avoid potential incompatibilities between Spring Boot and jOOQ), then use the
    following code:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想解耦`SpringTransactionProvider`（例如，为了避免Spring Boot和JOOQ之间的潜在不兼容性），则可以使用以下代码：
- en: '[PRE322]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'Once you''ve decoupled `SpringTransactionProvider`, jOOQ will execute the transaction
    via the jOOQ''s `DefaultTransactionProvider` and `DefaultConnectionProvider` with
    *auto-commit* mode set to `false` (if it was `true` before the transaction, then
    jOOQ will restore it after the transaction). `DefaultTransactionProvider` supports
    nested transactions that have been implemented via JDBC''s `java.sql.Savepoint`.
    In [*Chapter 18*](B16833_18.xhtml#_idTextAnchor338), *jOOQ SPI (Providers and
    Listeners)*, you''ll learn how to implement a `TransactionProvider`, but for now,
    let''s look at some examples of jOOQ transactions. Let''s start from a simple
    transaction that highlights the commit/rollback:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解耦了`SpringTransactionProvider`，jOOQ将通过jOOQ的`DefaultTransactionProvider`和`DefaultConnectionProvider`执行事务，并将*自动提交*模式设置为`false`（如果事务之前是`true`，则jOOQ将在事务后恢复它）。`DefaultTransactionProvider`支持通过JDBC的`java.sql.Savepoint`实现的嵌套事务。在[*第18章*](B16833_18.xhtml#_idTextAnchor338)
    *jOOQ SPI（提供者和监听器）*中，您将学习如何实现`TransactionProvider`，但现在，让我们看看一些jOOQ事务的例子。让我们从一个简单的、突出提交/回滚的事务开始：
- en: '[PRE326]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'If you want to handle/prevent rollbacks, then you can wrap the transactional
    code in a `try-catch` block and act as you consider; if you want to do some work
    (for instance, do some cleanup work) and roll back, then just throw the exception
    at the end of the `catch` block. Otherwise, by catching `RuntimeException`, we
    can prevent a rollback from occurring if something went wrong while executing
    the SQL statements from jOOQ:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想处理/防止回滚，则可以将事务性代码包装在`try-catch`块中，并根据您的考虑行事；如果您想做一些工作（例如，做一些清理工作）然后回滚，那么只需在`catch`块的末尾抛出异常。否则，通过捕获`RuntimeException`，我们可以在执行jOOQ的SQL语句时发生错误时防止回滚：
- en: '[PRE335]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: jOOQ nested transactions look like Matrioska dolls. We nest the transactional
    code by nesting calls of `transaction()`/`transactionResult()`. Here, the transactions
    will be automatically demarcated by jOOQ with savepoints. Of course, no one is
    prevented from extracting these lambdas into methods and composing them as higher-order
    functions, just like you can compose Spring-annotated transactional methods.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ嵌套事务看起来像套娃。我们通过嵌套调用`transaction()`/`transactionResult()`来嵌套事务性代码。在这里，事务将由jOOQ自动使用保存点来界定。当然，没有人阻止将这些lambda表达式提取到方法中，并将它们作为高阶函数组合起来，就像您可以将Spring注解的事务性方法组合起来一样。
- en: 'Here is an example of nesting two jOOQ transactions:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个嵌套两个jOOQ事务的示例：
- en: '[PRE343]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'By default, if something goes wrong in one of the transactions, then the subsequent
    transactions (inner transactions) will not be executed and all the outer transactions
    will be rolled back. But sometimes, we may want to roll back only the current
    transaction and not affect the outer transactions, as shown in the following example:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果在事务中发生错误，则后续事务（内部事务）将不会执行，所有外部事务都将回滚。但有时，我们可能只想回滚当前事务，而不影响外部事务，如下例所示：
- en: '[PRE355]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: You can check out these examples in *JOOQTransaction* (available for MySQL).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*JOOQTransaction*（适用于MySQL）中查看这些示例。
- en: ThreadLocalTransactionProvider
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ThreadLocalTransactionProvider
- en: Another jOOQ built-in transaction provider is `ThreadLocalTransactionProvider`.
    This provider implements thread-bound transaction semantics. In other words, a
    transaction and its associated `Connection` will never leave the thread that started
    the transaction.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个jOOQ内置事务提供者是`ThreadLocalTransactionProvider`。此提供者实现了线程绑定的事务语义。换句话说，事务及其关联的`Connection`永远不会离开启动事务的线程。
- en: An important requirement of `ThreadLocalTransactionProvider` is that we must
    pass a custom `ConnectionProvider` implementation directly to this provider instead
    of passing it to `Configuration`. We can write our own `CustomProvider` or rely
    on a jOOQ built-one such as `MockConnectionProvider` (for tests), `DefaultConnectionProvider`,
    `DataSourceConnectionProvider`, or `NoConnectionProvider`.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadLocalTransactionProvider`的一个重要要求是我们必须直接将自定义的`ConnectionProvider`实现传递给此提供者，而不是将其传递给`Configuration`。我们可以编写自己的`CustomProvider`或依赖于jOOQ提供的内置实现，如`MockConnectionProvider`（用于测试）、`DefaultConnectionProvider`、`DataSourceConnectionProvider`或`NoConnectionProvider`。'
- en: 'For instance, if we choose `DataSourceConnectionProvider`, then, in a Spring
    Boot application, we can use a `DataSource` (for instance, `HikariDataSource`)
    that has already been prepared by Spring Boot, as follows:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们选择`DataSourceConnectionProvider`，那么在一个Spring Boot应用程序中，我们可以使用Spring Boot已经准备好的`DataSource`（例如，`HikariDataSource`），如下所示：
- en: '[PRE374]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: 'Alternatively, if you are using Spring Boot 2.5.0+, then you can profit from
    the `DefaultConfigurationCustomizer` functional interface. This interface defines
    a method called `customize(DefaultConfiguration configuration)`, which is a handy
    way to customize jOOQ''s `DefaultConfiguration`:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您正在使用Spring Boot 2.5.0+，那么您可以利用`DefaultConfigurationCustomizer`功能接口。此接口定义了一个名为`customize(DefaultConfiguration
    configuration)`的方法，这是一种自定义jOOQ的`DefaultConfiguration`的便捷方式：
- en: '[PRE395]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: Done! Now, we can inject the `DSLContext` information that's been built by Spring
    Boot based on our `Configuration` and take advantage of thread-bound transaction
    semantics, which is usually exactly what Spring uses. You can check out an example
    by looking at *ThreadLocalTransactionProvider{1,2}*, which is available for MySQL.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，我们可以注入由Spring Boot根据我们的`Configuration`构建的`DSLContext`信息，并利用线程绑定的事务语义，这通常是Spring所使用的。您可以通过查看*ThreadLocalTransactionProvider{1,2}*来查看示例，该示例适用于MySQL。
- en: Next, let's talk about jOOQ asynchronous transactions.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来谈谈jOOQ的异步事务。
- en: jOOQ asynchronous transactions
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jOOQ异步事务
- en: 'While `transaction()` and `transactionResult()` are synchronous, jOOQ also
    has `transactionAsync()` and `transactionResultAsync()`, which can be used to
    shape asynchronous transactions. Here are two asynchronous transactions that act
    independently of each other – they run in concurrent threads. The first one commits,
    while the second one rolls back:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`transaction()`和`transactionResult()`是同步的，但jOOQ也有`transactionAsync()`和`transactionResultAsync()`，可以用来构建异步事务。这里有两组独立的异步事务——它们在并发线程中运行。第一个事务提交，而第二个事务回滚：
- en: '[PRE408]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: If you don't want to rely on the default `Executor` (`ForkJoinPool.commonPool()`),
    then use `transactionAsync(Executor exctr, TransactionalRunnable tr)` or `transactionResultAsync(Executor
    exctr, TransactionalCallable<T> tc)`, respectively. But unlike what `CompletableFuture`
    does, jOOQ will remember `Executor` in its `CompletionStage` implementation so
    that it doesn't have to be provided on every ensuing asynchronous call.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想依赖于默认的`Executor`（`ForkJoinPool.commonPool()`），那么请分别使用`transactionAsync(Executor
    exctr, TransactionalRunnable tr)`或`transactionResultAsync(Executor exctr, TransactionalCallable<T>
    tc)`。但与`CompletableFuture`不同，jOOQ会在其`CompletionStage`实现中记住`Executor`，这样就不需要在每个随后的异步调用中提供它。
- en: However, asynchronous transactions work very badly with Spring, which usually
    assumes thread-bound transactions. Go to [https://github.com/spring-projects/spring-boot/issues/24049](https://github.com/spring-projects/spring-boot/issues/24049)
    to see a discussion about this.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，异步事务与Spring配合得非常糟糕，因为Spring通常假设线程绑定事务。前往[https://github.com/spring-projects/spring-boot/issues/24049](https://github.com/spring-projects/spring-boot/issues/24049)查看关于此问题的讨论。
- en: Check out the complete code in *JOOQTransactionAsync* (available for MySQL).
    Next, let's look at some examples of using/choosing `@Transactional` or the jOOQ
    transaction API.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 查看*JOOQTransactionAsync*中的完整代码（适用于MySQL）。接下来，让我们看看使用/选择`@Transactional`或jOOQ事务API的一些示例。
- en: '@Transactional versus the jOOQ transaction API'
  id: totrans-659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`@Transactional`与jOOQ事务API的比较'
- en: Right off the bat, I wish to enforce an important note (most of you probably
    already know and respect these statements, but a quick reminder is always welcome).
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我希望强调一个重要的注意事项（你们中的大多数人可能已经知道并尊重这些声明，但快速提醒总是受欢迎的）。
- en: Important Note
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: A non-transactional-context refers to a context with no explicit transaction
    boundaries, *not* to a context with no physical database transaction. All database
    statements are executed in the context of a physical database transaction.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 非事务上下文指的是没有显式事务边界的上下文，*并不是*指没有物理数据库事务的上下文。所有数据库语句都在物理数据库事务的上下文中执行。
- en: Without specifying the explicit boundaries of the transaction (via `@Transactional`,
    `TransactionTemplate`, the jOOQ transaction API, and so on), jOOQ *may* use a
    different database connection for each statement. Whether or not jOOQ uses a different
    connection per statement is defined by `ConnectionProvider`. This statement is
    true for `DataSourceConnectionProvider` (and even then, it depends on `DataSource`)
    but false for `DefaultConnectionProvider`. In the worst-case scenario, this means
    that the statements that define a *logical transaction* don't benefit from ACID
    and they are prone to lead to *race condition* bugs and SQL *phenomena*. Each
    statement is executed in a separate transaction (*auto-commit* mode), which may
    result in a high database connection acquisition request rate, which is not good!
    On medium/large applications, reducing the database connection acquisition request
    rate next to short transactions will sustain performance since your application
    will be ready to face high traffic (a high number of concurrent requests).
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定事务的显式边界（通过`@Transactional`、`TransactionTemplate`、jOOQ事务API等），jOOQ*可能*为每个语句使用不同的数据库连接。jOOQ是否为每个语句使用不同的连接由`ConnectionProvider`定义。这个声明对`DataSourceConnectionProvider`（即使在那时，也取决于`DataSource`）是正确的，但对`DefaultConnectionProvider`是错误的。在最坏的情况下，这意味着定义*逻辑事务*的语句无法受益于ACID，并且容易导致*竞争条件*错误和SQL
    *现象*。每个语句都在单独的事务中执行（*自动提交*模式），这可能会导致数据库连接获取请求率很高，这并不好！在中等/大型应用程序中，通过缩短事务来减少数据库连接获取请求率可以维持性能，因为您的应用程序将准备好应对高流量（大量并发请求）。
- en: Never combine `@Transactional`/`TransactionTemplate` and the jOOQ transaction
    API to solve a task in common (the same is true for Java/Jakarta EE transactions,
    of course). This may lead to unexpected behaviors. So long as Spring transactions
    and jOOQ transactions are not interleaved, it is safe to use them in the same
    application.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将`@Transactional`/`TransactionTemplate`和jOOQ事务API组合起来解决共同的任务（当然，这也适用于Java/Jakarta
    EE事务）。这可能会导致意外的行为。只要Spring事务和jOOQ事务没有交错，就可以在同一个应用程序中使用它们。
- en: The best way to use Spring transactions *only* consists of annotating your repository/service
    class with `@Transactional(readOnly=true)` and explicitly setting `@Transactional`
    only on methods that should be allowed to execute write statements. However, if
    the same repository/service uses jOOQ transactions as well, then you should explicitly
    annotate each method, not the class itself. This way, you avoid inheriting `@Transactional(readOnly=true)`
    in methods that explicitly use jOOQ transactions.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring事务的最佳方式*仅*包括在您的仓库/服务类上使用`@Transactional(readOnly=true)`注解，并且仅在允许执行写语句的方法上显式设置`@Transactional`。然而，如果相同的仓库/服务也使用jOOQ事务，那么您应该显式注解每个方法，而不是类本身。这样，您就可以避免在显式使用jOOQ事务的方法中继承`@Transactional(readOnly=true)`。
- en: 'Now, let''s consider several examples that are meant to reveal the best practices
    for using transactions. Let''s start with the following snippet of code:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑几个旨在揭示使用事务最佳实践的示例。让我们从以下代码片段开始：
- en: '[PRE437]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: 'This method runs in a non-transactional context and executes two read statements.
    Each read is executed by the database in a separate physical transaction that
    requires a separate database connection. Keep in mind that this may not be true,
    depending on `ConnectionProvider`. Relying on `@Transactional(readOnly=true)`
    is much better:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在非事务性上下文中运行，并执行两个读取语句。每个读取操作都由数据库在单独的物理事务中执行，这需要单独的数据库连接。请注意，这可能并不总是正确的，这取决于`ConnectionProvider`。依赖`@Transactional(readOnly=true)`要更好：
- en: '[PRE441]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: This time, a single database connection and a single transaction are used. `readOnly`
    come with a bunch of advantages, including that your team members cannot accidentally
    add write statements (such attempt result in an error), read-only transactions
    can be optimized at the database level (this is database vendor-specific), you
    must explicitly set the transaction isolation level as expected, and so on.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，使用单个数据库连接和单个事务。`readOnly`带来了许多优势，包括你的团队成员不会意外地添加写语句（这种尝试会导致错误），只读事务可以在数据库级别进行优化（这是数据库供应商特定的），你必须显式设置预期的事务隔离级别，等等。
- en: Moreover, having no transaction and setting auto-commit to `true` only makes
    sense if you execute a single read-only SQL statement, but it doesn't lead to
    any significant benefit. Therefore, even in such cases, it's better to rely on
    explicit (declarative) transactions.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有事务并将自动提交设置为`true`只有在执行单个只读SQL语句时才有意义，但这不会带来任何显著的好处。因此，即使在这样的情况下，也最好依赖显式（声明性）事务。
- en: 'However, if you consider that the `readOnly=true` flag isn''t needed, then
    the following code can be executed in a jOOQ transaction as well (by default,
    this is a read-write transaction):'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你认为不需要`readOnly=true`标志，那么以下代码也可以在jOOQ事务中执行（默认情况下，这是一个读写事务）：
- en: '[PRE446]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: 'Notice that, exactly like Spring''s `TransactionTemplate` (which can be used
    as well), the jOOQ transaction can strictly demarcate the transactional code.
    In other words, the `@Transactional` annotation acquires the database connection
    and starts the transaction immediately when entering the method. Then, it commits
    the transaction at the end of the method. This means that the potentially non-transactional
    code of a `@Transactional` method (the code that shapes business logic that doesn''t
    need to run in a transaction) still runs inside the current transaction, which
    can lead to a long-running transaction. On the other hand, jOOQ transactions (just
    like `TransactionTemplate`) allow us to isolate and orchestrate the transactional
    code to run in transactions and the rest of the code outside of transactions.
    Let''s look at a scenario where using a jOOQ transaction (or `TransactionTemplate`)
    is a better choice than using `@Transactional`:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与Spring的`TransactionTemplate`（也可以使用）一样，jOOQ事务可以严格界定事务性代码。换句话说，`@Transactional`注解在进入方法时立即获取数据库连接并开始事务。然后，它在方法结束时提交事务。这意味着`@Transactional`方法中可能的事务性代码（不需要在事务中运行的业务逻辑代码）仍然在当前事务中运行，这可能导致长时间运行的事务。另一方面，jOOQ事务（就像`TransactionTemplate`）允许我们将事务性代码隔离和编排，以便在事务中运行，而其余代码在事务外运行。让我们看看使用jOOQ事务（或`TransactionTemplate`）比使用`@Transactional`更好的场景：
- en: '[PRE453]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: 'In this case, jOOQ fetches the whole result set into memory via the connection
    that''s been opened by `@Transactional`. This means that the streaming operations
    (for instance, `map()`) don''t need transactions, but Spring will close this transaction
    at the end of the method. This can result in a potentially long-running transaction.
    While we can avoid this issue by splitting the code into separate methods, we
    can also rely on a jOOQ transaction (or `TransactionTemplate`):'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，jOOQ通过`@Transactional`打开的连接将整个结果集检索到内存中。这意味着流操作（例如，`map()`）不需要事务，但Spring将在方法结束时关闭此事务。这可能导致长时间运行的事务。虽然我们可以通过将代码拆分为单独的方法来避免这个问题，但我们也可以依赖jOOQ事务（或`TransactionTemplate`）：
- en: '[PRE466]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: This is much better because we've removed the streaming operations from the
    transaction.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这更好，因为我们已经从事务中移除了流操作。
- en: 'In terms of executing one or more DML operations in a method, it should be
    annotated with `@Transactional`, explicitly use the jOOQ transaction API, or use
    `TransactionTemplate` to demarcate the transactional code. Otherwise, Spring Boot
    will report an `SQLException`: *Connection is read-only. Queries leading to data
    modification are not allowed*. You can see such an example next to the previous
    examples in *SpringBootTransactional* (available for MySQL).'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中执行一个或多个 DML 操作时，应使用 `@Transactional` 注解，显式使用 jOOQ 事务 API，或使用 `TransactionTemplate`
    来标记事务代码。否则，Spring Boot 将报告 `SQLException`：*连接为只读。不允许导致数据修改的查询*。您可以在 *SpringBootTransactional*（适用于
    MySQL）中的前一个示例旁边看到这样的示例。
- en: It is a well-known shortcoming of Spring transactions that `@Transactional`
    is ignored if it is added to a `private`, `protected`, or package-protected method
    or to a method that's been defined in the same class as where it is invoked. By
    default, `@Transactional` only works on `public` methods that should be added
    to classes and are different from where they are invoked. However, this issue
    can easily be avoided by using the jOOQ transaction API or `TransactionTemplate`,
    which don't suffer from these issues. You can explore some examples by looking
    at the *JOOQTransactionNotIgnored* application (available for MySQL).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 事务的一个众所周知的问题是，如果 `@Transactional` 被添加到 `private`、`protected` 或包保护的类中，或者添加到与调用它的类定义相同的类的方法中，则会被忽略。默认情况下，`@Transactional`
    仅在 `public` 方法上起作用，这些方法应添加到类中，并且与调用它们的类不同。然而，通过使用 jOOQ 事务 API 或 `TransactionTemplate`，可以轻松避免这些问题，因为它们不受这些问题的影响。您可以通过查看
    *JOOQTransactionNotIgnored* 应用程序（适用于 MySQL）来探索一些示例。
- en: A strong argument for choosing the Spring transactions for our jOOQ queries
    is that we can benefit from Spring transactions' isolation levels and propagation
    strategies. In the bundled code, you can find a suite of seven applications –
    one for each of the seven propagation levels supported by Spring transactions
    – that exemplifies the usage of jOOQ queries and Spring transaction propagations.
    These applications are called *Propagation{Foo}* and are available for MySQL.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Spring 事务为我们 jOOQ 查询的一个强有力的论点是，我们可以从 Spring 事务的隔离级别和传播策略中受益。在捆绑的代码中，您可以找到一个包含七个应用程序的套件——每个应用程序对应于
    Spring 事务支持的七个传播级别之一——这些应用程序展示了 jOOQ 查询和 Spring 事务传播的使用。这些应用程序被称为 *Propagation{Foo}*，适用于
    MySQL。
- en: 'In conclusion, jOOQ queries can be used in the following circumstances:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，jOOQ 查询可以在以下情况下使用：
- en: Only with Spring transactions (you can take advantage of Spring transactions'
    features at full capacity)
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在 Spring 事务中（您可以充分利用 Spring 事务的特性）
- en: Only with jOOQ transactions (in the context of Spring Boot, you'll get read-write,
    nested transactions that rely on the database's isolation level)
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在 jOOQ 事务（在 Spring Boot 的上下文中，您将获得依赖数据库隔离级别的读写、嵌套事务）中
- en: By combining them without interleaving Spring with jOOQ transactions to accomplish
    common tasks (in other words, once you open a Spring transaction, ensure that
    any subsequent inner transaction is a Spring one as well. If you open a jOOQ transaction,
    then ensure that any subsequent inner transaction is a jOOQ one.)
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将它们结合使用，而不将 Spring 与 jOOQ 事务交织在一起以完成常见任务（换句话说，一旦打开 Spring 事务，确保任何后续的内层事务也是
    Spring 事务。如果您打开 jOOQ 事务，那么确保任何后续的内层事务也是 jOOQ 事务。）
- en: Hooking reactive transactions
  id: totrans-725
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩子式响应式事务
- en: 'As mentioned earlier, starting with jOOQ 3.17, we can take advantage of reactive
    transactions or transactions in R2DBC. Reactive transactions are easy to use via
    `Publisher`, as they have the same semantics as JDBC’s blocking APIs Here is an
    example of how to write a nested reactive transaction:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，从 jOOQ 3.17 版本开始，我们可以利用响应式事务或 R2DBC 中的事务。响应式事务可以通过 `Publisher` 容易地使用，因为它们与
    JDBC 的阻塞 API 具有相同的语义。以下是一个编写嵌套响应式事务的示例：
- en: '[PRE481]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: Being in Spring Boot, this example relies on Project Reactor ([https://projectreactor.io/](https://projectreactor.io/)),
    but you can use any other reactive library. More examples are available in the
    bundled code for MySQL, *jOOQReactiveTransaction*.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 Spring Boot 中，此示例依赖于 Project Reactor ([https://projectreactor.io/](https://projectreactor.io/))，但您可以使用任何其他响应式库。更多示例可以在捆绑的
    MySQL 代码中的 *jOOQReactiveTransaction* 中找到。
- en: Locking
  id: totrans-741
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定
- en: '**Locking** is used to orchestrate concurrent access to data to prevent *race
    condition* threads, deadlocks, *lost updates*, and other SQL *phenomena*.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '**锁定**用于协调对数据的并发访问，以防止 *竞争条件* 线程、死锁、*丢失更新* 和其他 SQL *现象*。'
- en: Among the most popular locking mechanisms, we have **optimistic** and **pessimistic**
    *locking*. As you'll see shortly, jOOQ supports both of them for CRUD operations.
    So, let's start with *optimistic locking*.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 在最流行的锁定机制中，我们有**乐观**和**悲观***锁定*。正如你很快就会看到的，jOOQ支持它们在CRUD操作中。所以，让我们从*乐观锁定*开始。
- en: Optimistic locking overview
  id: totrans-744
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乐观锁定概述
- en: '*Optimistic locking* is commonly related to the **lost updates** SQL phenomena,
    so let''s quickly overview this anomaly.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '*乐观锁定*通常与**丢失更新**SQL现象相关，所以让我们快速概述这个异常。'
- en: A *lost update* is a popular anomaly that can seriously affect data integrity.
    A transaction reads a record and uses this information to make business decisions
    (for instance, decisions that may lead to that record being modified) without
    being aware that, in the meantime, a concurrent transaction has modified that
    record and committed it. When the first transaction commits, it is unaware of
    the lost update. This may cause data integrity issues (for example, the inventory
    can report a negative value, a certain payment can be lost, and so on).
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '*丢失更新*是一种常见的异常，可能会严重影响数据完整性。一个事务读取一条记录并使用这些信息做出业务决策（例如，可能导致该记录被修改的决策）而没有意识到，在此期间，一个并发事务已经修改了该记录并提交了它。当第一个事务提交时，它没有意识到丢失更新。这可能会导致数据完整性问题（例如，库存可能报告负值，某些付款可能丢失，等等）。'
- en: 'Consider the scenario shown in the following diagram:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图中所示的场景：
- en: '![Figure 9.9 – Lost update phenomena'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.9 – Lost update phenomena]'
- en: '](img/B16833_Figure_9.9.jpg)'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_9.9.jpg]'
- en: Figure 9.9 – Lost update phenomena
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 丢失更新现象
- en: 'If we take this scenario step-by-step, then the following occurs:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们逐步分析这个场景，那么以下情况会发生：
- en: John and Mary fetch the invoice amount (*2,300*) of the same payment.
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 约翰和玛丽获取相同付款的发票金额（*2,300*）。
- en: Mary considers that the current invoice amount is too much, so she updates the
    amount from *2,300* to *2,000*.
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玛丽认为当前的发票金额太高，因此将金额从*2,300*更新为*2,000*。
- en: John's transaction is not aware of Mary's update.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 约翰的交易没有意识到玛丽的更新。
- en: John considers that the current invoice amount is not enough, so he updates
    the amount to *2,800*, without being aware of Mary's decision.
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 约翰认为当前的发票金额不足，因此将金额更新为*2,800*，而没有意识到玛丽的决定。
- en: This anomaly affects the **Read Committed** isolation level and can be avoided
    by setting the **Repeatable Read** or **Serializable** isolation level. For the
    **Repeatable Read** isolation level without **Multi-Version Concurrency Control**
    (**MVCC**), the database uses shared locks to reject other transactions' attempts
    to modify an already fetched record.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异常会影响**可重复读**隔离级别，可以通过设置**可重复读**或**串行化**隔离级别来避免。对于没有**多版本并发控制**（**MVCC**）的**可重复读**隔离级别，数据库使用共享锁来拒绝其他事务尝试修改已检索的记录。
- en: 'However, in the presence of MVCC databases, there is no need for locks since
    we can use the application-level optimistic locking mechanism. Typically, application-level
    optimistic locking starts by adding an integer field (typically named `version`)
    to the corresponding table(s). By default, this field is 0, and each `UPDATE`
    attempts to increment it by 1, as shown in the following diagram (this is also
    known as *versioned* optimistic locking):'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在存在MVCC数据库的情况下，没有必要使用锁，因为我们可以使用应用级别的乐观锁定机制。通常，应用级别的乐观锁定是通过向相应的表（s）添加一个整数字段（通常命名为`version`）开始的。默认情况下，此字段为0，每次`UPDATE`尝试将其增加1，如图所示（这也称为*版本化*乐观锁定）：
- en: '![Figure 9.10 – Versioned optimistic locking (via numeric field)'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.10 – Versioned optimistic locking (via numeric field)]'
- en: '](img/B16833_Figure_9.10.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_9.10.jpg]'
- en: Figure 9.10 – Versioned optimistic locking (via numeric field)
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 基于数值字段的版本化乐观锁定
- en: This time, John is aware of Mary's decision, so he can make further decisions
    based on this information. In application-level optimistic locking, the application
    is responsible for handling the `version` field. The application should set the
    `version` value and append the proper `WHERE` clause to the executed `UPDATE`/`DELETE`
    to check the `version` value against the database. Moreover, if no `UPDATE`/`DELETE`
    has happened because `WHERE version=?` failed, then the application is responsible
    for signaling this behavior, meaning that the corresponding transaction contains
    *stale* data. Commonly, it does this by throwing a meaningful exception. As you'll
    see next, jOOQ aligns with this behavior.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，约翰知道玛丽的决定，因此他可以根据这个信息做出进一步的决策。在应用级别的乐观锁定中，应用程序负责处理`版本`字段。应用程序应设置`版本`值，并将适当的`WHERE`子句附加到执行的`UPDATE`/`DELETE`中，以检查数据库中的`版本`值。此外，如果没有发生`UPDATE`/`DELETE`操作，因为`WHERE
    version=?`失败，那么应用程序负责发出此行为信号，这意味着相应的事务包含*过时*的数据。通常，它会通过抛出一个有意义的异常来完成。正如您接下来将看到的，jOOQ与此行为保持一致。
- en: With long conversations that span several (HTTP) requests, besides the application-level
    optimistic locking mechanism, you must keep the old data snapshots (for instance,
    jOOQ updatable records). In web applications, they can be stored in the HTTP session.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 对于跨越多个（HTTP）请求的长对话，除了应用级别的乐观锁定机制之外，您还必须保留旧数据快照（例如，jOOQ可更新记录）。在Web应用程序中，它们可以存储在HTTP会话中。
- en: jOOQ optimistic locking
  id: totrans-763
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jOOQ乐观锁定
- en: 'By default, the jOOQ optimistic locking mechanism for CRUD operations is disabled.
    It can be enabled via the `withExecuteWithOptimisticLocking()` setting, as shown
    here:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，jOOQ的CRUD操作的乐观锁定机制是禁用的。可以通过`withExecuteWithOptimisticLocking()`设置来启用，如下所示：
- en: '[PRE494]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: Of course, you can toggle this setting locally by using a `Configuration` as
    well.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以通过使用`配置`来在本地切换此设置。
- en: jOOQ optimistic locking via SELECT … FOR UPDATE
  id: totrans-774
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过SELECT … FOR UPDATE进行jOOQ乐观锁定
- en: At this point, without further settings, jOOQ will intercept any CRUD `UPDATE`/`DELETE`
    (executed explicitly via `update()`/`delete()` or generated via `merge()`/`store()`),
    and will attempt to determine if the record contains *stale* data. For this, jOOQ
    acquires a database-exclusive read/write lock for the involved data via `SELECT
    … FOR UPDATE`, which is practically done via pessimistic locking. Next, jOOQ compares
    the fetched data with the data to be updated/deleted. Practically, the fetched
    data is compared against the *original* values of the record to be updated/deleted.
    If the record data is not *stale*, then jOOQ executes `UPDATE`/`DELETE` against
    the database; otherwise, it will throw a specific `org.jooq.exception.DataChangedException`.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果没有进一步的设置，jOOQ将拦截任何CRUD `UPDATE`/`DELETE`（通过`update()`/`delete()`显式执行或通过`merge()`/`store()`生成），并尝试确定记录是否包含*过时*数据。为此，jOOQ通过`SELECT
    … FOR UPDATE`获取涉及数据的数据库独占读写锁，这实际上是通过悲观锁定完成的。接下来，jOOQ将获取的数据与要更新/删除的数据进行比较。实际上，获取的数据与要更新/删除的记录的*原始*值进行比较。如果记录数据不是*过时*的，那么jOOQ将对数据库执行`UPDATE`/`DELETE`；否则，它将抛出一个特定的`org.jooq.exception.DataChangedException`。
- en: 'For instance, before updating the amount of a payment (`PAYMENT.INVOICE_AMOUNT`),
    jOOQ will execute the following `SELECT` (MySQL dialect):'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在更新支付金额（`PAYMENT.INVOICE_AMOUNT`）之前，jOOQ将执行以下`SELECT`（MySQL方言）：
- en: '[PRE502]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: 'It''s quite easy to enable this type of optimistic locking, but it has two
    main shortcomings: it uses exclusive locks and is applied to all CRUD `DELETE`/`UPDATE`,
    which means it''s also applied to all tables.'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 启用这种类型的乐观锁定相当简单，但它有两个主要缺点：它使用独占锁，并且应用于所有CRUD `DELETE`/`UPDATE`，这意味着它也应用于所有表。
- en: However, jOOQ also supports optimistic locking via the TIMESTAMP or VERSION
    fields. This kind of implementation is more popular, so let's look at this next.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，jOOQ还支持通过TIMESTAMP或VERSION字段进行乐观锁定。这种实现更为流行，所以让我们接下来看看这个。
- en: jOOQ optimistic locking via the TIMESTAMP/VERSION fields
  id: totrans-785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过TIMESTAMP/VERSION字段进行jOOQ乐观锁定
- en: 'We already know from the previous section that jOOQ optimistic locking is enabled
    via the `withExecuteWithOptimisticLocking(true)` flag. Next, we must add a field
    of the `TIMESTAMP` type (for TIMESTAMP optimistic locking) or the `INT` type (for
    VERSION optimistic locking) for the corresponding table(s). For instance, let''s
    add the `PAYMENT` table (for the MySQL dialect):'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从上一节中了解到，jOOQ乐观锁定是通过`withExecuteWithOptimisticLocking(true)`标志启用的。接下来，我们必须为相应的表添加一个`TIMESTAMP`类型字段（用于TIMESTAMP乐观锁定）或`INT`类型字段（用于VERSION乐观锁定）。例如，让我们添加`PAYMENT`表（针对MySQL方言）：
- en: '[PRE508]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: 'Of course, you don''t have to add both of them! Decide what type of optimistic
    locking you need and add the corresponding field. Next, we must inform the jOOQ
    Code Generator about the fact that these fields should be used for optimistic
    locking. We can do so programmatically or declaratively. For Maven applications,
    you can do this via `<recordVersionFields/>` or `recordTimestampFields/>`, respectively:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不必添加两者！决定您需要哪种类型的乐观锁，并添加相应的字段。接下来，我们必须通知 jOOQ 代码生成器这些字段应该用于乐观锁。我们可以通过编程或声明性方式做到这一点。对于
    Maven 应用程序，您可以通过 `<recordVersionFields/>` 或 `recordTimestampFields/>` 分别完成此操作：
- en: '[PRE518]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: For Gradle, please look at the bundled code.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Gradle，请查看捆绑的代码。
- en: At this point, jOOQ optimistic locking based on the TIMESTAMP/VERSION fields
    is ready to be used. Two jOOQ flags are useful for controlling (enable/disable)
    optimistic locking based on the TIMESTAMP/VERSION fields. These two flags are
    set to `true` by default (`withUpdateRecordVersion()` and `withUpdateRecordTimestamp()`),
    so you don't have to enable them explicitly. However, you can use them to disable
    this type of optimistic locking.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，基于 TIMESTAMP/VERSION 字段的 jOOQ 乐观锁已经准备好使用。有两个 jOOQ 标志对于控制（启用/禁用）基于 TIMESTAMP/VERSION
    字段的乐观锁非常有用。这两个标志默认设置为 `true`（`withUpdateRecordVersion()` 和 `withUpdateRecordTimestamp()`），因此您不需要显式启用它们。然而，您可以使用它们来禁用这种类型的乐观锁。
- en: 'Nevertheless, at this point, there is an important aspect that you should be
    aware of. So far, jOOQ uses optimistic locking based on the TIMESTAMP/VERSION
    fields for any record of the `PaymentRecord` type, that is updated/deleted, but
    it still employees `SELECT … FOR UPDATE` for the rest of the records that execute
    CRUD `UPDATE`/`DELETE` statements. If this is not what you need, then you can
    explicitly enable the jOOQ flag setting (disabled by default); that is, `withExecuteWithOptimisticLockingExcludeUnversioned()`.
    For instance, you can instruct jOOQ to use only optimistic locking based on the
    TIMESTAMP/VERSION fields, like this:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个阶段，有一个重要的方面您应该注意。到目前为止，jOOQ 使用基于 TIMESTAMP/VERSION 字段的乐观锁来处理任何 `PaymentRecord`
    类型的记录，即更新/删除的记录，但它仍然使用 `SELECT … FOR UPDATE` 来处理执行 CRUD `UPDATE`/`DELETE` 语句的其他记录。如果您不需要这样做，那么您可以显式启用
    jOOQ 标志设置（默认禁用）；即，`withExecuteWithOptimisticLockingExcludeUnversioned()`。例如，您可以指示
    jOOQ 只使用基于 TIMESTAMP/VERSION 字段的乐观锁，如下所示：
- en: '[PRE524]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: 'So, if we group all these settings into a logical diagram, we can obtain something:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将这些设置组合成一个逻辑图，我们可以得到以下内容：
- en: '![Figure 9.11 – jOOQ optimistic locking settings'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.11 – jOOQ 乐观锁设置'
- en: '](img/B16833_Figure_9.11.jpg)'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_9.11.jpg)'
- en: Figure 9.11 – jOOQ optimistic locking settings
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – jOOQ 乐观锁设置
- en: If you can choose between versions and timestamps, then go for versions. jOOQ
    has to support timestamps too if a legacy system uses them, or for quick wins,
    but with timestamps, there's always the risk of a lack of precision. For instance,
    when two updates happen in a very short time, the timestamps may still be the
    same. This can't happen with versions.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以在版本和时间戳之间选择，那么选择版本。如果遗留系统使用它们，或者为了快速胜利，jOOQ 也必须支持时间戳，但使用时间戳始终存在精度不足的风险。例如，当两个更新在非常短的时间内发生时，时间戳可能仍然是相同的。这种情况不会发生在版本上。
- en: Next, let's try to apply the jOOQ optimist locking based on the VERSION field
    to the *StoreRecords* application (the application that's available for MySQL
    that uses `store()` was created in the *Using merge() versus store()* section).
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试将基于 VERSION 字段的 jOOQ 乐观锁应用到 *StoreRecords* 应用程序（在 *Using merge() versus
    store()* 部分创建的、适用于 MySQL 且使用 `store()` 的应用程序）。
- en: Let's look at some code
  id: totrans-827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让我们看看一些代码
- en: 'I assume that you are already familiar with the *StoreRecords* code that shapes
    the following scenario: we must load and display the payments (`PAYMENT`) of a
    certain customer (for instance, `PAYMENT.CUSTOMER_NUMBER.eq(103L)`). The user
    should be able to insert new payments for this customer or update the amount of
    an existing payment via a user interface, as shown in the following screenshot:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您已经熟悉 *StoreRecords* 代码，它构成了以下场景：我们必须加载并显示特定客户的付款（例如，`PAYMENT.CUSTOMER_NUMBER.eq(103L)`）。用户应该能够通过用户界面插入该客户的新付款或更新现有付款的金额，如下面的截图所示：
- en: '![Figure 9.12 – INSERT/UPDATE PAYMENT'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.12 – 插入/更新付款'
- en: '](img/B16833_Figure_9.12.jpg)'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_9.12.jpg)'
- en: Figure 9.12 – INSERT/UPDATE PAYMENT
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 插入/更新付款
- en: 'Behind the scenes, we use `store()`:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，我们使用 `store()`：
- en: '[PRE538]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: Here, if two concurrent transactions update the same payment, then our code
    is prone to the *lost updates* anomaly, so we must engage in optimistic locking.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果有两个并发事务更新相同的付款，那么我们的代码容易受到*丢失更新*异常的影响，因此我们必须进行乐观锁定。
- en: 'So far, we''ve already added the `version` field to `PAYMENT`:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在`PAYMENT`中添加了`version`字段：
- en: '[PRE543]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: 'We have also added the settings for enabling jOOQ optimistic locking based
    on the VERSION field, so we have set the following:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了基于VERSION字段启用jOOQ乐观锁定的设置，因此我们设置了以下内容：
- en: '[PRE548]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: 'We have also set the following:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了以下内容：
- en: '[PRE551]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: 'So far, so good! From the perspective of optimistic locking, the interesting
    part starts when we call the `store()` method. If we attempt to store a new `PaymentRecord`,
    then `store()` will produce an `INSERT` statement that is not affected by optimistic
    locking. However, if this `PaymentRecord` needs to be updated, then optimistic
    locking will enrich the `WHERE` clause of the generated `UPDATE` (the same goes
    for `DELETE`) with an explicit check of the `version` number, as shown in the
    following MySQL `UPDATE`:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！从乐观锁定的角度来看，有趣的部分开始于我们调用`store()`方法时。如果我们尝试存储一个新的`PaymentRecord`，那么`store()`将生成一个不受乐观锁定影响的`INSERT`语句。然而，如果这个`PaymentRecord`需要更新，那么乐观锁定将丰富生成的`UPDATE`（同样适用于`DELETE`）的`WHERE`子句，以显式检查`version`号，如下面的MySQL
    `UPDATE`所示：
- en: '[PRE557]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: 'If the `version` number from the database doesn''t match the version number
    from the `WHERE` clause, then this record contains *stale* data (another transaction
    has modified this data). This will lead to a jOOQ `DataChangedException` that
    can be handled in our controller endpoint, as shown here:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库中的`version`号与`WHERE`子句中的版本号不匹配，那么这个记录包含*过时*的数据（另一个事务已修改此数据）。这将导致jOOQ `DataChangedException`，可以在我们的控制器端点中处理，如下所示：
- en: '[PRE568]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: 'So, if `DataChangedException` occurs, then we must add a global error in `BindingResult`
    that contains the message *Another user updated the data*. This message will be
    rendered via Thymeleaf next to a button labeled *Refresh*, as shown in the following
    screenshot:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果发生`DataChangedException`，那么我们必须在`BindingResult`中添加一个全局错误，包含消息*另一个用户更新了数据*。这个消息将通过Thymeleaf渲染在标签为*刷新*的按钮旁边，如下面的截图所示：
- en: '![Figure 9.13 – Signaling stale data to the user'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.13 – 向用户发出过时数据的信号](img/B16833_Figure_9.13.jpg)'
- en: '](img/B16833_Figure_9.13.jpg)'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16833_Figure_9.13.jpg](img/B16833_Figure_9.13.jpg)'
- en: Figure 9.13 – Signaling stale data to the user
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 向用户发出过时数据的信号
- en: 'Remember jOOQ''s `refresh()` method? This is the perfect place to highlight
    its usability because the user should see the latest state of the record. This
    is the perfect job for `refresh()`. In this case, the `reset()` method doesn''t
    help since `reset()` restores the record to its in-memory original values, which
    is a different thing. So, let''s use `refresh()` to execute a `SELECT` that will
    fetch the latest state of this `PaymentRecord`:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 记得jOOQ的`refresh()`方法吗？这是突出其可用性的完美地方，因为用户应该看到记录的最新状态。这正是`refresh()`的工作。在这种情况下，`reset()`方法没有帮助，因为`reset()`会将记录恢复到内存中的原始值，这是另一回事。所以，让我们使用`refresh()`来执行一个`SELECT`，这将获取这个`PaymentRecord`的最新状态：
- en: '[PRE588]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: 'After refreshing, the user sees the data that was updated earlier by the concurrent
    transaction and can decide whether they wish to continue with their update. To
    reproduce this scenario, follow these steps:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新后，用户会看到由并发事务提前更新的数据，并可以决定是否继续他们的更新。要重现此场景，请按照以下步骤操作：
- en: Launch two browsers (mainly, two users or HTTP sessions).
  id: totrans-906
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动两个浏览器（主要是两个用户或HTTP会话）。
- en: In both, use the *Load* link to fetch the same payment.
  id: totrans-907
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两者中，使用*Load*链接获取相同的付款。
- en: For user A, update the invoice amount and click *Finish*. This should successfully
    update the payment.
  id: totrans-908
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于用户A，更新发票金额并点击*完成*。这应该会成功更新付款。
- en: For user B, update the invoice amount and click *Finish*. Since user A already
    updated this payment, you should see the message shown in the preceding screenshot.
  id: totrans-909
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于用户B，更新发票金额并点击*完成*。由于用户A已经更新了这笔付款，你应该会看到前面截图中的消息。
- en: Click *Refresh*. Now, you should see the invoice amount that was set by user
    A.
  id: totrans-910
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击*刷新*。现在，你应该会看到用户A设置的发票金额。
- en: For user B, try to update again. This time, it will work as expected.
  id: totrans-911
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于用户B，再次尝试更新。这次，它将按预期工作。
- en: In a conclusion, if an explicit `UPDATE`/`DELETE` or `UPDATE` resulted from
    calling `store()`, jOOQ VERSION/TIMESTAMP optimistic locking will enrich the `WHERE`
    clause of the generated `UPDATE`/`DELETE` with an explicit check of the numeric
    values of timestamp fields. In the case of calling `merge()`, an explicit `INSERT`
    or `UPDATE` is rendered, depending on whether the numeric/timestamp values are
    present or not in the record.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，如果调用`store()`产生了显式的`UPDATE`/`DELETE`或`UPDATE`，jOOQ版本/时间戳乐观锁定将丰富生成的`UPDATE`/`DELETE`的`WHERE`子句，以显式检查时间戳字段的数值。在调用`merge()`的情况下，将根据记录中是否存在数值/时间戳值生成显式的`INSERT`或`UPDATE`。
- en: The complete code for this example can be found in *OLVersionStoreRecords*.
    The alternative, which is for using a TIMESTAMP field, can be found in *OLTimestampStoreRecords*.
    Finally, the `SELECT … FOR UPDATE` solution can be found in *OLPLStoreRecords*.
    All of them are available for MySQL.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的完整代码可以在*OLVersionStoreRecords*中找到。使用TIMESTAMP字段的替代方案可以在*OLTimestampStoreRecords*中找到。最后，`SELECT
    … FOR UPDATE`解决方案可以在*OLPLStoreRecords*中找到。所有这些都在MySQL中可用。
- en: Retrying a failed transaction
  id: totrans-914
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重试失败的事务
- en: Let's consider that our scenario gets updated. If a transaction didn't update
    a payment with an invoice amount larger than the current amount, then this transaction
    should be retried without user interaction (so, in this case, we don't care about
    the lost updates). Otherwise, the user should see the current amount and perform
    the update from the interface (there will be no *Refresh* button since the refresh
    should be done automatically).
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们的场景被更新。如果一个事务没有使用比当前金额更大的发票金额更新付款，那么这个事务应该在没有用户交互的情况下重试（因此，在这种情况下，我们不在乎丢失的更新）。否则，用户应该看到当前金额并从界面执行更新（由于刷新应该自动完成，所以将没有*刷新*按钮）。
- en: 'But how can we retry a failed transaction from the application? In Spring Boot,
    this is equivalent to executing the failed `@Transactional storePayment(PaymentRecord
    pr)` method again, which can be done via Spring Retry. Once you''ve added Spring
    Retry (see the bundled code), you must adjust the `storePayment(PaymentRecord
    pr)` method, as shown here:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何在应用程序中重试一个失败的事务？在Spring Boot中，这相当于再次执行失败的`@Transactional storePayment(PaymentRecord
    pr)`方法，这可以通过Spring Retry来完成。一旦你添加了Spring Retry（请参阅捆绑的代码），你必须调整`storePayment(PaymentRecord
    pr)`方法，如下所示：
- en: '[PRE599]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: So, this time, we catch `DataChangedException` and analyze the *current* value
    of the invoice amount against the refreshed record (the latest state from the
    database). If the current amount is larger than the fetched amount, then we set
    it in place of the fetched amount and throw the caught `DataChangedException`.
    This will trigger the Spring Retry mechanism, will should retry this transaction.
    Otherwise, we must throw a custom `OptimisticLockingRetryFailed` exception, which
    will lead to an explicit message for the user. You can practice this example in
    *OLRetryVersionStoreRecords* (available for MySQL).
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这次，我们捕获`DataChangedException`并分析发票金额的*当前*值与刷新的记录（数据库的最新状态）进行比较。如果当前金额大于获取的金额，则我们将它设置为获取金额的替代，并抛出捕获的`DataChangedException`。这将触发Spring
    Retry机制，应该重试这个事务。否则，我们必须抛出一个自定义的`OptimisticLockingRetryFailed`异常，这将导致用户看到显式消息。你可以在*OLRetryVersionStoreRecords*（适用于MySQL）中练习这个示例。
- en: Pessimistic locking overview
  id: totrans-939
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 悲观锁定概述
- en: Pessimistic locking is about locking rows (or cells) via exclusive/shared locks
    until the transaction that acquired these locks finishes its tasks. Depending
    on the lock's strength, other transactions may partially interact with these rows/cells
    or they will have to abort or wait for the resource to become available (lock-free).
    From the well-known `SELECT … FOR UPDATE` (exclusive read/write lock for rows
    (record lock)) and `SELECT … FOR UPDATE OF` (exclusive read/write locks for cells
    specific to Oracle) to `SELECT … FOR UPDATE NOWAIT` and `SELECT … FOR UPDATE WAIT
    n` (also specific to Oracle), to the more relaxed `SELECT ... FOR UPDATE SKIP
    LOCKED`, `SELECT … FOR SHARE`, and PostgreSQL-specific `SELECT … FOR NO KEY UPDATE` and `SELECT
    … FOR KEY SHARE`, jOOQ supports them all.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 悲观锁定是通过排他性/共享锁锁定行（或单元格）直到获取这些锁的事务完成其任务。根据锁的强度，其他事务可能只能部分地与这些行/单元格交互，或者它们将不得不中止或等待资源可用（无锁）。从众所周知的`SELECT
    … FOR UPDATE`（针对行的排他性读写锁（记录锁））和`SELECT … FOR UPDATE OF`（针对Oracle特定单元格的排他性读写锁）到`SELECT
    … FOR UPDATE NOWAIT`和`SELECT … FOR UPDATE WAIT n`（也特定于Oracle），再到更宽松的`SELECT ...
    FOR UPDATE SKIP LOCKED`、`SELECT … FOR SHARE`以及PostgreSQL特定的`SELECT … FOR NO KEY
    UPDATE`和`SELECT … FOR KEY SHARE`，jOOQ都支持它们。
- en: jOOQ pessimistic locking
  id: totrans-941
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jOOQ悲观锁定
- en: 'As we mentioned in the *Pessimistic locking overview* section, jOOQ supports
    a significant number of locks of the `SELECT … FOR FOO` type. For instance, we
    can explicitly call `SELECT … FOR UPDATE` via `forUpdate()`:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*悲观锁定概述*部分中提到的，jOOQ支持大量的`SELECT … FOR FOO`类型的锁。例如，我们可以通过`forUpdate()`显式调用`SELECT
    … FOR UPDATE`：
- en: '[PRE620]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: 'If transaction A executes this statement, then it locks the corresponding rows.
    The other transaction, transaction B, must wait for transaction A to release this
    exclusive lock before performing its tasks on the same resource. Check out this
    scenario in the *ForUpdate* application (available for MySQL) – pay attention
    that this application results in an exception: `MySQLTransactionRollbackException`:
    *Lock wait timeout exceeded; try restarting transaction*. Also, check out *ForUpdateForeignKey*
    (available for PostgreSQL) – this example highlights the effect of `FOR UPDATE`
    on foreign keys that''s caused by the fact this lock affects the referenced rows
    from other tables as well, not just the rows from the current table.'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事务A执行此语句，则锁定相应的行。其他事务，事务B，必须在事务A释放此排他锁之前，才能在相同资源上执行其任务。查看*ForUpdate*应用程序中的此场景（适用于MySQL）-
    注意，此应用程序会导致异常：`MySQLTransactionRollbackException`：*锁等待超时；尝试重新启动事务*。另外，查看*ForUpdateForeignKey*（适用于PostgreSQL）-
    此示例突出了`FOR UPDATE`对外键的影响，这是由于此锁不仅影响当前表的行，还影响其他表的引用行。
- en: So, remaining in the same context, `SELECT … FOR UPDATE` locks all the selected
    rows across all the involved tables (listed in the `FROM` clause, joined, and
    so on). If table X and table Y are involved in such a case, then `SELECT … FOR
    UPDATE` locks the rows of both tables, even if transaction A affects only rows
    from table X. On the other hand, transaction B needs to acquire locks from table
    Y, but it cannot do so until transaction A releases the locks on tables X and
    Y.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继续在同一上下文中，`SELECT … FOR UPDATE`锁定所有涉及表（在`FROM`子句中列出，连接等）中选定的行。如果表X和表Y在这种情况下涉及，则`SELECT
    … FOR UPDATE`锁定两个表的行，即使事务A仅影响表X的行。另一方面，事务B需要从表Y获取锁，但它不能这样做，直到事务A释放对表X和Y的锁。
- en: 'For such scenarios, Oracle has `SELECT … FOR UPDATE OF`, which allows us to
    nominate the columns that should be locked. In this case, Oracle only acquires
    locks on the rows of the table(s) that have the column name listed in `FOR UPDATE
    OF`. For instance, the following statements only lock rows from `PRODUCTLINE`,
    even if the `PRODUCT` table is also involved:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类场景，Oracle有`SELECT … FOR UPDATE OF`，这允许我们指定应该被锁定的列。在这种情况下，Oracle仅锁定具有列名列在`FOR
    UPDATE OF`中的表（的）行。例如，以下语句仅锁定`PRODUCTLINE`的行，即使`PRODUCT`表也涉及在内：
- en: '[PRE624]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: 'Since the `PRODUCT` table isn''t locked, another statement can obtain locks
    on its rows:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PRODUCT`表未锁定，另一个语句可以锁定其行：
- en: '[PRE631]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: If we remove `.of(PRODUCT.PRODUCT_NAME)`, then this statement will attempt to
    lock rows from `PRODUCTLINE` as well, so it will have to wait for the lock to
    release on that table. You can check out this example by going to the *ForUpdateOf*
    application (available for Oracle).
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除`.of(PRODUCT.PRODUCT_NAME)`，则此语句将尝试锁定`PRODUCTLINE`的行，因此它将不得不等待该表的锁释放。您可以通过访问*ForUpdateOf*应用程序（适用于Oracle）来查看此示例。
- en: 'If a transaction were to acquire a lock or fail immediately, then we should
    use `SELECT … FOR UPDATE NOWAIT`:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事务要获取锁或立即失败，则应使用`SELECT … FOR UPDATE NOWAIT`：
- en: '[PRE638]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: 'However, if the transaction needs to wait for a fixed amount of time, then
    we must rely on the `SELECT … FOR UPDATE WAIT n` lock (Oracle), where `n` is the
    time to wait, given in seconds:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果事务需要等待固定的时间，那么我们必须依赖于`SELECT … FOR UPDATE WAIT n`锁（Oracle），其中`n`是等待时间，以秒为单位：
- en: '[PRE642]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '[PRE645]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: 'You can check out an example in *ForUpdateWait* (available for Oracle). As
    you''ll see, transaction A acquires a lock immediately, while transaction B waits
    for a certain amount of time before acquiring a lock on the same resource. If
    this time expires before transaction A releases the lock, then you''ll get an
    error stating *ORA-30006: resource busy; acquire with WAIT timeout expired*.'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*ForUpdateWait*（适用于Oracle）中查看一个示例。您将看到，事务A立即获取锁，而事务B在获取相同资源的锁之前等待一段时间。如果在事务A释放锁之前此时间已过期，则您将收到一个错误，表明*ORA-30006：资源忙；超时等待获取*。
- en: 'Let''s consider the following scenario: to provide a high-quality description
    of products, we have reviewers that analyze each product and write a proper description.
    Since this is a concurrent process on the `PRODUCT` table, the challenge consists
    of coordinating the reviewers so that they don''t review the same product at the
    same time. To pick a product for review, the reviewer should skip the products
    that have already been reviewed (`PRODUCT.PRODUCT_DESCRIPTION.eq("PENDING")`)
    and the products that are currently in review. This is what we call a concurrent
    table-based queue (also known as job queues or batch queues).'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下场景：为了提供高质量的产品描述，我们有审查员分析每个产品并编写适当的描述。由于这是`PRODUCT`表上的并发过程，挑战在于协调审查员，以确保他们不会同时审查相同的产品。为了选择一个产品进行审查，审查员应该跳过已经审查过的产品（`PRODUCT.PRODUCT_DESCRIPTION.eq("PENDING")`）和当前正在审查的产品。这就是我们所说的基于并发表的队列（也称为作业队列或批量队列）。
- en: 'This is a job for `SKIP LOCKED`. This SQL option is available in many databases
    (Oracle, MySQL 8, PostgreSQL 9.5, and so on) and it instructs the database to
    skip the locked rows and to lock the rows that have not been locked previously:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`SKIP LOCKED`的工作。这个SQL选项在许多数据库中可用（Oracle、MySQL 8、PostgreSQL 9.5等），并指示数据库跳过已锁定的行，并锁定之前未锁定的行：
- en: '[PRE646]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: '[PRE648]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: If transaction A executes this statement, then it may lock the `PENDING` products
    with IDs *1*, *2*, and *3*. While transaction A holds this lock, transaction B
    executes the same statement and will lock the `PENDING` products with IDs *4*,
    *5*, and *6*. You can see this scenario in *ForUpdateSkipLocked* (available for
    MySQL).
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事务A执行这个语句，那么它可能会锁定ID为*1*、*2*和*3*的`PENDING`产品。当事务A持有这个锁时，事务B执行相同的语句并将锁定ID为*4*、*5*和*6*的`PENDING`产品。你可以在*ForUpdateSkipLocked*（适用于MySQL）中看到这个场景。
- en: 'A weaker form of `SELECT … FOR UPDATE` is the `SELECT … FOR SHARE` query. This
    ensures referential integrity when inserting child records for a parent. For instance,
    transaction A executes the following:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT … FOR UPDATE`的一种较弱的形式是`SELECT … FOR SHARE`查询。这确保在插入父记录的子记录时保持引用完整性。例如，事务A执行以下操作：'
- en: '[PRE652]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: 'However, transaction B cannot `UPDATE` if transaction A holds the `SHARE` lock:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果事务A持有`SHARE`锁，事务B不能`UPDATE`：
- en: '[PRE660]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: 'Also, transaction C cannot `DELETE`:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，事务C不能`DELETE`：
- en: '[PRE664]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: '[PRE665]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: '[PRE666]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: You can check out this example in *ForShare* (available for PostgreSQL).
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*ForShare*（适用于PostgreSQL）中查看这个示例。
- en: 'Starting with version 9.3, PostgreSQL supports two more locking clauses: `SELECT
    … FOR NO KEY UPDATE` and `SELECT … FOR KEY SHARE`. The former acts similarly to
    the `FOR UPDATE` locking clause but it does not block `SELECT … FOR KEY SHARE`.
    For instance, transaction A uses `SELECT … FOR NO KEY UPDATE`:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本9.3开始，PostgreSQL支持两个额外的锁定子句：`SELECT … FOR NO KEY UPDATE`和`SELECT … FOR KEY
    SHARE`。前者与`FOR UPDATE`锁定子句的作用类似，但它不会阻塞`SELECT … FOR KEY SHARE`。例如，事务A使用`SELECT
    … FOR NO KEY UPDATE`：
- en: '[PRE667]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[PRE668]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: '[PRE672]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '[PRE673]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[PRE674]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: 'Even if transaction A holds a lock on this resource, transaction B can acquire
    a `SELECT … FOR KEY SHARE`:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 即使事务A持有这个资源的锁，事务B也可以获取`SELECT … FOR KEY SHARE`：
- en: '[PRE675]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '[PRE676]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: '[PRE677]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: 'However, transaction C cannot acquire a `SELECT … FOR SHARE` on this resource
    if transaction A doesn''t release its lock:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果事务A没有释放其锁，事务C不能在这个资源上获取`SELECT … FOR SHARE`：
- en: '[PRE679]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '[PRE680]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: '[PRE681]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: You can check out this example in *ForNoKeyUpdate* (available for PostgreSQL).
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*ForNoKeyUpdate*（适用于PostgreSQL）中查看这个示例。
- en: 'Finally, `SELECT … FOR KEY SHARE` is the weakest lock. For instance, transaction
    A acquires the following type of lock:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`SELECT … FOR KEY SHARE`是最弱的锁。例如，事务A获取以下类型的锁：
- en: '[PRE683]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '[PRE685]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: '[PRE686]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '[PRE687]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '[PRE689]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: '[PRE690]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: 'While transaction A holds this lock, transaction B can perform updates if it
    doesn''t attempt to update `SALE_ID`:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 当事务A持有这个锁时，如果事务B不尝试更新`SALE_ID`，它可以执行更新操作：
- en: '[PRE691]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: '[PRE692]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: '[PRE693]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: '[PRE694]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: 'Transaction B will have to wait for transaction A to release the lock since
    it attempts to update `SALE_ID`:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 事务B将不得不等待事务A释放锁，因为它试图更新`SALE_ID`：
- en: '[PRE695]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '[PRE696]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '[PRE697]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: '[PRE698]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: 'Finally, transaction C cannot `DELETE` if transaction A holds the `KEY SHARE`
    lock:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果事务A持有`KEY SHARE`锁，事务C不能`DELETE`：
- en: '[PRE699]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: '[PRE700]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '[PRE701]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: You can see this example in *ForNoKeyUpdate* (available for PostgreSQL).
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*ForNoKeyUpdate*（适用于PostgreSQL）中查看这个示例。
- en: Deadlocks
  id: totrans-1049
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁
- en: 'Deadlocks are not specific to databases – they can occur in any scenario involving
    a concurrency environment (concurrency control) and they mainly define a situation
    when two processes cannot advance because they are waiting for each other to finish
    (release the lock). In the case of a database, a classical deadlock can be represented
    like so:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁不仅限于数据库 – 它可以发生在任何涉及并发环境（并发控制）的场景中，并且它们主要定义了两个进程无法前进的情况，因为它们正在等待对方完成（释放锁）。在数据库的情况下，一个经典的死锁可以表示如下：
- en: '![Figure 9.14 – A classical case of a deadlock'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – 死锁的经典案例'
- en: '](img/B16833_Figure_9.14.jpg)'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_9.14.jpg)'
- en: Figure 9.14 – A classical case of a deadlock
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 死锁的经典案例
- en: Here, we have two transactions that don't use explicit locks (the database itself
    relies on locks since it detects whether a transaction has attempted to modify
    data). Transaction A has acquired a lock on the `SALE` resource, and it doesn't
    release it until it manages to acquire another lock on the `ORDER` resource, which
    is currently locked by transaction B. At the same time, transaction B holds a
    lock on the `ORDER` resource, and it doesn't release it until it manages to acquire
    a lock on the `SALE` resource, which is currently locked by transaction A. You
    can see this scenario exemplified in *Deadlock* (available for MySQL).
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个不使用显式锁的事务（数据库本身依赖于锁，因为它会检测事务是否尝试修改数据）。事务A已经获取了`SALE`资源的锁，并且它不会释放它，直到它设法获取`ORDER`资源的另一个锁，而该锁目前被事务B锁定。同时，事务B持有`ORDER`资源的锁，并且它不会释放它，直到它设法获取被事务A锁定的`SALE`资源的锁。你可以在这个场景中看到*Deadlock*（适用于MySQL）的示例。
- en: 'However, using explicit locks doesn''t mean that deadlocks cannot happen anymore.
    For instance, in *DeadlockShare* (available for MySQL), you can see explicit usage
    of `SELECT … FOR SHARE` that causes a deadlock. It is very important to understand
    what each type of lock does and what other locks are permitted (if any) while
    a certain lock is present. The following table covers the common locks:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用显式锁并不意味着死锁就不会发生。例如，在*DeadlockShare*（适用于MySQL）中，你可以看到显式使用`SELECT … FOR SHARE`导致死锁的情况。理解每种类型的锁做什么以及当存在某种锁时允许的其他锁（如果有的话）非常重要。以下表格涵盖了常见的锁：
- en: '![Figure 9.15 – Lock acquisition permissions'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15 – 锁定获取权限'
- en: '](img/B16833_Figure_9.15.jpg)'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_9.15.jpg)'
- en: Figure 9.15 – Lock acquisition permissions
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 锁定获取权限
- en: Databases automatically scan transactions to discover deadlocks (or the so-called
    lock-wait cycles). When a deadlock occurs, the database attempts to fix it by
    aborting one of the transactions. This releases the lock and allows the other
    transaction to progress. In this context, always rely on `NOWAIT` or explicit
    short timeouts to avoid deadlocks. While the database can recover after a deadlock,
    it can only do so after the timeout (if any). So, a long timeout means keeping
    a database connection busy for a long time, and this is a performance penalty.
    Moreover, locking too much data may affect scalability.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库会自动扫描事务以发现死锁（或所谓的锁等待循环）。当发生死锁时，数据库会尝试通过终止其中一个事务来修复它。这会释放锁，并允许其他事务继续进行。在这种情况下，始终依赖`NOWAIT`或显式的短超时来避免死锁。虽然数据库可以在死锁后恢复，但它只能在超时（如果有的话）之后才能这样做。因此，长超时意味着数据库连接长时间忙碌，这会带来性能惩罚。此外，锁定过多数据可能会影响可伸缩性。
- en: Summary
  id: totrans-1060
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I'm glad that you've come this far and that we've managed to cover the three
    main topics of this chapter – CRUD, transactions, and locking. At this point,
    you should be familiar with jOOQ UpdatableRecords and how they work in the context
    of CRUD operations. Among other things, we've learnt about cool stuff such as
    the must-know `attach()`/`detach()`, the handy `original()` and `reset()`, and
    the fancy `store()` and `refresh()` operations. After that, we learned how to
    handle transactions in the context of Spring Boot and jOOQ APIs before tackling
    optimistic and pessimistic locking in jOOQ.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 我很高兴你走到了这一步，并且我们已经成功覆盖了本章的三个主要主题 – CRUD、事务和锁定。到这一点，你应该熟悉jOOQ的可更新记录以及它们在CRUD操作中的工作方式。除此之外，我们还学习了诸如必须知道的`attach()`/`detach()`、方便的`original()`和`reset()`，以及花哨的`store()`和`refresh()`操作。在那之后，我们学习了如何在Spring
    Boot和jOOQ API的上下文中处理事务，然后解决了jOOQ中的乐观锁和悲观锁。
- en: In the next chapter, we'll learn how to batching, bulking and loading files
    into the database via jOOQ. We'll also do single-thread and multi-thread batching.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过jOOQ将批处理、批量加载数据文件到数据库。我们还将进行单线程和多线程批处理。
