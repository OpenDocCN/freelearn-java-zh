- en: Creating a Taxi Application
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 创建出租车应用程序
- en: In everyday conversation, people greet each other, exchange banter, and then
    eventually end the conversation and continue on their way. Low-level TCP connections
    function in the same way over lightweight channels in RabbitMQ. Applications that
    are going to exchange messages over RabbitMQ need to establish a permanent connection
    to the message broker. When this connection is established, a channel needs to
    be created so that message-oriented interactions, such as publishing and consuming
    messages, can be performed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常对话中，人们互相问候，交换闲聊，然后最终结束对话并继续前行。在RabbitMQ的轻量级通道中，低级TCP连接以同样的方式工作。将要通过RabbitMQ交换消息的应用程序需要与消息代理建立永久连接。当建立此连接时，需要创建一个通道，以便执行面向消息的交互，例如发布和消费消息。
- en: 'After demonstrating these fundamentals, this chapter will cover how a broker
    uses **exchanges** to determine where each message should be delivered. An exchange
    is like a mailman: it delivers messages to their proper queues (mailboxes) for
    consumers to find at a later time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示了这些基础知识之后，本章将介绍经纪人如何使用**交易所**来确定每条消息应该发送到何处。交易所就像邮递员一样：它将消息递送到适当的队列（邮箱）供消费者在稍后找到。
- en: 'The basic RabbitMQ concepts are shown in the following diagram:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基本RabbitMQ概念如下所示：
- en: '![](img/18e8d28a-a508-4004-8e74-5c3d14f7e03b.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18e8d28a-a508-4004-8e74-5c3d14f7e03b.png)'
- en: 'Fig 2.1: Basic RabbitMQ concepts'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：基本RabbitMQ概念
- en: 'By the end of this chapter, you will have a solid understanding of the application
    architecture behind the **Complete Car** (**CC**) platform and how they sent the
    first message through RabbitMQ. This requires an introduction to two different
    types of exchanges: direct exchange, which delivers messages to a single queue,
    and topic exchange, which delivers messages to multiple queues based on pattern-matching
    routing keys.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深入理解**完整汽车**（**CC**）平台背后的应用程序架构以及它们如何通过RabbitMQ发送第一条消息。这需要介绍两种不同类型的交易所：直接交换，它将消息发送到单个队列，以及主题交换，它根据模式匹配路由键将消息发送到多个队列。
- en: 'To get the best start possible, following topics are covered:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳开始，以下主题将得到介绍：
- en: The application architecture behind CC
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CC背后的应用程序架构
- en: Establishing a connection to RabbitMQ
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立与RabbitMQ的连接
- en: Sending the first messages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送第一条消息
- en: Adding topic messages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加主题消息
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter02).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter02)。
- en: The application architecture behind CC
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CC背后的应用程序架构
- en: 'CC needs one application that is used by the taxi drivers and one that is used
    by the customer. The customer should be able to request a taxi via the application,
    and the taxi driver should be able to accept a request (the ride):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'CC需要一款供出租车司机使用的应用程序和一款供客户使用的应用程序。客户应能够通过应用程序请求出租车，出租车司机应能够接受请求（行程）： '
- en: '![](img/9ef350c8-bc43-4d03-b857-8019b22db9a2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ef350c8-bc43-4d03-b857-8019b22db9a2.png)'
- en: 'Fig 2.2: The customer requests a taxi via the CC application'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：客户通过CC应用程序请求出租车
- en: The customer should be able to enter information about the starting point and
    the endpoint of the trip. Active drivers receive the requests and are able to
    accept them. The customer should, in the end, be able to follow the location of
    the taxi during the trip.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 客户应能够输入关于行程起点和终点的信息。活跃的司机收到请求并能够接受它们。最终，客户应能够在整个行程中跟踪出租车的位置。
- en: 'The following diagram shows the messaging architecture that CC wants to achieve:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了CC想要实现的消息架构：
- en: '![](img/74212d1d-1a7a-4c38-9195-fa1a97e55bd1.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74212d1d-1a7a-4c38-9195-fa1a97e55bd1.png)'
- en: 'Fig 2.3: CC''s main application architecture'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：CC的主要应用程序架构
- en: 'This flow can be explained in 10 steps, as highlighted in the preceding diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，此流程可以用10个步骤来解释：
- en: A customer uses CC's mobile application to book a taxi. A request is now sent
    from the mobile application to the Application Service. This request includes
    information about the trip that the customer wants to book.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户使用CC的移动应用程序预订出租车。现在，请求从移动应用程序发送到应用程序服务。此请求包含客户想要预订的行程信息。
- en: The Application Service stores the request in a database.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序服务将请求存储在数据库中。
- en: The Application Service adds a message with information about the trip to a
    queue in RabbitMQ.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序服务将有关行程的信息消息添加到RabbitMQ的一个队列中。
- en: Connected taxi cars subscribe to the message (the booking request).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已连接的出租车订阅消息（预订请求）。
- en: A taxi responds to the customer by sending a message back to RabbitMQ.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一辆出租车通过向RabbitMQ发送消息来响应客户。
- en: The Application Service subscribes to the messages.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序服务订阅消息。
- en: Again, the Application Service stores the information in a database.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，应用程序服务将信息存储在数据库中。
- en: The Application Service forwards the information to the customer.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序服务将信息转发给客户。
- en: The taxi app starts to automatically send the taxi's geographical location at
    a given interval to RabbitMQ.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出租车应用程序开始自动以给定间隔将出租车的地理位置发送到RabbitMQ。
- en: The location of the taxi is then passed straight to the customer's mobile application,
    via WebSockets, so that they know when the taxi arrives.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将出租车的位置直接通过WebSockets传递给客户的移动应用程序，以便他们知道出租车何时到达。
- en: Let's begin by taking a closer look at *steps* *1*, *2*, *3*, and *4*, as shown
    in the preceding diagram, where a customer requests a taxi (a message is published
    to RabbitMQ) and a taxi driver receives the request (a message is consumed from
    RabbitMQ).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先仔细看看前面图中所示的步骤*1*、*2*、*3*和*4*，其中客户请求出租车（消息发布到RabbitMQ），出租车司机接收请求（从RabbitMQ消费消息）。
- en: Establishing a solid connection to RabbitMQ
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立到RabbitMQ的稳固连接
- en: 'As mentioned in Chapter 1, *A Rabbit Springs to Life*, a physical network connection
    must be established between the application servers and RabbitMQ. An **Advanced
    Message Queuing Protocol** (**AMQP**) connection is a link between the client
    and the broker that performs underlying networking tasks, including initial authentication,
    IP resolution, and networking:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如第1章“兔子跃然纸上”中所述，应用程序服务器和RabbitMQ之间必须建立物理网络连接。**高级消息队列协议**（**AMQP**）连接是客户端和代理之间的链接，执行底层网络任务，包括初始身份验证、IP解析和网络：
- en: '![](img/e959981b-8e51-459f-adb4-f27147bf43aa.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e959981b-8e51-459f-adb4-f27147bf43aa.png)'
- en: 'Fig 2.4: AMQP connection between the application and RabbitMQ'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：应用程序和RabbitMQ之间的AMQP连接
- en: Each AMQP connection maintains a set of underlying channels. A channel reuses
    a connection, forgoing the need to reauthorize and open a new TCP stream, making
    it more resource-efficient.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个AMQP连接维护一组底层通道。通道重用连接，无需重新授权和打开新的TCP流，使其更有效率。
- en: 'The following diagram illustrates a channel within a connection between an
    application and RabbitMQ:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了应用程序与RabbitMQ之间连接中的一个通道：
- en: '![](img/43ce057b-af5f-4164-95ff-ee965b9a21b7.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43ce057b-af5f-4164-95ff-ee965b9a21b7.png)'
- en: 'Fig 2.5: Channels allow you to use resources more efficiently'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：通道允许您更有效地使用资源
- en: Unlike creating channels, creating connections is a costly operation, very much
    like it is with database connections. Typically, database connections are pooled,
    where each instance of the pool is used by a single execution thread. AMQP is
    different in the sense that a single connection can be used by many threads through
    many multiplexed channels.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建通道不同，创建连接是一个成本较高的操作，非常类似于数据库连接。通常，数据库连接是池化的，其中每个池实例由单个执行线程使用。AMQP的不同之处在于，单个连接可以通过多个复用通道被许多线程使用。
- en: 'The handshake process for an AMQP connection requires at least seven TCP packets,
    and even more when using TLS. Channels can be opened and closed more frequently
    if needed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP连接的握手过程至少需要七个TCP数据包，使用TLS时甚至更多。如果需要，通道可以更频繁地打开和关闭：
- en: 'AMQP connections: 7 TCP packages'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMQP连接：7个TCP数据包
- en: 'AMQP channel: 2 TCP packages'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMQP通道：2个TCP数据包
- en: 'AMQP publish: 1 TCP package (more for larger messages)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMQP发布：1个TCP数据包（对于更大的消息可能有更多）
- en: 'AMQP close channel: 2 TCP packages'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMQP关闭通道：2个TCP数据包
- en: 'AMQP close connection: 2 TCP packages'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AMQP关闭连接：2个TCP数据包
- en: Total 14-19 packages (plus Acks)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总计14-19个数据包（包括确认包）
- en: 'The following diagram illustrates an overview of the information that''s sent
    to connections and channels:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了发送到连接和通道的信息概述：
- en: '![](img/f23a471f-89ff-43ca-a643-e779f4492462.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f23a471f-89ff-43ca-a643-e779f4492462.png)'
- en: 'Fig 2.6: The handshake process for an AMQP connection'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：AMQP连接的握手过程
- en: Establishing a single long-lived connection between the Application Service
    and RabbitMQ is a good start.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序服务和RabbitMQ之间建立一个单一的长连接是一个良好的开始。
- en: A decision must be made regarding which programming language and client library
    to use. The first few examples in this book are written in Ruby, and the client
    library Bunny ([https://github.com/ruby-amqp/bunny](https://github.com/ruby-amqp/bunny))
    is used to publish and consume messages. Ruby is an easy language to read and
    understand, even if it is unfamiliar to you.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 必须决定使用哪种编程语言和客户端库。本书的前几个示例是用Ruby编写的，并使用Bunny客户端库（[https://github.com/ruby-amqp/bunny](https://github.com/ruby-amqp/bunny)）来发布和消费消息。Ruby是一种易于阅读和理解的语言，即使你对它不熟悉。
- en: The application must be configured to use a certain connection endpoint, often
    referred to as a connection string; for example, a host and port. The connection
    string contains the information needed to be able to establish a connection. AMQP's
    assigned port number is `5672`. TLS/SSL-encrypted AMQP can be used via AMQPS;
    it's a secure version of the AMQP protocol that's assigned port `5671`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序必须配置为使用特定的连接端点，通常称为连接字符串；例如，主机和端口。连接字符串包含建立连接所需的信息。AMQP分配的端口号是`5672`。可以通过AMQPS使用TLS/SSL加密的AMQP；它是分配端口号`5671`的AMQP协议的安全版本。
- en: 'The library is the element that opens the TCP connection to the target IP address
    and port. The connection parameters have been added as a URI string to an environment
    variable to the code called `RABBITMQ_URI`. There is no URI standard for AMQP
    URIs, but this format is widely used:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该库是打开目标IP地址和端口的TCP连接的元素。连接参数已被添加为一个名为`RABBITMQ_URI`的环境变量的URI字符串。AMQP URI没有URI标准，但此格式被广泛使用：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'According to the Ruby (Bunny) documentation, connecting to RabbitMQ is simple.
    The code for this is divided into code blocks, and can be found later in this
    chapter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Ruby（Bunny）文档，连接到RabbitMQ很简单。这段代码被分为代码块，可以在本章后面找到：
- en: 'Add the username, the password, and the `vhost` that were set up in Chapter
    1, *A Rabbit Springs to Life*, and then add the string to an environment variable
    on the machine:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加在第一章“兔子跃动起来”中设置的用户名、密码和`vhost`，然后将字符串添加到机器上的环境变量中：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Require the `bunny` client library:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要引入`bunny`客户端库：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Read the connection URI from the environment variable and start a connection:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从环境变量中读取连接URI并启动连接：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This seems straightforward so far, but CC requires production-grade code that
    can gracefully handle failures. What if RabbitMQ is not running? Clearly, it is
    bad if the whole application is down. What if RabbitMQ needs to be restarted?
    CC wants its application to recover gracefully if any issues occur. In fact, CC
    wants its application to keep functioning, regardless of whether the whole messaging
    subsystem is working or not. The user experience must be smooth and easy to understand,
    as well as reliable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这似乎很简单，但CC需要能够优雅地处理失败的生成级代码。如果RabbitMQ没有运行会怎样？显然，如果整个应用程序都崩溃了，那就很糟糕。如果需要重启RabbitMQ呢？CC希望其应用程序在出现任何问题时都能优雅地恢复。实际上，CC希望其应用程序无论整个消息子系统是否工作都能继续运行。用户体验必须平滑、易于理解，并且可靠。
- en: 'In summary, the behavior CC wishes to achieve is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，CC希望实现的行为如下：
- en: If the connection to RabbitMQ is lost, it should reconnect by itself.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果与RabbitMQ的连接丢失，它应该自动重新连接。
- en: If the connection is down, sending or fetching messages should fail gracefully.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果连接断开，发送或获取消息应该优雅地失败。
- en: When the application connects to the broker, it needs to handle connection failures.
    No network is reliable all the time and misconfigurations and mistakes happen;
    the broker might be down, and so on. While not automatic, in this case, error
    detection should happen early in the process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序连接到代理时，它需要处理连接失败。没有网络总是可靠的，配置错误和错误也会发生；代理可能已经关闭，等等。虽然不是自动的，但在这个情况下，错误检测应该在过程早期发生。
- en: 'To handle TCP connection failures in Bunny, it is necessary to catch the exception:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理Bunny中的TCP连接失败，必须捕获异常：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Detecting network connection failures is nearly useless if an application cannot
    recover from them. Recovery is an important part of error handling.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序无法从网络连接失败中恢复，检测网络连接失败几乎是无用的。恢复是错误处理的重要部分。
- en: Some client libraries offer automatic connection recovery features that include
    consumer recovery. Any operation that's attempted on a closed channel will fail
    with an exception. If Bunny detects a TCP connection failure, it will try to reconnect
    every 5 seconds with no limit regarding the number of reconnection attempts. It
    is possible to disable automatic connection recovery by adding `automatic_recovery
    => false` to `Bunny.new`. This setting should only be used if you're reconnecting
    in some other way, or when testing the connection string.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些客户端库提供自动连接恢复功能，包括消费者恢复。对已关闭通道的任何尝试操作都将失败并抛出异常。如果Bunny检测到TCP连接故障，它将尝试每5秒重新连接一次，没有关于重连尝试次数的限制。可以通过在`Bunny.new`中添加`automatic_recovery
    => false`来禁用自动连接恢复。此设置仅在您以其他方式重新连接或测试连接字符串时使用。
- en: 'Messages can be sent across languages, platforms, and operating systems. You
    can choose from a number of different client libraries for different languages.
    There are lots of client libraries out there, but here are some that are recommended:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以在不同的语言、平台和操作系统之间发送。您可以从多种不同语言的客户端库中进行选择。客户端库有很多，但以下是一些推荐的：
- en: 'Python: Pika'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python：Pika
- en: 'Node.js: amqplib'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js：amqplib
- en: 'PHP: php-amqplib'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP：php-amqplib
- en: 'Java: amqp-client'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java：amqp-client
- en: 'Clojure: Langohr'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clojure：Langohr
- en: This section has shown how CC manages to establish a connection to RabbitMQ.
    We demonstrated why a long-lived connection is recommended and how to handle some
    common errors. Now, it's time to create a channel inside the connection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了CC如何建立与RabbitMQ的连接。我们演示了为什么推荐长期连接以及如何处理一些常见错误。现在，是时候在连接中创建一个通道了。
- en: Working with channels
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与通道一起工作
- en: Every AMQP protocol-related operation occurs over a channel. The channel instances
    are created by the connection instance. As described, a channel is a virtual (AMQP)
    connection inside the (TCP) connection. All operations performed by a client happen
    on a channel, queues are declared on channels, and messages are sent over channels.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个AMQP协议相关的操作都在通道上发生。通道实例是由连接实例创建的。如上所述，通道是在(TCP)连接内的虚拟(AMQP)连接。客户端执行的所有操作都在通道上，队列在通道上声明，消息通过通道发送。
- en: 'A channel never exists on its own; it''s always in the context of a connection:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通道本身并不存在；它总是在连接的上下文中：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Channels in a connection are closed once the connection is closed or when a
    channel error occurs. Client libraries allow us to observe and react to channel
    exceptions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接关闭或发生通道错误，连接中的通道就会被关闭。客户端库允许我们观察并响应通道异常。
- en: More **e****xceptions** are usually thrown at a channel level than at the connection
    level. Channel-level exceptions often indicate errors the application can recover
    from, such as, when it has no permissions, or when attempting to consume from
    a deleted queue. Any attempted operation on a closed channel will also fail with
    an exception.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在通道级别而不是在连接级别抛出更多**异常**。通道级别的异常通常指示应用程序可以从中恢复的错误，例如，当它没有权限，或者尝试从一个已删除的队列中消费时。对已关闭通道的任何尝试操作都将通过异常失败。
- en: Even though channel instances are technically thread-safe, it is strongly recommended
    to avoid having several threads that are using the same channel concurrently.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通道实例在技术上是无线程安全的，但强烈建议避免多个线程同时使用同一个通道。
- en: CC is now able to connect to a RabbitMQ broker, open a channel, and issue a
    series of commands, all in a thread-safe and exception-safe manner. It's now time
    to build on this foundation!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: CC现在能够以线程安全和异常安全的方式连接到RabbitMQ代理、打开通道并发出一系列命令。现在是时候在此基础上构建了！
- en: Building the taxi request tool
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建出租车请求工具
- en: Now, it's time to build the message flow.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候构建消息流了。
- en: First, the customer will send a simple HTTP request from the mobile application
    to the Application Service. This message will contain meta-information such as
    a timestamp, sender and receiver IDs, and the destination and requested taxi ID.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，客户将从移动应用程序向应用程序服务发送一个简单的HTTP请求。此消息将包含元信息，如时间戳、发送者和接收者ID以及目的地和请求的出租车ID。
- en: 'The message flow will look something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 消息流看起来可能如下所示：
- en: '![](img/c4c3407a-a481-4a0c-9d1c-6f0b2adb7b4c.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4c3407a-a481-4a0c-9d1c-6f0b2adb7b4c.png)'
- en: 'Fig 2.7: The frontend/backend interactions of CC''s main application'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：CC 主应用程序的前端/后端交互
- en: The Application Service stores the information in a database so that all the
    data becomes visible for the data analysis scripts in a later state.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务将信息存储在数据库中，以便所有数据在后续状态中都对数据分析脚本可见。
- en: How the data is stored in the database is not handled in these examples since
    that's not the main case being followed in this chapter. The easiest method would
    be to allow the Application Service to add the information to the database. Another
    option is to offload the Application Service and put new messages into a message
    queue between the database and the Application Service and let another service
    subscribe to those messages and handle them; that is, store them in the database.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，没有处理数据在数据库中的存储方式，因为这不是本章所关注的主题。最简单的方法是允许应用程序服务将信息添加到数据库中。另一种选择是将应用程序服务卸载，并将新消息放入数据库和应用程序服务之间的消息队列中，让另一个服务订阅这些消息并处理它们；也就是说，将它们存储在数据库中。
- en: 'The flow between the mobile device, the Application Service, and RabbitMQ is
    illustrated in the following diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了移动设备、应用程序服务和 RabbitMQ 之间的流程：
- en: '![](img/09a3d121-718e-4fbc-86de-3f58c18094fa.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09a3d121-718e-4fbc-86de-3f58c18094fa.png)'
- en: 'Fig 2.8: The flow between the mobile device, the Application Service, and RabbitMQ'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：移动设备、应用程序服务和 RabbitMQ 之间的流程
- en: Regarding our main flow, the discussion about AMQP in [Chapter 1](4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml),
    *A Rabbit Springs to Life*, detailed how messages are published to exchanges after
    being routed to queues to be consumed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们主要流程的讨论，[第 1 章](4f4722d3-131f-4c38-9ea0-4c03e8545175.xhtml)，“兔子跃然于生”，详细说明了消息在被路由到队列以供消费后是如何发布到交换的。
- en: A routing strategy determines which queue (or queues) the message will be routed
    to. The routing strategy bases its decision on a routing key (a free-form string)
    and potentially on message meta-information. Think of the routing key as an address
    that the exchange uses to decide how the message should be routed. It also needs
    to be a binding between an exchange and the queue to enable a message to flow
    from the former to the latter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 路由策略决定了消息将被路由到哪个队列（或多个队列）。路由策略基于路由键（一个自由形式的字符串）以及可能的消息元信息做出决策。将路由键想象成交换用来决定消息如何路由的地址。它还需要在交换和队列之间建立一个绑定，以使消息可以从前者流向后者。
- en: Now, let's explore the direct exchange.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨直接交换。
- en: The direct exchange
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接交换
- en: A direct exchange delivers messages to queues based on a message routing key.
    A message goes to the queue(s) whose bindings routine key matches the routing
    key of the message.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 直接交换根据消息路由键将消息传递到队列。一条消息将发送到与消息路由键匹配的绑定路由键的队列（或队列）。
- en: 'CC only has two cars, so it starts out with a simple communication system where
    one customer can request a taxi from one driver. In this case, one message needs
    to be routed to the queue acting as the inbox of that driver. Therefore, the exchange-routing
    strategy that will be used is a direct one, matching the destination queue name
    with the routing key used when the message is produced, as illustrated in the
    following diagram:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: CC 只有两辆车，因此它从一个简单的通信系统开始，其中一个客户可以请求一位司机的出租车。在这种情况下，需要将一条消息路由到该司机的收件箱队列。因此，将要使用的交换-路由策略是直接的，将目标队列名称与消息产生时使用的路由键相匹配，如下面的图示所示：
- en: '![](img/40c44f43-019d-4d0d-8880-d292a31a6a19.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40c44f43-019d-4d0d-8880-d292a31a6a19.jpg)'
- en: 'Fig 2.9: The direct exchange route messages to specific queues'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：直接交换将消息路由到特定的队列
- en: 'An example use case of direct exchange could be as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 直接交换的一个示例用例可能如下所示：
- en: The customer orders the taxi named taxi.1\. An HTTP request is sent from the
    customer's mobile application to the Application Service.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户订购名为 taxi.1 的出租车。一个 HTTP 请求从客户的移动应用程序发送到应用程序服务。
- en: The Application Service sends a message to RabbitMQ with a routing key, taxi.1\.
    The message routing key matches the name of the queue, so the message ends up
    in the taxi.1 queue.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序服务使用路由键 taxi.1 向 RabbitMQ 发送消息。消息路由键与队列名称匹配，因此消息最终进入 taxi.1 队列。
- en: 'The following diagram demonstrates how the direct exchange message routing
    would happen:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示演示了直接交换消息路由将如何发生：
- en: '![](img/71ddd244-042c-4d10-a2a0-af0476d1a2cd.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71ddd244-042c-4d10-a2a0-af0476d1a2cd.png)'
- en: 'Fig 2.10: The direct exchange routing messages to specific queues based on
    the routing key'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：根据路由键将直接交换路由消息到特定的队列
- en: This may not be the most efficient approach to scale. In fact, it will be reviewed
    as soon as CC has more cars, but it's the easiest way to get started and launch
    the application fast.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是扩展效率最高的方法。实际上，一旦CC有更多的车辆，就会对其进行审查，但这是快速开始和启动应用程序的最简单方法。
- en: 'Let''s follow the first code CC creates as the initial application and learn
    about the different concepts at the same time. The code at the beginning of the
    code block has been taken from the connection and channel section:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟随CC创建的第一个代码块作为初始应用程序，并在学习不同概念的同时进行。代码块开头的代码是从连接和通道部分取出的：
- en: Require the `bunny` client library.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要使用`bunny`客户端库。
- en: Read the `URI` connection from the environment variable and start a connection.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从环境变量中读取`URI`连接并启动连接。
- en: Start a communication session with RabbitMQ.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与RabbitMQ启动通信会话。
- en: Declare the `taxi.1` queue.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`taxi.1`队列。
- en: Declare the `taxi.1` direct exchange.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`taxi.1`直接交换。
- en: 'Bind the `taxi.1` queue to the `taxi-direct` exchange with the `taxi.1` routing
    key:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`taxi.1`队列绑定到`taxi-direct`交换，使用`taxi.1`路由键：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's a bit of an overkill and unnecessary to declare queues and exchanges for
    every message that's sent, so it's highly recommended to create a method that
    handles the setup of the application. This should be a method that creates the
    connection and declares queues, exchanges, and so on. The method in this example
    is simply called `on_start`, which declares the queue and binds an exchange to
    the queue.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个发送的消息都声明队列和交换有些过度，并且是不必要的，因此强烈建议创建一个处理应用程序设置的方法。这个方法应该创建连接并声明队列、交换等。本例中的方法简单地称为`on_start`，它声明队列并将交换绑定到队列。
- en: If the exchange doesn't exist when something is published to it, it will raise
    exceptions. If the exchange already exists, it will do nothing; otherwise, it
    will actually create one. This is why it's safe to declare queues every time the
    application starts or before publishing a message.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在交换上发布消息时交换不存在，它将引发异常。如果交换已经存在，它将不执行任何操作；否则，它实际上会创建一个。这就是为什么每次应用程序启动或发布消息之前声明队列都是安全的。
- en: Channels are killed by exceptions. In CC's case, sending to a nonexistent exchange
    would not only raise an exception, but it would also terminate the channel where
    the error occurred. Any subsequent code that tries to use the terminated channel
    will fail as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通道由异常终止。在CC的情况下，向不存在的交换发送消息不仅会引发异常，还会终止发生错误的通道。任何尝试使用已终止通道的后续代码都将失败。
- en: In addition to using the direct type, CC has configured the `durable` type,
    `autoDelete`, and the `argument` properties of the exchange. This exchange should
    not go away after a restart of RabbitMQ, nor when it's unused, which explains
    the values used in the configuration.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用直接类型外，CC还配置了交换的`durable`类型、`autoDelete`和`argument`属性。这个交换在RabbitMQ重启后不应消失，也不应在未使用时消失，这解释了配置中使用的值。
- en: An exchange declaration is only idempotent if the exchange properties are the
    same. Trying to declare an already-existing exchange with different properties
    will fail. Always use consistent properties in an exchange declaration. If you're
    making a change to the properties, delete the exchange before declaring it with
    the new properties. The same rule applies to a queue declaration.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 交换声明仅在交换属性相同时才是幂等的。尝试使用不同属性声明已存在的交换将会失败。在交换声明中始终使用一致的属性。如果你正在更改属性，请在声明新属性之前删除交换。同样的规则也适用于队列声明。
- en: After creating the exchange, the taxi queue is created and bound to it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建交换之后，创建taxi队列并将其绑定到它。
- en: 'The queue is declared with a similar approach to an exchange, but with slightly
    different properties, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的声明方法与交换类似，但属性略有不同，如下所示：
- en: '`durable`: True – the queue must stay declared, even after a broker restart.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`durable`: True – 队列必须在代理重启后仍然声明。'
- en: '`autoDelete`: False – keep the queue, even if it''s not being consumed anymore.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoDelete`: False – 保持队列，即使它不再被消费。'
- en: '`exclusive`: False – this queue should be able to be consumed by other connections
    (several application servers can be connected to RabbitMQ and accessed from different
    connections).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exclusive`: False – 此队列应该能够被其他连接消费（多个应用服务器可以连接到RabbitMQ，并通过不同的连接访问）。'
- en: '`arguments`: Null – no need to custom configure the queue.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments`: Null – 无需自定义配置队列。'
- en: The queue is bound to the exchange using its own name as the routing key so
    that the direct routing strategy can route messages to it. When this is done,
    publishing messages to the `taxi-direct` exchange will actually deliver messages
    to the taxi queue whose name matches the published routing key.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 队列使用其自己的名称作为路由键绑定到交换，以便直接路由策略可以将消息路由到它。当这样做时，向`taxi-direct`交换发布消息实际上会将消息传递到名称与发布路由键匹配的出租车队列。
- en: If no queue is bound to an exchange, or if the routing strategy can't find a
    matching destination queue, the message that was published to the exchange will
    be discarded silently. As an option, it is possible to be notified when unroutable
    messages are discarded, as shown in subsequent chapters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有队列绑定到交换，或者如果路由策略找不到匹配的目标队列，则发布到交换的消息将被静默丢弃。作为选项，当无法路由的消息被丢弃时，可以通知到，如后续章节所示。
- en: Again, when the same properties are used, these operations are idempotent, so
    the queue can safely be declared and bound to the exchange, again and again
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，当使用相同的属性时，这些操作是幂等的，因此队列可以安全地声明并绑定到交换，一次又一次。
- en: 'Although direct exchange has been covered in this chapter, AMQP 0-9-1 brokers
    provide four different types of exchanges. Depending on the binding setups you
    have between queues and parameters, these exchanges route messages differently.
    The upcoming chapters look closer at the other types of exchanges. For now, here
    is a short explanation of each:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管直接交换在本章中已经介绍过，但AMQP 0-9-1代理提供了四种不同类型的交换。根据队列和参数之间的绑定设置，这些交换以不同的方式路由消息。接下来的章节将更详细地介绍其他类型的交换。现在，这里简要说明每种交换：
- en: '**Fanout**: Messages are routed to all queues bound to the fanout exchange.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扇出**：消息将被路由到绑定到扇出交换的所有队列。'
- en: '**Topic**: Wildcards must form a match between the routing key and the binding''s
    specific routing pattern.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：通配符必须与绑定特定路由模式的路由键匹配。'
- en: '**Headers**: Use the message header attributes for routing.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：使用消息头部属性进行路由。'
- en: Now, it's time to send our first message to RabbitMQ!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候向RabbitMQ发送我们的第一条消息了！
- en: Sending the first messages
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送第一条消息
- en: The basic concept and initial setup has already been covered, so let's jump
    in and send the first messages!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基本概念和初始设置已经介绍过了，所以让我们直接发送第一条消息！
- en: 'First, let''s take a look at the `order_taxi` method, which is in charge of
    sending messages for the initial car request:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`order_taxi`方法，它负责发送初始车辆请求的消息：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`order_taxi` is going to be called every time a user wants to order a taxi.
    There is no guarantee that the addressee has ever logged into the system, so as
    far as the sender is concerned, it''s impossible to be sure the destination queue
    exists. The safest path is to declare the queue on every message sent, bearing
    in mind that this declare operation is idempotent, so it will not do anything
    if the queue already exists. This may seem strange at first, but it''s the sender''s
    responsibility to ensure the addressee''s queue exists if they want to be sure
    the message will not get lost.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`order_taxi`将在用户想要叫出租车时被调用。无法保证收件人是否曾登录过系统，因此对于发送者来说，无法确定目标队列是否存在。最安全的做法是在每条消息发送时声明队列，记住这个声明操作是幂等的，所以如果队列已经存在，它将不会做任何事情。这乍一看可能有些奇怪，但如果发送者想要确保消息不会丢失，那么确保收件人的队列存在是发送者的责任。'
- en: This is a common pattern with AMQP when there is no strong **happens-before**
    relationship between events. **Re-declaration** is the way to go. Conversely,
    the **check**-**then**-**act** pattern is discouraged; trying to check the pre-existence
    of an exchange or a queue does not guarantee success in the typical distributed
    environment where AMQP is used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件之间没有强烈的**发生之前**关系时，这是AMQP中的一种常见模式。**重新声明**是可行的方案。相反，**检查**-**然后**-**行动**模式是不被推荐的；试图检查交换或队列的存在并不能保证在AMQP通常使用的典型分布式环境中成功。
- en: 'The method for publishing a message is very simple; call `publish` toward the
    `exchange`. Then, use the queue name as the routing key (as per the **direct**
    routing) and an array of bytes that represent the actual message payload. It''s
    possible to add some optional message properties, which could include the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 发布消息的方法非常简单；向`exchange`调用`publish`。然后，使用队列名称作为路由键（按照**直接**路由），以及表示实际消息有效载荷的字节数组。还可以添加一些可选的消息属性，可能包括以下内容：
- en: '`content_type` (**string**): A message is published and consumed as a byte
    array, but nothing really says what these bytes represent. In the current situation,
    both publishers and consumers are in the same system, so it could be assumed that
    the content type is expected. That being said, always specify the content type
    so that messages are self-contained; whichever system ends up receiving or introspecting
    a message will know for sure what the byte array it contains represents.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content_type`（**字符串**）：消息以字节数组的形式发布和消费，但并没有真正说明这些字节代表什么。在当前情况下，发布者和消费者都在同一个系统中，因此可以假设内容类型是预期的。话虽如此，始终指定内容类型，以便消息是自包含的；无论哪个系统最终接收或检查消息，都将确切知道它包含的字节数组代表什么。'
- en: '`content_encoding` (**string**): A specific encoding (UTF-8) is used when serializing
    string messages into byte arrays so that they can be published. Again, in order
    for the messages to be self-explicit, provide all the necessary meta-information
    to allow them to be read.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content_encoding`（**字符串**）：在将字符串消息序列化为字节数组以便发布时使用特定的编码（UTF-8）。再次强调，为了使消息自解释，提供所有必要的元信息，以便它们可以被读取。'
- en: '`message_id` (**string**): As demonstrated later in this book, message identifiers
    are an important aspect of traceability in messaging and distributed applications.
    In the example is a random message id generated.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message_id`（**字符串**）：正如本书后面所展示的，消息标识符是消息和分布式应用程序中可追溯性的重要方面。在示例中是一个随机生成的消息ID。'
- en: '`persistent` (**boolean**): Specifies if the message should be persisted to
    disk or not.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`persistent`（**布尔值**）：指定消息是否应该持久化到磁盘。'
- en: Do not confuse exchange and queue durability with message persistence; non-persistent
    messages stored in a durable queue will be gone after a broker restart, leaving
    you with an empty queue.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆交换和队列的持久性与消息的持久性；存储在持久队列中的非持久消息在代理重启后将消失，留下一个空队列。
- en: Additionally, persistent messages in a non-persistent queue will be gone after
    a broker restart, also leaving you with an empty queue.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在非持久队列中的持久消息在代理重启后也将消失，同样会留下一个空队列。
- en: Ensure that messages are not lost by declaring a queue as **durable** and setting
    the message delivery mode to **persistent.**
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将队列声明为**持久**的并将消息投递模式设置为**持久**，确保消息不会丢失。
- en: But what would happen if sending the message fails, such as when the connection
    with RabbitMQ is broken?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果发送消息失败会怎样，比如当与RabbitMQ的连接断开时？
- en: Why would you ever use a non-persistent delivery mode? Isn't the whole point
    of a message broker such as RabbitMQ to guarantee that messages aren't lost? This
    is true, but there are circumstances where this guarantee can be relaxed. Consider
    a scenario where a publisher bombards the broker with a lot of non-critical messages.
    Using a non-persistent delivery here would mean that RabbitMQ wouldn't need to
    constantly access the disk, thus providing better performance in this case.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你会使用非持久投递模式呢？难道消息代理如RabbitMQ的整个目的不是保证消息不会丢失吗？这是真的，但在某些情况下，这种保证可以放宽。考虑一个场景，其中发布者向代理发送大量非关键消息。在这种情况下使用非持久投递意味着RabbitMQ不需要不断访问磁盘，从而在此情况下提供更好的性能。
- en: Before going any further, let's take a look at the structure of an AMQP message.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看看AMQP消息的结构。
- en: AMQP message structure
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AMQP消息结构
- en: 'The following screenshot illustrates the structure of an AMQP message and includes
    the four AMQP message properties just used, plus a few new ones. Note that this
    diagram uses the specification name of the fields and that each language implementation
    renames them slightly so that they can be valid names. For example, `content-type`
    becomes `contentType` in Java, and `content_type` in Ruby:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了AMQP消息的结构，包括刚刚使用的四个AMQP消息属性，以及一些新的属性。请注意，此图使用的是字段的规范名称，并且每种语言的实现都会稍微重命名它们，以便它们可以成为有效的名称。例如，`content-type`在Java中变为`contentType`，而在Ruby中变为`content_type`：
- en: '![](img/9b3fe337-567a-459c-97b3-1226398fa7dd.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b3fe337-567a-459c-97b3-1226398fa7dd.png)'
- en: 'Fig 2.11: Properties of an AMQP message'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：AMQP消息的属性
- en: Except for `reserved`, all these properties are free to use and, unless otherwise
    specified, are ignored by the AMQP broker. In the case of RabbitMQ, the only field
    that is supported by the broker is the `user-id` field, which is validated to
    ensure it matches the name of the broker user that established the connection.
    Notice how the `headers` property allows us to add extra key-value pairs in case
    none of the standard properties fit the requirements.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`reserved`之外，所有这些属性都可以自由使用，除非另有说明，否则AMQP代理会忽略它们。在RabbitMQ的情况下，代理支持的字段只有`user-id`字段，该字段被验证以确保它与建立连接的代理用户名称匹配。注意`headers`属性如何允许我们在没有标准属性符合要求的情况下添加额外的键值对。
- en: The next section explains how messages are consumed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释消息是如何被消费的。
- en: Consuming messages
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费消息
- en: Now, let's turn our attention to the method in charge of retrieving messages,
    which is *step 4* in the main architecture of CC, which can be found in the *The
    application architecture behind CC *section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向负责检索消息的方法，这是CC主架构中的**第4步**，可以在“CC背后的应用架构”部分找到。
- en: 'Here, the taxi application can check the queue for new messages at a regular
    interval. This is a so-called synchronous approach. This would mean holding the
    application thread in charge of dealing with the poll requests until all pending
    messages have been removed from the queue, as illustrated in the following diagram:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，出租车应用程序可以定期检查队列以获取新消息。这是一种所谓的同步方法。这意味着将处理轮询请求的应用程序线程保持，直到所有挂起的消息都从队列中移除，如图所示：
- en: '![](img/2c2137d3-3784-4d43-90d1-4ce304c5d344.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13](img/2c2137d3-3784-4d43-90d1-4ce304c5d344.png)'
- en: 'Fig 2.12: A client asking for new messages in the broker'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：客户端在代理中请求新消息
- en: A frontend regularly polling the backend for messages would soon start to take
    its toll in terms of load, meaning that the overall solution would begin to suffer
    from performance degradation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个前端定期轮询后端以获取消息，很快就会在负载方面造成影响，这意味着整体解决方案将开始遭受性能下降。
- en: 'Instead, CC wisely decides to build the solution in favor of a server-push
    approach. The idea is to server-push messages to the clients from the broker.
    Luckily, RabbitMQ offers two ways to receive messages: there''s the polling-based
    `basic.get` method and the push-based `basic.consume` method. As illustrated in
    the following diagram, messages are pushed to the consumer:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，CC明智地决定采用服务器推送的方法来构建解决方案。想法是从代理服务器将消息推送到客户端。幸运的是，RabbitMQ提供了两种接收消息的方式：基于轮询的`basic.get`方法和基于推送的`basic.consume`方法。如图所示，消息被推送到消费者：
- en: '![](img/152412b4-01d6-4e4a-ac95-e9fc397b1f52.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13](img/152412b4-01d6-4e4a-ac95-e9fc397b1f52.png)'
- en: 'Fig 2.13: Consumer subscribing messages from the broker'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：消费者从代理订阅消息
- en: The `subscribe` method adds a consumer to the queue, which then subscribes to
    receive message deliveries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe`方法将消费者添加到队列中，然后订阅接收消息传递。'
- en: Make sure that the consumer consumes messages from the queue instead of using
    basic GET actions. The `basic.get` command is comparatively expensive when it
    comes to resources.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保消费者从队列中消费消息，而不是使用基本的GET操作。当涉及到资源时，`basic.get`命令相对昂贵。
- en: With `subscribe`, the messages are delivered to the client from the broker when
    new messages are ready and the client has availability. This allows, in general,
    the smooth processing of messages. Additionally, using `subscribe` means that
    a consumer is connected as long as the channel it was declared on is available
    or until the client cancels it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`subscribe`，当有新消息准备好且客户端有可用性时，消息将从代理发送到客户端。这通常允许消息的平稳处理。此外，使用`subscribe`意味着消费者只要声明的通道可用或直到客户端取消它，就会保持连接。
- en: The message process is running smoothly and effortlessly, almost as if nothing
    is happening! That is, of course, until alerts are set in motion to acknowledge
    and/or negative acknowledge whether a part of the process has run as expected,
    or not as planned.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 消息处理正在平稳且无障碍地进行，几乎就像什么都没发生一样！当然，直到设置了警报来确认或否定确认某个过程是否按预期或未按计划运行。
- en: Acknowledgment and negative acknowledgment
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确认和否定确认
- en: RabbitMQ needs to know when a message can be considered **successful** in terms
    of being sent to the consumer as expected. The broker should then delete messages
    from the queue once the broker receives the response; otherwise, the queue would
    overflow. The client can reply to the broker by either acking (acknowledge) the
    message when it receives it or when the consumer has completely processed the
    message. In either situation, once the message has been ack:ed, it's removed from
    the queue.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ需要知道何时可以将消息视为**成功**，即在预期中将消息发送给消费者。一旦代理收到响应，代理应从队列中删除消息；否则，队列会溢出。客户端可以通过在收到消息时或消费者完全处理消息时确认消息来回复代理。在任何情况下，一旦消息被确认，它就会从队列中移除。
- en: Therefore, it's up to the consumer to acknowledge a message if and only if it
    is done with processing, or if it is certain that there is no risk of losing the
    message if it is processed asynchronously.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，消费者是否确认消息取决于它是否已经完成处理，或者它确定如果异步处理则没有丢失消息的风险。
- en: To avoid a situation where a message could be forever lost (for example, worker
    crashed, exceptions, and so on), the consuming application should not acknowledge
    a message until it is completely finished with it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免消息可能永远丢失的情况（例如，工作者崩溃、异常等），消费应用程序应在完全完成消息处理之前不确认消息。
- en: A message is rejected by an application when the application indicates to the
    broker that processing has failed or cannot be accomplished at the time. Nack,
    or negative-acknowledge, tells RabbitMQ that a message was not handled as instructed.
    Nack'ed messages, by default, are sent back to the queue for another try.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序向代理指示处理失败或无法在此时完成时，应用程序会拒绝消息。否定确认（Nack）告诉RabbitMQ消息没有被按指示处理。默认情况下，否定确认的消息会被送回队列以进行另一次尝试。
- en: Acknowledges will be covered in detail in [Chapter 3](4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml),
    *Sending Messages to Multiple Taxi Drivers*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 确认将在[第3章](4e1d39f3-47d1-4423-916c-2c2c01c75887.xhtml)中详细说明，*向多个出租车司机发送消息*。
- en: Ready? Set? Time to RUN, Rabbit!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？设定好了吗？是时候RUN，Rabbit！
- en: Running the code
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行代码
- en: Now, it's time to set up some code for the consumer. You'll be able to recognize
    most of this code from the previous section, *Sending the first messages:*
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为消费者设置一些代码了。你将能够从上一节*发送第一条消息*中识别出大部分代码。
- en: Require client libraries.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要客户端库。
- en: Read `RABBITMQ_URI` from `ENV`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ENV`中读取`RABBITMQ_URI`。
- en: Start a communication session with RabbitMQ.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与RabbitMQ启动通信会话。
- en: Declare a queue for a given taxi.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为特定出租车声明一个队列。
- en: Declare a direct exchange, `taxi-direct`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个直接交换，`taxi-direct`。
- en: Bind the queue to the exchange.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将队列绑定到交换。
- en: Subscribe to the queue.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅队列。
- en: 'What follows is the code that''s required for the initial consumer setup:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是初始消费者设置所需的代码：
- en: '[PRE8]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, two flags were added to the `subscribe` method that need to be explained.
    Let''s look at them in detail:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`subscribe`方法中添加了两个需要解释的标志。让我们详细看看它们：
- en: '`block` (Boolean, default `false`): Should the call block the calling thread?
    This option can be useful for keeping the main thread of a script alive. It is
    incompatible with automatic connection recovery and is not generally recommended.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block`（布尔值，默认`false`）：调用是否应该阻塞调用线程？此选项对于保持脚本的主线程活动可能很有用。它与自动连接恢复不兼容，并且通常不推荐使用。'
- en: '`manual_ack` (Boolean, default `false`): In CC''s case, since the risk of losing
    a message is acceptable during this phase, the system does not manually acknowledge
    messages. Instead, it informs the broker to consider them as acknowledged as soon
    as it fetches them (more on manual acknowledgment later in this book).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manual_ack`（布尔值，默认`false`）：在CC的情况下，由于在此阶段丢失消息的风险是可以接受的，系统不会手动确认消息。相反，它会在获取消息后立即通知代理将其视为已确认（关于手动确认的更多内容将在本书的后面部分介绍）。'
- en: And that's it! CC now has a working order request inbox ready to be tested.
    Next, we'll look at the management console when activated taxis are running.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！CC现在有一个可测试的工作订单收件箱。接下来，我们将查看当激活出租车运行时的管理控制台。
- en: Running the application
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'With the application running and a server connected to RabbitMQ, the following
    established connections can be seen from the management console:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行并且服务器连接到RabbitMQ时，可以从管理控制台中看到以下已建立的连接：
- en: '![](img/90a38a53-a625-4f9f-a15f-b3a8c4ff7c1a.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/90a38a53-a625-4f9f-a15f-b3a8c4ff7c1a.png)'
- en: 'Fig 2.14: The management console provides connection information'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：管理控制台提供连接信息
- en: 'Notice how the upstream and downstream network throughputs are clearly represented,
    and that the channels that get opened and closed very quickly are hard to see
    from the management console. So, let''s look at the following exchanges:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上游和下游的网络吞吐量被清楚地表示，而那些打开和关闭非常快的通道在管理控制台中很难看到。因此，让我们看看以下交换：
- en: '![](img/91175a73-136f-44c6-b528-217c23549537.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91175a73-136f-44c6-b528-217c23549537.png)'
- en: 'Fig 2.15: The taxi-direct direct exchange showing up in the management console'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：在管理控制台中出现的taxi-direct直接交换
- en: 'The user exchange and the rate of messages coming in and out are shown in the
    management console. The fact that they are being consumed as fast as they come
    in is a good sign that the current architecture is sufficient for CC''s needs
    and that messages are not piling up. But what are all these other exchanges that
    haven''t been created by code and where are they coming from? The nameless exchange
    represented as (AMQP default) and all the exchanges with names that start with
    amq. are defined by the AMQP specification and, as such, must be provided by default
    by RabbitMQ. Now, what about queues? Let''s have a look:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 用户交换和进出消息的速率显示在管理控制台中。它们被以与接收速度相同的速度消耗，这是一个好兆头，表明当前架构足以满足CC的需求，并且消息没有堆积。但是，所有这些未由代码创建的交换是什么？它们从哪里来？以（AMQP默认）表示的无名交换以及所有以amq.开头的交换名称都是由AMQP规范定义的，因此RabbitMQ必须默认提供。现在，关于队列呢？让我们看看：
- en: '![](img/9e8a32d8-41e2-46fc-a8fb-79fd4cb2acb1.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e8a32d8-41e2-46fc-a8fb-79fd4cb2acb1.png)'
- en: 'Fig 2.16: Each client-to-taxi inbox queue is visible in the management console'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：每个客户到出租车收件箱队列在管理控制台中可见
- en: As expected, there is one queue per taxi and some nifty usage statistics. Notice
    how the ack column is empty, which is no surprise, given how message acknowledgment
    works. The queue is receiving messages while letting RabbitMQ know it won't be
    acknowledging them, so there is no activity related to acknowledging messages.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，每辆出租车都有一个队列，还有一些巧妙的用法统计信息。注意，ack列是空的，这是意料之中的事，因为消息确认的工作方式就是这样。队列正在接收消息，同时通知RabbitMQ它不会进行确认，因此没有与确认消息相关的活动。
- en: With enough RAM, RabbitMQ can deal with hundreds of queues and bindings without
    a problem, so multiple queues are not an issue.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有足够的RAM，RabbitMQ可以处理数百个队列和绑定而不会出现问题，所以多个队列不是问题。
- en: Confident about its architecture and implementation, CC rolls out the client-to-taxi
    ordering subsystem. The client can send the request and the taxi can handle the
    request.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对其架构和实施充满信心，CC推出了客户到出租车订购子系统。客户可以发送请求，出租车可以处理请求。
- en: CC quickly expands the company with two new environmentally friendly cars. As
    in the previous solution, a client needs to send an order request message to a
    certain driver. Now, a new feature was requested – the capacity to send a message
    to a group of taxi cars. It should be possible for clients to select a normal
    taxi or an environmentally friendly taxi. Let's see how CC will implement this
    new feature through the power of RabbitMQ.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: CC通过两款新的环保汽车迅速扩大了公司规模。与之前的解决方案一样，客户需要向特定司机发送订单请求消息。现在，客户请求了一个新功能——向一组出租车发送消息的能力。客户应该能够选择普通出租车或环保出租车。让我们看看CC将通过RabbitMQ的力量如何实现这一新功能。
- en: Adding topic messages
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加主题消息
- en: CC's application allows its taxis to organize themselves into groups by registering
    their topics of interest. The new feature to roll out will allow clients to send
    an order request to all taxis within a particular topic. It turns out that this
    feature matches a specific exchange routing rule, not surprisingly called topic!
    This type of exchange allows us to route the message to all the queues that have
    been bound with a routing key matching the routing key of the message. So, unlike
    the direct exchange that routes a message to one queue maximum, the topic exchange
    can route it to multiple queues. Two other examples of where topic-based routing
    could be applied are to location-specific data, such as traffic warning broadcasts,
    or to trip price updates.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: CC的应用程序允许其出租车通过注册它们感兴趣的主题来组织成组。即将推出的新功能将允许客户向特定主题内的所有出租车发送订单请求。结果证明，这个功能与一个特定的交换路由规则相匹配，不出所料，被称为topic！这种类型的交换允许我们将消息路由到所有与路由键匹配消息路由键的队列。因此，与最多将消息路由到一个队列的直接交换不同，主题交换可以将消息路由到多个队列。基于主题的路由还可以应用于其他两个场景，例如特定位置的数据，如交通警告广播，或行程价格更新。
- en: A routing pattern consists of several words separated by dots. A best practice
    to follow is to structure routing keys from the most general element to the most
    specific one, such as `news.economy.usa` or `europe.sweden.stockholm`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模式由几个用点分隔的单词组成。遵循的最佳实践是从最一般元素到最具体元素来构建路由键，例如`news.economy.usa`或`europe.sweden.stockholm`。
- en: The topic exchange supports strict routing key matching and will also perform
    wildcard matching using `*` and `#` as placeholders for exactly one word and zero
    or more words, respectively.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 主题交换支持严格的路由键匹配，并且还会使用`*`和`#`作为占位符来执行通配符匹配，分别代表恰好一个单词和零个或多个单词。
- en: 'The following diagram illustrates how the topic exchange will be used in CC''s
    application. Notice how the single inbox queue remains unchanged and simply gets
    connected to the topic exchange via extra bindings, each of them reflecting the
    interest of a user:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了在CC应用中如何使用主题交换。注意，单个收件箱队列保持不变，只是通过额外的绑定连接到主题交换，每个绑定都反映了用户的一个兴趣点：
- en: '![](img/3f964e6f-517b-466a-a0eb-9965c3fb05a2.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f964e6f-517b-466a-a0eb-9965c3fb05a2.png)'
- en: 'Fig 2.17: The topic exchange sending thematic messages to eco queues'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：主题交换向生态队列发送主题消息
- en: 'Because the same inbox is used for everything, the code that''s already in
    place for fetching messages doesn''t need to be changed. In fact, this whole feature
    can be implemented with only a few additions. The first of these additions takes
    care of declaring the topic exchange in the existing `on_start` method, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用相同的收件箱处理所有事务，因此用于检索消息的现有代码无需更改。实际上，这个整个功能只需添加少量代码即可实现。这些添加中的第一个是负责在现有的`on_start`方法中声明主题交换，如下所示：
- en: '[PRE9]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There''s nothing really new or fancy here; the main difference is that this
    exchange is called `taxi-topic` and is a `topic` type of exchange. Sending a message
    is even simpler than with the client-to-taxi feature because there is no attempt
    to create the addressee''s queue. It wouldn''t make sense for the sender to iterate
    through all the users to create and bind their queues, as only users already subscribed
    to the target topic at the time of sending will get the message, which is exactly
    the expected functionality. The `order_taxi` method is listed here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里并没有什么真正新颖或复杂的地方；主要区别在于这个交换被命名为`taxi-topic`，并且是一个`topic`类型的交换。发送消息甚至比客户端到出租车功能还要简单，因为没有尝试创建收件人的队列。发送者遍历所有用户以创建和绑定他们的队列是没有意义的，因为只有那些在发送消息时已经订阅了目标主题的用户会收到消息，这正是预期的功能。`order_taxi`方法如下所示：
- en: '[PRE10]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The difference is that, now, messages are published to the `taxi-topic` exchange.
    The rest of the code that creates and publishes the message is exactly the same
    as the client-to-taxi messaging. Lastly, information needs to be added when a
    new taxi subscribes or unsubscribes from certain topics:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，现在消息是发布到`taxi-topic`交换的。创建和发布消息的其余代码与客户端到出租车消息的代码完全相同。最后，当新的出租车订阅或取消订阅某些主题时，需要添加信息：
- en: '[PRE11]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`taxi.3` is the new environmentally friendly taxi, now ready to receive orders
    from clients that want an environmentally friendly car.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`taxi.3`是新的环保出租车，现在准备好接收想要环保车型的客户的订单。'
- en: The AMQP specification does not provide any means to introspect the current
    bindings of a queue, so it is not possible to iterate them and remove the ones
    not needed anymore in order to reflect a change in a taxi's topics of interest.
    This is not a terrible concern because the application is required to maintain
    this state anyway.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP规范没有提供任何方法来检查队列的当前绑定，因此无法迭代它们并删除不再需要的绑定，以反映出租车感兴趣的主题的变化。这不是一个严重的问题，因为应用程序无论如何都需要维护这个状态。
- en: The RabbitMQ management console exposes a REST API that can be used to perform
    queue binding introspection, among many other features not covered by the AMQP
    specification. More about that in upcoming chapters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ管理控制台提供了一个REST API，可以用来执行队列绑定自省，以及其他许多AMQP规范未涵盖的功能。更多内容将在后续章节中介绍。
- en: With this new code in place, everything works as expected. No code changes are
    needed to retrieve the new client-to-taxi orders because they arrive in the same
    inbox queue as the previous messages. Topical messages are sent and received correctly
    by the taxi cars, and all this happens with a minimal change and no increase in
    the number of queues. When connected to the management console, click on the Exchanges
    tab; the only visible difference is the new exchange topic; that is, `taxi-topic`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了新的代码之后，一切按预期工作。不需要对代码进行更改来检索新的客户端到出租车订单，因为它们与之前的消息一样，到达同一个收件箱队列。主题消息被出租车正确发送和接收，所有这些都是在最小更改和队列数量没有增加的情况下发生的。当连接到管理控制台时，点击“交换”选项卡；唯一可见的差异是新交换的主题；即`taxi-topic`。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered how to connect to RabbitMQ and how to send and receive
    order messages. The car order system was successfully created, and direct and
    topic exchanges were put in motion in the context of CC's client-to-taxi and client-to-taxis
    features.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何连接到RabbitMQ以及如何发送和接收订单消息。汽车订单系统已成功创建，并在CC的客户端到出租车和客户端到多辆出租车功能背景下启动了直接和主题交换。
- en: As Complete Car grows, so does the demand for new features in the taxi application.
    What's next for CC as it meets user demand? The next chapter explains how to work
    with channels and queues to expand the features of the app.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 随着完整汽车（Complete Car）的成长，对出租车应用中新增功能的需求也在增加。当CC（Complete Car）满足用户需求时，接下来会是什么？下一章将解释如何使用通道和队列来扩展应用的功能。
