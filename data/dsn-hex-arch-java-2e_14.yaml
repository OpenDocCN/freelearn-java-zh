- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Setting Up Dockerfile and Kubernetes Objects for Cloud Deployment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Dockerfile 和 Kubernetes 对象以进行云部署
- en: We spent the previous chapters exploring some of the amazing features that Quarkus
    provides to help us create cloud-native applications. Going even further, we also
    learned how to integrate Quarkus into a hexagonal system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中探讨了 Quarkus 提供的一些令人惊叹的功能，以帮助我们创建云原生应用程序。更进一步，我们还学习了如何将 Quarkus 集成到六边形系统中。
- en: Now, we need to prepare the hexagonal system so that it can be deployed in cloud
    environments. Docker and Kubernetes are the leading technologies that dominate
    the cloud scene nowadays. If your application is prepared to run on these technologies,
    you’re safe to make it run on most cloud providers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要准备六边形系统，以便它可以在云环境中部署。Docker 和 Kubernetes 是目前主导云场景的领先技术。如果您的应用程序已准备好在这些技术上运行，那么您可以在大多数云提供商上安全地运行它。
- en: 'So, in this chapter, we’ll learn how to wrap the hexagonal system in a Docker
    image and run it on a Kubernetes cluster. For Docker images, we’ll explore two
    techniques for creating such images: one that relies on an executable `.jar` and
    another that uses a native executable. We’ll also learn how to deploy the hexagonal
    system in a local **minikube**-based Kubernetes cluster.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将学习如何将六边形系统封装在 Docker 镜像中，并在 Kubernetes 集群上运行它。对于 Docker 镜像，我们将探讨创建此类镜像的两种技术：一种依赖于可执行的
    `.jar` 文件，另一种使用原生可执行文件。我们还将学习如何在基于本地**minikube**的 Kubernetes 集群中部署六边形系统。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Preparing the Docker image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备 Docker 镜像
- en: Creating Kubernetes objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Kubernetes 对象
- en: Deploying on minikube
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 minikube 上部署
- en: By the end of this chapter, you’ll know how to make the hexagonal system run
    in a cloud-native environment based on Docker and Kubernetes. Nowadays, most modern
    applications run on the cloud. By turning the hexagonal system into a cloud-native
    one, you’ll be able to tap into the advantages that exist when you’re on the cloud.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何使六边形系统在基于 Docker 和 Kubernetes 的云原生环境中运行。如今，大多数现代应用程序都在云端运行。通过将六边形系统转变为云原生系统，您将能够利用在云端存在的优势。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are available for the Linux, macOS, and Windows operating systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中展示的代码示例，您需要在您的计算机上安装最新的**Java SE 开发工具包**和**Maven 3.8**。它们适用于 Linux、macOS
    和 Windows 操作系统。
- en: You’ll also need **Docker** and **minikube** installed on your machine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在您的机器上安装**Docker**和**minikube**。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter14).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件，链接为 [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter14)。
- en: Preparing the Docker image
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 Docker 镜像
- en: Container-based virtualization technology is not something new. Long before
    Docker, there were technologies such as OpenVZ, which applied the same fundamental
    concepts that are applied by Docker as well. Even today, we have alternatives
    such as **Linux Containers** (**LXC**), which provides a robust container-based
    solution. What sets Docker apart is how easy and intuitive it makes handling containerized
    applications. Docker takes portability to another level, simplifying and making
    containers a viable technology for larger audiences.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于容器的虚拟化技术并非新事物。在 Docker 之前，就有像 OpenVZ 这样的技术，它们应用了 Docker 所应用的基本概念。即使今天，我们也有像**Linux
    容器**（**LXC**）这样的替代方案，它提供了一个强大的基于容器的解决方案。Docker 的独特之处在于它使处理容器化应用程序变得非常简单直观。Docker
    将可移植性提升到了另一个层次，简化了容器技术，使其对更广泛的受众成为可行的技术。
- en: In the past, other container platforms were not as straightforward to use as
    Docker is today. Containers were a topic more related to system administrators
    than to software developers. Today, the scenario is different because of the simple
    yet powerful container-based solution we have with Docker. Because of its simplicity,
    Docker rapidly became popular among developers, who started to incorporate it
    into their projects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，其他容器平台不像今天的 Docker 那样易于使用。容器是一个更多与系统管理员相关的话题，而不是与软件开发者相关。今天，由于我们拥有的简单而强大的基于容器的解决方案，情况已经不同。由于其简单性，Docker
    迅速在开发者中流行起来，他们开始将其纳入他们的项目中。
- en: As I mentioned previously, Docker’s strength is in its simplicity to use and
    learn. Take, for example, how Docker abstracts the complexity required to wrap
    an application inside a container. You just need to define a Dockerfile describing
    how the application should be configured and executed inside the container. You
    can do this by using a simple set of instructions. So, Docker shields the user
    from low-level complexities that existed in previous container technologies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，Docker 的优势在于其使用和学习简单。以 Docker 如何抽象化将应用程序包裹在容器内所需的复杂性为例。你只需要定义一个 Dockerfile，描述应用程序应在容器内如何配置和执行。你可以通过使用一组简单的指令来完成此操作。因此，Docker
    保护用户免受先前容器技术中存在的底层复杂性。
- en: One of the things that makes Quarkus so special is that it’s a container-first
    framework. It’s designed to build container-based applications. So, Quarkus is
    an excellent choice if you’re targeting container-based environments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使 Quarkus 如此特别的事情之一是它是一个以容器为先的框架。它旨在构建基于容器的应用程序。因此，如果你针对基于容器的环境，Quarkus 是一个极佳的选择。
- en: With Quarkus, we can generate Docker images using `.jar` artifacts or native
    executable artifacts. We’ll explore both of these approaches next.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quarkus，我们可以使用 `.jar` 艺术品或原生可执行艺术品生成 Docker 镜像。接下来，我们将探讨这两种方法。
- en: Creating a Docker image with an uber .jar artifact
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 uber `.jar` 艺术品创建 Docker 镜像
- en: Our approach here is to wrap the uber `.jar` artifact in the Docker image so
    that the container can start and run the application by executing that `.jar`
    file. To build a Docker image, we need to create a Dockerfile with instructions
    to build such an image.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法是将 uber `.jar` 艺术品包裹在 Docker 镜像中，以便容器可以通过执行该 `.jar` 文件来启动和运行应用程序。要构建 Docker
    镜像，我们需要创建一个包含构建此类镜像指令的 Dockerfile。
- en: 'The following code shows how to create a Dockerfile for the topology and inventory
    system that uses the uber `.``jar` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何为使用 uber `.jar` 文件的拓扑和库存系统创建 Dockerfile：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This Dockerfile should be placed in the project’s root directory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Dockerfile 应放置在项目的根目录中。
- en: The first line is the base `APP_FILE_RUNNER` and `APP_HOME` environment variables
    to define the artifact’s name and path, respectively. Because Quarkus is configured
    to run on port `8080`, we have to use the `EXPOSE` property to expose this port
    externally. The `COPY` command will copy the artifact generated by Maven. `WORKDIR`
    defines the path that the commands will be executed from within the container.
    With `ENTRYPOINT` and `CMD`, we can define how the container will execute the
    application’s uber `.``jar` file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是定义艺术品的名称和路径的 `APP_FILE_RUNNER` 和 `APP_HOME` 环境变量。由于 Quarkus 配置为在端口 `8080`
    上运行，我们必须使用 `EXPOSE` 属性来外部暴露此端口。`COPY` 命令将复制 Maven 生成的艺术品。`WORKDIR` 定义了命令将在容器内执行的路径。通过
    `ENTRYPOINT` 和 `CMD`，我们可以定义容器将如何执行应用程序的 uber `.jar` 文件。
- en: 'Follow these steps to generate the Docker image and start the container:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤生成 Docker 镜像并启动容器：
- en: 'First, we need to compile and generate an uber `.``jar` file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要编译并生成一个 uber `.jar` 文件：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we can generate the Docker image:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以生成 Docker 镜像：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can start the container with the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令启动容器：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To confirm that the application is running on the Docker container, we can access
    the Swagger UI URL at `http://localhost:5555/q/swagger-ui`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要确认应用程序正在 Docker 容器上运行，我们可以访问 `http://localhost:5555/q/swagger-ui` 的 Swagger
    UI URL。
- en: Now, let’s learn how to generate a Docker image using the native executable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用原生可执行文件生成 Docker 镜像。
- en: Creating a Docker image with a native executable
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原生可执行文件创建 Docker 镜像
- en: In [*Chapter 10*](B19777_10.xhtml#_idTextAnchor213), *Adding Quarkus to a Modularized
    Hexagonal Application*, we learned that Quarkus uses **Ahead-Of-Time** (**AOT**)
    compilation techniques to optimize the bytecode and generate native code that
    offers improved performance, mainly during application startup.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 10 章*](B19777_10.xhtml#_idTextAnchor213)，“将 Quarkus 添加到模块化六边形应用程序”，我们了解到
    Quarkus 使用 **Ahead-Of-Time** (**AOT**) 编译技术来优化字节码并生成提供改进性能的原生代码，主要在应用程序启动期间。
- en: This native executable is a product of the AOT compilation that’s performed
    by Quarkus. Contrary to the uber `.jar` file, which can be distributed to run
    on different operating systems and CPU architectures, the native executable file
    is platform-dependent. But we can overcome this limitation by wrapping the native
    executable into a Docker image that can be distributed to different operating
    systems and CPU architectures.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原生可执行文件是 Quarkus 执行的 AOT 编译的结果。与可以在不同操作系统和 CPU 架构上运行的 uber `.jar` 文件不同，原生可执行文件是平台相关的。但我们可以通过将原生可执行文件包装在一个可以分发到不同操作系统和
    CPU 架构的 Docker 镜像中来克服这个限制。
- en: There are different approaches to generating a native executable. Some of them
    require us to install a **GraalVM** distribution and other software. However,
    to keep things simple, we’ll follow an uncomplicated and convenient approach where
    Quarkus generates the native executable for us inside a Docker container that
    contains GraalVM.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 生成原生可执行文件有不同的方法。其中一些需要我们安装 **GraalVM** 分发版和其他软件。然而，为了保持简单，我们将遵循一个简单且方便的方法，其中
    Quarkus 在包含 GraalVM 的 Docker 容器内为我们生成原生可执行文件。
- en: 'Follow these steps to generate a Docker image with a native executable:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤生成包含原生可执行文件的 Docker 镜像：
- en: 'In the `pom.xml` file from the project’s root directory, we need to include
    the following code before the `</``project>` tag:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录的 `pom.xml` 文件中，我们需要在 `</project>` 标签之前包含以下代码：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding configuration creates a profile that sets the `quarkus.package.type`
    property to `native`, causing Quarkus to build a native executable artifact.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述配置创建了一个配置文件，将 `quarkus.package.type` 属性设置为 `native`，导致 Quarkus 构建原生可执行文件。
- en: 'Then, we must create the `ReflectionConfiguration` class on the `bootstrap`
    hexagon:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须在 `bootstrap` 六边形上创建 `ReflectionConfiguration` 类：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One of the limitations of the native executable is that it offers partial support
    for reflection. `.json` configuration file, or we can create a class annotated
    with the `@RegisterForReflection` annotation containing the classes we want to
    register for reflection. In the preceding code, we are using the latter approach,
    which relies on the annotated class.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原生可执行文件的一个限制是它只提供部分反射支持。我们可以创建一个包含我们想要注册的类的 `.json` 配置文件，或者我们可以创建一个带有 `@RegisterForReflection`
    注解的类，包含我们想要注册的类。在上面的代码中，我们使用的是后者，它依赖于注解的类。
- en: 'To generate a native executable, we have to run the following command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成原生可执行文件，我们必须运行以下命令：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we must create a file called `Dockerfile-native` that contains instructions
    for building a Docker image with the native executable:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个名为 `Dockerfile-native` 的文件，其中包含构建包含原生可执行文件的 Docker 镜像的指令：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Instead of the JDK 17 base image, we’re using the `ubi-minimal` image from the
    official **Red Hat** registry. This image is suitable for running native executables.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不是使用 JDK 17 基础镜像，而是使用来自官方 **Red Hat** 仓库的 `ubi-minimal` 镜像。这个镜像适合运行原生可执行文件。
- en: 'Then, we must generate the Docker image with the following command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须使用以下命令生成 Docker 镜像：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Tag and upload your image to your personal Docker registry:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记并上传您的镜像到您的个人 Docker 仓库：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll use the system’s native image when deploying the application on a minikube
    cluster.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当在 minikube 集群上部署应用程序时，我们将使用系统的原生镜像。
- en: 'Now, we can start the container:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以启动容器：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With that, we have configured the Docker images for both the uber `.jar` and
    native executable artifacts. These Docker images can be deployed on a Kubernetes
    cluster. However, to do that, we need to create the required Kubernetes objects
    to allow the deployment. So, in the next section, we’ll learn how to create Kubernetes
    objects for the containerized hexagonal system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经为 uber `.jar` 和原生可执行文件配置了 Docker 镜像。这些 Docker 镜像可以在 Kubernetes 集群上部署。但是，为了做到这一点，我们需要创建所需的
    Kubernetes 对象以允许部署。因此，在下一节中，我们将学习如何为容器化的六边形系统创建 Kubernetes 对象。
- en: Creating Kubernetes objects
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Kubernetes 对象
- en: Docker Engine does not provide any fault-tolerance or high availability mechanism.
    It only offers container-based virtualization technology. So, if you plan on running
    a critical-mission application using Docker, you may either need to work out your
    solution to ensure the containers are reliable while running or delegate this
    responsibility to a container orchestrator.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎不提供任何容错或高可用性机制。它只提供基于容器的虚拟化技术。因此，如果你计划使用 Docker 运行关键任务应用程序，你可能需要制定解决方案以确保容器在运行时是可靠的，或者将这项责任委托给容器编排器。
- en: 'Container orchestrators arose as a response to the increased use of containers
    in the IT industry. Among these orchestrators, we can quote Docker Swarm, Rancher,
    and the one that dominates the industry: **Kubernetes**.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排器作为对 IT 行业容器使用增加的回应而出现。在这些编排器中，我们可以引用 Docker Swarm、Rancher 以及在行业中占据主导地位的：**Kubernetes**。
- en: Initially conceived at Google as a closed source software called Borg, it was
    open-sourced with the name Kubernetes. It’s a powerful technology that can run
    on your computer for development purposes or control a fleet of hundreds, even
    thousands, of server nodes, providing Pods for the running applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最初在 Google 内部作为名为 Borg 的闭源软件构思，后来以 Kubernetes 的名字开源。这是一种强大的技术，可以在你的计算机上用于开发目的，或者控制成百上千的服务器节点，为运行中的应用程序提供
    Pod。
- en: You may be wondering, *what is a Pod?* We’ll find out soon.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，*什么是 Pod？* 我们很快就会找到答案。
- en: It’s not our intent here to dive deep into Kubernetes' internals, but we’ll
    review some basic concepts to ensure we’re on the same page.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的目的不是深入研究 Kubernetes 的内部结构，但我们将回顾一些基本概念以确保我们处于同一页面上。
- en: Reviewing Kubernetes' main objects
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查 Kubernetes 的主要对象
- en: As we saw earlier, Kubernetes is a container orchestrator that helps us manage
    containers. To accomplish this, most – if not all – Kubernetes configuration can
    be done through `.yaml` files. In Kubernetes, we have the notion of the current
    state and the desired state. When the former meets the latter, we’re fine. Otherwise,
    we have problems.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，Kubernetes 是一个容器编排器，帮助我们管理容器。为了实现这一点，大多数——如果不是所有——Kubernetes 配置都可以通过
    `.yaml` 文件完成。在 Kubernetes 中，我们有当前状态和期望状态的概念。当前者与后者相匹配时，我们就没问题。否则，我们就有问题。
- en: 'The backbone of this currently desired state approach is the Kubernetes configuration
    mechanism based on YAML files. With these files, we can express the desired state
    of things inside the cluster. Kubernetes will do its magic to ensure that the
    current state always matches the desired state. But, you may be wondering, *the
    state of what?* The answer is the state of Kubernetes objects. Let’s look at some
    of them:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种目前期望状态方法的基础是基于 YAML 文件的 Kubernetes 配置机制。通过这些文件，我们可以表达集群内事物的期望状态。Kubernetes
    将施展其魔法以确保当前状态始终与期望状态相匹配。但是，你可能想知道，*是什么状态？* 答案是 Kubernetes 对象的状态。让我们看看其中的一些：
- en: '**Pod**: A Pod is a Kubernetes object that controls the life cycle of containers
    in a Kubernetes cluster. It’s possible to attach more than one container to the
    same Pod, although this is not a common practice.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod**: Pod 是 Kubernetes 中的一个对象，它控制 Kubernetes 集群中容器的生活周期。可以将多个容器附加到同一个 Pod
    上，尽管这不是一个常见的做法。'
- en: '`Deployment` object controls the life cycle of Pods. With a Deployment, you
    can specify how many Pods you want to provide for your application. Kubernetes
    will take care of finding the available resources in the cluster to bring up these
    Pods. If, for some reason, one of the Pods goes down, Kubernetes will try to bring
    a brand-new Pod to ensure the desired state is being met.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deployment` 对象控制 Pod 的生命周期。使用 Deployment，你可以指定为你的应用程序提供多少个 Pod。Kubernetes
    将负责在集群中找到可用资源来启动这些 Pod。如果由于某种原因，其中一个 Pod 崩溃，Kubernetes 将尝试启动一个新的 Pod 来确保达到期望的状态。'
- en: '`Service` object attached to that Pod. This `Service` object acts as a DNS
    entry point that provides basic load balancing access to the Pods. For example,
    if you have an application running on three Pods, the `Service` object will handle
    application requests for one of the three Pods sitting behind the `Service` object.
    More sophisticated load balancing features can be achieved by using service mesh
    technologies such as **Istio**.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加到该 Pod 的 `Service` 对象。这个 `Service` 对象充当 DNS 入口点，为 Pod 提供基本的负载均衡访问。例如，如果你有三个
    Pod 上运行着应用程序，`Service` 对象将处理位于 `Service` 对象后面的三个 Pod 之一的应用程序请求。通过使用如 **Istio**
    这样的服务网格技术，可以实现更复杂的负载均衡功能。
- en: '`ConfigMap` is the object that can help you with that.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigMap` 是可以帮助你的对象。'
- en: '`ConfigMap` but can be used to store sensitive information such as credentials
    or private keys. The data in a `Secret` object should be encoded with `base64`.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigMap`但可以用来存储敏感信息，如凭证或私钥。`Secret`对象中的数据应该使用`base64`编码。'
- en: Now that we’re more acquainted with some of the most important Kubernetes objects,
    let’s see how we can use them to prepare our hexagonal system to be deployed on
    a Kubernetes cluster.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了一些最重要的Kubernetes对象，让我们看看如何使用它们来准备我们的六边形系统以便在Kubernetes集群上部署。
- en: Configuring Kubernetes objects for the hexagonal system
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置六边形系统的Kubernetes对象
- en: 'Before creating the Kubernetes objects, first, let’s configure Quarkus to enable
    YAML configuration and also a health check mechanism. We’ll need both of these
    when we’re deploying the application on Kubernetes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Kubernetes对象之前，首先，让我们配置Quarkus以启用YAML配置以及健康检查机制。当我们将在Kubernetes上部署应用程序时，我们需要这两个配置：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With `quarkus-config-yaml`, we can use the `application.yaml` file for most
    of the Quarkus configurations. And to enable health checks endpoints, we can use
    `quarkus-smallrye-health`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quarkus-config-yaml`，我们可以为大多数Quarkus配置使用`application.yaml`文件。并且为了启用健康检查端点，我们可以使用`quarkus-smallrye-health`。
- en: 'Before creating the Kubernetes objects, let’s configure the `application.yaml`
    file on the `bootstrap` hexagon:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Kubernetes对象之前，让我们在`bootstrap`六边形上配置`application.yaml`文件：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This `.yaml` file allows us to use most, but not all, of the configurations
    available on Quarkus. So, it’s normal to use both `application.yaml` and `application.properties`.
    We’re using the YAML configuration because we can employ a technique called **variable
    interpolation**. Take, for example, the following configuration entry:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`.yaml`文件允许我们使用大多数，但不是所有的Quarkus上的配置。因此，同时使用`application.yaml`和`application.properties`是正常的。我们使用YAML配置是因为我们可以使用一种称为**变量插值**的技术。以以下配置条目为例：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the application starts, it will try to resolve an environment variable
    named `QUARKUS_DATASOURCE_USERNAME`. If the application can’t resolve the variable
    name, it will fall back to the default value of `root`. This technique is very
    useful for defining default configurations for local development where environment
    variables may not be set.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，它将尝试解析一个名为`QUARKUS_DATASOURCE_USERNAME`的环境变量。如果应用程序无法解析变量名，它将回退到默认值`root`。这种技术在定义本地开发中的默认配置时非常有用，因为环境变量可能没有设置。
- en: 'You may have noticed the presence of the `QUARKUS_DATASOURCE_USERNAME`, `QUARKUS_DATASOURCE_PASSWORD`,
    and `QUARKUS_DATASOURCE_REACTIVE_URL` environment variables. Kubernetes will provide
    these environment variables with the `Secret` and `ConfigMap` objects. So, let’s
    learn how to configure these and the other Kubernetes objects that are required
    to deploy the topology and inventory system (the files we will describe here are
    put inside a directory called `k8s` in the project’s root directory):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了`QUARKUS_DATASOURCE_USERNAME`、`QUARKUS_DATASOURCE_PASSWORD`和`QUARKUS_DATASOURCE_REACTIVE_URL`环境变量的存在。Kubernetes将通过`Secret`和`ConfigMap`对象提供这些环境变量。因此，让我们学习如何配置这些以及其他需要部署拓扑和库存系统（我们将在下面描述的文件被放置在项目根目录下的`k8s`目录中）所需的Kubernetes对象：
- en: 'We will start by configuring the `configmap.yaml` file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先配置`configmap.yaml`文件：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `ConfigMap` provides a `QUARKUS_DATASOURCE_REACTIVE_URL` environment variable
    with the reactive database URL that the application needs to connect to the MySQL
    database.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`ConfigMap`提供了一个名为`QUARKUS_DATASOURCE_REACTIVE_URL`的环境变量，其中包含应用程序连接到MySQL数据库所需的反应式数据库URL。
- en: 'Then, we must configure the `secret.yaml` file:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须配置`secret.yaml`文件：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding `Secret`, we define the `QUARKUS_DATASOURCE_USERNAME` and `QUARKUS_DATASOUCE_PASSWORD`
    environment variables as the credentials to connect to the system’s MySQL database.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的`Secret`中，我们定义了`QUARKUS_DATASOURCE_USERNAME`和`QUARKUS_DATASOUCE_PASSWORD`环境变量作为连接到系统MySQL数据库的凭证。
- en: 'To generate `base64`, you can execute the following command on Unix-based systems:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成`base64`，你可以在基于Unix的系统上执行以下命令：
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s configure the `deployment.yaml` file:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们配置`deployment.yaml`文件：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we describe some of the metadata entries from the `deployment.yaml` file:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们描述了`deployment.yaml`文件中的一些元数据条目：
- en: 'The `metadata.labels.app` field: A Kubernetes `Service` object can apply load
    balancing by using the `labels` property to identify the Pods that are part of
    the same `Deployment`. We’ll see how the `Service` object references that label
    shortly.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata.labels.app` 字段：Kubernetes `Service` 对象可以通过使用 `labels` 属性来识别属于同一 `Deployment`
    的 Pods 来应用负载均衡。我们将很快看到 `Service` 对象如何引用该标签。'
- en: 'The `replicas` field: This defines that this `Deployment` will provide just
    one Pod.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replicas` 字段：这定义了此 `Deployment` 将仅提供一个 Pod。'
- en: 'Still in the `deployment.yaml` file, we can start defining the entries for
    the container configuration:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `deployment.yaml` 文件中，我们可以开始定义容器配置的条目：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s look at the entries that are used for the container configuration:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看用于容器配置的条目：
- en: 'The `initContainers` field: This is used when we need to execute some tasks
    or wait for something before the main container starts. Here, we’re using an `init`
    container to wait for a MySQL database to be available. The `.yaml` file that
    loads the database is available in this book’s GitHub repository for this chapter.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initContainers` 字段：当我们需要在主容器启动之前执行一些任务或等待某些事情时使用。在这里，我们使用一个 `init` 容器来等待 MySQL
    数据库可用。加载数据库的 `.yaml` 文件可在本书的 GitHub 仓库中找到，针对本章内容。'
- en: 'The `Containers` field: This is where we set the configuration for the container
    that the Pod runs.'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Containers` 字段：这是设置 Pod 运行的容器配置的地方。'
- en: 'The `image` field: This is where we inform the image location of our application.
    It can be a public or private registry.'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image` 字段：这是我们告知应用程序镜像位置的地方。它可以是公共或私有仓库。'
- en: 'The `configMapRef` field: This is used to inject `ConfigMap` data into the
    container.'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configMapRef` 字段：此字段用于将 `ConfigMap` 数据注入到容器中。'
- en: 'The `livenessProbe` field: Kubernetes can send probe packets to check whether
    the application is alive. This is where we’ll use the health check mechanism we
    configured earlier.'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`livenessProbe` 字段：Kubernetes 可以发送探测数据包来检查应用程序是否存活。这是我们之前配置的健康检查机制将在这里使用的地方。'
- en: 'The `containerPort` field: This is where we’ll inform the port about the exposed
    Docker container.'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containerPort` 字段：这是我们告知暴露的 Docker 容器端口的地点。'
- en: 'Finally, we will configure the `service.yaml` file:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将配置 `service.yaml` 文件：
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Kubernetes provides three different Service types: `ClusterIP` for internal
    communication, and `NodePort` and `LoadBalance` for external communication. We’re
    using `NodePort` to access the application from outside the Kubernetes cluster.
    Let’s take a look at the most important fields:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Kubernetes 提供了三种不同的服务类型：`ClusterIP` 用于内部通信，以及 `NodePort` 和 `LoadBalance` 用于外部通信。我们使用
    `NodePort` 从 Kubernetes 集群外部访问应用程序。让我们看看最重要的字段：
- en: 'The `port` field: This field declares the Service port that is available internally
    for other Pods in the Kubernetes cluster'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port` 字段：此字段声明 Kubernetes 集群内部其他 Pods 可用的服务端口'
- en: 'The `targetPort` field: This field specifies the port that the container is
    exposing'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetPort` 字段：此字段指定容器暴露的端口'
- en: 'The `nodePort` field: This field specifies the external port, which allows
    external clients to access the application'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodePort` 字段：此字段指定外部端口，允许外部客户端访问应用程序'
- en: It’s not a trivial undertaking to prepare an application to be deployed on a
    Kubernetes cluster. In this section, we learned about the main objects of Kubernetes.
    Understanding these objects is essential because they are the building blocks
    for any application running on a Kubernetes cluster.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个要在 Kubernetes 集群上部署的应用程序并非易事。在本节中，我们了解了 Kubernetes 的主要对象。理解这些对象是至关重要的，因为它们是任何在
    Kubernetes 集群上运行的应用程序的基本构建块。
- en: With all the required Kubernetes objects adequately configured, we can deploy
    the hexagonal system in a Kubernetes cluster.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有必需的 Kubernetes 对象都得到充分配置后，我们可以在 Kubernetes 集群中部署菱形系统。
- en: Deploying on minikube
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 minikube 上部署
- en: '**minikube** is a Kubernetes cluster that was made for development purposes.
    It allows us to create and destroy clusters with ease. Because of its simplicity,
    we’ll use minikube to deploy our hexagonal system by following these steps (I
    recommend following the instructions at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
    to install minikube on your machine):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**minikube** 是一个专为开发目的而创建的 Kubernetes 集群。它允许我们轻松地创建和销毁集群。由于其简单性，我们将使用 minikube
    通过以下步骤来部署我们的菱形系统（我建议遵循[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)上的说明来在您的机器上安装
    minikube）：'
- en: 'Once you have installed minikube, you can start your cluster by issuing the
    following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您安装了minikube，您可以通过以下命令启动您的集群：
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The default cluster configuration consumes 2 CPUs, 2 GB of RAM, and 20 GB of
    disk space.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认集群配置消耗2个CPU、2GB的RAM和20GB的磁盘空间。
- en: 'To confirm that your cluster is alive, run the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认您的集群是活跃的，请运行以下命令：
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Nice!* Now, we can deploy the topology and inventory system to our local Kubernetes
    cluster.'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*太棒了！* 现在，我们可以将拓扑和库存系统部署到我们的本地Kubernetes集群。'
- en: 'The Deployment process is fairly simple. All we have to do is apply the Kubernetes
    YAML files we created in the previous section:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署过程相当简单。我们只需应用上一节中创建的Kubernetes YAML文件：
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we can run the following command to see whether the topology and inventory
    system is up and running:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以运行以下命令来查看拓扑和库存系统是否正在运行：
- en: '[PRE23]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To access the application, we need to use the minikube cluster IP. You can
    use the following code to retrieve that IP on a Unix-based operating system:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问应用程序，我们需要使用minikube集群IP。您可以使用以下代码在基于Unix的操作系统上检索该IP：
- en: '[PRE24]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With that IP, we can query the health check endpoint to see whether the topology
    and inventory system is alive:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该IP，我们可以查询健康检查端点以查看拓扑和库存系统是否存活：
- en: '[PRE25]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Figure 14.1 – Swagger UI from topology and inventory running on minikube](img/B19777_14_01.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 在minikube上运行的拓扑和库存的Swagger UI](img/B19777_14_01.jpg)'
- en: Figure 14.1 – Swagger UI from topology and inventory running on minikube
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 在minikube上运行的拓扑和库存的Swagger UI
- en: Note that we are using port `30080` to access the Swagger UI URL on minikube.
    `30080` is the Kubernetes node port that we configured to enable external access
    to the application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用端口`30080`来访问minikube上的Swagger UI URL。`30080`是我们配置的Kubernetes节点端口，用于启用对应用程序的外部访问。
- en: With that, we have completed the fundamental steps to turn the hexagonal system
    into a cloud-native one. Our application is ready to be deployed on a local minikube
    cluster and any cloud provider that offers Kubernetes clusters.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了将六边形系统转变为云原生系统的基本步骤。我们的应用程序已准备好部署到本地minikube集群和任何提供Kubernetes集群的云服务提供商。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by learning about the building blocks that we can use
    to create a Docker image for the hexagonal system. Then, we created two Docker
    image types. The first one was based on the uber `.jar` file, which is used to
    package and run the application, while the second one was based on native executables,
    where we could leverage the features Quarkus provides to create a native executable
    artifact.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以学习可用于创建六边形系统Docker镜像的构建块开始本章。然后，我们创建了两种Docker镜像类型。第一种是基于uber `.jar` 文件，用于打包和运行应用程序，而第二种是基于原生态可执行文件，我们可以利用Quarkus提供的功能来创建原生态可执行文件。
- en: Then, we created the Kubernetes objects that were required to deploy the hexagonal
    system in a Kubernetes cluster. Finally, we deployed the hexagonal system in a
    local minikube cluster. More than a hexagonal system, we now have a cloud-native
    hexagonal system ready to tap into the advantages provided by cloud environments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了在Kubernetes集群中部署六边形系统所需的Kubernetes对象。最后，我们在本地minikube集群中部署了六边形系统。现在，我们不仅有一个六边形系统，而且还有一个准备好利用云环境提供的优势的云原生六边形系统。
- en: In the next chapter, we will learn how hexagonal architecture relates to layered
    architecture, an architectural style used by many applications. Understanding
    the differences between these two architectures helps us assess which architecture
    may be better to employ when starting or refactoring a software project.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习六边形架构如何与分层架构相关联，这是一种许多应用程序使用的架构风格。了解这两种架构之间的差异有助于我们评估在启动或重构软件项目时，哪种架构可能更适合采用。
- en: Questions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the advantage of the native executable over the uber `.``jar` artifact?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与uber `.jar` 文件原生态可执行文件相比，其优势是什么？
- en: Which Kubernetes object can we use to store environment variables and mount
    configuration files?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个Kubernetes对象来存储环境变量和挂载配置文件？
- en: What Service type is used to make a Kubernetes Pod externally available?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用什么服务类型来使Kubernetes Pod对外可用？
- en: Answers
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The startup time is much faster than the traditional uber `.``jar` artifact.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动时间比传统的uber `.jar` 文件原生态可执行文件快得多。
- en: We can use the `ConfigMap` object.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`ConfigMap`对象。
- en: The `NodePort` Service type.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NodePort`服务类型。'
- en: 'Part 4: Hexagonal Architecture and Beyond'
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：六边形架构及其超越
- en: You will learn in this part what distinguishes hexagonal architecture from the
    widely used layered architecture. We will highlight the differences between both
    and allow you to make a more informed decision regarding which architecture to
    use when starting your next software project.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，您将了解六边形架构与广泛使用的分层架构的区别。我们将突出两者的差异，并让您在开始下一个软件项目时做出更明智的决策，选择使用哪种架构。
- en: We will then explore how SOLID principles can be combined with hexagonal architecture
    ideas to build better, change-tolerant applications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨如何将SOLID原则与六边形架构理念相结合，以构建更好、更易于变更的应用程序。
- en: Finally, to finish the book, we'll discuss some good design practices you can
    follow to create robust hexagonal systems.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完成本书，我们将讨论一些您可以遵循的良好设计实践，以创建健壮的六边形系统。
- en: 'This part has the following chapters:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 15*](B19777_15.xhtml#_idTextAnchor305), *Comparing Hexagonal Architecture
    with Layered Architecture*'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19777_15.xhtml#_idTextAnchor305), *比较六边形架构与分层架构*'
- en: '[*Chapter 16*](B19777_16.xhtml#_idTextAnchor324), *Using SOLID Principles with
    Hexagonal Architecture*'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B19777_16.xhtml#_idTextAnchor324), *使用SOLID原则与六边形架构*'
- en: '[*Chapter 17*](B19777_17.xhtml#_idTextAnchor348), *Good Design Practices for
    Your Hexagonal Application*'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B19777_17.xhtml#_idTextAnchor348), *您的六边形应用程序的良好设计实践*'
