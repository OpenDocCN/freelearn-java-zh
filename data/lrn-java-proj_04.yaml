- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Conditional Statements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: In [*Chapter 3*](B19793_03.xhtml#_idTextAnchor067), we learned about Java operators.
    We discussed two important properties of operators, namely, precedence and associativity.
    Precedence helps group shared operands. When precedence levels match, associativity
    is then used for grouping.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B19793_03.xhtml#_idTextAnchor067) 中，我们学习了 Java 运算符。我们讨论了运算符的两个重要属性，即优先级和结合性。优先级有助于分组共享的操作数。当优先级级别相同时，结合性用于分组。
- en: We discussed the unary operators – prefix and postfix increment/decrement, cast,
    and logical NOT. We also covered the binary operators – arithmetic, relational,
    logical, bitwise, and compound assignment. We learned about the behavior of the
    `+` symbol when one (or both) operands is a string. We discussed the logical AND
    (`&&`) and logical OR (`||`) and their short-circuiting property. Finally, the
    ternary operator, with its three operands, was covered.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一元运算符——前缀和后缀增量/减量、类型转换和逻辑非。我们还涵盖了二元运算符——算术、关系、逻辑、位运算和复合赋值。我们学习了当操作数（或两者）为字符串时
    `+` 符号的行为。我们讨论了逻辑与 (`&&`) 和逻辑或 (`||`) 以及它们的短路特性。最后，我们介绍了具有三个操作数的三元运算符。
- en: We also learned about Java casting. This can be done implicitly, known as **implicit
    promotion** or **widening**. The other alternative is explicit casting, known
    as **narrowing**. When narrowing, we must cast to the target type in order to
    remove the compiler error. Lastly, we discussed compile-time constants, which,
    because their values never change, enable the compiler to apply different rules.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了 Java 的类型转换。这可以隐式地进行，称为**隐式提升**或**宽化**。另一种选择是显式转换，称为**窄化**。在窄化时，我们必须将类型转换为目标类型，以消除编译器错误。最后，我们讨论了编译时常量，由于它们的值永远不会改变，因此使编译器能够应用不同的规则。
- en: Now that we know about operators, let us do something interesting with them.
    By the end of this chapter, you will be able to use Java’s operators to create
    conditional statements. Conditional statements enable us to make decisions. In
    addition, you will understand a fundamental concept in Java, namely, scope.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了运算符，让我们用它们做一些有趣的事情。到本章结束时，你将能够使用 Java 的运算符来创建条件语句。条件语句使我们能够做出决策。此外，你将理解
    Java 中的一个基本概念，即作用域。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Understanding scope
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解作用域
- en: Exploring `if` statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 `if` 语句
- en: Mastering `switch` statements and expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 `switch` 语句和表达式
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch4](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch4).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch4](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch4)。
- en: Understanding scope
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解作用域
- en: In programming, scope defines where a variable is/is not usable within a program.
    This is often referred to as the visibility of the variable. In other words, where
    in the code is the variable “visible”. Java uses **block scope**. In order to
    explain Java’s scope, we must first understand what a block is.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，作用域定义了变量在程序中的可用性。这通常被称为变量的可见性。换句话说，变量在代码中的“可见”位置在哪里。Java 使用**块作用域**。为了解释
    Java 的作用域，我们首先必须了解什么是块。
- en: What is a block?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是块？
- en: 'Curly braces delimit a block of code. In other words, a block starts with the
    opening curly brace, `{`, and ends with the closing curly brace, `}`. Note that
    the braces face each other, as in `{ }`. A variable is visible and available for
    use, from where it is declared in the block, to the closing `}` of that block.
    *Figure 4**.1* presents a code example to help explain:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号分隔代码块。换句话说，一个块从开括号 `{` 开始，以闭括号 `}` 结束。注意，大括号面对面，如 `{}`。一个变量从其声明的地方开始，到该块的闭括号
    `}`，都是可见并可用的。*图 4**.1* 展示了一个代码示例，以帮助解释：
- en: '![Figure 4.1 – Block scope in Java](img/B19793_04_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Java 中的块作用域](img/B19793_04_1.jpg)'
- en: Figure 4.1 – Block scope in Java
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Java 中的块作用域
- en: In the preceding figure, we declare an `int` variable, `x`, on line 5 and initialize
    it to `1`. The current block of code is the group of Java statements surrounded
    by `{ }`. Therefore, the `x` variable’s block of code starts on line 4, where
    the opening curly brace is, and ends on line 15, where the closing curly brace
    is. Thus, the scope of `x` is from line 5, where it is declared, to line 15 (the
    closing curly brace of the current scope). When we refer to `x` on line 6, there
    is no issue, as `x` is in scope.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们在第 5 行声明了一个 `int` 类型的变量 `x` 并将其初始化为 `1`。当前代码块是包围在 `{}` 中的 Java 语句组。因此，`x`
    变量的代码块从第 4 行开始，即开括号所在的位置，到第 15 行结束，即闭括号所在的位置。因此，`x` 的作用域从声明它的第 5 行开始，到当前作用域的闭括号第
    15 行。当我们第 6 行引用 `x` 时，没有问题，因为 `x` 在作用域内。
- en: On line 8, we start a new block/scope with `{`. Though somewhat unusual, as
    there is no code preceding `{` on line 8, lines 8 to 12 define a valid code block.
    Note that variables from the outer scope are visible within this inner (nested)
    scope. This is shown on line 11 where, in the inner scope, we refer to a variable
    declared in the outer scope, namely `x`, without any issue.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 行，我们使用 `{` 开始一个新的代码块/作用域。尽管有些不寻常，因为第 8 行之前没有代码，但第 8 行到第 12 行定义了一个有效的代码块。注意，外部作用域中的变量可以在内部（嵌套）作用域中可见。这可以在第
    11 行看到，在内部作用域中，我们引用了在外部作用域中声明的变量，即 `x`，没有任何问题。
- en: The inverse is not true, however; a variable defined in an inner scope is not
    visible in the outer scope. The `y` variable is in scope from where it is declared
    (line 9 of the inner scope) to line 12 (the closing curly brace of that scope).
    Thus, we get a compiler error on line 14 where, in the outer scope, we refer to
    the `y` variable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，情况并非总是如此；在内部作用域中定义的变量在外部作用域中不可见。`y` 变量的作用域从其声明处（内部作用域的第 9 行）到第 12 行（该作用域的闭括号）。因此，我们在第
    14 行得到编译错误，因为在外部作用域中我们引用了 `y` 变量。
- en: Indentation
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进
- en: Indentation really helps with the identification of code blocks and, consequently,
    scopes. The style we use is to start the code block at the end of the line. For
    example, in *Figure 4**.1*, note the opening curly brace `{` on line 3\. The closing
    curly brace `}` for that code block (and thus the scope) is on line 16\. From
    an indentation point of view, the closing curly brace `}` is directly under the
    `public` keyword from line 3\. More specifically, the closing curly brace is directly
    under the ‘p’ in `public`. While not necessary for compilation, it does make your
    code easier to read and maintain – the scope starts on line 3 and to find where
    the scope ends, one just scans down the program to find the matching curly brace
    `}` which lines up under `public` (from line 3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进确实有助于识别代码块和作用域。我们使用的风格是在行的末尾开始代码块。例如，在 *图 4.1* 中，注意第 3 行的开括号 `{`。该代码块的闭括号
    `}`（以及作用域）在第 16 行。从缩进的角度来看，闭括号 `}` 直接位于第 3 行的 `public` 关键字下方。更具体地说，闭括号直接位于 `public`
    中的 'p' 下方。虽然这对编译不是必需的，但它确实使代码更容易阅读和维护——作用域从第 3 行开始，要找到作用域的结束，只需扫描程序以找到匹配的闭括号 `}`，该括号与
    `public`（第 3 行）对齐。
- en: Line 4 also defines a block and thus a scope. Line 15 contains the matching
    curly brace `}` for that scope – note that the closing curly brace is lined up
    under the keyword `public` (from line 4). Thankfully, the editors are a great
    help in keeping your code properly indented.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第 4 行也定义了一个代码块和作用域。第 15 行包含该作用域的匹配闭括号 `}`——注意闭括号与关键字 `public`（第 4 行）对齐。幸运的是，编辑器在保持代码正确缩进方面非常有帮助。
- en: In summary, blocks are defined with `{ }`. As Java uses block scope, the code
    blocks define the scope of where a variable can be used. Variables are visible
    in nested scopes, but not vice versa.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，代码块是用 `{}` 定义的。由于 Java 使用代码块作用域，代码块定义了变量可以使用的范围。变量在嵌套作用域中是可见的，但反之则不然。
- en: Now that we understand scope in Java, let us examine conditional logic in Java.
    We will start with `if` statements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Java 中的作用域，让我们来检查 Java 中的条件逻辑。我们将从 `if` 语句开始。
- en: Exploring if statements
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 if 语句
- en: 'As their name suggests, conditional statements are based on the evaluation
    of a condition. The result of this condition is either `true` or `false` – in
    other words, a boolean. *Figure 4**.2* introduces the syntax of the overall `if`
    statement:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，条件语句基于条件的评估。这个条件的结果是 `true` 或 `false`——换句话说，是一个布尔值。*图 4.2* 介绍了整体 `if`
    语句的语法：
- en: '![Figure 4.2 – The if statement syntax](img/B19793_04_2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – if 语句的语法](img/B19793_04_2.jpg)'
- en: Figure 4.2 – The if statement syntax
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – if 语句的语法
- en: The square brackets `[]` in the preceding figure denote something as optional.
    For example, both the `else if` statements and the `else` statement are optional.
    The `if` statement itself is mandatory. The three ellipses, `...`, indicate that
    you can have as many `else if` statements as you like (or none at all).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个图中的方括号 `[]` 表示某项是可选的。例如，`else if` 语句和 `else` 语句都是可选的。`if` 语句本身是必需的。三个省略号
    `...` 表示你可以有任意数量的 `else if` 语句（或者一个都没有）。
- en: Now that we have the overall syntax, let us break it down into smaller pieces.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了整体语法，让我们将其分解成更小的部分。
- en: The if statement itself
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`if` 语句本身'
- en: 'As stated earlier, an `if` statement evaluates a `boolean` expression. This
    `boolean` expression is enclosed in parentheses. Curly braces that delimit a block
    of code are optional if there is only one statement after the `if` clause. However,
    it is considered good practice to always explicitly declare a block of code. *Figure
    4**.3* demonstrates both styles:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`if` 语句评估一个 `boolean` 表达式。这个 `boolean` 表达式被括号包围。如果 `if` 子句之后只有一个语句，则界定代码块的括号是可选的。然而，始终显式声明一个代码块被认为是良好的实践。*图4**.3*
    展示了两种风格：
- en: '![Figure 4.3 – Simple if statements](img/B19793_04_3.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 简单的 `if` 语句](img/B19793_04_3.jpg)'
- en: Figure 4.3 – Simple if statements
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 简单的 `if` 语句
- en: 'First, let us explain the code. Note the indentation, which is automatically
    facilitated by the code editors. This makes it easier to see the statements that
    are governed by the various `if` statements. Both lines 9 and 11 demonstrate simple
    `if` statements that control just one statement. Line 9 controls line 10\. This
    means that if line 9 is true, line 10 is executed. If line 9 is false then line
    10 is skipped. Similarly, if line 11 is true: line 12 is executed; if line 11
    is false, line 12 is skipped.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们解释一下代码。注意缩进，这是由代码编辑器自动提供的。这使得更容易看到受各种 `if` 语句控制的语句。第9行和第11行都展示了简单的 `if`
    语句，它们只控制一个语句。第9行控制第10行。这意味着如果第9行是真的，则第10行将执行。如果第9行是假的，则跳过第10行。同样，如果第11行是真的：第12行将执行；如果第11行是假的，则跳过第12行。
- en: However, if you wish to execute two or more statements when an `if` statement
    is true, a code block is required. This is demonstrated by lines 13 to 16\. If
    the boolean expression on line 13 evaluates to true, then both of the statements
    on lines 14 and 15 will be executed. This is because they are in a code block.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你希望在 `if` 语句为真时执行两个或更多语句，则需要一个代码块。这由第13行到第16行的代码块演示。如果第13行的布尔表达式评估为真，则第14行和第15行的两个语句都将执行。这是因为它们在一个代码块中。
- en: As regards the running program, with `x` initialized to `5` and `y` to `4`,
    when line 9 executes, it is true (as `5 > 4`). Therefore, line 10 executes and
    therefore the output from *Figure 4**.3* is `5 > 4`. Lines 11 and 13 are both
    executed but as they both evaluate to false, nothing else is output to the screen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于运行程序，当 `x` 初始化为 `5`，`y` 为 `4` 时，当第9行执行，它为真（因为 `5 > 4`）。因此，第10行执行，因此 *图4**.3*
    的输出是 `5 > 4`。第11行和第13行都执行了，但它们都评估为假，所以屏幕上没有其他输出。
- en: 'What if, on line 8, we initialized the variables as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在第8行，我们将变量初始化如下：
- en: '`int` `x=4, y=5;`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`int x=4, y=5;`'
- en: Now, `if(x > y)` is false and line 10 is not executed; `if(x < y)` is true and
    line 12 outputs `4 < 5` to the screen; `if(x == y)` is also false, so lines 14
    and 15 are not executed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`if(x > y)` 为假且第10行未执行；`if(x < y)` 为真且第12行将 `4 < 5` 输出到屏幕上；`if(x == y)` 也为假，因此第14行和第15行未执行。
- en: 'Lastly, let us make the variables equal by changing line 8 as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过以下方式更改第8行，使变量相等：
- en: '`int` `x=4, y=4;`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`int x=4, y=4;`'
- en: Now, `if(x > y)` is false so line 10 is not executed; `if(x < y)` is also false
    so line 12 is not executed; however, `if(x == y)` is true, so line 14 builds up
    the string `s` to be “4 == 4” and line 15 outputs it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`if(x > y)` 为假，所以第10行未执行；`if(x < y)` 也为假，所以第12行未执行；然而，`if(x == y)` 为真，所以第14行将字符串
    `s` 构建为 “4 == 4”，第15行将其输出。
- en: Note the indentation, which is automatically facilitated by the code editors.
    This makes it easier to see the statements that are governed by the various `if`
    statements.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意缩进，这是由代码编辑器自动提供的。这使得更容易看到受各种 `if` 语句控制的语句。
- en: else if statements
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`else if` 语句'
- en: 'In *Figure 4**.3*, there is no code to cater to the situations where an `if`
    expression evaluates to false. This is where the `else if` statement comes in.
    *Figure 4**.4* shows an `else if` in code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图4**.3* 中，没有代码来处理 `if` 表达式评估为假的情况。这就是 `else if` 语句发挥作用的地方。*图4**.4* 展示了代码中的
    `else if`：
- en: '![Figure 4.4 – else if statements](img/B19793_04_4.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – `else if`语句](img/B19793_04_4.jpg)'
- en: Figure 4.4 – else if statements
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – `else if`语句
- en: As `x` is 4 and `y` is 5 (line 19), the `if` expression on line 20 evaluates
    to false and thus control jumps to line 22 where the first `else` `if` is evaluated.
    As this evaluates to true, line 23 is executed. *Now, no other branch will be
    evaluated*. In other words, the next line of code executed after line 23 is line
    27\. Note that, as per good coding practice, each branch is coded as a block,
    even though there is only one statement in each block.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`x`是4而`y`是5（第19行），第20行的`if`表达式评估为假，因此控制跳转到第22行，那里第一个`else if`被评估。由于这评估为真，第23行被执行。*现在，不会评估其他分支*。换句话说，在执行第23行之后的下一行代码是第27行。请注意，根据良好的编码实践，每个分支都应编码为一个块，即使每个块中只有一个语句。
- en: Had `x` been initialized to `5`, then lines 20 and 22 would both have evaluated
    to false. Line 24 would be true, and thus, line 25 would be executed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`被初始化为`5`，那么第20行和第22行都会评估为假。第24行将是真，因此第25行将被执行。
- en: For situations where the `if` and `else if` statements do not match, we can
    use the `else` statement. Let us discuss that now.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`if`和`else if`语句不匹配的情况，我们可以使用`else`语句。现在让我们来讨论这个问题。
- en: else statements
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`else`语句'
- en: The code in *Figure 4**.4* evaluates all possible scenarios when comparing `x`
    and `y`. Either `x` is greater than, less than, or equal to `y`. This logic lends
    itself nicely to introducing the `else` statement. The `else` statement is a *catch-all*.
    As per `[]` in *Figure 4**.2*, the `else` clause is optional. If present, it must
    be coded at the end after any `if` and/or `else if` clauses. *Figure 4**.5* is
    *Figure 4**.4* refactored using an `else` clause, except that the values of `x`
    and `y` in *Figure 4**.5* are now the same.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.4*中的代码评估了比较`x`和`y`时所有可能的情况。`x`可能大于、小于或等于`y`。这种逻辑非常适合引入`else`语句。`else`语句是一个*通配符*。正如*图4.2*中的`[]`所示，`else`子句是可选的。如果存在，它必须在任何`if`和/或`else
    if`子句之后编码。*图4.5*是使用`else`子句重构的*图4.4*，除了*图4.5*中的`x`和`y`的值现在相同。'
- en: '![Figure 4.5 – else statement](img/B19793_04_5.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – `else`语句](img/B19793_04_5.jpg)'
- en: Figure 4.5 – else statement
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – `else`语句
- en: In *Figure 4**.5*, as both `x` and `y` are `4`, lines 31 and 33 evaluate to
    `false`. However, there is no condition on line 35 as it is simply an `else` statement
    (as opposed to `else if`). This means that the code block beginning on line 35
    is executed automatically and line 36 is executed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.5*中，由于`x`和`y`都是`4`，第31行和第33行评估为`false`。然而，第35行没有条件，因为它只是一个`else`语句（而不是`else
    if`）。这意味着从第35行开始的代码块将自动执行，第36行将被执行。
- en: With regard to `if else` statements, it is important to understand a subtle
    problem that can arise known as the “dangling `else`” problem.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`if else`语句，了解可能出现的微妙问题很重要，这个问题被称为“悬挂的`else`”问题。
- en: Dangling else
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 悬挂的`else`
- en: 'Consider the following unindented code, which uses no code blocks:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下未缩进的代码，它没有使用代码块：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code has two `if` statements but only one `else` statement. Which `if`
    statement does `else` match with? The rule is: when an `else` statement is looking
    to match with `if`, it will match with the nearest *unmatched* `if` as it progresses
    back up through the code.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两个`if`语句但只有一个`else`语句。`else`与哪个`if`匹配？规则是：当`else`语句寻找与`if`匹配时，它将与它向上回溯代码时遇到的最近的*未匹配*`if`匹配。
- en: 'Following this rule, the `else` statement matches with the second `if` (line
    3) as that `if` statement has not yet been matched. This means that the `if` statement
    on line 2 remains unmatched. The code, when written using proper indentation,
    is much clearer:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 依照这个规则，`else`语句与第二个`if`（第3行）匹配，因为那个`if`语句尚未匹配。这意味着第2行的`if`语句仍然未匹配。当使用适当的缩进编写代码时，代码会更加清晰：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is confirmed by the output. If `flag` is true, the output is `"True True"`;
    if `flag` is false, however, nothing is output to the screen. Interestingly, there
    is no way line 6 can now be reached (as `boolean` variables have only two values:
    `true` and `false`).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点通过输出得到证实。如果`flag`为真，输出将是`"True True"`；然而，如果`flag`为假，屏幕上则没有任何输出。有趣的是，现在无法到达第6行（因为布尔变量只有两个值：`true`和`false`）。
- en: 'Using code blocks makes the code even easier to understand, as can be seen
    as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码块可以使代码更容易理解，如下所示：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is why using code blocks, even for one statement, is very helpful. Throughout
    the book, we will use proper indentation and code blocks to aid clarity and ease
    of understanding.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么即使对于一条语句，使用代码块也是非常有帮助的。在整个书中，我们将使用适当的缩进和代码块来帮助清晰和易于理解。
- en: Now, let us look at a more involved example. This example (and others to follow)
    use the pre-defined `Scanner` class from the Java **Application Programming Interface**
    (**API**). The API is a suite of pre-defined types (for example classes) that
    are available for our use. We will cover these topics as we progress through the
    book but suffice to say that the API is extremely useful as it provides pre-defined
    and well-tested code for our use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个更复杂的例子。这个例子（以及随后的其他例子）使用了Java **应用程序编程接口**（**API**）中预定义的`Scanner`类。API是一套预定义的类型（例如类），可供我们使用。随着我们在书中继续前进，我们将涵盖这些主题，但可以说API非常有用，因为它为我们提供了预定义和经过良好测试的代码。
- en: The `Scanner` class resides in the `java.util` package. Therefore, we need to
    briefly discuss both packages and the `Scanner` class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`类位于`java.util`包中。因此，我们需要简要讨论这两个包和`Scanner`类。'
- en: Packages
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包
- en: A package is a group of related types, such as classes, that we can use. Conveniently,
    many are already available for us to use in the API.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 包是一组相关的类型，例如类，我们可以使用。方便的是，许多已经为我们准备好了，可以在API中使用。
- en: 'To gain access to these types, we need to “import” them into our code. For
    this purpose, Java provides the `import` keyword. Any `import` statements go at
    the top of your file. We can import a whole package using the `*` wildcard; for
    example: `import java.util.*;`. We can also import a particular type explicitly
    by naming it in the `import` statement; for example: `import java.util.Scanner;`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这些类型，我们需要将它们“导入”到我们的代码中。为此，Java提供了`import`关键字。任何`import`语句都放在文件的顶部。我们可以使用`*`通配符导入整个包；例如：`import
    java.util.*;`。我们也可以通过在`import`语句中命名它来显式地导入特定类型；例如：`import java.util.Scanner;`。
- en: When you precede the type with its package name, such as `java.util.Scanner`,
    this is known as the “fully qualified name”. We could omit the `import` statement
    and simply refer each time to `Scanner` using its fully qualified name; in other
    words, everywhere `Scanner` is mentioned, replace it with `java.util.Scanner`.
    Generally speaking, however, importing the type and using its non-qualified name
    is preferred.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类型前加上它的包名，例如`java.util.Scanner`，这被称为“完全限定名”。我们可以省略`import`语句，每次简单地使用其完全限定名来引用`Scanner`；换句话说，在提到`Scanner`的地方，将其替换为`java.util.Scanner`。然而，一般来说，导入类型并使用其非限定名是首选的。
- en: There is one package that is automatically available (imported) for us and that
    is the `java.lang` package. For example, the `String` class resides in `java.lang`
    and that is why we never have to import anything to get access to the `String`
    class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个包是自动对我们可用的（已导入），那就是`java.lang`包。例如，`String`类位于`java.lang`中，这就是为什么我们永远不需要导入任何东西就能访问`String`类。
- en: Scanner class
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Scanner类
- en: It is helpful to know that while `Scanner` is a versatile class, for our purposes,
    we will simply use `Scanner` to enable us to retrieve keyboard input from the
    user. With this in mind, note that `System.in` used in the examples refers to
    the standard input stream which is already open and ready to supply input data.
    Typically, this corresponds to the keyboard. `System.in` is therefore perfect
    for getting input data from the user via the keyboard. The `Scanner` class provides
    various methods for parsing/interpreting the keyboard input. For example, when
    the user types in a number at the keyboard, the method `nextInt()` provides that
    number to us as an `int` primitive. We will avail of these methods in our examples.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点是有帮助的，即虽然`Scanner`是一个多功能的类，但就我们的目的而言，我们只需使用`Scanner`来使我们能够从用户那里检索键盘输入。考虑到这一点，请注意，在示例中使用的`System.in`指的是已经打开并准备好提供输入数据的标准输入流。通常，这对应于键盘。因此，`System.in`非常适合通过键盘从用户那里获取输入数据。`Scanner`类提供了各种解析/解释键盘输入的方法。例如，当用户在键盘上输入一个数字时，`nextInt()`方法会以`int`原生的形式提供这个数字给我们。我们将在示例中使用这些方法。
- en: Nested if statements
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套if语句
- en: Now that we have discussed packages and `Scanner`, in *Figure 4**.6* and *Figure
    4**.7*, we discuss a more involved `if-else` example that deals with input from
    the user (via the keyboard). Both figures relate to the one example. *Figure 4**.6*
    focuses on the declaration of constants to make the code more readable. In addition,
    *Figure 4**.6* also focuses on declaring and using `Scanner`. On the other hand,
    *Figure 4**.7* focuses on the subsequent `if-else` structure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了包和`Scanner`，在**图4**.6*和**图4**.7*中，我们讨论了一个更复杂的`if-else`示例，该示例处理来自用户的输入（通过键盘）。这两个图都与一个示例相关。**图4**.6*侧重于声明常量以使代码更易读。此外，**图4**.6*还侧重于声明和使用`Scanner`。另一方面，**图4**.7*侧重于随后的`if-else`结构。
- en: '![Figure 4.6 – Using Scanner to get input from the keyboard](img/B19793_04_6.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 使用Scanner从键盘获取输入](img/B19793_04_6.jpg)'
- en: Figure 4.6 – Using Scanner to get input from the keyboard
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 使用Scanner从键盘获取输入
- en: Lines 11 to 14 define constants using the keyword `final`. This means that their
    values cannot change. It is good practice to use uppercase identifiers for constants
    (where words are separated by underscores). This will make the code in *Figure
    4**.7* more readable; in other words, instead of comparing `month` with `1` (which,
    in this context, means January), we will compare `month` with `JAN`, which reads
    better. For brevity’s sake, we have declared three constants per line but you
    can easily declare one per line also.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第11到14行使用`final`关键字定义常量。这意味着它们的值不能改变。使用大写标识符（单词之间用下划线分隔）作为常量的命名习惯是好的。这将使**图4**.7*中的代码更易读；换句话说，我们不会比较`month`与`1`（在这个上下文中表示一月），而是将`month`与`JAN`进行比较，这样读起来更好。为了简洁起见，我们每行声明了三个常量，但你也可以轻松地每行声明一个。
- en: Line 16 in *Figure 4**.6* creates our `Scanner` object reference, `sc`. Essentially,
    we are creating a reference, namely `sc`, which refers to the `Scanner` object
    created using the `new` keyword. As stated previously, `System.in` means that
    `sc` is looking at the keyboard. This reference is what we will use to interact
    with `Scanner`, much like a remote control is used to interact with a television.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图4**.6*的第16行创建我们的`Scanner`对象引用，`sc`。本质上，我们创建了一个引用，即`sc`，它指向使用`new`关键字创建的`Scanner`对象。正如之前所述，`System.in`意味着`sc`正在查看键盘。这个引用是我们用来与`Scanner`交互的，就像遥控器用来与电视交互一样。
- en: Line 17 prompts the user to enter a month (`1..12`) on the keyboard. This is
    actually very important because, without the prompt, the cursor will just blink
    and the user will wonder what they should type in. Line 18 is where `Scanner`
    really comes into its own. Here we use the `nextInt()` method to get in a number.
    For the moment, just know that when we call `sc.nextInt()`, Java does not return
    to our code until the user has typed in something and hit the return key. For
    the moment, we will make the (convenient) assumption that it is an integer. We
    will store the `int` primitive returned in our own `int` primitive, `month`. Now,
    in our code, we can use what the user typed in. *Figure 4**.7* shows this in action.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第17行提示用户在键盘上输入一个月份（`1..12`）。这实际上非常重要，因为没有提示，光标就会闪烁，用户会想知道他们应该输入什么。第18行是`Scanner`真正发挥作用的地方。在这里，我们使用`nextInt()`方法获取一个数字。目前，只需知道当我们调用`sc.nextInt()`时，Java不会返回到我们的代码中，直到用户输入了一些内容并按下了回车键。目前，我们将做出（方便的）假设，它是一个整数。我们将返回的`int`原始值存储在我们的`int`原始值`month`中。现在，在我们的代码中，我们可以使用用户输入的内容。**图4**.7*展示了这一过程。
- en: '![Figure 4.7 – A complex if statement](img/B19793_04_7.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 一个复杂的if语句](img/B19793_04_7.jpg)'
- en: Figure 4.7 – A complex if statement
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 一个复杂的if语句
- en: 'Note that the code presented in the preceding image is a *continuation* of
    *Figure 4**.6*. On line 20, we declare an `int` variable, namely `numDays`, and
    initialize it to `0`. Lines 21 to 22 are the start of the `if` statement. Using
    the `boolean` logical OR operator, the `if` statement checks to see whether the
    `month` value matches any of the constants defined in *Figure 4**.6*. In the background,
    the constant values are used, so in reality, the `if` statement is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面图像中显示的代码是**图4**.6*的**延续**。在第20行，我们声明了一个`int`变量，即`numDays`，并将其初始化为`0`。第21到22行是`if`语句的开始。使用`boolean`逻辑或运算符，`if`语句检查`month`值是否与**图4**.6*中定义的任何常量匹配。在后台，使用常量值，所以实际上，`if`语句如下：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `month` variable must be specified each time. In other words,
    `if(month == JAN || MAR || MAY || JUL || AUG || OCT || DEC)` will *not* compile.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次都必须指定`month`变量。换句话说，`if(month == JAN || MAR || MAY || JUL || AUG || OCT
    || DEC)`将**无法**编译。
- en: So, assuming that the user typed in `1` (representing January), `month` becomes
    `1` and, as a result, lines 21 to 22 evaluate to true and `numDays` is set to
    `31` on line 23\. The logic is the same if the user types in `3`, `5`, `7`, `8`,
    `10`, and `12`, representing March, May, July, August, October, and December,
    respectively.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户输入`1`（代表一月），`month`变为`1`，因此第21到22行评估为真，第23行将`numDays`设置为`31`。如果用户输入`3`、`5`、`7`、`8`、`10`和`12`，分别代表三月、五月、七月、八月、十月和十二月，逻辑相同。
- en: If the user types in `4` (representing April), lines 21 to 22 evaluate to false
    and the `else if` statement on line 24 is evaluated. Line 24 evaluates to true
    and `numdays` is set to `30` on line 25\. The logic is the same if the user types
    in `6`, `9`, and `11`, representing June, September, and November, respectively.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入`4`（代表四月），第21到22行评估为假，第24行的`else if`语句将被评估。第24行评估为真，第25行将`numdays`设置为`30`。如果用户输入`6`、`9`和`11`，分别代表六月、九月和十一月，逻辑相同。
- en: 'Now, let us deal with the user typing in `2`, representing February. The `if`
    condition on lines 21 to 22 and the `else if` condition on line 24 both evaluate
    to false. Line 26 evaluates to true. Now, we need to review the leap year logic.
    Of course, February has 28 days every year (as do all the months!) but has one
    extra day when the year is a leap year. The logic for determining whether a year
    is a leap year is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理用户输入的`2`，代表二月。第21到22行的`if`条件和第24行的`else if`条件都评估为假。第26行评估为真。现在，我们需要回顾闰年的逻辑。当然，二月每年都有28天（所有月份都是这样！），但在闰年时会有额外的一天。判断是否为闰年的逻辑如下：
- en: '`year` is a multiple of 400 => leap year'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`year`是400的倍数 => 闰年'
- en: '`year` is a multiple of 4 AND `year` is *not* a multiple of 100 => leap year'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`year`是4的倍数且`year`不是100的倍数 => 闰年'
- en: 'The following are all leap years: 2000 (satisfies scenario A), 2012, and 2016
    (both satisfy scenario B).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下都是闰年：2000年（满足情况A），2012年和2016年（都满足情况B）。
- en: As the leap year algorithm depends on the year, we first need the year from
    the user. Lines 27 to 28 accomplish this. We then encounter a nested `if` statement
    from lines 30 to 34, which determines, according to the logic just outlined, whether
    the year entered by the user is a leap year. Line 30 implements the logic for
    both scenarios A and B. Whether `year` is a multiple of 400 is achieved with `(year
    % 400 == 0)`. The condition of `year` being a multiple of 4 and not a multiple
    of 100 is achieved with
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于闰年算法依赖于年份，我们首先需要从用户那里获取年份。第27到28行完成了这个任务。然后，我们遇到了从第30到34行的嵌套`if`语句，它根据前面概述的逻辑确定用户输入的年份是否为闰年。第30行实现了A和B两种情况下的逻辑。判断`year`是否是400的倍数是通过`(year
    % 400 == 0)`实现的。`year`是4的倍数且不是100的倍数的条件是通过
- en: '`(year % 4 == 0 && !( year % 100 == 0))`. The fact that either condition satisfies
    the leap year calculation is achieved by using the logical OR operator between
    them. Assuming a year of 2000, line 30 would be true and `numDays` is set to `29`.
    Assuming a year of 1900, the `if` statement on line 30 is false and, as there
    is no condition on line 32 (it is just an `else` statement), line 33 is executed,
    setting `numDays` to `28`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`(year % 4 == 0 && !( year % 100 == 0))`。通过在它们之间使用逻辑或运算符，使得任一条件满足闰年计算。假设年份为2000，第30行将为真，`numDays`将被设置为`29`。假设年份为1900，第30行的`if`语句为假，由于第32行没有条件（它只是一个`else`语句），因此执行第33行，将`numDays`设置为`28`。'
- en: An invalid `month` value of, for example, `25` or `-3` would result in the `else`
    branch on line 35 being executed. An error message would be output to the screen
    on line 36 as a result.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的`month`值，例如`25`或`-3`，会导致第35行的`else`分支被执行。结果，第36行将输出错误消息到屏幕。
- en: 'Lines 38 to 40 output the number of days provided that `numDays` was changed
    from its initial value of `0`. The `if` statement on line 38 prevents the message
    `"Number of days is: 0"` from appearing on the screen if the user typed in an
    invalid `month` value.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '第38到40行在`numDays`从其初始值`0`改变时输出天数。第38行的`if`语句防止在用户输入无效的`month`值时在屏幕上显示消息`"Number
    of days is: 0"`。'
- en: That concludes our treatment of the `if` statement. Now, let us examine both
    `switch` statements and expressions, which can, in certain situations, be a more
    elegant option.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对`if`语句的处理。现在，让我们来检查两个`switch`语句和表达式，在某些情况下，它们可能是一个更优雅的选择。
- en: Mastering switch statements and expressions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握`switch`语句和表达式
- en: Complicated `if` statements, with many `else if` branches and an `else` branch
    can be verbose. The `switch` structure can, in many situations, be more concise
    and elegant. Let us start with `switch` statements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的 `if` 语句，带有许多 `else if` 分支和一个 `else` 分支可能会很冗长。在许多情况下，`switch` 结构可以更加简洁和优雅。让我们从
    `switch` 语句开始。
- en: switch statements
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch 语句
- en: Firstly, let us examine the syntax of the `switch` statement. *Figure 4**.8*
    introduces the syntax.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来检查 `switch` 语句的语法。*图 4.8* 介绍了语法。
- en: '![Figure 4.8 – The switch statement syntax](img/B19793_04_8.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – switch 语句语法](img/B19793_04_8.jpg)'
- en: Figure 4.8 – The switch statement syntax
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – switch 语句语法
- en: A `switch` statement evaluates an expression. As of Java 21, the expression
    can be an integral primitive (excluding `long`) or any reference type. This means
    that we can `switch` on primitive variables of type `byte`, `char`, `short`, or
    `int` and also `switch` on class types, enum types, record types and array types.
    The `case` labels can now include a `null` label. Java 21 also brought in *pattern
    matching for switch*. We will present another `switch` example demonstrating this
    feature when we have those topics covered ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205)).
    Until then, we will focus on the more traditional `switch`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句评估一个表达式。从 Java 21 开始，表达式可以是一个整型原始值（不包括 `long`）或任何引用类型。这意味着我们可以对
    `byte`、`char`、`short` 或 `int` 类型的原始变量进行 `switch`，也可以对类类型、枚举类型、记录类型和数组类型进行 `switch`。现在
    `case` 标签可以包括一个 `null` 标签。Java 21 还引入了 *switch 的模式匹配*。当涉及到这些主题时，我们将展示另一个 `switch`
    示例来演示这个功能（[*第 9 章*](B19793_09.xhtml#_idTextAnchor205)）。在此之前，我们将专注于更传统的 `switch`。'
- en: Wrapper types
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类型
- en: 'For each of the primitive types, there is a corresponding class, known as a
    “wrapper type”: `byte` (wrapped by `Byte`), `short` (`Short`), `int` (`Integer`),
    `long` (`Long`), `float` (`Float`), `double` (`Double`), `boolean` (`Boolean`),
    and `char` (`Character`). They are so called because they represent objects that
    encapsulate the primitive. As they are class types, useful methods are available.
    For example, `int val = Integer.parseInt("22");` converts the `String "22"` into
    the number `22`, stored in `val`, where we can perform arithmetic.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种原始类型，都有一个相应的类，称为“包装类型”：`byte`（由 `Byte` 包装），`short` (`Short`)，`int` (`Integer`)，`long`
    (`Long`)，`float` (`Float`)，`double` (`Double`)，`boolean` (`Boolean`)，和 `char`
    (`Character`)。它们之所以被称为包装类型，是因为它们代表封装原始值的对象。由于它们是类类型，因此有可用的一些有用方法。例如，`int val =
    Integer.parseInt("22");` 将 `String "22"` 转换为数字 `22`，存储在 `val` 中，我们可以在其中执行算术运算。
- en: 'The expression just evaluated is compared against the `case` labels. The `case`
    labels are compile-time constants of the same type as the `switch` expression.
    If there is a match with a `case` label, the associated block of code is executed
    (note: no need for curly braces in the `case` or `default` blocks). To exit the
    `case` block, ensure you insert a `break` statement. The `break` statement exits
    the `switch` block. However, the `break` statement is optional. If you omit the
    `break` statement, the code *falls through* to the next `case` label (or `default`),
    even though there is no match.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚评估的表达式与 `case` 标签进行比较。`case` 标签与 `switch` 表达式具有相同类型的编译时常量。如果与 `case` 标签匹配，则执行相关的代码块（注意：在
    `case` 或 `default` 块中不需要花括号）。要退出 `case` 块，请确保插入一个 `break` 语句。`break` 语句退出 `switch`
    块。然而，`break` 语句是可选的。如果您省略了 `break` 语句，即使没有匹配，代码也会 *跌入* 到下一个 `case` 标签（或 `default`）。
- en: The `default` keyword is used to specify a code block to execute if none of
    the `case` labels match. Typically, it is coded at the end of the `switch` block
    but this is not mandatory. In effect, `default` can appear anywhere in the `switch`
    block with similar semantics (this is a poor programming practice, however).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 关键字用于指定在没有任何 `case` 标签匹配时执行的代码块。通常，它被编码在 `switch` 块的末尾，但这不是强制性的。实际上，`default`
    可以出现在 `switch` 块的任何位置，具有类似的语义（然而，这并不是一个好的编程实践）。'
- en: '*Figure 4**.9* presents an example.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.9* 展示了一个示例。'
- en: '![Figure 4.9 – switch on a String example](img/B19793_04_9.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 在 String 上进行 switch 的示例](img/B19793_04_9.jpg)'
- en: Figure 4.9 – switch on a String example
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 在 String 上进行 switch 的示例
- en: Using the `Scanner` class, lines 18 to 20 ask and retrieve from the user a sport.
    Note that the `Scanner` method used on this occasion is `next()`, which returns
    a `String` type (as opposed to a primitive type).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Scanner` 类，第 18 到 20 行会询问并从用户那里检索一项运动。请注意，在这种情况下使用的 `Scanner` 方法是 `next()`，它返回一个
    `String` 类型（与原始类型相反）。
- en: Lines 21 to 31 present the `switch` block. Note that the `case` labels on lines
    22 and 25 are both `String` compile-time constants. If the user types in `"Soccer"`,
    the `case` label on line 22 matches, and both lines 23 and 24 will execute. Interestingly,
    even though there are two statements to be executed, there is no need for curly
    braces here. This is a feature of `switch` blocks. As line 22 matched, line 23
    will execute, and `"I play soccer"` will be echoed to the screen. The `break`
    statement on line 24 ensures that the `switch` block is exited and that the `"Rugby"`
    section is not executed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第 21 行到第 31 行展示了 `switch` 块。请注意，第 22 行和第 25 行的 `case` 标签都是 `String` 编译时常量。如果用户输入
    `"Soccer"`，则第 22 行的 `case` 标签匹配，并且第 23 行和第 24 行都将执行。有趣的是，尽管有两个语句要执行，但这里不需要花括号。这是
    `switch` 块的一个特性。由于第 22 行匹配，第 23 行将执行，并且 `"I play soccer"` 将被显示在屏幕上。第 24 行的 `break`
    语句确保退出 `switch` 块，并且不执行 `"Rugby"` 部分。
- en: If, on the other hand, the user types in `"Rugby"`, line 25 matches, and `"I
    play Rugby"` is echoed to the screen. Again, the `break` statement, this time
    on line 27, ensures that the `switch` block is exited and that the `default` section
    is not executed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入 `"Rugby"`，则第 25 行匹配，并且 `"I play Rugby"` 将被显示在屏幕上。同样，这次在第 27 行的 `break`
    语句确保退出 `switch` 块，并且不执行 `default` 部分。
- en: If the user typed in `"Tennis"`, then neither of the `case` labels on lines
    22 and 25 will match. This is when the `default` section comes into play. When
    there are no matches with any `case` label, the `default` section is executed.
    Typically, the `default` section is coded at the end of the `switch` block and
    the `break` statement is traditionally inserted for completeness.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入 `"Tennis"`，则第 22 行和第 25 行的 `case` 标签都不会匹配。这时 `default` 部分就派上用场了。当没有任何
    `case` 标签匹配时，将执行 `default` 部分。通常，`default` 部分被编码在 `switch` 块的末尾，并且传统上插入 `break`
    语句以确保完整性。
- en: Case labels are case-sensitive
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 标签是区分大小写的'
- en: Note that the `case` labels are case-sensitive. In other words, in *Figure 4**.9*,
    if the user types in `"soccer"`, the `case` label on line 22 will *not* match.
    The `"Rugby"` case label will not match either, naturally. Thus, the default section
    will execute, and `"Unknown sport"` will echo (print) to the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`case` 标签是区分大小写的。换句话说，在 *图 4**.9* 中，如果用户输入 `"soccer"`，则第 22 行的 `case` 标签不会匹配。自然地，`"Rugby"`
    的 `case` 标签也不会匹配。因此，将执行 `default` 部分，并且 `"Unknown sport"` 将被显示（打印）在屏幕上。
- en: Let us look at another example. *Figure 4**.10* is a `switch` statement based
    on integers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子。*图 4**.10* 是一个基于整数的 `switch` 语句。
- en: '![Figure 4.10 – switch on an integer example](img/B19793_04_10.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 整数开关示例](img/B19793_04_10.jpg)'
- en: Figure 4.10 – switch on an integer example
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 整数开关示例
- en: In the preceding figure, line 37 declares a compile-time constant, `two`, and
    initializes it to the integer literal, `2`. Line 38 starts the `switch` block
    by switching on an `int` variable named `number`, which was declared and initialized
    based on user input, on line 36\. All of the `case` labels in the `switch` block
    must now be integers – be they literal values as on lines 39 to 43 and line 47,
    or compile-time constants as on line 46\. Note that if the `two` variable is not
    *final*, a compile-time error is generated (as it is no longer a constant).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第 37 行声明了一个编译时常量 `two`，并将其初始化为整数文字 `2`。第 38 行通过切换名为 `number` 的 `int`
    变量开始 `switch` 块，该变量在第 36 行根据用户输入声明并初始化。现在 `switch` 块中的所有 `case` 标签都必须是整数——无论是第
    39 到 43 行和第 47 行的文本值，还是第 46 行的编译时常量。请注意，如果 `two` 变量不是 `final` 的，将生成编译时错误（因为它不再是常量）。
- en: In this example, we have multiple labels together, such as, lines 39-43\. This
    section of code can be read as *if number is 1 or 3 or 5 or 7 or 9, then do the
    following*. So, for example, if the user types in `1`, the `case` label on line
    39 matches. This is known as the *entry point* of the `switch` statement. As there
    is no `break` statement on line 39, the code *falls through* to line 40, even
    though line 40 has a `case` label for `3`. Again, line 40 has no `break` statement
    and the code *falls through* to line 41\. In fact, the code keeps executing from
    the entry point until it reaches a `break` statement (or the end of the `switch`
    statement itself). This *fall-through* behavior is what enables the *if it’s 1
    or 3 or 5 or 7 or 9* type logic to work. If this *fall-through* behavior were
    not present, we would have to duplicate lines 44 to 45 for each of the `case`
    labels! Line 44 uses the `String` append to output that the number entered is
    odd, by appending `"is odd"` to the number – for example, `"7 is odd"`. Line 45
    is the `break` statement that ensures we exit the `switch` block.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有多个标签一起，例如，第 39-43 行。这段代码可以读作 *如果数字是 1 或 3 或 5 或 7 或 9，则执行以下操作*。例如，如果用户输入
    `1`，第 39 行的 `case` 标签匹配。这被称为 `switch` 语句的 *入口点*。由于第 39 行没有 `break` 语句，代码会 *穿透*
    到第 40 行，尽管第 40 行有一个 `case` 标签用于 `3`。同样，第 40 行没有 `break` 语句，代码会 *穿透* 到第 41 行。实际上，代码会从入口点一直执行到遇到
    `break` 语句（或 `switch` 语句本身的末尾）。这种 *穿透* 行为使得 *如果是 1 或 3 或 5 或 7 或 9* 类型的逻辑能够工作。如果没有这种
    *穿透* 行为，我们就必须为每个 `case` 标签复制第 44 至 45 行！第 44 行使用 `String` 追加输出输入的数字是奇数，通过将 `"is
    odd"` 追加到数字上——例如，`"7 is odd"`。第 45 行是确保我们退出 `switch` 块的 `break` 语句。
- en: Line 46 is just to demonstrate that compile-time constants work for `case` labels.
    Line 47 shows that the `case` labels can be organized in a horizontal fashion
    if so desired. Remember, the use of indentation and spacing is just for human
    readability – the compiler just sees one long sequence of characters. So, lines
    46 to 47 match for the numbers 2, 4, 6, 8, and 10\. Again, the *fall-through*
    logic is used to keep the code concise. Lines 48 to 49 output that that number
    is even and `break` out of the `switch` block.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第 46 行只是为了演示编译时常量对 `case` 标签有效。第 47 行显示，如果需要，`case` 标签可以按水平方式组织。记住，缩进和间距的使用只是为了提高人类可读性——编译器只看到一长串字符。因此，第
    46 至 47 行与数字 2、4、6、8 和 10 匹配。同样，使用 *穿透* 逻辑来保持代码简洁。第 48 至 49 行输出该数字是偶数，并退出 `switch`
    块。
- en: Line 50 is the `default` section, which caters to any numbers outside of the
    `1..10` range. Line 51 outputs that the number entered is out of range, and line
    52 is the `break` statement. While the `break` statement is not strictly needed
    here (as `default` is at the bottom of the `switch` statement), it is considered
    good practice to include it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第 50 行是 `default` 部分，用于处理 `1..10` 范围之外的任何数字。第 51 行输出输入的数字超出范围，第 52 行是 `break`
    语句。虽然在这里 `break` 语句不是严格必需的（因为 `default` 在 `switch` 语句的底部），但包括它是良好的实践。
- en: Let us rewrite the code in *Figure 4**.7* using a `switch` statement instead
    of a complicated `if-else` statement. Note that *Figure 4**.6* is still relevant
    in declaring `Scanner` and the constants used; this is why we separated *Figure
    4**.6* (so we could use it with both the `if` and `switch` code). *Figure 4**.11*
    represents *Figure 4**.7* refactored using a `switch` statement.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `switch` 语句重写 *图 4.7* 中的代码，而不是复杂的 `if-else` 语句。请注意，*图 4.6* 仍然适用于声明 `Scanner`
    和使用的常量；这就是为什么我们将其分开（这样我们就可以同时使用 `if` 和 `switch` 代码）。*图 4.11* 表示使用 `switch` 语句重构的
    *图 4.7*。
- en: '![Figure 4.11 – Refactoring an if statement with a switch statement](img/B19793_04_11.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 使用 switch 语句重构 if 语句](img/B19793_04_11.jpg)'
- en: Figure 4.11 – Refactoring an if statement with a switch statement
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 使用 switch 语句重构 if 语句
- en: In the preceding figure, we can see the `switch` statement starts on line 23\.
    The first group of `case` labels is on line 24 and the second group is on line
    27\. February, the odd one out, has a `case` label to itself (line 30). Finally,
    the `default` label is on line 40\. Personally speaking, I find the use of `switch`
    in this example preferable due to the absence of the multiple logical OR expressions
    required in *Figure 4**.7* (lines 21 to 22 and 24).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到 `switch` 语句从第 23 行开始。第一组 `case` 标签在第 24 行，第二组在第 27 行。二月，作为特例，有一个单独的
    `case` 标签（第 30 行）。最后，`default` 标签在第 40 行。就我个人而言，由于没有像 *图 4.7*（第 21 至 22 行和第 24
    行）中所需的多个逻辑 OR 表达式，我认为在这个例子中使用 `switch` 更为可取。
- en: Now that we have covered valid `switch` statements, let us examine, in *Figure
    4**.12*, a few scenarios where compiler errors can arise.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了有效的 `switch` 语句，让我们在 *图 4*.12 中检查一些可能导致编译器错误的情况。
- en: '![Figure 4.12 – Some switch compiler errors](img/B19793_04_12.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 一些 switch 编译器错误](img/B19793_04_12.jpg)'
- en: Figure 4.12 – Some switch compiler errors
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 一些 switch 编译器错误
- en: In the preceding figure, we are switching on a `byte` variable, `b`. Recall
    that the valid `byte` range is `-128` to `+127`. Line 60 demonstrates that the
    minimum and maximum values are fine. Line 63 shows that, as `128` is out of range
    for our `byte` type `b`, the `case` labels that are out of range of the `switch`
    variable cause a compiler error. Line 64 was fine until line 65 used the same
    `case` label – `case` label duplicates are not allowed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们正在根据 `byte` 变量 `b` 进行切换。回想一下，有效的 `byte` 范围是 `-128` 到 `+127`。第 60 行演示了最小和最大值是正常的。第
    63 行显示，由于 `128` 超出了我们的 `byte` 类型 `b` 的范围，超出 `switch` 变量范围的 `case` 标签会导致编译器错误。第
    64 行原本是好的，直到第 65 行使用了相同的 `case` 标签——不允许 `case` 标签重复。
- en: We will finish our discussion on `switch` by discussing `switch` expressions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过讨论 `switch` 表达式来结束对 `switch` 的讨论。
- en: switch expressions
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch 表达式
- en: Like all expressions, `switch` expressions evaluate to a single value and, therefore,
    enable us to return values. All the `switch` examples so far have been `switch`
    *statements*, which return nothing. Note that in a `switch` expression, `break`
    statements are not allowed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有表达式一样，`switch` 表达式计算出一个单一值，因此使我们能够返回值。到目前为止的所有 `switch` 示例都一直是 `switch` *语句*，它们不返回任何内容。请注意，在
    `switch` 表达式中不允许使用 `break` 语句。
- en: On the other hand, `switch` *expressions* return something – either implicitly
    or explicitly (using `yield`). We will explain `yield` shortly, but note that
    `yield` cannot be used in a `switch` statement (as they do not return anything).
    In addition, `switch` statements can *fall through*, whereas `switch` expressions
    do not. These differences are encapsulated in *Table 4.1*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`switch` *表达式* 会返回一些内容——无论是隐式地还是显式地（使用 `yield`）。我们很快就会解释 `yield`，但请注意，`yield`
    不能在 `switch` 语句中使用（因为它们不返回任何内容）。此外，`switch` 语句可以 *穿透*，而 `switch` 表达式则不能。这些差异在
    *表 4.1* 中得到了封装。
- en: '![Table 4.1 – Comparison of switch statements versus switch expressions](img/B19793_04_Table_01.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![表 4.1 – switch 语句与 switch 表达式的比较](img/B19793_04_Table_01.jpg)'
- en: Table 4.1 – Comparison of switch statements versus switch expressions
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – switch 语句与 switch 表达式的比较
- en: Let us look at some example code to demonstrate the differences. *Figure 4**.13*
    is the traditional `switch` statement.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例代码来展示这些差异。*图 4*.13 是传统的 `switch` 语句。
- en: '![Figure 4.13 – A traditional switch statement](img/B19793_04_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 一个传统的 switch 语句](img/B19793_04_13.jpg)'
- en: Figure 4.13 – A traditional switch statement
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 一个传统的 switch 语句
- en: In the preceding figure, we are switching on the `String` variable, `name`.
    As it is initialized to `"Jane"`, line 19 is true and line 23 sets `nLetters`
    to `4` (the number of letters in “Jane”). The `break` statement on line 24 ensures
    that there is no fall-through to line 27\. Line 39 outputs `4` to the screen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们正在根据 `String` 变量 `name` 进行切换。由于它被初始化为 `"Jane"`，第 19 行为真，第 23 行将 `nLetters`
    设置为 `4`（"Jane" 中的字母数量）。第 24 行的 `break` 语句确保没有穿透到第 27 行。第 39 行将 `4` 输出到屏幕上。
- en: Notice that the code is quite verbose and requires the correct use of the `break`
    statement to prevent fall through. Plus, these `break` statements are tedious
    to write and easy to forget. *Figure 4**.14* represents *Figure 4**.13* written
    using a `switch` expression.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码相当冗长，需要正确使用 `break` 语句来防止穿透。此外，这些 `break` 语句编写起来很繁琐，很容易忘记。*图 4*.14 表示使用
    `switch` 表达式编写的 *图 4*.13。
- en: '![Figure 4.14 – A switch expression](img/B19793_04_14.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – switch 表达式](img/B19793_04_14.jpg)'
- en: Figure 4.14 – A switch expression
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – switch 表达式
- en: The preceding figure shows the new `case` label where the labels are comma-delimited
    and an arrow token separates the labels from the expression (or code block). There
    is no `break` statement required anywhere as there is no fall-through behavior
    to worry about. As `name` is still `"Jane"` (from *Figure 4**.13*, line 17), line
    42 is executed, which initializes/returns `4` into `nLetters`. Thus, line 50 outputs
    `4`. Note that the list of `case` labels in a `switch` expression must be exhaustive.
    In almost all cases, this means that a `default` clause is required. The `default`
    clause in this example executes a code block (lines 45-48), where an error is
    output to the screen and using the `yield` keyword, `nLetters` is initialized
    to (an error value of) `–1`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了新的`case`标签，其中标签以逗号分隔，并且一个箭头符号将标签与表达式（或代码块）分开。任何地方都不需要`break`语句，因为没有需要担心的穿透行为。由于`name`仍然是`"Jane"`（来自*图4.13*，第17行），第42行被执行，将`4`初始化/返回到`nLetters`中。因此，第50行输出`4`。请注意，`switch`表达式中的`case`标签列表必须是详尽的。在几乎所有情况下，这意味着需要一个`default`子句。在这个例子中，`default`子句执行一个代码块（第45-48行），其中将错误输出到屏幕上，并使用`yield`关键字，将`nLetters`初始化为（错误值）`-1`。
- en: We can omit the need for the `nLetters` variable by returning the expression
    value straight into the `System.out.println()` statement. *Figure 4**.15* demonstrates
    this.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过直接将表达式值返回到`System.out.println()`语句来省略对`nLetters`变量的需求。*图4.15*展示了这一点。
- en: '![Figure 4.15 – A switch expression returning straight to System.out.println()](img/B19793_04_15.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15 – 直接返回到System.out.println()的switch表达式](img/B19793_04_15.jpg)'
- en: Figure 4.15 – A switch expression returning straight to System.out.println()
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 – 一个直接返回到System.out.println()的switch表达式
- en: In the preceding figure, there is no variable used to store the result of the
    `switch` expression. This makes the code even more concise. The result of the
    `switch` expression is returned straight into the `System.out.println()` statement.
    Again, `4` is output to the screen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，没有变量用于存储`switch`表达式的结果。这使得代码更加简洁。`switch`表达式的结果直接返回到`System.out.println()`语句中。同样，`4`被输出到屏幕上。
- en: The yield keyword
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: yield关键字
- en: '*Figure 4**.14* and *Figure 4**.15* were simple `switch` expressions, where
    (for the most part), to the right of the arrow token was the value to be returned.
    However, instead of simply returning a value, what if you wished to execute a
    code block? This is where `yield` is used. *Figure 4**.16* shows the use of `yield`
    in a `switch` expression.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.14*和*图4.15*是简单的`switch`表达式，其中（大部分情况下），箭头符号右侧是返回的值。然而，如果你不仅想返回一个值，还想执行一个代码块，那么`yield`就派上用场了。*图4.16*展示了在`switch`表达式中使用`yield`。'
- en: '![Figure 4.16 – A switch expression using yield](img/B19793_04_16.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图4.16 – 使用yield的switch表达式](img/B19793_04_16.jpg)'
- en: Figure 4.16 – A switch expression using yield
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 – 使用yield的switch表达式
- en: The preceding figure highlights the fact that, if you need to execute more than
    one statement in a `switch` expression, you must provide a code block. This is
    shown with the curly braces for lines 61-64, 65-68, 69-72 and 73-76\. To return
    an expression result from a code block we use `yield`. This is what is done on
    lines 63, 67, 71 and 75, where `4`, `5`, `6` and `–1` are returned, respectively.
    As `name` is still `"Jane"`, line 63 returns `4` from the `switch` expression,
    initializing `nLetters` to `4`. Therefore, line 78 outputs `4`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示强调了这样一个事实，如果你需要在`switch`表达式中执行多个语句，你必须提供一个代码块。这通过第61-64行、65-68行、69-72行和73-76行的花括号来展示。要从代码块返回一个表达式结果，我们使用`yield`。这就是第63、67、71和75行所做的工作，分别返回`4`、`5`、`6`和`-1`。由于`name`仍然是`"Jane"`，第63行从`switch`表达式中返回`4`，将`nLetters`初始化为`4`。因此，第78行输出`4`。
- en: To aid flexibility, you can, up to a point, mix the syntaxes. In other words,
    regular `case` labels can be used in `switch` expressions, and the new `case`
    labels syntax can be used in `switch` statements. However, as stated earlier,
    `break` only appears in `switch` *statements* and `yield` only appears (if required)
    in switch *expressions*. *Figure 4**.17* is a refactor of the verbose `switch`
    statement in *Figure 4**.13*, where the new `case` labels are used in a `switch`
    statement.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加灵活性，你可以在一定程度上混合语法。换句话说，在`switch`表达式中可以使用常规的`case`标签，在`switch`语句中可以使用新的`case`标签语法。然而，如前所述，`break`只出现在`switch`*语句*中，而`yield`（如果需要）只出现在`switch`*表达式*中。*图4.17*是对*图4.13*中冗长的`switch`语句的重构，其中使用了新的`case`标签。
- en: '![Figure 4.17 – A switch statement using new case labels and an arrow token](img/B19793_04_17.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图4.17 – 使用新`case`标签和箭头标记的`switch`语句](img/B19793_04_17.jpg)'
- en: Figure 4.17 – A switch statement using new case labels and an arrow token
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 – 使用新`case`标签和箭头标记的`switch`语句
- en: In the preceding figure, the labels are comma-delimited and the arrow token
    is present. As before, on the right of the arrow token, we have the initialization
    of `nLetters` to the number of letters in the name. However, in contrast to *Figure
    4**.13*, as we are using the arrow token, no `break` statements are required.
    Note however that curly braces are required for a code block as per the `default`
    clause (lines 86-89).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，标签是逗号分隔的，并且存在箭头标记。和之前一样，在箭头标记的右侧，我们有`nLetters`的初始化，即名字中的字母数。然而，与*图4.13*不同，因为我们使用了箭头标记，所以不需要`break`语句。然而请注意，根据`default`子句（第86-89行），代码块需要大括号。
- en: We can also use the regular `case` labels with `switch` expressions. This is
    shown in *Figure 4**.18*, which is a refactored version of *Figure 4**.16*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用常规的`case`标签与`switch`表达式一起使用。这如图4.18所示，它是图4.16的重构版本。
- en: '![ Figure 4.18 – A switch expression using old-style case labels](img/B19793_04_18.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图4.18 – 使用旧式`case`标签的`switch`表达式](img/B19793_04_18.jpg)'
- en: Figure 4.18 – A switch expression using old-style case labels
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 – 使用旧式`case`标签的`switch`表达式
- en: 'In the preceding figure, the old-style `case` labels are used. This means that
    the keyword `case` must precede each label. The curly braces for the code blocks
    can, however, be omitted. As it is a `switch` expression, where there is more
    than one statement to be executed when a match is found, we need to use `yield`
    to return the expression result. As the `name` variable has never been changed
    from `"Jane"` throughout all the examples, a match is made on line 95, resulting
    in line 99 outputting `"There are 4 letters in: Jane"` to the screen. The `yield`
    on line 100 returns `4`, and thus, `nLetters` is initialized to `4`. Finally,
    line 114 outputs `4` to the screen.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的图中，使用了旧式的`case`标签。这意味着关键字`case`必须在每个标签之前。然而，代码块的括号可以省略。由于这是一个`switch`表达式，当找到匹配时，会有多个语句需要执行，因此我们需要使用`yield`来返回表达式结果。由于`name`变量在整个示例中从未从`"Jane"`改变，因此在第95行进行匹配，导致第99行将`"There
    are 4 letters in: Jane"`输出到屏幕。第100行的`yield`返回`4`，因此`nLetters`被初始化为`4`。最后，第114行将`4`输出到屏幕。'
- en: This completes our treatment of `switch` expressions and, indeed, `switch` statements
    in general. We will now put what we have learned into practice.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对`switch`表达式以及一般`switch`语句的处理。现在，我们将所学应用到实践中。
- en: Exercises
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We finally have the coding capability to make decisions. Mesozoic Eden is going
    to be benefiting from this so much. Let’s show off our newly acquired skills,
    shall we?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终拥有了做出决策的编码能力。中生代伊甸园将因此受益匪浅。让我们展示我们新获得的本领，怎么样？
- en: We need to determine whether a dinosaur is a carnivore or herbivore. Write an
    `if` statement that prints whether a dinosaur is a carnivore or herbivore based
    on a `boolean` variable. This information is critical for feeding and care guidelines.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确定恐龙是肉食性还是草食性。编写一个`if`语句，根据布尔变量打印恐龙是肉食性还是草食性。这些信息对于饲养和护理指南至关重要。
- en: Different species require different care strategies and exhibit unique behavior
    traits. Write a `switch` statement that prints a description of a dinosaur based
    on its species. This will help educate both the staff and park visitors.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不同的物种需要不同的护理策略，并表现出独特的行为特征。编写一个`switch`语句，根据恐龙的物种打印恐龙的描述。这将有助于教育员工和公园游客。
- en: Some dinosaurs are tougher to handle than others. Write an `if` statement that
    checks whether a number of years of experience is enough experience to work with
    a certain type of dinosaur. This ensures the safety of both our dinosaurs and
    employees.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有些恐龙比其他恐龙更难处理。编写一个`if`语句，检查是否有足够的经验来处理某种类型的恐龙。这确保了我们的恐龙和员工的安全。
- en: We are working with beautiful but dangerous creatures. So, safety first. Write
    a program that prints a warning message if the park’s safety rating falls below
    a certain threshold. We must always be alert to potential issues that could harm
    our staff, visitors, or dinosaurs.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在与美丽但危险的生物打交道。所以，安全第一。编写一个程序，如果公园的安全评级低于某个阈值，则打印警告信息。我们必须始终保持警惕，以防止可能伤害我们的员工、游客或恐龙的问题。
- en: Proper housing is essential for the dinosaurs’ well-being. Write a `switch`
    statement that assigns a dinosaur to a specific enclosure based on its size (XS,
    S, M, L, or XL).
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适当的住所对于恐龙的幸福至关重要。编写一个`switch`语句，根据恐龙的大小（XS、S、M、L或XL）将其分配到特定的围栏。
- en: Proper nutrition is crucial for maintaining our dinosaurs’ health. Write an
    `if` statement that determines the number of feeds a dinosaur requires per day
    based on its weight.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适当的营养对于维持我们恐龙的健康至关重要。编写一个`if`语句，根据恐龙的体重确定其每天所需的喂食次数。
- en: It is important to delegate tasks properly to keep operations running smoothly.
    Create a program that assigns different duties to employees based on their job
    titles using a `switch` statement.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确地委派任务是保持运营顺利的重要因素。创建一个程序，使用`switch`语句根据员工的职位分配不同的职责。
- en: The park is not open to day visitors 24/7\. Write an `if` statement that checks
    whether the park is open for them based on the time. They are open for day visitors
    from 10 A.M. to 7 P.M. This helps in managing visitor expectations and staff schedules.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公园不是全天24小时对日间游客开放。编写一个`if`语句，根据时间检查公园是否对日间游客开放。他们从上午10点到下午7点对日间游客开放。这有助于管理游客的期望和员工的时间表。
- en: Project – Task allocation system
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 – 任务分配系统
- en: The manager of Mesozoic Eden needs a systematic way of managing the team and
    ensuring all tasks are efficiently accomplished.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 中生代伊甸园的经理需要一个系统化的方法来管理团队并确保所有任务都高效完成。
- en: Design a simple program that assigns tasks to the Mesozoic Eden employees based
    on their roles (for example, feeding, cleaning, security, and tour guiding). The
    program should decide tasks based on time, the employee’s role, and other factors,
    such as the park’s safety rating.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个简单的程序，根据员工的角色（例如，喂食、清洁、安全和导游）将任务分配给中生代伊甸园的员工。该程序应根据时间、员工的角色和其他因素（如公园的安全评级）来决定任务。
- en: This program would not only help streamline operations but also ensure the safety
    and satisfaction of our staff, visitors, and, most importantly, our dinosaurs!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序不仅可以帮助简化运营，还可以确保我们员工、游客以及最重要的是恐龙的安全和满意度！
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by explaining that Java uses block scope. A block
    is delimited by `{ }`. A variable is visible from the point of declaration to
    the closing `}` of that block. As blocks (and therefore, scopes) can be nested,
    this means that a variable defined in a block is visible to any inner/nested blocks.
    The inverse is not true, however. A variable declared in an inner block is not
    visible in an outer block
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先解释了Java使用块作用域。一个块由`{}`界定。一个变量从声明点可见到该块的结束`}`。由于块（以及因此作用域）可以嵌套，这意味着在块中定义的变量对任何内部/嵌套块都是可见的。然而，反之则不成立。在内部块中声明的变量在外部块中不可见。
- en: Conditional statements enable us to make decisions and are based on the evaluation
    of a condition resulting in true or false. The `if` statement allows several branches
    to be evaluated. Once one branch evaluates to true and is executed, no other branch
    is evaluated. An `if` statement can be coded on its own without any `else if`
    or `else` clause. The `else if` and `else` clauses are optional. However, if an
    `else` clause is present, it must be the last clause. We saw how a complex `if`
    example can lead to code verbosity.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句使我们能够做出决定，并基于条件的评估结果为真或假。`if`语句允许评估多个分支。一旦某个分支评估为真并执行，则不会评估其他分支。`if`语句可以单独编码，而不需要任何`else
    if`或`else`子句。`else if`和`else`子句是可选的。然而，如果存在`else`子句，它必须是最后一个子句。我们看到了一个复杂的`if`示例如何导致代码冗长。
- en: We briefly discussed packages and the `Scanner` class. The `Scanner` class resides
    in the `java.util` package and is very useful for retrieving keyboard input from
    the user.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了包和`Scanner`类。`Scanner`类位于`java.util`包中，对于从用户那里获取键盘输入非常有用。
- en: We also discussed both `switch` statements and `switch` expressions. An expression
    can return a value but a statement cannot. We saw how `switch` statements can
    make complicated `if` statements more concise and elegant. The expression you
    `switch` on (typically, a variable) can be a primitive `byte`, `char`, `short`,
    or `int` type ; or a reference type. The `case` labels must be compile-time constants
    and must be in range for the `switch` variable. `switch` statements have a fall-through
    feature, which enables multiple `case` labels to use the same section of code
    without repetition. However, this fall-through behavior requires a `break` statement
    to exit the `switch` statement. This requires care, as `break` statements are
    easy to forget.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了`switch`语句和`switch`表达式。一个表达式可以返回一个值，但一个语句不能。我们看到了`switch`语句如何使复杂的`if`语句更加简洁和优雅。你`switch`上的表达式（通常是变量）可以是原始类型`byte`、`char`、`short`或`int`；或者是一个引用类型。`case`标签必须是编译时常量，并且必须在`switch`变量的范围内。`switch`语句有一个穿透特性，这使得多个`case`标签可以使用相同的代码段而不需要重复。然而，这种穿透行为需要`break`语句来退出`switch`语句。这需要小心，因为`break`语句很容易忘记。
- en: '`switch` expressions can return a value. They have no fall-through logic so
    `break` statements are not required. This makes the code more concise and less
    error-prone. If you wish to execute a code block in a `switch` expression, use
    `yield` to return the value.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`表达式可以返回一个值。它们没有穿透逻辑，所以不需要`break`语句。这使得代码更加简洁且错误更少。如果你想在`switch`表达式中执行一个代码块，请使用`yield`来返回值。'
- en: '`switch` statements do not support `yield` (as they do not return anything),
    and `switch` expressions do not support `break` (as they must return something).
    However, both of the `case` labels, namely the old-style `case X:` and the newer
    style `case A, B, C ->`, can be used with either `switch` statements or `switch`
    expressions.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句不支持`yield`（因为它们不返回任何内容），而`switch`表达式不支持`break`（因为它们必须返回某些内容）。然而，两种`case`标签，即旧式的`case
    X:`和新式的`case A, B, C ->`，都可以与`switch`语句或`switch`表达式一起使用。'
- en: Now that we know how to make decisions, we will move on to iteration in the
    next chapter, where we will examine the Java structures that enable us to repeat
    statements.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何做出决策，我们将在下一章中继续讨论迭代，我们将检查Java结构，这些结构使我们能够重复执行语句。
