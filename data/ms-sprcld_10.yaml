- en: Additional Configuration and Discovery Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的配置和发现功能
- en: 'We talked a great deal about service discovery and distributed configuration
    in [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*,
    and [Chapter 5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), *Distributed Configuration
    with Spring Cloud Config*. We discussed two solutions in detail. The first of
    them, Eureka, is provided by Netflix OSS and has been adopted by Spring Cloud
    for service discovery. The second was the Spring Cloud Config project dedicated
    only to a distributed configuration. However, there are some interesting solutions
    on the market effectively combining both of these features. Currently, Spring
    Cloud supports two of them:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第4章*服务发现*和第5章*使用Spring Cloud Config进行分布式配置*中详细讨论了服务发现和分布式配置。我们讨论了两个解决方案。第一个，Eureka，由Netflix
    OSS提供，并被Spring Cloud用于服务发现。第二个是仅致力于分布式配置的Spring Cloud Config项目。然而，市场上有一些有趣的产品，它们有效地结合了这两项功能。目前，Spring
    Cloud支持其中的两个：
- en: '**Consul**: This product is built by HashiCorp. It is a highly available, distributed
    solution designed to connect and configure applications across dynamic, distributed
    infrastructure. Consul is a rather complex product, and has multiple components,
    but its main functionality is discovering and configuring services across any
    infrastructure.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Consul**：这个产品是由HashiCorp构建的。它是一个高可用的分布式解决方案，旨在连接和配置跨动态、分布式基础设施的应用程序。Consul是一个相当复杂的产品，具有多个组件，但其主要功能是在任何基础设施上发现和配置服务。'
- en: '**Zookeeper**: This product is built by Apache Software Foundation. It is a
    distributed, hierarchical key/value storage written in Java. It is designed to
    maintain configuration information, naming, and distributed synchronization. In
    contrast to Consul, it is more of a primitive key/value storage than a modern
    service discovery tool. However, Zookeeper is still very popular, especially for
    solutions based on the Apache Software stack.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zookeeper**：这个产品是由Apache软件基金会构建的。它是一个用Java编写的分布式、层次化的键/值存储。它旨在维护配置信息、命名和分布式同步。与Consul相比，它更像是原始的键/值存储，而不是现代的服务发现工具。然而，Zookeeper仍然非常受欢迎，特别是对于基于Apache软件栈的解决方案。'
- en: 'Support for two other popular products from that area is still in the development
    stage. The following projects have still not been added to the official Spring
    Cloud Release Train:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 支持该领域内的另外两个流行产品仍处于开发阶段。以下项目尚未添加到官方Spring Cloud发行版中：
- en: '**Kubernetes**: This is an open-source solution designed for automating deployment,
    scaling, and management of containerized applications, originally created by Google.
    This tool is enjoying great popularity right now. Recently, the Docker platform
    has started supporting Kubernetes.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：这是一个开源解决方案，旨在自动化容器化应用程序的部署、扩展和管理，最初由Google创建。目前这个工具非常受欢迎。最近，Docker平台开始支持Kubernetes。'
- en: '**Etcd**: This is a distributed reliable key/value storage for the most critical
    data of a distributed system written in Go. It is used in production by many companies
    and other software products, for example, Kubernetes.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Etcd**：这是一个用Go编写的分布式可靠键/值存储，用于存储分布式系统中最关键的数据。许多公司和软件产品在生产环境中使用它，例如Kubernetes。'
- en: In this chapter, I'm going to introduce only officially supported solutions,
    namely Consul and Zookeeper. Kubernetes, which is much more than only a key/value
    storage or a service registry, will be discussed in [Chapter 14](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml),
    *Docker Support*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将只介绍官方支持的两个解决方案，即Consul和Zookeeper。Kubernetes，它不仅仅是键/值存储或服务注册表，将在第14章*Docker支持*中讨论。
- en: Using Spring Cloud Consul
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Consul
- en: The Spring Cloud Consul project provides integration for Consul and Spring Boot
    applications through auto-configuration. By using the well-known Spring Framework
    annotation style, we may enable and configure common patterns within microservice-based
    environments. These patterns include service discovery using Consul agent, distributed
    configuration using Consul key/value store, distributed events with Spring Cloud
    Bus, and Consul Events. The project also supports a client-side load balancer
    based on Netflix's Ribbon and an API gateway based on Netflix's Zuul. Before we
    start to discuss these features, we first have to run and configure Consul agent.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Consul项目通过自动配置为Consul和Spring Boot应用程序提供集成。通过使用众所周知的Spring Framework注解风格，我们可以在微服务环境中启用和配置常见模式。这些模式包括使用Consul代理的服务发现，使用Consul键/值存储的分布式配置，使用Spring
    Cloud Bus的分布式事件，以及Consul事件。该项目还支持基于Netflix的Ribbon的客户端负载均衡器和一个基于Netflix的Zuul的API网关。在我们讨论这些特性之前，我们首先必须运行和配置Consul代理。
- en: Running Consul agent
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Consul代理
- en: 'We will begin with the simplest way of starting Consul agent on our local machines.
    The standalone development mode may be easily set up with the Docker container.
    Here''s the command, which will start the Consul container from the official Hashicorp''s
    image available on Docker Hub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在本地机器上以最简单的方式启动Consul代理开始。使用Docker容器独立开发模式可以很容易地设置。以下是命令，它将从一个在Docker Hub上可用的官方HashiCorp镜像启动Consul容器：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After launching, Consul is available under the address `http://192.168.99.100:8500`.
    It exposes RESTful HTTP API, that is, the main interface. All the API routes are
    prefixed with `/v1/`. Of course, it is not required to use the API directly. There
    are some programming libraries that can be used to consume the API more conveniently.
    One of them is `consul-api`, the client written in Java and also used by Spring
    Cloud Consul internally. There is also the web UI dashboard provided by Consul
    available under the same address as the HTTP API, but on a different context path,
    `/ui/`. It allows for viewing all registered services and nodes, viewing all health
    checks and their current status, and reading and setting key/value data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，Consul可以在地址`http://192.168.99.100:8500`下访问。它暴露了RESTful HTTP API，即主要接口。所有API路由都带有`/v1/`前缀。当然，不直接使用API也是可以的。还有一些编程库可以更方便地消费API。其中之一是`consul-api`，这是用Java编写的客户端，也是Spring
    Cloud Consul内部使用的。还有由Consul提供的web UI仪表板，在相同的地址下，但上下文路径不同，为`/ui/`。它允许查看所有注册的服务和节点，查看所有健康检查及其当前状态，以及读取和设置键/值数据。
- en: 'As I mentioned in the preface to this section, we are going to use three different
    features of Consul—agent, events, and KV store. Each of them is represented by
    the group of endpoints, respectively `/agent`, `/event`, and `/kv`. The most interesting
    agent endpoints are those related with service registration. Here''s a list of
    these endpoints:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在本节前言中提到的，我们将使用Consul的三个不同功能——代理、事件和KV存储。每个功能都由一组端点代表，分别是`/agent`、`/event`和`/kv`。最有趣的代理端点是与服务注册相关的那些。以下是这些端点的列表：
- en: '| **Method** | **Path** | **Description** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **路径** | **描述** |'
- en: '| `GET` | `/agent/services` | It returns a list of the services registered
    with the local agent. If Consul is run in a clustered mode, that list may be different
    than the list reported by the `/catalog` endpoint before synchronization performed
    between cluster members. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/agent/services` | 它返回已注册到本地代理的服务列表。如果Consul以集群模式运行，该列表可能与在集群成员之间执行同步之前由`/catalog`端点报告的列表不同。
    |'
- en: '| `PUT` | `/agent/service/register` | It adds a new service to the local agent.
    The agent is responsible for managing local services, and for sending updates
    to the servers to perform synchronization for the global catalog. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/agent/service/register` | 它向本地代理添加了一个新服务。代理负责管理本地服务，并向服务器发送更新以执行全局目录的同步。
    |'
- en: '| `PUT` | `/agent/service/deregister/:service_id` | It removes a service with
    `service_id` from the local agent. The agent takes care of de-registering the
    service with the global catalog. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/agent/service/deregister/:service_id` | 它从本地代理中移除具有`service_id`的服务。代理负责在全球目录中注销该服务。
    |'
- en: 'The `/kv` endpoints are dedicated to managing simple key/value store, which
    is especially useful for storing service configuration or other metadata. It is
    worth noting that each data center has its own KV store, so in order to share
    it across multiple nodes, we should have configured the Consul replicate daemon.
    Anyway, here''s a list of the three endpoints for managing the key/value store:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`/kv`端点用于管理简单的键/值存储，这对于存储服务配置或其他元数据特别有用。值得注意的是，每个数据中心都有自己的KV存储，因此为了在多个节点之间共享它，我们应该配置Consul复制守护进程。无论如何，这里是为管理键/值存储列出的三个端点：'
- en: '| **Method** | **Path** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **路径** | **描述** |'
- en: '| `GET` | `/kv/:key` | It returns the value for the given key name. If the
    requested key does not exist, HTTP status 404 is returned as a response. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/kv/:key` | 它返回给定键名的值。如果请求的键不存在，则返回HTTP状态404作为响应。 |'
- en: '| `PUT` | `/kv/:key` | It is used for adding a new key to the store, or just
    to update the existing one with a key name. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/kv/:key` | 它用于向存储中添加新键，或者只是用键名更新现有键。 |'
- en: '| `DELETE` | `/kv/:key` | It is the last CRUD method that is used for deleting
    a single key, or all keys, with the same prefix. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/kv/:key` | 它是用于删除单个键或具有相同前缀的所有键的最后CRUD方法。 |'
- en: Spring Cloud uses Consul Events for providing a dynamic configuration reload.
    There are two simple API methods. The first of them, `PUT /event/fire/:name`,
    triggers a new event. The second, `GET /event/list`, returns a list of events,
    which might be filtered by name, tag, node, or service name.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud使用Consul事件来提供动态配置重载。其中有两个简单的API方法。第一个，`PUT /event/fire/:name`，触发一个新的事件。第二个，`GET
    /event/list`，返回一个事件列表，可能通过名称、标签、节点或服务名称进行过滤。
- en: Integration on the client side
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端集成
- en: 'To activate Consul service discovery in your project, you should include the
    starter `spring-cloud-starter-consul-discovery` to the dependencies. If you would
    like to enable distributed configuration with Consul, just include `spring-cloud-starter-consul-config`.
    In some cases, you would probably use both these features in your client-side
    application. Then, you should declare a dependency to the `spring-cloud-starter-consul-all`
    artifact:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的项目中激活Consul服务发现，您应该将启动器`spring-cloud-starter-consul-discovery`包含在依赖项中。如果您希望启用与Consul的分布式配置，只需包含`spring-cloud-starter-consul-config`。在某些情况下，您可能在客户端应用程序中使用这两个功能。然后，您应该声明对`spring-cloud-starter-consul-all`工件的依赖关系：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By default, the Consul agent is expected to be available under the address
    `localhost:8500`. If it is different for your application, you should provide
    the appropriate address in the `application.yml` or `bootstrap.yml` file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Consul代理预计将在`localhost:8500`地址下可用。如果对于您的应用程序不同，您应该在`application.yml`或`bootstrap.yml`文件中提供适当的地址：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Service discovery
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: 'Discovery with Consul is enabled for the application by annotating the main
    class with the generic Spring Cloud `@EnableDiscoveryClient`. You should remember
    that from [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*,
    because there is no difference in comparison with Eureka. The default service
    name is also taken from the `${spring.application.name}` property. Sample microservices
    that use Consul as a discovery server are available on GitHub in the [https://github.com/piomin/sample-spring-cloud-consul.git](https://github.com/piomin/sample-spring-cloud-consul.git)
    repository. The architecture of the system is the same as for examples in some
    previous chapters. There are four microservices, `order-service`, `product-service`,
    `customer-service`, and `account-service`, and the API gateway is implemented
    in the module `gateway-service`. For inter-service communication, we use the Feign
    client together with the Ribbon load balancer:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在主类上使用泛型的Spring Cloud `@EnableDiscoveryClient`注解，可以使应用程序启用Consul发现。你应该记得从[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)，*服务发现*，因为与Eureka相比没有区别。默认服务名称也来自`${spring.application.name}`属性。在GitHub上的[https://github.com/piomin/sample-spring-cloud-consul.git](https://github.com/piomin/sample-spring-cloud-consul.git)存储库中提供了使用Consul作为发现服务器的微服务示例。系统的架构与前几章中的示例相同。有四个微服务，`order-service`、`product-service`、`customer-service`和`account-service`，并且API网关在`gateway-service`模块中实现。对于服务间通信，我们使用Feign客户端和Ribbon负载均衡器：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By default, the Spring Boot application is registered in Consul with the instance
    ID generated as a concatenation of values taken from the properties `spring.application.name`,
    `spring.profiles.active`, `server.port`. In most cases, it is enough to be sure
    that the ID is unique, but if the custom pattern is required, it may be easily
    set with the `spring.cloud.consul.discovery.instanceId` property:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot应用程序在Consul中注册，实例ID是`spring.application.name`、`spring.profiles.active`、`server.port`属性值的拼接。在大多数情况下，确保ID是唯一的就足够了，但如果需要自定义模式，可以通过`spring.cloud.consul.discovery.instanceId`属性轻松设置：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After launching all the sample microservices, take a look at the Consul UI
    dashboard. You should see there are four different services registered, like in
    the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 启动所有示例微服务后，查看Consul UI控制台。您应该会在那里看到四个不同的服务注册，如下面的屏幕截图所示：
- en: '![](img/8fa25939-b447-4d22-af84-19dab28e9745.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fa25939-b447-4d22-af84-19dab28e9745.png)'
- en: 'Alternatively, you may check out a list of registered services using the RESTful
    HTTP API endpoint `GET /v1/agent/services`. Here''s the fragment of the JSON response:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，您可以使用RESTful HTTP API端点`GET /v1/agent/services`查看已注册服务的列表。这是JSON响应的一个片段：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you may easily test the whole system by sending some test requests to `order-service`
    using the `pl.piomin.services.order.OrderControllerTest` JUnit test class. Everything
    should work fine, and the same as for discovery with Eureka.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以轻松地通过使用`pl.piomin.services.order.OrderControllerTest` JUnit测试类向`order-service`发送一些测试请求来测试整个系统。一切应该都会正常工作，与使用Eureka进行发现相同。
- en: Health check
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查
- en: 'Consul checks out the health status of every registered instance by calling
    the `/health` endpoint. If you do not wish to provide the Spring Boot Actuator
    library in the classpath, or there are some problems with your service, it will
    be visible on the web dashboard:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Consul通过调用`/health`端点检查每个注册实例的健康状态。如果您不想在类路径中提供Spring Boot Actuator库，或者您的服务存在一些问题，它将会在网页控制台上显示出来：
- en: '![](img/208a2cee-71ec-4469-b222-39572887b4ea.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/208a2cee-71ec-4469-b222-39572887b4ea.png)'
- en: If the health check endpoint is available under a different context path for
    any reason, you may override that path with the `spring.cloud.consul.discovery.healthCheckPath`
    property. There is also the possibility to change the status refresh interval
    by defining `healthCheckInterval` with a pattern, such as, for example, `10s`
    for seconds or `2m` for minutes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于任何原因健康检查端点在不同的上下文路径下可用，您可以通过`spring.cloud.consul.discovery.healthCheckPath`属性覆盖该路径。还可以通过定义`healthCheckInterval`属性来更改状态刷新间隔，例如，使用`10s`表示秒或`2m`表示分钟。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Zones
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区域
- en: I assume you remember our discussion about zoning mechanisms available for discovery
    with Eureka in [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service
    Discovery*. It is useful when the hosts are placed in a different location, and
    you would prefer communication between instances registered in the same zone.
    The official documentation of the Spring Cloud Consul ([http://cloud.spring.io/spring-cloud-static/spring-cloud-consul/1.2.3.RELEASE/single/spring-cloud-consul.html](http://cloud.spring.io/spring-cloud-static/spring-cloud-consul/1.2.3.RELEASE/single/spring-cloud-consul.html))
    says nothing about such a solution, which fortunately doesn't mean it is not implemented.
    Spring Cloud provides a zoning mechanism based on Consul tags. The default zone
    for the application may be configured with the `spring.cloud.consul.discovery.instanceZone`
    property. It sets the tag configured in the `spring.cloud.consul.discovery.defaultZoneMetadataName`
    property with the passed value. The default metadata tag name is `zone`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您还记得我们在[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)《服务发现》中关于Eureka的分区机制的讨论。当主机位于不同位置时，它很有用，您希望实例在同一区域之间进行通信。Spring
    Cloud Consul的官方文档（[http://cloud.spring.io/spring-cloud-static/spring-cloud-consul/1.2.3.RELEASE/single/spring-cloud-consul.html](http://cloud.spring.io/spring-cloud-static/spring-cloud-consul/1.2.3.RELEASE/single/spring-cloud-consul.html)）没有提到这种解决方案，幸运的是这意味着它没有实现。Spring
    Cloud提供了一个基于Consul标签的分区机制。应用程序的默认区域可以通过`spring.cloud.consul.discovery.instanceZone`属性进行配置。它设置了在`spring.cloud.consul.discovery.defaultZoneMetadataName`属性中配置的标签，并传递给传入的值。默认的元数据标签名是`zone`。
- en: 'Let''s go back to the sample applications. I have extended all the configuration
    files with two profiles, `zone1` and `zone2`. Here''s the `bootstrap.yml` file
    for `order-service`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到示例应用程序。我将所有配置文件扩展了两个配置文件，`zone1`和`zone2`。这是`order-service`的`bootstrap.yml`文件：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are two running instances of every microservice registered in two different
    zones. After building the whole project with the `mvn clean install` command,
    you should launch the Spring Boot application with the active profile `zone1`
    or `zone2`, for example, `java -jar --spring.profiles.active=zone1 target/order-service-1.0-SNAPSHOT.jar`.
    You can see the full list of registered instances tagged with the zone in the
    Nodes section. The view from the Consul dashboard is visible in the following
    screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务在两个不同的区域都有两个运行实例。在用`mvn clean install`命令构建整个项目后，你应该使用`zone1`或`zone2`活动配置启动Spring
    Boot应用程序，例如，`java -jar --spring.profiles.active=zone1 target/order-service-1.0-SNAPSHOT.jar`。您可以在节点部分查看带有区域标签的注册实例的完整列表。Consul仪表板的观点在以下屏幕快照中可见：
- en: '![](img/a1a34b42-27d3-46d1-814b-fc20ffd77a3e.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1a34b42-27d3-46d1-814b-fc20ffd77a3e.png)'
- en: The last element of our architecture is an API gateway based on Zuul. We also
    run two instances of `gateway-service` in different zones. We would like to omit
    registration in Consul and allow only a configuration to be fetched, which is
    used by the Ribbon client while performing load balancing. Here's the fragment
    of the `bootstrap.yml` file of `gateway-service`. Registration has been disabled
    by setting the properties `spring.cloud.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们架构的最后一部分是一个基于Zuul的API网关。我们还在不同的区域运行两个`gateway-service`实例。我们想省略在Consul中的注册，并只允许获取配置，该配置由Ribbon客户端在执行负载均衡时使用。以下是`gateway-service`的`bootstrap.yml`文件的一个片段。通过设置属性`spring.cloud.
- en: consul.discovery.register` and `spring.cloud.consul.discovery.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: consul.discovery.register`和`spring.cloud.consul.discovery.
- en: 'registerHealthCheck` to `false`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: registerHealthCheck`设置为`false`：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Client settings customization
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端设置自定义
- en: 'The Spring Cloud Consul client may be customized through the properties in
    the configuration file. Some of those settings have already been introduced in
    the previous sections in this chapter. Other useful settings have been listed
    in the following table. All of them are prefixed with `spring.cloud.consul.discovery`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过配置文件中的属性自定义Spring Cloud Consul客户端。本章前面部分已经介绍了其中一些设置。其他有用设置列在下面的表格中。它们都带有`spring.cloud.consul.discovery`前缀：
- en: '| **Property** | **Default value** | **Description** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **默认值** | **描述** |'
- en: '| `enabled` | `true` | It sets whether Consul discovery is enabled or disabled
    for an application |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `enabled` | `true` | 它设置应用程序是否启用Consul发现 |'
- en: '| `failFast` | `true` | It throws exceptions during service registration if
    `true`; otherwise, it logs warnings |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `failFast` | `true` | 如果为真，则在服务注册时抛出异常；否则，记录警告 |'
- en: '| `hostname` | - | It sets the hostname of the instance when registering in
    Consul |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `hostname` | - | 它在Consul中注册实例时设置实例的主机名 |'
- en: '| `preferIpAddress` | `false` | It forces an application to send its IP address
    instead of the hostname during registration |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `preferIpAddress` | `false` | 它强制应用程序在注册时发送其IP地址，而不是主机名 |'
- en: '| `scheme` | `http` | It sets whether the service is available under HTTP or
    HTTPS protocol |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `scheme` | `http` | 它设置服务是否通过HTTP或HTTPS协议可用 |'
- en: '| `serverListQueryTags` | - | It allows filtering services by a single tag
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `serverListQueryTags` | - | 它允许通过单个标签过滤服务 |'
- en: '| `serviceName` | - | It overrides the service name, which by default takes
    from the property `spring.application.name` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `serviceName` | - | 它覆盖了服务名称，默认情况下从`spring.application.name`属性中获取 |'
- en: '| `tags` | - | It sets the list tags with values to use when registering the
    service |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `tags` | - | 它设置在注册服务时使用的标签及其值的列表 |'
- en: Running in clustered mode
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行在集群模式下
- en: Until now, we were always launching a single, standalone instance of Consul.
    As far as this is a suitable solution in development mode, it is not enough for
    a production. There, we would like to have a scalable, production-grade service
    discovery infrastructure, consisting of some nodes working together inside the
    cluster. Consul provides support for clustering based on a gossip protocol used
    for communication between members and a Raft consensus protocol for a leadership
    election. I wouldn't like to go into the details of that process, but some basics
    about Consul architecture should be clarified.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们总是启动一个独立的Consul实例。虽然在开发模式下这是一个合适的解决方案，但在生产环境中是不够的。在那里，我们希望能够有一个可扩展的、生产级别的服务发现基础设施，由一些在集群内部协同工作的节点组成。Consul提供了基于八卦协议的集群支持，该协议用于成员之间的通信，以及基于Raft共识协议的领导选举。我不想深入了解这个过程，但关于Consul架构的一些基本知识应该澄清。
- en: We have already talked about Consul agent, but what it is exactly and what is
    its role weren't explained. An agent is the long-running daemon on every member
    of the Consul cluster. It may be run in either client or server mode. All agents
    are responsible for running checks and keeping services registered, in different
    nodes and in sync, globally.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈论过Consul代理，但它到底是什么以及它的作用并没有被解释。代理是Consul集群上每个成员上的长运行守护进程。它可以在客户端或服务器模式下运行。所有代理都负责运行检查并保持服务在不同节点上注册并全局同步。
- en: 'Our main goal in this section is to set up and configure the Consul cluster
    using its Docker image. First, we will start the container, which acts as a leader
    of the cluster. There is only one difference in the currently used Docker command
    than for the standalone Consul server. We have set the environment variable `CONSUL_BIND_INTERFACE=eth0`
    in order to change the network address of the cluster agent from `127.0.0.1` to
    the one available for other member containers. My Consul server is now running
    at the internal address `172.17.0.2`. To check out what your address is (it should
    be the same) you may run the command `docker logs consul`. The appropriate information
    is logged just after container startup:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中的主要目标是使用Docker镜像设置和配置Consul集群。首先，我们将启动一个容器，它作为集群的领导者。与独立的Consul服务器相比，当前使用的Docker命令只有一个区别。我们设置了环境变量`CONSUL_BIND_INTERFACE=eth0`，以将集群代理的网络地址从`127.0.0.1`更改为对其他成员容器可用的地址。我的Consul服务器现在在内部地址`172.17.0.2`上运行。要查看您的地址（它应该相同），您可以运行命令`docker
    logs consul`。容器启动后立即记录了适当的信息：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Knowledge of that address is very important, since now we have to pass it to
    every member container startup command as a cluster join parameter. We also bind
    it to all interfaces by setting `0.0.0.0` as a client address. Now, we may easily
    expose the client agent API outside the container using the `-p` parameter:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这个地址非常重要，因为现在我们必须将其作为集群加入参数传递给每个成员容器的启动命令。通过将`0.0.0.0`设置为客户端地址，我们还将其绑定到所有接口。现在，我们可以使用`-p`参数轻松地将客户端代理API暴露在容器外：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After running two containers with Consul agent, you may check out the full
    list of cluster members by executing the following command on the leader''s container:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个容器中运行Consul代理后，您可以在领导者的容器上执行以下命令，以查看集群成员的完整列表：
- en: '![](img/62ad9459-eb41-4770-8035-f2a23dee1e42.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62ad9459-eb41-4770-8035-f2a23dee1e42.png)'
- en: 'The Consul server agent is exposed on the `8500` port, while member agents
    on ports `8501` and `8502`. Even if the microservice instance registers itself
    to a member agent, it is visible to all members of a cluster:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Consul服务器代理暴露在`8500`端口上，而成员代理在`8501`和`8502`端口上。即使微服务实例将自己注册到一个成员代理上，它对集群中的所有成员都是可见的：
- en: '![](img/0003cbac-7ff3-4286-ac65-3c13cf98a2ad.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0003cbac-7ff3-4286-ac65-3c13cf98a2ad.png)'
- en: 'We may easily change the default Consul agent address for the Spring Boot application
    by changing the configuration properties:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改配置属性轻松地更改Spring Boot应用程序的默认Consul代理地址：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Distributed configuration
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式配置
- en: 'An application with Spring Cloud Consul Config library in the classpath fetches
    configuration from the Consul key/value store during the bootstrap phase. That
    is, by default, stored in the `/config` folder. When we are creating a new key
    first, we have to set a folder path. That path is then used for identifying the
    key and assigning it to the application. Spring Cloud Config tries to resolve
    properties stored in the folder based on the application name and active profiles.
    Assuming we have the `spring.application.name` property set to `order-service`
    in the `bootstrap.yml` file and the `spring.profiles.active` running argument
    set to `zone1`, it tries to locate the property sources in the following order:
    `config/order-service,zone1/`, `config/order-service/`, `config/application,zone1/`,
    `config/application/`. All folders with the prefix `config/application` are the
    default configuration dedicated to all the applications that do not have service-specific
    property sources.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Consul Config库在类路径中的应用程序在引导阶段从Consul键/值存储中获取配置。也就是说，默认存储在`/config`文件夹中。当我们创建一个新的键时，我们必须设置一个文件夹路径。然后，该路径用于识别键并将它分配给应用程序。Spring
    Cloud Config尝试根据应用程序名称和活动配置文件解析存储在文件夹中的属性。假设我们在`bootstrap.yml`文件中将`spring.application.name`属性设置为`order-service`，并且将`spring.profiles.active`运行参数设置为`zone1`，它将按照以下顺序查找属性源：`config/order-service,zone1/`,
    `config/order-service/`, `config/application,zone1/`, `config/application/`。所有前缀为`config/application`的文件夹都是为所有没有服务特定属性源的应用程序提供的默认配置。
- en: Managing properties in Consul
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Consul中的属性
- en: 'The most comfortable way to add a single key to Consul is through its web dashboard.
    The other way is by using the `/kv` HTTP endpoint, which has been already described
    at the beginning of this chapter. When using a web console, you have to go to
    the section KEY/VALUE. Then, you may view all the currently existing keys and
    also create a new one by providing its full path and value, in any format. That
    feature is visualized in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个键添加到Consul中最舒适的方式是通过它的网页控制台。另一种方式是使用`/kv` HTTP端点，这在章节的开始部分已经描述过了。当使用网页控制台时，你必须去到KEY/VALUE部分。然后，你可以查看所有当前存在的键，也可以通过提供其完整路径和值（任何格式）来创建一个新的。这个功能在下面的截图中可视化：
- en: '![](img/f0b420c2-a7db-4403-9a36-107311c5d2ac.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0b420c2-a7db-4403-9a36-107311c5d2ac.png)'
- en: 'Every single key may be updated or deleted:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个键可能被更新或删除：
- en: '![](img/85ffa69a-6da9-49aa-b8fc-ef419d3a28ce.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85ffa69a-6da9-49aa-b8fc-ef419d3a28ce.png)'
- en: To access a sample application that uses a property source stored in Consul,
    you should switch to the branch configuration in the same repository as the previous
    sample. I have created keys, `server.port` and `spring.cloud.consul.discovery.instanceZone`,
    for every microservice instead of defining it in the `application.yml` or `bootstrap.yml`
    files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问使用存储在Consul中的属性源的示例应用程序，你应该切换到与之前示例相同的仓库中的配置分支。我为每个微服务创建了键`server.port`和`spring.cloud.consul.discovery.instanceZone`，而不是在`application.yml`或`bootstrap.yml`文件中定义它。
- en: Client customization
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端自定义
- en: 'The Consul Config client may be customized with the following properties, which
    are prefixed with `spring.cloud.consul.config`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Consul Config客户端可以通过以下属性进行自定义，这些属性前面带有`spring.cloud.consul.config`前缀：
- en: '`enabled`: By setting this property to `false`, you may disable Consul Config.
    It is useful if you include `spring-cloud-starter-consul-all`, which enables both
    discovery and distributed configuration.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enabled`：通过将此属性设置为`false`，您可以禁用Consul Config。如果您包含`spring-cloud-starter-consul-all`，它启用了发现和分布式配置，这个属性很有用。'
- en: '`fail-fast`: This sets whether to throw exceptions during configuration lookup
    or log warnings in case of connection failure. Setting it to `true` allows the
    application to continue startup normally.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail-fast`：这设置了在配置查找期间是否抛出异常或连接失败时是否记录警告。设置为`true`可以让应用程序正常启动。'
- en: '`prefix`: This sets the base folder for all the configuration values. By default,
    it is `/config`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefix`：这设置了所有配置值的基础文件夹。默认是`/config`。'
- en: '`defaultContext`: This sets the folder name used by all applications that do
    not have a specific configuration. By default, it is `/application`. For example,
    if you override it to `app`, the properties should be searched in the folder `/config/apps`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultContext`：这设置了所有没有特定配置的应用程序使用的文件夹名称。默认是`/application`。例如，如果你重写它为`app`，属性应该在`/config/apps`文件夹中搜索。'
- en: '`profileSeparator`: By default, a profile is separated with an application
    name using a comma. That property allows you to override the value of that separator.
    For example, if you set it to `::`, you should create the folder `/config/order-service::zone1/`.
    Here''s an example:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`profileSeparator`：默认情况下，一个配置文件使用逗号和一个应用名称进行分隔。这个属性允许你覆盖那个分隔符的值。例如，如果你设置它为`::`，你应该创建文件夹`/config/order-service::zone1/`。这是一个例子：'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sometimes, you would like to store a blob of properties created in a YAML or
    Properties format, in contrast to individual key/value pairs. In that case, you
    should set the `spring.cloud.consul.config.format` property to `YAML` or `PROPERTIES`.
    Then, the application would look for configuration properties located inside a
    folder with the data key, for example, `config/order-service,zone1/data`, `config/order-service/data`,
    `config/application,zone1/data`, or `config/application/data`. The default data
    key may be changed using the `spring.cloud.consul.config.data-key` property.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望将创建在YAML或Properties格式的属性块，与单独的键/值对相对比。在这种情况下，你应该将`spring.cloud.consul.config.format`属性设置为`YAML`或`PROPERTIES`。然后，应用程序会在带有数据键的文件夹中查找配置属性，例如，`config/order-service,zone1/data`，`config/order-service/data`，`config/application,zone1/data`或`config/application/data`。默认数据键可以通过`spring.cloud.consul.config.data-key`属性进行更改。
- en: Watching configuration changes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察配置更改
- en: 'The sample that has been discussed in the previous section loads the configuration on
    startup of the application. If you would like that configuration to be reloaded,
    you should send an HTTP `POST` to the `/refresh` endpoint. In order to examine
    how such a refresh would work for our application, we modify the fragment of application
    code responsible for creating some test data. Until now, it has been provided
    as a repository, `@Bean`, with some hardcoded in-memory objects. Take a look at
    the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分讨论的示例中，应用程序启动时加载配置。如果你希望重新加载配置，你应该向`/refresh`端点发送HTTP `POST`请求。为了查看我们应用程序的刷新如何工作，我们修改了负责创建一些测试数据的应用程序代码片段。到目前为止，它作为带有硬编码内存对象的存储库（`@Bean`）提供。请看以下代码：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our goal is to move the code visible here to the configuration store using
    the Consul key/value feature. To achieve this, we have to create three keys per
    object, with names `id`, `name`, and `type`. The configuration is loaded from
    the properties with the `repository` prefix:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将此处可见的代码移动到使用Consul键/值功能的配置存储中。为了实现这一点，我们必须为每个对象创建三个键，键名分别为`id`、`name`和`type`。配置从带有`repository`前缀的属性加载：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to define the appropriate keys for each service using the
    Consul web dashboard. Here''s the sample configuration for the list consisting
    of `Customer` objects. The list is initialized on application startup:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在Consul web仪表板上为每个服务定义适当的键。以下是为包含`Customer`对象的列表的示例配置。列表在应用程序启动时初始化：
- en: '![](img/bffd5327-fdb1-4ea1-9e4f-8dd99169c30a.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bffd5327-fdb1-4ea1-9e4f-8dd99169c30a.png)'
- en: 'You may change the value of each property. The update event would be automatically
    sent to application thanks to Consul''s ability to watch a key prefix. If there
    is a new configuration data, the refresh event is published to the queue. All
    queues and exchanges are created on application startup by Spring Cloud Bus, which
    is included in the project as a dependency of `spring-cloud-starter-consul-all`.
    If your application receives such an event, it prints the following information
    in logs:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改每个属性的值。由于Consul具有监视键前缀的能力，更新事件会自动发送到应用程序。如果有新的配置数据，则会发布刷新事件到队列中。所有队列和交换机都在应用程序启动时由Spring
    Cloud Bus创建，该组件作为`spring-cloud-starter-consul-all`项目的依赖项包含在内。如果你的应用程序接收到此类事件，它将在日志中打印以下信息：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using Spring Cloud Zookeeper
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Zookeeper
- en: 'Spring Cloud supports various products used as a part of the microservices
    architecture. You can find this out when reading this chapter where Consul has
    been compared with Eureka as a discovery tool, and with Spring Cloud Config as
    a distributed configuration tool. Zookeeper is another solution that might serve
    as an alternative choice to those listed previously. As with Consul, it can be
    used for both service discovery and distributed configuration. To enable Spring
    Cloud Zookeeper in the project, you should include the `spring-cloud-starter-zookeeper-discovery`
    starter for the service discovery feature, or `spring-cloud-starter-zookeeper-config`
    for the configuration server feature. Alternatively, you may declare a `spring-cloud-starter-zookeeper-all`
    dependency that activates all functionalities for the application. Don''t forget
    to include `spring-boot-starter-web`, which is still required to provide web functionality:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud支持各种作为微服务架构一部分的产品。在阅读本章时，你可以了解到Consul作为发现工具与Eureka进行了比较，与Spring
    Cloud Config作为分布式配置工具进行了比较。Zookeeper是另一个可能作为前面列出的选择之一替代的解决方案。与Consul一样，它可用于服务发现和分布式配置。为了在项目中启用Spring
    Cloud Zookeeper，你应该包含用于服务发现功能的`spring-cloud-starter-zookeeper-discovery`启动器，或用于配置服务器功能的`spring-cloud-starter-zookeeper-config`。或者，您可以声明一个`spring-cloud-starter-zookeeper-all`依赖项，为应用程序激活所有功能。不要忘记包含`spring-boot-starter-web`，它仍然需要提供web功能：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Zookeeper connection settings are auto-configured. By default, the client tries
    to connect to `localhost:2181`. In order to override it, you should define the
    `spring.cloud.zookeeper.connect-string` property with the current server network
    address:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Zookeeper连接设置是自动配置的。默认情况下，客户端尝试连接到`localhost:2181`。为了覆盖它，你应该定义`spring.cloud.zookeeper.connect-string`属性，并使用当前服务器网络地址：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As with Spring Cloud Consul, Zookeeper supports all the most popular communication
    libraries provided by Spring Cloud Netflix, such as Feign, Ribbon, Zuul, or Hystrix.
    Before we start working on the sample implementation, first we have to start the
    Zookeeper instance.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Spring Cloud Consul一样，Zookeeper支持Spring Cloud Netflix提供的所有最受欢迎的通信库，如Feign、Ribbon、Zuul或Hystrix。在我们开始样本实现之前，首先必须启动Zookeeper实例。
- en: Running Zookeeper
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Zookeeper
- en: 'As you probably guessed, I''m going to launch Zookeeper on the local machine
    using its Docker image. The following command starts the Zookeeper server instance.
    Since it <q>fails fast</q>, the best approach is to always restart it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能会猜到的，我将使用Docker镜像在本地机器上启动Zookeeper。下面的命令启动了Zookeeper服务器实例。由于它<q>快速失败</q>，最好的方法总是重新启动它：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In contrast to previously discussed solutions in this area, such as Consul
    or Eureka, Zookeeper doesn''t provide a simple RESTful API or a web management
    console that allows us to easily manage it. It has an official API binding for
    Java and C. We may also use its command line interface, which can be easily started
    within the Docker container. The command visible here starts the container with
    the command line client, and links it to the Zookeeper server container:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与本领域之前讨论的解决方案，如Consul或Eureka相比，Zookeeper没有提供简单的RESTful API或一个web管理控制台，使我们能够轻松管理它。它有一个官方的API绑定用于Java和C。我们还可以使用其命令行界面，这可以在Docker容器内轻松启动。这里显示的命令使用命令行客户端启动容器，并将其连接到Zookeeper服务器容器：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Zookeeper CLI allows for performing some useful operations, such as the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Zookeeper CLI允许执行一些有用的操作，如下所示：
- en: '**Creating znodes**: To create a znode with the given path, use the command
    `create /path /data`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建znode**：要使用给定路径创建znode，请使用命令`create /path /data`。'
- en: '**Getting data**: The command `get /path` returns the data and metadata associated
    with the znode.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取数据**：命令`get /path`返回与znode相关的数据和元数据。'
- en: '**Watching znode for changes**: This shows a notification if znode or znode''s
    children data changes. Watching can only be set with the `get` command.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控znode的变化**：如果znode或znode的子节点数据发生变化，这将显示一个通知。监控只能与`get`命令一起设置。'
- en: '**Setting data**: To set znode data, use the command `set /path /data`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置数据**：要设置znode数据，请使用命令`set /path /data`。'
- en: '**Creating children of a znode**: This command is similar to that used for
    creating a single znode. The only difference is that the path of the child znode
    includes the parent path `create /parent/path/subnode/path /data`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建znode的子节点**：这个命令与创建单个znode的命令类似。唯一的区别是子znode的路径包括了父路径`create /parent/path/subnode/path
    /data`。'
- en: '**Listing children of a znode**: This may be displayed using the `ls /path`
    command.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列出znode的子节点**：这可以通过`ls /path`命令来显示。'
- en: '**Checking status**: This may be checked out with the command `stat /path`.
    Status describes the metadata of a specified znode, like timestamp or version
    number.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查状态**：这可以通过命令`stat /path`来查看。状态描述了指定znode的元数据，如时间戳或版本号。'
- en: '**Removing/deleting a znode**: The command `rmr /path` removes the znode with
    all its children.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除/删除znode**：命令`rmr /path`删除了所有子节点的znode。'
- en: In that fragment, the term *znode* has appeared for the first time. When storing
    data, Zookeeper uses a tree structure, where each node is called a **znode**.
    The names of those znodes are based on the path taken from the root node. Each
    node has a name. It can be accessed using the absolute path that begins from the
    root node. This concept is similar to Consul folders, and has been used for creating
    keys in the key/value store.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个片段中，术语*znode*第一次出现。在存储数据时，Zookeeper使用树状结构，每个节点称为**znode**。这些znode的名称基于从根节点开始的路径。每个节点都有一个名字。可以使用从根节点开始的绝对路径来访问它。这个概念与Consul文件夹类似，并已用于在键/值存储中创建键。
- en: Service discovery
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: The most popular Java client library for Apache Zookeeper is Apache Curator.
    It provides an API framework and utilities to make using Apache Zookeeper much
    easier. It also includes recipes for common-use cases and extensions, such as
    service discovery or Java 8 asynchronous DSL. Spring Cloud Zookeeper leverages
    one such extension for service discovery implementation. The usage of the Curator
    library by Spring Cloud Zookeeper is completely transparent for the developer,
    so I wouldn't like to describe it in more detail here.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的Apache Zookeeper的Java客户端库是Apache Curator。它提供了一个API框架和工具，使使用Apache Zookeeper变得更容易。它还包括常见用例和扩展的食谱，例如服务发现或Java
    8异步DSL。Spring Cloud Zookeeper利用了其中一个扩展来实现服务发现。Curator库在Spring Cloud Zookeeper中的使用对开发者完全透明，因此我在这里不想再详细描述。
- en: Client implementation
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端实现
- en: The usage on the client side is the same as for other Spring Cloud projects
    related to service discovery. The application main class, or `@Configuration`
    class, should be annotated with `@EnableDiscoveryClient`. The default service
    name, instance ID, and port are taken from `spring.application.name`, the Spring
    Context ID, and `server.port`, respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的使用与其他与服务发现相关的Spring Cloud项目相同。应用程序的主类或`@Configuration`类应使用`@EnableDiscoveryClient`注解。默认的服务名称、实例ID和端口分别从`spring.application.name`、Spring上下文ID和`server.port`获取。
- en: Sample application source code is available in the GitHub repository at [https://github.com/piomin/sample-spring-cloud-zookeeper.git](https://github.com/piomin/sample-spring-cloud-zookeeper.git).
    Fundamentally, it is no different than the sample system introduced for Consul,
    other than the dependency on Spring Cloud Zookeeper Discovery. It still consists
    of four microservices, which communicate with each other. Now, after cloning the
    repository, build it with the `mvn clean install` command. Then, run every service
    with an active profile name using `java -jar` command, for example, `java -jar
    --spring.profiles.active=zone1 order-service/target/order-service-1.0-SNAPSHOT.jar`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序的源代码可以在GitHub仓库中找到，网址为[https://github.com/piomin/sample-spring-cloud-zookeeper.git](https://github.com/piomin/sample-spring-cloud-zookeeper.git)。本质上，它与为Consul引入的示例系统没有区别，除了依赖Spring
    Cloud Zookeeper发现。它仍然由四个微服务组成，它们相互通信。现在，在克隆仓库后，使用`mvn clean install`命令来构建它。然后，使用`java
    -jar`命令运行每个服务的活动配置文件名称，例如，`java -jar --spring.profiles.active=zone1 order-service/target/order-service-1.0-SNAPSHOT.jar`。
- en: 'You may see the list of registered services and instances by using the CLI
    commands `ls` and `get`. Spring Cloud Zookeeper, by default, registers all instances
    in the `/services` root folder. It may be overridden with the `spring.cloud.zookeeper.discovery.root`
    property. You may check out a list of currently registered services by using the
    Docker container with the command-line client:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用CLI命令`ls`和`get`来查看已注册服务和实例的列表。Spring Cloud Zookeeper默认将在`/services`根目录下注册所有实例。这可以通过设置`spring.cloud.zookeeper.discovery.root`属性来更改。您可以通过使用带有命令行客户端的Docker容器来查看当前注册的服务列表：
- en: '![](img/fdbd83d4-a14c-43f6-8302-5a761da38a9d.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdbd83d4-a14c-43f6-8302-5a761da38a9d.png)'
- en: Zookeeper dependencies
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zookeeper依赖项
- en: Spring Cloud Zookeeper has one additional feature, called **Zookeeper dependencies**.
    Dependencies are to be understood as the other applications registered in Zookeeper,
    which are called via the Feign client or the Spring `RestTemplate`. These dependencies
    may be provided as properties of the application. The functionality is enabled
    through auto-configuration after you include the `spring-cloud-starter-zookeeper-discovery`
    starter to the project. It may be disabled by setting the `spring.cloud.zookeeper.dependency.enabled`
    property to `false`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Zookeeper具有一项额外的功能，称为**Zookeeper依赖项**。依赖项是指在Zookeeper中注册的其他应用程序，它们通过Feign客户端或Spring
    `RestTemplate`进行调用。这些依赖项可以作为应用程序的属性提供。在包含`spring-cloud-starter-zookeeper-discovery`启动器到项目后，通过自动配置启用此功能。通过将`spring.cloud.zookeeper.dependency.enabled`属性设置为`false`可以禁用它。
- en: 'The configuration of the Zookeeper Dependency mechanism is provided with `spring.cloud.zookeeper.dependencies.*`
    properties. Here''s the fragment of the `bootstrap.yml` file from `order-service`.
    This service integrates with all other available services:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Zookeeper依赖机制的配置由`spring.cloud.zookeeper.dependencies.*`属性提供。以下是`order-service`中的`bootstrap.yml`文件的一个片段。这个服务与所有其他可用服务集成：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s take a closer look at the preceding configuration. The root property
    of every called service is the alias, which may then be used as the service name
    by the Feign client or `@LoadBalanced RestTemplate`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看前面的配置。每个调用服务的主属性是别名，然后可以被Feign客户端或`@LoadBalanced RestTemplate`用作服务名称：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The next very important field in the configuration is the path. It sets the
    path under which the dependency is registered in Zookeeper. So, if that property
    has the value `customer-service`, it means Spring Cloud Zookeeper tries to look
    up the appropriate service znode under the path `/services/customer-service`.
    There are some other properties that may customize the behavior of the client.
    One of them is `loadBalancerType`, used for applying the load balancing strategy.
    We can choose between three available strategies—`ROUND_ROBIN`, `RANDOM`, and
    `STICKY`. I also set the `required` property to `true` for every service mapping. Now,
    if your application can’t detect the required dependency during boot time, it
    fails to start. Spring Cloud Zookeeper dependencies also allow managing API versions
    (the properties `contentTypeTemplate` and `versions`), and request headers (the
    `headers` property).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中的下一个非常重要的字段是路径。它设置了在Zookeeper中注册依赖项的路径。所以，如果该属性的值为`customer-service`，这意味着Spring
    Cloud Zookeeper尝试在路径`/services/customer-service`下查找适当的服务znode。还有一些其他属性可以自定义客户端的行为。其中之一是`loadBalancerType`，用于应用负载均衡策略。我们可以选择三种可用的策略——`ROUND_ROBIN`、`RANDOM`和`STICKY`。我还为每个服务映射设置了`required`属性为`true`。现在，如果您的应用程序在启动时无法检测到所需的依赖项，它将无法启动。Spring
    Cloud Zookeeper依赖项还允许管理API版本（`contentTypeTemplate`和`versions`属性）和请求头（`headers`属性）。
- en: By default, Spring Cloud Zookeeper enables `RestTemplate` for communication
    with dependencies. In the sample application available in branch dependencies
    ([https://github.com/piomin/sample-spring-cloud-zookeeper/tree/dependencies](https://github.com/piomin/sample-spring-cloud-zookeeper/tree/dependencies)),
    we use the Feign client instead of `@LoadBalanced RestTemplate`. In order to disable
    that feature, we should set the property `spring.cloud.zookeeper.dependency.resttemplate.enabled`
    to `false`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Cloud Zookeeper为与依赖项的通信启用`RestTemplate`。在可用的分支依赖中([https://github.com/piomin/sample-spring-cloud-zookeeper/tree/dependencies](https://github.com/piomin/sample-spring-cloud-zookeeper/tree/dependencies))，我们使用Feign客户端而不是`@LoadBalanced
    RestTemplate`。为了禁用该功能，我们应该将属性`spring.cloud.zookeeper.dependency.resttemplate.enabled`设置为`false`。
- en: Distributed configuration
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式配置
- en: 'Configuration management with Zookeeper is pretty similar to that described
    for Spring Cloud Consul Config. By default, all the property sources are stored
    in the `/config` folder (or znode in Zookeeper nomenclature). Let me point it
    out one more time. Assuming we have the `spring.application.name` property set
    to `order-service` in the `bootstrap.yml` file, and the `spring.profiles.active`
    running argument set to `zone1`, it tries to locate the property sources in the
    following order: `config/order-service,zone1/`, `config/order-service/`, `config/application,zone1/`,
    `config/application/`. Properties stored in the folder with the prefix `config/application`
    in the namespace are available for all applications that use Zookeeper for distributed
    configuration.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理使用Zookeeper与Spring Cloud Consul Config中描述的配置非常相似。默认情况下，所有的属性源都存储在`/config`文件夹中（在Zookeeper的术语中叫做znode）。让我再强调一次。假设我们在`bootstrap.yml`文件中将`spring.application.name`属性设置为`order-service`，并且将`spring.profiles.active`运行参数设置为`zone1`，它将按照以下顺序尝试定位属性源：`config/order-service,zone1/`、`config/order-service/`、`config/application,zone1/`、`config/application/`。存储在以`config/application`为前缀的命名空间中的文件夹中的属性，可供所有使用Zookeeper进行分布式配置的应用程序使用。
- en: 'To access the sample application, you need to switch to the branch configuration
    in the [https://github.com/piomin/sample-spring-cloud-zookeeper.git](https://github.com/piomin/sample-spring-cloud-zookeeper.git)
    repository. The configuration defined in the local `application.yml` or `bootstrap.yml`
    file, visible here, has now been moved to Zookeeper:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问示例应用程序，你需要切换到[https://github.com/piomin/sample-spring-cloud-zookeeper.git](https://github.com/piomin/sample-spring-cloud-zookeeper.git)仓库的分支配置。这里可见的本地`application.yml`或`bootstrap.yml`文件中定义的配置，现在已移动到Zookeeper中：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The required znodes have to be created using CLI. Here''s the list of Zookeeper
    commands that create znodes with the given path. I have used the `create /path
    /data` command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用CLI创建所需的znode。以下是创建给定路径的znode的Zookeeper命令列表。我使用了`create /path /data`命令：
- en: '![](img/7494c667-24b5-4a33-aef6-fbb27e519e61.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7494c667-24b5-4a33-aef6-fbb27e519e61.png)'
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I have guided you through the main features of two Spring Cloud
    projects—Consul and Zookeeper. I haven't focused only on Spring Cloud functionalities,
    but have also given you the instructions on how to start, configure, and maintain
    instances of its tools. We have discussed even more advanced scenarios, such as
    setting up a cluster consisting of numerous members using Docker. There, you had
    a chance to see the true power of Docker as a development tool. It allowed us
    to initialize a cluster that consists of three members just by using three simple
    commands, without any additional configuration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我引导你了解了两个Spring Cloud项目——Consul和Zookeeper的主要功能。我不仅关注Spring Cloud的功能，还向你讲解了如何启动、配置和维护其工具的实例。我们甚至讨论了更高级的场景，比如使用Docker设置由多个成员组成的集群。在那里，你有机会看到Docker作为开发工具真正的力量。它允许我们仅通过三个简单命令初始化一个由三个成员组成的集群，而无需任何其他配置。
- en: Consul seems to be an important alternative to Eureka as a discovery server
    when using Spring Cloud. I cannot say the same about Zookeeper. As you have probably
    noticed, I have written much more about Consul than Zookeeper. Also, Spring Cloud
    treats Zookeeper as a second choice. It still does not have a zoning mechanism
    or watching capability for configuration changes that are implemented, in contrast
    to Spring Cloud Consul. You shouldn't be surprised by this. Consul is a modern
    solution designed in order to meet needs of the newest architectures, such as
    microservices-based systems, while Zookeeper is a key/value store adopted as a
    service discovery tool for applications running in a distributed environment.
    However, it is worth considering this tool if you use an Apache Foundation stack
    in your system. Thanks to that, you may take advantage of integration between
    Zookeeper and other Apache components, such as Camel or Karaf, and easily discover
    services created using the Spring Cloud framework.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Spring Cloud时，Consul似乎是Eureka的一个重要的发现服务器替代品。对于Zookeeper我无法这么说。正如你可能已经注意到的，我写了很多关于Consul而不是Zookeeper的内容。此外，Spring
    Cloud将Zookeeper视为第二选择。它仍然没有实现区域机制或监视配置变化的能力，这与Spring Cloud Consul不同。你不应该对此感到惊讶。Consul是为满足最新架构的需求而设计的现代解决方案，如基于微服务的系统，而Zookeeper是一个作为分布式环境中运行的应用程序的服务发现工具的关键/值存储。然而，如果你在你的系统中使用Apache
    Foundation堆栈，考虑这个工具是有价值的。借助这一点，你可以利用Zookeeper与其他Apache组件（如Camel或Karaf）的集成，并轻松发现使用Spring
    Cloud框架创建的服务。
- en: To conclude, after reading this chapter, you should be able to use the main
    features of Spring Cloud Consul and Spring Cloud Zookeeper in your microservice-based
    architecture. You should also know the major advantages and disadvantages of all
    available discovery and configuration tools within Spring Cloud, in order to choose
    the most appropriate solution for your system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在阅读了本章之后，你应该能够在你基于微服务的架构中使用Spring Cloud Consul和Spring Cloud Zookeeper的主要功能。你还应该知道Spring
    Cloud中所有可用发现和配置工具的主要优点和缺点，以便为你的系统选择最合适的解决方案。
