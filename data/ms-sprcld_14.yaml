- en: Docker Support
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker支持
- en: We have already discussed the basics of microservices architecture and Spring
    Cloud projects in the first part of this book. In the second part, we looked at
    the most common elements of that architecture and we discussed how to implement
    them using Spring Cloud. So far, we have talked about some important topics related
    to microservice migration, such as centralized logging, distributed tracing, security,
    and automated testing. Now, as we are armed with that knowledge, we may proceed
    to the final part of the book, where we will discuss the real power of microservices
    as a cloud-native development approach. The ability to isolate applications from
    each other using containerization tools, implementing continuous deployment in
    the software delivery process and the ability to easily scale an application are
    things that all contribute to the rapidly growing popularity of microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书的第一部分讨论了微服务架构的基础和Spring Cloud项目。在第二部分中，我们研究了该架构的最常见元素，并讨论了如何使用Spring
    Cloud实现它们。到目前为止，我们已经谈到了与微服务迁移有关的一些重要主题，例如集中日志记录、分布式追踪、安全和自动化测试。现在，由于我们掌握了这些知识，我们可以继续讨论书的最后一部分，那里我们将讨论微服务作为一种云原生开发方法的真正力量。使用容器化工具将应用程序彼此隔离、在软件交付过程中实现持续部署以及轻松扩展应用程序的能力，所有这些都有助于微服务的迅速普及。
- en: 'As you will probably remember from earlier chapters, we have used Docker images
    for running third-party tools and solutions on the local machine. With that in
    mind, I would like to introduce you to the main concepts of Docker, such as its
    basic commands and use cases. This information will help you to run the samples
    presented in previous chapters. We will then discuss how to build images with
    our example Spring Boot application, as well as how to run them inside the containers
    on the local machine. We will use simple Docker commands for that, as well as
    more advanced tools such as the Jenkins server, which helps you to perform full,
    continuous delivery and enables a Continuous Integration process in your organization.
    Finally, we will introduce one of the most popular tools used for the automation
    of deploying, scaling, and managing containerized applications: Kubernetes. All
    of our examples will be run locally on a single-node Kubernetes cluster via Minikube.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得早前的章节，我们使用了Docker镜像在本地机器上运行第三方工具和解决方案。有了这个前提，我想向您介绍Docker的主要概念，比如其基本命令和使用场景。这些信息将帮助您运行前几章中呈现的示例。然后，我们将讨论如何使用我们的示例Spring
    Boot应用程序来构建镜像，以及如何在本地机器上的容器内运行它们。为此，我们将使用简单的Docker命令，以及更高级的工具，如Jenkins服务器，它帮助您执行完整的、持续的交付，并在您的组织中启用持续集成流程。最后，我们将介绍用于自动化部署、扩展和管理容器化应用程序的最受欢迎的工具之一：Kubernetes。我们所有的示例都将在通过Minikube运行的单节点Kubernetes集群上本地运行。
- en: 'The topics we will cover in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将覆盖的主题如下：
- en: Most useful Docker commands
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最有用的Docker命令
- en: Building Docker containers with Spring Boot microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot微服务构建Docker容器
- en: Running Spring Cloud components on Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker上运行Spring Cloud组件
- en: Continuous Integration/Continuous Delivery with Jenkins and Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jenkins和Docker进行持续集成/持续交付
- en: Deploying and running microservices on Minikube
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Minikube上部署和运行微服务
- en: Introducing Docker
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Docker
- en: Docker is a tool that helps you to create, deploy, and run applications by using
    containers. It was designed with the view to benefit both developers and system
    administrators in accordance with the DevOps philosophy. Docker helps to improve
    the software delivery process by solving some important concerns related with
    it. One of those concerns is the idea of immutable delivery, which is related
    to something called **it works for me**. It is especially important that a developer
    uses the same image for their tests as the one that is used in production when
    working in Docker. The only difference that should be seen is during configuration.
    Software delivery in an immutable delivery pattern seems to be particularly important
    for a microservices-based system as there are many applications deployed independently.
    Thanks to Docker, developers can now focus on writing code without worrying about
    the target OS (where the application would be launched). The operation can, therefore,
    use the same interface for deploying, starting, and maintaining all the applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一个帮助你通过容器创建、部署和运行应用程序的工具。它旨在根据 DevOps 哲学，同时造福开发人员和系统管理员。Docker 通过解决与软件交付相关的一些重要问题来改进软件交付过程。其中一个关注点是不可变交付的概念，这与所谓的“**对我有效**”有关。当在
    Docker 中工作时，尤其是重要的，开发者使用与生产中相同的镜像进行测试。唯一应该看到的不同是在配置上。在不可变交付模式下，软件交付对于微服务基础系统尤为重要，因为有很多独立部署的应用程序。多亏了
    Docker，开发者现在可以专注于编写代码，而不用担心目标操作系统（应用程序将被启动的地方）。因此，操作人员可以使用相同的接口来部署、启动和维护所有应用程序。
- en: There are also many other reasons for Docker's growing popularity. After all,
    the containerization idea is nothing new in the Information Technology world.
    Linux containers were introduced many years ago and have been a part of the kernel
    since 2008\. However, Docker has introduced several new things and solutions that
    other technologies haven't. Firstly, it provides a simple interface that allows
    you to easily package an application with dependencies to a single container before
    running it across different versions and implementations of Linux kernel. The
    container may be run locally or remotely on any Docker-enabled server, and every
    container starts in seconds. We can also easily run every command on it without
    going inside a container. In addition, the sharing and distribution mechanisms
    of Docker images allows developers to commit their changes and push and pull images
    in the same way they share source code, for example, using Git. Currently, almost
    all of the most popular software tools are published on Docker Hub as an image,
    some we have successfully used for running the tools required for our sample applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他原因促使 Docker 越来越受欢迎。毕竟，容器化概念在信息技术世界中并不是什么新事物。Linux 容器多年前就已经被引入，并自 2008
    年起成为内核的一部分。然而，Docker 引入了几项其他技术和解决方案，这是其他技术所没有的。首先，它提供了一个简单的接口，允许你轻松地将应用程序及其依赖打包到一个容器中，然后在不同的
    Linux 内核版本和实现中运行。容器可以在本地或远程的任何启用了 Docker 的服务器上运行，每个容器都在几秒钟内启动。我们还可以轻松地在容器外部对其执行每个命令。此外，Docker
    镜像的共享和分发机制允许开发人员像分享源代码一样提交更改、推送和拉取镜像，例如使用 Git。目前，几乎所有最受欢迎的软件工具都在 Docker 中心以镜像的形式发布，有些我们已经成功用于运行我们样本应用程序所需的工具。
- en: 'There are some essential definitions and elements that Docker architecture
    is composed of; the most important is a container. Containers run on a single
    machine and share the OS kernel with that machine. They contain everything you
    need to run specific software on your machine code: runtime, system tools, system
    libraries, and settings. Containers are created from the instructions found within
    a Docker image. Images are like a kind of recipe or template that defines the
    steps for installing and running necessary software on a container. Containers
    can also be compared to virtual machines as they have similar resource isolation
    and allocation benefits. However, they virtualize the operating system instead
    of the hardware, making them more portable and efficient than VMs. The following
    diagram illustrates the architectural differences between a Docker container and
    a virtual machine:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些基本的定义和元素构成了 Docker 架构，最重要的是容器。容器在单一机器上运行，并与该机器共享操作系统内核。它们包含运行特定软件所需的一切，包括运行时、系统工具、系统库和设置。容器是由
    Docker 镜像中发现的指令创建的。镜像就像一种食谱或模板，定义了在容器上安装和运行必要软件的步骤。容器还可以与虚拟机相比较，因为它们具有类似的资源隔离和分配优势。然而，它们虚拟化操作系统而不是硬件，使它们比虚拟机更便携、更高效。以下图表展示了
    Docker 容器与虚拟机之间的架构差异：
- en: '![](img/5c4496c4-a46a-4400-a77d-9e5fff6d99ca.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c4496c4-a46a-4400-a77d-9e5fff6d99ca.png)'
- en: All containers are launched on a physical or virtual machine that is called
    a **Docker host**. Docker hosts, in turn, run a Docker daemon, which listens for
    the commands sent by the Docker client through a Docker API. Docker clients may
    be command-line tools or other software such as Kinematic. Besides running a daemon,
    a Docker host is responsible for storing cached images and containers created
    from those images. Every image is built from a set of layers. Each layer contains
    only the incremental differences from the parent layer. Such an image is not small
    and needs to be stored elsewhere. This place is called the **Docker registry**.
    You may create your own private repository or use the existing public repository
    available on the web. The most popular repository is Docker Hub, which contains
    almost all of the required images.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有容器都部署在一个称为**Docker 主机**的物理或虚拟机上。Docker 主机反过来运行一个 Docker 守护进程，该守护进程通过 Docker
    API 监听 Docker 客户端发送的命令。Docker 客户端可能是命令行工具或其他软件，如 Kinematic。除了运行守护进程，Docker 主机还负责存储从这些镜像创建的缓存镜像和容器。每个镜像都是由一系列层构建的。每个层仅包含与父层相比的增量差异。这样的镜像不是很小，需要存储在其他地方。这个地方称为**Docker
    仓库**。你可以创建自己的私有仓库，或者使用网络上的现有公共仓库。最受欢迎的仓库是 Docker Hub，其中包含几乎所有必需的镜像。
- en: Installing Docker
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: 'Docker installation instructions for Linux are specific to each distribution
    ([https://docs.docker.com/install/#supported-platforms](https://docs.docker.com/install/#supported-platforms)).
    However, sometimes you have to run a Docker daemon after installation, which you
    can do by calling the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 下的 Docker 安装步骤因发行版而异([https://docs.docker.com/install/#supported-platforms](https://docs.docker.com/install/#supported-platforms))。然而，有时在安装后你不得不运行
    Docker 守护进程，你可以通过调用以下命令来实现：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this section, we will focus on instructions for the Windows platform. Generally,
    you have two available options when installing Docker Community Edition (CE) on
    Windows or Mac. The fastest and easiest way is by using Docker for Windows, which
    is available at [https://www.docker.com/docker-windows](https://www.docker.com/docker-windows).
    This is a native Windows application that provides an easy-to-use development
    environment for building, shipping, and running containerized applications. This
    is definitely the best option to utilize, because it uses Windows-native Hyper-V
    virtualization and networking. There is, however, one disadvantage—it is available
    only for Microsoft Windows 10 Professional or Enterprise 64-bit. Earlier versions
    of Windows should use Docker Toolbox, which can be downloaded here at, [https://docs.docker.com/toolbox/toolbox_install_windows/](https://docs.docker.com/toolbox/toolbox_install_windows/).
    This includes the Docker platform, the command-line with Docker Machine, Docker
    Compose, Kitematic, and VirtualBox. Note that you can’t run Docker Engine natively
    on Windows using Docker Toolbox because it uses Linux-specific kernel features.
    Instead, you must use the Docker Machine command (`docker-machine`), which creates
    a Linux VM on the local machine and runs it using Virtual Box. This VM may be
    accessed by your machine using a virtual address that is, by default, `192.168.99.100`.
    All previously discussed examples were integrating with the Docker tools available
    at that IP address.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注Windows平台的指令。通常，当你在Windows或Mac上安装Docker Community Edition (CE)时有两种可用的选项。最快最简单的方法是使用Docker
    for Windows，你可以在[https://www.docker.com/docker-windows](https://www.docker.com/docker-windows)找到它。这是一个原生的Windows应用程序，为构建、部署和运行容器化应用程序提供了易于使用的开发环境。这绝对是利用最好的选择，因为它使用了Windows本地的Hyper-V虚拟化和网络。然而，有一个缺点——它仅适用于Microsoft
    Windows 10专业版或企业版64位。更早的Windows版本应该使用Docker Toolbox，你可以在[https://docs.docker.com/toolbox/toolbox_install_windows/](https://docs.docker.com/toolbox/toolbox_install_windows/)下载到它。这包括Docker平台、带有Docker
    Machine的命令行、Docker Compose、Kitematic和VirtualBox。请注意，你不能在Windows上使用Docker Toolbox本地运行Docker
    Engine，因为它使用了特定于Linux的内核功能。相反，你必须使用Docker Machine命令（`docker-machine`），它在本机上创建一个Linux虚拟机，并使用Virtual
    Box运行它。这个虚拟机可以通过默认的虚拟地址`192.168.99.100`被你的机器访问。所有之前讨论的示例都是与那个IP地址上可用的Docker工具集成的。
- en: Commonly used Docker commands
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用的Docker命令
- en: 'After installing Docker Toolbox on Windows you should run Docker Quickstart
    Terminal. It does everything that is needed, including creating and starting Docker
    Machine and providing the command line interface. If you type a Docker command
    without any parameters, you should now be able to see the full list of available
    Docker client commands with descriptions. These are the types of commands we will
    look at:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上安装Docker Toolbox后，你应该运行Docker快速启动终端。它会完成所有需要做的事情，包括创建和启动Docker Machine以及提供命令行界面。如果你输入一个没有参数的Docker命令，你现在应该能够看到完整的可用Docker客户端命令列表及其描述。我们将要查看的就是这类命令：
- en: Running and stopping a container
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和停止容器
- en: List and remove container
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出并删除容器
- en: Pull and push images
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取和推送镜像
- en: Building an image
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建镜像
- en: Networking
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络配置
- en: Running and stopping a container
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和停止容器
- en: 'The first Docker command that is usually run after installation is `docker
    run`. As you may remember, this command is one of the most commonly used in previous
    examples. This command does two things: it pulls and downloads the image definition
    from the registry, in case it is not cached locally, and starts the container.
    There are many options that can be set for this command, which you can easily
    check by running `docker run --help`. Some options have one-letter shortcuts,
    which are often the most commonly used options. Option `–d` runs a container in
    the background, while `–i` keeps `stdin` open even if it is not attached. If your
    container has to expose any ports outside, you can use the activate option `–p`
    with the definition `<port_outside_container>:<port_inside_container>`. Some images
    need additional configurations that are usually done through environment variables
    that can be overridden with the `–e` option. It is also often useful to set a
    friendly name for the container using the `--name` option in order to run other
    commands on it with ease. Take a look at the example Docker command visible here.
    It starts the container with Postgres, creates a database user with a password,
    and exposes it on port `55432`. Now, the Postgres database is available at the
    address `192.168.99.100:55432`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后通常运行的第一个Docker命令是`docker run`。正如您可能记得的，这个命令在前面的示例中是最常用的命令之一。这个命令做两件事：它从注册表中拉取和下载镜像定义，以防它没有在本地缓存，然后启动容器。对这个命令可以设置很多选项，您可以通过运行`docker
    run --help`来轻松查看这些选项。有些选项有一个字母的简写，这些通常是使用最频繁的选项。选项`–d`让容器在后台运行，而`–i`即使在未附加的情况下也保持`stdin`打开。如果您需要在容器外部暴露任何端口，您可以使用带有定义`<port_outside_container>:<port_inside_container>`的激活选项`–p`。一些镜像需要额外的配置，这通常通过环境变量完成，这些环境变量可以通过`–e`选项覆盖。为了轻松运行其他命令，设置容器的好友名称也很有用，使用`--name`选项。看看这里可见的示例Docker命令。它启动了带有Postgres的容器，创建了一个具有密码的数据库用户，并在端口`55432`上暴露它。现在，Postgres数据库可以在地址`192.168.99.100:55432`上访问：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The container with Postgres persists data. The recommended mechanism for containers
    that store data accessed by outside applications is via volumes. A volume may
    be passed to the container with the `–v` option, where the value consists of fields
    separated by a colon, `:`. The first field is the name of the volume, while the
    second is the path where the file or directory is mounted in the container. The
    next interesting option is the ability to limit the maximum RAM allocated for
    the container using the `–m` option. The following are the commands that create
    new volumes and mount them to the launched container. The maximum amount of RAM
    is set to 500 MB. The container is automatically removed after stopping using
    the activated option `--rm`, shown as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 带有Postgres的容器持久化数据。建议通过卷机制来存储外部应用程序访问的数据的容器。可以通过`–v`选项将卷传递给容器，其中值由冒号分隔的字段组成，`:`。第一个字段是卷的名称，第二个字段是在容器中挂载文件或目录的路径。下一个有趣的选项是使用`–m`选项限制容器分配的最大RAM量。以下是为新卷创建并挂载到启动的容器的命令。最大RAM设置为500
    MB。容器在停止后自动删除，使用激活的选项`--rm`，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Every running container can be stopped using the `docker stop` command. We
    have already set a name for our container so we can easily use it as a label,
    shown as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行中的容器都可以使用`docker stop`命令来停止。我们已经为我们的容器设置了一个名字，因此我们可以很容易地将其作为标签使用，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The entire state of the container is written to the disk, so we may run it
    again with exactly the same set of data as we did before stopping, for example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的整个状态都会写入磁盘，因此我们可以用完全相同的数据再次运行它，例如：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you only want to restart a container, you can use the following command
    instead of stopping/starting container:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想重新启动容器，而不是停止/启动容器，您可以使用以下命令：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Listing and removing containers
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出和删除容器
- en: 'If you have started some containers, you may want to consider displaying a
    list of all the running containers on your Docker machine. The `docker ps` command
    should be used for that. This command displays some basic information about the
    container, such as a list of exposed ports and the name of the source image. This
    command prints only the currently started containers. If you would like to see
    containers that have been stopped or are inactive, use option `-a` on the Docker
    command, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经启动了一些容器，你可能想考虑显示你Docker机器上所有正在运行的容器列表。应该使用`docker ps`命令来实现。这个命令显示关于容器的一些基本信息，比如暴露的端口列表和源镜像的名称。这个命令只打印当前启动的容器。如果你想看到已停止或未活跃的容器，请在Docker命令中使用`-a`选项，如下所示：
- en: '![](img/cce5a0a7-6103-4def-af56-718b3cd98812.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cce5a0a7-6103-4def-af56-718b3cd98812.png)'
- en: 'If a container is no longer needed, it can be removed using the `docker rm`
    command. Sometimes it is necessary that you remove a running container, which
    is not allowed by default. To force this option, set the `-f` option on Docker
    with the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个容器不再需要，可以使用`docker rm`命令将其删除。有时你可能需要删除一个正在运行的容器，但默认情况下这是不允许的。要强制这个选项，请在Docker上使用以下命令设置`-f`选项：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should remember that the `docker ps` command removes only the container.
    The image from which it has been created is still cached locally. Such images
    can take up a significant amount of space, ranging from a megabyte to several
    hundred megabytes. You may remove every image by using the `docker rmi` command
    with the image ID or name as a parameter, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记得`docker ps`命令只删除容器。它创建的镜像仍然在本地下缓存。这类镜像可能会占用相当大的空间，从兆字节到几百兆字节不等。你可以使用以下参数使用`docker
    rmi`命令删除每个镜像：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We haven’t created any Docker images yet, but it''s not unusual to generate
    a large amount of unwanted or unnamed images during image creation. These images
    can be easily recognized, as they are denoted with a name of `<none>`. In Docker
    nomenclature, these are called **dangling images** and can be easily removed with
    the following command. The list of all currently cached images can be displayed
    with the `docker images` command, shown as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有创建任何Docker镜像，但在创建镜像过程中很容易产生大量不需要或未命名的镜像。这些镜像很容易识别，因为它们的名称是`<none>`。在Docker的术语中，这些被称为**悬空镜像**，可以通过以下命令轻松删除。当前缓存的所有镜像列表可以使用`docker
    images`命令显示，如下所示：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Pulling and pushing images
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉取和推送镜像
- en: 'We''ve already discussed Docker Hub. It is the biggest and most popular Docker
    repository available on the web. It is available at [https://hub.docker.com](https://hub.docker.com).
    The Docker client, by default, tries to pull all the images for that repository.
    There are many certified official images for common software such as Redis, Java,
    Nginx, or Mongo, but you may also find hundreds of thousands of images created
    by other people as well. If you use the command `docker run` , the image is pulled
    from the repository in case it is not cached locally. You may also run the following
    command `docker pull`, which is only responsible for downloading an image:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过Docker Hub。它是网络上最大的最受欢迎的Docker仓库。它位于[https://hub.docker.com](https://hub.docker.com)。Docker客户端默认会尝试拉取该仓库的所有镜像。有许多经过认证的官方镜像，如Redis、Java、Nginx或Mongo，但您也可以找到数十万人创建的镜像。如果您使用`docker
    run`命令，则镜像会在本地没有缓存的情况下从仓库拉取。您还可以运行以下`docker pull`命令，它只负责下载镜像：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding command downloads the newest version of an  image (with the latest
    tag's name). If you would like to use an older version of a Postgres Docker image,
    you should append the tag with the specific version's number. The full list of
    available versions is usually published on the image's site, and is no different
    in this case. Visit [https://hub.docker.com/r/library/postgres/tags/](https://clicktime.symantec.com/a/1/Im1LdWl8NQ4ddISjfwL_OxcUojdkW-H3fP-oquj1vZs=?d=zKV7R9H5uhYC7J5kAN4WlSdYuV7w56mec0MwOxbVt-onFGmsM6Sx37HIaVHJUb3QiEeB2UoRmfzGJLL2nbKFa0anD4Lnn9-ximh393HGo36BjpeP0FoTIe_ikOi5QeJ1AeoMYVgQp_eESUZZNBRlDtcfYxSSkGpgZ_sGge1ts1DBD0AiZXddlCKygZL3ttJma9imoX-dIYGhyIi7l13N-8Y_5N5OYuthQeHXR4cE3e6ZicVVMyrnPGOm4nPLOHZiFzLZsTnDT0QQgFKRuqd4dsZekUaglgG9Y90wlN16gLc1DewmmCqRs_KiE1hwsBfCnFIku3QSPBvVa8e7YWJmMEGwuCxlybf2ywMx81HkC4uMHvQfq1EiVA0PYg5arA%3D%3D&u=https%3A%2F%2Fhub.docker.com%2Fr%2Flibrary%2Fpostgres%2Ftags%2F) for
    a list of the available tags.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令下载了一个镜像的最新版本（具有最新标签的名称）。如果你想要使用一个较老版本的Postgres Docker镜像，你应该在标签后加上具体版本的数字。通常，可用的所有版本列表会发布在镜像的网站上，这个情况也不例外。访问[https://hub.docker.com/r/library/postgres/tags/](https://clicktime.symantec.com/a/1/Im1LdWl8NQ4ddISjfwL_OxcUojdkW-H3fP-oquj1vZs=?d=zKV7R9H5uhYC7J5kAN4WlSdYuV7w56mec0MwOxbVt-onFGmsM6Sx37HIaVHJUb3QiEeB2UoRmfzGJLL2nbKFa0anD4Lnn9-ximh393HGo36BjpeP0FoTIe_ikOi5QeJ1AeoMYVgQp_eESUZZNBRlDtcfYxSSkGpgZ_sGge1ts1DBD0AiZXddlCKygZL3ttJma9imoX-dIYGhyIi7l13N-8Y_5N5OYuthQeHXR4cE3e6ZicVVMyrnPGOm4nPLOHZiFzLZsTnDT0QQgFKRuqd4dsZekUaglgG9Y90wlN16gLc1DewmmCqRs_KiE1hwsBfCnFIku3QSPBvVa8e7YWJmMEGwuCxlybf2ywMx81HkC4uMHvQfq1EiVA0PYg5arA%3D%3D&u=https%3A%2F%2Fhub.docker.com%2Fr%2Flibrary%2Fpostgres%2Ftags%2F)获取可用标签的列表。
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once you have run and validated your image, you should think about saving it
    remotely. The most appropriate place for it is, of course, Docker Hub. However,
    sometimes you might want to store images in alternative storage, such as a private
    repository. Before pushing an image, you have to tag it with your registry username,
    image name, and its version number. The following command creates a new image
    from a Postgres source image with the name `piomin/postgres` and the `1.0` version
    tag:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行并验证了你的镜像，你应该考虑将其远程保存。当然，最合适的地方是Docker Hub。然而，有时你可能想将镜像存储在其他存储中，比如私有仓库。在推送镜像之前，你必须使用你的注册表用户名、镜像名称和其版本号来标记它。以下命令从Postgres源镜像创建了一个名为`piomin/postgres`和`1.0`版本标签的新镜像：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now if you run the `docker images` command you will see two images with the
    same ID. The first has the name Postgres and the latest tag, while the second
    has the name `piomin/postgres` and the tag `1.0`. What is important is that `piomin`
    is my username on Docker Hub. So, before proceeding any further we should first
    register the image there. After, we should also log in to our Docker client using
    the `docker login` command. Here, you will be prompted for a username, password,
    and the email address you used for registration. Finally, you can push a tagged
    image with the following `docker push` command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行`docker images`命令，你会发现有两个具有相同ID的镜像。第一个镜像的名称是Postgres，并且是最新的标签，而第二个镜像的名称是`piomin/postgres`，标签是`1.0`。重要的是`piomin`是我的Docker
    Hub用户名。因此，在进一步操作之前，我们首先应该在那里注册这个镜像。之后，我们还应该使用`docker login`命令登录到我们的Docker客户端。在这里，系统会提示你输入用户名、密码和用于注册的电子邮件地址。最后，你可以使用以下`docker
    push`命令推送一个带标签的镜像：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now all that''s left to do is log in to your Docker Hub account using a web
    browser to check if the pushed image has appeared. If everything worked correctly,
    you will see a new public repository with your image on-site. The following screenshot
    shows the image currently pushed to my Docker Hub account:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的所有事情就是使用网络浏览器登录到你的Docker Hub账户，以检查推送到那里的镜像是否出现。如果一切工作正常，你将在网站上看到一个新的公开仓库和你的镜像。下面的屏幕截图显示了我Docker
    Hub账户中当前推送的镜像：
- en: '![](img/8ab7815a-c6bc-47e4-bc66-9c939ad920e2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ab7815a-c6bc-47e4-bc66-9c939ad920e2.png)'
- en: Building an image
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'In the previous section, we pushed the copy of the Postgres Docker image to
    a Docker Hub registry. Usually, we push our own images created from the file  `Dockerfile`,
    which defines all the instructions required when installing and configuring software
    on the container. The details related to the structure of `Dockerfile` will be
    discussed later. What is important for now, though, is the command used for building
    a Docker image,  `docker build`. This command should be run in the same directory
    where `Dockerfile` is located. When building a new image it is recommended to
    set its name and tag using the `-t` option. The following command creates the
    image `piomin/order-service` , tagged with a `1.0` version. The image may be pushed
    to your Docker Hub account in the same way as the previous image was with Postgres,
    as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们将Postgres的Docker镜像副本推送到Docker Hub仓库。通常，我们会将基于文件`Dockerfile`创建的自己的镜像推送到仓库，`Dockerfile`中定义了安装和配置软件所需的所有指令。关于`Dockerfile`结构的细节将在后面讨论。现在重要的是构建Docker镜像时使用的命令，即`docker
    build`。这个命令应该在`Dockerfile`所在的同一个目录中运行。构建新镜像时，建议使用`-t`选项为其设置名称和标签。以下命令创建了名为`piomin/order-service`的镜像，版本标记为`1.0`。您可以像之前推送Postgres镜像一样，将此镜像推送到您的Docker
    Hub账户中，如下所示：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Networking
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络配置
- en: 'Networking is an important aspect of Docker architecture since we often have
    to provide communication between applications running on different containers.
    A common use case may be a web application that needs access to a database. We''re
    now going to refer to another example that has already been introduced in [Chapter
    11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message Driven Microservices*.
    It is communication between Apache Kafka and ZooKeeper. Kafka requires ZooKeeper
    because it stores a variety of configuration as a key/value pair in the ZK data
    tree and uses it across the cluster. As you may remember, we first had to create
    a custom network and run those two containers there. The following command is
    used to create a user-defined network on a Docker host:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 网络配置是Docker架构的一个重要方面，因为我们必须经常在不同容器上运行的应用程序之间提供通信。一个常见的用例可能是一个需要访问数据库的web应用程序。现在我们将参考在[第11章](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml)中已经介绍过的另一个例子，即*消息驱动的微服务*。这是Apache
    Kafka与ZooKeeper之间的通信。Kafka需要ZooKeeper，因为它将各种配置作为键/值对存储在ZK数据树中，并在整个集群中使用它。正如您可能记得的，我们首先必须创建一个自定义网络并在那里运行这两个容器。以下命令用于在Docker主机上创建一个用户定义的网络：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After the previous command has finished running, you can check out the list
    of available networks using the following command. By default, Docker creates
    three networks for you, so you should see four networks with the names bridge,
    host, none, and `kafka-network`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令运行完成后，您可以使用以下命令查看可用的网络列表。默认情况下，Docker为您创建了三个网络，所以您应该看到四个网络，名称分别为bridge、host、none和`kafka-network`：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next step is to pass the network name to the container created with the `docker
    run` command. It can be achieved through the `--network` parameter, as you can
    see in the following example. If you set the same network''s name for two different
    containers, they will be started on the same network. Let''s analyze what this
    means in practice. If you were inside one container, you could call it its name
    instead of using its IP address, which is why we could have set the environment
    variable `ZOOKEEPER_IP` to ZooKeeper when starting a container with Apache Kafka.
    Kafka, which starts inside this container, connects the ZooKeeper instance on
    the default port as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向使用`docker run`命令创建的容器传递网络名称。这可以通过`--network`参数实现，正如您在以下示例中看到的那样。如果您为两个不同的容器设置相同的网络名称，它们将在同一个网络中启动。让我们实际分析一下这意味着什么。如果您在一个容器内，可以用它的名字而不是IP地址来调用它，这就是为什么在启动带有Apache
    Kafka的容器时，我们可以将环境变量`ZOOKEEPER_IP`设置为ZooKeeper的原因。Kafka在这个容器内启动，如下所示连接到默认端口的ZooKeeper实例：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating a Docker image with microservices
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有微服务的Docker镜像
- en: We have already discussed the basic Docker commands that are available for running,
    creating, and managing containers. It's now time to create and build our first
    Docker image that starts the sample microservice that we introduced in the previous
    chapter. For that, we should move back to the repository available at the address
    [https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git)
    and then switch to the branch `feign_with_discovery`  on [https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_discovery).
    There, you will find a `Dockerfile` for every single microservice, gateway, and
    discovery. Before discussing these examples however we should refer to the `Dockerfile`
    reference to understand the basic commands that we can place there. In fact, `Dockerfile`
    is not the only way to build Docker images; we're also going to show you how to
    create an image with a microservice using the Maven plugin.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了可用于运行、创建和管理容器的基本Docker命令。现在是我们创建和构建第一个Docker镜像的时候了，这个镜像启动了我们在上一章中介绍的示例微服务。为此，我们应该回到地址[https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git)可用的仓库，然后切换到`feign_with_discovery`分支上[https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_discovery)。在那里，你可以找到每个微服务、网关和发现模块的`Dockerfile`。然而，在讨论这些示例之前，我们应该参考`Dockerfile`参考资料，以了解我们可以在其中放置的基本命令。实际上，`Dockerfile`不是构建Docker镜像的唯一方法；我们还将向您展示如何使用Maven插件创建包含微服务的镜像。
- en: Dockerfiles
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfiles
- en: 'Docker can build images automatically by reading the instructions provided
    in a `Dockerfile`,  a document that contains all the commands that are invoked
    on the command line to assemble an image. All of those commands have to be preceded
    by the keywords defined in the `Dockerfile` specification. The following is a
    list of the most commonly used instructions. They are executed in the order in
    which they are found in the `Dockerfile`. Here, we can also append some comments
    that have to be followed by the `#` character:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Docker可以通过读取`Dockerfile`中提供的指令来自动构建镜像，这是一个包含所有在命令行中调用以组装镜像的命令的文档。`Dockerfile`中的所有命令都必须由`Dockerfile`规范中定义的关键字前缀。以下是最常用的指令列表。它们按照在`Dockerfile`中找到的顺序执行。在这里，我们还可以添加一些以`#`字符开头的注释：
- en: '| **Instruction** | **Description** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `FROM` | This  initializes a new build stage and sets the base image for
    subsequent instructions. In fact, every valid `Dockerfile` has to start with a
    `FROM` instruction. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `FROM` | 这初始化一个新的构建阶段并设置后续指令的基础镜像。实际上，每个有效的`Dockerfile`都必须以`FROM`指令开始。 |'
- en: '| `MAINTAINER` | This sets author identities of the generated images. This
    instruction is deprecated, so you may find it in many older images. We should
    use the `LABEL` instruction instead of `MAINTAINER` , as follows:`LABEL maintainer="piotr.minkowski@gmail.com"`.
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `MAINTAINER` | 这设置了生成镜像的作者身份。这个指令已经过时，所以你可能会在许多旧镜像中找到它。我们应该使用`LABEL`指令代替`MAINTAINER`，如下所示：`LABEL
    maintainer="piotr.minkowski@gmail.com"`。 |'
- en: '| `RUN` | This executes Linux commands for configuring and installing the required
    software in a new layer on top of the current image and then commits the results.
    It can have two forms:`RUN <command>` or `RUN ["executable", "param1", "param2"]`.
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `RUN` | 这执行Linux命令，用于在新的层上配置和安装当前镜像所需的应用程序，然后提交结果。它可以有两种形式:`RUN <命令>`或`RUN
    ["可执行文件", "参数1", "参数2"]`。 |'
- en: '| `ENTRYPOINT` | This configures a final script that is used when bootstrapping
    the container that will run as an executable. It overrides all elements specified
    using `CMD` and has two forms: `ENTRYPOINT ["executable", "param1", "param2"]`
    and `ENTRYPOINT` the command `param1 param2`. It is worth noticing that only the
    last `ENTRYPOINT` instruction in the `Dockerfile` will have an affect. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRYPOINT` | 这配置了一个最终脚本，用于引导作为可执行文件的容器。它覆盖了所有使用`CMD`指定的元素，并有两个形式:`ENTRYPOINT
    ["可执行文件", "参数1", "参数2"]`和`ENTRYPOINT`命令`参数1 参数2`。值得注意的是，`Dockerfile`中最后一个`ENTRYPOINT`指令才会生效。
    |'
- en: '| `CMD` | `Dockerfile` can contain only one `CMD` instruction. This instruction
    provides the default arguments to  `ENTRYPOINT` using a JSON array format. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `CMD` | `Dockerfile`中只能包含一个`CMD`指令。这个指令通过JSON数组格式为`ENTRYPOINT`提供默认参数。 |'
- en: '| `ENV` | This sets the environment variable for a container in key/value form.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `ENV` | 这为容器设置环境变量，以键/值形式。 |'
- en: '| `COPY` | This copies new files or directories from a given source path to
    the filesystem inside the container at the path defined by the target path. It
    has the following form: `COPY [--chown=<user>:<group>] <src>... <dest>`. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `COPY` | 这个指令会将给定源路径的新文件或目录复制到容器文件系统内的目标路径。它的格式如下：`COPY [--chown=<用户>:<组>]
    <源>... <目标>`。 |'
- en: '| `ADD` | This is an alternative to a `COPY` instruction. It is allowed to
    do a little more than `COPY`, for example, it allows `<src>` to be a URL address.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `ADD` | 这是`COPY`指令的一个替代选项。它比`COPY`指令多做了一些事情，例如，它允许`<src>`是一个 URL 地址。 |'
- en: '| `WORKDIR` | This sets the working directory for `RUN`, `CMD`, `ENTRYPOINT`,
    `COPY`, and `ADD.` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `WORKDIR` | 这个指令为`RUN`、`CMD`、`ENTRYPOINT`、`COPY`和`ADD`设置工作目录。 |'
- en: '| `EXPOSE` | This is responsible for informing Docker that the container listens
    on the specified network ports at runtime. It does not actually publish the port.
    The ports are published through the `-p` option on the `docker run` command. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `EXPOSE` | 这个指令负责告知 Docker 容器在运行时监听指定的网络端口。它实际上并不发布端口。端口的发布是通过`docker run`命令的`-p`选项来实现的。
    |'
- en: '| `VOLUME` | This creates a mount point with the specified name. Volumes are
    the preferred mechanism for persisting data inside Docker containers. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `VOLUME` | 这个指令创建了指定名称的挂载点。卷是 Docker 容器内持久化数据的首选机制。 |'
- en: '| `USER` | This sets the username and, optionally, the user group used when
    running the image, as well as for the `RUN`, `CMD`, and `ENTRYPOINT` instructions.
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `USER` | 这个指令为运行镜像以及`RUN`、`CMD`和`ENTRYPOINT`指令设置用户名和可选的用户组。 |'
- en: 'Let’s take a look how this works in practice. We should define a `Dockerfile`
    for every microservice and place it in the root directory of its Git project.
    The following is a `Dockerfile` created for `account-service`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作中它是如何工作的。我们应该为每个微服务定义一个`Dockerfile`，并将其放在其 Git 项目的根目录中。下面是为`account-service`创建的`Dockerfile`：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding example is not very complicated. It only adds the microservice-generated
    fat JAR file to the Docker container and uses the `java -jar` command as `ENTRYPOINT`.
    Even so, let''s analyze it step-by-step. Our example `Dockerfile` performs the
    following instructions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子并不复杂。它只是将微服务生成的胖 JAR 文件添加到 Docker 容器中，并将`java -jar`命令作为`ENTRYPOINT`。即便如此，让我们逐一分析它。我们示例中的`Dockerfile`执行了以下指令：
- en: The image extends an existing OpenJDK image that is an official, open-source
    implementation of the Java Platform Standard Edition. OpenJDK images come in many
    flavors. The main difference between available images' variants is in their size.
    The image tagged with `8u151-jdk-slim-stretch` provides JDK 8 and includes all
    the libraries needed to run the Spring Boot microservice. It is also much smaller
    than a basic image with this version of Java (`8u151-jdk`).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该镜像扩展了一个现有的 OpenJDK 镜像，这是一个官方的、开源的 Java 平台标准版实现。OpenJDK 镜像有很多版本。可用的镜像变体之间的主要区别在于它们的大小。标记为`8u151-jdk-slim-stretch`的镜像提供了
    JDK 8，并包括运行 Spring Boot 微服务所需的所有库。它也比这个版本的 Java（`8u151-jdk`）的基本镜像小得多。
- en: Here, we defined two environment variables that can be overridden during runtime
    that have the `-e` option of the `docker run` command. The first is the active
    Spring profile name, which is by default initialized with a `zone1` value. The
    second is the discovery server's address, which is by default equal to [http://localhost:8761/eureka/](http://localhost:8761/eureka/).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个可以在运行时覆盖的环境变量，它们是通过`docker run`命令的`-e`选项来设置的。第一个是活动的 Spring 配置文件名，默认初始化为`zone1`值。第二个是发现服务器的地址，默认等于`[http://localhost:8761/eureka/](http://localhost:8761/eureka/)`。
- en: The fat JAR file contains all the required dependencies together with an application's
    binaries. So, we have to put a generated JAR file inside the container using the
    `ADD` instruction.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胖 JAR 文件包含了所有必需的依赖项以及应用程序的二进制文件。因此，我们必须使用`ADD`指令将生成的 JAR 文件放入容器中。
- en: 'We configure our container to run as an executable Java application. The defined
    `ENTRYPOINT` is equivalent to running the following command on a local machine:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将容器配置为执行 Java 应用程序。定义的`ENTRYPOINT`相当于在本地机器上运行以下命令：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using the `EXPOSE` instruction we have informed Docker that it may expose our
    application's HTTP API, which is available inside the container on port `8091`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`EXPOSE`指令告知 Docker 可能会暴露容器内部应用程序的 HTTP API，该 API 可通过端口`8091`访问。
- en: Running containerized microservices
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行容器化的微服务
- en: Assuming we have prepared a valid `Dockerfile` for each service, the next step
    is to build the whole Maven project with the `mvn clean install` command, before
    building a Docker image for every service.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经为每个服务准备了一个有效的`Dockerfile`，下一步是在为每个服务构建Docker镜像之前，使用`mvn clean install`命令构建整个Maven项目。
- en: 'When building a Docker image, you should always be in the `root` directory
    of every microservice source code. The first container that has to be run in our
    microservices-based system is a discovery server. Its Docker image has been named
    `piomin/discovery-service`. Before running Docker''s `build` command, go to the
    module `discovery-service`. This `Dockerfile` is a little simpler than other microservices,
    because there is no environment variables to set inside the container, shown as
    follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像时，你应该始终位于每个微服务源代码的`root`目录。在我们基于微服务的系统中，需要运行的第一个容器是一个发现服务器。其Docker镜像被命名为`piomin/discovery-service`。在运行Docker的`build`命令之前，请转到模块`discovery-service`。这个`Dockerfile`比其他微服务要简单一些，因为容器内部不需要设置环境变量，如下所示：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are only five steps to perform here, which you can see in the logs generated
    during the target image''s build, just after running the `docker build` command.
    If everything works correctly, you should see the progress of all five steps as
    defined in `Dockerfile` and the following final messages telling you that the
    image has been successfully built and tagged:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里只需要执行五个步骤，你可以在构建目标镜像时生成的日志中看到，在运行`docker build`命令之后。如果一切正常，你应该看到`Dockerfile`中定义的所有五个步骤的进度，以及以下告诉您镜像已成功构建和标记的最终消息：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we have successfully built an image, we should run it. We recommend creating
    a network where all the containers with our microservices will be launched. To
    launch a container inside a newly created network, we have to pass its name to
    the `docker run` command using the `--network` parameter. In order to check if
    a container has been successfully started, run the `docker logs` command. This
    command prints all the lines logged by the application to the console, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功构建了一个镜像，我们就应该运行它。我们建议创建一个网络，在该网络中启动所有我们的微服务容器。要在新创建的网络中启动容器，我们需要使用`--network`参数将容器名称传递给`docker
    run`命令。为了检查容器是否已成功启动，运行`docker logs`命令。此命令将应用程序打印到控制台的所有日志行输出到控制台，如下所示：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next step is to build and run the containers with our four microservices—`account-service`,
    `customer-service`, `order-service`, and `product-service`. The procedure is the
    same for each service. For example, if you would like to build `account-service`,
    first go to that directory within the example project''s source code. The `build`
    command is the same here as it is for the discovery service; the only difference
    is in the image name, as shown in the following snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用我们的四个微服务—`account-service`、`customer-service`、`order-service`和`product-service`—构建和运行容器。每个服务的步骤都相同。例如，如果你想构建`account-service`，首先需要进入示例项目源代码中的那个目录。这里的`build`命令与发现服务相同；唯一的区别在于镜像名称，如下所示片段：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The command to run the Docker image is a little more complicated for `discovery-service`.
    In this case, we have to pass the address of the Eureka server to the starting
    container. Because this container is running in the same network as the discovery
    service container, we may use its name instead of its IP address or any other
    identifier. Optionally, we can also set the container''s memory limit by using
    the `-m` parameter, for example, to 256 MB. Finally, we can see the logs generated
    by the application running on the container by using the `docker logs` command
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`discovery-service`，运行Docker镜像的命令要稍微复杂一些。在这种情况下，我们必须将Eureka服务器的地址传递给启动容器。因为此容器与发现服务容器在同一网络中运行，我们可以使用其名称而不是其IP地址或其他任何标识符。可选地，我们还可以使用`-m`参数设置容器的内存限制，例如，设置为256
    MB。最后，我们可以使用以下方式使用`docker logs`命令查看容器上运行的应用程序生成的日志：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The same steps as described previously should be repeated for all other microservices.
    The final result is the five running containers that can be displayed using the `docker
    ps` command, as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前描述的步骤相同，应对所有其他微服务重复这些步骤。最终结果是五个正在运行的容器，可以使用`docker ps`命令来显示，如下所示截图：
- en: '![](img/2638f3f5-f1ee-446e-8090-25e5c1622119.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2638f3f5-f1ee-446e-8090-25e5c1622119.png)'
- en: 'All the microservices are registered in the Eureka server. The Eureka dashboard
    is available at the address `http://192.168.99.100:8761/`, as shown in the following
    screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的微服务都注册在Eureka服务器上。Eureka仪表板可在地址`http://192.168.99.100:8761/`找到，如下截图所示：
- en: '![](img/da00480d-f780-4d73-a76d-7f1055e5e176.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da00480d-f780-4d73-a76d-7f1055e5e176.png)'
- en: 'There is one more interesting Docker command that we mention here: `docker
    stats`. This command prints some statistics related to the started container,
    such as memory or CPU usage. If you use the  `--format` parameter of that command
    you can customize the way it prints the statistics; for example, you can print
    the container name rather than its ID. Before running that command you may perform
    some tests in order to check that everything is working as it should. It''s worth
    checking whether the communication between microservices that was started on the
    containers has finished successfully. You may also want to try to call the endpoint
    `GET /withAccounts/{id}` from `customer-service` , which calls an endpoint exposed
    by `account-service`. We run the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再提一个有趣的Docker命令：`docker stats`。这个命令打印了一些关于启动容器的统计信息，比如内存或CPU使用情况。如果你使用该命令的`--format`参数，你可以自定义它打印统计信息的方式；例如，你可以打印容器名称而不是它的ID。在运行那个命令之前，你可能需要进行一些测试，以检查一切是否按预期工作。检查微服务之间的通信是否成功完成是很值得的。你可能还想尝试从`customer-service`调用端点`GET
    /withAccounts/{id}`，该端点由`account-service`暴露出来。我们运行以下命令：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following screenshot is visible:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图可见：
- en: '![](img/4eb480b3-3149-4c73-bdc3-7885ad46bf71.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4eb480b3-3149-4c73-bdc3-7885ad46bf71.png)'
- en: Building an image using the Maven plugin
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven插件构建镜像
- en: 'As we''ve mentioned previously, `Dockerfile` is not the only way of creating
    and building containers. There are some other approaches available, for example,
    by using Maven plugin. We have many available plugins dedicated to building images,
    which are used with  `mvn` commands. One of the more popular among them is `com.spotify:docker-maven-plugin`.
    This has the equivalent tags in its configuration that can be used instead of
    `Dockerfile` instructions. The configuration of the plugin inside `pom.xml` for
    `account-service `is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`Dockerfile`不是创建和构建容器的唯一方式。还有其他一些方法可用，例如，通过使用Maven插件。我们有多个用于构建镜像的插件，它们与`mvn`命令一起使用。其中比较流行的是`com.spotify:docker-maven-plugin`。这个插件在其配置中有与`Dockerfile`指令相当的标签。`account-service`的`pom.xml`中插件的配置如下：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This plugin can be invoked during Maven''s `build` command. If you would like
    to build a Docker image just after building the application, use the following
    Maven command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件可以在Maven的`build`命令期间被调用。如果你想在构建应用程序之后立即构建一个Docker镜像，可以使用以下的Maven命令：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, you can also set the `dockerDirectory` tag in order to perform
    a build based on `Dockerfile`. No matter which method you choose, the effect is
    the same. Any new image that is built with an application will be available on
    your Docker machine. When using `docker-maven-plugin`, you can force the automated
    image to push to the repository by setting `pushImage` to `true`, shown as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以设置`dockerDirectory`标签，以便基于`Dockerfile`进行构建。无论你选择哪种方法，效果都是一样的。任何用应用程序构建的新镜像都会在你的Docker机器上可用。在使用`docker-maven-plugin`时，你可以通过将`pushImage`设置为`true`来强制自动镜像推送到仓库，如下所示：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Advanced Docker images
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Docker镜像
- en: 'Until now, we have built rather simple Docker images. However, it is sometimes
    necessary to create a more advanced image. We will need such an image for the
    purpose of Continuous Delivery presentation. This Docker image will be run as
    a Jenkins slave and would be connected to the Jenkins master, which is started
    as a Docker container. We have not found such an image on Docker Hub, so we created
    in by ourselves. Here, the image has to contain Git, Maven, JDK8, and Docker.
    These are all the tools required for building our example microservices using
    the Jenkins slave. I will give you a brief summary of the basics related to Continuous
    Delivery using the Jenkins server in a later section of this chapter. For now,
    we will focus on just building the required image. The following is the full definition
    of the image provided inside `Dockerfile`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一些相当简单的Docker镜像。然而，有时需要创建一个更高级的镜像。我们将需要这样一个镜像来进行持续交付演示。这个Docker镜像将作为Jenkins奴隶运行，并连接到作为Docker容器启动的Jenkins主节点。我们在Docker
    Hub上没有找到这样的镜像，所以我们自己创建了一个。在这里，镜像必须包含Git、Maven、JDK8和Docker。这些都是构建我们的示例微服务的Jenkins奴隶所需的全部工具。我将在本章的后面部分给你一个关于使用Jenkins服务器进行持续交付的基本概述。现在，我们将重点关注
    just building the required image。以下是`Dockerfile`中提供的镜像的完整定义：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s analyze what''s happened. Here, we have extended the Docker base image.
    This is a pretty smart solution, because that image now provides Docker inside
    Docker. Although running Docker inside Docker is generally not recommended, there
    are some desirable use cases, such as Continuous Delivery with Docker. Besides
    Docker, there is other software installed on the image using the `RUN` instruction,
    such as Git, JDK, Maven, or Curl. We have also added an OS user, which has `sudoers`
    permission in the `dockerd` script, which is responsible for running the Docker
    daemon on the machine. This is not the only process that has to be started in
    the running container; launching JAR with the Jenkins slave is also required.
    Those two commands are executed inside `entrypoint.sh`, which is set as an `ENTRYPOINT`
    of the image. The full source code of this Docker image is available on GitHub
    at [https://github.com/piomin/jenkins-slave-dind-jnlp.git](https://github.com/piomin/jenkins-slave-dind-jnlp.git).
    You can omit building it from source code and just download a ready image from
    my Docker Hub account by using the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下发生了什么。在这里，我们扩展了Docker基础镜像。这是一个相当智能的解决方案，因为现在这个镜像提供了Docker内的Docker。尽管通常不建议在Docker内运行Docker，但有一些期望的使用案例，比如使用Docker的持续交付。除了Docker之外，还使用`RUN`指令在镜像上安装了其他软件，如Git、JDK、Maven或Curl。我们还添加了一个OS用户，在`dockerd`脚本中有`sudoers`权限，负责在机器上运行Docker守护进程。这不是在运行容器中必须启动的唯一进程；启动JAR与Jenkins奴隶也是必须的。这两个命令在`entrypoint.sh`中执行，作为镜像的`ENTRYPOINT`。这个Docker镜像的完整源代码可以在GitHub上找到，地址为[https://github.com/piomin/jenkins-slave-dind-jnlp.git](https://github.com/piomin/jenkins-slave-dind-jnlp.git)。你可以省略从源代码构建它，只需使用以下命令从我的Docker
    Hub账户下载一个现成的镜像：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here''s the script `entrypoint.sh` inside Docker image that starts Docker deamon
    and Jenkins slave:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是在Docker镜像中的`entrypoint.sh`脚本，它启动了Docker守护进程和Jenkins奴隶：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Continuous Delivery
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付
- en: One of the key benefits of migrating to microservice-based architecture is the
    ability to deliver software quickly. This should be the main motivation for implementing
    continuous delivery or a continuous deployment process in your organization. In
    short, the continuous delivery process is an approach that tries to automate all
    the stages of software delivery such as building, testing a code, and releasing
    an application. There are many tools that empower that process. One of them is
    Jenkins, an open source automation server written in Java. Docker is something
    that can take your **Continuous Integration** (**CI**) or **Continuous Delivery** (**CD**) processes
    to a higher level. Immutable delivery, for example, is one of the most important
    advantages of Docker.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移到基于微服务的架构的关键好处之一就是能够快速交付软件。这应该是你在组织中实施持续交付或持续部署流程的主要动机。简而言之，持续交付流程是一种尝试自动化软件交付的所有阶段的方法，比如构建、测试代码和发布应用程序。有许多工具可以赋能这个过程。其中之一就是Jenkins，这是一个用Java编写的开源自动化服务器。Docker能够将你的**持续集成**（**CI**）或**持续交付**（**CD**）流程提升到一个新的水平。例如，不可变交付是Docker最重要的优势之一。
- en: Integrating Jenkins with Docker
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Jenkins与Docker集成
- en: 'The main goal here is to design and run the continuous delivery process locally using
    Jenkins and Docker. There are four elements that have a part in this process.
    The first of them is already prepared: the source code repository of our microservices,
    which is available on GitHub. The second element, Jenkins, needs to be run and
    configured. Jenkins is a key element of our continuous delivery system. It has
    to download the application''s source code from the GitHub repository, build it,
    and then place the resulting JAR file in Docker image, push that image to Docker
    Hub, and finally run the container with a microservice. All of the tasks within
    this process are directly performed on a Jenkins master but on its slave node.
    Both Jenkins and its slave are launched as Docker containers. The architecture
    of this solution is illustrated as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要目标是使用Jenkins和Docker在本地设计和运行持续交付过程。这个过程涉及到四个元素。其中第一个元素已经准备好了：我们的微服务源代码仓库，它位于GitHub上。第二个元素，Jenkins，需要运行和配置。Jenkins是我们持续交付系统的一个关键元素。它必须从GitHub仓库下载应用程序的源代码，构建它，然后将生成的JAR文件放入Docker镜像中，将该镜像推送到Docker
    Hub，最后运行带有微服务的容器。这个过程中所有的任务都是直接在Jenkins主节点上执行的，但是是在其从节点上。Jenkins及其从节点都是作为Docker容器启动的。这个解决方案的架构如下所示：
- en: '![](img/f069db09-864d-4eb4-b61a-e56760ded97d.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f069db09-864d-4eb4-b61a-e56760ded97d.png)'
- en: 'It''s worth mentioning that Jenkins is built on the basis of the concept of
    plugins. The core is too simple an engine for automated builds. The real power
    of Jenkins is in its plugins, and there are hundreds of them in the Update Center.
    For now, we will only discuss a few opportunities available to us thanks to the
    Jenkins server. We will need the following plugins installed to be able to build
    and run our microservices in Docker containers:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，Jenkins是基于插件概念构建的。核心是一个过于简单的自动化构建引擎。Jenkins的真正力量在于其插件，并且在更新中心有数百个插件。现在，我们将只讨论一些感谢Jenkins服务器为我们提供的机会。我们需要安装以下插件才能在Docker容器中构建和运行我们的微服务：
- en: '**Pipeline**: This is a suite of plugins that lets you create automation using
    Groovy scripts following the idea **Pipeline as code** ([https://wiki.jenkins.io/display/JENKINS/Pipeline+Plugin](https://clicktime.symantec.com/a/1/4g9YbrLxE43FYJrIE5v0J-RjoqlfXZm5h2piohXV60o=?d=GiSMteljxw-3ox0rf3cMazK9IOHzeSrn0vm9sus4y_n0hehkoAHvPijqT9dNXanC2Z3KtWbAm0BF-YDyp2HFvxXpFa6IkS_tvoddqdWrcb2R6vx-7YEpFHbt4IzErozigZnPecmyLha58i_mX_GOqw8nGcIkFmptcNTdFqB6DA-shedWhYxMv5VpzsTWPmDZA52S7fjMHuYvrTP5MOqqgejXYWvZr4d9OaWe0jeXJ-MEIccIx-UiD_tYy9OK2eYpd4eiaegTQb9XhbUR0ZNPGlpo4vSShb3yAI2Kf9JPcQ4hOSXoj5JpZSvnKhm1C9Yn68IsYCIBmwjYZZYyuS3y9uUI9zHbgSpVOx8ehvCmMWx0MAwCJ5gDR1ZIXXNcnw%3D%3D&u=https%3A%2F%2Fwiki.jenkins.io%2Fdisplay%2FJENKINS%2FPipeline%2BPlugin))'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流水线**：这是一套插件，可以让您使用Groovy脚本创建自动化，遵循**流水线即代码**的理念 ([https://wiki.jenkins.io/display/JENKINS/Pipeline+Plugin](https://clicktime.symantec.com/a/1/4g9YbrLxE43FYJrIE5v0J-RjoqlfXZm5h2piohXV60o=?d=GiSMteljxw-3ox0rf3cMazK9IOHzeSrn0vm9sus4y_n0hehkoAHvPijqT9dNXanC2Z3KtWbAm0BF-YDyp2HFvxXpFa6IkS_tvoddqdWrcb2R6vx-7YEpFHbt4IzErozigZnPecmyLha58i_mX_GOqw8nGcIkFmptcNTdFqB6DA-shedWhYxMv5VpzsTWPmDZA52S7fjMHuYvrTP5MOqqgejXYWvZr4d9OaWe0jeXJ-MEIccIx-UiD_tYy9OK2eYpd4eiaegTQb9XhbUR0ZNPGlpo4vSShb3yAI2Kf9JPcQ4hOSXoj5JpZSvnKhm1C9Yn68IsYCIBmwjYZZYyuS3y9uUI9zHbgSpVOx8ehvCmMWx0MAwCJ5gDR1ZIXXNcnw%3D%3D&u=https%3A%2F%2Fwiki.jenkins.io%2Fdisplay%2FJENKINS%2FPipeline%2BPlugin))'
- en: '**Docker Pipeline**: This allows you to build Docker containers in pipelines
    ([https://wiki.jenkins.io/display/JENKINS/Docker+Pipeline+Plugin](https://clicktime.symantec.com/a/1/3BcsCubSP1UZ0ssSZFCe2iSCQQ_b1asMBhlt_0nQFKI=?d=GiSMteljxw-3ox0rf3cMazK9IOHzeSrn0vm9sus4y_n0hehkoAHvPijqT9dNXanC2Z3KtWbAm0BF-YDyp2HFvxXpFa6IkS_tvoddqdWrcb2R6vx-7YEpFHbt4IzErozigZnPecmyLha58i_mX_GOqw8nGcIkFmptcNTdFqB6DA-shedWhYxMv5VpzsTWPmDZA52S7fjMHuYvrTP5MOqqgejXYWvZr4d9OaWe0jeXJ-MEIccIx-UiD_tYy9OK2eYpd4eiaegTQb9XhbUR0ZNPGlpo4vSShb3yAI2Kf9JPcQ4hOSXoj5JpZSvnKhm1C9Yn68IsYCIBmwjYZZYyuS3y9uUI9zHbgSpVOx8ehvCmMWx0MAwCJ5gDR1ZIXXNcnw%3D%3D&u=https%3A%2F%2Fwiki.jenkins.io%2Fdisplay%2FJENKINS%2FDocker%2BPipeline%2BPlugin))'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker流水线**：这允许您在流水线中构建Docker容器 ([https://wiki.jenkins.io/display/JENKINS/Docker+Pipeline+Plugin](https://clicktime.symantec.com/a/1/3BcsCubSP1UZ0ssSZFCe2iSCQQ_b1asMBhlt_0nQFKI=?d=GiSMteljxw-3ox0rf3cMazK9IOHzeSrn0vm9sus4y_n0hehkoAHvPijqT9dNXanC2Z3KtWbAm0BF-YDyp2HFvxXpFa6IkS_tvoddqdWrcb2R6vx-7YEpFHbt4IzErozigZnPecmyLha58i_mX_GOqw8nGcIkFmptcNTdFqB6DA-shedWhYxMv5VpzsTWPmDZA52S7fjMHuYvrTP5MOqqgejXY'
- en: '**Git**: This integrates Git with Jenkins ([https://wiki.jenkins.io/display/JENKINS/Git+Plugin](https://clicktime.symantec.com/a/1/Zbv8hM_2L26s_PMbntThO-9W_A4uUxsqo7UyU5nbae8=?d=GiSMteljxw-3ox0rf3cMazK9IOHzeSrn0vm9sus4y_n0hehkoAHvPijqT9dNXanC2Z3KtWbAm0BF-YDyp2HFvxXpFa6IkS_tvoddqdWrcb2R6vx-7YEpFHbt4IzErozigZnPecmyLha58i_mX_GOqw8nGcIkFmptcNTdFqB6DA-shedWhYxMv5VpzsTWPmDZA52S7fjMHuYvrTP5MOqqgejXYWvZr4d9OaWe0jeXJ-MEIccIx-UiD_tYy9OK2eYpd4eiaegTQb9XhbUR0ZNPGlpo4vSShb3yAI2Kf9JPcQ4hOSXoj5JpZSvnKhm1C9Yn68IsYCIBmwjYZZYyuS3y9uUI9zHbgSpVOx8ehvCmMWx0MAwCJ5gDR1ZIXXNcnw%3D%3D&u=https%3A%2F%2Fwiki.jenkins.io%2Fdisplay%2FJENKINS%2FGit%2BPlugin))'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   **Git**: 该插件将Git与Jenkins集成([https://wiki.jenkins.io/display/JENKINS/Git+Plugin](https://clicktime.symantec.com/a/1/Zbv8hM_2L26s_PMbntThO-9W_A4uUxsqo7UyU5nbae8=?d=GiSMteljxw-3ox0rf3cMazK9IOHzeSrn0vm9sus4y_n0hehkoAHvPijqT9dNXanC2Z3KtWbAm0BF-YDyp2HFvxXpFa6IkS_tvoddqdWrcb2R6vx-7YEpFHbt4IzErozigZnPecmyLha58i_mX_GOqw8nGcIkFmptcNTdFqB6DA-shedWhYxMv5VpzsTWPmDZA52S7fjMHuYvrTP5MOqqgejXYWvZr4d9OaWe0jeXJ-MEIccIx-UiD_tYy9OK2eYpd4eiaegTQb9XhbUR0ZNPGlpo4vSShb3yAI2Kf9JPcQ4hOSXoj5JpZSvnKhm1C9Yn68IsYCIBmwjYZZYyuS3y9uUI9zHbgSpVOx8ehvCmMWx0MAwCJ5gDR1ZIXXNcnw%3D%3D&u=https%3A%2F%2Fwiki.jenkins.io%2Fdisplay%2FJENKINS%2FGit%2BPlugin))'
- en: '**Maven integration**: This provides some useful commands when building an
    application with Maven and Jenkins ([https://plugins.jenkins.io/maven-plugin](https://clicktime.symantec.com/a/1/jmIwLdZZ-wtodkRm1Goje_nuKFV98VcZYPHn5cWj1KM=?d=GiSMteljxw-3ox0rf3cMazK9IOHzeSrn0vm9sus4y_n0hehkoAHvPijqT9dNXanC2Z3KtWbAm0BF-YDyp2HFvxXpFa6IkS_tvoddqdWrcb2R6vx-7YEpFHbt4IzErozigZnPecmyLha58i_mX_GOqw8nGcIkFmptcNTdFqB6DA-shedWhYxMv5VpzsTWPmDZA52S7fjMHuYvrTP5MOqqgejXYWvZr4d9OaWe0jeXJ-MEIccIx-UiD_tYy9OK2eYpd4eiaegTQb9XhbUR0ZNPGlpo4vSShb3yAI2Kf9JPcQ4hOSXoj5JpZSvnKhm1C9Yn68IsYCIBmwjYZZYyuS3y9uUI9zHbgSpVOx8ehvCmMWx0MAwCJ5gDR1ZIXXNcnw%3D%3D&u=https%3A%2F%2Fplugins.jenkins.io%2Fmaven-plugin))'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-   **Maven集成**: 当使用Maven和Jenkins构建应用程序时，该插件提供了一些有用的命令([https://plugins.jenkins.io/maven-plugin](https://clicktime.symantec.com/a/1/jmIwLdZZ-wtodkRm1Goje_nuKFV98VcZYPHn5cWj1KM=?d=GiSMteljxw-3ox0rf3cMazK9IOHzeSrn0vm9sus4y_n0hehkoAHvPijqT9dNXanC2Z3KtWbAm0BF-YDyp2HFvxXpFa6IkS_tvoddqdWrcb2R6vx-7YEpFHbt4IzErozigZnP'
- en: 'The required plugins can be configured using the UI dashboard, either after
    startup or via Manage Jenkins *|* Manage Plugins. To run Jenkins locally, we will
    use its Docker image. The following commands create the network called `jenkins`
    and start the Jenkins master container, exposing the UI dashboard on port `38080`.
    Notice that when you start the Jenkins container and use its web console for the
    first time you need to set it up using the initial generated password. You can
    easily retrieve this password from Jenkins logs by invoking the `docker logs jenkins`
    command as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '-   所需插件可以通过UI仪表盘进行配置，可以在启动后或通过管理Jenkins *|* 管理插件进行配置。为了在本地运行Jenkins，我们将使用其Docker镜像。下面的命令将创建一个名为`jenkins`的网络，并启动Jenkins主容器，在端口`38080`上暴露UI仪表盘。注意，当你启动Jenkins容器并首次使用其Web控制台时，需要使用生成的初始密码进行设置。你可以通过调用`docker
    logs jenkins`命令轻松地从Jenkins日志中获取此密码，如下所示：'
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once we have successfully configured the Jenkins master with its required plugins,
    we need to add new slaves'' nodes. To do this, you should go to the section Manage
    Jenkins *|* Manage Nodes and then select New Node. In the displayed form, you
    have to set `/home/jenkins` as a remote root directory, and the launch agent via
    Java Web Start as the launch method. Now you may start the Docker container with
    a Jenkins slave, as previously discussed. Note that you will have to override
    two environment variables indicating the slave''s name and secret. The `name`
    parameter is set during node creation, while the secret is automatically generated
    by the server. You can take a look at the node''s details page for more information,
    as shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '-   一旦我们成功配置了Jenkins主节点及其所需插件，我们需要添加新的奴隶节点。为此，你应该前往管理Jenkins *|* 管理节点部分，然后选择新建节点。在显示的表单中，你必须将`/home/jenkins`设置为远程根目录，并通过Java
    Web Start将启动代理作为启动方法。现在你可以按照之前讨论的启动带有Jenkins奴隶的Docker容器。请注意，你必须覆盖两个环境变量，指示奴隶的名称和密钥。`name`参数在节点创建时设置，而密钥由服务器自动生成。你可以查看节点的详细信息页面以获取更多信息，如下所示的屏幕截图：'
- en: '![](img/a171112c-7bfe-4bd0-a491-1746adc35d68.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a171112c-7bfe-4bd0-a491-1746adc35d68.png)'
- en: 'The following is the Docker command that starts a container with the Jenkins
    slave with Docker in Docker:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '-   以下是在Docker中使用Docker的Jenkins奴隶容器启动的Docker命令：'
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This short introduction to the configuration of Jenkins should help you to repeat
    the discussed continuous delivery process on your own machine. Remember that we
    have only looked at a few aspects related to Jenkins, including settings, which
    will allow you to set up a CI or CD environment for your own microservices-based
    system. If you are interested in pursuing this topic in greater depth, you should
    refer to the documentation available at [https://jenkins.io/doc](https://jenkins.io/doc).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇关于 Jenkins 配置的简短介绍应该可以帮助你在自己的机器上重复讨论的持续交付过程。记住，我们只查看了与 Jenkins 相关的几个方面，包括设置，这允许你为你的微服务基础系统设置
    CI 或 CD 环境。如果你对深入研究这个话题感兴趣，你应该参考可用的文档，具体请访问 [https://jenkins.io/doc](https://jenkins.io/doc)。
- en: Building pipelines
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建流水线
- en: In older versions of Jenkins server, the basic unit of work was a job. Currently,
    its main feature is the ability to define pipelines as code. This change is related
    to more modern trends in IT architecture that consider application delivery as
    critical as the application that's being delivered. Since all the components of
    the application stack are already automated and represented as code in the version
    control system, the same benefits can be leveraged for CI or CD pipelines.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 服务器的旧版本中，工作单位是作业。目前，其主要特性是能够将流水线定义为代码。这种变化与 IT 架构中更现代的趋势有关，该趋势认为应用程序交付与正在交付的应用程序一样重要。由于应用程序堆栈的所有组件已经自动化，并以代码的形式在版本控制系统中表示，因此可以利用同样的好处来定义
    CI 或 CD 流水线。
- en: 'The Jenkins Pipeline provides a set of tools designed for modeling simple and
    more advanced delivery pipelines as code. The definition of such a pipeline is
    typically written into a text file called a `Jenkinsfile`. It supports the domain-specific
    language with additional, specific steps available through the *Shared Libraries* feature. Pipeline
    supports two syntaxes: Declarative (introduced in Pipeline 2.5) and Scripted Pipeline.
    No matter which syntax is used, it will be logically divided into stages and steps.
    Steps are the most fundamental part of a pipeline as they tell Jenkins what to
    do. Stages logically group a couple of steps, which are then displayed on the
    pipeline''s result screen. The following code is an example of a scripted pipeline
    and defines a build process for `account-service`. Similar definitions have to
    be created for other microservices. All of these definitions are located in the
    `root` directory of every application''s source code as `Jenkinsfile`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins Pipeline 提供了一套用于将简单和更高级的交付流水线建模为代码的工具。这样的流水线的定义通常写入一个名为 `Jenkinsfile`
    的文本文件中。它支持通过 *共享库* 功能提供的特定步骤的领域特定语言。流水线支持两种语法：声明式（在 Pipeline 2.5 中引入）和脚本化流水线。无论使用哪种语法，它都会逻辑上分为阶段和步骤。步骤是流水线的最基本部分，因为它们告诉
    Jenkins 需要做什么。阶段逻辑上分组了几个步骤，然后在流水线的结果屏幕上显示。下面的代码是一个脚本化流水线的示例，为 `account-service`
    定义了一个构建过程。对于其他微服务也需要创建类似的定义。所有这些定义都位于每个应用程序源代码的 `root` 目录中的 `Jenkinsfile`：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The previous definition is divided into four stages. In the first, `Checkout`,
    we clone the Git repository with the source code of all the example applications.
    In the second stage, `Build` , we build an application from the `account-service`
    module and then read the whole Maven project's version number from `root`'s `pom.xml`.
    In the `Image` stage we build an image from `Dockerfile` and push it to the Docker
    repository. Finally, we run a container with the `account-service` application
    inside the `Run` stage. All the described stages are executed on `dind-node-1`
    following the definition of a node element, which is a root for all the other
    elements in the pipeline definition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的定义被分为四个阶段。在第一个阶段，`Checkout`，我们克隆包含所有示例应用程序源代码的 Git 仓库。在第二个阶段，`Build`，我们从
    `account-service` 模块构建一个应用程序，然后从 `root` 的 `pom.xml` 中读取整个 Maven 项目的版本号。在 `Image`
    阶段，我们从 `Dockerfile` 构建一个镜像，并将其推送到 Docker 仓库。最后，在 `Run` 阶段我们在 `dind-node-1` 上运行一个包含
    `account-service` 应用程序的容器。所有描述的阶段都按照节点元素的定义在 `dind-node-1` 上执行，节点元素是流水线定义中所有其他元素的根。
- en: 'Now we can proceed to defining the pipeline in Jenkins'' web console. Select
    New Item, then check the Pipeline item type and enter its name. After confirmation
    you should be redirected to the pipeline''s configuration page. The only thing
    you have to do once there is to provide the location of `Jenkinsfile` in the Git
    repository and then set the SCM authentication credentials as shown in the following
    screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续在Jenkins的网页控制台中定义流水线。选择新建项目，然后检查管道项目类型并输入其名称。确认后，你应该会被重定向到管道的配置页面。在那里你唯一需要做的是提供Git仓库中`Jenkinsfile`的位置，然后按照下面的屏幕截图设置SCM认证凭据：
- en: '![](img/de3445e9-d691-4ca5-8344-ac9a2cd9cc06.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de3445e9-d691-4ca5-8344-ac9a2cd9cc06.png)'
- en: 'After saving the changes, the configuration of the pipeline is ready. In order
    to start the build, click the Build Now button. There are two things that should
    be clarified at this stage. In the production mode you can use the `webhook` mechanism,
    which is provided by the most popular Git host vendors, including GitHub, BitBucket,
    and GitLab. This mechanism automatically triggers your build on Jenkins after
    pushing the changes to the repository. In order to demonstrate this, we would
    have to run the version control system locally with Docker, for example using
    GitLab. There is also another simplified way of testing. The containerized application
    is run directly on Jenkins'' Docker in Docker slave; under normal circumstances,
    we would launch on the separated remote machine dedicated only to the deployment
    of applications. The following screenshot is Jenkins'' web console illustrating
    the build process, divided into different stages, for `product-service`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改后，管道的配置就准备好了。为了启动构建，点击“立即构建”按钮。在这个阶段，有两件事需要澄清。在生产模式下，你可以使用由最流行的Git托管提供商（包括GitHub、BitBucket和GitLab）提供的`webhook`机制。这个机制可以在将更改推送到仓库后自动触发Jenkins中的构建。为了演示这个，我们本应运行一个本地的版本控制系统，例如使用GitLab和Docker。还有一种更简单的测试方法。容器化的应用程序直接在Jenkins的Docker
    in Docker奴隶上运行；在正常情况下，我们会在专门用于应用程序部署的分离远程机器上启动。下面的屏幕截图是Jenkins的网页控制台，展示了`product-service`的构建过程，分为不同的阶段：
- en: '![](img/389420f0-9f82-4ff8-94f3-50dc772ae4c8.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/389420f0-9f82-4ff8-94f3-50dc772ae4c8.png)'
- en: 'We should now create one pipeline per microservice. The list of all the created
    pipelines is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该现在为每个微服务创建一个管道。创建的所有管道的列表如下：
- en: '![](img/6f01811b-9091-425b-90cf-e19bdbffef91.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f01811b-9091-425b-90cf-e19bdbffef91.png)'
- en: Working with Kubernetes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Kubernetes一起工作
- en: We have already launched our example microservices on Docker containers. We
    have even used CI and CD automated pipelines in order to run them on the local
    machine. You may, however, be asking an important question. How can we organize
    our environment on a larger scale and in production mode where we have to run
    multiple containers across multiple machines? Well, this is exactly what we have
    to do when implementing microservices in accordance with the idea of cloud native
    development. It turns out that many challenges still remain in this instance.
    Assuming that we have many microservices launched in multiple instances, there
    will be plenty of containers to manage. Doing things such as starting the correct
    containers at the correct time, handling storage considerations, scaling up or
    down, and dealing with failures manually would be a nightmare. Fortunately, there
    are some platforms available that help in clustering and orchestrating Docker
    containers at scale. Currently, the leader in this field is Kubernetes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们本地的Docker容器上启动了我们的示例微服务。我们甚至使用了CI和CD自动化管道，以便在本地机器上运行它们。然而，你可能有一个重要的问题。我们如何在大规模和生产模式下组织我们的环境，在那里我们必须在多台机器上运行多个容器呢？好吧，这正是我们在根据云原生开发的观念实现微服务时必须做的。然而，在这个实例中，仍然存在许多挑战。假设我们在多个实例中启动了许多微服务，将有很多容器需要管理。在正确的时间启动正确的容器，处理存储考虑，进行扩展或缩放，以及手动处理故障将是一场噩梦。幸运的是，有一些平台可以帮助在大规模上进行Docker容器的集群和编排。目前，在这个领域的领导者是Kubernetes。
- en: Kubernetes is an open-source platform for managing containerized workloads and
    services. It can act as a container platform, as a microservices platform, as
    a cloud platform, and a lot more. It automates such actions as running containers
    across different machines, scaling up and down, distributing load between containers,
    and keeping storage consistency between multiple instances of an application.
    It also has a number of additional features, including service discovery, load
    balancing, configuration management, service naming, and rolling updates. Not
    all of these features would be useful for us however as many similar features
    are provided by Spring Cloud.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个用于管理容器化工作负载和服务的开源平台。它可以作为容器平台，微服务平台，云平台，还有更多。它自动化了在不同机器上运行容器、扩展、缩减、在容器之间分配负载，以及在应用程序的多个实例之间保持存储一致性等操作。它还有许多其他功能，包括服务发现、负载均衡、配置管理、服务命名和滚动更新。然而，这些功能并非都对我们有用，因为许多类似的功能由
    Spring Cloud 提供。
- en: It is worth mentioning that Kubernetes is not the only container management
    tool out there. There is also Docker Swarm, the native tool provided within Docker.
    However, since Docker has announced native support for Kubernetes, it seems to
    be a natural choice. There are several important concepts and components regarding
    Kubernetes that we should know before we move on to any practical examples.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，Kubernetes 并不是市面上唯一的容器管理工具。还有 Docker Swarm，这是 Docker 自带的本地工具。然而，由于 Docker
    已经宣布对 Kubernetes 提供原生支持，似乎这是一个自然的选择。在深入实践之前，我们应该了解几个关于 Kubernetes 的重要概念和组件。
- en: Concepts and components
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念和组件
- en: The first term you will probably have to deal with when using Kubernetes is
    pod, which is a basic building block in Kubernetes. A pod represents a running
    process in the cluster. It can consist of one or more containers that are guaranteed
    to be co-located on the host machine and will share the same resources. One container
    per pod is the most common Kubernetes use case. Each pod has a unique IP address
    within the cluster but all containers deployed inside the same pod can communicate
    with others via `localhost`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 时，您可能首先要处理的第一个术语是 pod，这是 Kubernetes 中的基本构建块。pod 表示集群中的运行进程。它可以由一个或多个容器组成，这些容器保证在主机机器上共同定位，并将共享相同的资源。每个
    pod 中只有一个容器是最常见的 Kubernetes 用例。每个 pod 在集群中都有一个唯一的 IP 地址，但部署在同一 pod 中的所有容器可以通过
    `localhost` 与彼此通信。
- en: Another common component is a service. A service logically groups a set of pods
    and defines a policy of access to it; it is sometimes called a microservice. By
    default, a service is exposed inside a cluster but it can also be exposed onto
    an external  IP address. We can expose a service using one of the four available
    behaviors: `ClusterIP`, `NodePort`, `LoadBalancer` , and `ExternalName`. The default option
    is `ClusterIP`. This exposes the service on a cluster-internal IP, which makes
    it reachable only from within the cluster. `NodePort` exposes the service on each
    Node's IP at a static port, and automatically create `ClusterIP` for exposing
    service inside a cluster. In turn, `LoadBalancer` exposes the service externally
    using a cloud provider’s load balancer, and `ExternalName` maps the service to
    the contents of the `externalName` field. We should also take a few moments to
    discuss Kubernetes's replication controller. This handles replication and scaling
    by running a specified number of copies of a pod across the cluster. It is also
    responsible for replacing pods if the underlying node fails. Every controller
    in Kubernetes is a separate process run by `kube-controller-manager`. You can
    also find node controller, endpoints controller, and service account and token
    controllers in Kubernetes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的组件是服务。服务逻辑上组了一组 pod，并定义了对其访问的策略；有时它被称为微服务。默认情况下，服务是在集群内部暴露的，但它也可以暴露在外的
    IP 地址上。我们可以使用四种可用行为之一来暴露服务：`ClusterIP`、`NodePort`、`LoadBalancer` 和 `ExternalName`。默认选项是
    `ClusterIP`。这将在集群内部 IP 上暴露服务，使其仅可在集群内部访问。`NodePort` 将在每个节点的 IP 上以静态端口暴露服务，并自动创建
    `ClusterIP` 以在集群内部暴露服务。反过来，`LoadBalancer` 使用云提供商的负载均衡器在外部暴露服务，而 `ExternalName`
    将服务映射到 `externalName` 字段的内容。我们还应该花点时间讨论 Kubernetes 的复制控制器。此控制器通过在集群中运行指定数量的 pod
    副本来处理复制和扩展。如果底层节点失败，它还负责替换 pod。Kubernetes 中的每个控制器都是由 `kube-controller-manager`
    运行的独立进程。你还可以在 Kubernetes 中找到节点控制器、端点控制器以及服务账号和令牌控制器。
- en: Kubernetes uses an `etcd` key/value store as a backing store for all cluster
    data. Inside every node of the cluster is an agent called **kubelet**, which is
    responsible for ensuring that containers are running in a pod. Every command sent
    to Kubernetes by a user is processed by Kubernetes API exposed by `kubeapi-server`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用一个 `etcd` 键/值存储作为所有集群数据的后端存储。在集群中的每个节点都有一个名为 **kubelet** 的代理，它负责确保容器在
    pod 中运行。用户发送给 Kubernetes 的每个命令都由 `kubeapi-server` 暴露的 Kubernetes API 处理。
- en: Of course, this is a really simplified explanation of Kubernetes's architecture.
    There are more components and tools available that have to be configured properly
    in order to run highly available Kubernetes clusters successfully. This is not
    a trivial task to perform, and it requires a significant amount of knowledge about
    this platform. Fortunately, there is a tool out there that makes it easy to run
    a Kubernetes cluster locally—Minikube.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是对 Kubernetes 架构的一个非常简化的解释。为了成功运行高可用的 Kubernetes 集群，还有更多组件和工具需要正确配置。执行此任务并非易事，它需要对这个平台有大量的了解。幸运的是，有一个工具可以使在本地运行
    Kubernetes 集群变得容易——Minikube。
- en: Running Kubernetes locally via Minikube
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Minikube 在本地运行 Kubernetes
- en: Minikube is a tool that makes it easy to run Kubernetes locally. It runs a single-node
    Kubernetes cluster inside a VM on the local machine. It is definitely the most
    suitable choice in development mode. Of course, Minikube does not support all
    of the features provided by Kubernetes; only the most important ones, including
    DNS, NodePorts, Config Map, Dashboard, and Ingress.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 是一个使在本地运行 Kubernetes 变得简单的工具。它在一个本地机器上的 VM 中运行一个单节点 Kubernetes 集群。在开发模式下，它绝对是最佳选择。当然，Minikube
    不支持 Kubernetes 提供的所有功能；只包括最重要的功能，包括 DNS、NodePorts、Config Map、Dashboard 和 Ingress。
- en: 'To run Minikube on Windows, we need to have a virtualization tool installed.
    However, if you have already run Docker, you will have probably installed Oracle
    VM VirtualBox. In this case, you don''t have to do anything other than download
    and install the latest release of Minikube, which you can check at [https://github.com/kubernetes/minikube/releases](https://clicktime.symantec.com/a/1/eXr_fIrvCIRYzEHt0YvbtkptTqcVd9nJzBV28fxoaTY=?d=7tChM-hIl54SsiVoHKrovXbmLIi8ouu38bfWFa5LjYebKneJvW_c2_HMgDdoq431rSiEnNRRoWc7WI40qLP-zxO_svn7BtB5YkP7_3z6XE1bc9UDw_gg4B_LUQLmxfklfTjgbs0J-dnBHLc3GOsVYjvBMyOE-nmJR1SuKthIzdMfxP8oasaAGIamKBmwy-pKxDOZYKGzKE4iEAO1nFo15LHQ7enPYrMhvcEhb3LDIMsYYwnwVTe52q36t77MaAeAFdq7DgkU1BLlVMydfq9vglCYhLnhnOOzSDesZnjGR3spuBjVhNyCD3pcc73yC-ARPXPUpScKDxqUYA8pZg40QrbDOyzuC95KNm-9vIqcPXR6iDgu8QK_SscvFxnDi4A%3D&u=https%3A%2F%2Fgithub.com%2Fkubernetes%2Fminikube%2Freleases) ,
    and `kubectl.exe` , as described at [https://storage.googleapis.com/kubernetes-release/release/stable.txt](https://storage.googleapis.com/kubernetes-release/release/stable.txt).
    Both files `minikube.exe` and `kubectl.exe` should be included in the `PATH` environment
    variable. In addition, Minikube provides its own installer, `minikube-installer.exe` ,
    which will automatically add `minikube.exe` to your path. You may then start Minikube
    from your command line by running the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上运行 Minikube，我们需要安装一个虚拟化工具。然而，如果您已经运行了 Docker，您可能已经安装了 Oracle VM
    VirtualBox。在这种情况下，您只需要下载并安装 Minikube 的最新版本，您可以查看 [https://github.com/kubernetes/minikube/releases](https://clicktime.symantec.com/a/1/eXr_fIrvCIRYzEHt0YvbtkptTqcVd9nJzBV28fxoaTY=?d=7tChM-hIl54SsiVoHKrovXbmLIi8ouu38bfWFa5LjYebKneJvW_c2_HMgDdoq431rSiEnNRRoWc7WI40qLP-zxO_svn7BtB5YkP7_3z6XE1bc9UDw_gg4B_LUQLmxfklfTjgbs0J-dnBHLc3GOsVYjvBMyOE-nmJR1SuKthIzdMfxP8oasaAGIamKBmwy-pKxDOZYKGzKE4iEAO1nFo15LHQ7enPYrMhvcEhb3LDIMsYYwnwVTe52q36t77MaAeAFdq7DgkU1BLlVMydfq9vglCYhLnhnOOzSDesZnjGR3spuBjVhNyCD3pcc73yC-ARPXPUpScKDxqUYA8pZg40QrbDOyzuC95KNm-9vIqcPXR6iDgu8QK_SscvFxnDi4A%3D&u=https%3A%2F%2Fgithub.com%2Fkubernetes%2Fminikube%2Freleases)
    ，并 `kubectl.exe` ，如 [https://storage.googleapis.com/kubernetes-release/release/stable.txt](https://storage.googleapis.com/kubernetes-release/release/stable.txt)
    描述。文件 `minikube.exe` 和 `kubectl.exe` 应该包括在 `PATH` 环境变量中。此外，Minikube 提供自己的安装程序
    `minikube-installer.exe` ，它将自动将 `minikube.exe` 添加到您的路径中。然后，您可以从命令行通过运行以下命令启动 Minikube：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding command initializes a `kubectl` context called `minikube`. It
    contains the configuration that allows you to communicate with the Minikube cluster.
    You can now use `kubectl` commands in order to maintain your local cluster created
    by Minikube and deploy your containers there. An alternative solution to a command-line
    interface is Kubernetes dashboard. Kubernetes dashboard can be enabled for your
    node by calling `minikube` dashboard. You can create, update, or delete deployment
    using this dashboard, as well as list and view a configuration of all pods, services,
    ingresses, and replication controllers. It is possible to easily stop and remove
    a local cluster by invoking the following commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令初始化了一个名为`minikube`的`kubectl`上下文。它包含了允许你与Minikube集群通信的配置。现在你可以使用`kubectl`命令来维护由Minikube创建的本地集群，并在其中部署容器。命令行界面的替代方案是Kubernetes仪表板。通过调用`minikube`
    dashboard，可以为你的节点启用Kubernetes仪表板。您可以使用这个仪表板创建、更新或删除部署，以及列出和查看所有pods、服务、ingress和复制控制器的配置。通过以下命令可以轻松停止和删除本地集群：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Deploying an application
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: 'Every configuration existing on a Kubernetes cluster is represented by Kubernetes
    objects. These objects can be managed through the Kubernetes API and should be
    expressed in a YAML format. You may use that API directly, but will probably decide
    to leverage the `kubectl` command-line interface to make all the necessary calls
    for you. The description of a newly created object in Kubernetes has to provide
    specification that describes its desired state, as well as some basic information
    about the object. The following are some required fields in the YAML configuration
    file that should always be set:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群上存在的每个配置都由Kubernetes对象表示。这些对象可以通过Kubernetes API进行管理，并且应该以YAML格式表达。你可能会直接使用那个API，但可能会决定利用`kubectl`命令行界面为你做所有必要的调用。在Kubernetes上新建对象的描述必须提供描述其期望状态的规格，以及关于对象的一些基本信息。以下是在YAML配置文件中应始终设置的一些必需字段：
- en: '`apiVersion`: This indicates the version of the Kubernetes API used to create
    an object. An API always requires the JSON format in a request but `kubectl` automatically
    converts YAML input into JSON.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`：这指示了用于创建对象的Kubernetes API的版本。API在请求中总是需要JSON格式，但`kubectl`会自动将YAML输入转换为JSON。'
- en: '`kind`: This sets the kind of object to create. There are some predefined types
    available such as Deployment, Service, Ingress, or ConfigMap.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`：这设置了要创建的对象的种类。有一些预定义的类型可供选择，例如Deployment、Service、Ingress或ConfigMap。'
- en: '`metadata`: This allows you to identify the object by name, UID or, optional
    namespace.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`：这允许你通过名称、UID或可选的命名空间来标识对象。'
- en: '`spec`: This is the proper definition of an object. The precise format of a
    specification depends on an object''s kind and contains nested fields specific
    to that object.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`：这是对象的正确定义。规格的精确格式取决于对象的类型，并包含特定于该对象的嵌套字段。'
- en: 'Usually, when creating new objects on Kubernetes, its `kind` is deployment.
    In the `Deployment` YAML file, shown as follows, there are two important fields
    set. The first of, `replicas`, specifies the number of desired pods. In practice,
    this means that we run two instances of the containerized application. The second,
    `spec.template.spec.containers.image`, sets the name and version of the Docker
    image that will be launched inside a pod. The container will be exposed on port
    `8090`, on which `order-service` listens for HTTP connections:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Kubernetes上创建新对象时，其`kind`是部署。在下面的`Deployment` YAML文件中，有两个重要的字段被设置。首先是`replicas`，它指定了期望的pods数量。实际上，这意味着我们将运行容器化应用程序的两个实例。第二个是`spec.template.spec.containers.image`，它设置了将在pods内部启动的Docker镜像的名称和版本。容器将在端口`8090`上暴露，`order-service`在此端口监听HTTP连接：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Assuming the preceding code is stored in the file `order-deployment.yaml`,
    we can now deploy our containerized application on Kubernetes using imperative
    management as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面的代码存储在文件`order-deployment.yaml`中，我们现在可以使用以下命令基于 imperative management 在
    Kubernetes 上部署我们的容器化应用程序：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alternatively, you can perform the same action based on the declarative management
    approach, illustrated as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以基于声明式管理方法执行相同的操作，如下所示：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We now have to create the same deployment file for all the microservices and
    `discovery-service`. The subject of `discovery-service` is a very curious matter.
    We have the option to use built-in Kubernetes discovery based on pods and services,
    but our main goal here is to deploy and run Spring Cloud components on that platform.
    So, before deploying any microservices, we should first deploy, run, and expose
    Eureka on Kubernetes. The following is a deployment file of `discovery-service`
    that can also can be applied to Kubernetes by calling the `kubectl apply` command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须为所有微服务和`discovery-service`创建相同的部署文件。`discovery-service`的主题是一个非常好奇的事情。我们有使用基于pods和服务的内置Kubernetes发现的选项，但我们的主要目标是在这个平台上部署和运行Spring
    Cloud组件。所以，在部署任何微服务之前，我们首先应该部署、运行并暴露Eureka在Kubernetes上。以下是`discovery-service`的部署文件，也可以通过调用`kubectl
    apply`命令应用于Kubernetes：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you create a Deployment, Kubernetes automatically creates pods for you.
    Their number is equal to the value set in the `replicas` field. A pod is not able
    to expose the API provided by the application deployed on the container, it just
    represents a running process on your cluster. To access the API provided by the
    microservices running inside pods, we have to define a service. Let''s remind
    ourselves what a service is. A service is an abstraction that defines a logical
    set of pods and a policy by which to access them. The set of pods targeted by
    a service is usually determined by a label selector. There are four types of service
    available in Kubernetes. The simplest and default one is `ClusterIP`, which exposes
    a service internally. If you would like to access a service from outside the cluster,
    you should define the type `NodePort`.  This option has been set out in the following
    example YAML file; now, all the microservices can communicate with Eureka using
    its Kubernetes service name:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个Deployment，Kubernetes会自动为你创建pods。它们的数量等于`replicas`字段中设置的值。一个pods不能暴露部署在容器上的应用程序提供的API，它只是代表集群上运行的一个进程。为了访问运行在pods内的微服务提供的API，我们必须定义一个服务。让我们回顾一下服务是什么。服务是一个定义了逻辑集合
    of pods和访问它们的策略的抽象。服务针对的pods集合通常由一个标签选择器确定。Kubernetes中提供了四种服务类型。最简单且默认的是`ClusterIP`，它在一个内部暴露服务。如果你希望从集群外部访问一个服务，你应该定义类型为`NodePort`的服务。这个选项已经在下面的YAML文件示例中设置；现在，所有微服务都可以使用其Kubernetes服务名称与Eureka通信：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In fact, all of our microservices deployed on Minikube should be available outside
    the cluster, as we would like to access the API exposed by them. To do this, you
    need to provide the similar YAML configuration to that in the preceding example,
    changing only the service's name, labels and port.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们部署在Minikube上的所有微服务都应该能在集群外部访问，因为我们需要访问它们暴露的API。为此，你需要提供与前面示例类似的YAML配置，只更改服务的名称、标签和端口。
- en: 'There is only one last component that should be present in our architecture:
    API Gateway. We could deploy a container with the Zuul proxy, however we need
    to introduce the popular Kubernetes object, Ingress. This component is responsible for
    managing external access to services that are typically exposed via HTTP. Ingress
    provides load balancing, SSL termination, and name-based virtual hosting. The
    Ingress configuration YAML file is shown as follows; note that all the services
    can be accessed on the same port, `80`, on different URL paths:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们架构中只有一个组件应该存在：API网关。我们可以部署一个带有Zuul代理的容器，但是我们需要引入流行的Kubernetes对象，Ingress。这个组件负责管理通常通过HTTP暴露的服务的外部访问。Ingress提供负载均衡、SSL终止和基于名称的虚拟托管。Ingress配置的YAML文件如下所示；注意所有服务可以在不同URL路径上的相同端口`80`上访问：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Maintaining a cluster
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护集群
- en: 'Maintaining a Kubernetes cluster is rather complex. In this section, we will
    show you how to use some basic commands and the UI dashboard in order to view
    the object currently existing on the cluster. Let''s first list the elements that
    have been created for the purpose of running our example microservices-based system.
    First, we display a list of deployments by running the command `kubectl get deployments`,
    which should result in the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 维护Kubernetes集群是非常复杂的。在本节中，我们将向您展示如何使用一些基本命令和UI仪表板来查看集群上当前存在的对象。首先，我们列出为运行我们的微服务
    based系统而创建的元素。首先，我们通过运行`kubectl get deployments`命令来显示部署列表，这应该会导致以下结果：
- en: '![](img/2e7394a7-2440-45a6-abdb-b4bb42eec586.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e7394a7-2440-45a6-abdb-b4bb42eec586.png)'
- en: 'One deployment can create a number of pods. You can check the list of pods
    by calling the `kubectl get pods` command as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个部署可以创建多个pods。您可以如下调用`kubectl get pods`命令来查看pods列表：
- en: '![](img/3603bc5a-2cef-41ac-a82e-3b2a96cfbeeb.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3603bc5a-2cef-41ac-a82e-3b2a96cfbeeb.png)'
- en: 'The same list can be viewed using the UI dashboard. You can view these details
    by clicking on the selected row, or check out the container logs by clicking the
    icon available on the right-hand side of each row, as shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用UI仪表板查看相同的列表。通过点击选中的行或者点击每行右侧的图标来查看这些详细信息，如下图所示：
- en: '![](img/82fecacc-7077-472a-b216-14d941e30e55.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82fecacc-7077-472a-b216-14d941e30e55.png)'
- en: 'The full list of available services can be displayed using the command `kubectl
    get services`. There are some interesting fields here, including one that indicates
    an IP address on which a service is available inside a cluster (CLUSTER-IP), and
    a pair of ports (PORT(S)) on which services are exposed internally and externally.
    We can also call the HTTP API exposed on `account-service` at the address `http://192.168.99.100:31099`,
    or the Eureka UI dashboard at the address`http://192.168.99.100:31931`, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用命令`kubectl get services`显示所有可用服务的完整列表。这里有一些有趣的字段，包括一个指示集群内部可用服务IP地址的字段（CLUSTER-IP），以及服务内部和外部暴露的一对端口（PORT(S)）。我们还可以通过`http://192.168.99.100:31099`调用`account-service`上暴露的HTTP
    API，或者通过`http://192.168.99.100:31931`调用Eureka UI仪表板，如下所示：
- en: '![](img/0307a557-39dc-4f7d-98af-f49d8c3c73a7.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0307a557-39dc-4f7d-98af-f49d8c3c73a7.png)'
- en: 'Similar to previous objects, services can also be displayed using the Kubernetes
    dashboard, as shown in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的对象类似，服务也可以使用Kubernetes仪表板显示，如下所示：
- en: '![](img/6d5eb014-3315-437a-861c-69c44ff7a67b.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d5eb014-3315-437a-861c-69c44ff7a67b.png)'
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we discussed a lot of topics not obviously related to Spring
    Cloud, but the tools explained in this chapter will allow you to take advantage
    of migrating to microservices-based architecture. When using Docker, Kubernetes,
    or tools for CI or CD, there is an obvious advantage to cloud-native development
    with Spring Cloud. Of course, all of the presented examples have been launched
    on the local machine, but you can refer to these to imagine how that process could
    be designed in a production environment across a cluster of remote machines.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多与Spring Cloud明显不相关的主题，但本章解释的工具将使您能够利用迁移到基于微服务的架构。在使用Docker、Kubernetes或CI/CD工具时，采用Spring
    Cloud进行云原生开发具有明显的优势。当然，所有示例都已在本机上启动，但您可以参考这些示例来想象该过程如何在远程机器集群的生产环境中设计。
- en: In this chapter, we wanted to show you how simple and quick it can be to move
    from running Spring microservices manually on the local machine to a fully-automated
    process that builds the application from source code, creates and runs a Docker
    image with your application, and deploys it on a cluster consisting of multiple
    machines. It is not easy to describe all of the features provided by such complex
    tools as Docker, Kubernetes, or Jenkins in a single chapter. Instead, the main
    purpose here was to give you a look at the bigger picture of how to design and
    maintain a modern architecture based on concepts such as containerization, automated
    deploying, scaling, and a private, on-premise cloud.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们想向您展示将Spring微服务手动运行在本地机器转变为完全自动化的过程是多么简单和快速，该过程从源代码构建应用程序，创建包含应用程序的Docker镜像，并在由多台机器组成的集群上部署它。在一章中很难描述Docker、Kubernetes或Jenkins等复杂工具提供的所有功能。取而代之的是，这里的主要目的是为您提供如何基于容器化、自动化部署、扩展和私有、本地云等概念设计和维护现代架构的更广阔视野。
- en: We're now getting very close to the end of the book. We have already discussed
    most of the planned topics related to the Spring Cloud framework. In the next
    chapter, we will show you how to use two of the most popular cloud platforms available
    on the web, allowing you to continuously deliver Spring Cloud applications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们离书的结尾已经非常近了。我们已经讨论了与Spring Cloud框架相关的计划主题的大部分。在下一章中，我们将向您展示如何使用两个最受欢迎的在线云平台，使您能够持续交付Spring
    Cloud应用程序。
