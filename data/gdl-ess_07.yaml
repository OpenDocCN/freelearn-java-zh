- en: Chapter 7. Testing and Reporting with Gradle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用Gradle进行测试和报告
- en: 'In this chapter, we will cover four different topics: testing with TestNG,
    integration testing, code coverage with JaCoCo, and code analysis with Sonar.
    In [Chapter 2](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 2. Building Java Projects"), *Building Java Projects*, we already discussed
    unit testing with JUnit. In this chapter, we''ll cover another widely used testing
    tool, TestNG. Code coverage and code quality are the other two important aspects
    in **test-driven development** (**TDD**). In today''s agile development process,
    developers need continuous feedback on the code developed by them. Code quality
    tools help us to achieve this goal. Often, these tools are integrated with the
    **Continuous Integration** (**CI**) systems so that these reports are created
    on a daily basis (may be even after each commit), shared among different teams,
    and even be persisted for future analysis. In this chapter, we will be focusing
    only on the Gradle aspects of different tools. We will mainly cover different
    Gradle plugins that support these features.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖四个不同的主题：使用TestNG进行测试、集成测试、使用JaCoCo进行代码覆盖率以及使用Sonar进行代码分析。在[第2章](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0
    "第2章。构建Java项目")中，*构建Java项目*，我们已经讨论了使用JUnit进行单元测试。在本章中，我们将介绍另一个广泛使用的测试工具，TestNG。代码覆盖率和代码质量是**测试驱动开发**（**TDD**）中的另外两个重要方面。在今天的敏捷开发过程中，开发者需要对其开发的代码进行持续的反馈。代码质量工具帮助我们实现这一目标。通常，这些工具与**持续集成**（**CI**）系统集成，以便这些报告每天（甚至每次提交后）生成，在不同团队之间共享，甚至可以持久化以供未来分析。在本章中，我们将专注于不同工具的Gradle方面。我们将主要介绍支持这些特性的不同Gradle插件。
- en: Testing with TestNG
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TestNG进行测试
- en: 'Working with TestNG is similar to the JUnit integration that we discussed in
    [Chapter 2](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0 "Chapter 2. Building
    Java Projects"), *Building Java Projects*. The very first step is to create the
    build file with TestNG dependencies and configure the test closure. The following
    build file adds the TestNG library as the `testCompile` dependency and in the
    test closure, we added a `testng.xml` file to execute the test cases. In this
    section, we will briefly discuss the use of `testng.xml`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TestNG与我们在[第2章](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0
    "第2章。构建Java项目")中讨论的JUnit集成类似，即*构建Java项目*。第一步是创建带有TestNG依赖项的构建文件并配置测试闭包。以下构建文件将TestNG库添加为`testCompile`依赖项，并在测试闭包中，我们添加了一个`testng.xml`文件来执行测试用例。在本节中，我们将简要讨论`testng.xml`的使用：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: However, you can read more about TestNG configuration at [http://testng.org/doc/documentation-main.html](http://testng.org/doc/documentation-main.html).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以在[http://testng.org/doc/documentation-main.html](http://testng.org/doc/documentation-main.html)了解更多关于TestNG配置的信息。
- en: 'In our example, we have created three test cases named as `verifyMapSize`,
    `verifyMapNotNull`, and `addEvenNumbers`. These test cases are grouped as `Smoke`
    and `Integration` test cases. If you execute a Gradle test command, all the three
    test cases will be executed and the test report will be created in the `build/reports/tests`
    directory. The look and feel of the report is similar to the JUnit report that
    we saw earlier. The actual TestNG report is created in the `test-output/` directory
    in the project home directory. Both JUnit and TestNG generate their own different
    report formats, but Gradle reconciles them into a standard look and feel:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了三个测试用例，分别命名为`verifyMapSize`、`verifyMapNotNull`和`addEvenNumbers`。这些测试用例被分组为`Smoke`和`Integration`测试用例。如果你执行Gradle测试命令，所有三个测试用例都将被执行，并在`build/reports/tests`目录中创建测试报告。报告的外观和感觉与我们在前面看到的JUnit报告类似。实际的TestNG报告是在项目主目录下的`test-output/`目录中创建的。JUnit和TestNG都生成它们自己的不同报告格式，但Gradle将它们协调成标准的外观和感觉：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A TestNG test case can be executed from a command line, Ant file, Gradle script,
    Eclipse plugin, or a TestNG test suite file. TestNG suite files provide a flexible
    mechanism control for the test execution. In a test suite file, you can define
    test classes, tests, test group names, listener information, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个TestNG测试用例可以从命令行、Ant文件、Gradle脚本、Eclipse插件或TestNG测试套件文件中执行。TestNG套件文件提供了一个灵活的测试执行控制机制。在测试套件文件中，你可以定义测试类、测试、测试组名称、监听器信息等。
- en: We have created a sample `testng.xml` file in the `src/test/resource` folder.
    The file has some important information. The **listener configuration** to create
    a report format, a **test group** declaration as `Smoke`, and a test class named
    `com.packtpub.ge.ch7.HashTest`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`src/test/resource`文件夹中创建了一个示例`testng.xml`文件。该文件包含一些重要信息。用于创建报告格式的**监听器配置**，一个**测试组**声明为`Smoke`，以及一个名为`com.packtpub.ge.ch7.HashTest`的测试类。
- en: 'Gradle doesn''t force you to put `testng.xml` in the `src/test/resources`,
    and we''re just doing this as a means to keep it organized:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle不会强迫你将`testng.xml`放在`src/test/resources`中，我们只是这样做作为一种保持其组织性的手段：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we have only included test cases that are marked as `Smoke`, the TestNG
    invoked only two test cases, `verifyMapNotNull` and `addEvenNumbers`, when we
    executed the `gradle test` command. The following figure shows the TestNG report
    that is created in the `<Project_Home>/ test-output/` directory:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只包含了标记为`Smoke`的测试用例，当我们执行`gradle test`命令时，TestNG只调用了两个测试用例，`verifyMapNotNull`和`addEvenNumbers`。以下图显示了在`<Project_Home>/test-output/`目录中创建的TestNG报告：
- en: '![Testing with TestNG](img/00015.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![使用TestNG进行测试](img/00015.jpeg)'
- en: Figure 7.1
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1
- en: Integration testing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Unit testing is one of the key step in software development life cycle. It is
    one of the first checks to verify the code quality. Most of the basic functionalities
    can be tested with unit test cases. They are quick and take little time to execute.
    We discussed both JUnit framework and TestNG framework to unit test the code.
    The next step in the quality check process is integration testing. As by general
    definition of unit testing, you divide your code into small units and test them
    independently, which is good when you are developing your code independently.
    Once you commit the code and integrate the code with other developers, you need
    another level of testing, which is known as integration testing. It verifies the
    communication between different components working together as expected or not.
    Your test reports might give 100 percent success results in unit testing, but
    unless and until you perform integration testing, you cannot be assured of the
    functionality of the software as a whole.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是软件开发生命周期中的关键步骤之一。它是验证代码质量的第一步检查。大多数基本功能都可以通过单元测试用例进行测试。它们快速且执行时间短。我们讨论了JUnit框架和TestNG框架来对代码进行单元测试。质量检查流程的下一步是集成测试。根据单元测试的一般定义，你将代码划分为小的单元并独立测试它们，这在独立开发代码时是好的。一旦你提交了代码并与其他开发者集成代码，你需要另一个级别的测试，这被称为集成测试。它验证不同组件按预期协同工作或否。你的测试报告可能在单元测试中给出100%的成功结果，但除非你执行集成测试，否则你不能保证整个软件的功能。
- en: 'We have already seen Gradle support for unit testing and how Gradle provides
    conventions to write your test classes in different directory structures and tasks
    to execute the test cases. Gradle does not differentiate between unit testing
    and integration testing, if we talk in terms of the convention it provides. To
    enable integration testing along with unit testing in Gradle, you need to customize
    the Gradle to enable both. Consider the following hierarchy for your project source
    code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Gradle对单元测试的支持以及Gradle如何提供约定来在不同的目录结构和任务中编写测试类以及执行测试用例。在提供约定的术语中，Gradle不会区分单元测试和集成测试。要在Gradle中同时启用单元测试和集成测试，你需要自定义Gradle以启用两者。考虑以下项目源代码的层次结构：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the standard folder structure you create for your source and test code.
    You create `src/test/java` to store your unit test cases. Now, if you want to
    add integration test cases to your project, you can merge the integration test
    cases in the same directory structure; however, this would not be a good design—since
    you might want to execute the unit test case each time you build your project
    and might want to execute the integration test biweekly or weekly—as it might
    consume more time depending on the project complexity and size. Thus, rather than
    merging the integration tests to your unit test cases' directory structure, we
    recommend you to create a separate directory structure, `src/integrationTest/java`,
    for integration test cases, and you can configure the same in your Gradle build
    scripts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您为源代码和测试代码创建的标准文件夹结构。您创建 `src/test/java` 来存储您的单元测试用例。现在，如果您想将集成测试用例添加到项目中，您可以将集成测试用例合并到相同的目录结构中；然而，这并不是一个好的设计——因为您可能希望在构建项目时每次都执行单元测试，并且可能希望每两周或每周执行一次集成测试——这可能会根据项目的复杂性和大小消耗更多时间。因此，而不是将集成测试合并到单元测试用例的目录结构中，我们建议您为集成测试用例创建一个单独的目录结构，`src/integrationTest/java`，并在您的
    Gradle 构建脚本中进行配置。
- en: 'The following will be the updated directory structure to store the integration
    test cases:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是存储集成测试用例的更新目录结构：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you have created the directory structure, you need to configure this in
    your Gradle build script. The updated build script would be as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了目录结构，您需要在您的 Gradle 构建脚本中进行配置。更新的构建脚本如下：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have added one extra configuration, `integrationTest`, to add the integration
    test cases. To execute the integration tests, we have also defined one task, `runIntegrationTest`,
    which is of type `Test` and configured the `testClassesDir` and classpath attributes.
    Once we have added additional `sourceSets` to the build script, the `java` plugin
    automatically adds two new dependency configurations to your build script `integrationTestCompile`
    and `integrationTestRuntime`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个额外的配置，`integrationTest`，以添加集成测试用例。为了执行集成测试，我们还定义了一个任务，`runIntegrationTest`，其类型为
    `Test`，并配置了 `testClassesDir` 和类路径属性。一旦我们在构建脚本中添加了额外的 `sourceSets`，Java 插件会自动将两个新的依赖配置添加到您的构建脚本中
    `integrationTestCompile` 和 `integrationTestRuntime`。
- en: 'Execute the following command to check for the current dependencies:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以检查当前依赖项：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, `integrationTestCompile` can be used to configure dependencies required
    to compile the test cases and `integrationTestRuntime` can be used to configure
    dependencies required to execute the test cases. As you can see, no dependencies
    are explicitly configured for integration test cases. You can configure them under
    dependencies closure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`integrationTestCompile` 可以用于配置编译测试用例所需的依赖项，而 `integrationTestRuntime` 可以用于配置执行测试用例所需的依赖项。如您所见，没有为集成测试用例显式配置依赖项。您可以在依赖项闭包下进行配置：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We do not want to execute the integration tests each time we build the project.
    Thus, to execute the integration test, you need to explicitly execute the following
    command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在每次构建项目时都执行集成测试。因此，要执行集成测试，您需要显式执行以下命令：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will invoke the `runIntegrationTest` task and will execute the integration
    test cases. If you want to execute these test cases each time you build your code,
    you can link this task with other tasks using `dependsOn` or any other dependency
    attributes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用 `runIntegrationTest` 任务并执行集成测试用例。如果您希望在构建代码时每次都执行这些测试用例，您可以使用 `dependsOn`
    或其他依赖属性将此任务与其他任务链接。
- en: Code coverage
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: There are so many coverage tools available for source code analysis such as
    EMMA, Corbatura, JaCoCo, and so on. In this section, we'll cover Gradle integration
    with JaCoCo to find the source code analysis.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用于源代码分析的覆盖率工具，例如 EMMA、Corbatura、JaCoCo 等。在本节中，我们将介绍 Gradle 与 JaCoCo 的集成以进行源代码分析。
- en: Before we get started, we need to understand what code coverage is and why it
    is important in the test-driven development.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要了解代码覆盖率是什么以及为什么它在测试驱动开发中很重要。
- en: Code coverage is a metric that we can use to check how much of the source code
    was tested. Higher code coverage means a greater percentage of our code has been
    tested. Code coverage is typically done in the unit testing cycle. During code
    coverage, a developer must ensure that different logical paths in the source code
    have been tested and verified to achieve better code coverage.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是我们用来检查源代码被测试了多少的指标。更高的代码覆盖率意味着我们的代码被测试的比例更大。代码覆盖率通常在单元测试周期中完成。在代码覆盖率期间，开发者必须确保源代码中的不同逻辑路径已被测试和验证，以达到更好的代码覆盖率。
- en: Here, it is important to understand that the code coverage is not directly related
    to code quality. High code coverage does not guarantee that the quality code has
    been written. A developer must use static code analysis tools such as PMD ([https://pmd.github.io/](https://pmd.github.io/))
    to find the quality of the code. Another point to remember is that, even with
    100 percent of code coverage, there is no guarantee that a complete bug-free code
    has been written. Thus, many developers argue that this not a right metric to
    be considered for the code quality or unit test. However, 70-80 percent code coverage
    is considered to be a good number for healthy code coverage.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，重要的是要理解代码覆盖率与代码质量没有直接关系。高代码覆盖率并不能保证编写了高质量的代码。开发者必须使用静态代码分析工具，如PMD ([https://pmd.github.io/](https://pmd.github.io/))
    来查找代码的质量。另一个需要记住的点是，即使有100%的代码覆盖率，也不能保证编写了完全无错误的代码。因此，许多开发者认为这不是衡量代码质量或单元测试的正确指标。然而，70-80%的代码覆盖率被认为是健康代码覆盖率的好数字。
- en: 'In Gradle, the code coverage tool, JaCoCo, can be applied to a project like
    any other plugin:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle中，代码覆盖率工具JaCoCo可以像任何其他插件一样应用于项目：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `build.gradle` file has the following content. We have created a few TestNG
    test cases to test the functionalities of the source code. We have also configured
    a test task to be dependent on the `jacocoTestReport` task. This is to make sure
    that test cases are executed before running and creating the test coverage reports:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`build.gradle`文件包含以下内容。我们创建了一些TestNG测试用例来测试源代码的功能。我们还配置了一个测试任务，使其依赖于`jacocoTestReport`任务。这是为了确保在运行和创建测试覆盖率报告之前执行测试用例：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By default, the report will be created in the `<build dir>/reports/jacoco/test/html
    directory` and an HTML report file will be generated. For example, we have created
    a simple POJO `User.java` file with the getter and setter methods. Also, we have
    created a few unit test cases to verify the functionalities. The two sample test
    cases are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，报告将在`<build dir>/reports/jacoco/test/html`目录下创建，并将生成一个HTML报告文件。例如，我们创建了一个简单的POJO
    `User.java`文件，其中包含getter和setter方法。我们还创建了一些单元测试用例来验证功能。以下两个示例测试用例如下：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we can execute the `jacocoTestReport` task to generate the code coverage
    report:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以执行`jacocoTestReport`任务来生成代码覆盖率报告：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the coverage report, you can observe that all the methods of the Java class
    were tested unit tests. You can further drill down following the links in the
    report that shows the line coverage on the source code. The source code is marked
    in green and red to display what is covered and what is not tested. The following
    figure (*Figure 7.2*) shows the code coverage statistics for the `User.java` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖率报告中，你可以观察到Java类的所有方法都经过了单元测试。你可以进一步通过报告中的链接深入挖掘，这些链接显示了源代码的行覆盖率。源代码用绿色和红色标记来显示已覆盖和未测试的部分。以下图（*图7.2*）显示了`User.java`类的代码覆盖率统计：
- en: '![Code coverage](img/00016.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![代码覆盖率](img/00016.jpeg)'
- en: Figure 7.2
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2
- en: 'By default, an HTML report file is generated in the `build/reports/jacoco/test/html`
    directory. Also, the default version of the `jacoco` plugin can be modified by
    modifying the `jacoco` extension as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，HTML报告文件将在`build/reports/jacoco/test/html`目录下生成。此外，`jacoco`插件的默认版本可以通过修改以下`jacoco`扩展来修改：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Similarly, the report can be customized by configuring the `jacocoTestReport`
    task as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以通过以下方式配置`jacocoTestReport`任务来自定义报告：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Code analysis reports
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码分析报告
- en: 'Sonar is one of the most popular quality management tools that gives a complete
    analysis of a project in terms of lines of code, documentation, test coverage,
    issues, and complexities. As a developer, we are mainly interested in the following
    areas:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Sonar是最受欢迎的质量管理工具之一，它可以从代码行数、文档、测试覆盖率、问题复杂度等方面对项目进行全面分析。作为开发者，我们主要对以下领域感兴趣：
- en: Duplicate lines of code
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复的代码行
- en: Lacking comments in the source code, especially in public APIs
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码中缺少注释，尤其是在公共API中
- en: Not following coding standards and best practices
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不遵循编码标准和最佳实践
- en: Finding code complexity
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找代码复杂性
- en: Code coverage produced by unit tests
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试产生的代码覆盖率
- en: In this section, we will discuss Gradle integration with Sonar. The only prerequisite
    is, the Sonar server should be installed and running.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Gradle与Sonar的集成。唯一的前提是，Sonar服务器应该已安装并运行。
- en: 'A prerequisite to run Sonar is to have Java installed on the box. Once prerequisites
    are met, you can install Sonar in just three simple steps as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Sonar的前提是在机器上安装Java。一旦满足前提条件，你只需三个简单步骤就可以安装Sonar，如下所示：
- en: Download the distribution from [http://www.sonarqube.org/downloads/](http://www.sonarqube.org/downloads/)
    and unzip it.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://www.sonarqube.org/downloads/](http://www.sonarqube.org/downloads/)下载分发版并将其解压。
- en: 'Open a console and start the Sonar server:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并启动Sonar服务器：
- en: On Windows platforms, start `$SONAR_HOME\bin\windows-x86-32\StartSonar.bat`
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows平台上，启动`$SONAR_HOME\bin\windows-x86-32\StartSonar.bat`
- en: On other platforms, start `$SONAR_HOME/bin/[OS]/sonar.sh`
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他平台上，启动`$SONAR_HOME/bin/[OS]/sonar.sh`
- en: Go to `http://localhost:9000`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`http://localhost:9000`。
- en: To run `sonar-runner` plugin, we just need to apply the plugin `sonar-runner`
    and configure it to connect to the Sonar server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`sonar-runner`插件，我们只需应用`sonar-runner`插件并将其配置为连接到Sonar服务器。
- en: 'Create the build file `build.gradle` for your project with the following contents:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容为你的项目创建构建文件`build.gradle`：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The above configuration is self-explanatory. You need to add configurations
    such as Sonar URL, DB URL, and JDBC driver details, and our build file is ready.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置是自我解释的。你需要添加诸如Sonar URL、DB URL和JDBC驱动程序详情等配置，我们的构建文件就准备好了。
- en: 'The next step is to run the `sonarRunner` task for code analysis. After successful
    execution of this task, you will find the report hosted on the Sonar server:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是运行`sonarRunner`任务进行代码分析。在成功执行此任务后，你将在Sonar服务器上找到报告：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, you can open `http://localhost:9000/` to browse the projects. This page
    is the default dashboard page, which shows the details of all the projects. You
    can find your project and browse through the details. The details will be displayed
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以打开`http://localhost:9000/`来浏览项目。这个页面是默认仪表板页面，显示了所有项目的详细信息。你可以找到你的项目并浏览其详细信息。详细信息将如下显示：
- en: '![Code analysis reports](img/00017.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![代码分析报告](img/00017.jpeg)'
- en: Figure 7.3
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3
- en: 'You can again further verify the details of each metric, just by following
    the links provided in the project home page. For example, the following figure
    displays the source code-related metrics in the Sonar. It provides details such
    as code complexity, lines of code, methods, documentation, and so on:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过遵循项目主页提供的链接进一步验证每个指标的详细信息。例如，以下图显示了Sonar中的源代码相关指标。它提供了代码复杂性、代码行数、方法、文档等详细信息：
- en: '![Code analysis reports](img/00018.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![代码分析报告](img/00018.jpeg)'
- en: Figure 7.4
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more on Sonar at [http://docs.sonarqube.org/display/SONAR/Documentation/](http://docs.sonarqube.org/display/SONAR/Documentation/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://docs.sonarqube.org/display/SONAR/Documentation/](http://docs.sonarqube.org/display/SONAR/Documentation/)找到更多关于Sonar的信息。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the testing and reporting aspects of Gradle. We
    started our discussion with TestNG and also discussed how we can configure Gradle
    to support the integration test cases separate from unit test cases. Then, we
    discussed code coverage with JaCoCo and, finally, we talked about Sonar integration
    with Gradle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Gradle的测试和报告方面。我们的讨论从TestNG开始，并讨论了如何配置Gradle以支持集成测试用例与单元测试用例分离。然后，我们讨论了JaCoCo的代码覆盖率，最后我们讨论了Gradle与Sonar的集成。
- en: In the next chapter, we will discuss how to organize the build logic in build
    scripts and plugins. We'll explore how to modularize plugin code so that it can
    be shared across multi-project Gradle build. We'll also explore how to create
    a custom plugin in Gradle.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何在构建脚本和插件中组织构建逻辑。我们将探讨如何模块化插件代码，以便在多项目Gradle构建中共享。我们还将探讨如何在Gradle中创建自定义插件。
