- en: Chapter 2. Concurrency on the JVM and the Java Memory Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章：JVM 和 Java 内存模型上的并发
- en: '|   | *"All non-trivial abstractions, to some degree, are leaky."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|    | *"所有非平凡的抽象，在某种程度上，都是泄漏的。"|    |'
- en: '|   | --*Jeff Atwood* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|    | --*Jeff Atwood* |'
- en: Since its inception, Scala has run primarily on top of JVM, and this fact has
    driven the design of many of its concurrency libraries. The memory model in Scala,
    its multithreading capabilities, and its inter-thread synchronization are all
    inherited from the JVM. Most, if not all, higher-level Scala concurrency constructs
    are implemented in terms of the low-level primitives presented in this chapter.
    These primitives are the basic way to deal with concurrency-in a way, the APIs
    and synchronization primitives in this chapter constitute the assembly of concurrent
    programming on the JVM.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自从诞生以来，Scala 主要在 JVM 上运行，这一事实推动了其许多并发库的设计。Scala 的内存模型、其多线程能力以及其线程间同步都继承自 JVM。大多数，如果不是所有，高级
    Scala 并发结构都是通过本章中介绍的低级原语来实现的。这些原语是处理并发的最基本方式——从某种意义上说，本章中介绍的 API 和同步原语构成了在 JVM
    上进行并发编程的汇编。
- en: In most cases, you should avoid low-level concurrency in place of higher-level
    constructs introduced later, but we felt it was important for you to understand
    what a thread is, that a guarded block is better than busy-waiting, or why a memory
    model is useful. We are convinced that this is essential for a better understanding
    of high-level concurrency abstractions. Despite the popular notion that an abstraction
    that requires knowledge about its implementation is broken, understanding the
    basics often proves very handy- in practice, all abstractions are to some extent
    leaky.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你应该避免使用后面介绍的高级结构中的低级并发，但我们认为了解线程是什么、保护块比忙等待更好，或者为什么内存模型有用是很重要的。我们相信，这对于更好地理解高级并发抽象是至关重要的。尽管普遍认为需要了解其实施知识的抽象是破绽百出的，但了解基础知识通常非常有用——在实践中，所有抽象在某种程度上都是泄漏的。
- en: 'In what follows, we not only explain the cornerstones of concurrency on JVM,
    but also discuss how they interact with some Scala-specific features. In particular,
    we will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们不仅将解释 JVM 并发的基础知识，还将讨论它们如何与一些 Scala 特定功能交互。特别是，在本章中我们将涵盖以下主题：
- en: Creating and starting threads and waiting for their completion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和启动线程以及等待它们的完成
- en: Communication between threads using object monitors and the `synchronized` statement
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象监视器和 `synchronized` 语句在线程之间进行通信
- en: How to avoid busy-waiting using guarded blocks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用保护块避免忙等待
- en: The semantics of volatile variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易变变量的语义
- en: The specifics of the **Java Memory Model** (**JMM**), and why the JMM is important
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 内存模型**（**JMM**）的具体细节以及为什么 JMM 很重要'
- en: In the following section, we will study how to use threads--the basic way to
    express concurrent computations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究如何使用线程——表达并发计算的基本方式。
- en: Processes and threads
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和线程
- en: In modern, pre-emptive, multitasking operating systems, the programmer has little
    or no control over the choice of processor on which the program will be executed.
    In fact, the same program might run on many different processors during its execution
    and sometimes even simultaneously on several processors. It is usually the task
    of the **Operating System** (**OS**) to assign executable parts of the program
    to specific processors--this mechanism is called **multitasking**, and it happens
    transparently for the computer user.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代的抢占式多任务操作系统中，程序员对程序将在哪个处理器上执行的选择几乎没有或没有控制权。实际上，同一个程序在执行过程中可能会运行在许多不同的处理器上，有时甚至在几个处理器上同时运行。通常，将程序的可执行部分分配给特定处理器的任务由**操作系统**（**OS**）来完成——这种机制称为**多任务处理**，对于计算机用户来说，这个过程是透明的。
- en: Historically, multitasking was introduced to operating systems to improve the
    user experience by allowing multiple users or programs to use resources of the
    same computer simultaneously. In cooperative multitasking, programs were able
    to decide when to stop using the processor and yield control to other programs.
    However, this required a lot of discipline on the programmer's part and programs
    could easily give the impression of being unresponsive. For example, a download
    manager that starts downloading a file must take care in order to yield control
    to other programs. Blocking the execution until a download finishes will completely
    ruin the user experience. Most operating systems today rely on pre-emptive multitasking,
    in which each program is repetitively assigned slices of execution time at a specific
    processor. These slices are called **time slices**. Thus, multitasking happens
    transparently for the application programmer as well as the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，多任务处理被引入操作系统是为了通过允许多个用户或程序同时使用同一台计算机的资源来改善用户体验。在协作多任务处理中，程序能够决定何时停止使用处理器并将控制权交给其他程序。然而，这需要程序员有很大的自律，程序很容易给人留下无响应的印象。例如，一个开始下载文件的下载管理器必须小心处理，以便将控制权交给其他程序。阻塞执行直到下载完成将完全破坏用户体验。大多数操作系统今天都依赖于抢占式多任务处理，其中每个程序在特定处理器上重复分配执行时间片。这些时间片被称为**时间片**。因此，多任务处理对应用程序程序员和用户来说都是透明的。
- en: 'The same computer program can be started more than once, or even simultaneously
    within the same OS. A **process** is an instance of a computer program that is
    being executed. When a process starts, the OS reserves a part of the memory and
    other computational resources and associates them with a specific computer program.
    The OS then associates the processor with the process, and the process executes
    during one-time slice. Eventually, the OS gives other processes control over the
    processor. Importantly, the memory and other computational resources of one process
    are isolated from the other processes: two processes cannot read each other''s
    memory directly or simultaneously use most of the resources.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个计算机程序可以启动多次，甚至在同一操作系统内同时启动。**进程**是正在执行的计算机程序的一个实例。当一个进程启动时，操作系统会为其预留一部分内存和其他计算资源，并将它们与特定的计算机程序关联起来。然后操作系统将处理器与进程关联，进程在一段时间内执行。最终，操作系统将处理器的控制权交给其他进程。重要的是，一个进程的内存和其他计算资源与其他进程是隔离的：两个进程不能直接或同时读取彼此的内存或使用大部分资源。
- en: Most programs are comprised of a single process, but some programs run in multiple
    processes. In this case, different tasks within the program are expressed as separate
    processes. Since separate processes cannot access the same memory areas directly,
    it can be cumbersome to express multitasking using multiple processes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序由单个进程组成，但有些程序在多个进程中运行。在这种情况下，程序中的不同任务被表示为不同的进程。由于不同的进程不能直接访问相同的内存区域，使用多个进程来表示多任务处理可能会很麻烦。
- en: Multitasking was important long before recent years when multicore computers
    became mainstream. Large programs such as web browsers are divided into many logical
    modules. A browser's download manager downloads files independent of rendering
    the web page or updating the HTML **Document Object Model** (**DOM**). While the
    user is browsing a social networking website, the file download proceeds in the
    background; but both independent computations occur as part of the same process.
    These independent computations occurring in the same process are called **threads**.
    In a typical operating system, there are many more threads than processors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在多核计算机成为主流之前，多任务处理就已经很重要了。像网页浏览器这样的大型程序被划分为许多逻辑模块。浏览器的下载管理器在渲染网页或更新HTML **文档对象模型**（**DOM**）时独立下载文件。当用户浏览社交网站时，文件下载在后台进行；但这两个独立的计算作为同一进程的一部分发生。在同一个进程中发生的这些独立计算被称为**线程**。在典型的操作系统中，线程的数量比处理器多得多。
- en: Every thread describes the current state of the program **stack** and the program
    **counter** during program execution. The program stack contains a sequence of
    method invocations that are currently being executed, along with the local variables
    and method parameters of each method. The program counter describes the position
    of the current instruction in the current method. A processor can advance the
    computation in some thread by manipulating the state of its stack or the state
    of the program objects and executing the instruction at the current program counter.
    When we say that a thread performs an action such as writing to a memory location,
    we mean that the processor executing that thread performs that action. In pre-emptive
    multitasking, thread execution is scheduled by the operating system. A programmer
    must assume that the processor time assigned to their thread is unbiased towards
    other threads in the system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程描述了程序执行期间的当前程序**栈**和程序**计数器**的状态。程序栈包含当前正在执行的方法调用的序列，以及每个方法的局部变量和方法参数。程序计数器描述了当前方法中当前指令的位置。处理器可以通过操作其栈的状态或程序对象的状态，并执行当前程序计数器处的指令来在某些线程中推进计算。当我们说一个线程执行诸如写入内存位置之类的操作时，我们是指执行该线程的处理器执行该操作。在抢占式多任务处理中，线程执行由操作系统调度。程序员必须假设分配给他们的处理器时间对系统中的其他线程是公平的。
- en: '**OS threads** are a programming facility provided by the OS, usually exposed
    through an OS-specific programming interface. Unlike separate processes, separate
    OS threads within the same process share a region of memory, and communicate by
    writing to and reading parts of that memory. Another way to define a process is
    to define it as a set of OS threads along with the memory and resources shared
    by these threads.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作系统线程**是操作系统提供的编程设施，通常通过特定的操作系统编程接口公开。与单独的进程不同，同一进程内的单独操作系统线程共享一个内存区域，并通过写入和读取该内存的部分来通信。另一种定义进程的方法是将其定义为包含这些线程共享的内存和资源的操作系统线程集合。'
- en: 'Based on the preceding discussion about the relationships between processes
    and threads, a summary of a typical OS is depicted in the following simplified
    diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据关于进程和线程之间关系的先前讨论，以下是一个典型的操作系统的简化示意图：
- en: '![Processes and threads](img/image_02_001.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![进程和线程](img/image_02_001.jpg)'
- en: The preceding diagram shows an OS in which multiple processes are executing
    simultaneously. Only the first three processes are shown in the illustration.
    Each process is assigned a fixed region of computer memory. In practice, the memory
    system of the OS is much more complex, but this approximation serves as a simple
    mental model.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图显示了同时执行多个进程的操作系统。图中只显示了前三个进程。每个进程都被分配了一个固定的计算机内存区域。实际上，操作系统的内存系统要复杂得多，但这种近似提供了一个简单的心理模型。
- en: Each of the processes contains multiple OS threads, two of which are shown for
    each process. Currently, **Thread 1** of **Process 2** is executing on **CPU Core
    1**, and **Thread 2** of **Process 3** is executing on **CPU Core 2**. The OS
    periodically assigns different OS threads to each of the CPU cores to allow the
    computation to progress in all the processes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程包含多个操作系统线程，每个进程中展示了其中两个。目前，**进程2的线程1**正在**CPU核心1**上执行，而**进程3的线程2**正在**CPU核心2**上执行。操作系统定期将不同的操作系统线程分配给每个CPU核心，以允许所有进程的计算进度。
- en: Having shown the relationship between the OS threads and processes, we turn
    our attention to see how these concepts relate to the **Java Virtual Machine**
    (**JVM**), the runtime on top of which Scala programs execute.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示了操作系统线程和进程之间的关系后，我们将注意力转向了解这些概念如何与**Java虚拟机**（**JVM**）相关联，Scala程序就是在其上运行的运行时环境。
- en: Starting a new JVM instance always creates only one process. Within the JVM
    process, multiple threads can run simultaneously. The JVM represents its threads
    with the `java.lang.Thread` class. Unlike runtimes for languages such as Python,
    the JVM does not implement its custom threads. Instead, each Java thread is directly
    mapped to an OS thread. This means that Java threads behave in a very similar
    way to the OS threads, and the JVM depends on the OS and its restrictions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新的JVM实例总是只创建一个进程。在JVM进程中，可以同时运行多个线程。JVM使用`java.lang.Thread`类来表示其线程。与Python等语言的运行时不同，JVM没有实现其自定义线程。相反，每个Java线程直接映射到一个操作系统线程。这意味着Java线程的行为与操作系统线程非常相似，JVM依赖于操作系统及其限制。
- en: Scala is a programming language that is by default compiled to the JVM bytecode,
    and the Scala compiler output is largely equivalent to that of Java from the JVM's
    perspective. This allows Scala programs to transparently call Java libraries,
    and in some cases, even vice versa. Scala reuses the threading API from Java for
    several reasons. First, Scala can transparently interact with the existing Java
    thread model, which is already sufficiently comprehensive. Second, it is useful
    to retain the same threading API for compatibility reasons, and there is nothing
    fundamentally new that Scala can introduce with respect to the Java thread API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 是一种默认编译为 JVM 字节码的编程语言，从 JVM 的角度来看，Scala 编译器的输出在很大程度上与 Java 相当。这允许 Scala
    程序透明地调用 Java 库，在某些情况下甚至相反。Scala 重新使用 Java 的线程 API 有几个原因。首先，Scala 可以透明地与现有的 Java
    线程模型交互，该模型已经足够全面。其次，为了兼容性原因，保留相同的线程 API 是有用的，并且 Scala 在 Java 线程 API 方面没有引入任何根本性的新内容。
- en: The rest of this chapter shows how to create JVM threads using Scala, how they
    can be executed, and how they can communicate. We will show and discuss several
    concrete examples. Java aficionados, already well-versed in this subject, might
    choose to skip the rest of this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将展示如何使用 Scala 创建 JVM 线程，如何执行它们，以及它们如何进行通信。我们将展示和讨论几个具体的例子。已经对这一主题非常熟悉的
    Java 爱好者可能会选择跳过本章的其余部分。
- en: Creating and starting threads
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和启动线程
- en: 'Every time a new JVM process starts, it creates several threads by default.
    The most important thread among them is the **main thread**, which executes the
    `main` method of the Scala program. We will show this in the following program,
    which gets the name of the current thread and prints it to the standard output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每次新的 JVM 进程启动时，它都会默认创建几个线程。其中最重要的线程是 **主线程**，它执行 Scala 程序的 `main` 方法。我们将在以下程序中展示这一点，该程序获取当前线程的名称并将其打印到标准输出：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On the JVM, thread objects are represented with the `Thread` class. The preceding
    program uses the static `currentThread` method to obtain a reference to the current
    thread object, and stores it to a local variable named `t`. It then calls the
    `getName` method to obtain the thread''s name. If you are running this program
    from **Simple Build Tool** (SBT) with the `run` command, as explained in [Chapter
    1](ch01.html "Chapter 1. Introduction"), *Introduction*, you should see the following
    output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 上，线程对象通过 `Thread` 类来表示。前面的程序使用静态的 `currentThread` 方法来获取当前线程对象的引用，并将其存储到名为
    `t` 的局部变量中。然后它调用 `getName` 方法来获取线程的名称。如果你使用 **Simple Build Tool** (SBT) 中的 `run`
    命令运行此程序，如 [第 1 章](ch01.html "第 1 章。简介") 中所述，你应该看到以下输出：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Normally, the name of the main thread is just the `main` method. The reason
    we see a different name is because SBT started our program on a separate thread
    inside the SBT process. To ensure that the program runs inside a separate JVM
    process, we need to set SBT''s `fork` setting to `true`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，主线程的名称只是 `main` 方法。我们看到不同的名称是因为 SBT 在 SBT 进程内部启动了我们的程序的一个单独的线程。为了确保程序在单独的
    JVM 进程中运行，我们需要将 SBT 的 `fork` 设置设置为 `true`：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Invoking the SBT `run` command again should give the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用 SBT 的 `run` 命令应该给出以下输出：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every thread goes through several **thread states** during its existence. When
    a `Thread` object is created, it is initially in the **new** state. After the
    newly created thread object starts executing, it goes into the **runnable** state.
    After the thread is done executing, the thread object goes into the **terminated
    state**, and cannot execute anymore.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程在其存在期间都会经历几个 **线程状态**。当创建 `Thread` 对象时，它最初处于 **新建** 状态。新创建的线程对象开始执行后，进入
    **可运行** 状态。线程执行完毕后，线程对象进入 **终止状态**，不能再执行。
- en: 'Starting an independent thread of computation consists of two steps. First,
    we need to create a `Thread` object to allocate the memory for the stack and thread
    state. To start the computation, we need to call the `start` method on this object.
    We show how to do this in the following example application called `ThreadsCreation`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个独立的计算线程包括两个步骤。首先，我们需要创建一个 `Thread` 对象来分配堆栈和线程状态所需的内存。为了开始计算，我们需要调用此对象上的
    `start` 方法。我们将在以下示例应用程序 `ThreadsCreation` 中展示如何做到这一点：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When a JVM application starts, it creates a special thread called the **main
    thread** that executes the method called `main` in the specified class, in this
    case, the `ThreadsCreation` object. When the `App` class is extended, the `main`
    method is automatically synthesized from the object body. In this example, the
    main thread first creates another thread of the `MyThread` type and assigns it
    to `t`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 JVM 应用程序启动时，它会创建一个特殊的线程，称为 **主线程**，该线程在指定的类中执行名为 `main` 的方法，在本例中是 `ThreadsCreation`
    对象。当扩展 `App` 类时，`main` 方法会自动从对象体中生成。在这个例子中，主线程首先创建了一个 `MyThread` 类型的线程，并将其赋值给
    `t`。
- en: Next, the main thread starts `t` by calling the `start` method. Calling the
    `start` method eventually results in executing the `run` method from the new thread.
    First, the OS is notified that `t` must start executing. When the OS decides to
    assign the new thread to some processor, this is largely out of the programmer's
    control, but the OS must ensure that this eventually happens. After the main thread
    starts the new thread `t`, it calls its `join` method. This method halts the execution
    of the main thread until `t` completes its execution. We say that the `join` operation
    puts the main thread into the **waiting state** until `t` terminates. Importantly,
    the waiting thread relinquishes its control over the processor, and the OS can
    assign that processor to some other thread.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，主线程通过调用 `start` 方法启动 `t`。调用 `start` 方法最终会导致新线程执行 `run` 方法。首先，操作系统被通知 `t`
    必须开始执行。当操作系统决定将新线程分配给某个处理器时，这很大程度上超出了程序员的控制，但操作系统必须确保这最终发生。在主线程启动新线程 `t` 之后，它调用其
    `join` 方法。此方法使主线程的执行暂停，直到 `t` 完成执行。我们说 `join` 操作将主线程置于 **等待状态**，直到 `t` 终止。重要的是，等待的线程放弃对处理器的控制，操作系统可以将该处理器分配给其他线程。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Waiting threads notify the OS that they are waiting for some condition and cease
    spending CPU cycles, instead of repetitively checking that condition.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 等待的线程通知操作系统它们正在等待某个条件，并停止消耗 CPU 循环，而不是反复检查该条件。
- en: 'In the meantime, the OS finds an available processor and instructs it to run
    the child thread. The instructions that a thread must execute are specified by
    overriding its `run` method. The `t` instance of the `MyThread` class starts by
    printing the "`New thread running."` text to the standard output and then terminates.
    At this point, the operating system is notified that `t` is terminated and eventually
    lets the main thread continue the execution. The OS then puts the main thread
    back into the running state, and the main thread prints `"New thread joined."`.
    This is shown in the following diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，操作系统找到一个可用的处理器，并指示它运行子线程。线程必须执行的指令是通过覆盖其 `run` 方法来指定的。`MyThread` 类的 `t` 实例首先将
    `"New thread running."` 文本打印到标准输出，然后终止。此时，操作系统被通知 `t` 已终止，最终允许主线程继续执行。然后操作系统将主线程放回运行状态，主线程打印
    `"New thread joined."`。这在上面的图中显示：
- en: '![Creating and starting threads](img/image_02_002.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![创建和启动线程](img/image_02_002.jpg)'
- en: It is important to note that the two outputs `"New thread running."` and `"New
    thread joined."` are always printed in this order. This is because the `join`
    call ensures that the termination of the `t` thread occurs before the instructions
    following the `join` call.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，两个输出 `"New thread running."` 和 `"New thread joined."` 总是按照这个顺序打印。这是因为
    `join` 调用确保了 `t` 线程的终止发生在 `join` 调用之后的指令执行之前。
- en: 'When running the program, it is executed so fast that the two `println` statements
    occur almost simultaneously. Could it be that the ordering of the `println` statements
    is just an artifact in how the OS chooses to execute these threads? To verify
    the hypothesis that the main thread really waits for `t` and that the output is
    not just because the OS is biased to execute `t` first in this particular example,
    we can experiment by tweaking the execution schedule. Before we do that, we will
    introduce a shorthand to create and start a new thread; the current syntax is
    too verbose! The new `thread` method simply runs a block of code in a newly started
    thread. This time, we will create the new thread using an anonymous thread class
    declared inline at the instantiation site:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行程序时，执行速度非常快，以至于两个`println`语句几乎同时发生。这能是`println`语句的顺序只是操作系统选择执行这些线程的方式的一个偶然现象吗？为了验证主线程确实在等待`t`，并且输出不是仅仅因为操作系统在这个特定例子中倾向于首先执行`t`，我们可以通过调整执行计划进行实验。在我们这样做之前，我们将引入一个简写来创建和启动一个新的线程；当前的语法太冗长了！新的`thread`方法简单地在一个新启动的线程中运行一个代码块。这次，我们将使用在实例化位置声明的匿名线程类来创建新的线程：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `thread` method takes a block of code body, creates a new thread that executes
    this block of code in its `run` method, starts the thread, and returns a reference
    to the new thread so that the clients can call `join` on it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread`方法接受一个代码块体，创建一个新的线程，在该线程的`run`方法中执行此代码块，启动线程，并返回对新线程的引用，以便客户端可以调用`join`。'
- en: Creating and starting threads using the `thread` statement is much less verbose.
    To make the examples in this chapter more concise, we will use the `thread` statement
    from now on. However, you should think twice before using the `thread` statement
    in production projects. It is prudent to correlate the syntactic burden with the
    computational cost; lightweight syntax can be mistaken for a cheap operation and
    creating a new thread is relatively expensive.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`thread`语句创建和启动线程比使用更简洁。为了使本章的示例更简洁，我们将从现在开始使用`thread`语句。然而，在使用`thread`语句之前，你应该三思而后行。谨慎地将语法负担与计算成本相关联；轻量级语法可能会被误认为是廉价操作，而创建一个新线程相对较贵。
- en: 'We can now experiment with the OS by making sure that all the processors are
    available. To do this, we will use the static `sleep` method on the `Thread` class,
    which postpones the execution of the thread that is being currently executed for
    the specified number of milliseconds. This method puts the thread into the **timed
    waiting** state. The OS can reuse the processor for other threads when `sleep`
    is called. Still, we will require a sleep time much larger than the time slice
    on a typical OS, which ranges from 10 to 100 milliseconds. The following code
    depicts this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过确保所有处理器都可用来与操作系统进行实验。为此，我们将使用`Thread`类的静态`sleep`方法，该方法将当前正在执行的线程的执行推迟指定的毫秒数。此方法将线程置于**定时等待**状态。当调用`sleep`时，操作系统可以重新使用处理器为其他线程服务。尽管如此，我们仍然需要一个比典型操作系统上的时间片大得多的睡眠时间，时间片通常在10到100毫秒之间。以下代码展示了这一点：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The main thread of the `ThreadSleep` application creates and starts a new `t`
    thread that sleeps for one second, then outputs some text, and repeats this two
    or more times before terminating. The main thread calls `join` as before and then
    prints `"New thread joined."`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadSleep`应用程序的主线程创建并启动一个新的`t`线程，该线程睡眠一秒钟，然后输出一些文本，然后重复两次或更多次，最后终止。主线程像以前一样调用`join`，然后打印`"New
    thread joined."`。'
- en: Note that we are now using the `log` method described in [Chapter 1](ch01.html
    "Chapter 1. Introduction"), *Introduction*. The `log` method prints the specified
    string value along with the name of the thread that calls the `log` method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在正在使用[第1章](ch01.html "第1章。介绍")中描述的`log`方法，*介绍*。`log`方法打印指定的字符串值以及调用`log`方法的线程的名称。
- en: 'Regardless of how many times you run the preceding application, the last output
    will always be `"New thread joined."`. This program is **deterministic**: given
    a particular input, it will always produce the same output, regardless of the
    execution schedule chosen by the OS.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你运行前面应用程序多少次，最后的输出总是`"New thread joined."`。这个程序是**确定性的**：给定特定的输入，它将始终产生相同的输出，无论操作系统选择的执行计划如何。
- en: 'However, not all the applications using threads will always yield the same
    output if given the same input. The following code is an example of a **nondeterministic**
    application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不是所有使用线程的应用程序在给定相同输入的情况下都会始终产生相同的输出。以下代码是一个**非确定性**应用的例子：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is no guarantee that the `log("...")` statements in the main thread occur
    before or after the `log` call in the `t` thread. Running the application several
    times on a multicore processor prints `"..."` before, after, or interleaved with
    the output by the `t` thread. By running the program, we get the following output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 没有保证主线程中的`log("...")`语句会在`t`线程中的`log`调用之前或之后发生。在多核处理器上多次运行应用程序会在`t`线程的输出之前、之后或与之交织地打印`"..."`。通过运行程序，我们得到以下输出：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the program again results in a different order between these outputs:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序会导致这些输出之间的顺序不同：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Most multithreaded programs are nondeterministic, and this is what makes multithreaded
    programming so hard. There are multiple possible reasons for this. First, the
    program might be too big for the programmer to reason about its determinism properties,
    and interactions between threads could simply be too complex. But some programs
    are inherently non-deterministic. A web server has no idea which client will be
    the first to send a request for a web page. It must allow these requests to arrive
    in any possible order and respond to them as soon as they arrive. Depending on
    the order in which the clients prepare inputs for the web server, they can behave
    differently even though the requests might be the same.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数多线程程序都是非确定性的，这也是多线程编程如此困难的原因。这有多种可能的原因。首先，程序可能太大，程序员无法推理其确定性属性，线程之间的交互可能过于复杂。但有些程序本质上是非确定性的。一个网络服务器不知道哪个客户端将是第一个发送网页请求的。它必须允许这些请求以任何可能的顺序到达，并尽快对它们做出响应。根据客户端为网络服务器准备输入的顺序，即使请求相同，它们的行为也可能不同。
- en: Atomic execution
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子执行
- en: 'We have already seen one basic way in which threads can communicate: by waiting
    for each other to terminate. The information that the joined thread delivers is
    that it has terminated. In practice, however, this information is not necessarily
    useful; for example, a thread that renders one page in a web browser must inform
    the other threads that a specific URL has been visited, so as to render such a
    visited URL in a different color.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到线程可以通信的一种基本方式：通过等待彼此终止。被连接的线程提供的信息是它已经终止。然而，在实践中，这个信息并不一定有用；例如，渲染网页浏览器中一个页面的线程必须通知其他线程已访问特定的URL，以便以不同的颜色渲染已访问的URL。
- en: 'It turns out that the `join` method on threads has an additional property.
    All the writes to memory performed by the thread being joined occur before the
    `join` call returns and are visible to threads that call the `join` method. This
    is illustrated by the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，线程上的`join`方法有一个额外的属性。被连接的线程执行的内存写入操作发生在`join`调用返回之前，并且对调用`join`方法的线程是可见的。以下示例说明了这一点：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main thread will never print `null`, as the call to `join` always occurs
    before the `log` call, and the assignment to `result` occurs before the termination
    of `t`. This pattern is a very basic way in which the threads can use their results
    to communicate with each other.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程永远不会打印`null`，因为`join`调用总是在`log`调用之前发生，并且`result`的赋值发生在`t`终止之前。这种模式是线程可以使用它们的结果以非常基本的方式相互通信的一种方式。
- en: 'However, this pattern only allows very restricted one-way communication, and
    it does not allow threads to mutually communicate during their execution. There
    are many use cases for an unrestricted two-way communication. One example is assigning
    unique identifiers, in which a set of threads concurrently choose numbers such
    that no two threads produce the same number. We might be tempted to proceed as
    in the following incorrect example. We start by showing the first half of the
    program:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模式只允许非常受限的单向通信，并且不允许线程在执行期间相互通信。有许多无限制双向通信的使用场景。一个例子是分配唯一标识符，其中一组线程并发选择数字，使得没有两个线程产生相同的数字。我们可能会倾向于按照以下不正确的示例进行操作。我们首先展示程序的前半部分：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code snippet, we first declare a `uidCount` variable that
    will hold the last unique identifier picked by any thread. The threads will call
    the `getUniqueId` method to compute the first unused identifier and then update
    the `uidCount` variable. In this example, reading `uidCount` to initialize `freshUid`
    and assigning `freshUid` back to `uniqueUid` do not necessarily happen together.
    We say that the two statements do not happen **atomically** since the statements
    from the other threads can interleave arbitrarily. We next define a `printUniqueIds`
    method such that, given a number `n`, the method calls `getUniqueId` to produce
    `n` unique identifiers and then prints them. We use Scala for-comprehensions to
    map the range `0 until n` to unique identifiers. Finally, the main thread starts
    a new `t` thread that calls the `printUniqueIds` method, and then calls `printUniqueIds`
    concurrently with the `t` thread as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先声明一个`uidCount`变量，该变量将保存任何线程选择的最后一个唯一标识符。线程将调用`getUniqueId`方法来计算第一个未使用的标识符，然后更新`uidCount`变量。在这个例子中，读取`uidCount`以初始化`freshUid`和将`freshUid`赋值回`uniqueUid`并不一定同时发生。我们说这两个语句不是原子地发生的，因为其他线程的语句可以任意交错。接下来，我们定义一个`printUniqueIds`方法，该方法接受一个数字`n`，该方法调用`getUniqueId`来生成`n`个唯一标识符，然后打印它们。我们使用Scala的for-comprehensions将范围`0
    until n`映射到唯一标识符。最后，主线程启动一个新的`t`线程，该线程调用`printUniqueIds`方法，然后与`t`线程并发调用`printUniqueIds`如下：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running this application several times reveals that the identifiers generated
    by the two threads are not necessarily unique; the application prints `Vector(1,
    2, 3, 4, 5)` and `Vector(1, 6, 7, 8, 9)` in some runs, but not in the others!
    The outputs of the program depend on the timing at which the statements in separate
    threads get executed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序几次会揭示，两个线程生成的标识符不一定唯一；在某些运行中，应用程序打印`Vector(1, 2, 3, 4, 5)`和`Vector(1,
    6, 7, 8, 9)`，但在其他运行中则不会！程序的输出取决于不同线程中语句执行的时机。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **race condition** is a phenomenon in which the output of a concurrent program
    depends on the execution schedule of the statements in the program.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**竞态条件**是一种现象，其中并发程序的结果取决于程序中语句的执行顺序。'
- en: 'A race condition is not necessarily an incorrect program behavior. However,
    if some execution schedule causes an undesired program output, the race condition
    is considered to be a program error. The race condition from the previous example
    is a program error, because the `getUniqueId` method is not atomic. The `t` thread
    and the main thread sometimes concurrently calls `getUniqueId`. In the first line,
    they concurrently read the value of `uidCount`, which is initially `0`, and conclude
    that their own `freshUid` variable should be `1`. The `freshUid` variable is a
    local variable, so it is allocated on the thread stack; each thread sees a separate
    instance of that variable. At this point, the threads decide to write the value
    `1` back to `uidCount` in any order, and both return a non-unique identifier `1`.
    This is illustrated in the following figure:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件不一定是程序的不正确行为。然而，如果某些执行顺序导致程序输出不期望的结果，则认为竞态条件是程序错误。前一个示例中的竞态条件是程序错误，因为`getUniqueId`方法不是原子的。`t`线程和主线程有时会并发调用`getUniqueId`。在第一行，它们并发读取`uidCount`的值，该值最初为`0`，并得出结论，它们的`freshUid`变量应该是`1`。`freshUid`变量是一个局部变量，因此它是在线程栈上分配的；每个线程都看到该变量的一个单独实例。此时，线程决定以任何顺序将值`1`写回`uidCount`，并且两者都返回一个非唯一标识符`1`。这在下图中得到说明：
- en: '![Atomic execution](img/image_02_003.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![原子执行](img/image_02_003.jpg)'
- en: 'There is a mismatch between the mental model that most programmers inherit
    from sequential programming and the execution of the `getUniqueId` method when
    it is run concurrently. This mismatch is grounded in the assumption that `getUniqueId`
    executes atomically. Atomic execution of a block of code means that the individual
    statements in that block of code executed by one thread cannot interleave with
    those statements executed by another thread. In atomic execution, the statements
    can only be executed all at once, which is exactly how the `uidCount` field should
    be updated. The code inside the `getUniqueId` function reads, modifies, and writes
    a value, which is not atomic on the JVM. An additional language construct is necessary
    to guarantee atomicity. The fundamental Scala construct that allows this sort
    of atomic execution is called the `synchronized` statement, and it can be called
    on any object. This allows us to define `getUniqueId` as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员从顺序编程中继承的心理模型与`getUniqueId`方法在并发执行时的执行之间存在不匹配。这种不匹配源于对`getUniqueId`原子执行的假设。代码块的原子执行意味着在该块中由一个线程执行的各个语句不能与另一个线程执行的语句交织。在原子执行中，语句只能一次性执行，这正是`uidCount`字段应该更新的方式。`getUniqueId`函数内部的代码读取、修改和写入一个值，这在JVM上不是原子的。需要额外的语言结构来保证原子性。允许这种类型原子执行的Scala基本结构称为`synchronized`语句，并且可以在任何对象上调用。这允许我们将`getUniqueId`定义为以下内容：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `synchronized` call ensures that the subsequent block of code can only execute
    if there is no other thread simultaneously executing this synchronized block of
    code, or any other synchronized block of code called on the same `this` object.
    In our case, the `this` object is the enclosing singleton object, `ThreadsUnprotectedUid`,
    but in general, this can be an instance of the enclosing class or trait.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`调用确保后续的代码块只有在没有其他线程同时执行此`synchronized`代码块或任何其他在相同`this`对象上调用的`synchronized`代码块时才能执行。在我们的例子中，`this`对象是封装的单例对象`ThreadsUnprotectedUid`，但在一般情况下，这可以是封装类的实例或特质。'
- en: 'Two concurrent invocations of the `getUniqueId` method are shown in the following
    figure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了`getUniqueId`方法的两次并发调用：
- en: '![Atomic execution](img/image_02_004.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![原子执行](img/image_02_004.jpg)'
- en: We can also call `synchronized` and omit the `this` part, in which case the
    compiler will infer what the surrounding object is, but we strongly discourage
    you from doing so. Synchronizing on incorrect objects results in concurrency errors
    that are not easily identified.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以调用`synchronized`并省略`this`部分，在这种情况下，编译器将推断出周围的对象是什么，但我们强烈建议您不要这样做。在错误的对象上同步会导致不易识别的并发错误。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always explicitly declare the receiver for the `synchronized` statement doing
    so protects you from subtle and hard to spot program errors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 总是明确声明`synchronized`语句的接收者，这样做可以保护您免受微妙且难以发现的程序错误的侵害。
- en: The JVM ensures that the thread executing a `synchronized` statement invoked
    on some `x` object is the only thread executing any `synchronized` statement on
    that particular `x` object. If a `T` thread calls `synchronized` on `x`, and there
    is another `S` thread calling `synchronized` on `x`, then the `T` thread is put
    into the **blocked** state. Once the `S` thread completes its `synchronized` statement,
    the JVM can choose the `T` thread to execute its own `synchronized` statement.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: JVM确保在某个`x`对象上调用`synchronized`语句的线程是唯一执行该特定`x`对象上任何`synchronized`语句的线程。如果一个`T`线程在`x`上调用`synchronized`，而另一个`S`线程也在`x`上调用`synchronized`，那么`T`线程将被置于**阻塞**状态。一旦`S`线程完成其`synchronized`语句，JVM可以选择`T`线程来执行其自己的`synchronized`语句。
- en: Every object created inside the JVM has a special entity called an **intrinsic
    lock** or a **monitor**, which is used to ensure that only one thread is executing
    some `synchronized` block on that object. When a thread starts executing the `synchronized`
    block, we say that the thread **gains ownership** of the `x` monitor, or alternatively,
    **acquires** it. When a thread completes the `synchronized` block, we say that
    it **releases** the monitor.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM内部创建的每个对象都有一个特殊的实体，称为**内在锁**或**监视器**，它用于确保只有一个线程在执行该对象上的某些`synchronized`块。当一个线程开始执行`synchronized`块时，我们说该线程**获得**了`x`监视器的所有权，或者换句话说，**获取**了它。当一个线程完成`synchronized`块时，我们说它**释放**了监视器。
- en: The `synchronized` statement is one of the fundamental mechanisms for inter-thread
    communication in Scala and on the JVM. Whenever there is a possibility that multiple
    threads access and modify a field in some object, you should use the `synchronized`
    statement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`语句是Scala和JVM中线程间通信的基本机制之一。每当存在多个线程可能访问和修改某个对象中的字段时，你应该使用`synchronized`语句。'
- en: Reordering
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重排序
- en: 'The `synchronized` statement is not without a price: writes to fields such
    as `uidCount`, which are protected by the `synchronized` statement are usually
    more expensive than regular unprotected writes. The performance penalty of the
    `synchronized` statement depends on the JVM implementation, but it is usually
    not large. You might be tempted to avoid using `synchronized` when you think that
    there is no bad interleaving of program statements, like the one we saw previously
    in the unique identifier example. Never do this! We will now show you a minimal
    example in which this leads to serious errors.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`语句并非没有代价：受`synchronized`语句保护的字段，如`uidCount`的写入通常比常规的无保护写入更昂贵。`synchronized`语句的性能惩罚取决于JVM实现，但通常并不大。当你认为程序语句没有不良交织时，可能会倾向于避免使用`synchronized`，就像我们在之前的唯一标识符示例中看到的那样。永远不要这样做！现在我们将向你展示一个最小示例，说明这会导致严重错误。'
- en: 'Let''s consider the following program, in which two threads, `t1` and `t2`,
    access a pair of Boolean variables, `a` and `b`, and a pair of Integer variables,
    `x` and `y`. The `t1` thread sets the variable `a` to `true`, and then reads the
    value of `b`. If the value of `b` is `true`, the `t1` thread assigns `0` to `y`,
    and otherwise it assigns `1`. The `t2` thread does the opposite: it first assigns
    `true` to the variable `b`, and then assigns `0` to `x` if `a` is `true`, and
    `1` otherwise. This is repeated in a loop `100000` times, as shown in the following
    snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下程序，其中两个线程`t1`和`t2`访问一对布尔变量`a`和`b`以及一对整数变量`x`和`y`。`t1`线程将变量`a`设置为`true`，然后读取`b`的值。如果`b`的值为`true`，则`t1`线程将`0`赋值给`y`，否则赋值`1`。`t2`线程执行相反的操作：它首先将`true`赋值给变量`b`，然后如果`a`为`true`，则将`0`赋值给`x`，否则赋值`1`。这在一个循环中重复`100000`次，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This program is somewhat subtle, so we need to carefully consider several possible
    execution scenarios. By analyzing the possible interleaving of the instructions
    of the `t1` and `t2` threads, we can conclude that if both threads simultaneously
    assign to `a` and `b`, then they will both assign `0` to `x` and `y`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有些微妙，因此我们需要仔细考虑几个可能的执行场景。通过分析`t1`和`t2`线程指令的可能交织，我们可以得出结论，如果两个线程同时向`a`和`b`赋值，那么它们都会将`0`赋值给`x`和`y`。
- en: 'This outcome indicates that both the threads started at almost the same time,
    and is shown on the left in the following figure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果表明两个线程几乎同时开始，如下面的图中左侧所示：
- en: '![Reordering](img/image_02_005.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![重排序](img/image_02_005.jpg)'
- en: Alternatively, let's assume that the `t2` thread executes faster. In this case,
    the `t2` thread sets the variable `b` to `true`, and proceeds to read the value
    of `a`. This happens before the assignment to `a` by the `t1` thread, so the `t2`
    thread reads the value `false`, and assigns `1` to `x`. When the `t1` thread executes,
    it sees that the value of `b` is `true`, and assigns `0` to `y`. This sequence
    of events is shown on the right in the preceding figure. Note that the case where
    the `t1` thread starts first results in a similar assignment where `x = 0` and
    `y = 1`, so it is not shown in the figure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，让我们假设`t2`线程执行得更快。在这种情况下，`t2`线程将变量`b`设置为`true`，然后读取`a`的值。这发生在`t1`线程进行赋值之前，因此`t2`线程读取到`false`，并将`1`赋值给`x`。当`t1`线程执行时，它看到`b`的值为`true`，并将`0`赋值给`y`。上述事件序列在前面图中的右侧显示。请注意，如果`t1`线程先开始，则会导致类似的赋值，其中`x
    = 0`和`y = 1`，所以它没有在图中显示。
- en: The conclusion is that regardless of how we reorder the execution of the statements
    in the `t1` and `t2` threads, the output of the program should never be such that
    `x = 1` and `y = 1` simultaneously. Thus, the assertion at the end of the loop
    never throws an exception.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，无论我们如何重新排序`t1`和`t2`线程中的语句执行，程序的输出都不应该是`x = 1`和`y = 1`同时发生。因此，循环末尾的断言永远不会抛出异常。
- en: 'However, after running the program several times, we get the following output,
    which indicates that both `x` and `y` can be assigned the value `1` simultaneously:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在运行程序几次之后，我们得到了以下输出，这表明`x`和`y`可以同时被赋予值`1`：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This result is scary and seems to defy common sense. Why can't we reason about
    the execution of the program the way we did? The answer is that by the JMM specification,
    the JVM is allowed to reorder certain program statements executed by one thread
    as long as it does not change the serial semantics of the program for that particular
    thread. This is because some processors do not always execute instructions in
    the program order. Additionally, the threads do not need to write all their updates
    to the main memory immediately, but can temporarily keep them cached in registers
    inside the processor. This maximizes the efficiency of the program and allows
    better compiler optimizations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果令人恐惧，似乎违反了常识。我们为什么不能像以前那样推理程序的执行呢？答案是，根据JMM规范，只要不改变特定线程程序的序列语义，JVM允许重新排序一个线程执行的一定程序语句。这是因为某些处理器并不总是按程序顺序执行指令。此外，线程不需要立即将所有更新写入主内存，而可以暂时将它们缓存处理器内部的寄存器中。这最大化了程序的效率，并允许更好的编译器优化。
- en: How then should we reason about multithreaded programs? The error we made when
    analyzing the example is that we assumed that the writes by one thread are immediately
    visible to all the other threads. We always need to apply proper synchronization
    to ensure that the writes by one thread are visible to another thread.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何推理多线程程序呢？我们在分析示例时犯的错误是假设一个线程的写入对其他所有线程都是立即可见的。我们始终需要应用适当的同步来确保一个线程的写入对另一个线程是可见的。
- en: The `synchronized` statement is one of the fundamental ways to achieve proper
    synchronization. Writes by any thread executing the `synchronized` statement on
    an `x` object are not only atomic but also visible to threads that execute `synchronized`
    on `x`. Enclosing each assignment in the `t1` and `t2` threads in a `synchronized`
    statement makes the program behave as expected.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`语句是实现适当同步的基本方法之一。任何在`x`对象上执行`synchronized`语句的线程的写入不仅具有原子性，而且对在`x`上执行`synchronized`的线程也是可见的。在`t1`和`t2`线程中将每个赋值语句包裹在`synchronized`语句中，可以使程序按预期运行。'
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the `synchronized` statement on some object `x` when accessing (reading
    or modifying) a state shared between multiple threads. This ensures that at most,
    a single thread is at any time executing a `synchronized` statement on `x`. It
    also ensures that all the writes to the memory by the `T` thread are visible to
    all the other threads that subsequently execute `synchronized` on the same object
    `x`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问（读取或修改）多个线程之间共享的状态时，在对象`x`上使用`synchronized`语句。这确保在任何时候，最多只有一个线程在执行`x`上的`synchronized`语句。它还确保`T`线程对内存的所有写入都对随后在相同对象`x`上执行`synchronized`的所有其他线程可见。
- en: In the rest of this chapter and in [Chapter 3](ch03.html "Chapter 3. Traditional
    Building Blocks of Concurrency"), *Traditional Building Blocks of Concurrency*,
    we will see additional synchronization mechanisms, such as volatile and atomic
    variables. In the next section, we will take a look at other use cases of the
    `synchronized` statement and learn about object monitors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分以及[第3章](ch03.html "第3章。并发传统构建块")中，我们将看到额外的同步机制，例如`volatile`和原子变量。在下一节中，我们将探讨`synchronized`语句的其他用例，并了解对象监视器。
- en: Monitors and synchronization
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视器和同步
- en: In this section, we will study inter-thread communication using the `synchronized`
    statement in more detail. As we saw in the previous sections, the `synchronized`
    statement serves both to ensure the visibility of writes performed by different
    threads, and to limit concurrent access to a shared region of memory. Generally
    speaking, a synchronization mechanism that enforces access limits on a shared
    resource is called a **lock**. Locks are also used to ensure that no two threads
    execute the same code simultaneously; that is, they implement **mutual exclusion**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更详细地研究使用`synchronized`语句进行线程间通信。正如我们在前面的章节中看到的，`synchronized`语句既用于确保不同线程执行的写入的可见性，也用于限制对共享内存区域的并发访问。一般来说，对共享资源执行访问限制的同步机制被称为**锁**。锁还用于确保没有两个线程同时执行相同的代码；也就是说，它们实现了**互斥**。
- en: As mentioned previously, each object on the JVM has a special built-in **monitor
    lock**, also called the **intrinsic lock**. When a thread calls the `synchronized`
    statement on an `x` object, it gains ownership of the monitor lock of the `x`
    object, given that no other thread owns the monitor. Otherwise, the thread is
    blocked until the monitor is released. Upon gaining ownership of the monitor,
    the thread can witness the memory writes of all the threads that previously released
    that monitor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JVM上的每个对象都有一个特殊的内置**监视器锁**，也称为**内在锁**。当一个线程在`x`对象上调用`synchronized`语句时，如果没有任何其他线程拥有监视器，它就获得了`x`对象的监视器锁。否则，线程将被阻塞，直到监视器被释放。一旦获得监视器所有权，线程就可以见证之前释放该监视器的所有线程的内存写入。
- en: 'A natural consequence is that `synchronized` statements can be nested. A thread
    can own monitors belonging to several different objects simultaneously. This is
    useful when composing larger systems from simpler components. We do not know which
    sets of monitors independent software components use in advance. Let''s assume
    that we are designing an online banking system in which we want to log money transfers.
    We can maintain the transfers list of all the money transfers in a mutable `ArrayBuffer`
    growable array implementation. The banking application does not manipulate transfers
    directly, but instead appends new messages with a `logTransfer` method that calls
    `synchronized` on `transfers`. The `ArrayBuffer` implementation is a collection
    designed for single-threaded use, so we need to protect it from concurrent writes.
    We will start by defining the `logTransfer` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 自然的结果是`同步`语句可以嵌套。一个线程可以同时拥有属于几个不同对象的监视器。当从简单的组件构建更大的系统时，这很有用。我们事先不知道独立软件组件使用哪些监视器集合。让我们假设我们正在设计一个在线银行系统，我们希望记录货币转账。我们可以在可增长的`ArrayBuffer`数组实现中维护所有货币转账的转账列表。银行应用程序不直接操作转账，而是通过调用`transfers`上的`synchronized`的`logTransfer`方法来追加新消息。`ArrayBuffer`实现是为单线程使用而设计的集合，因此我们需要保护它免受并发写入的影响。我们将首先定义`logTransfer`方法：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Apart from the logging modules of the banking system, the accounts are represented
    with the `Account` class. The `Account` objects hold information about their owner
    and the amount of money with them. To add some money to an account, the system
    uses an `add` method that obtains the monitor of the `Account` object and modifies
    its `money` field. The bank''s business process requires treating large transfers
    specially: if a money transfer is bigger than 10 currency units, we need to log
    it. In the following code, we will define the `Account` class and the `add` method,
    which adds an amount `n` to the `Account` object:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 除了银行系统的日志模块之外，账户由`Account`类表示。`Account`对象持有关于其所有者和他们拥有的金额的信息。要向账户中添加一些钱，系统使用一个获取`Account`对象监视器并修改其`money`字段的`add`方法。银行的业务流程要求特别处理大额转账：如果货币转账超过10个货币单位，我们需要记录它。在以下代码中，我们将定义`Account`类和`add`方法，该方法向`Account`对象添加金额`n`：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `add` method calls `logTransfer` from inside the `synchronized` statement,
    and `logTransfer` first obtains the `transfers` monitor. Importantly, this happens
    without releasing the `account` monitor. If the `transfers` monitor is currently
    acquired by some other thread, the current thread goes into the blocked state
    without releasing any of the monitors that it previously acquired.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`方法在`synchronized`语句内部调用`logTransfer`，而`logTransfer`首先获取`transfers`监视器。重要的是，这发生时不会释放`account`监视器。如果`transfers`监视器当前被某个其他线程获取，当前线程将进入阻塞状态，而不会释放它之前获取的任何监视器。'
- en: 'In the following example, the main application creates two separate accounts
    and three threads that execute transfers. Once all the threads complete their
    transfers, the main thread outputs all the transfers that were logged:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，主应用程序创建了两个单独的账户和三个执行转账的线程。一旦所有线程完成转账，主线程将输出所有已记录的转账：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The use of the `synchronized` statement in this example prevents threads `t1`
    and `t3` from corrupting Jane''s account by concurrently modifying it. The `t2`
    and `t3` threads also access the `transfers` log. This simple example shows why
    nesting is useful: we do not know which other components in our banking system
    potentially use the `transfers` log. To preserve encapsulation and prevent code
    duplication, independent software components should not explicitly synchronize
    to log a money transfer; synchronization is instead hidden in the `logTransfer`
    method.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用`synchronized`语句防止了线程`t1`和`t3`通过并发修改Jane的账户来破坏其账户。`t2`和`t3`线程也访问`transfers`日志。这个简单的示例展示了嵌套的用途：我们不知道我们的银行系统中哪些其他组件可能使用了`transfers`日志。为了保持封装并防止代码重复，独立的软件组件不应显式同步以记录货币转移；相反，同步被隐藏在`logTransfer`方法中。
- en: Deadlocks
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁
- en: A factor that worked to our advantage in the banking system example is that
    the `logTransfer` method never attempts to acquire any monitors other than the
    `transfers` monitor. Once the monitor is obtained, a thread will eventually modify
    the `transfers` buffer and release the monitor; in a stack of nested monitor acquisitions,
    `transfers` always comes last. Given that `logTransfer` is the only method synchronizing
    on `transfers`, it cannot indefinitely delay other threads that synchronize on
    `transfers`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在银行系统示例中，对我们有利的一个因素是`logTransfer`方法永远不会尝试获取除`transfers`监视器之外的任何监视器。一旦获取了监视器，线程最终会修改`transfers`缓冲区并释放监视器；在嵌套监视器获取的堆栈中，`transfers`总是最后。鉴于`logTransfer`是唯一在`transfers`上同步的方法，它不能无限期地延迟其他在`transfers`上同步的线程。
- en: A **deadlock** is a general situation in which two or more executions wait for
    each other to complete an action before proceeding with their own action. The
    reason for waiting is that each of the executions obtains an exclusive access
    to a resource that the other execution needs to proceed. As an example from our
    daily life, assume that you are sitting in a cafeteria with your colleague and
    just about to start your lunch. However, there is only a single fork and a single
    knife at the table, and you need both the utensils to eat. You grab the fork,
    but your colleague grabs a knife. Both of you wait for the other to finish the
    meal, but do not let go of your own utensil. You are now in a state of deadlock,
    and you will never finish your lunch. Well, at least not until your boss arrives
    to see what's going on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**死锁**是一种通用情况，其中两个或多个执行在继续自己的操作之前等待对方完成操作。等待的原因是每个执行都获得了对其他执行需要的资源的独占访问权。以我们日常生活中的一个例子来说明，假设你和你的同事坐在自助餐厅里，准备开始吃午餐。然而，桌子上只有一个叉子和一把刀，你需要这两样餐具才能吃饭。你拿起叉子，但你的同事拿起刀。你们两个都在等待对方吃完饭，但都不愿意放下自己的餐具。你现在处于死锁状态，你将永远无法吃完午餐。好吧，至少直到你的老板到来看到发生了什么。'
- en: In concurrent programming, when two threads obtain two separate monitors at
    the same time and then attempt to acquire the other thread's monitor, a deadlock
    occurs. Both the threads go into a blocked state until the other monitor is released,
    but do not release the monitors they own.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发编程中，当两个线程同时获取两个不同的监视器，然后尝试获取另一个线程的监视器时，会发生死锁。两个线程都会进入阻塞状态，直到另一个监视器被释放，但不会释放它们拥有的监视器。
- en: 'The `logTransfer` method can never cause a deadlock, because it only attempts
    to acquire a single monitor that is released eventually. Let''s now extend our
    banking example to allow money transfers between specific accounts, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`logTransfer`方法永远不会引起死锁，因为它只尝试获取最终会释放的单个监视器。现在让我们扩展我们的银行示例，允许在特定账户之间进行货币转移，如下所示：'
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We import the `Account` class from the previous example. The `send` method
    atomically transfers a given amount of money `n` from an account `a` to another
    account `b`. To do so, it invokes the `synchronized` statement on both the accounts
    to ensure that no other thread is modifying either account concurrently, as shown
    in the following snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从上一个示例中导入`Account`类。`send`方法原子性地将给定金额`n`从账户`a`转移到另一个账户`b`。为此，它对两个账户都调用了`synchronized`语句，以确保没有其他线程正在同时修改任一账户，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, assume that two of our bank's new clients, Jack and Jill, just opened their
    accounts and are amazed with the new e-banking platform. They log in and start
    sending each other small amounts of money to test it, frantically hitting the
    send button a 100 times. Soon, something very bad happens. The `t1` and `t2` threads,
    which execute Jack's and Jill's requests, invoke `send` simultaneously with the
    order of accounts `a` and `b` reversed. Thread `t1` locks `a` and `t2` locks `b`,
    but are then both unable to lock the other account. To Jack's and Jill's surprise,
    the new transfer system is not as shiny as it seems. If you are running this example,
    you'll want to close the terminal session at this point and restart SBT.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们银行的新客户杰克和吉尔刚刚开设了账户，并对新的电子银行平台感到惊讶。他们登录并开始互相发送小额金钱以测试它，疯狂地按发送按钮100次。很快，发生了一件非常糟糕的事情。执行杰克和吉尔请求的`t1`和`t2`线程，以账户`a`和`b`的顺序相反的方式同时调用`send`。线程`t1`锁定`a`，而`t2`锁定`b`，但随后两者都无法锁定另一个账户。让杰克和吉尔惊讶的是，新的转账系统并不像看起来那么完美。如果你正在运行这个示例，你将想要在这个时候关闭终端会话并重新启动SBT。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A deadlock occurs when a set of two or more threads acquire resources and then
    cyclically try to acquire other thread's resources without releasing their own.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当一组两个或更多线程获取资源后，然后循环尝试获取其他线程的资源而不释放自己的资源时，会发生死锁。
- en: How do we prevent deadlocks from occurring? Recall that, in the initial banking
    system example, the order in which the monitors were acquired was well defined.
    A single account monitor was acquired first and the `transfers` monitor was possibly
    acquired afterward. You should convince yourself that whenever resources are acquired
    in the same order, there is no danger of a deadlock. When a thread `T` waits for
    a resource `X` acquired by some other thread S, the thread S will never try to
    acquire any resource `Y` already held by `T`, because `Y` < `X` and `S` might
    only attempt to acquire resources `Y` > `X`. The ordering breaks the cycle, which
    is one of the necessary preconditions for a deadlock.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何防止死锁的发生？回想一下，在最初的银行系统示例中，获取监视器的顺序是明确定义的。首先获取单个账户监视器，然后可能随后获取`transfers`监视器。你应该确信，无论何时以相同的顺序获取资源，都不会有死锁的危险。当线程`T`等待由某个其他线程`S`获取的资源`X`时，线程`S`永远不会尝试获取`T`已经持有的任何资源`Y`，因为`Y`
    < `X`，而`S`可能只尝试获取`Y` > `X`的资源。这种排序打破了循环，这是死锁的必要前提条件之一。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Establish a total order between resources when acquiring them; this ensures
    that no set of threads cyclically wait on the resources they previously acquired.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取资源时建立资源的总顺序；这确保了没有一组线程会循环等待它们之前获取的资源。
- en: 'In our example, we need to establish an order between different accounts. One
    way of doing so is to use the `getUniqueId` method introduced in an earlier section:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们需要在不同账户之间建立一种顺序。这样做的一种方法是在前面的章节中引入的`getUniqueId`方法：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The new `Account` class ensures that no two accounts share the same `uid` value,
    regardless of the thread they were created on. The deadlock-free `send` method
    then needs to acquire the accounts in the order of their `uid` values, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Account`类确保无论在哪个线程上创建，两个账户都不会共享相同的`uid`值。然后，无死锁的`send`方法需要按照账户的`uid`值顺序获取账户，如下所示：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After a quick response from the bank's software engineers, Jack and Jill happily
    send each other money again. A cyclic chain of blocked threads can no longer happen.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在银行软件工程师的快速响应后，杰克和吉尔又愉快地互相发送金钱。阻塞线程的循环链不再发生。
- en: Deadlocks are inherent to any concurrent system in which the threads wait indefinitely
    for a resource without releasing the resources they previously acquired. However,
    while they should be avoided, deadlocks are often not as deadly as they sound.
    A nice thing about deadlocks is that by their definition, a deadlocked system
    does not progress. The developer that resolved Jack and Jill's issue was able
    to act quickly by doing a heap dump of the running JVM instance and analyzing
    the thread stacks; deadlocks can at least be easily identified, even when they
    occur in a production system. This is unlike the errors due to race conditions,
    which only become apparent long after the system transitions into an invalid state.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁是任何并发系统中固有的，其中线程无限期地等待资源而不释放它们之前获取的资源。然而，尽管应该避免死锁，但它们通常不像听起来那么致命。关于死锁的一个好事情是，根据其定义，死锁的系统不会进步。解决杰克和吉尔问题的开发者能够通过执行正在运行的JVM实例的堆转储并分析线程堆栈来迅速行动；死锁至少可以很容易地识别，即使它们发生在生产系统中。这与由于竞争条件引起的错误不同，这些错误只有在系统过渡到无效状态之后才会变得明显。
- en: Guarded blocks
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护块
- en: Creating a new thread is much more expensive than creating a new lightweight
    object such as `Account`. A high-performance banking system should be quick and
    responsive, and creating a new thread on each request can be too slow when there
    are thousands of requests per second. The same thread should be reused for many
    requests; a set of such reusable threads is usually called a **thread pool**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的线程比创建一个新的轻量级对象，如`Account`，要昂贵得多。一个高性能的银行系统应该快速响应，当每秒有数千个请求时，为每个请求创建一个新的线程可能会太慢。应该重用相同的线程来处理许多请求；这样的一组可重用线程通常被称为**线程池**。
- en: 'In the following example, we will define a special thread called `worker` that
    will execute a block of code when some other thread requests it. We will use the
    mutable `Queue` class from the Scala standard library collections package to store
    the scheduled blocks of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将定义一个特殊的线程，称为`worker`，当其他线程请求时，它将执行一个代码块。我们将使用Scala标准库集合包中的可变`Queue`类来存储计划执行的代码块：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We represent the blocks of code with the `() => Unit` function type. The `worker`
    thread will repetitively call the `poll` method that synchronizes on `tasks` to
    check whether the queue is non-empty. The `poll` method shows that the `synchronized`
    statement can return a value. In this case, it returns an optional `Some` value
    if there are tasks to do, or `None` otherwise. The `Some` object contains the
    block of code to execute:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`() => Unit`函数类型来表示代码块。`worker`线程会重复调用`poll`方法，该方法在`tasks`上同步，以检查队列是否非空。`poll`方法表明`synchronized`语句可以返回一个值。在这种情况下，如果有任务要做，它返回一个可选的`Some`值，否则返回`None`。`Some`对象包含要执行的代码块：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We set the `worker` thread to be a **daemon** thread before starting it. Generally,
    a JVM process does not stop when the main thread terminates. The JVM process terminates
    when all non-daemon threads terminate. We want `worker` to be a daemon thread
    because we send work to it using the `asynchronous` method, which schedules a
    given block of code to eventually execute the `worker` thread:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动之前，我们将`worker`线程设置为**守护线程**。通常，当主线程终止时，JVM进程不会停止。只有当所有非守护线程终止时，JVM进程才会终止。我们希望`worker`是一个守护线程，因为我们使用`asynchronous`方法向它发送工作，该方法安排给定的代码块最终执行`worker`线程：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the preceding example and witness the `worker` thread print `Hello` and
    then `world!`. Now listen to your laptop. The fan should start humming by now.
    Turn on your **Task Manager** or simply type `top` into your terminal if you are
    running this on a Unix system. One of your CPUs is completely used up by a process
    called `java`. You can guess the reason. After `worker` completes its work, it
    is constantly checking if there are any tasks on the queue. We say that the `worker`
    thread is **busy-waiting**. Busy-waiting is undesired, because it needlessly uses
    processor power. Still, shouldn''t a daemon thread be stopped once the main thread
    terminates? In general, yes, but we are running this example from SBT in the same
    JVM process that SBT itself is running. SBT has non-daemon threads of its own,
    so our `worker` thread is not stopped. To tell SBT that it should execute the
    `run` command in a new process, enter the following directive:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的示例，并观察`worker`线程打印`Hello`然后`world!`。现在听听你的笔记本电脑。风扇应该已经开始嗡嗡作响了。打开你的**任务管理器**，或者如果你在Unix系统上运行此程序，简单地在终端中输入`top`。你的CPU中有一个进程被`java`完全占用。你可以猜到原因。在`worker`完成其工作后，它会不断地检查队列中是否有任何任务。我们说`worker`线程正在**忙等待**。忙等待是不希望的，因为它无谓地使用了处理器功率。然而，一旦主线程终止，守护线程不应该停止吗？一般来说，是的，但我们是从SBT中运行这个示例的，SBT本身也是在同一个JVM进程中运行的。SBT有自己的非守护线程，所以我们的`worker`线程没有被停止。为了告诉SBT它应该在新的进程中执行`run`命令，请输入以下指令：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running the preceding example again should stop the `worker` thread as soon
    as the main thread completes its execution. Still, our busy-waiting `worker` thread
    can be a part of a larger application that does not terminate so quickly. Creating
    new threads all the time might be expensive, but a busy-waiting thread is even
    more expensive. Several such threads can quickly compromise system performance.
    There are only a handful of applications in which busy-waiting makes sense. If
    you still have doubts that this is dangerous, start this example on your laptop
    while running on battery power and go grab a snack. Make sure that you save any
    open files before you do this; you might lose data once the CPU drains all the
    battery power.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行前面的示例应该会在主线程完成执行后立即停止`worker`线程。然而，我们的忙等待`worker`线程可能是更大应用的一部分，该应用不会那么快就终止。不断创建新线程可能会很昂贵，但忙等待线程的成本更高。几个这样的线程可以迅速降低系统性能。只有少数应用程序中忙等待才有意义。如果你仍然怀疑这是危险的，请在笔记本电脑上以电池供电运行此示例，然后去拿点零食。在这样做之前，请确保保存所有打开的文件；一旦CPU耗尽所有电池电量，你可能会丢失数据。
- en: What we would really like the `worker` thread to do is to go to the waiting
    state, similar to what a thread does when we call `join`. It should only wake
    up after we ensure that there are additional function objects to execute on the
    `tasks` queue.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正希望`worker`线程做到的是进入等待状态，类似于我们调用`join`时线程所做的那样。它应该在确保`tasks`队列中有额外的函数对象要执行后才能唤醒。
- en: 'Scala objects (and JVM objects in general) support a pair of special methods
    called `wait` and `notify`, which allow waiting and awakening the waiting threads,
    respectively. It is only legal to call these methods on an `x` object if the current
    thread owns the monitor of the object `x`. In other words, `wait` and `notify`
    can only be called from a thread that owns the monitor of that object. When a
    thread `T` calls `wait` on an object, it releases the monitor and goes into the
    waiting state until some other thread `S` calls `notify` on the same object. The
    thread `S` usually prepares some data for `T`, as in the following example in
    which the main thread sets the `Some` message for the `greeter` thread to print:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Scala对象（以及一般而言的JVM对象）支持一对特殊方法，称为`wait`和`notify`，分别允许等待和唤醒等待的线程。只有在当前线程拥有对象`x`的监视器时，才可以在`x`对象上调用这些方法。换句话说，`wait`和`notify`只能从拥有该对象监视器的线程中调用。当一个线程`T`在对象上调用`wait`时，它会释放监视器并进入等待状态，直到另一个线程`S`在同一个对象上调用`notify`。线程`S`通常会为`T`准备一些数据，如下面的示例中，主线程为`greeter`线程设置了`Some`消息以便打印：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The threads use the monitor from a fresh `lock` object of an `AnyRef` type that
    maps into the `java.lang.Object` class. The `greeter` thread starts by acquiring
    the lock's monitor and checks whether the message is set to `None`. If it is,
    there is nothing to output as yet and the `greeter` thread calls `wait` on `lock`.
    Upon calling `wait`, the `lock` monitor is released and the main thread, which
    was previously blocked at its `synchronized` statement, now obtains the ownership
    of the `lock` monitor, sets the message, and calls `notify`. When the main thread
    leaves the `synchronized` block, it releases `lock`. This causes `greeter` to
    wake up, acquire `lock`, check whether there is a message again, and then output
    it. Since `greeter` acquires the same monitor that the main thread previously
    released, the write to `message` by the main thread occurs before the check by
    the `greeter` thread. We now know that the `greeter` thread will see the message.
    In this example, the `greeter` thread will output `Hello!` regardless of which
    thread runs `synchronized` first.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 线程使用从`AnyRef`类型的`lock`对象中获取的监视器，该对象映射到`java.lang.Object`类。`greeter`线程首先获取锁的监视器，并检查消息是否设置为`None`。如果是，目前还没有任何输出，`greeter`线程在`lock`上调用`wait`。在调用`wait`时，`lock`监视器被释放，之前在`synchronized`语句处阻塞的主线程现在获得了`lock`监视器的所有权，设置了消息，并调用了`notify`。当主线程离开`synchronized`块时，它释放了`lock`。这导致`greeter`唤醒，获取`lock`，再次检查是否有消息，然后输出。由于`greeter`获取了主线程之前释放的相同监视器，主线程对`message`的写入发生在`greeter`线程的检查之前。我们现在知道`greeter`线程将看到消息。在这个例子中，无论哪个线程首先运行`synchronized`，`greeter`线程都将输出`Hello!`。
- en: An important property of the `wait` method is that it can cause **spurious wakeups**.
    Occasionally, the JVM is allowed to wake up a thread that called `wait` even though
    there is no corresponding `notify` call. To guard against this, we must always
    use `wait` in conjunction with a `while` loop that checks the condition, as in
    the previous example. Using an `if` statement would be incorrect, as a spurious
    wakeup could allow the thread to execute `message.get`, even though `message`
    was not set to a value different than `None`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait`方法的一个重要属性是它可以导致**虚假唤醒**。偶尔，JVM允许唤醒一个调用了`wait`的线程，即使没有相应的`notify`调用。为了防止这种情况，我们必须始终像上一个例子中那样将`wait`与检查条件的`while`循环一起使用。使用`if`语句是不正确的，因为虚假唤醒可能会允许线程执行`message.get`，即使`message`没有被设置为不同于`None`的值。'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: After the thread that checks the condition wakes up, the monitor becomes owned
    by that thread, so we are guaranteed that the check is performed atomically. Note
    that a thread that checks the condition must acquire the monitor to wake up. If
    it cannot acquire the monitor immediately, it goes into the blocked state.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查条件的线程唤醒之后，监视器被该线程拥有，因此我们保证检查是原子性执行的。请注意，检查条件的线程必须获取监视器才能唤醒。如果它不能立即获取监视器，它将进入阻塞状态。
- en: 'A `synchronized` statement in which some condition is repetitively checked
    before calling `wait` is called a **guarded block**. We can now use our insight
    on guarded blocks to avoid the busy-wait in our `worker` thread in advance. We
    will now show the complete `worker` implementation using monitors:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`wait`之前反复检查某些条件的`synchronized`语句被称为**保护块**。我们现在可以使用我们对保护块的了解来避免在`worker`线程中提前忙等待。现在，我们将使用监视器展示完整的`worker`实现：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we declared the `Worker` thread as a singleton object within
    our application to be more concise. This time, the `poll` method calls `wait`
    on the `tasks` object and waits until the main thread adds a code block to `tasks`
    and calls `notify` in the `asynchronous` method. Start the example and inspect
    your CPU usage again. If you restarted SBT (and still have battery power) since
    running the busy-wait example, you will see that the CPU usage by the `java` process
    is zero.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`Worker`线程作为我们的应用程序中的一个单例对象声明，以使代码更简洁。这次，`poll`方法在`tasks`对象上调用`wait`，并等待主线程将代码块添加到`tasks`中并在异步方法中调用`notify`。启动示例并再次检查您的CPU使用情况。如果您从运行忙等待示例以来重新启动了SBT（并且仍然有电池电量），您将看到`java`进程的CPU使用率为零。
- en: Interrupting threads and the graceful shutdown
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断线程和优雅关闭
- en: 'In the previous example, the `Worker` thread loops forever in its `run` method
    and never terminates. You might be satisfied with this; `Worker` does not use
    the CPU if it has no work to do, and since `Worker` is a daemon thread, it is
    destroyed when the application exits. However, its stack space is not reclaimed
    until the application terminates. If we have a lot of dormant workers lying around,
    we might run out of memory. One way to stop a dormant thread from executing is
    to interrupt it, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Worker`线程在其`run`方法中无限循环，永远不会终止。你可能对此感到满意；如果`Worker`没有工作要做，它不会使用CPU，并且由于`Worker`是守护线程，当应用程序退出时它将被销毁。然而，其堆栈空间直到应用程序终止才被回收。如果我们有很多休眠的工作线程，我们可能会耗尽内存。停止休眠线程执行的一种方法是通过以下方式中断它：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Calling the `interrupt` method on a thread that is in the waiting or timed waiting
    state causes it to throw an `InterruptedException`. This exception can be caught
    and handled, but in our case, it will terminate the `Worker` thread. However,
    if we call this method while the thread is running, the exception is not thrown
    and the thread's `interrupt` flag is set. A thread that does not block must periodically
    query the interrupt flag with the `isInterrupted` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在处于等待或定时等待状态的线程上调用`interrupt`方法会导致它抛出`InterruptedException`。这个异常可以被捕获和处理，但在这个情况下，它将终止`Worker`线程。然而，如果我们在这个线程正在运行时调用此方法，则不会抛出异常，并且线程的`interrupt`标志被设置。一个不阻塞的线程必须定期使用`isInterrupted`方法查询中断标志。
- en: 'An alternative is to implement an idiom known as the **graceful shutdown**.
    In the graceful shutdown, one thread sets the condition for the termination and
    then calls `notify` to wake up a worker thread. The worker thread then releases
    all its resources and terminates willingly. We first introduce a variable called
    `terminated` that is `true` if the thread should be stopped. The `poll` method
    additionally checks this variable before waiting on `tasks` and optionally returns
    a task only if the `Worker` thread should continue to run, as shown in the following
    code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是实现一个称为**优雅关闭**的惯用表达法。在优雅关闭中，一个线程设置终止条件，然后调用`notify`来唤醒工作线程。然后工作线程释放所有资源并自愿终止。我们首先引入一个名为`terminated`的变量，如果线程应该停止，则该变量为`true`。`poll`方法在等待`tasks`之前会检查这个变量，并且只有在`Worker`线程应该继续运行的情况下才可选地返回一个任务，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We change the `run` method to check if `poll` returns `Some(task)` in a pattern
    match. We no longer use a `while` loop in the `run` method. Instead, we call `run`
    tail-recursively if `poll` returned `Some(task)`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`run`方法修改为在模式匹配中检查`poll`是否返回`Some(task)`。我们不再在`run`方法中使用`while`循环。相反，如果`poll`返回`Some(task)`，我们将尾递归地调用`run`：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The main thread can now call the synchronized `shutdown` method on the `Worker`
    thread to communicate with the termination request. There is no need to make the
    `Worker` thread a daemon thread anymore. Eventually, the `Worker` thread will
    terminate on its own.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程现在可以调用`Worker`线程的同步`shutdown`方法来与终止请求进行通信。不再需要将`Worker`线程设置为守护线程。最终，`Worker`线程将自行终止。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To ensure that various utility threads terminate correctly without race conditions,
    use the graceful shutdown idiom.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保各种实用线程能够正确地终止，避免竞争条件，请使用优雅关闭的惯用表达法。
- en: The situation where calling `interrupt` is preferred to a graceful shutdown
    is when we cannot wake the thread using `notify`. One example is when the thread
    does blocking I/O on an `InterruptibleChannel` object, in which case the object
    the thread is calling the `wait` method on is hidden.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们无法使用`notify`唤醒线程时，调用`interrupt`比优雅关闭更可取的情况。一个例子是当线程在`InterruptibleChannel`对象上执行阻塞I/O时，在这种情况下，线程正在调用的`wait`方法的对象是隐藏的。
- en: The `Thread` class also defines a deprecated `stop` method that immediately
    terminates a thread by throwing a `ThreadDeath` exception. You should avoid it
    as it stops the thread's execution at an arbitrary point, possibly leaving the
    program data in an inconsistent state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类还定义了一个已过时的`stop`方法，该方法通过抛出`ThreadDeath`异常立即终止线程。你应该避免使用它，因为它可能在任意点停止线程的执行，这可能导致程序数据处于不一致的状态。'
- en: Volatile variables
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 易失性变量
- en: The JVM offers a more lightweight form of synchronization than the `synchronized`
    block, called **volatile variables**. Volatile variables can be atomically read
    and modified, and are mostly used as status flags; for example, to signal that
    a computation is completed or canceled. They have two advantages. First, writes
    to and reads from volatile variables cannot be reordered in a single thread. Second,
    writing to a volatile variable is immediately visible to all the other threads.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 提供了一种比 `synchronized` 块更轻量级的同步形式，称为 **volatile 变量**。Volatile 变量可以原子地读取和修改，通常用作状态标志；例如，用于表示计算已完成或已取消。它们有两个优点。首先，对
    volatile 变量的写入和读取不能在单个线程中重新排序。其次，写入 volatile 变量对其他所有线程都是立即可见的。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Reads and writes to variables marked as volatile are never reordered. If a write
    `W` to a volatile `v` variable is observed on another thread through a read `R`
    of the same variable, then all the writes that preceded the write `W` are guaranteed
    to be observed after the read `R`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 volatile 的变量的读取和写入永远不会重新排序。如果另一个线程通过读取相同变量的读取 `R` 观察到对 volatile `v` 变量的写入
    `W`，则保证在读取 `R` 之后观察到所有在写入 `W` 之前发生的写入。
- en: 'In the following example, we search for at least one `!` character in several
    pages of the text. Separate threads start scanning separate pages `p` of the text
    written by a person that is particularly fond of a popular fictional hero. As
    soon as one thread finds the exclamation, we want to stop searching in other threads:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们在文本的几个页面上搜索至少一个 `!` 字符。单独的线程开始扫描由特别喜爱某个流行虚构英雄的人编写的文本的单独页面 `p`。一旦一个线程找到感叹号，我们希望停止其他线程的搜索：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Separate pages of text are represented by the `Page` class, which has a special
    `position` field for storing the result of the exclamation mark search. The `found`
    flag denotes that some thread has found an exclamation. We add the `@volatile`
    annotation to the `found` flag to declare it volatile. When some thread finds
    an exclamation character in some page, the `position` value is stored and the
    `found` flag is set so that the other threads can stop their search early. It
    is entirely possible that all the threads end up scanning the entire text, but
    more likely that they see that `found` is `true` before that. Thus, at least one
    thread stores the exclamation position.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的单独页面由 `Page` 类表示，该类有一个特殊的 `position` 字段用于存储感叹号搜索的结果。`found` 标志表示某个线程找到了一个感叹号。我们向
    `found` 标志添加 `@volatile` 注解以声明其为 volatile。当某个线程在某个页面上找到感叹号字符时，将存储 `position` 值并将
    `found` 标志设置为其他线程可以提前停止搜索。所有线程最终扫描整个文本是完全可能的，但更有可能的是，它们在看到 `found` 为 `true` 之前就看到了。因此，至少有一个线程存储了感叹号的位置。
- en: For the purposes of this example, the main thread busy-waits until it reads
    `found`, which is `true`. It then prints the positions. Note that a write to `position`
    occurs before the write to `found` in the spawned threads, which in turn occurs
    before reading `found` in the main thread. This means that the main thread always
    sees the write of the thread that set `found`, and hence prints at least one position
    other than `-1`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，主线程忙等待直到读取到 `found`，其为 `true`。然后打印位置。请注意，在派生线程中，对 `position` 的写入发生在对 `found`
    的写入之前，这又发生在主线程读取 `found` 之前。这意味着主线程总是看到设置 `found` 的线程的写入，因此至少打印一个除 `-1` 之外的位置。
- en: The `ThreadSharedStateAccessReordering` example from an earlier section can
    be fixed by declaring all the variables as volatile. As we will learn in the next
    section, this ensures a correct order between reads from and writes to `a` and
    `b`. Unlike Java, Scala allows you to declare local fields volatile (in this case,
    local to the closure of the enclosing `for` loop). A heap object with a volatile
    field is created for each local volatile variable used in some closure or a nested
    class. We say the variable is **lifted** into an object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 早期部分中的 `ThreadSharedStateAccessReordering` 示例可以通过声明所有变量为 volatile 来修复。正如我们将在下一节中学习的，这确保了从
    `a` 和 `b` 读取和写入之间的正确顺序。与 Java 不同，Scala 允许你声明局部字段为 volatile（在这种情况下，局部于包围的 `for`
    循环的闭包）。为在某个闭包或嵌套类中使用的每个局部 volatile 变量创建一个具有 volatile 字段的堆对象。我们说变量被 **提升** 到一个对象中。
- en: A volatile read is usually extremely cheap. In most cases, however, you should
    resort to the `synchronized` statements; volatile semantics are subtle and easy
    to get wrong. In particular, multiple volatile reads and writes are not atomic
    without additional synchronization; volatiles alone cannot help us to implement
    `getUniqueId` correctly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 易失性读取通常非常便宜。然而，在大多数情况下，你应该求助于`synchronized`语句；易失性语义微妙且容易出错。特别是，没有额外同步的多重易失性读取和写入不是原子的；仅易失性本身不能帮助我们正确实现`getUniqueId`。
- en: The Java Memory Model
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java内存模型
- en: While we were never explicit about it throughout this chapter, we have actually
    defined most of the JMM. What is a memory model in the first place?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这章中从未明确指出，但实际上我们已经定义了JMM的大部分内容。那么，内存模型究竟是什么呢？
- en: A language memory model is a specification that describes the circumstances
    under which a write to a variable becomes visible to other threads. You might
    think that a write to a variable `v` changes the corresponding memory location
    immediately after the processor executes it, and that other processors see the
    new value of `v` instantaneously. This memory consistency model is called **sequential
    consistency**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 语言内存模型是一种规范，它描述了在什么情况下对变量的写入对其他线程可见。你可能认为对变量`v`的写入在处理器执行后立即改变相应的内存位置，并且其他处理器会立即看到`v`的新值。这种内存一致性模型被称为**顺序一致性**。
- en: As we already saw in the `ThreadSharedStateAccessReordering` example, sequential
    consistency has little to do with how processors and compilers really work. Writes
    rarely end up in the main memory immediately; instead, processors have hierarchies
    of caches that ensure a better performance and guarantee that the data is only
    eventually written to the main memory. Compilers are allowed to use registers
    to postpone or avoid memory writes, and reorder statements to achieve optimal
    performance, as long as it does not change the serial semantics. It makes sense
    to do so; while the short examples in this book are interspersed with synchronization
    primitives, in actual programs, different threads communicate relatively rarely
    compared to the amount of time spent doing useful work.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`ThreadSharedStateAccessReordering`示例中已经看到的，顺序一致性与处理器和编译器实际工作方式的关系很小。写入很少立即结束在主内存中；相反，处理器有层次化的缓存，以确保更好的性能并保证数据最终写入主内存。编译器允许使用寄存器来推迟或避免内存写入，并重新排序语句以实现最佳性能，只要它不改变序列语义。这样做是有意义的；虽然这本书中的简短示例中穿插着同步原语，但在实际程序中，不同线程之间的通信相对较少，与花费在有用工作上的时间相比。
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A memory model is a trade-off between the predictable behavior of a concurrent
    program and a compiler's ability to perform optimizations. Not every language
    or platform has a memory model. A typical purely functional programming language,
    which doesn't support mutations, does not need a memory model at all.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 内存模型是在并发程序的预期行为和编译器执行优化的能力之间的一种权衡。并非每种语言或平台都有内存模型。一个典型的纯函数式编程语言，它不支持突变，根本不需要内存模型。
- en: Differences between processor architectures result in different memory models;
    it would be very difficult, if not impossible, to correctly write a Scala program
    that works in the same way on every computer without the precise semantics of
    the `synchronized` statement or volatile reads and writes. Scala inherits its
    memory model from the JVM, which precisely specifies a set of **happens-before**
    relationships between different actions in a program.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器架构之间的差异导致了不同的内存模型；如果没有`synchronized`语句或易失性读取和写入的精确语义，正确编写在每台计算机上都能以相同方式工作的Scala程序是非常困难，如果不是不可能的。Scala从JVM继承了其内存模型，JVM精确地指定了程序中不同操作之间的一系列**发生之前**的关系。
- en: 'In the JMM, the different actions are (volatile) variable reads and writes,
    acquiring and releasing object monitors, starting threads, and waiting for their
    termination. If an action A happens before an action B, then the action B sees
    A''s memory writes. The same set of happens-before relationships is valid for
    the same program irrespective of the machine it runs on; it is the JVM''s task
    to ensure this. We already summarized most of these rules, but we will now present
    a complete overview:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在JMM中，不同的操作包括（易失性）变量读取和写入、获取和释放对象监视器、启动线程以及等待其终止。如果一个操作A在操作B之前发生，那么操作B将看到A的内存写入。对于同一程序，无论它在哪个机器上运行，这一组发生之前的关系都是有效的；确保这一点是JVM的任务。我们之前已经总结了大部份这些规则，但现在我们将提供一个完整的概述：
- en: '**Program order**: Each action in a thread happens-before every other subsequent
    action in the program order of that thread.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序顺序**: 线程中的每个操作都发生在该线程程序顺序中的每个后续操作之前。'
- en: '**Monitor locking**: Unlocking a monitor happens-before every subsequent locking
    of that monitor.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视器锁定**: 监视器解锁发生在对该监视器后续所有锁定之前。'
- en: '**Volatile fields**: A write to a volatile field happens-before every subsequent
    read of that volatile field.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易变字段**: 对易变字段的写入操作发生在对该易变字段后续所有读取操作之前。'
- en: '**Thread start**: A call to `start()` on a thread happens-before any actions
    in the started thread.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程启动**: 在线程上调用 `start()` 的操作发生在启动的线程中任何操作之前。'
- en: '**Thread termination**: Any action in a thread happens-before another thread
    completes a `join()` call on that thread.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程终止**: 线程中的任何操作都发生在另一个线程完成对该线程的 `join()` 调用之前。'
- en: '**Transitivity**: If action A happens-before action B, and action B happens-before
    action C, then action A happens-before action C.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传递性**: 如果操作 A 发生在操作 B 之前，且操作 B 发生在操作 C 之前，那么操作 A 发生在操作 C 之前。'
- en: Despite its somewhat misleading name, the happens-before relationship exists
    to ensure that threads see each other's memory writes. It does not exist to establish
    a temporal ordering between different statements in the program. When we say that
    a write A happens before a read B, it is guaranteed that the effects of the write
    A are visible to that particular read B. Whether or not the write A occurs earlier
    than the read B depends on the execution of the program.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其名称有些误导，但 happens-before 关系的存在是为了确保线程可以看到彼此的内存写入。它不是为了在程序中的不同语句之间建立时间顺序。当我们说写入
    A 发生在读取 B 之前时，我们保证写入 A 的效果对该特定读取 B 是可见的。写入 A 是否早于读取 B 取决于程序的执行。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The happens-before relationship describes the visibility of the writes performed
    by a different thread.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: happens-before 关系描述了不同线程执行的写入的可视性。
- en: 'Additionally, the JMM guarantees that volatile reads and writes as well as
    monitor locks and unlocks are never reordered. The happens-before relationship
    ensures that nonvolatile reads and writes also cannot be reordered arbitrarily.
    In particular, this relationship ensures the following things:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JMM 保证易变读取和写入以及监视器锁定和解锁永远不会重新排序。happens-before 关系确保非易变读取和写入也不能任意重新排序。特别是，这种关系确保以下事项：
- en: A non-volatile read cannot be reordered to appear before a volatile read (or
    monitor lock) that precedes it in the program order
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非易变读取不能重新排序以出现在程序顺序中先于它的易变读取（或监视器锁定）之前。
- en: A non-volatile write cannot be reordered to appear after a volatile write (or
    monitor unlock) that follows it in the program order
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非易变写入不能重新排序以出现在程序顺序中跟随其后的易变写入（或监视器解锁）之后。
- en: Higher-level constructs often establish a happens-before relationship on top
    of these rules. For example, an `interrupt` call happens before the interrupted
    thread detects it; this is because the `interrupt` call uses a monitor to wake
    the thread in a typical implementation. Scala concurrency APIs described in the
    later chapters also establish happens-before relationships between various method
    calls, as we will see. In all these cases, it is the task of the programmer to
    ensure that every write of a variable is in a happens-before relationship with
    every read of that variable that should read the written value. A program in which
    this is not true is said to contain **data races**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 高级构造通常在这些规则之上建立 happens-before 关系。例如，`interrupt` 调用发生在中断的线程检测到它之前；这是因为 `interrupt`
    调用通常使用监视器唤醒线程。在后面的章节中描述的 Scala 并发 API 也建立了各种方法调用之间的 happens-before 关系，正如我们将看到的。在这些所有情况下，程序员的任务是确保每个变量的每个写入都与应该读取该写入值的每个读取操作建立
    happens-before 关系。如果一个程序中这一点不成立，那么该程序被认为包含 **数据竞争**。
- en: Immutable objects and final fields
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变对象和最终字段
- en: We have said that programs must establish happens-before relationships to avoid
    data races, but there is an exception to this rule. If an object contains only
    **final fields** and the reference to the enclosing object does not become visible
    to another thread before the constructor completes, then the object is considered
    immutable and can be shared between the threads without any synchronization.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过程序必须建立 happens-before 关系以避免数据竞争，但这个规则有一个例外。如果一个对象只包含 **final 字段**，并且封装对象的引用在构造函数完成之前不会对另一个线程可见，那么该对象被认为是不可变的，并且可以在线程之间共享而不需要任何同步。
- en: 'In Java, a final field is marked with the `final` keyword. In Scala, declaring
    an object field as `final` means that the getter for that field cannot be overridden
    in a subclass. The field itself is always final provided that it is a value declaration,
    that is, a `val` declaration. The following class depicts this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，final字段用`final`关键字标记。在Scala中，将对象字段声明为`final`意味着该字段的getter不能在子类中重写。只要它是值声明，即`val`声明，该字段本身始终是final。以下类展示了这一点：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding class corresponds to the following Java class after the Scala
    compiler translates it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala编译器将其转换后，前面的类对应以下Java类：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that both the fields become final at the JVM level and can be shared without
    synchronization. The difference is that the getter for `a` cannot be overridden
    in a `Foo` subclass. We have to disambiguate finality in the reassignment and
    overriding sense.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在JVM级别，这两个字段都变为final，并且可以在不进行同步的情况下共享。区别在于`a`的getter不能在`Foo`子类中重写。我们必须在重新分配和重写意义上消除final性的歧义。
- en: 'Since Scala is a hybrid between functional and object-oriented paradigms, many
    of its language features map to immutable objects. A lambda value can capture
    a reference to the enclosing class or a lifted variable, as in the following example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Scala是函数式和面向对象范式的混合体，许多语言特性映射到不可变对象。一个lambda值可以捕获封装类的引用或提升的变量，如下例所示：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The local `number` variable is captured by the lambda, so it needs to be lifted.
    The statement in the last line translates to an anonymous `Function0` class instantiation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本地`number`变量被lambda捕获，因此需要提升。最后一行的语句转换为匿名`Function0`类的实例化：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There is no happens-before relationship between the assignment to `inc` and
    the read of `inc` by the thread `t`. However, if the `t` thread sees that `inc`
    is not `null`, invoking `inc` still works correctly, because the `$number` field
    is appropriately initialized since it is stored as a field in the immutable lambda
    object. The Scala compiler ensures that lambda values contain only final, properly
    initialized fields. Anonymous classes, auto-boxed primitives, and value classes
    share the same philosophy.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`inc`的赋值和线程`t`读取`inc`之间没有happens-before关系。然而，如果`t`线程看到`inc`不是`null`，调用`inc`仍然可以正确工作，因为`$number`字段已经适当地初始化，因为它存储在不可变lambda对象中。Scala编译器确保lambda值只包含final、正确初始化的字段。匿名类、自动装箱的基本类型和值类遵循相同的哲学。'
- en: In current versions of Scala, however, certain collections that are deemed immutable,
    such as `List` and `Vector`, cannot be shared without synchronization. Although
    their external API does not allow you to modify them, they contain non-final fields.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在当前版本的Scala中，某些被认为是不可变的集合，如`List`和`Vector`，在未同步的情况下不能共享。尽管它们的公共API不允许您修改它们，但它们包含非final字段。
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Even if an object seems immutable, always use proper synchronization to share
    any object between the threads.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个对象看起来是不可变的，在线程之间共享任何对象时，始终使用适当的同步。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we showed how to create and start threads, and wait for their
    termination. We have shown how to achieve inter-thread communication by modifying
    the shared memory and by using the `synchronized` statement, and what it means
    for a thread to be in a blocked state. We have studied approaches to prevent deadlocks
    by imposing the ordering on the locks and avoided busy-waits in place of guarded
    blocks. We have seen how to implement a graceful shutdown for thread termination
    and when to communicate using volatiles. We witnessed how the correctness of a
    program can be compromised by undesired interactions known as race conditions
    as well as data races due to the lack of synchronization. And, most importantly,
    we have learned that the only way to correctly reason about the semantics of a
    multithreaded program is in terms of happens-before relationships defined by the
    JMM.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何创建和启动线程，以及等待它们的终止。我们展示了如何通过修改共享内存和使用`synchronized`语句来实现线程间的通信，以及线程处于阻塞状态的含义。我们研究了通过在锁上施加排序来防止死锁的方法，并避免了在保护块中使用忙等待。我们看到了如何实现线程终止的优雅关闭，以及在何时使用volatile进行通信。我们见证了程序的正确性如何因未预期的交互（称为竞态条件）以及由于缺乏同步而导致的数据竞争而受损。最重要的是，我们了解到正确推理多线程程序语义的唯一方法是使用JMM定义的happens-before关系。
- en: The language primitives and APIs presented in this section are low-level; they
    are the basic building blocks for concurrency on the JVM and in Scala, and there
    are only a handful of situations where you should use them directly. One of them
    is designing a new concurrency library yourself; another one is dealing with a
    legacy API built directly from these primitives. Although you should strive to
    build concurrent Scala applications in terms of concurrency frameworks introduced
    in the later chapters, the insights from this chapter will be helpful in understanding
    how higher-level constructs work. You should now have a valuable insight of what's
    going on under the hood.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '本节中介绍的语言原语和 API 是低级的；它们是 JVM 和 Scala 上并发的基本构建块，只有少数情况下你应该直接使用它们。其中之一是自行设计新的并发库；另一个是处理直接从这些原语构建的遗留
    API。尽管你应该努力使用后续章节中介绍的并发框架来构建并发 Scala 应用程序，但本章的见解将有助于理解高级结构是如何工作的。你现在应该对底层发生的事情有一个宝贵的洞察。 '
- en: If you would like to learn more about concurrency on the JVM and the JMM, we
    recommend that you read the book *Java Concurrency in Practice*, *Brian Goetz,
    Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea*, *Addison-Wesley*.
    For an in-depth understanding of processes, threads, and the internals of operating
    systems, we recommend the book *Operating System Concepts*, *Abraham Silberschatz,
    Peter B. Galvin, and Greg Gagne*, *Wiley*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 JVM 和 JMM 上的并发知识，我们建议你阅读书籍 *Java Concurrency in Practice*，作者 *Brian
    Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, 和 Doug Lea*，*Addison-Wesley*。为了深入了解进程、线程和操作系统的内部结构，我们建议阅读书籍
    *Operating System Concepts*，作者 *Abraham Silberschatz, Peter B. Galvin, 和 Greg
    Gagne*，*Wiley*。
- en: In the next chapter, we will cover more advanced building blocks of concurrent
    programs. We will learn how to use executors to avoid creating threads directly,
    concurrent collections for thread-safe data access, and atomic variables for deadlock-free
    synchronization. These high-level abstractions will alleviate many of the problems
    inherent to the fundamental concurrency primitives presented in this chapter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍并发程序的更多高级构建块。我们将学习如何使用执行器来避免直接创建线程，使用线程安全的并发集合进行数据访问，以及使用原子变量来实现无死锁的同步。这些高级抽象将减轻许多本章中介绍的并发基本原语固有的问题。
- en: Exercises
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'In the following set of exercises, you are required to implement higher-level
    concurrency abstractions in terms of basic JVM concurrency primitives. Some of
    these exercises introduce concurrent counterparts of sequential programming abstractions,
    and, in doing so, highlight important differences between sequential and concurrent
    programming. The exercises are not ordered in any particular order, but some of
    them rely on specific content from earlier exercises or this chapter:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下一系列练习中，你需要使用基本的 JVM 并发原语来实现高级并发抽象。其中一些练习引入了顺序编程抽象的并发对应物，并在这样做的同时，突出了顺序编程和并发编程之间的重要差异。练习没有特定的顺序，但其中一些依赖于早期练习或本章中的特定内容：
- en: 'Implement a `parallel` method, which takes two computation blocks, `a` and
    `b`, and starts each of them in a new thread. The method must return a tuple with
    the result values of both the computations. It should have the following signature:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `parallel` 方法，该方法接受两个计算块 `a` 和 `b`，并在新线程中启动每个块。该方法必须返回一个包含两个计算结果值的元组。它应该具有以下签名：
- en: '[PRE37]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implement a `periodically` method, which takes a time interval `duration` specified
    in milliseconds, and a computation block `b`. The method starts a thread that
    executes the computation block `b` every `duration` milliseconds. It should have
    the following signature:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `periodically` 方法，该方法接受一个以毫秒为单位指定的时间间隔 `duration`，以及一个计算块 `b`。该方法启动一个线程，每
    `duration` 毫秒执行一次计算块 `b`。它应该具有以下签名：
- en: '[PRE38]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement a `SyncVar` class with the following interface:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个具有以下接口的 `SyncVar` 类：
- en: '[PRE39]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A `SyncVar` object is used to exchange values between two or more threads.
    When created, the `SyncVar` object is empty:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SyncVar` 对象用于在两个或多个线程之间交换值。当创建时，`SyncVar` 对象为空：'
- en: Calling `get` throws an exception
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `get` 抛出异常
- en: Calling `put` adds a value to the `SyncVar` object
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `put` 向 `SyncVar` 对象添加一个值
- en: 'After a value is added to a `SyncVar` object, we say that it is non-empty:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在向 `SyncVar` 对象添加一个值之后，我们称它为非空：
- en: Calling `get` returns the current value, and changes the state to empty
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `get` 返回当前值，并将状态更改为空
- en: Calling `put` throws an exception
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `put` 抛出异常
- en: The `SyncVar` object from the previous exercise can be cumbersome to use, due
    to exceptions when the `SyncVar` object is in an invalid state. Implement a pair
    of methods, `isEmpty` and `nonEmpty`, on the `SyncVar` object. Then, implement
    a producer thread that transfers a range of numbers `0 until 15` to the consumer
    thread that prints them.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`SyncVar`对象在无效状态下会抛出异常，因此之前的练习中的`SyncVar`对象可能难以使用。在`SyncVar`对象上实现一对方法，`isEmpty`和`nonEmpty`。然后，实现一个生产者线程，将范围数字`0`到`15`传输到打印它们的消费者线程。
- en: 'Using the `isEmpty` and `nonEmpty` pair of methods from the previous exercise
    requires busy-waiting. Add the following methods to the `SyncVar` class:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前练习中的`isEmpty`和`nonEmpty`方法对需要忙等待。向`SyncVar`类添加以下方法：
- en: '[PRE40]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: These methods have similar semantics as before, but go into the waiting state
    instead of throwing an exception, and return once the `SyncVar` object is empty
    or non-empty, respectively.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法与之前具有相似的语义，但会进入等待状态而不是抛出异常，并在`SyncVar`对象为空或非空时分别返回。
- en: A `SyncVar` object can hold at most one value at a time. Implement a `SyncQueue`
    class, which has the same interface as the `SyncVar` class, but can hold at most
    `n` values. The `n` parameter is specified in the constructor of the `SyncQueue`
    class.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SyncVar`对象一次最多只能保存一个值。实现一个`SyncQueue`类，它具有与`SyncVar`类相同的接口，但最多可以保存`n`个值。`n`参数在`SyncQueue`类的构造函数中指定。'
- en: 'The `send` method in the *Deadlocks* section was used to transfer money between
    the two accounts. The `sendAll` method takes a set `accounts` of bank accounts
    and a `target` bank account, and transfers all the money from every account in
    `accounts` to the `target` bank account. The `sendAll` method has the following
    signature:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*死锁*部分的`send`方法被用来在两个账户之间转账。`sendAll`方法接受一个银行账户集合`accounts`和一个目标银行账户`target`，并将`accounts`中每个账户的所有资金转账到目标银行账户。`sendAll`方法具有以下签名：
- en: '[PRE41]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Implement the `sendAll` method and ensure that a deadlock cannot occur.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现`sendAll`方法并确保不会发生死锁。
- en: 'Recall the `asynchronous` method from the *Guarded blocks* section. This method
    stores the tasks in a **First In First Out** (**FIFO**) queue; before a submitted
    task is executed, all the previously submitted tasks need to be executed. In some
    cases, we want to assign priorities to tasks so that a high-priority task can
    execute as soon as it is submitted to the task pool. Implement a `PriorityTaskPool`
    class that has the `asynchronous` method with the following signature:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想一下来自*守卫块*部分的`异步`方法。这种方法将任务存储在一个**先进先出**（**FIFO**）队列中；在执行提交的任务之前，需要先执行所有之前提交的任务。在某些情况下，我们希望给任务分配优先级，以便高优先级任务可以在提交到任务池后立即执行。实现一个具有以下签名的`PriorityTaskPool`类：
- en: '[PRE42]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A single worker thread picks tasks submitted to the pool and executes them.
    Whenever the worker thread picks a new task from the pool for execution, that
    task must have the highest priority in the pool.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单个工作线程从池中选取提交的任务并执行它们。每当工作线程从池中选取一个新任务进行执行时，该任务必须在池中具有最高的优先级。
- en: Extend the `PriorityTaskPool` class from the previous exercise so that it supports
    any number of worker threads `p`. The parameter `p` is specified in the constructor
    of the `PriorityTaskPool` class.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展之前练习中的`PriorityTaskPool`类，使其支持任何数量的工作线程`p`。参数`p`在`PriorityTaskPool`类的构造函数中指定。
- en: 'Extend the `PriorityTaskPool` class from the previous exercise so that it supports
    the `shutdown` method:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展之前练习中的`PriorityTaskPool`类，使其支持`shutdown`方法：
- en: '[PRE43]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the `shutdown` method is called, all the tasks with the priorities greater
    than `important` must be completed, and the rest of the tasks must be discarded.
    The `important` integer parameter is specified in the constructor of the `PriorityTaskPool`
    class.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当调用`shutdown`方法时，所有优先级高于`important`的任务必须完成，其余任务必须被丢弃。`important`整数参数在`PriorityTaskPool`类的构造函数中指定。
- en: 'Implement a `ConcurrentBiMap` collection, which is a concurrent bidirectional
    map. The invariant is that every key is mapped to exactly one value, and vice
    versa. Operations must be atomic. The concurrent bidirectional map has the following
    interface:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`ConcurrentBiMap`集合，它是一个并发双向映射。不变量是每个键恰好映射到一个值，反之亦然。操作必须是原子的。并发双向映射具有以下接口：
- en: '[PRE44]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Make sure that your implementation prevents deadlocks from occurring in the
    map.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你的实现防止在映射中发生死锁。
- en: 'Add a `replace` method to the concurrent bidirectional map from the previous
    exercise. The method should atomically replace a key-value pair with another key-value
    pair:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`replace`方法添加到之前练习中的并发双向映射中。该方法应原子性地用一个键值对替换另一个键值对：
- en: '[PRE45]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Test the implementation of the concurrent bidirectional map from the earlier
    exercise by creating a test in which several threads concurrently insert millions
    of key-value pairs into the map. When all of them complete, another batch of threads
    must concurrently invert the entries in the map - for any key-value pair `(k1,
    k2)`, the thread should replace it with a key-value pair `(k2, k1)`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个测试来测试之前练习中并发双向映射的实现，测试中多个线程并发地向映射中插入数百万个键值对。当所有线程完成时，另一批线程必须并发地反转映射中的条目
    - 对于任何键值对`(k1, k2)`，线程应将其替换为键值对`(k2, k1)`。
- en: 'Implement a `cache` method, which converts any function into a memoized version
    of itself. The first time that the resulting function is called for any argument,
    it is called in the same way as the original function. However, the result is
    memoized, and subsequently invoking the resulting function with the same arguments
    must return the previously returned value:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`cache`方法，该方法将任何函数转换为它的记忆化版本。当结果函数第一次被任何参数调用时，它以与原始函数相同的方式被调用。然而，结果被记忆化，并且随后以相同参数调用结果函数必须返回之前返回的值：
- en: '[PRE46]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Make sure that your implementation works correctly when the resulting function
    is called simultaneously from multiple threads.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 确保当结果函数从多个线程同时调用时，你的实现能够正确工作。
