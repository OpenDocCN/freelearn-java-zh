- en: Conclusion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: I hope that all that we have learned in this book provides helpful insights
    into how to build modern, lightweight, business-oriented enterprise applications.
    Maybe this book could even dissolve some outdated best practices of the past.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书中我们所学的所有内容都能为如何构建现代、轻量级、面向业务的企业应用程序提供有价值的见解。也许这本书甚至能消除一些过时的最佳实践。
- en: We have seen how modern versions of Java EE fit into a new world of software
    development, embracing container technology, cloud platforms, automation, Continuous
    Delivery, and more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了现代版本的Java EE如何融入一个全新的软件开发世界，它拥抱了容器技术、云平台、自动化、持续交付以及更多。
- en: Motivations in enterprise development
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业开发中的动机
- en: As we have seen several times in this book, engineering teams should follow
    the right motivations when developing software. The main focus of enterprise systems
    should be on their business motivations. The domain and business use cases of
    applications need to be clear, before they can deliver value to their customers.
    At the end of the day, working software that accomplishes business functionality
    is what generates revenue.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中多次看到的，工程团队在开发软件时应遵循正确的动机。企业系统的主要焦点应该是其业务动机。在能够为顾客提供价值之前，应用程序的领域和业务用例需要明确。最终，能够完成业务功能的实际工作软件才是产生收入的关键。
- en: 'A helpful question that developers can ask themselves over time is: *Is what
    we''re doing helping to solve the business problem?*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以随着时间的推移问自己一个有用的问题：*我们正在做的事情是否有助于解决业务问题？*
- en: Software that aims to meet a customer's demands therefore mainly focuses on
    fulfilling business uses cases. Technology that fulfills a subordinate necessity,
    such as communication, persistence, or distribution, comes second. The chosen
    solutions should aim to solve the business demands first.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以满足客户需求为目的的软件因此主要关注满足业务用例。满足次要需求的技术，如通信、持久性或分发，则次之。所选解决方案应首先解决业务需求。
- en: Therefore, technology, programming languages and frameworks ideally support
    the implementation of use cases without too much overhead. The team of engineers
    is advised to choose technology that they are productive and familiar with, but
    that also fits this requirement.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，技术、编程语言和框架理想情况下应支持在不增加太多开销的情况下实现用例。建议工程师团队选择他们既高效又熟悉的、同时符合这一要求的技术。
- en: Cloud and Continuous Delivery
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云和持续交付
- en: We have seen the necessity of moving fast in a fast moving world. It's important
    to put emphasis on agility and reactiveness towards the customer's demands, the
    time-to-market, or better, *time-to-production*. The best features don't deliver
    value, until they are in the customer's hands.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在快速变化的世界中快速行动的必要性。重视敏捷性和对客户需求、上市时间或更好的*生产时间*的响应性非常重要。最好的功能只有在客户手中才能提供价值。
- en: It makes sense to use concepts and technology that help achieve this goal, such
    as Continuous Delivery, automation, infrastructure as code, and automated software
    tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有助于实现这一目标的概念和技术是有意义的，例如持续交付、自动化、基础设施即代码和自动软件测试。
- en: 'This is what represents the biggest benefit of modern environments and cloud
    technology: *the ability to move fast*. Application environments for new projects,
    features, or test scenarios, can be created in a matter of minutes, using well-defined
    specifications. In particular, infrastructure as code and container technology
    support these attempts. Software developers deliver the environment configuration
    together with the application code, contained in the project''s repository.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是现代环境和云技术最大的好处：*快速行动的能力*。使用明确定义的规范，可以在几分钟内创建新项目、功能或测试场景的应用程序环境。特别是，基础设施即代码和容器技术支持这些尝试。软件开发者将环境配置与应用程序代码一起交付，这些代码包含在项目的存储库中。
- en: Defining all contents of enterprise software thus becomes a responsibility of
    the whole engineering team. Developers, as well as operational engineers, are
    interested in shipping software that provides value to its users. The whole software
    team is accountable for achieving this goal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义企业软件的所有内容成为整个工程团队的责任。开发人员和运维工程师都希望推出对用户有价值的软件。整个软件团队对实现这一目标负有责任。
- en: This also includes the topic of software quality assurance. Delivering features
    with rapid pace is only possible if proper, automated quality verification mechanisms
    are in place. Tests that require human intervention and that don't run reliably
    or fast enough prevent fast processes and keep developers from doing more useful
    work. It's a necessity to invest effort in automated, sufficient, and reliable
    test cases that are built with maintainability and code quality in mind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这也包括软件质量保证的主题。只有当适当的、自动化的质量验证机制到位时，才能以快速的速度交付功能。需要人工干预且运行不可靠或不够快的测试会阻碍快速流程，并阻止开发者进行更有用的工作。投资于自动化、充分且可靠的测试用例，这些测试用例在构建时考虑到可维护性和代码质量，是必要的。
- en: Relevance of Java EE
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 的相关性
- en: We have seen how Java EE enables all this. The platform supports focusing on
    business demands by enabling developers to write code without setting too many
    constraints. Use cases can be designed and implemented by following the domain's
    demands first.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Java EE 如何实现这一切。该平台通过允许开发者编写代码而不设置太多约束来支持关注业务需求。可以通过首先遵循领域需求来设计和实现用例。
- en: The technology itself does not *want attention*. In the majority of cases, it's
    sufficient to annotate business logic which leads the application container to
    add the required technical necessities. The approaches of Java EE standards, such
    as JAX-RS, JPA, or JSON-B, accomplish the required technical integration with
    minimum effort required.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 技术本身并不需要**关注**。在大多数情况下，仅对业务逻辑进行注解就足够了，这会导致应用程序容器添加所需的技术必要性。Java EE 标准的方法，如 JAX-RS、JPA
    或 JSON-B，以最小的努力完成所需的技术集成。
- en: The Java EE platform especially enables engineers to seamlessly integrate multiple
    standards without configuration work. The JSR specifications that are written
    with the principles of Java EE in mind, make this possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 平台特别使得工程师能够无缝集成多个标准，而无需进行配置工作。考虑到 Java EE 原则编写的 JSR 规范使得这一点成为可能。
- en: Modern Java EE has to be seen differently to how it was in the old days of J2EE.
    In fact, the programming model and runtimes have little to do with J2EE.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Java EE必须与J2EE的旧时代有所不同。实际上，编程模型和运行时与J2EE几乎没有关系。
- en: With the backwards-compatible nature of the platform, outdated approaches are
    still possible, but the technology has advanced a lot since then. Programming
    models and design patterns have been revisited and vastly simplified. In particular,
    the restrictions of past patterns in implementing hierarchies of technology-motivated
    interfaces, and superclasses, are gone. Developers are able to focus on business
    domains, not on the technology.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于平台具有向后兼容的特性，过时的方法仍然可行，但自那时起技术已经取得了很大的进步。编程模型和设计模式已经被重新审视并大大简化。特别是，过去在实现由技术驱动的接口层次和超类时的模式限制已经消失。开发者能够专注于业务领域，而不是技术。
- en: The nature of the Java EE standards allows companies to realize vendor-independent
    applications. This avoids vendor lock-in on the technology-side. Developers are
    also not exclusively trained for vendor-specific technologies. We have seen quite
    a few cases of teams that were solely familiar with vendors that became obsolete.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 标准的性质允许公司实现供应商独立的应用程序。这避免了在技术方面的供应商锁定。开发者也不专门接受针对特定供应商技术的培训。我们已经看到了很多团队，他们只熟悉已经过时的供应商。
- en: Java EE technology is not only used on the server-side. Standards such as JAX-RS,
    JSON-P, or CDI provide valuable benefits for Java SE applications as well. It
    makes sense to realize certain functionalities, such as HTTP clients, with standards
    technology that developers are familiar with.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 技术不仅用于服务器端。例如 JAX-RS、JSON-P 或 CDI 这样的标准为 Java SE 应用程序也提供了有价值的益处。使用开发者熟悉的标准化技术实现某些功能，如
    HTTP 客户端，是有意义的。
- en: API updates introduced in Java EE 8
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java EE 8 中引入的 API 更新
- en: This book focuses on enterprise applications with Java EE 8.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本书专注于使用 Java EE 8 的企业应用程序。
- en: There have been certain standards that have been updated in the course of this
    version. The following are the most important new features and standards.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的过程中，某些标准已经得到了更新。以下是最重要的新特性和标准。
- en: CDI 2.0
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CDI 2.0
- en: Since Java EE 8 and CDI 2.0, events cannot only be handled synchronously. As
    we have seen previously in this book, CDI natively supports handling events asynchronously.
    In fact, this was only possible before if the event observer method was a business
    method of an EJB, annotated with `@Asynchronous`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java EE 8和CDI 2.0以来，事件不仅可以通过同步方式处理。正如我们在本书中之前看到的，CDI原生支持异步处理事件。实际上，如果事件观察者方法是EJB的业务方法，并注解为`@Asynchronous`，在此之前这是唯一可行的方法。
- en: In order to emit and handle asynchronous CDI events, the publisher side uses
    the `fireAsync` method. The observer method parameter is annotated with `@ObservesAsync`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发射和处理异步CDI事件，发布方使用`fireAsync`方法。观察者方法参数被注解为`@ObservesAsync`。
- en: 'Another new event functionality the advent of CDI 2.0 included is the possibility
    to order event observers. Therefore, the `@Priority` annotation, which is well-known
    within the Java EE platform, is specified at the event observer method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 2.0引入的另一个新事件功能是能够对事件观察者进行排序。因此，在事件观察者方法中指定了Java EE平台中广为人知的`@Priority`注解：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This approach guarantees that the event observers are called in the specified
    order, with lower priority numbers first. Developers should consider whether the
    situation violates loose coupling and the single point of responsibility principle,
    by needing to order the event handlers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法保证了事件观察者按照指定的顺序被调用，优先级较低的先调用。开发者应该考虑是否需要排序事件处理器会违反松耦合和单一责任原则。
- en: The biggest feature of CDI 2.0 was the integration outside of an enterprise
    container, providing the possibility to use CDI in Java SE applications. The idea
    is that Java SE applications can also use the features of a sophisticated dependency
    injection standard. This aims to increase the acceptance of CDI outside of the
    Java EE world.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CDI 2.0最大的特点是集成到企业容器之外，提供了在Java SE应用程序中使用CDI的可能性。这个想法是Java SE应用程序也可以使用复杂的依赖注入标准的特性。这旨在增加CDI在Java
    EE世界之外的可接受度。
- en: JAX-RS 2.1
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAX-RS 2.1
- en: Version 2.1 of JAX-RS mainly targeted reactive clients, SSE, and better integration
    into standards such as JSON-B. Besides these, some small improvements have been
    added.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 2.1的2.1版本主要针对反应式客户端、SSE以及更好地集成到JSON-B等标准。除此之外，还增加了一些小的改进。
- en: Reactive programming is used more and more, and, in particular, the client receives
    new, reactive functionality to make HTTP calls and directly returning so-called
    reactive types. An example for such a type is the `CompletionStage` type. This
    type is supported natively; other types and libraries can be added via extensions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程越来越被广泛使用，特别是客户端获得了新的反应式功能来执行HTTP调用并直接返回所谓的反应式类型。这种类型的一个例子是`CompletionStage`类型。这个类型是原生支持的；其他类型和库可以通过扩展添加。
- en: In order to make reactive calls, the `rx()` method of the `Invocation.Builder`
    is used.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行反应式调用，使用`Invocation.Builder`的`rx()`方法。
- en: As also shown in this book, JAX-RS 2.1 supports SSE, both on the client and
    on the server side. The SSE standard represents a lightweight, one-way messaging
    protocol that uses plain text messages over HTTP.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中所示，JAX-RS 2.1在客户端和服务器端都支持SSE。SSE标准代表了一种轻量级、单向的消息协议，它使用HTTP上的纯文本消息。
- en: In order to match the usual approach of the Java EE platform, the JSON-B standard
    which has been added in Java EE 8 is seamlessly integrated into JAX-RS. This means
    that, similarly to JAXB, Java types that are used as request or response bodies,
    respectively, are implicitly mapped to JSON.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Java EE平台的传统方法相匹配，Java EE 8中添加的JSON-B标准被无缝集成到JAX-RS中。这意味着，类似于JAXB，用作请求或响应体的Java类型分别隐式映射到JSON。
- en: Similarly, the new features that are part of JSON-P 1.1 and Bean Validation
    2.0 are included in JAX-RS, as well. This is possible since the specifications
    forward the specific functionality to the corresponding standards.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，JSON-P 1.1和Bean Validation 2.0的新特性也被包含在JAX-RS中。这是可能的，因为规范将特定功能转发到相应的标准。
- en: A smaller update that was incorporated into JAX-RS was the inclusion of the
    `@PATCH` annotation for the HTTP method of the same name. Although support of
    HTTP methods other than the provided ones was possible in JAX-RS before, it simplifies
    the usage for developers who require this feature.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 被整合到JAX-RS中的较小更新包括添加了与同名的HTTP方法的`@PATCH`注解。尽管在JAX-RS之前已经可以支持提供的HTTP方法之外的HTTP方法，但它简化了需要此功能的开发者的使用。
- en: Another small but indeed helpful improvement was to include standardized HTTP
    timeout methods on the JAX-RS client. The builder methods `connectTimeout` and
    `readTimeout` handle configured timeouts. A lot of projects require this configuration,
    which previously resulted in including vendor-specific features.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个虽小但确实有用的改进是，在 JAX-RS 客户端中包含了标准化的 HTTP 超时方法。`connectTimeout` 和 `readTimeout`
    构建方法处理配置的超时。许多项目都需要这种配置，这以前导致了包含供应商特定的功能。
- en: We have seen the implementation of these features in [Chapter 3](329094a0-f41b-4ad1-b05e-cd52c4bb9e42.xhtml),
    *Implementing Modern Java Enterprise Applications*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 3 章](329094a0-f41b-4ad1-b05e-cd52c4bb9e42.xhtml)，《实现现代 Java 企业应用程序》中看到了这些功能的实现。
- en: JSON-B 1.0
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-B 1.0
- en: The JSON-B is a new standard that maps Java types to and from JSON structures,
    respectively. Similarly to JAXB for XML, it provides functionality to declaratively
    map objects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-B 是一种新的标准，它将 Java 类型映射到 JSON 结构，反之亦然。类似于用于 XML 的 JAXB，它提供了声明式映射对象的功能。
- en: The biggest advantage of this standard within the Java EE ecosystem is that
    applications don't need to rely on vendor-specific implementations anymore. JSON
    mapping frameworks have typically prevented enterprise applications to be built
    in a portable way. They increase the risk of breaking runtime dependencies with
    existing framework versions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 生态系统内，该标准的最大优势是应用程序不再需要依赖特定的供应商实现。通常，JSON 映射框架阻止企业应用程序以可移植的方式构建。它们增加了与现有框架版本断开运行时依赖的风险。
- en: JSON-B solves this issue by providing standardized JSON mapping. Shipping custom
    mapping frameworks such as Jackson or Johnzon is not required anymore.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JSON-B 通过提供标准化的 JSON 映射来解决此问题。不再需要打包自定义映射框架，如 Jackson 或 Johnzon。
- en: JSON-P 1.1
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON-P 1.1
- en: JSON-P 1.0, which was introduced in Java EE 7, shipped a powerful feature to
    programmatically create and read JSON structures. The version 1.1 mainly included
    support for common JSON standards.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 7 中引入的 JSON-P 1.0，提供了一个强大的功能，可以编程创建和读取 JSON 结构。版本 1.1 主要包括对常见 JSON
    标准的支持。
- en: One of these IETF standards is **JSON Pointer** (RFC 6901). It defines a syntax
    to query JSON structures and values. By using pointers such as `"/0/user/address"`,
    JSON values are referenced, similarly to **XPath** in the XML world.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 IETF 标准之一是 **JSON Pointer**（RFC 6901）。它定义了一种查询 JSON 结构和值的语法。通过使用指针，例如 `"/0/user/address"`，JSON
    值被引用，类似于 XML 世界中的 **XPath**。
- en: This feature is included in the `JsonPointer` type, that is created via the
    `Json.createPointer()` method, similarly to the existing JSON-P API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能包含在通过 `Json.createPointer()` 方法创建的 `JsonPointer` 类型中，类似于现有的 JSON-P API。
- en: Another, newly-supported standard is **JSON Patch** (RFC 6902). RFC 6902 defines
    so-called patches and modification methods that are applied to existing JSON structures.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新支持的标准是 **JSON Patch**（RFC 6902）。RFC 6902 定义了所谓的补丁和修改方法，这些方法应用于现有的 JSON 结构。
- en: JSON 1.1 supports creating JSON patches via `Json.createPatch` or `Json.createPatchBuilder`,
    respectively. The corresponding JSON-P type is `JsonPatch`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 1.1 支持通过 `Json.createPatch` 或 `Json.createPatchBuilder` 分别创建 JSON 补丁。相应的
    JSON-P 类型是 `JsonPatch`。
- en: The third supported IETF standard is **JSON Merge Patch** (RFC 7386). This standard
    merges existing JSON structures to create new structures. JSON-P supports creating
    Merge Patches via `Json.createMergeDiff` or `Json.createMergePatch`, respectively,
    that result in the `JsonMergePatch`type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个支持的 IETF 标准是 **JSON Merge Patch**（RFC 7386）。该标准通过合并现有的 JSON 结构来创建新的结构。JSON-P
    通过 `Json.createMergeDiff` 或 `Json.createMergePatch` 分别支持创建合并补丁，结果生成 `JsonMergePatch`
    类型。
- en: Besides these supported IETF standards, JSON-P 1.1 includes a few smaller features
    that simplify the API usage. One example is the support of Java SE 8 streams via
    pre-defined stream collectors, such as the `JsonCollectors.toJsonArray()` method.
    Another small improvement enables the creation of JSON-P values types from Java
    strings and primitives, via `Json.createValue`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些支持的 IETF 标准，JSON-P 1.1 还包括一些简化 API 使用的较小功能。一个例子是通过预定义的流收集器，如 `JsonCollectors.toJsonArray()`
    方法，支持 Java SE 8 流。另一个小的改进是，通过 `Json.createValue`，可以从 Java 字符串和原始数据类型创建 JSON-P
    值类型。
- en: Bean Validation 2.0
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean Validation 2.0
- en: Java EE 8 updates the Bean Validation version to 2.0\. Besides including new,
    pre-defined constraints, it mainly targets support for Java SE 8.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 8 将 Bean Validation 版本更新到 2.0。除了包括新的预定义约束外，它主要针对对 Java SE 8 的支持。
- en: The Java SE 8 support includes multiple, differently-configured validation constraint
    annotations. Types of the Java 8 Date and Time API are now supported; for example,
    via usage such as `@Past LocalDate date`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE 8 的支持包括多个不同配置的验证约束注解。Java 8 日期和时间 API 的类型现在得到支持；例如，通过使用 `@Past LocalDate
    date`。
- en: Values that are contained in container types can also be validated separately,
    via parameterized type annotations. Examples for this are `Map<String, @Valid
    Customer> customers`, `List<@NotNull String> strings`, and `Optional<@NotNull
    String> getResult()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 容器类型中包含的值也可以通过参数化类型注解单独验证。例如，`Map<String, @Valid Customer> customers`、`List<@NotNull
    String> strings` 和 `Optional<@NotNull String> getResult()` 就是这样的例子。
- en: Bean Validation 2.0 includes new pre-defined constraints. For example, `@Email`
    validates email addresses. `@Negative` and `@Positive` verify numeric values.
    `@NotEmpty` ensures that collections, maps, arrays, or strings are not empty or
    `null`. `@NotBlank` validates that strings do not solely consist of whitespace.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation 2.0 包含了新的预定义约束。例如，`@Email` 验证电子邮件地址。`@Negative` 和 `@Positive`
    验证数值。`@NotEmpty` 确保集合、映射、数组或字符串不为空或 `null`。`@NotBlank` 验证字符串不单纯由空白字符组成。
- en: These constraints are a helpful default feature that avoids potentially defining
    this manually.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束是一个有用的默认功能，可以避免手动定义这些约束。
- en: JPA 2.2
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JPA 2.2
- en: Java EE 8 updates the JPA specification to version 2.2\. This version mainly
    targets Java SE 8 features.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 8 更新了 JPA 规范到版本 2.2。这个版本主要针对 Java SE 8 的特性。
- en: Similar to Bean Validation, the Java SE 8 support includes the Date and Time
    API. Types such as `LocalDate` or `LocalDateTime` are now natively supported for
    entity properties.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Bean Validation 类似，Java SE 8 的支持包括日期和时间 API。例如，`LocalDate` 或 `LocalDateTime`
    类型现在原生支持实体属性。
- en: 'Version 2.2 makes it possible to return a query result, not only as `List<T>`
    but `Stream<T>`, using the `getResultStream()` method as shown in the following
    code snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 2.2 使得可以使用 `getResultStream()` 方法返回查询结果，不仅作为 `List<T>`，还可以作为 `Stream<T>`。以下代码片段展示了这一点：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What JPA 2.2 also finally added is support to inject managed beans into attribute
    converters using CDI's `@Inject`. This increases the use and number of scenarios
    of custom attribute converters. Similar to other standards such as JSON-B, better
    CDI integration encourages reuse of Java EE components.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2.2 最终添加了对使用 CDI 的 `@Inject` 将管理 Bean 注入属性转换器的支持。这增加了自定义属性转换器的使用和场景数量。类似于
    JSON-B 等其他标准，更好的 CDI 集成鼓励 Java EE 组件的重用。
- en: Also version 2.2 adds repeatable annotations, such as `@JoinColumn`, `@NamedQuery`,
    or `@NamedEntityGraph`. Since Java SE 8 allows to repeat the same annotation type
    multiple times, developers are no longer required to use the corresponding group
    annotations, such as `@JoinColumns`, for these functionalities.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，版本 2.2 还增加了可重复注解，例如 `@JoinColumn`、`@NamedQuery` 或 `@NamedEntityGraph`。由于
    Java SE 8 允许重复相同的注解类型多次，因此开发者不再需要使用相应的分组注解，如 `@JoinColumns` 来实现这些功能。
- en: Security 1.0
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性 1.0
- en: As seen in the last chapter, Security 1.0 aims to simplify the integration of
    security concerns into Java EE applications. Developers are therefore encouraged
    to use powerful functionalities such as JASPIC.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一章所述，Security 1.0 旨在简化安全关注点集成到 Java EE 应用程序中。因此，鼓励开发者使用诸如 JASPIC 等强大的功能。
- en: We have seen the features and usage of HTTP authentication mechanisms, identity
    stores, and security contexts in the previous chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中看到了 HTTP 身份验证机制、身份存储和安全上下文的功能和用法。
- en: Servlet 4.0
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Servlet 4.0
- en: As of writing this book, HTTP/1.1 is the primarily used version of HTTP. HTTP/2
    targets the shortcomings of HTTP performance of web applications in the past.
    In particular, requesting several resources of a web based system could lead to
    suboptimal performance due to the numerous connections involved. Version 2 of
    HTTP aims to lower latency and maximize throughput by multiplexing, pipelining,
    compressing headers, and Server Push.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，HTTP/1.1 是主要使用的 HTTP 版本。HTTP/2 针对过去 Web 应用程序 HTTP 性能的不足。特别是，请求基于 Web
    系统的多个资源可能会由于涉及的大量连接而导致性能不佳。HTTP 2 的第二个版本通过多路复用、流水线、压缩头和服务器推送来降低延迟并最大化吞吐量。
- en: Most of the changes in HTTP/2 do not affect the engineers' work compared to
    1.1\. The servlet container deals with HTTP concerns under the hood. The exception
    to this is the Server Push feature.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与 1.1 相比，HTTP/2 的大多数更改不会影响工程师的工作。Servlet 容器在底层处理 HTTP 关注点。这一例外是服务器推送功能。
- en: Server Push works in such a way that the server directly sends HTTP responses
    of resources related to a client-requested resource, following the assumption
    that the client would need these resources as well. It allows the server to send
    resources which were not explicitly requested by a client. This is a performance
    optimization technique that in web pages mainly concerns style sheets, JavaScript
    code, and other assets.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器推送（Server Push）工作原理是服务器直接发送与客户端请求的资源相关的HTTP响应，基于这样的假设：客户端也可能需要这些资源。这允许服务器发送客户端未明确请求的资源。这是一种性能优化技术，在网页中主要涉及样式表、JavaScript代码和其他资产。
- en: The Servlet API supports Server Push messages by using the `PushBuilder` type
    that is instantiated with the `HttpServletRequest.newPushBuilder()` method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet API通过使用`PushBuilder`类型支持服务器推送消息，该类型是通过`HttpServletRequest.newPushBuilder()`方法实例化的。
- en: JSF 2.3
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 2.3
- en: Java Server Faces are a traditional way of building server-centric, component-based
    HTML UIs. Java EE 8 ships with the updated JSF version 2.3.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java服务器端面（Java Server Faces）是构建以服务器为中心、基于组件的HTML UI的传统方式。Java EE 8附带更新的JSF版本2.3。
- en: The main improvements of the version update include better CDI, WebSocket and
    AJAX integration, class-level Bean Validation, as well as support for Java SE
    8.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 版本更新的主要改进包括更好的CDI、WebSocket和AJAX集成、类级别的Bean验证，以及Java SE 8的支持。
- en: Since the focus of this book is clearly on the backend-side, it doesn't include
    much about JSF.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的重点显然在后端，因此它不包括太多关于JSF的内容。
- en: JCP and participation
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JCP和参与
- en: The **Java Community Process** (**JCP**) defines the standards that make up
    the Java SE and EE platforms, including the Java EE umbrella standard itself.
    The individual standards are defined as **Java Specification Requests** (**JSR**),
    each forming so-called **Expert Groups**, consisting of experts and companies
    involved in enterprise software.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java社区进程**（**JCP**）定义了构成Java SE和EE平台的标准，包括Java EE总标准本身。这些单独的标准被定义为**Java规范请求**（**JSR**），每个形成所谓的**专家小组**，由参与企业软件的专家和公司组成。'
- en: The idea is to standardize technology that has proven itself well in real-world
    projects. The experience of companies and individuals from these real-world projects
    is brought together to form vendor-independent Java enterprise standards.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是标准化在现实世界项目中证明效果良好的技术。来自这些现实世界项目的公司和个人的经验被汇集起来，形成供应商独立的Java企业标准。
- en: It's highly advisable for both companies and individuals to participate in the
    JCP. It provides the ability to form the standards and the future of Java technology
    as well as to gain knowledge in this technology. The open processes of the JCP
    enable developers to get insight about how the future versions of Java EE will
    look.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于公司和个人来说，都强烈建议参与JCP。它提供了形成标准和Java技术未来的能力，以及在这个技术中获得知识。JCP的开放流程使开发者能够了解Java
    EE未来版本将如何呈现。
- en: Individuals and companies can also follow the standardization processes, even
    if they don't participate in the JCP. It's possible to review working states of
    the standards and provide feedback to the Expert Groups.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 个人和公司也可以遵循标准化流程，即使他们没有参与JCP。他们可以审查标准的草案状态并提供对专家小组的反馈。
- en: The Expert Groups indeed welcome constructive feedback while the specifications
    are being formed. It's very beneficial to receive feedback and experience from
    real-world projects and helps in crafting standards that suit the needs of the
    industry better.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 专家小组确实欢迎在形成规范时收到建设性的反馈。从现实世界项目中获得反馈和经验对于制定更适合行业需求的标准非常有帮助。
- en: I also was involved in shaping Java EE 8, being part of two Expert Groups, namely
    JAX-RS 2.1 and JSON-P 1.1\. I personally gained a lot of knowledge as part of
    this engagement and can encourage enterprise Java developers to look into the
    processes within the JCP.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我也参与了Java EE 8的塑造，是两个专家小组的成员，即JAX-RS 2.1和JSON-P 1.1。在这个过程中，我获得了大量的知识，并鼓励企业Java开发者关注JCP中的流程。
- en: MicroProfile
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile
- en: The motivation behind the MicroProfile initiative was to build upon the Java
    EE standards and create smaller-scale profiles that target microservice architectures
    as well as experiment with features independent from standardization. Multiple
    application server vendors have been involved in this initiative that forms vendor-agreed
    de facto standards.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile倡议背后的动机是在Java EE标准的基础上构建，创建较小规模的配置文件，针对微服务架构，并尝试与标准化无关的功能。多个应用服务器供应商参与了这一倡议，形成了供应商同意的事实标准。
- en: Server applications that support MicroProfile pride the opportunity to run Java
    EE applications that only require a smaller set of standards, in the first version
    this includes JAX-RS, CDI, and JSON-P. Similarly, application server vendors provide
    the ability to strip down runtime to a specific required set of standards.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 支持MicroProfile的服务器应用程序为运行仅需要较小一组标准的Java EE应用程序提供了机会，在第一个版本中这包括JAX-RS、CDI和JSON-P。同样，应用服务器供应商提供了将运行时精简到特定所需标准集的能力。
- en: The advantage of these approaches is that they don't add dependencies to the
    enterprise project, rather than just optimizes the runtime. Developers still write
    their applications using the same Java EE standard technology.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的优势在于它们不会向企业项目添加依赖，而是仅仅优化了运行时。开发者仍然使用相同的Java EE标准技术编写他们的应用程序。
- en: Eclipse Enterprise for Java
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse Enterprise for Java
- en: In September 2017, just before publishing this book, Oracle, the steward of
    Java EE and the JCP, announced to move the Java EE platform and its standards
    to an Open Source Foundation, what emerged in **Eclipse Enterprise for Java**
    (**EE4J**). The plans aim to lower the barrier for companies and developers who
    would like to contribute and to ultimately enable to a more open technology.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在2017年9月，就在出版这本书之前，Java EE和JCP的监护人Oracle宣布将Java EE平台及其标准转移到开源基金会，这产生了**Eclipse
    Enterprise for Java**（**EE4J**）。这些计划旨在降低希望贡献的公司和开发者的门槛，并最终使技术更加开放。
- en: However the realization of these plans will look, it's important to mention
    that the plans include the preservation of the nature of the platform. The approaches
    and techniques presented in this book will hold true in the future of enterprise
    Java.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这些计划的实现看起来如何，重要的是要提到这些计划包括保留平台的本性。本书中提出的方法和技巧将在企业Java的未来中依然适用。
- en: I can repeat my message of what I have said in the past about participation
    within the JCP. However the manifestation of the standardization process of Enterprise
    Java looks, I encourage engineers and companies to have a look into Eclipse Enterprise
    for Java and to participate in defining enterprise standards. The collective knowledge
    and real world experience helped shaping the standards of Java EE, and will help
    shaping Enterprise Java in the future.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以重复我过去关于JCP内参与的信息。然而，企业Java标准化过程的体现，我鼓励工程师和公司关注Eclipse Enterprise for Java，并参与定义企业标准。集体知识和实际经验有助于塑造Java
    EE的标准，并将有助于未来塑造企业Java。
