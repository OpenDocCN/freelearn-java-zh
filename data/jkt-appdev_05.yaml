- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Microservices Development with Jakarta EE
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jakarta EE进行微服务开发
- en: Microservices is an architectural style in which code is deployed in small,
    granular modules. The microservices architecture reduces coupling and increases
    cohesion. Typically, microservices are implemented as RESTful web services, using
    JSON to pass data to one another, by invoking HTTP methods (`GET`, `POST`, `PUT`
    or `DELETE`) on each other. Since communication between microservices is done
    via HTTP methods, microservices written in different programming languages can
    interact with each other. In this chapter, we will cover how we can use Jakarta
    EE to implement microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种将代码部署在小而粒度化的模块中的架构风格。微服务架构减少了耦合并增加了内聚。通常，微服务被实现为RESTful Web服务，通过在彼此上调用HTTP方法（`GET`、`POST`、`PUT`或`DELETE`）来相互传递数据，使用JSON进行数据交换。由于微服务之间的通信是通过HTTP方法完成的，因此用不同编程语言编写的微服务可以相互交互。在本章中，我们将介绍如何使用Jakarta
    EE来实现微服务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: An introduction to microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务简介
- en: Microservices and Jakarta EE
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务和Jakarta EE
- en: Developing microservices using Jakarta EE
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jakarta EE开发微服务
- en: Note
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Example source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch05_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch05_src).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch05_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch05_src)。
- en: An introduction to microservices
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: Architecting applications as a series of microservices offers some advantages
    over traditionally designed applications, as well as some disadvantages. When
    considering a microservices architecture for our applications, we must carefully
    weigh the advantages and disadvantages before we make our decision.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序设计为一系列微服务，与传统设计的应用程序相比，具有一些优势以及一些缺点。在考虑为我们的应用程序采用微服务架构时，我们必须在做出决定之前仔细权衡利弊。
- en: The advantages of a microservices architecture
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势
- en: 'Developing an application as a series of microservices offers several advantages
    over traditionally designed applications, such as the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序作为一系列微服务开发具有比传统设计应用程序更多的优势，如下所示：
- en: '**Smaller code bases**: Since each microservice is a small, standalone unit,
    code bases for microservices tend to be smaller and easier to manage than traditionally
    designed applications.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的代码库**：由于每个微服务都是一个小的、独立的单元，因此微服务的代码库通常比传统设计的应用程序更小，更容易管理。'
- en: '**Microservices encourage good coding practices**: A microservices architecture
    encourages loose coupling and high cohesion.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务鼓励良好的编码实践**：微服务架构鼓励松耦合和高内聚。'
- en: '**Greater resilience**: Traditionally designed applications act as a single
    point of failure; if any component of an application is down or unavailable, the
    whole application is unavailable. Since microservices are independent modules,
    one component (i.e., one microservice) being down does not necessarily make the
    whole application unavailable.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的弹性**：传统设计的应用程序作为一个单一故障点；如果应用程序的任何组件出现故障或不可用，整个应用程序将不可用。由于微服务是独立的模块，一个组件（即一个微服务）的故障并不一定导致整个应用程序不可用。'
- en: '**Scalability**: Since applications developed as a series of microservices
    are composed of a number of different modules, scalability becomes easier. We
    can focus only on those services that may need scaling, without having to waste
    effort on parts of an application that do not need to be scaled.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：由于作为一系列微服务开发的应用程序由多个不同的模块组成，因此可伸缩性变得更容易。我们可以只关注可能需要扩展的服务，而无需在不需要扩展的应用程序部分上浪费精力。'
- en: The disadvantages of a microservices architecture
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构的缺点
- en: 'Developing and deploying applications adhering to microservices architecture
    comes with its own set of challenges, regardless of what programming language
    or application framework is used to develop an application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和部署遵循微服务架构的应用程序会带来一系列挑战，无论使用什么编程语言或应用程序框架来开发应用程序：
- en: '**Additional operational and tooling overhead**: Each microservice implementation
    would require its own (possibly automated) deployment, monitoring systems, and
    so on.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外的操作和工具开销**：每个微服务实现都需要自己的（可能是自动化的）部署、监控系统等。'
- en: '**Debugging microservices may be more involved than debugging traditional enterprise
    applications**: If an end user reports a problem with their application and the
    application utilizes multiple microservices internally, it is not always clear
    which of the microservices may be the culprit. This may be especially difficult
    if the microservices involved are developed by different teams with different
    priorities.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试微服务可能比调试传统企业应用程序更复杂**：如果最终用户报告了应用程序的问题，并且该应用程序内部使用了多个微服务，那么并不总是清楚哪个微服务可能是问题的根源。如果涉及的微服务是由不同团队开发且优先级不同的，这可能尤其困难。'
- en: '**Distributed transactions may be a challenge**: Rolling back a transaction
    involving several microservices may be hard. A common approach to work around
    this is to isolate microservices as much as possible, treat them as single units,
    and then have local transaction management for each microservice. For example,
    if microservice A invokes microservice B and there is a problem with the latter,
    a local transaction in microservice B would roll back. Then, it would return a
    500 HTTP status code (server error) to microservice A. It could then use this
    HTTP status code as a signal to initiate a compensating transaction, restoring
    the system to its initial state.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式事务可能是一个挑战**：涉及多个微服务的回滚事务可能很难。一种常见的解决方案是尽可能地将微服务隔离，将它们视为单一单元，并为每个微服务提供本地事务管理。例如，如果微服务A调用微服务B，并且后者存在问题，微服务B的本地事务将回滚。然后，它将返回500
    HTTP状态码（服务器错误）给微服务A。微服务A可以使用这个HTTP状态码作为信号来启动补偿事务，将系统恢复到初始状态。'
- en: '**Network latency**: Since microservices rely on HTTP method calls for communication,
    performance may suffer due to network latency.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络延迟**：由于微服务依赖于HTTP方法调用进行通信，性能可能会因为网络延迟而受到影响。'
- en: '**The potential for complex interdependencies**: While independent microservices
    tend to be simple, they are dependent on each other. A microservices architecture
    can potentially create a complex dependency graph. This situation can be worrisome
    if some of our services depend on microservices developed by other teams that
    may have conflicting priorities (i.e., we find a bug in their microservice, but
    fixing the bug may not be a priority for the other team).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**潜在的复杂依赖性**：虽然独立的微服务往往很简单，但它们相互依赖。微服务架构可能创建一个复杂的依赖图。如果我们的某些服务依赖于其他团队开发的微服务，而这些微服务的优先级可能存在冲突（例如，我们在他们的微服务中找到一个错误，但修复这个错误可能不是其他团队的优先事项），这种情况可能会令人担忧。'
- en: '**Susceptibility to the fallacies of distributed computing**: Applications
    developed following a microservices architecture may make some incorrect assumptions,
    such as network reliability, zero latency, and infinite bandwidth.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易受分布式计算谬误的影响**：遵循微服务架构开发的应用程序可能会做出一些不正确的假设，例如网络可靠性、零延迟和无限带宽。'
- en: Now that we’ve talked about microservices in general, we’ll focus our attention
    on how Jakarta EE can be leveraged to develop applications adhering to a microservices
    architecture.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了微服务的一般概念，接下来我们将关注如何利用Jakarta EE来开发遵循微服务架构的应用程序。
- en: Microservices and Jakarta EE
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务和Jakarta EE
- en: Some may think that Jakarta EE is “too heavyweight” for microservices development.
    This is simply not the case. Because of this misconception, some may also think
    that Jakarta EE may not be suitable for a microservices architecture when, in
    reality, Jakarta EE fits microservices development well. Some time ago, Java EE
    applications were deployed to a “heavyweight” application server. Nowadays, most
    Jakarta EE application server vendors offer lightweight application servers that
    use very little memory or disk space. Some examples of these Jakarta EE-compliant
    lightweight application servers include IBM’s Open Liberty, Red Hat’s WildFly
    Swarm, Apache TomEE, and Payara Micro. Jakarta EE 10 introduced the core profile,
    which is ideal for microservices development using Jakarta EE.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能认为Jakarta EE对于微服务开发来说“太重了”。这根本不是事实。由于这种误解，有些人也可能认为Jakarta EE可能不适合微服务架构，而实际上，Jakarta
    EE非常适合微服务开发。在不久前，Java EE应用程序被部署到“重量级”的应用服务器上。如今，大多数Jakarta EE应用服务器供应商都提供轻量级的应用服务器，它们使用的内存或磁盘空间非常少。这些Jakarta
    EE兼容的轻量级应用服务器的例子包括IBM的Open Liberty、Red Hat的WildFly Swarm、Apache TomEE和Payara Micro。Jakarta
    EE 10引入了核心配置文件，这对于使用Jakarta EE进行微服务开发来说非常理想。
- en: Developing microservices with the Jakarta EE core profile involves writing standard
    Jakarta EE applications, while limiting yourself to the subset of Jakarta EE APIs
    supported by the core profile, namely Jakarta REST, JSON-P, JSON-B, and CDI. If
    interacting with a relational database, we may need transaction support and likely
    would like an object-relational mapping API, such as Jakarta Persistence. To interact
    with a relational database, we would need the Jakarta EE web profile, as the core
    profile does not include Jakarta Persistence or transaction support. Only microservices
    needing to directly interact with a relational database would need the web profile;
    other microservices can be developed against the core profile.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jakarta EE核心配置文件开发微服务涉及编写标准的Jakarta EE应用程序，同时将自己限制在核心配置文件支持的Jakarta EE API子集内，即Jakarta
    REST、JSON-P、JSON-B和CDI。如果与关系型数据库交互，我们可能需要事务支持，并且可能希望有一个对象关系映射API，例如Jakarta Persistence。为了与关系型数据库交互，我们需要Jakarta
    EE网络配置文件，因为核心配置文件不包括Jakarta Persistence或事务支持。只有需要直接与关系型数据库交互的微服务才需要网络配置文件；其他微服务可以针对核心配置文件进行开发。
- en: Jakarta EE developers can leverage their existing expertise when developing
    microservices. When developing microservices, the main requirement is the development
    of RESTful web services, which can be easily implemented using Jakarta REST. These
    RESTful web services would be packaged in a WAR file and deployed to a lightweight
    Jakarta EE runtime.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发微服务时，Jakarta EE开发者可以利用他们现有的专业知识。在开发微服务时，主要要求是开发RESTful网络服务，这可以通过使用Jakarta
    REST轻松实现。这些RESTful网络服务将被打包在一个WAR文件中，并部署到轻量级的Jakarta EE运行时环境中。
- en: When using modern, embeddable Jakarta EE implementations, usually only one application
    is deployed to each instance of the application server, and, in some cases, the
    “tables are turned” so to speak, by making the Jakarta EE implementation just
    a library that the application uses as a dependency. With these modern Jakarta
    EE implementations, several instances of the Jakarta EE runtime are often deployed
    to a server, making modern Jakarta EE very suitable for microservices development.
    Many modern, lightweight Jakarta EE application servers are embeddable, allowing
    the creation of an “uber jar,” which includes both the application code and the
    application server libraries. This “uber jar” is then transferred to the server
    and run as a standalone application. In addition to “uber jars,” modern application
    servers can be added to a container image (such as Docker). Then, our application
    can be deployed as a thin WAR, typically only a few kilobytes in size; this approach
    has the advantage of very fast deployments, usually under two seconds.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用现代、可嵌入的Jakarta EE实现时，通常每个应用服务器实例只部署一个应用程序，在某些情况下，可以说“形势逆转”，将Jakarta EE实现仅仅作为一个库，应用程序将其作为依赖项使用。这些现代的Jakarta
    EE实现通常会将多个Jakarta EE运行时实例部署到服务器上，这使得现代Jakarta EE非常适合微服务开发。许多现代的轻量级Jakarta EE应用服务器都是可嵌入的，允许创建一个“uber
    jar”，它包含应用程序代码和应用服务器库。然后，这个“uber jar”被传输到服务器上并作为一个独立的应用程序运行。除了“uber jars”之外，现代应用服务器还可以添加到容器镜像（如Docker）中。然后，我们的应用程序可以作为一个瘦WAR部署，通常只有几KB大小；这种方法具有非常快速部署的优势，通常在两秒以内。
- en: By deploying to a contemporary, Jakarta EE core profile-compliant application
    server (or, as explained in the previous paragraph, creating an “uber jar”), Jakarta
    EE developers can certainly leverage their existing expertise to develop applications
    adhering to a microservices architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部署到符合Jakarta EE核心配置文件规范的现代应用服务器（或者，如前一段所述，创建一个“uber jar”），Jakarta EE开发者当然可以利用他们现有的专业知识来开发遵循微服务架构的应用程序。
- en: Developing microservices using Jakarta EE
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jakarta EE开发微服务
- en: Now that we have briefly introduced you to microservices, we are ready to show
    an example of a microservices application written using Jakarta EE. Our example
    application should be very familiar to most Jakarta EE developers. It is a simple
    **CRUD** (**Create, Read, Update, Delete**) application developed as a series
    of microservices. The application will follow the familiar MVC design pattern,
    with the “View” and “Controller” developed as microservices. The application will
    also utilize the very common **Data Access Object** (**DAO**) **pattern**, with
    our DAO developed as a microservice as well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要地向您介绍了微服务，我们准备展示一个使用Jakarta EE编写的微服务应用程序的示例。我们的示例应用程序对于大多数Jakarta EE开发者来说应该非常熟悉。它是一个简单的**CRUD**（**创建、读取、更新、删除**）应用程序，作为一系列微服务开发的。该应用程序将遵循熟悉的MVC设计模式，其中“视图”和“控制器”作为微服务开发。该应用程序还将利用非常常见的**数据访问对象**（**DAO**）**模式**，我们的DAO也作为微服务开发。
- en: DAO Pattern
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: DAO模式
- en: The **DAO** design pattern is one that allows us to separate data access code
    from the rest of our application. Allowing us to switch the implementation of
    the data access code without impacting the rest of the application code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**DAO**设计模式是一种允许我们将数据访问代码与我们的应用程序的其他部分分离的模式。这使我们能够在不影响应用程序的其他代码的情况下切换数据访问代码的实现。'
- en: Our application will be developed as three modules – first, a microservices
    client, followed by a microservices implementation of a controller in the MVC
    design pattern, and then an implementation of the DAO design pattern implemented
    as a microservice.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将作为三个模块开发 – 首先，一个微服务客户端，然后是MVC设计模式中控制器微服务的实现，最后是实现为微服务的DAO设计模式。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The example code is not a full CRUD application. For simplicity, we only implemented
    the “create” part of our CRUD application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码不是一个完整的CRUD应用程序。为了简单起见，我们只实现了CRUD应用程序的“创建”部分。
- en: Developing microservices client code
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发微服务客户端代码
- en: Before delving into developing our services, we will first develop a microservices
    client using plain HTML and JavaScript. The JavaScript code will invoke the controller
    microservice, passing a JSON representation of user-entered data. The controller
    service will then invoke the persistence service and save the data to a database.
    Each microservice will return an HTTP code indicating success or error condition.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入开发我们的服务之前，我们首先将使用纯HTML和JavaScript开发一个微服务客户端。JavaScript代码将调用控制器微服务，传递用户输入数据的JSON表示。然后，控制器服务将调用持久化服务并将数据保存到数据库。每个微服务将返回一个HTTP代码，指示成功或错误状态。
- en: The most relevant parts of our client code are the HTML form and the JavaScript
    code to submit it to our Controller microservice.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们客户端代码中最相关的部分是HTML表单和将其提交到我们的控制器微服务的JavaScript代码。
- en: 'The form in our HTML page contains the following input fields:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们HTML页面中的表单包含以下输入字段：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our web client form contains a number of input fields to collect data from
    the user. It is implemented using plain HTML, with no additional CSS or JavaScript
    libraries. Our page also has a script to send form data to the controller microservice
    using JavaScript, as illustrated in the following code block:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web客户端表单包含多个输入字段，用于收集用户数据。它是使用纯HTML实现的，没有使用额外的CSS或JavaScript库。我们的页面还有一个脚本，使用JavaScript将表单数据发送到控制器微服务，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the form is submitted, our script generates a JSON-formatted representation
    of the user-entered data and then sends an HTTP `POST` request to our controller
    service, using the JavaScript fetch API. In our example, our controller service
    is deployed to a Jakarta EE runtime on our local workstation, listening on port
    `8080`; therefore, our client code sends a `POST` request to http://localhost:8080/CrudController/resources/customercontroller/.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时，我们的脚本生成用户输入数据的JSON格式表示，然后使用JavaScript fetch API向我们的控制器服务发送HTTP `POST`请求。在我们的示例中，我们的控制器服务部署到我们本地工作站上的Jakarta
    EE运行时，监听端口`8080`；因此，我们的客户端代码向http://localhost:8080/CrudController/resources/customercontroller/发送`POST`请求。
- en: We can now point our browser to our `CrudView` application URL (http://localhost:8080/CrudView
    in our example). After entering some data, the page will look as shown in the
    following screenshot.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的浏览器指向我们的`CrudView`应用程序URL（在我们的示例中为http://localhost:8080/CrudView）。在输入一些数据后，页面将看起来如下所示。
- en: '![Figure 5.1 – The HTML/JavaScript RESTful web service client](img/B21231_5_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – HTML/JavaScript RESTful Web服务客户端](img/B21231_5_01.jpg)'
- en: Figure 5.1 – The HTML/JavaScript RESTful web service client
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – HTML/JavaScript RESTful Web服务客户端
- en: When the user clicks on the **Submit** button, the client passes a JSON representation
    of user-entered data to the controller service.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**提交**按钮时，客户端将用户输入数据的JSON表示传递给控制器服务。
- en: The controller service
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器服务
- en: 'The controller service is a standard RESTful web service implementation of
    a controller in the MVC design pattern, implemented using Jakarta REST:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器服务是MVC设计模式中控制器的一个标准RESTful Web服务实现，使用Jakarta REST实现：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `options()` method, annotated with the `jakarta.ws.rs.OPTIONS` annotation
    is necessary, since the browser automatically calls it, before invoking the actual
    request containing the main logic of our server. In this method, we set some header
    values to allow `http://localhost:8080`, which is the host and port where our
    client code is deployed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`jakarta.ws.rs.OPTIONS`注解的`options()`方法是必要的，因为浏览器在调用包含我们服务器主要逻辑的实际请求之前会自动调用它。在这个方法中，我们设置了一些头部值，允许`http://localhost:8080`，这是我们客户端代码部署的主机和端口。
- en: The main logic of our controller service is in the `addCustomer()` method. This
    method receives an instance of our `Customer` class as a parameter; Jakarta REST
    automatically populates the `Customer` parameter with the JSON-formatted data
    sent by the client.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器服务的主要逻辑在`addCustomer()`方法中。此方法接收一个`Customer`类的实例作为参数；Jakarta REST自动将客户端发送的JSON格式数据填充到`Customer`参数中。
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Customer` class is a simple **Data Transfer Object** (**DTO**), containing
    a few properties matching the input fields in the form in the client, plus the
    corresponding getters and setters. Since the class is quite simple, we decided
    not to show it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer`类是一个简单的**数据传输对象**（**DTO**），包含一些与客户端表单中的输入字段匹配的属性，以及相应的getter和setter。由于该类相当简单，我们决定不展示它。'
- en: In the `addCustomer()` method, we create an instance of `CustomerPersistenceClient()`,
    which is a client for the persistence service, implemented using the Jakarta REST
    client API.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addCustomer()`方法中，我们创建了一个`CustomerPersistenceClient()`实例，这是一个持久化服务的客户端，使用Jakarta
    REST客户端API实现。
- en: Then, our `addCustomer()` method invokes the persistence service by invoking
    the `create()` method on `CustomerPersistenceClient`, checks the HTTP status code
    returned by the persistence service, and then sends an appropriate response to
    the client.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的`addCustomer()`方法通过在`CustomerPersistenceClient`上调用`create()`方法来调用持久化服务，检查持久化服务返回的HTTP状态码，然后向客户端发送适当的响应。
- en: 'Now, let’s take a look at the implementation of our Jakarta REST client code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的Jakarta REST客户端代码的实现：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, our client code is a fairly simple class that makes use of the
    Jakarta REST client API. We declare a constant containing the base URI of the
    service we are invoking (our persistence service). In its constructor, we create
    a new instance of `jakarta.ws.rs.client.ClientBuilder`. We then set its base URI
    and path, matching the appropriate values for our persistence service. Our client
    class has a single method, which submits an HTTP `POST` request to the persistence
    service and then returns the response sent back from it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的客户端代码是一个相当简单的类，它使用了Jakarta REST客户端API。我们声明了一个包含我们正在调用的服务的基础URI的常量（我们的持久化服务）。在其构造函数中，我们创建了一个新的`jakarta.ws.rs.client.ClientBuilder`实例。然后我们设置其基础URI和路径，匹配我们持久化服务的适当值。我们的客户端类有一个单一的方法，该方法向持久化服务提交一个HTTP
    `POST`请求，然后返回从它那里返回的响应。
- en: Now that we have successfully developed our controller service, we are ready
    to explore the final component of our application – the persistence service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功开发出我们的控制器服务，我们准备探索我们应用程序的最后一个组件——持久化服务。
- en: The persistence service
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化服务
- en: 'Our persistence service is implemented as a simple RESTful web service using
    Jakarta REST. Its `create()` method is invoked when the service receives an HTTP
    `POST` request:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的持久化服务使用Jakarta REST实现为一个简单的RESTful Web服务。其`create()`方法在服务接收到HTTP `POST`请求时被调用：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `create()` method is invoked when the controller service sends an HTTP `POST`
    request to the persistence service. This method simply invokes a `create()` method
    on a class implementing the DAO design pattern. Our persistence service returns
    an HTTP response, `201` (Created). If everything goes well and the DAO’s `create()`
    method throws an exception, then our service returns a `500` HTTP error (Internal
    Server Error).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制器服务向持久化服务发送HTTP `POST`请求时，我们的`create()`方法被调用。此方法简单地在一个实现DAO设计模式的类上调用`create()`方法。我们的持久化服务返回一个HTTP响应，`201`（已创建）。如果一切顺利且DAO的`create()`方法抛出异常，则我们的服务返回`500`
    HTTP错误（内部服务器错误）。
- en: 'Our DAO is implemented as a CDI-managed bean, using JPA to insert data into
    the database:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 DAO 实现为一个 CDI 管理的 Bean，使用 JPA 将数据插入数据库：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our DAO couldn’t be much simpler; it implements a single method that invokes
    the `persist()` method on an injected instance of `EntityManager`. Note that we
    took advantage of the `@DataSourceDefinition` annotation to create a data source
    pointing to our database. This annotation is a standard Jakarta EE annotation
    that allows us to define data sources in an implementation-independent way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 DAO 实现非常简单；它实现了一个方法，该方法在注入的 `EntityManager` 实例上调用 `persist()` 方法。请注意，我们利用了
    `@DataSourceDefinition` 注解来创建一个指向我们数据库的数据源。这个注解是一个标准的 Jakarta EE 注解，它允许我们以实现无关的方式定义数据源。
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In our persistence service project, the `Customer` class is a trivial JPA entity.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的持久化服务项目中，`Customer` 类是一个简单的 JPA 实体。
- en: Now that we have developed all three components of our application, we are ready
    to see it in action.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开发了我们应用程序的所有三个组件，我们准备看到它的实际效果。
- en: Once a user enters some data and clicks the submit button, we should see a “success”
    message at the top of our page (see *Figure 5**.2*).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入一些数据并点击提交按钮后，我们应该在我们的页面顶部看到一条“成功”消息（见图 *图 5**.2*）。
- en: '![Figure 5.2 – User-entered data](img/B21231_5_02.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 用户输入的数据](img/B21231_5_02.jpg)'
- en: Figure 5.2 – User-entered data
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 用户输入的数据
- en: If we look at the database, we should see that the user-entered data persisted
    successfully, as shown in *Figure 5**.3*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看数据库，我们应该看到用户输入的数据已成功持久化，如图 *图 5**.3* 所示。
- en: '![Figure 5.3 – Data inserted into the database](img/B21231_5_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 插入数据库中的数据](img/B21231_5_03.jpg)'
- en: Figure 5.3 – Data inserted into the database
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 插入数据库中的数据
- en: As shown by our example code, developing applications following microservices
    architecture in Jakarta EE is very simple. It doesn’t require any special knowledge.
    Microservices are developed using standard Jakarta EE APIs and deployed to a lightweight
    Jakarta EE runtime.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的示例代码所示，在 Jakarta EE 中遵循微服务架构开发应用程序非常简单。它不需要任何特殊知识。微服务使用标准的 Jakarta EE API
    开发，并部署到轻量级的 Jakarta EE 运行时。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As seen in this chapter, Jakarta EE is quite suitable for microservices development.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章所示，Jakarta EE 非常适合微服务开发。
- en: 'In this chapter, we covered the following topics:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: We introduced you to microservices, listing the advantages and disadvantages
    of a microservices architecture
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向您介绍了微服务，并列出了微服务架构的优缺点
- en: We explained how to develop microservices using standard Jakarta EE technologies,
    such as Jakarta REST
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了如何使用标准的 Jakarta EE 技术开发微服务，例如 Jakarta REST
- en: Jakarta EE developers can leverage their existing knowledge to develop microservices
    architecture – deploying modern, lightweight application servers. Traditional
    Jakarta EE applications can interact with microservices quite well, and they can
    also be refactored iteratively into a microservices architecture when it makes
    sense. Whether developing new applications following a microservices architecture,
    refactoring an existing application to microservices, or modifying existing applications
    to interact with microservices, Jakarta EE developers can leverage their existing
    skills for the task at hand.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE 开发者可以利用他们现有的知识来开发微服务架构——部署现代、轻量级的应用服务器。传统的 Jakarta EE 应用程序可以很好地与微服务交互，并且当有需要时，也可以迭代地重构为微服务架构。无论是开发遵循微服务架构的新应用程序，重构现有应用程序为微服务，还是修改现有应用程序以与微服务交互，Jakarta
    EE 开发者都可以利用他们现有的技能来完成这项任务。
