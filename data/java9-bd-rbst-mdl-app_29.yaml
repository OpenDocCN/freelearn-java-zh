- en: DeskDroid - A Desktop Client for Your Android Phone
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DeskDroid - 为您的Android手机提供的桌面客户端
- en: We've come at long last to our final project. To close our time together here,
    we're going to build a very practical application, one that lets us send and receive
    SMS messages from the comfort of our desktop. There are a number of products on
    the market that let you do this now, but they typically require a third-party
    service, meaning your message travels through someone else's servers. For the
    privacy-minded, that can be a real problem. We'll build a system that is 100%
    local.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于来到了我们的最终项目。为了结束我们在这里的时光，我们将构建一个非常实用的应用程序，一个让我们能够从桌面舒适地发送和接收短信的应用程序。市场上现在有许多产品可以让你做这件事，但它们通常需要一个第三方服务，这意味着你的消息会通过别人的服务器。对于注重隐私的人来说，这可能是一个真正的问题。我们将构建一个100%本地的系统。
- en: 'Building the app will cover several different topics, some familiar, some new.
    That list includes the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用将涵盖几个不同的主题，有些熟悉，有些新颖。以下是这个列表：
- en: Android applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android应用程序
- en: Android services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android服务
- en: REST servers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST服务器
- en: Server-sent events for event/data streaming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器发送的事件用于事件/数据流
- en: Data access using Content Providers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内容提供者进行数据访问
- en: There will also be a host of other, smaller tidbits along the way as we finish
    out our time together on a strong, high note.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们共同度过的时间结束时，我们还将有其他许多小细节，以一个强大、高调的结尾。
- en: Getting started
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'This project will have two parts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将有两个部分：
- en: The Android application/server (not to be confused with application server,
    of course)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android应用程序/服务器（当然不要与应用程序服务器混淆）
- en: The desktop/JavaFX application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面/JavaFX应用程序
- en: The desktop piece is somewhat useless without the **server** piece, so we'll
    start by building the Android side first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 没有服务器组件，桌面组件就有些无用了，所以我们将首先构建Android端。
- en: Creating the Android project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Android项目
- en: While we have been using NetBeans for most of our work so far, we will again
    use Android Studio for this piece of the project. While there is some semblance
    of Android support for NetBeans, as of this writing, the project seems to have
    stalled. Android Studio, on the other hand, is very actively developed by Google
    and is, in fact, the official IDE for Android development. I will leave it as
    an exercise for the reader, if needed, to install the IDE and the SDK.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们到目前为止的大部分工作都在使用NetBeans，但我们将再次使用Android Studio来完成这个项目部分。虽然NetBeans对Android有一些支持，但截至本文撰写时，该项目似乎已经停滞不前。另一方面，Android
    Studio是由谷歌非常积极地开发的，事实上，它是Android开发的官方IDE。如果需要，我将把它留给读者作为练习，安装IDE和SDK。
- en: 'To create a new project, we click on File | New Project, and specify Application
    name, Company domain, and Project location, as shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新项目，我们点击文件 | 新建项目，并指定应用程序名称、公司域名和项目位置，如下面的截图所示：
- en: '![](img/40d38df6-07a4-40e1-8936-599fc2cc81fc.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40d38df6-07a4-40e1-8936-599fc2cc81fc.png)'
- en: 'Next, we need to specify the API version we want to target. This can be a tricky
    choice. On the one hand, we''d like to be on the cutting edge and have all of
    the great new features that Android offers available to us, but on the other hand,
    we don''t want to target such a new API level that we make the application unusable
    (read uninstallable) for a larger number of Android users than is necessary. In
    this case, Android 6.0, or Marshmallow, seems like an acceptable trade-off:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定我们想要的目标API版本。这是一个棘手的选择。一方面，我们希望走在前沿，能够使用Android提供的大多数新功能，但另一方面，我们不想针对如此新的API级别，以至于让更多的Android用户无法使用（或者说无法卸载）应用程序。在这种情况下，Android
    6.0，或Marshmallow，似乎是一个可接受的折衷方案：
- en: '![](img/3fcfe029-ebb7-40ca-9b03-abb856bc76b2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3fcfe029-ebb7-40ca-9b03-abb856bc76b2.png)'
- en: Click on Next, select Blank Activity, Next, and Finish, and our project is ready
    for development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步，选择空白活动，然后点击下一步，完成，我们的项目就准备好开发了。
- en: On the Android side, we are not going to do much in the way of user interface.
    Once we have finished the project, you will likely have all sorts of ideas of
    what could be done, which is great, but we won't spend the time here doing any
    of those. That said, the first thing we really need to do is ask the user for
    permission to access the text messages on their phone.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android端，我们不会在用户界面方面做太多工作。一旦我们完成项目，你可能会想到各种可以做的事情，这很好，但我们不会在这里花时间做这些。话虽如此，我们真正需要做的第一件事是请求用户允许访问他们手机上的短信。
- en: Requesting permissions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求权限
- en: 'In earlier versions of Android, permissions were an all or nothing proposition.
    Starting with Android 6, though, the user is prompted for each permission that
    the application requests, allowing for the possibility of a user to grant some
    permissions while denying others. We will need to request some permissions--we
    need to be able to read and write SMS messages, and we''ll need access to the
    contacts (so we can try to figure out who sent us a given message). Android provides
    an API for requesting those permissions very easily, which we''ll put in our `onCreate()`
    method, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 的早期版本中，权限是一个全有或全无的提议。然而，从 Android 6 开始，对于应用程序请求的每个权限，用户都会被提示，这允许用户授予一些权限同时拒绝其他权限。我们需要请求一些权限——我们需要能够读取和写入短信消息，并且我们需要访问联系人（这样我们就可以尝试找出谁给我们发送了特定的消息）。Android
    提供了一个非常容易请求这些权限的 API，我们将在 `onCreate()` 方法中实现，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When this preceding code runs, Android will prompt the user to grant or deny
    the requested permissions. This is done asynchronously, so, in your applications,
    you need to make sure you don't attempt any operation that requires any permission
    that you request until the user has had a chance to grant the permission (and,
    should the user deny the permission, the application should degrade, or fail,
    gracefully).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段前置代码运行时，Android 会提示用户授予或拒绝请求的权限。这是异步进行的，因此，在你的应用程序中，你需要确保在用户有机会授予权限之前，不要尝试任何需要你请求的权限的操作（如果用户拒绝权限，应用程序应该优雅地降级或失败）。
- en: 'To allow the application to respond to permission grants, Android provides
    a callback. In our callback, we want to make sure the user grants us both permissions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许应用程序响应权限授予，Android 提供了一个回调。在我们的回调中，我们想要确保用户授予我们两个权限：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When Android calls back in to our application, we need to make sure that the
    `requestCode` is what we specified-- `PERMISSION_REQUEST_CODE`--to make sure that
    we only respond to our own requests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Android 回调到我们的应用程序时，我们需要确保 `requestCode` 是我们指定的——`PERMISSION_REQUEST_CODE`——以确保我们只响应我们自己的请求。
- en: Once we've identified an appropriate response, we make sure that `grantResults`
    is the correct length, and that each entry is `PERMISSION_GRANTED`. If the array
    is too short, or if either array element is not the correct type, we display a
    dialog informing the user that both permissions are required, and then exit the
    application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了适当的响应，我们确保 `grantResults` 的长度正确，并且每个条目都是 `PERMISSION_GRANTED`。如果数组太短，或者如果任一数组元素不是正确的类型，我们将显示一个对话框通知用户需要这两个权限，然后退出应用程序。
- en: In our example, we are requesting both permissions simultaneously, so we respond
    to both simultaneously. If you have a complex set of permissions, for example,
    if your application can work with only some of the requested permissions, you
    can make multiple calls to `ActivityCompat.requestPermissions`, providing a distinct
    `requestCode` for each. You would then need to expand your switch block in `onRequestPermissionsResult()`
    to cover each new `requestCode`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们同时请求这两个权限，因此我们同时响应。如果你有一组复杂的权限，例如，如果你的应用程序只能使用请求的一些权限，你可以多次调用 `ActivityCompat.requestPermissions`，为每个提供不同的
    `requestCode`。然后你需要扩展 `onRequestPermissionsResult()` 中的 switch 块，以覆盖每个新的 `requestCode`。
- en: 'One final word on permissions. Typically, you should always check to make sure
    that you have the permission needed to perform a given task. You can do that with
    a method as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于权限的问题。通常情况下，你应该始终检查以确保你有执行特定任务所需的权限。你可以使用以下方法来完成：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our case, we just don't allow the application to run if we aren't granted
    the required permissions, so we need not worry about additional permission checks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如果我们没有得到所需的权限，我们就不允许应用程序运行，因此我们不需要担心额外的权限检查。
- en: Creating the service
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务
- en: The heart of the Android portion of the project is our REST endpoints. We would
    like these endpoints to be available whenever the phone is on, so we can't use
    an `Activity` to host them. What we want is a `Service`. The Android documentation
    defines a `Service` as *an application component that can perform long-running
    operations in the background, and it does not provide a user interface*. There
    are three types of Services--`scheduled` (which runs on a schedule), `started`
    (which can be started explicitly by another application component), and `bound`
    (which is bound to an application component via the `bindService()` call, and
    runs until all the bound components are destroyed). Since we want this to be available
    all the time, we want a started service.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中Android部分的精髓是我们的REST端点。我们希望这些端点在手机开启时始终可用，因此我们不能使用`Activity`来托管它们。我们想要的是一个`Service`。Android文档将`Service`定义为*一种可以在后台执行长时间运行操作的应用程序组件，并且它不提供用户界面*。有三种类型的Service--`计划`（按计划运行）、`启动`（可以被其他应用程序组件显式启动）和`绑定`（通过`bindService()`调用绑定到应用程序组件，直到所有绑定组件被销毁为止）。由于我们希望它始终可用，我们想要一个启动服务。
- en: 'To create the service, click on File | New | Service | Service. Enter `DeskDroidService`
    for the service, uncheck Exported, and click on Finish. That will get you the
    following stubbed code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务，请点击文件 | 新建 | 服务 | 服务。为服务输入`DeskDroidService`，取消勾选导出，然后点击完成。这将生成以下示例代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The wizard also updates `AndroidManifest.xml` as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 向导还会按如下方式更新`AndroidManifest.xml`：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The method `onBind()` is abstract, so it must be implemented. We are not creating
    a bound service, so we can leave this unimplemented, although we will change it
    so that it returns `null` rather than throwing an `Exception`. We are, though,
    interested in when the service is started and stopped, so we need to override
    these two relevant lifecycle methods:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`onBind()`方法是抽象的，因此必须实现。我们不是创建一个绑定服务，所以我们可以将其留空不实现，尽管我们将更改它，使其返回`null`而不是抛出`Exception`。然而，我们对服务启动和停止的时间感兴趣，因此我们需要重写这两个相关生命周期方法：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s in these methods that we''ll place our REST service code. We will once
    again use Jersey, the JAX-RS reference implementation, which provides a nice way
    of bootstrapping a server in a Java SE environment, such as what we find ourselves
    in here in our Android application. We''ll encapsulate that logic in a new method
    called `startServer()` as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这些方法中放置我们的REST服务代码。我们再次使用Jersey，JAX-RS的参考实现，它为在Java SE环境中启动服务器提供了一种很好的方式，就像我们在Android应用程序中找到的那样。我们将把这个逻辑封装在一个名为`startServer()`的新方法中，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first thing we do is check to make sure that we're on Wi-Fi. This isn't
    strictly necessary, but it seemed to be a prudent precaution to prevent the application
    from listening for connections, regardless of the network state. If the phone
    is not on Wi-Fi, there's a good chance the intended laptop is not either. There
    may be legitimate use cases for allowing the endpoints to listen even on a cellular
    network, however. Making this restriction configurable is a great candidate for
    a preferences-driven option.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保我们正在使用Wi-Fi。这并不是绝对必要的，但似乎是一个谨慎的预防措施，以防止应用程序在无论网络状态如何的情况下监听连接。如果手机没有连接Wi-Fi，那么目标笔记本电脑很可能也没有。然而，可能存在允许端点在蜂窝网络上监听的有效用例。将此限制设置为可配置的是偏好驱动选项的一个很好的候选。
- en: 'For this code to work, we need to add this new permission to the manifest:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此代码能够正常工作，我们需要在清单文件中添加这个新的权限：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once we're sure that we're on Wi-Fi, we look up our IP address, and bootstrap
    a Jetty-based Jersey server. With a nod to the Venerable Commodore 64, for those
    of us old enough to remember that computing pioneer, we listen on port `49152`
    on the Wi-Fi network interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定正在使用Wi-Fi，我们查找我们的IP地址，并启动一个基于Jetty的Jersey服务器。向那些还记得这位计算先驱的尊敬的指挥官64致敬，对于那些足够老的人来说，我们在Wi-Fi网络接口上监听端口`49152`。
- en: Next, we create a `ResourceConfig` instance, providing two feature references
    that we're interested in--`SseFeature` and `JacksonFeature`. We've already seen
    `JacksonFeature`; that's what lets us work with POJOs, leaving the JSON concerns
    to Jersey. What is `SseFeature`, though?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`ResourceConfig`实例，提供我们感兴趣的两种功能引用--`SseFeature`和`JacksonFeature`。我们已经看到了`JacksonFeature`；这正是让我们能够处理POJOs，将JSON问题留给Jersey的功能。那么，`SseFeature`是什么呢？
- en: Server-sent events
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端事件
- en: SSE, or server-sent events, is a means by which we can stream data from the
    server to the client. Typically, a REST request is very short-lived--make a connection,
    send the request, get a response, close the connection. Sometimes, though, the
    REST server may not have all of the data that the client wants at the time of
    the request (for example, reading data from another data source such as a log
    file or network socket). So, it would be nice to be able to push that data to
    the client as it becomes available. That's exactly what SSE allows us to do. We'll
    look into that in more detail later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SSE，或服务器发送事件，是我们可以从服务器向客户端流式传输数据的一种方式。通常，REST请求的生命周期非常短暂——建立连接，发送请求，获取响应，关闭连接。有时，尽管如此，REST服务器可能没有在请求时客户端所需的所有数据（例如，从另一个数据源读取数据，如日志文件或网络套接字）。因此，能够将那些数据在它们可用时推送到客户端将是非常好的。这正是SSE允许我们做到的。我们将在稍后更详细地探讨这一点。
- en: 'Finally, we start the server instance with a call to `JettyHttpContainerFactory.createServer()`.
    Since we need to be able to stop the server later, we capture the server instance,
    and store it in an instance variable. We call `startServer()` from `onStartCommand()`
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`JettyHttpContainerFactory.createServer()`来启动服务器实例。由于我们需要能够在以后停止服务器，我们捕获服务器实例，并将其存储在一个实例变量中。我们从`onStartCommand()`中调用`startServer()`，如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we've wrapped our call to `startServer()` in a `synchronized` block.
    For those that might be unaware, `synchronized` is one of the more basic approaches
    to concurrent code available to Java developers. The net effect of this keyword
    is that multiple threads that try to execute this block of code must do so synchronously,
    or one a time. We do this here so that if we have two different processes attempting
    to start the server, we can guarantee that at most one is running. Without this
    block, the first thread could start the server and store the instance in the variable,
    while a second thread could do the same thing, but its server instance, which
    gets stored in the variable, fails to start. We would now have a running server
    with no valid reference to it, so we would be unable to stop it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将`startServer()`的调用包裹在一个`synchronized`块中。对于那些可能不知道的人来说，`synchronized`是Java开发者可用的更基本的并发代码方法之一。这个关键字的效果是，尝试执行此代码块的多线程必须同步执行，或者一次一个。我们在这里这样做是为了确保如果有两个不同的进程试图启动服务器，我们可以保证最多只有一个正在运行。如果没有这个块，第一个线程可能会启动服务器并将实例存储在变量中，而第二个线程可能会做同样的事情，但它的服务器实例，存储在变量中的，无法启动。现在我们会有一个正在运行的服务器，但没有有效的引用，因此我们将无法停止它。
- en: We have also registered a `BroadcastReceiver` that listens for `CODE_GENERATED`.
    We'll come back and explain this later in the chapter, so don't worry about this
    for now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注册了一个监听`CODE_GENERATED`的`BroadcastReceiver`。我们将在本章稍后解释这一点，所以现在不用担心。
- en: Controlling the service state
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制服务状态
- en: 'If we run the application now, our service won''t run, so we need to make it
    such that it will run. We''ll do that in a couple of different ways. The first
    way will be from our application. We want to make sure the service is running
    when we open the application, especially after it is just installed. To do that,
    we need to add one line to `MainActivity.onCreate()` as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们的服务将不会运行，因此我们需要确保它能够运行。我们将通过几种不同的方式来实现这一点。第一种方式将来自我们的应用程序。我们想要确保在打开应用程序时服务正在运行，尤其是在它刚刚安装之后。为此，我们需要在`MainActivity.onCreate()`中添加一行，如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the application is started now, it will guarantee that the service is
    running. We don''t, though, want to require that the user open the application
    to run the service. Fortunately, we have a way to start the application when the
    phone starts. We can do that by installing a `BroadcastReceiver` that listens
    for boot events, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序现在启动时，它将保证服务正在运行。但我们不希望用户打开应用程序来运行服务。幸运的是，我们有一种在手机启动时启动应用程序的方法。我们可以通过安装一个监听启动事件的`BroadcastReceiver`来实现这一点，如下所示：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The body of the preceding method is identical to our recent addition to `MainActivity`.
    We do, though, need to register the service, and ask for permission. In `AndroidManifest.xml`,
    we need to add this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的主体与我们在`MainActivity`中最近添加的内容相同。不过，我们需要注册服务并请求权限。在`AndroidManifest.xml`中，我们需要添加以下内容：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now have a service that starts either at device boot or application startup.
    It does not, however, do anything of interest, so we need to add some endpoints
    to our server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个在设备启动或应用程序启动时启动的服务。然而，它并没有做任何有趣的事情，因此我们需要向我们的服务器添加一些端点。
- en: Adding endpoints to the server
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向服务器添加端点
- en: 'As covered in [Chapter 25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml), *Taking
    Notes with Monumentum*, a JAX-RS resource lives in a POJO with certain annotations.
    To stub out our endpoint class, we can start with this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 [第 25 章](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml) 中所述，*使用 Monumentum 记笔记*，一个
    JAX-RS 资源存在于一个带有特定注解的 POJO 中。为了构建我们的端点类，我们可以从以下内容开始：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will also need to register this class with JAX-RS, which we do with this
    line in `startServer()`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将这个类注册到 JAX-RS 中，我们通过在 `startServer()` 方法中的这一行来完成：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ordinarily, we would pass, say, `DeskDroidResource.class`, to the `ResourceConfig`
    constructor, like we did with `JacksonFeature.class`. We will be accessing Android
    resources, and to do that, we're going to need the `Service`'s `Context` instance.
    There are a number of resources on the internet that will suggest creating a custom
    `Application` class and storing it in a `public static`. While that does seem
    to work, it will also leak memory, so, Android Studio, for example, will complain
    if you try that. We can, however, avoid that by using nested classes. That approach
    can get a bit unwieldy, but our classes should be small enough that it remains
    manageable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会将 `DeskDroidResource.class` 传递给 `ResourceConfig` 构造函数，就像我们处理 `JacksonFeature.class`
    一样。我们将访问 Android 资源，为此，我们需要 `Service` 的 `Context` 实例。互联网上有许多资源建议创建一个自定义的 `Application`
    类并将其存储在 `public static` 中。虽然这似乎可行，但它也会导致内存泄漏，所以，例如，如果你在 Android Studio 中尝试这样做，它将会报错。然而，我们可以通过使用嵌套类来避免这种情况。这种方法可能会有些难以管理，但我们的类应该足够小，以至于仍然可以管理。
- en: Getting conversations
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取对话
- en: 'Let''s start by adding an endpoint to get all of the conversations on the phone,
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加一个端点开始，以获取手机上的所有对话，如下所示：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here is where we see the Android artifacts start to show up--we are going to
    use a `ContentProvider` to access the SMS data. A `ContentProvider` is a way for
    an application, or, in this case, an Android subsystem, to expose data to outside
    consumers in a portable, storage-agnostic manner. We don't care how the data is
    stored. We simply specify what fields we want, what filters or restrictions we
    want placed on that data, and `ContentProvider` does the rest.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们可以看到 Android 的组件开始显现——我们将使用 `ContentProvider` 来访问短信数据。`ContentProvider`
    是一种方式，允许一个应用程序，或者在这个案例中是一个 Android 子系统，以可移植、不依赖于存储的方式向外部消费者公开数据。我们不在乎数据是如何存储的。我们只需指定我们想要的字段，我们想要对那些数据施加的过滤器或限制，然后
    `ContentProvider` 会完成剩余的工作。
- en: Using `ContentProvider`s, we specify the type of data not by a table name, like
    we would with SQL, but with a `Uri`. In this case, we specify `Telephony.Sms.Conversations.CONTENT_URI`.
    We pass several null values to `query()` as well. These represent the projection
    (or field list), the selection (or filter), the selection arguments, and the sort
    order. Since these are all `null`, we want every field and every row in the natural
    sort order for the provider. That gets us a `Cursor` object, which we then iterate
    over, creating `Conversation` objects, and add them to our `List`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ContentProvider`，我们不是通过表名来指定数据类型，就像我们使用 SQL 一样，而是通过 `Uri`。在这种情况下，我们指定 `Telephony.Sms.Conversations.CONTENT_URI`。我们还向
    `query()` 传递几个 null 值。这些代表投影（或字段列表）、选择（或过滤器）、选择参数和排序顺序。由于这些全部是 `null`，我们希望获取提供者自然排序顺序下的所有字段和每一行。这给我们一个
    `Cursor` 对象，然后我们遍历它，创建 `Conversation` 对象，并将它们添加到我们的 `List` 中。
- en: 'We create the `Conversation` instances with this method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个方法创建 `Conversation` 实例：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This method, and the processing logic, is mostly identical to that for conversations.
    The `Uri` for the `ContentProvider`, `Telephony.Sms.CONTENT_URI`, is different,
    of course, and we specify a filter for the query as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法和处理逻辑基本上与对话的相同。`ContentProvider` 的 `Uri`，即 `Telephony.Sms.CONTENT_URI`，当然不同，我们按照如下方式指定查询的过滤器：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We do have a slight bit of data analysis here. We need to know which of the
    messages are the ones we sent and which are the ones we received so that we can
    display the thread more meaningfully. On the device, the messages we've sent have
    the type `Telephony.Sms.MESSAGE_TYPE_SENT`. The values for this field translate
    roughly to folders (sent, received, draft, and so on). Rather than leaking part
    of the Android API into ours by sharing the value of the constant, we have a `boolean`
    field, `isMine`, which is true if the message is of type `MESSAGE_TYPE_SENT`.
    It is, admittedly, a slightly clumsy alternative, but it works and should be clear
    enough.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里进行了一些数据分析。我们需要知道哪些是我们发送的消息，哪些是我们接收的消息，以便我们可以更有意义地显示线程。在设备上，我们发送的消息类型为`Telephony.Sms.MESSAGE_TYPE_SENT`。这个字段的值大致对应于文件夹（已发送、已接收、草稿等）。我们不是通过共享常量的值将Android
    API的一部分泄露到我们的API中，而是有一个`boolean`类型的字段`isMine`，如果消息类型为`MESSAGE_TYPE_SENT`，则该字段为true。诚然，这是一个稍微有些笨拙的替代方案，但它有效，并且应该足够清晰。
- en: Once we return the list of messages, we iterate over the list, getting a list
    of the unique participants (which should be only one, since we are dealing with
    SMS messages).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们返回消息列表，我们就遍历列表，获取唯一参与者的列表（由于我们处理的是短信消息，所以应该只有一个）。
- en: 'Finally, we return this `List<Conversation>` to the client using Jersey''s
    POJO-mapping feature as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Jersey的POJO-mapping功能将这个`List<Conversation>`返回给客户端，如下所示：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](img/8df486ff-1ee8-4e2d-a573-fa7d55e4e23c.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8df486ff-1ee8-4e2d-a573-fa7d55e4e23c.png)'
- en: 'If we click either the run or debug buttons (the large triangle or the triangle-over-a-bug
    icons in the tool bar), you''ll be asked for the deployment target, as seen in
    this screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击运行或调试按钮（工具栏中的大三角形或三角形-over-a-bug图标），你会被要求选择部署目标，如下截图所示：
- en: '![](img/6a7f7e2a-55a8-4da0-a587-5bb8b4550558.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a7f7e2a-55a8-4da0-a587-5bb8b4550558.png)'
- en: 'Since we require Wi-Fi, I select my physical device. If you want to configure
    an emulator with Wi-Fi, that would work as well. Click on OK, and after a few
    moments, the application should start on the device you have selected, and we
    can make our first REST request as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要Wi-Fi，我选择了我的物理设备。如果你想要配置具有Wi-Fi的模拟器，那也可以。点击确定，经过几分钟，应用程序应该在你选择的设备上启动，然后我们可以进行我们的第一个REST请求，如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This preceding sample code shows a conversation I'm having with myself. Too
    many late nights, perhaps, but you can see where the first message, the oldest
    message, is marked as mine, which is the one I sent to myself, and the second
    is where I received it back. Pretty cool, but how do you send a message? It turns
    out that that's actually quite simple.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码显示了我和自己进行的对话。或许是因为太多的深夜，但你可以看到第一条消息，即最旧的消息，被标记为我的，这是我给自己发送的，第二条是我接收到的。非常酷，但你是如何发送消息的呢？实际上，这实际上非常简单。
- en: Sending an SMS message
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送短信消息
- en: To send a message, we will create a POST endpoint that takes a `Message` object,
    which we'll then pull apart and pass to Android's telephony APIs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送消息，我们将创建一个POST端点，该端点接受一个`Message`对象，然后我们将将其拆分并传递给Android的电信API。
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There''s a lot going on this method. Here is the breakdown:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法中有很多事情在进行。以下是分解：
- en: We get a reference to the `SmsManager` class. This class will do all of the
    work for us.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取到`SmsManager`类的引用。这个类将为我们完成所有工作。
- en: We ask `SmsManager` to divide the message for us. Text messages are, typically,
    limited to 160 characters, so this will split the message as needed.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要求`SmsManager`为我们分割消息。通常，短信文本限制在160个字符，所以这将根据需要分割消息。
- en: We create a `CountDownLatch` with a count that matches the number of parts in
    the message.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个计数与消息部分数量相匹配的`CountDownLatch`。
- en: We create an `AtomicInteger` to store the status code. As we'll see in a moment,
    we need to change the value of this variable from inside an anonymous class. However,
    for an anonymous class to access variables from its enclosing scope, those variables
    must be `final`, which means that we can not have a `final int`, as then we would
    not be able to change the value. With `AtomicInteger`, though, we can call `set()`
    to change the value while leaving the instance reference, which is what the variable
    will hold, unchanged.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个`AtomicInteger`来存储状态码。正如我们一会儿将看到的，我们需要从匿名类内部更改这个变量的值。然而，为了让匿名类能够访问其封装作用域中的变量，这些变量必须是`final`的，这意味着我们不能有一个`final
    int`，因为那样我们就无法更改其值。不过，使用`AtomicInteger`，我们可以调用`set()`来更改值，同时保持实例引用不变，这就是变量将保持的内容。
- en: We create a new `BroadcastReceiver`, which will handle `Intent`s broadcast (as
    we'll see further) when the message is sent. In `onReceive()`, if the result code
    is not `ACTIVITY.RESULT_OK`, we call `AtomicInteger.set()` to reflect the failure.
    We then call `sentLatch.countDown()` to indicate that this message part has been
    processed.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的 `BroadcastReceiver`，它将在消息发送时处理 `Intent` 广播（正如我们稍后看到的）。在 `onReceive()`
    中，如果结果代码不是 `ACTIVITY.RESULT_OK`，我们调用 `AtomicInteger.set()` 来反映失败。然后我们调用 `sentLatch.countDown()`
    来表示此消息部分已被处理。
- en: With the call to `registerReceiver()`, we let the operating system know about
    our new receiver. We provide an `IntentFilter` to restrict which `Intents` our
    receiver has to process.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `registerReceiver()`，我们让操作系统知道我们的新接收器。我们提供一个 `IntentFilter` 来限制我们的接收器必须处理的
    `Intents`。
- en: We then create a new `PendingIntent` for each part our message has been split
    into. This will allow us to react to each part's send attempt individually.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为消息的每一部分创建一个新的 `PendingIntent`。这将使我们能够单独对每一部分的发送尝试做出反应。
- en: We call `sendMultipartTextMessage()` to send the message part(s). Android handles
    the details of a multipart message for us, so there's no extra effort required.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用 `sendMultipartTextMessage()` 来发送消息部分。Android 会为我们处理多部分消息的细节，因此不需要额外的努力。
- en: We need to wait for all of the message parts to be sent, so we call `sentLatch.await()`
    to give the system time to send the message. We don't want to wait forever, though,
    so we give it a timeout of five seconds, which should be long enough. It is conceivable
    that some networks may be very slow about sending text messages, so this value
    may need to be adjusted.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要等待所有消息部分发送完成，因此我们调用 `sentLatch.await()` 给系统发送消息的时间。但我们不想永远等待，所以我们给它一个五秒的超时，这应该足够长。可以想象，某些网络在发送短信方面可能非常慢，因此这个值可能需要调整。
- en: Once we pass the latch, we `unregister` our receiver, and return the status
    code.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们通过 latch，我们就取消注册我们的接收器，并返回状态码。
- en: 'Using curl again, we can now test sending a message (be sure to click on `Run`
    or `Debug` again to deploy your updated code):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 curl，我们现在可以测试发送消息（确保再次点击运行或调试以部署您的更新代码）：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding `curl` we send some `lorem ipsum` text to our recipient, which
    gives us a nice, long message (482 total characters for the request payload),
    which is correctly chunked up and sent to the destination phone number, as indicated
    by the `201 Created` response status.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `curl` 中，我们向我们的收件人发送一些 `lorem ipsum` 文本，这给我们提供了一个很长的消息（请求有效载荷总共有 482 个字符），它被正确地分块并发送到目标电话号码，如
    `201 Created` 响应状态所示。
- en: We now have a working REST service on the phone, which lets us read the existing
    messages and send new ones. Interacting with the service with `curl` has worked
    well enough, but it's time to build our desktop client, and put a nice face on
    this project.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在手机上有一个工作的 REST 服务，它允许我们读取现有的消息并发送新的消息。使用 `curl` 与服务交互已经足够好，但现在是时候构建我们的桌面客户端，并给这个项目一个美好的外观。
- en: Creating the desktop application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建桌面应用程序
- en: 'To build our application, we''ll return to NetBeans and JavaFX. As in the previous
    chapters, we''ll create a new Maven-based JavaFX application by clicking on File
    | New Project:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的应用程序，我们将回到 NetBeans 和 JavaFX。与前面的章节一样，我们将通过点击文件 | 新项目来创建一个新的基于 Maven 的
    JavaFX 应用程序：
- en: '![](img/095f8c0e-ab8f-4125-9dbe-96ff4dbe62a5.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/095f8c0e-ab8f-4125-9dbe-96ff4dbe62a5.png)'
- en: In the next step, call the project `deskdroid-desktop`, verify the package name,
    and click on Finish. While not strictly necessary, let's clean up the naming a
    bit, changing the controller to `DeskDroidController`, and the FXML file to `deskdroid.fxml`.
    We'll also need to modify the references to the FXML and the CSS in the controller,
    and the reference to the controller in the FXML. Click on Run | Run Project to
    make sure everything is wired up correctly. Once the app starts, we can immediately
    close it so we can start making changes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，将项目命名为 `deskdroid-desktop`，验证包名，然后点击完成。虽然不是严格必要的，但让我们稍微整理一下命名，将控制器改为 `DeskDroidController`，将
    FXML 文件改为 `deskdroid.fxml`。我们还需要修改控制器中 FXML 和 CSS 的引用，以及 FXML 中控制器的引用。点击运行 | 运行项目以确保一切连接正确。一旦应用程序启动，我们就可以立即关闭它，以便开始进行更改。
- en: Defining the user interface
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户界面
- en: 'Let''s start by building up the user interface. Here''s what the application
    will look like:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建用户界面开始。以下是应用程序的外观：
- en: '![](img/4278a3b2-cead-4ecd-ac27-f4a1989c87ef.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4278a3b2-cead-4ecd-ac27-f4a1989c87ef.png)'
- en: In the preceding screen, we'll have our list of conversations on the left, and
    we will display the selected conversation on the right. We will add a mechanism
    for auto-refreshing, but the Refresh Conversations will allow for a manual refresh,
    if needed. New Message should be self-explanatory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕中，我们将有左边的会话列表，并将显示选定的会话在右侧。我们将添加自动刷新的机制，但刷新会话将允许手动刷新，如果需要的话。新消息应该很容易理解。
- en: 'We can use Gluon''s Scene Builder to build the user interface, of course, but
    let''s take a look at the FXML. We''ll start, as usual, with a `BorderPane`, as
    follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Gluon 的场景构建器来构建用户界面，当然，但让我们先看看 FXML。我们将像往常一样，从一个 `BorderPane` 开始，如下所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the `top` section, we''re going to add a menu bar as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `top` 部分，我们将添加一个菜单栏，如下所示：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll have three `MenuItem`s in the `FileMenu`: `connectToPhone`, `disconnectFromPhone`,
    and `Exit`. Each menu item will have a mnemonic, as indicated by the underscores.
    The `ExitMenuItem` has an accelerator key, `ALT-F4`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FileMenu` 中，我们将有三个 `MenuItem`：`connectToPhone`、`disconnectFromPhone` 和 `Exit`。每个菜单项都将有一个快捷键，如下划线所示。`ExitMenuItem`
    有一个加速键，`ALT-F4`。
- en: 'We''ll put the bulk of the user interface in the `center` section. The vertical
    split allows us to resize the two sides of the user interface. For that, we use
    a `SplitPane` as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把大部分用户界面放在 `center` 部分。垂直分割允许我们调整用户界面的两侧大小。为此，我们使用以下 `SplitPane`：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With `dividerPositions`, we set the default split at the 25% mark along the
    horizontal rule. The `SplitPane` has a nested `items` element to hold its children
    to which we add the left element, `ListView`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dividerPositions`，我们将默认分割设置为水平规则上的 25% 标记处。`SplitPane` 有一个嵌套的 `items` 元素来持有其子元素，我们将左侧元素
    `ListView` 添加到其中：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We wrap `ListView` in a `VBox` to make the `ListView` grow and shrink, as needed,
    more easily.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `ListView` 包裹在一个 `VBox` 中，以便 `ListView` 可以更容易地根据需要增长和收缩。
- en: 'Finally, let''s build the right side of the user interface:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们构建用户界面的右侧：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the right side, we also have a `VBox`, which we use to arrange our two user
    interface elements. The first is `HBox`, which holds two buttons: Refresh Conversation
    and New Message. The second is our `ListView` for displaying the selected conversation.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，我们还有一个 `VBox`，我们使用它来排列我们的两个用户界面元素。第一个是 `HBox`，它包含两个按钮：刷新会话和新消息。第二个是我们用于显示选定会话的
    `ListView`。
- en: Defining user interface behavior
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用户界面行为
- en: 'While we can define the structure of the user interface in FXML in all but
    the most trivial applications, the user interface still requires some Java code
    to finish defining its behavior. We''ll do that now in `DeskDroidController.initialize()`.
    We''ll start with the left side of the user interface, the conversation list,
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以在除最简单应用之外的所有应用中定义用户界面的结构，但用户界面仍然需要一些 Java 代码来最终定义其行为。我们现在将在 `DeskDroidController.initialize()`
    中完成这项工作。我们将从用户界面的左侧开始，即会话列表，如下所示：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We declare an injectable variable to hold a reference to our `ListView`. JavaFX
    will set that value for us, thanks to the annotation `@FXML`. `ListView` will
    need a model to display, which we declare as `conversations`, and we declare `conversation`
    to hold the currently selected conversation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个可注入的变量来保存对 `ListView` 的引用。JavaFX 将通过 `@FXML` 注解为我们设置该值。`ListView` 需要一个模型来显示，我们将其声明为
    `conversations`，并声明 `conversation` 来保存当前选定的会话。
- en: In the `initialize()` method, we wire everything together. Since `ListView`
    will be displaying our domain object, we need to declare a `CellFactory` for it,
    which we do with the lambda passed to `setCellFactory()`. We'll look at `ListCell`
    in a moment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initialize()` 方法中，我们将一切连接起来。由于 `ListView` 将显示我们的域对象，我们需要为它声明一个 `CellFactory`，我们通过传递给
    `setCellFactory()` 的 lambda 来实现这一点。我们稍后会看看 `ListCell`。
- en: Next, we associate `ListView` with its model, `conversations`, and define what
    is, in effect, an `onClick` listener. We achieve that, though, by adding a listener
    to `SelectionModel` on `ListView`. In that listener, we update the currently selected
    conversation, update the messages `ListView` to display the conversation, and
    scroll that `ListView` to the very bottom so that we see the most recent message.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `ListView` 与其模型 `conversations` 相关联，并定义实际上是一个 `onClick` 监听器的内容。然而，我们是通过向
    `ListView` 的 `SelectionModel` 添加监听器来实现这一点的。在这个监听器中，我们更新当前选中的会话，更新显示会话的消息 `ListView`，并将该
    `ListView` 滚动到最底部，以便我们看到最新的消息。
- en: 'Initializing the message `ListView` is much simpler. We need these instance
    variables:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化消息 `ListView` 要简单得多。我们需要这些实例变量：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also need these lines in `initialize()`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `initialize()` 中添加以下这些行：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And the New Message button needs a handler:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 新消息按钮需要一个处理程序：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`ConversationCell` tells JavaFX how to display a `Conversation` instance. To
    do that, we create a new `ListCell` child as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConversationCell`告诉JavaFX如何显示一个`Conversation`实例。为了做到这一点，我们创建一个新的`ListCell`子项，如下所示：'
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then we override `updateItem()`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重写`updateItem()`：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the cell is given a `Conversation`, we process it. If not, we set the cell's
    graphic to null. If we fail to do that, we'll have unpredictable results when
    scrolling through the lists.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元格被赋予一个`Conversation`，我们就处理它。如果没有，我们将单元格的图形设置为null。如果我们无法做到这一点，在滚动列表时可能会出现不可预测的结果。
- en: 'To build the cell contents, we start by getting the `Participant` and creating
    the wrapper component as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建单元格内容，我们首先获取`Participant`并创建以下包装组件：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is pretty standard JavaFX fare--create an `HBox`, and add to it an `ImageView`.
    We are, though, using a class we haven't looked at yet--`ConversationService`.
    We'll look at this later, but for now, it's enough to know that we will encapsulate
    our REST calls in this class. Here, we're calling an endpoint (that we haven't
    seen yet) to get the contact information for the phone number at the other end
    of this conversation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当标准化的JavaFX操作——创建一个`HBox`，并向其中添加一个`ImageView`。不过，我们正在使用我们尚未查看的类——`ConversationService`。我们稍后会查看这个类，但就目前而言，我们只需要知道我们将在这个类中封装我们的REST调用。在这里，我们正在调用一个端点（我们尚未看到）来获取这个对话另一端的电话号码的联系人信息。
- en: 'We also need to create the conversation snippet as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要按照以下方式创建对话摘要：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using `VBox` to ensure vertical alignment, we create two labels, one with the
    participants' information, and the other with the snippet of the conversation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`VBox`确保垂直对齐，我们创建两个标签，一个包含参与者的信息，另一个包含对话的摘要。
- en: 'While that finishes the cell definition, if we were to run the application
    the way it is now, the `ListCell`''s contents would likely be cropped by the edge
    of `ListView` itself. For example, see the difference between the top list and
    the bottom list in the following screenshot:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当那部分完成单元格定义后，如果我们现在就运行应用程序，`ListCell`的内容可能会被`ListView`本身的边缘裁剪。例如，看看以下截图中的顶部列表和底部列表之间的区别：
- en: '![](img/3c21078d-c23b-4f6a-9700-2d0bf3b12872.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c21078d-c23b-4f6a-9700-2d0bf3b12872.png)'
- en: 'To make our `ListCell` behave as we see at the bottom of the last screen, we
    need to make one more change to our code, which is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的`ListCell`表现得像我们在最后一屏底部看到的那样，我们需要对我们的代码进行一个额外的更改，如下所示：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In our preceding `CellFactory`, we pass in the reference to the enclosing `ListView`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的`CellFactory`中，我们传递了引用到封装的`ListView`。
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the constructor, we then bind the preferred width of our cell to the actual
    width of the list (and subtract a small amount to adjust for the control borders).
    When rendered now, our cell will wrap just as we expected.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将我们单元格的首选宽度绑定到列表的实际宽度（并减去一小部分以调整控件边框）。现在渲染时，我们的单元格将像我们预期的那样自动换行。
- en: 'The `MessageCell` definition is similar, and goes as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageCell`的定义类似，如下所示：'
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For *my* message, we create the contents this way:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*我的*消息，我们这样创建内容：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The *their* message is created this way:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*对方*的消息是这样创建的：'
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is similar to the *my* message, with the exception that we display the
    sender's profile picture, if there is one associated with the contact on the phone,
    which we retrieve from the phone via the `ConversationService` class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这与*我的*消息类似，但不同之处在于我们显示发送者的个人资料图片，如果手机上与联系人相关联的话，我们可以通过`ConversationService`类从手机中检索到。
- en: 'We have a bit more work to do, but this is what the application will look like
    with data:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有更多的工作要做，但这就是有数据的应用程序的外观：
- en: '![](img/2e658425-c23c-4c95-8cf0-843f21db6233.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e658425-c23c-4c95-8cf0-843f21db6233.png)'
- en: 'To get the data, we need a REST client, and that is found in `ConversationService`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取数据，我们需要一个REST客户端，这可以在`ConversationService`中找到：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using the so-called *Initialize-on-Demand Holder* idiom, we create a sort of
    a poor man''s singleton. Since the constructor is private, it can''t be called
    from outside this class. The nested static class, `LazyHolder`, is initialized
    only when it is finally referenced, which happens on the first call to `getInstance()`.
    Once that method is called, `LazyHolder` is loaded and initialized, at which point,
    the constructor is run. The instance created is stored in the static variable,
    and lives as long as the JVM runs. Every subsequent call will return the same
    instance. This is important for us, as we have some objects that are expensive
    to create as well as some simple caching in the class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所谓的 *按需初始化持有者* 习语，我们创建了一种类似穷人的单例。由于构造函数是私有的，所以它不能从类外部调用。嵌套的静态类 `LazyHolder`
    只在最终引用时初始化，这发生在对 `getInstance()` 的第一次调用时。一旦该方法被调用，`LazyHolder` 就会被加载和初始化，此时构造函数会被运行。创建的实例存储在静态变量中，只要
    JVM 运行，它就会存在。后续的每次调用都将返回相同的实例。这对我们来说很重要，因为我们有一些创建成本高昂的对象，以及一些简单的类内缓存：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, we initialize our client instance, registering the `JacksonFeature`,
    which gets us the POJO mapping we've already discussed. We also register `SseFeature`,
    a more advanced feature of Jersey that we'll discuss in detail later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们初始化了客户端实例，注册了 `JacksonFeature`，这为我们提供了之前讨论过的 POJO 映射。我们还注册了 `SseFeature`，这是
    Jersey 的一个更高级的功能，我们将在稍后详细讨论。
- en: 'We''ve already seen the conversation list. That is generated using data from
    this method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了会话列表。这是使用此方法的数据生成的：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`WebTarget` is a JAX-RS class that represents the *resource target identified
    by the resource URI*. We''re pulling the address for the phone from preferences,
    which we''ll discuss later. Once we have our `WebTarget`, we complete building
    the URI by appending `conversations`, specify the request mime type, and issue
    the `GET` request. Note that our request here is somewhat optimistic, as we don''t
    do any status code checking. Should an `Exception` be thrown, we simply return
    an empty `List`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTarget` 是一个 JAX-RS 类，它表示由资源 URI 标识的 *资源目标*。我们从偏好设置中获取电话地址，这我们稍后讨论。一旦我们有了
    `WebTarget`，我们就通过添加 `conversations` 来完成 URI 的构建，指定请求的 MIME 类型，并发出 `GET` 请求。请注意，我们这里的请求有些乐观，因为我们没有进行任何状态码检查。如果抛出
    `Exception`，我们只需返回一个空的 `List`。'
- en: 'The other method we''ve seen is `getParticipant()`, which is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到的另一个方法是 `getParticipant()`，如下所示：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the last method, we see our cache come into play. When a `Participant` is
    requested, we look to see if this information has already been fetched. If so,
    we return the cached information. If not, we can make a request for it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个方法中，我们看到我们的缓存开始发挥作用。当请求 `Participant` 时，我们会查看是否已经获取了这些信息。如果是这样，我们就返回缓存的信息。如果不是，我们可以请求它。
- en: Much like `getConversations(),` we build a request for the appropriate endpoint,
    and send the `GET` request. This time, though, we do check for the status code.
    Only if the status is `200 (OK)` do we continue processing the response. In this
    case, we ask JAX-RS for the `Participant` instance returned, which `JacksonFeature`
    happily builds for us from the JSON response body, and which we immediately add
    to our cache.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `getConversations()` 类似，我们为适当的端点构建一个请求，并发送 `GET` 请求。不过，这次我们确实检查了状态码。只有当状态为
    `200 (OK)` 时，我们才继续处理响应。在这种情况下，我们请求 JAX-RS 返回的 `Participant` 实例，`JacksonFeature`
    会从 JSON 响应体中为我们构建它，并且我们立即将其添加到我们的缓存中。
- en: If the server found a thumbnail for the contact, we need to process that. The
    server piece, which we will look at immediately after we finish discussing this
    method, sends the thumbnail as a base 64-encoded string in the body of the JSON
    object, so we convert it back to the binary representation, and save that to a
    file. Notice that we are using try-with-resources, so we need not worry about
    cleaning up after ourselves.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器找到了联系人的缩略图，我们需要处理它。服务器部分，我们将在讨论完这个方法后立即查看，它将缩略图作为 base 64 编码的字符串发送到 JSON
    对象的主体中，因此我们将其转换回二进制表示，并将其保存到文件中。请注意，我们正在使用 try-with-resources，所以我们不需要担心清理。
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We haven''t seen the server side of this operation, so let''s look at that
    now. In our Android application in Android Studio, we have this method on `DeskDroidResource`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到这个操作的客户端，所以现在让我们看看它。在我们的 Android 应用程序中，Android Studio 的 `DeskDroidResource`
    上有这个方法：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We attempt to build the `Participant` instance. If an Exception is thrown, we
    return a `500` (Server Error). If `null` is returned, we return a `404` (Not Found).
    If a participant is found, we return `200` (OK) and the participant.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试构建`Participant`实例。如果抛出异常，我们返回`500`（服务器错误）。如果返回`null`，我们返回`404`（未找到）。如果找到参与者，我们返回`200`（OK）和参与者。
- en: 'To build the participant, we need to query the phone contacts. This works in
    much the same way as the SMS queries:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建参与者，我们需要查询电话联系人。这与SMS查询的工作方式几乎相同：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding is the same type of query and cursor management that we saw earlier
    with conversations, but there is one exception. If the contact has a thumbnail,
    the query returns a `Uri` to that image. We can use `ContentResolver` to open
    an `InputStream` using that `Uri` to read the contents, which we load into `ByteArrayOutputStream`.
    Using Android's `Base64` class, we encode this binary image into a `String`, and
    add that to our `Participant` model. We saw the decoding half of this operation
    previously.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询和光标管理类型与之前我们看到的对话相同，但有一个例外。如果联系人有一个缩略图，查询将返回一个指向该图像的`Uri`。我们可以使用`ContentResolver`通过该`Uri`打开一个`InputStream`来读取内容，然后将其加载到`ByteArrayOutputStream`中。使用Android的`Base64`类，我们将这个二进制图像编码成一个`String`，并将其添加到我们的`Participant`模型中。我们之前已经看到了这个操作的解码部分。
- en: Sending messages
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送消息
- en: 'Now that we can see the conversations that we''ve been having, we need to add
    the ability to take part in those conversations--to send new text messages. We''ll
    start on the client. We''ve actually already seen the handler for the `New Message`
    button assigned. It is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够看到我们一直在进行的对话，我们需要添加参与这些对话的能力——发送新的文本消息。我们将从客户端开始。实际上，我们已经在`New Message`按钮的处理器上看到了。如下所示：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'What we need to do now is to look at this `sendNewMessage()` method itself:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要查看这个`sendNewMessage()`方法本身：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The actual dialog is displayed in another window, so we have a separate FXML
    file, `message_dialog.fxml`, and controller, `SendMessageDialogController`. When
    the dialog closes, we check the return `Optional` to see if the user entered a
    message. If so, process the message as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的对话框在另一个窗口中显示，因此我们有一个单独的FXML文件`message_dialog.fxml`和控制器`SendMessageDialogController`。当对话框关闭时，我们检查返回的`Optional`以查看用户是否输入了消息。如果是这样，按照以下方式处理消息：
- en: Get a reference to the selected `Conversation`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所选`Conversation`的引用。
- en: Create a new message, setting the conversation ID, recipient, and body.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一条新消息，设置会话ID、收件人和正文。
- en: 'Using `ConversationService`, we attempt to send the message:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ConversationService`尝试发送消息：
- en: If successful, we update the user interface with the new message.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果操作成功，我们将更新用户界面以显示新消息。
- en: If unsuccessful, we display an error message.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果操作失败，我们将显示一个错误消息。
- en: '`SendMessageController` works just like the other controllers we''ve looked
    at. The most interesting is the method `showAndWait()`. We''ll use that method
    to show the dialog, wait for it to close, and return any user response to the
    caller. The dialog looks as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendMessageController`的工作方式与我们所查看的其他控制器一样。最有趣的是`showAndWait()`方法。我们将使用该方法来显示对话框，等待其关闭，并将任何用户响应返回给调用者。对话框如下所示：'
- en: '![](img/aa10e162-71fb-425f-9087-69c8e4abe267.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa10e162-71fb-425f-9087-69c8e4abe267.png)'
- en: 'The method looks as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法如下所示：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The first few lines in the preceding method are what we''ve normally seen,
    which is creating the loader and the `Stage`. Before showing the `Stage`, we set
    the modality, and pass in the current `Conversation`. Finally, we call `showAndWait()`,
    at which point the method blocks until the user closes the dialog, and then we
    return the entered message:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，前几行是我们通常看到的，即创建加载器和`Stage`。在显示`Stage`之前，我们设置模式，并传入当前的`Conversation`。最后，我们调用`showAndWait()`，此时方法会阻塞，直到用户关闭对话框，然后我们返回输入的消息：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A Java `Optional` is a *container object which may or may not contain a non-null
    value*. The value of `message` may or may not be set depending on which button
    is clicked in the dialog. Using the `Optional`, we can return a, possibly, null
    value, and handle it more safely in the caller--`if (result.isPresent())`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Java的`Optional`是一个*可能包含或不包含非空值的容器对象*。`message`的值可能设置或不设置，这取决于在对话框中点击哪个按钮。使用`Optional`，我们可以返回一个可能为null的值，并在调用者中更安全地处理它——`if
    (result.isPresent())`。
- en: 'The sending of the message is a simple POST operation in the `ConversationService`,
    which is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ConversationService`中发送消息是一个简单的POST操作，如下所示：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The client side is simple, but what about the server side? Unsurprisingly,
    that''s where the complexity lies:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端很简单，但服务器端呢？不出所料，复杂性就在这里：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To add the endpoint, we define a new method with the correct annotations. This
    method will listen on the path `conversations` for `POST` requests, and expect
    a `Message` as its payload. The actual work of sending a message is handled by
    `SmsManager`, so we acquire a reference to the default manager. The next step
    calls `divideMessage()`, but what's that all about?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加端点，我们定义一个新的方法，并使用正确的注解。这个方法将监听`conversations`路径的`POST`请求，并期望其有效载荷为`Message`。发送消息的实际工作由`SmsManager`处理，所以我们获取默认管理器的引用。下一步调用`divideMessage()`，但这究竟是怎么回事？
- en: Text messages are technically limited to 160 characters. Twitter users are probably
    somewhat familiar with that already. Twitter limits tweets to 140 characters,
    leaving 20 characters for the sender's name. While Twitter has stuck hard to that
    limit, regular SMS users have a better experience. If the message is longer than
    160 characters, most modern phones will chunk the message into 153 character segments
    when sending (with 7 characters for segmentation information used to piece the
    segments back together), which are merged back into one message on the receiving
    end if the phone supports it. The `SmsManager` API handles this complexity for
    us with `divideMessage()`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 文本消息在技术上限制为160个字符。Twitter用户可能已经对这一点有所了解。Twitter将推文限制为140个字符，为发送者姓名留下20个字符。虽然Twitter一直坚持这个限制，但常规短信用户有更好的体验。如果消息超过160个字符，大多数现代手机在发送时会将消息分成153个字符的片段（使用7个字符的分割信息用于将片段重新组合），如果手机支持，这些片段在接收端会合并成一个消息。`SmsManager`
    API通过`divideMessage()`为我们处理这个复杂性。
- en: 'Once the message is *chunked*, though, our job gets a little more difficult.
    We would like to be able to return a status code indicating whether or not the
    message was sent successfully. To do that, we need to check the status of each
    chunk of the message, be it one or ten. Sending a text message with `SmsManager`,
    Android broadcasts an `Intent` with the results. To react to that, we need to
    register a receiver. Put that all together, and we get this code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦消息被分割，我们的工作就变得有点困难。我们希望能够返回一个状态码，指示消息是否成功发送。为此，我们需要检查消息的每个片段的状态，无论是单个还是十个。使用`SmsManager`发送短信时，Android会广播一个带有结果的`Intent`。为了响应这个，我们需要注册一个接收器。把这些放在一起，我们就得到了以下代码：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To make sure that we've received the `Intent` for each message chunk, we start
    by creating a `CountDownLatch` with a count matching the number of chunks in the
    message. We also create an `AtomicInteger` to hold the status code. The reason
    we do this is that we need a final variable which we can access from our `BroadcastReceiver`,
    but we also need to be able to change the value. `AtomicInteger` allows us to
    do that.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们已经收到了每个消息片段的`Intent`，我们首先创建一个与消息中片段数量相匹配的`CountDownLatch`。我们还创建了一个`AtomicInteger`来保存状态码。我们这样做的原因是我们需要一个可以从我们的`BroadcastReceiver`访问的最终变量，但我们还需要能够改变它的值。`AtomicInteger`允许我们这样做。
- en: We create and register a `BroadcastReceiver`, which analyzes the result code
    on `Intent`. If it's not `Activity.RESULT_OK`, we set `statusCode` to `INTERNAL_SERVER_ERROR`.
    Either way, we count down the latch.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建并注册了一个`BroadcastReceiver`，它分析`Intent`上的结果代码。如果不是`Activity.RESULT_OK`，我们将`statusCode`设置为`INTERNAL_SERVER_ERROR`。无论如何，我们都减少闩锁的计数。
- en: With our receiver ready, we create a `List` of `PendingIntent`s, one for each
    chunk, then we pass that, with our list of message chunks, to `SmsManager.sendMultipartTextMessage()`.
    Message sending is asynchronous, so we call `sentLatch.await()` to wait for the
    results to be returned. We limit the wait to five seconds so that we don't wait
    forever. Once the wait time expires or the latch is cleared, we unregister our
    receiver and return the status code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的接收器准备就绪后，我们创建一个`PendingIntent`的`List`，每个片段一个，然后我们将这个列表和我们的消息片段列表一起传递给`SmsManager.sendMultipartTextMessage()`。消息发送是异步的，所以我们调用`sentLatch.await()`等待结果返回。我们限制等待时间为五秒，以免永远等待。一旦等待时间到期或闩锁被清除，我们就注销我们的接收器并返回状态码。
- en: Getting updates
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取更新
- en: So far, we can see all of the conversations, view individual messages in a conversation,
    and send new messages. What we can't do yet is get updates when new messages arrive
    on the device, so let's implement that now, starting with the server piece this
    time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以看到所有的对话，查看对话中的单个消息，并发送新的消息。但我们目前还无法在设备上收到新消息的更新，所以现在让我们来实现这个功能，从服务器端开始。
- en: 'To get a constant stream of events, we''ll use a feature called Server-Sent
    Events, a W3C specification for receiving push notifications from the server.
    We enabled this feature in Jersey by registering the `SseFeature` in both the
    client and server setup steps. To create an SSE endpoint, we specify that the
    method returns the media type `SERVER_SENT_EVENTS`, and we return an `EventOutput`
    as the payload:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一个持续的事件流，我们将使用一个名为Server-Sent Events的功能，这是一个W3C规范，用于从服务器接收推送通知。我们在Jersey中通过在客户端和服务器设置步骤中注册`SseFeature`来启用此功能。为了创建一个SSE端点，我们指定方法返回的媒体类型为`SERVER_SENT_EVENTS`，并且我们将`EventOutput`作为有效负载返回：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'From the Jersey documentation, we learn this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从Jersey文档中，我们了解到如下内容：
- en: After the eventOutput is returned from the method, the Jersey runtime recognizes
    that this is a ChunkedOutput extension and does not close the client connection
    immediately. Instead, it writes the HTTP headers to the response stream and waits
    for more chunks (SSE events) to be sent. At this point the client can read headers
    and starts listening for individual events.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法返回`eventOutput`之后，Jersey运行时识别出这是一个ChunkedOutput扩展，并且不会立即关闭客户端连接。相反，它将HTTP头写入响应流，并等待发送更多块（SSE事件）。此时，客户端可以读取头信息，并开始监听单个事件。
- en: 'The server, then, keeps the socket to the client open, and pushes data down
    it. But where does the data come from? The Server-sent Event endpoints create
    a `Thread` that writes data to the `EventOutput` instance we created earlier.
    When the `Thread` is finished, it calls `eventOutput.close()`, which signals to
    the runtime that it is appropriate to close the client connection. To stream updates,
    our `Thread` looks as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器保持与客户端的套接字打开，并将数据推送到它。但是数据从哪里来？Server-sent Event端点创建了一个`Thread`，将数据写入我们之前创建的`EventOutput`实例。当`Thread`完成后，它调用`eventOutput.close()`，这向运行时发出信号，表明适当地关闭客户端连接是合适的。为了流式传输更新，我们的`Thread`看起来如下所示：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As we've seen before, we set up a `BroadcastReceiver`, which we register here
    and unregister before the `Thread` ends, but this time, we're listening for broadcasts
    that an SMS message has been received. To make sure our `Thread` isn't in a small,
    tight, fast loop, which would quickly kill the battery on the device, we use `LinkedBlockingQueue`.
    When a message is received, we pull the `SmsMessage`(s) from `Intent`, and add
    them to `queue`. In our while loop, we attempt to `take()` an item from `queue`.
    If we find one, we process it and any more that might either already be in the
    queue or be added while we are processing. Once `queue` is empty, we go back to
    waiting. We have a timeout on `take()` to make sure that the thread can respond
    to the exit criteria, most notably, the client disconnecting. This will run as
    long as the client remains connected. Let's look, then, at the client.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们设置了一个`BroadcastReceiver`，在这里注册并在`Thread`结束时注销，但这次，我们正在监听接收到的短信消息广播。为了确保我们的`Thread`不在一个小的、紧密的、快速的循环中，这样会迅速耗尽设备的电池，我们使用了`LinkedBlockingQueue`。当收到消息时，我们从`Intent`中提取`SmsMessage`(s)，并将它们添加到`queue`中。在我们的while循环中，我们尝试从`queue`中`take()`一个项目。如果我们找到一个，我们处理它以及在我们处理过程中可能已经存在于队列中或被添加的项目。一旦`queue`为空，我们就返回等待。我们在`take()`上设置了一个超时，以确保线程可以响应退出条件，最值得注意的是，客户端断开连接。只要客户端保持连接，这个操作就会继续。那么，让我们看看客户端。
- en: 'We encapsulated the details in `ConversationService.subscribeToNewMessageEvents()`
    as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将细节封装在`ConversationService.subscribeToNewMessageEvents()`中，如下所示：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the preceding code, we create a `Thread`, in which we make the call to the
    SSE endpoint. The return type on the client is `EventInput`. We loop to process
    each incoming event, which we get as an `InboundEvent`. If it is null, then the
    connection has been closed, so we break out of our processing loop. If it is not
    null, we make sure that the event name matches what we're waiting for--`new-message`.
    If found, we extract the event payload, a `Message`, and call our callback, which
    we pass in as `Consumer<Message>`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`Thread`，在其中调用SSE端点。客户端的返回类型是`EventInput`。我们循环处理每个传入的事件，我们将其作为`InboundEvent`获取。如果它是null，那么连接已经关闭，因此我们退出处理循环。如果不是null，我们确保事件名称与我们等待的匹配--`new-message`。如果找到，我们提取事件有效负载，一个`Message`，并调用我们的回调，我们将其作为`Consumer<Message>`传递。
- en: 'From the application proper, we subscribe to the status stream this way:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序本身，我们这样订阅状态流：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`handleMessageReceived()` looks like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleMessageReceived()`看起来是这样的：'
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first step in handling this new message is very important--we pass a `Runnable`
    to `Platform.runLater()`. If we don't do this, any attempts to modify the user
    interface will fail. You have been warned. In our `Runnable`, we create a `Stream`
    of `Conversation`s, `filter()` it, looking for a `Conversation` whose participant
    matches the `Message` sender, then grab the first (and only) match.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这条新消息的第一步非常重要--我们向 `Platform.runLater()` 传递一个 `Runnable`。如果我们不这样做，任何尝试修改用户界面的操作都将失败。我们已经警告过您。在我们的
    `Runnable` 中，我们创建一个 `Conversation` 的 `Stream`，使用 `filter()` 查找与 `Message` 发送者匹配的
    `Conversation`，然后获取第一个（也是唯一一个）匹配项。
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If we don't find the `Conversation` in the list, we create a new one, and add
    it to the `ConversationObservable`, which results in the `List` automatically
    updating on the screen.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在列表中没有找到 `Conversation`，我们创建一个新的，并将其添加到 `ConversationObservable` 中，这会导致屏幕上的
    `List` 自动更新。
- en: Finally, we attempt a couple of desktop integration tasks. If `Taskbar` supports
    the `USER_ATTENTION` feature, we request user attention. From the Javadocs we
    learn that, *depending on the platform, this may be visually indicated by a bouncing
    or flashing icon in the task area*. Regardless, we issue a beep to get the user's
    attention.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们尝试执行一些桌面集成任务。如果 `Taskbar` 支持的 `USER_ATTENTION` 功能，我们将请求用户注意。从 Javadocs
    中我们了解到，*根据平台的不同，这可能会在任务区域中以弹跳或闪烁的图标来视觉上表示*。无论如何，我们发出蜂鸣声以吸引用户的注意。
- en: Security
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: There's one last major piece that we haven't discussed, and that's security.
    Currently, anybody with the desktop application can, in theory, connect to your
    phone, see your messages, send others, and so on. Let's fix that now.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论的最后一件重要的事情是安全性。目前，任何拥有桌面应用程序的人理论上都可以连接到您的手机，查看您的消息，发送给其他人等等。让我们现在解决这个问题。
- en: Securing the endpoints
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护端点
- en: 'To secure the REST server, we will use a filter just like we used in [Chapter
    25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml), *Taking Notes with Monumentum*.
    We''ll start by defining the annotation that will specify which endpoints need
    to be secured, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护 REST 服务器，我们将使用一个与我们在 [第 25 章](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml)，*使用
    Monumentum 记笔记* 中使用的过滤器一样。我们将首先定义一个注解，该注解将指定哪些端点需要被保护，如下所示：
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will apply this preceding annotation to each secured endpoint (annotations
    condensed to one line for brevity):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用此前的注解到每个受保护的端点（为了简洁，将注解压缩到一行）：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will also need a filter to enforce security, which we add as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个过滤器来强制执行安全性，我们添加如下：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Much like in [Chapter 25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml), *Taking
    Notes with Monumentum*, we''ll be using **JSON Web Tokens** (**JWT**) to help
    authenticate and authorize clients. In this filter, we extract the JWT from the
    request headers and validate it through these steps:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 [第 25 章](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml)，*使用 Monumentum 记笔记*，我们将使用
    **JSON Web Tokens** (**JWT**) 来帮助验证和授权客户端。在这个过滤器中，我们从请求头中提取 JWT 并通过以下步骤进行验证：
- en: Get the signing key from `KeyGenerator`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `KeyGenerator` 获取签名密钥。
- en: Create the `JwtParser` using the signing key.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用签名密钥创建 `JwtParser`。
- en: Parse the claims in the JWT. For our purposes here, this is, basically, just
    a validation of the token itself.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析 JWT 中的声明。就我们这里的用途而言，这基本上只是对令牌本身的验证。
- en: Abort the request with `UNAUTHORIZED` (`401`) should the token be invalid.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果令牌无效，则使用 `UNAUTHORIZED` (`401`) 中断请求。
- en: 'The `KeyGenerator` itself looks a bit like what we saw in [Chapter 25](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml),
    *Taking Notes with Monumentum*, but has been modified to use Android APIs in this
    manner:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyGenerator` 本身看起来有点像我们在 [第 25 章](0813704c-2f66-4efa-bbef-f0147dcfb059.xhtml)，*使用
    Monumentum 记笔记* 中看到的，但已经修改为使用 Android API 以这种方式：'
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Since we might possibly receive requests from multiple clients at a time, we
    need to be careful about how the key is generated. To make sure it's done once
    and only once, we'll use the same type of synchronization/locking we saw in the
    server startup.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能同时接收到来自多个客户端的请求，我们需要小心地生成密钥。为了确保它只生成一次，我们将使用我们在服务器启动中看到的相同类型的同步/锁定。
- en: Once we've acquired the lock, we perform a null check to see if the process
    has already generated (or read) the key. If not, we then read the signing key
    from `SharedPreferences`. If it's null, we create a random string (here, just
    a UUID), and save it to `SharedPreferences` for reuse next time. Note that to
    save to Android preferences, we have to get an instance of `SharedPreferences.Editor`,
    write the string, then `commit()`. Once we have the signing key, we create the
    actual `SecretKeySpec` that we'll use to sign and verify our JWTs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了锁，我们会进行一个空检查，以查看该过程是否已经生成了（或读取了）密钥。如果没有，然后我们从`SharedPreferences`读取签名密钥。如果它是null，我们创建一个随机字符串（这里，只是一个UUID），并将其保存到`SharedPreferences`以供下次重用。请注意，为了保存到Android首选项，我们必须获取`SharedPreferences.Editor`的一个实例，写入字符串，然后`commit()`。一旦我们有了签名密钥，我们就创建实际的`SecretKeySpec`，我们将使用它来签名和验证我们的JWT。
- en: Handling authorization requests
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理授权请求
- en: 'With our endpoints now secured, we need a way for the clients to request authorization.
    To do that, we''ll expose a new endpoint, unsecured, of course, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经保护了端点，我们需要一种方式让客户端请求授权。为此，我们将公开一个新的未加密端点，如下所示：
- en: '[PRE64]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Rather than require a more complicated authorization system that might require
    a username and password or an OAuth2 provider, what we''ll implement is a simple
    system that requires only a random number:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个简单的系统，只需要一个随机数，而不是要求一个更复杂的授权系统，可能需要用户名和密码或OAuth2提供者：
- en: On the phone, the user requests that a new client be added, and is presented
    with a random number.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手机上，用户请求添加一个新的客户端，并显示一个随机数。
- en: In the desktop application, the user enters the number, which the desktop application
    then POSTs to the server.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在桌面应用程序中，用户输入数字，然后桌面应用程序将其POST到服务器。
- en: If the numbers match, the client is given a JWT, which it will send with every
    request.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字匹配，客户端将获得一个JWT，它将在每次请求中发送。
- en: The JWT is verified each time to make sure the client is authorized to access
    the target resource.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次验证JWT，以确保客户端有权访问目标资源。
- en: In this method, we get the number POSTed by the client (which we let JAX-RS
    extract from the request body), then compare it to the number generated on the
    phone. If they match, we create the JWT, and return it to the client. Before doing
    so, we broadcast an intent with the action `CODE_ACCEPTED`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们获取客户端POST的数字（我们让JAX-RS从请求体中提取），然后将其与手机上生成的数字进行比较。如果它们匹配，我们创建JWT，并将其返回给客户端。在这样做之前，我们广播一个动作为`CODE_ACCEPTED`的意图。
- en: 'Where does the number come from, and why are we broadcasting this intent? We
    haven''t looked at this in detail yet, but in the main layout, `activity_main.xml`,
    there is a `FloatingActionButton`. To this, we attach an `onClick` listener as
    follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字从哪里来，为什么我们要广播这个意图？我们还没有详细查看，但在主布局`activity_main.xml`中有一个`FloatingActionButton`。我们将一个`onClick`监听器附加到它上，如下所示：
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'When the user taps on the button, the following screen will be shown:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，以下屏幕将显示：
- en: '![](img/6ee9cc7e-5b78-4b88-a9eb-da7ab9851a8e.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ee9cc7e-5b78-4b88-a9eb-da7ab9851a8e.png)'
- en: 'The client will use this information to connect and gain authorization. The
    `Activity` itself is fairly basic. It needs to present the IP address and code,
    and then respond to a client connecting. All of this is done in `onCreate()` in
    our new `AuthorizeClientActivity` class. We get the IP from `WifiManager`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将使用这些信息来连接并获得授权。`Activity`本身相当基础。它需要展示IP地址和代码，然后响应用户连接。所有这些都在我们的新`AuthorizeClientActivity`类的`onCreate()`方法中完成。我们从`WifiManager`获取IP：
- en: '[PRE66]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Remember that we require that the client be on a Wi-Fi network. The code is
    just a random, 6-digit number:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们要求客户端在Wi-Fi网络上。代码只是一个随机的6位数：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To listen for the `Intent` we saw earlier, which indicates that a client has
    been authenticated (which, presumably, will happen shortly after this `Activity`
    has been displayed), we register another receiver as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监听我们之前看到的`Intent`，它表示客户端已被认证（这，据推测，将在此`Activity`显示后不久发生），我们注册另一个接收器，如下所示：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We also need to tell the `Service` what this new code is so that it can verify
    it. To do that, we broadcast an `Intent` as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要告诉`Service`这个新代码是什么，以便它可以验证它。为此，我们按照以下方式广播一个`Intent`：
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We've already seen the other half of this broadcast in `DeskDroidService.onStartCommand()`
    earlier, where the code is retrieved from the `Intent`, and stored in the service
    for use by `DeskDroidResource.getAuthorization()`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经在`DeskDroidService.onStartCommand()`中看到了这个广播的另一部分，其中代码从`Intent`中检索出来，并存储在服务中以供`DeskDroidResource.getAuthorization()`使用。
- en: 'Finally, this method, which handles the authentication notice, simply cleans
    up the receiver and closes the `Activity`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个处理认证通知的方法，只是简单地清理接收器并关闭`Activity`：
- en: '[PRE70]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With this, when a client connects and successfully authenticates, the `Activity`
    closes, and the user is returned to the main `Activity`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当客户端连接并成功认证后，`Activity`关闭，用户返回到主`Activity`。
- en: Authorizing the client
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权客户端
- en: Up until this point, everything has assumed that the desktop is already connected
    to the phone. We have enough pieces in place now that we can talk about that in
    a meaningful manner.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有假设都是桌面已经连接到手机。现在我们已经有了足够的组件，可以有意义地讨论这一点。
- en: 'In the application''s main `Menu`, we have two `MenuItem`s: `Connect to Phone`
    and `Disconnect from Phone`. The `Connect to Phone` handler looks as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的主`菜单`中，我们有两个`MenuItem`：`连接到手机`和`从手机断开连接`。`连接到手机`处理器的样子如下：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We''re going to use the now-familiar `showAndWait()` pattern to display a modal
    dialog, and to get the response using the new `ConnectToPhoneController`. The
    user interface is very simple, and is shown in this screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用现在熟悉的`showAndWait()`模式来显示模态对话框，并使用新的`ConnectToPhoneController`获取响应。用户界面非常简单，如下截图所示：
- en: '![](img/195ad74a-3937-4595-980c-321fd1d35bec.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/195ad74a-3937-4595-980c-321fd1d35bec.png)'
- en: 'When the user clicks on OK, we save the address and the code in the application''s
    preferences, then attempt to authorize against the server, as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击“确定”时，我们将地址和代码保存到应用程序的首选项中，然后尝试如下授权服务器：
- en: '[PRE72]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Notice the use of `Optional<String>` as the return type for `ConversationService.getAuthorization()`.
    Using `Optional`, as we've discussed before, makes working with potentially `null`
    values much safer. In this case, if `Optional` has a value present, then we've
    successfully authenticated. So, we save the token to preferences, and close the
    dialog.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`ConversationService.getAuthorization()`的返回类型使用了`Optional<String>`。正如我们之前讨论的，使用`Optional`使处理可能为`null`的值更加安全。在这种情况下，如果`Optional`有值，那么我们已经成功认证。因此，我们将令牌保存到首选项中，并关闭对话框。
- en: 'The actual authentication is handled by `ConversationService`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的认证由`ConversationService`处理：
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This last method sends the code to the server via a `POST`, and if the status
    code is `200`, we create an `Optional` with the returned token. Otherwise, we
    return an empty `Optional`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的方法通过`POST`将代码发送到服务器，如果状态码是`200`，我们创建一个包含返回令牌的`Optional`。否则，我们返回一个空的`Optional`。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a different kind of project. We've had applications
    that run on Android, and some that run on the desktop. This one, though, runs
    on both platforms simultaneously. One is no good without the other. That requires
    that we build things a bit differently to make sure the two are synchronized.
    While there are a variety of ways to go about this, we chose to use a REST server
    on the phone, with the desktop acting as a REST client.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个不同类型的项目。我们之前有在Android上运行的应用程序，也有一些在桌面上运行。然而，这个项目同时运行在两个平台上。没有一个是好的，这需要我们以不同的方式构建东西，以确保两者同步。虽然有很多方法可以做到这一点，但我们选择在手机上使用REST服务器，桌面作为REST客户端。
- en: By the end of the chapter, we built an Android application that provides not
    only a user interface, but a background process (called `Service`), and embedded
    our REST server in the Android application using Jersey and its Java SE deployment
    option. You also learned how to interact with text (SMS) messages on Android using
    the system-provided Content Providers and platform APIs, and streaming those messages
    to the client using Server-Sent Events. We demonstrated how to send messages between
    processes/threads in Android using `Intent`s, broadcasts, and `BroadcastReceiver`s.
    Finally, on the desktop side, we built a JavaFX client to display and send text
    messages, which connects to the REST server on the phone via the Jersey REST client,
    and we consumed the Server-sent Event stream, updating the user interface as appropriate.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们构建了一个Android应用程序，它不仅提供了一个用户界面，还包含一个后台进程（称为`Service`），并使用Jersey及其Java
    SE部署选项将REST服务器嵌入到Android应用程序中。你还学习了如何使用系统提供的Content Providers和平台API在Android上与文本（SMS）消息交互，并使用服务器发送事件将这些消息流式传输到客户端。我们展示了如何使用`Intent`s、广播和`BroadcastReceiver`s在Android中在进程/线程之间发送消息。最后，在桌面端，我们构建了一个JavaFX客户端来显示和发送文本消息，该客户端通过Jersey
    REST客户端连接到手机上的REST服务器，并消费服务器发送事件流，根据需要更新用户界面。
- en: With all of the moving parts, this was probably the most complex of our projects.
    It was certainly a great way to round out our list of projects. In the next chapter,
    we'll take a look at what's next for Java, as well as some other technologies
    that might be good to have on your radar.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及众多移动部件，这可能是我们项目中最为复杂的。这无疑是我们项目列表的一个圆满结束。在下一章中，我们将探讨Java的未来发展方向，以及一些可能值得关注的其它技术。
