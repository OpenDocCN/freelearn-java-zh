- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Microservice Security with OAuth 2 and JSON Web Tokens
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务安全性使用 OAuth 2 和 JSON Web Tokens
- en: In this chapter, we will look at microservices-based architectures and look
    at how **OAuth 2** with **JSON Web Tokens** (**JWT**) plays a role in securing
    microservices in a Spring- based application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨基于微服务的架构，并查看如何使用 **OAuth 2** 和 **JSON Web Tokens** (**JWT**) 在基于 Spring
    的应用程序中确保微服务的安全性。
- en: 'The following is a list of topics that will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本章中将要涉及的主题列表：
- en: The general difference between **monolithic applications** and **microservices**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单体应用** 和 **微服务** 之间的基本区别'
- en: Comparing **Service-Oriented Architectures** (**SOA**) with microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较 **面向服务的架构** (**SOA**) 和微服务
- en: The conceptual architecture of **OAuth 2** and how it provides your services
    with trustworthy client access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth 2** 的概念架构以及它如何为您的服务提供可信的客户端访问'
- en: Types of **OAuth 2** access tokens
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth 2** 访问令牌的类型'
- en: Types of **OAuth 2** grant types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth 2** 授权类型的种类'
- en: Examining JWT and their general structure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 JWT 及其一般结构
- en: Implementing a resource server and authentication server used to grant access
    rights to clients in order to access **OAuth** **2** resources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现资源服务器和认证服务器，用于授予客户端访问 **OAuth** **2** 资源的权利
- en: Implementing a **RESTful** client to gain access to resources through an **OAuth
    2** grant flow
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个 **RESTful** 客户端，通过 **OAuth 2** 授权流程访问资源
- en: We have quite a few items to cover in this chapter, but before we dig into the
    details of how to start leveraging `Spring Security` to implement **OAuth 2**
    and **JWT**, we first want to create a baseline of the calendar application that
    does not have **Thymeleaf** or any other browser- based user interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有相当多的内容要介绍，但在我们深入探讨如何利用 `Spring Security` 实现 **OAuth 2** 和 **JWT** 的细节之前，我们首先想要创建一个没有
    **Thymeleaf** 或任何其他基于浏览器的用户界面的日历应用程序的基础。
- en: After removing all **Thymeleaf** configuration and resources, the various controllers
    have been converted to **JAX-RS** **REST** controllers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除所有 **Thymeleaf** 配置和资源后，各种控制器已转换为 **JAX-RS** **REST** 控制器。
- en: 'This chapter’s code in action link is here: [https://packt.link/zEHBU](https://packt.link/zEHBU).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的实际链接在这里：[https://packt.link/zEHBU](https://packt.link/zEHBU)。
- en: Important note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You should start with the code from `chapter17.00-calendar`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从 `chapter17.00-calendar` 中的代码开始。
- en: What are microservices?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务是什么？
- en: '**Microservices** are an architectural approach that allows the development
    of physically separated modular applications which are autonomous, enabling agility,
    rapid development, continuous deployment, and scaling.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务** 是一种架构方法，它允许开发物理上分离的模块化应用程序，这些应用程序是自治的，能够实现敏捷性、快速开发、持续部署和扩展。'
- en: An application is built as a set of services, like `JSON` or `XML`, and this
    allows the aggregation of language-agnostic services. Basically, a service can
    be written in the best language for the task the service is being created for.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序作为一个服务集构建，如 `JSON` 或 `XML`，这允许聚合语言无关的服务。基本上，一个服务可以用最适合该服务创建任务的编程语言编写。
- en: Each service runs in its own process and is location neutral, thus it can be
    located anywhere on the access network.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都在自己的进程中运行，并且位置无关，因此可以在访问网络的任何地方定位。
- en: In the next sections, we will explore Monoliths, Microservices, and Service-oriented
    architectures and discern their variances. Then, we can delve into Microservices
    Security using spring-security.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨单体架构、微服务和面向服务的架构，并区分它们的差异。然后，我们可以深入研究使用 spring-security 的微服务安全性。
- en: Monoliths
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单体架构
- en: 'The microservices approach is the opposite of the traditional monolithic software
    approach, which consists of tightly integrated modules that ship infrequently
    and have to scale as a single unit. Traditional `JBCP calendar` application in
    this book are examples of monolithic applications. Look at the following diagram
    which depicts the monolithic architecture:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务方法与传统单体软件方法相反，后者由紧密集成的模块组成，不经常发货，并且必须作为一个单一单元进行扩展。本书中的传统 `JBCP 日历` 应用程序是单体应用的例子。请看以下图示，它描述了单体架构：
- en: '![Figure 17.1 – Monolithic architecture](img/B21757_17_1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.1 – 单体架构](img/B21757_17_1.jpg)'
- en: Figure 17.1 – Monolithic architecture
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 – 单体架构
- en: Although the monolithic approach fits well for some organizations and some applications,
    microservices is becoming popular with companies that need more options for agility
    and scalability in their ecosystem.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单体方法适合某些组织和某些应用程序，但对于需要更多灵活性和可扩展性的生态系统的公司来说，微服务正在变得流行。
- en: Microservices
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务
- en: 'A microservice architecture is a collection of small discrete services where
    each service implements a specific business capability. These services run their
    own process and communicate via an **HTTP API** usually using a **RESTful** service
    approach. These services are created to serve only one specific business function,
    such as user management, administrative roles, an e-commerce cart, a search engine,
    social media integration, and many others. Look at the following diagram which
    depicts the microservices architecture:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一组小型离散服务，其中每个服务实现特定的业务能力。这些服务运行自己的进程，并通过**HTTP API**进行通信，通常使用**RESTful**服务方法。这些服务是为了仅服务于一个特定的业务功能而创建的，例如用户管理、管理角色、电子商务购物车、搜索引擎、社交媒体集成等。请看以下图示，它描述了微服务架构：
- en: '![Figure 17.2 – Microservices architecture](img/B21757_17_2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图17.2 – 微服务架构](img/B21757_17_2.jpg)'
- en: Figure 17.2 – Microservices architecture
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 – 微服务架构
- en: Each service can be deployed, upgraded, scaled, restarted, and removed independently
    of other services in the application and other systems in the enterprise.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都可以独立于应用程序中的其他服务和企业中的其他系统进行部署、升级、扩展、重启和移除。
- en: Because each service is created independently of the other, they can each be
    written in different programming languages and use different data storage. Centralized
    service management is virtually non-existent, and these services use lightweight
    **HTTP**, **REST** communicating among themselves.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个服务都是独立创建的，因此它们可以分别用不同的编程语言编写并使用不同的数据存储。集中的服务管理几乎不存在，这些服务使用轻量级的**HTTP**、**REST**进行相互通信。
- en: Service-oriented architectures
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向服务的架构
- en: You might be asking yourself, “Isn’t this the same as SOA?” Not exactly, you
    could say **microservices** achieve what **SOA** promised in the first place.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，“这不是和SOA一样吗？” 不完全一样，你可以这样说**微服务**实现了**SOA**最初承诺的东西。
- en: An **SOA** is a style of software design where services are exposed to other
    components through a language-agnostic, communication protocol over a computer
    network.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOA** 是一种软件设计风格，其中服务通过计算机网络上的语言无关的通信协议暴露给其他组件。'
- en: The basic principle of **SOA** is to be independent of vendors, products, and
    technologies.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOA** 的基本原则是独立于供应商、产品和技术。'
- en: The definition of a service is a discrete unit of functionality that can be
    accessed remotely and acted upon and updated independently, such as retrieving
    a credit card statement online.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的定义是一个离散的功能单元，可以远程访问并独立执行和更新，例如在线检索信用卡对账单。
- en: Although similar, **SOA** and microservices are still different types of architectures.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类似，**SOA** 和微服务仍然是不同类型的架构。
- en: A typical **SOA** is often implemented inside deployment monoliths and is more
    platform driven, while microservices can be independently deployable and, therefore,
    offer more flexibility in all dimensions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的**SOA**通常是在部署单体中实现的，并且更受平台驱动，而微服务可以独立部署，因此在整个维度上提供了更多的灵活性。
- en: 'The key difference, of course, is the size; the word micro says it all. Microservices
    tend to be significantly smaller than regular **SOA** services. As *Martin* *Fowler*
    said:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关键区别当然是大小；微服务一词就说明了这一点。微服务通常比常规的**SOA**服务小得多。正如 *Martin* *Fowler* 所说：
- en: We should think about SOA as a superset of microservices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将SOA视为微服务的超集。
- en: Microservice security
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务安全
- en: Microservices can provide great flexibility but also introduce challenges that
    must be addressed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以提供很大的灵活性，但也引入了必须解决的问题。
- en: '**Service communication**: Monolithic applications use in-memory communication
    between processes, while microservices communicate over the network. The move
    to network communication raises issues of not only speed but also security.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务通信**：单体应用程序使用进程之间的内存通信，而微服务通过网络进行通信。转向网络通信不仅提出了速度问题，还提出了安全问题。'
- en: '**Tight coupling**: Microservices use many datastores rather than a few. This
    creates the opportunity for implicit service contracts between microservices and
    services that are tightly coupled.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密耦合**：微服务使用许多数据存储而不是少数几个。这为微服务与紧密耦合的服务之间隐式服务合同创造了机会。'
- en: '**Technical complexity**: Microservices can create additional complexity, which
    can create security gaps. If the team does not have the correct experience, then
    managing these complexities can quickly become unmanageable.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术复杂性**：微服务可以创建额外的复杂性，这可能导致安全漏洞。如果团队没有正确经验，那么管理这些复杂性可能会迅速变得难以控制。'
- en: The OAuth 2 specification
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2规范
- en: There is sometimes a misconception that **OAuth 2** is an evolution from **OAuth
    1**, but it is a completely different approach. **OAuth 1** specification requires
    signatures, so you would have to use cryptographic algorithms to create generate
    and validate those signatures that are no longer required for **OAuth 2**. The
    **OAuth 2** encryption is now handled by **TLS**, which is required.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时存在一种误解，认为**OAuth 2**是**OAuth 1**的演变，但实际上它是一种完全不同的方法。**OAuth 1**规范要求签名，因此您必须使用加密算法来创建、生成和验证这些签名，而这些签名在**OAuth
    2**中不再需要。**OAuth 2**的加密现在由**TLS**处理，这是必需的。
- en: Important note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**OAuth 2 RFC-6749**, *The OAuth 2.0 Authorization* *Framework* ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth 2 RFC-6749**，*OAuth 2.0授权框架*([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749))：'
- en: The **OAuth 2.0** authorization framework enables a third-party application
    to obtain limited access to an HTTP service, either on behalf of a resource owner
    by orchestrating an approval interaction between the resource owner and the HTTP
    service, or by allowing the third-party application to obtain access on its own
    behalf.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth 2.0**授权框架允许第三方应用程序代表资源所有者通过在资源所有者和HTTP服务之间协调批准交互，或者允许第三方应用程序代表自己获取对HTTP服务的有限访问。'
- en: This specification replaces and makes obsolete the **OAuth 1.0** protocol described
    in **RFC 5849**, The **OAuth 1.0** Protocol ([https://tools.ietf.org/html/rfc5849](https://tools.ietf.org/html/rfc5849)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此规范取代并使**RFC 5849**中描述的**OAuth 1.0**协议过时，**OAuth 1.0**协议([https://tools.ietf.org/html/rfc5849](https://tools.ietf.org/html/rfc5849))。
- en: 'To properly understand how to utilize **OAuth 2**, we need to identify certain
    roles and the collaboration between these roles. Let’s define each of the roles
    that are participating in the **OAuth 2** authorization process:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确理解如何利用**OAuth 2**，我们需要确定某些角色以及这些角色之间的协作。让我们定义在**OAuth 2**授权过程中参与的所有角色：
- en: '**Resource owner**: The resource owner is the entity capable of granting access
    to a protected resource that is located on a resource server'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：资源所有者是能够授予对位于资源服务器上的受保护资源访问权限的实体。'
- en: '**Authorization server**: The authorization server is a centralized security
    gateway for issuing access tokens to the client after successfully authenticating
    the resource owner and obtaining authorization'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：授权服务器是在成功验证资源所有者并获得授权后向客户端颁发访问令牌的集中式安全网关。'
- en: '**Resource server**: The resource server is the server hosting the protected
    resources and is capable of dissecting and responding to protected resource requests
    using the **OAuth 2** access token'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：资源服务器是托管受保护资源的服务器，并且能够使用**OAuth 2**访问令牌分解和响应受保护资源请求。'
- en: '**Microservice client**: The client is the application making resource requests
    that are protected on behalf of the resource owner, but with their authorization'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务客户端**：客户端是代表资源所有者进行受保护资源请求的应用程序，但具有其授权。'
- en: Access tokens
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问令牌
- en: 'An `access_token` in code samples, represents a credential that can be used
    by a client to access an **API**. We have two types of access tokens:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，`access_token`代表一个凭证，客户端可以使用它来访问**API**。我们有两种类型的访问令牌：
- en: '**Access token**: An access token usually has a limited lifetime and is used
    to enable the client to access protected resources when including this token in
    the HTTP request header for each request.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问令牌**：访问令牌通常具有有限的生命周期，并在将此令牌包含在每个请求的HTTP请求头中时，用于使客户端能够访问受保护资源。'
- en: '**Refresh token**: A refresh token has a longer lifetime and is used to get
    a new access token once the access token has expired, but without the need to
    send credentials to the server again.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**刷新令牌**：刷新令牌的生存周期更长，用于在访问令牌过期后获取新的访问令牌，但无需再次向服务器发送凭证。'
- en: Grant types
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权类型
- en: 'Grant types are methods that a client can use to gain an access token that
    represents the permissions granted. There are different grant types that allow
    different types of access based on the needs of your application. Each grant type
    can support a different **OAuth 2** flow without worrying about the technical
    aspects of the implementation. We have four main grant types in **OAuth 2**:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 授权类型是客户端可以使用的方法来获取代表授予的权限的访问令牌。根据应用程序的需求，有不同的授权类型允许不同类型的访问。每种授权类型都可以支持不同的 **OAuth
    2** 流，而无需担心实现的技術方面。在 **OAuth 2** 中，我们有四种主要的授权类型：
- en: '`access_token` and, optionally, `id_token` and `refresh_token`. The client
    can now use this `access_token` to call the protected resource on behalf of the
    user.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access_token` 和可选的 `id_token` 以及 `refresh_token`。客户端现在可以使用此 `access_token`
    代表用户调用受保护的资源。'
- en: '`access_token` directly, without the need for `authorization_code`. This happens
    because the client application, which is usually a JavaScript application running
    within a browser and is less trusted than a client application running on the
    server, cannot be trusted with `client_secret` (which is required in the authorization
    code grant type). The implicit grant type does not send a refresh token to the
    application due to limited trust.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接使用 `access_token`，无需 `authorization_code`。这是因为客户端应用程序，通常是一个在浏览器中运行的JavaScript应用程序，其信任度低于在服务器上运行的应用程序，不能信任
    `client_secret`（在授权代码授予类型中需要）。由于信任度有限，隐式授权类型不会向应用程序发送刷新令牌。
- en: '`access_token` and, optionally, `refresh_token`. This grant is used when there
    is a high degree of trust between the user and the client and when other authorization
    grant flows are not available. This grant type eliminates the need for the client
    to store the user credentials by exchanging the credentials with a long-lived
    `access_token` or `refresh_token`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access_token` 和可选的 `refresh_token`。当用户和客户端之间有高度信任，并且其他授权授予流不可用时，使用此授权类型。此授权类型消除了客户端通过交换长期生存期的
    `access_token` 或 `refresh_token` 来存储用户凭证的需要。'
- en: '`access_token` by using client-provided credentials (client id and client secret)
    to authenticate.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端提供的凭证（客户端ID和客户端密钥）通过认证来获取 `access_token`。
- en: After covering the main OAuth 2 access tokens and grant types, in the next section
    will deep dive into the JSON Web Tokens specification.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了主要的OAuth 2访问令牌和授权类型之后，在下一节中，我们将深入探讨JSON Web Tokens规范。
- en: JSON Web Tokens
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web Tokens
- en: '**JWT** is an open standard, **RFC 7519** ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))
    that defines a compact and self-contained format for securely transmitting information
    between parties in the form of a **JSON** object. This information can be verified
    and trusted because it is digitally signed. JWTs can be signed using a secret
    (with the **hash-based message authentication code** (**HMAC**) algorithm) or
    a public/private key pair using the **Rivest–Shamir–Adleman** (**RSA**) encryption
    algorithm.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**JWT** 是一个开放标准，**RFC 7519** ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))，它定义了一种紧凑且自包含的格式，用于以
    **JSON** 对象的形式在各方之间安全地传输信息。由于信息是数字签名的，因此可以验证和信任。JWT可以使用秘密（使用基于哈希的消息认证码（**HMAC**）算法）或使用公钥/私钥对（使用
    **Rivest–Shamir–Adleman** （**RSA**）加密算法）进行签名。'
- en: Important note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: '**JWT RFC-** **7519** ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**JWT RFC-** **7519** ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)):'
- en: '**JWT** is a compact, URL-safe means of representing claims to be transferred
    between two parties. The claims in a **JWT** are encoded as a **JSON** object
    that is used as the payload of a **JSON Web Signature** (**JWS**) structure or
    as the plaintext of a **JSON Web Encryption** (**JWE**) structure, enabling the
    claims to be digitally signed or integrity protected with a **Message Authentication
    Code** (**MAC**) and/or encrypted.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**JWT** 是一种紧凑、URL安全的表示声明的方法，用于在双方之间传输。JWT中的声明编码为一个 **JSON** 对象，用作 **JSON Web
    Signature** （**JWS**）结构的有效负载或 **JSON Web Encryption** （**JWE**）结构的明文，使声明可以通过消息认证码（**MAC**）进行数字签名或完整性保护，以及/或加密。'
- en: '**JWT** is used to carry information related to the identity and characteristics
    (**claims**) of the client bearing the token. JWT is a container and is signed
    by the server to avoid client tampering. This token is created during the authentication
    process and is verified by the authorization server before any processing. It
    is used by a resource server to allow a client to present a token representing
    its *identity card* to the resource server and allows the resource server to verify
    the validity and integrity of the token in a stateless, secure manner.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**JWT** 用于携带与携带令牌的客户端的身份和特征（**声明**）相关的信息。JWT 是一个容器，并由服务器签名以防止客户端篡改。此令牌在认证过程中创建，并在任何处理之前由授权服务器验证。它由资源服务器使用，允许客户端向资源服务器展示代表其
    *身份证* 的令牌，并允许资源服务器以无状态、安全的方式验证令牌的有效性和完整性。'
- en: Token structure
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 令牌结构
- en: 'The structure of a JWT adheres to the following three-part structure including
    a header, payload, and signature:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 的结构遵循以下三部分结构，包括标题、有效载荷和签名：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Encoded JWT
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码后的 JWT
- en: 'The following code snippet is the complete encoded `access_token` that is returned
    based on the client request:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是基于客户端请求返回的完整编码的 `access_token`：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Header
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标题
- en: 'The encoded header for our `access_token` JWT is `base64` encoded, as shown
    in the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `access_token` JWT 的编码标题是 `base64` 编码的，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By decoding the encoded header, we have the following payload:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解码编码后的标题，我们得到以下有效载荷：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Payload
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有效载荷
- en: 'The encoded payload for our `access_token` JWT is `base64` encoded, as shown
    here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `access_token` JWT 的编码有效载荷是 `base64` 编码的，如下所示：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By decoding the encoded payload, we have the following payload claims:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解码编码后的有效载荷，我们得到以下有效载荷声明：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Signature
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 签名
- en: 'The encoded payload for our `access_token` has been encoded with a private
    key by the authorization server, as seen in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `access_token` 的编码有效载荷是由授权服务器使用私钥编码的，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is pseudo code for the creation of a JWT signature:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为创建 JWT 签名编写的伪代码：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JWT Authentication in Spring Security
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 中的 JWT 认证
- en: Moving forward, let’s examine the architectural elements employed by `Spring
    Security` to facilitate **JWT** Authentication in servlet-based applications,
    similar to the one we previously discussed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查 `Spring Security` 在基于 servlet 的应用程序中实现 **JWT** 认证所使用的架构元素，类似于我们之前讨论的那个。
- en: The `JwtAuthenticationProvider` serves as an implementation of `AuthenticationProvider`,
    utilizing a `JwtDecoder` and `JwtAuthenticationConverter` to validate a **JWT**
    during authentication.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`JwtAuthenticationProvider` 作为 `AuthenticationProvider` 的实现，利用 `JwtDecoder`
    和 `JwtAuthenticationConverter` 在认证过程中验证 **JWT**。'
- en: Now, let’s delve into the workings of `JwtAuthenticationProvider` within the
    context of `Spring Security`. The accompanying figure elucidates the intricacies
    of the `AuthenticationManager`, as illustrated in the figures depicting the process
    of reading the **Bearer Token**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解 `JwtAuthenticationProvider` 在 `Spring Security` 上下文中的工作原理。随附的图解说明了
    `AuthenticationManager` 的复杂性，如图中描绘的读取 **Bearer Token** 的过程所示。
- en: '![Figure 17.3 – JWT Authentication in Spring Security](img/B21757_17_3.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.3 – Spring Security 中的 JWT 认证](img/B21757_17_3.jpg)'
- en: Figure 17.3 – JWT Authentication in Spring Security
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3 – Spring Security 中的 JWT 认证
- en: 'The JWT authentication in spring-security entails the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 中的 JWT 认证包括以下步骤：
- en: The Authentication Filter, as part of the process outlined in reading the `BearerTokenAuthenticationToken`
    to the `AuthenticationManager`, which is implemented by `ProviderManager`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 认证过滤器是读取 `BearerTokenAuthenticationToken` 到 `AuthenticationManager` 的过程的一部分，`AuthenticationManager`
    由 `ProviderManager` 实现。
- en: The `ProviderManager` is set up to utilize an `AuthenticationProvider` of the
    `JwtAuthenticationProvider` type.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProviderManager` 已配置为使用 `JwtAuthenticationProvider` 类型的 `AuthenticationProvider`。'
- en: '`JwtAuthenticationProvider` undertakes the tasks of decoding, verifying, and
    validating the `Jwt` through a `JwtDecoder`.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JwtAuthenticationProvider` 通过 `JwtDecoder` 承担解码、验证和验证 `Jwt` 的任务。'
- en: Subsequently, `JwtAuthenticationProvider` employs the `JwtAuthentication` **Converter**
    to transform the **JWT** into a Collection of granted authorities.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，`JwtAuthenticationProvider` 使用 `JwtAuthentication` **转换器**将 **JWT** 转换为授权权限的集合。
- en: Upon successful authentication, the returned Authentication takes the form of
    `JwtAuthenticationToken`, featuring a principal representing the `JwtDecoder`.
    Eventually, the `JwtAuthenticationToken` returned will be placed in the `SecurityContextHolder`
    by the Authentication Filter.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在认证成功后，返回的 Authentication 以 `JwtAuthenticationToken` 的形式呈现，其中包含代表 `JwtDecoder`
    的主体。最终，`JwtAuthenticationToken` 将由 Authentication Filter 放置在 `SecurityContextHolder`
    中。
- en: After covering the **OAuth 2** and **JWT** specifications we’ll take a closer
    look at how they’re implemented within spring-security.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖了 **OAuth 2** 和 **JWT** 规范之后，我们将更深入地了解它们在 spring-security 中的实现。
- en: OAuth 2 support in Spring Security
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 中的 OAuth 2 支持
- en: '`Spring Security` provides `Spring Framework` programming models and configuration
    idioms.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring Security` 提供了 `Spring Framework` 编程模型和配置惯例。'
- en: In the following section we will identify the main components involved in **OAuth**
    **2** flow.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将确定参与 **OAuth** **2** 流的主要组件。
- en: Resource owner
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源所有者
- en: The resource owner can be one or multiple sources, and in the context of the
    **JBCP calendar**, it is going to have the calendar application as the resource
    owner. The **JBCP calendar** will not have any specific configuration that is
    needed to denote its ownership aside from configuring the resource server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 资源所有者可以是一个或多个来源，在 **JBCP 日历** 的上下文中，它将具有日历应用程序作为资源所有者。**JBCP 日历**除了配置资源服务器外，不需要任何特定的配置来表示其所有权。
- en: Resource server
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源服务器
- en: Most of the resource server support is consolidated in `spring-security-oauth2-resource-server`.
    However, the decoding and verification of `spring-security-oauth2-jose`. Therefore,
    both components are essential for a functional resource server that can handle
    **JWT-encoded** **Bearer Tokens**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数资源服务器支持都集中在 `spring-security-oauth2-resource-server` 中。然而，`spring-security-oauth2-jose`
    负责解码和验证。因此，这两个组件对于功能齐全的资源服务器，能够处理 **JWT 编码** **Bearer Tokens** 至关重要。
- en: 'In Spring Boot, setting up an application as a resource server involves two
    fundamental steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 中，将应用程序设置为资源服务器涉及两个基本步骤：
- en: Firstly, include the necessary dependencies
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包含必要的依赖项
- en: Secondly, specify the location of the authorization server.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，指定授权服务器位置。
- en: Authorization server
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权服务器
- en: To enable the authorization server capability, we will use `Spring Authorization
    Server` that offers implementations of the `Authorization` `Server` products.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用授权服务器功能，我们将使用提供 `Authorization` `Server` 产品实现的 `Spring Authorization Server`。
- en: To initiate the utilization of `Spring Authorization Server`, the most straightforward
    approach is to build a `Spring Authorization Server` as a dependency as follow.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 `Spring Authorization Server` 的使用，最直接的方法是将 `Spring Authorization Server`
    作为依赖项构建，如下所示。
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Important note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter17.00-authorization-server`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应类似于 `chapter17.00-authorization-server`。
- en: OAuth 2 resource minimal configuration properties
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth 2 资源最小配置属性
- en: Note that in the project `chapter17.00-calendar`, we already have added `spring-boot-starter-oauth2-resource-server`
    dependency, in addition to spring-security. This is important for our application
    in order to behave as a resource server.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在项目 `chapter17.00-calendar` 中，我们已添加 `spring-boot-starter-oauth2-resource-server`
    依赖项，除了 spring-security。这对于我们的应用程序作为资源服务器的行为非常重要。
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In a Spring Boot application, you can easily designate the authorization server
    to be used by following these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 应用程序中，您可以通过以下步骤轻松指定要使用的授权服务器：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The `issuer-uri` property to be effective, it’s essential that one of the following
    endpoints is a supported endpoint for the authorization server: `idp.example.com/issuer/.well-known/openid-configuration`,
    `idp.example.com/.well-known/openid-configuration/issuer`, or `idp.example.com/.well-known/oauth-authorization-server/issuer`.
    This endpoint is commonly referred to as either a Provider Configuration endpoint
    or an Authorization Server Metadata endpoint.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `issuer-uri` 属性生效，以下端点之一必须是授权服务器支持端点：`idp.example.com/issuer/.well-known/openid-configuration`、`idp.example.com/.well-known/openid-configuration/issuer`
    或 `idp.example.com/.well-known/oauth-authorization-server/issuer`。此端点通常被称为提供者配置端点或授权服务器元数据端点。
- en: Expectations at startup
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创业预期
- en: When employing this property and its associated dependencies, the Resource Server
    will autonomously set up its configuration to validate Bearer Tokens encoded in
    JWT format.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此属性及其相关依赖项时，资源服务器将自动设置其配置以验证 JWT 格式编码的 Bearer Tokens。
- en: 'This is accomplished through a predictable startup sequence:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过一个可预测的启动序列完成的：
- en: Interrogate the Provider Configuration or Authorization Server Metadata endpoint
    for the `jwks_url` property.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问提供者配置或授权服务器元数据端点以获取`jwks_url`属性。
- en: Examine the `jwks_url` endpoint for the supported algorithms.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`jwks_url`端点以支持算法。
- en: Configure the validation strategy to query the `jwks_url` for valid **public
    keys** corresponding to the identified algorithms.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置验证策略以查询`jwks_url`以获取对应于识别算法的有效**公钥**。
- en: Configure the validation strategy to verify the `"iss"` claim of each `idp.example.com`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置验证策略以验证每个`idp.example.com`的`"iss"`声明。
- en: An implication of this process is that the authorization server must be operational
    and capable of receiving requests for the Resource Server to initialize successfully.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的含义是，授权服务器必须处于运行状态并且能够接收请求，以便资源服务器能够成功初始化。
- en: Expectations during Runtime
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行时的期望
- en: After the application has been initiated, the `Resource Server` will endeavor
    to handle any request that includes an `Authorization:` `Bearer` header.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动后，`Resource Server`将努力处理任何包含`Authorization:` `Bearer`头的请求。
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As long as this scheme is specified, the resource server will strive to handle
    the request in accordance with the Bearer Token specification.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 只要指定了这个方案，资源服务器就会努力按照Bearer Token规范来处理请求。
- en: 'For a properly structured **JWT**, the resource server will:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构良好的JWT，资源服务器将：
- en: Validate its signature using a public key obtained from the `jwks_url` endpoint
    during startup, ensuring a match with the **JWT**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在启动时从`jwks_url`端点获得的公钥验证其签名，确保与JWT匹配。
- en: Verify the **JWT**’s **exp** and **nbf** timestamps, along with the **JWT**’s
    **iss** claim.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证JWT的`exp`和`nbf`时间戳，以及JWT的`iss`声明。
- en: Associate each scope with an authority, using the prefix **SCOPE_**.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个范围与一个权限关联，使用前缀**SCOPE_**。
- en: Spring Security will automatically update and rotate the keys used to validate
    **JWT**s as the authorization server introduces new keys.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当授权服务器引入新密钥时，Spring Security将自动更新和轮换用于验证JWT的密钥。
- en: Important note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter17.01-calendar`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter17.01-calendar`。
- en: By default, the resulting `Authentication#getPrincipal` is a `Spring Security
    Jwt` object, and if available, `Authentication#getName` corresponds to the sub
    property of the **JWT**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Authentication#getPrincipal`返回的是一个`Spring Security Jwt`对象，如果可用，`Authentication#getName`对应于JWT的sub属性。
- en: After defining `jwk-set-uri`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`jwk-set-uri`之后。
- en: Defining the JWK Set URI for the authorization server
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义授权服务器的JWK Set URI
- en: 'If the `jwk-set-uri` as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`jwk-set-uri`如下所示：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As a result, the `issuer-uri` to ensure that the resource server validates the
    `"iss"` claim within incoming **JWT**s.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`issuer-uri`确保资源服务器验证传入JWT中的`"iss"`声明。
- en: Providing Audience Information
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供受众信息
- en: As demonstrated earlier, the `issuer-uri` property verifies the `"iss"` claim,
    identifying the entity that sent the **JWT**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`issuer-uri`属性验证`"iss"`声明，识别发送JWT的实体。
- en: Additionally, `audiences` property for validating the `"aud"` claim, determining
    the intended recipients of the **JWT**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`audiences`属性用于验证`"aud"`声明，确定JWT的预期接收者。
- en: 'You can specify a resource server’s audience as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样指定资源服务器的受众：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The outcome will be that if the `"iss"` claim of the `"aud"` claim does not
    include `my-resource-server.example.com` in its list, the validation will not
    succeed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是，如果`"aud"`声明的`"iss"`声明列表中不包含`my-resource-server.example.com`，则验证将不会成功。
- en: Configuring Authorization using SecurityFilterChain
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SecurityFilterChain配置授权
- en: A `Authorization Server` will usually contain a `scope` or `scp` attribute,
    signifying the granted scopes or authorities.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorization Server`通常包含一个`scope`或`scp`属性，表示授予的权限或范围。'
- en: 'In such instances, the resource server will endeavor to transform these scopes
    into a roster of authorized authorities, adding the `SCOPE_` string as a prefix
    to each scope. Consequently, to secure an endpoint or method with a scope obtained
    from a **JWT**, the associated expressions should incorporate this prefix. For
    example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，资源服务器将努力将这些范围转换为授权权限列表，并为每个范围添加`SCOPE_`字符串作为前缀。因此，为了使用从JWT获得的范围来保护端点或方法，相关的表达式应包含此前缀。例如：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Important note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter17.02-calendar`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter17.02-calendar`。
- en: At this point, we can start the `chapter17.00-authorization-server` and `chapter17.02-calendar`
    and we will be ready to send **OAuth** **2** requests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以启动 `chapter17.00-authorization-server` 和 `chapter17.02-calendar`，我们将准备好发送
    **OAuth** **2** 请求。
- en: Token requests
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 令牌请求
- en: 'When we make the initial token request, we should get a successful response
    similar to the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发起初始令牌请求时，我们应该得到一个类似于以下的成功响应：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And this is a sample response:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例响应：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Specifically, we have been granted an access token that can be used in subsequent
    requests. The `access_token` that will be used as our bearer.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们已经获得了一个可以在后续请求中使用的访问令牌。这个 `access_token` 将作为我们的载体。
- en: Endpoints requests
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端点请求
- en: 'Now we will take the `access_token` and use that token to initiate additional
    requests to the server with the following format:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `access_token` 并用该令牌以以下格式向服务器发起额外的请求：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We should get the following response:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到以下响应：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Configuring Authorization using @PreAuthorize annotation
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 @PreAuthorize 注解配置授权
- en: Another way to configure authorization can be done using `@``PreAuthorize` annotation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种配置授权的方法是使用 `@PreAuthorize` 注解。
- en: 'First step is to enable method security in `SecurityConfig.java`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在 `SecurityConfig.java` 中启用方法安全：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The next step is to secure `CalendarService.getEvents()` that is invoked by
    the `/``events` endpoint.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确保 `/events` 端点调用的 `CalendarService.getEvents()` 的安全性。
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Important note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter17.03-calendar`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像 `chapter17.03-calendar`。
- en: At this point, we can start the `chapter17.00-authorization-server` and `chapter17.03-calendar`
    and we will be ready to send **OAuth** **2** requests.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以启动 `chapter17.00-authorization-server` 和 `chapter17.03-calendar`，我们将准备好发送
    **OAuth** **2** 请求。
- en: You can try again, the same previous steps for the `/token` and `/events` endpoints
    requests.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试再次进行，对于 `/token` 和 `/events` 端点请求使用相同的先前步骤。
- en: Now that we have our `OAuth 2 server` ready to issue `access_tokens` for clients,
    we now can create a microservices client to interact with our system.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了 `OAuth 2 服务器`，可以为客户颁发 `access_tokens`，我们现在可以创建一个微服务客户端来与我们的系统交互。
- en: Configuring the OAuth 2 client
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 OAuth 2 客户端
- en: Now that we have configured our resource server, you can create REST client
    to consume the **OAuth2** protected resources.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了资源服务器，您可以创建 REST 客户端来消费 **OAuth2** 受保护的资源。
- en: 'You can use https://start.spring.io/ to initialize you project by choosing
    the following dependencies:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 https://start.spring.io/ 通过选择以下依赖项来初始化您的项目：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, you will need to configure your application with the client configuration
    as follow:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要按照以下配置将应用程序与客户端配置一起配置：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For this example we will use `RestTemplate` and `ClientHttpRequestInterceptor`
    to bind the `OAuth2AccessToken` for our REST Client.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用 `RestTemplate` 和 `ClientHttpRequestInterceptor` 来绑定我们的 REST 客户端的
    `OAuth2AccessToken`。
- en: Making requests to a third-party `OAuth2AuthorizedClient` class in Spring Security,
    and gaining access to protected resources by inserting a Bearer token into the
    Authorization header of an outgoing request.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Spring Security 中向第三方 `OAuth2AuthorizedClient` 类发起请求，并通过在出站请求的授权头中插入 Bearer
    令牌来获取受保护资源。
- en: The provided example sets up the application to function as an **OAuth2** Client
    with the ability to request protected resources from a third-party **API**.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提供的示例设置了应用程序以作为 **OAuth2** 客户端运行，能够从第三方 **API** 请求受保护的资源。
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following `OAuth2HttpRequestInterceptor` can be defined as described in
    the sample code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 `OAuth2HttpRequestInterceptor` 可以按照示例代码中的描述进行定义：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last step is to make the `RestTemplate` Bean:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是创建 `RestTemplate` Bean：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We now should have the same codebase for a client application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该有一个客户端应用程序的相同代码库。
- en: Important note
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Your code should now look like `chapter17.03-calendar-client`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像 `chapter17.03-calendar-client`。
- en: We need to ensure that the `chapter17.03-calendar` and `chapter17.00-authorization-server`
    applications are running and ready to take **OAuth 2**requests from clients.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保 `chapter17.03-calendar` 和 `chapter17.00-authorization-server` 应用程序正在运行，并准备好接收来自客户端的
    **OAuth 2** 请求。
- en: 'We can then start the `chapter17.03-calendar-client` application, which will
    expose a RESTful endpoint that will call our resource server to access the configured
    events located at `/events` on the remote resource, and will return the following
    result by running `http://localhost:8888/`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以启动 `chapter17.03-calendar-client` 应用程序，该程序将公开一个 RESTful 端点，该端点将调用我们的资源服务器以访问远程资源上的
    `/events` 路径上配置的事件，并通过运行 `http://localhost:8888/` 返回以下结果：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the general difference between monolithic applications
    and **microservices** and compared **SOA** with **microservices**. You also learned
    the conceptual architecture of **OAuth 2** and how it provides your services with
    trustworthy client access, and learned about the types of **OAuth 2** access tokens
    and the types of **OAuth 2 client** **credentials** types.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了单体应用和**微服务**之间的基本区别，并将**SOA**与**微服务**进行了比较。你还学习了**OAuth 2**的概念架构以及它是如何为你的服务提供可信赖的客户端访问，以及了解了**OAuth
    2**访问令牌的类型和**OAuth 2**客户端**凭证**类型。
- en: We examined the **JWT** and their general structure, implemented a **resource
    server** and **authorization server** used to grant access rights to clients to
    access **OAuth 2**resources, and implemented a **RESTful** client to gain access
    to resources through an **OAuth 2** **grant flow**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考察了**JWT**及其一般结构，实现了一个**资源服务器**和**授权服务器**，用于授予客户端访问**OAuth 2**资源的权限，并实现了一个**RESTful**客户端，通过**OAuth
    2****授权流程**来访问资源。
- en: We’ve concluded by demonstrating a practical **OAuth 2** example implementation
    using spring-security. Moving forward, the next chapter will explore the integration
    with **Central Authentication Service** (**CAS**) to enable **Single Sign-On**
    (**SSO**) and **Single Logout** (**SLO**) functionalities for your Spring Security-enabled
    applications.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过演示使用spring-security的实用**OAuth 2**示例实现来结束本章。接下来，下一章将探讨与**中央认证服务**（**CAS**）的集成，以实现为你的Spring
    Security启用应用提供**单点登录**（**SSO**）和**单点登出**（**SLO**）功能。
