- en: Chapter 5. Combining Persistence with CDI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：将持久性与CDI结合
- en: In the earlier chapters, we discussed Java EE, combining several technologies
    such as CDI. The examples so far, however, are based on a false assumption that
    all the information can be stored in memory. In this chapter, we will show how
    to use a persistent data store for our application in the form of a standard relational
    database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了Java EE，结合了CDI等几种技术。然而，到目前为止的示例都是基于一个错误的假设，即所有信息都可以存储在内存中。在本章中，我们将展示如何以标准的关系数据库的形式为我们的应用程序使用持久性数据存储。
- en: The **Enterprise JavaBeans** (**EJB**) 3.2 specification includes a reference
    to a persistence specification called the **Java Persistence API** (**JPA**).
    It is an API to create, remove, and query Java objects called **entities** that
    can be used within both a compliant EJB 3.x container and a standard Java SE environment.
    In Java EE 7, it has been updated to Version 2.1\. You can check out the current
    version of the specification I the JSR 338 at [https://jcp.org/en/jsr/detail?id=338](https://jcp.org/en/jsr/detail?id=338).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Enterprise JavaBeans**（**EJB**）3.2规范包含对持久性规范**Java Persistence API**（**JPA**）的引用。它是一个用于创建、删除和查询称为**实体**的Java对象的API，这些实体可以在符合EJB
    3.x容器的标准和Java SE环境中使用。在Java EE 7中，它已更新到2.1版本。您可以在JSR 338（[https://jcp.org/en/jsr/detail?id=338](https://jcp.org/en/jsr/detail?id=338)）中查看当前版本的规范。'
- en: We need to warn you that in this chapter, you have a lot of things to learn
    and hence concepts will be coming at you from every direction. However, at the
    end of it, you will be able to appreciate exactly how to create and deploy a complete
    Java EE 7 application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提醒您，在本章中，您有很多东西要学习，因此概念将从各个方向向您袭来。然而，在结束时，您将能够确切地欣赏如何创建和部署一个完整的Java EE 7应用程序。
- en: 'Specifically, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: The key features of JPA
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA的关键特性
- en: How to create your entities and database schema
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建实体和数据库模式
- en: How to manipulate the entities using CDI Beans and EJBs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用CDI Beans和EJBs操作实体
- en: Delivering a frontend tier for our application using JSF and Facelets technology
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSF和Facelets技术为我们应用程序提供前端层
- en: Data persistence meets the standard
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据持久性符合标准
- en: The arrival of an Enterprise Java Persistence standard based on the **Plain
    Old Java Object** (**POJO**) development model fills a substantial gap in the
    Java EE platform. The previous attempt (the EJB 2.x specification) missed the
    mark and created a stereotype of EJB entity beans that was awkward to develop
    and too heavy for many applications. Therefore, it never achieved widespread adoption
    or general approval in many sectors of the industry.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基于简单Java对象（**POJO**）开发模型的Enterprise Java Persistence标准的到来，在Java EE平台中填补了一个重要的空白。之前的尝试（EJB
    2.x规范）偏离了目标，并创造了一个不便于开发且对许多应用程序来说过于沉重的EJB实体bean的刻板印象。因此，它从未在许多行业的许多领域得到广泛采用或普遍认可。
- en: Software developers knew what they wanted, but many could not find it in the
    existing standards, so they decided to look elsewhere. What they found was lightweight
    persistence frameworks, both in the commercial and open source domains.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发者知道他们想要什么，但很多人在现有的标准中找不到，所以他们决定另寻他处。他们找到的是轻量级持久性框架，包括商业和开源领域。
- en: In contrast to EJB 2.x entity beans, the EJB 3.0 **Java Persistence API** (**JPA**)
    is a metadata driven POJO technology, that is, to save the data held in Java objects
    in a database, our objects are not required to implement an interface, extend
    a class, or fit into a framework pattern.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与EJB 2.x实体bean相比，EJB 3.0的**Java Persistence API**（**JPA**）是一种元数据驱动的POJO技术，也就是说，为了将存储在Java对象中的数据保存到数据库中，我们的对象不需要实现接口、扩展类或符合框架模式。
- en: Another key feature of JPA is the query language called the **Java Persistence
    Query Language** (**JPQL**), which gives you a way to define the queries in a
    portable way, independent of the particular database you use in an enterprise
    environment. JPA queries resemble SQL queries by syntax but operate against entity
    objects rather than directly with database tables.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JPA的另一个关键特性是称为**Java Persistence Query Language**（**JPQL**）的查询语言，它提供了一种以可移植的方式定义查询的方法，独立于在企业环境中使用的特定数据库。JPA查询在语法上类似于SQL查询，但操作的是实体对象而不是直接与数据库表交互。
- en: Working with JPA
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JPA进行操作
- en: 'Inspired by ORM frameworks such as Hibernate, JPA uses annotations to map objects
    to a relational database. JPA entities are POJOs that do not extend any class
    nor implement any interface. You don''t even need XML descriptors for your mapping.
    Actually, the JPA API is made up of annotations and only a few classes and interfaces.
    For example, we will mark the `Company` class as `@Entity`, shown as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 受 ORM 框架如 Hibernate 的启发，JPA 使用注解将对象映射到关系数据库。JPA 实体是 POJO，不扩展任何类也不实现任何接口。您甚至不需要映射的
    XML 描述符。实际上，JPA API 由注解和一些类和接口组成。例如，我们将 `Company` 类标记为 `@Entity`，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding piece of code shows the minimal requirements for a class to be
    persistent, which are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码显示了使一个类持久化的最小要求，如下所示：
- en: It must be identified as an entity using the `@javax.persistence.Entity` annotation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须使用 `@javax.persistence.Entity` 注解标识为实体
- en: It must have an identifier attribute annotated with `@javax.persistence.Id`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须使用 `@javax.persistence.Id` 注解的标识属性
- en: It must have a no-argument constructor in at least the protected scope
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须在至少受保护的范围内有一个无参数的构造函数
- en: Since you will learn better with an example, we will show how to create and
    deploy a sample JPA application in WildFly in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通过示例学习效果更好，我们将在下一节中展示如何在 WildFly 中创建和部署一个示例 JPA 应用程序。
- en: Adding persistence to our application
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将持久化添加到我们的应用程序中
- en: In order to persist data, JPA needs a relational database; we will use the PostgreSQL
    database, which is pretty popular among developers and can be downloaded for free
    from [http://www.postgresql.org/download/](http://www.postgresql.org/download/).
    It is recommended to download the latest stable release of PostgreSQL 9.x and
    install it using the simple installation wizard. If you don't need a full-blown
    database, then keep in mind that later we will also show you how to use an in-memory
    database provided by WildFly, which can be a really useful alternative during
    development.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持久化数据，JPA 需要一个关系数据库；我们将使用在开发者中相当流行的 PostgreSQL 数据库，可以从 [http://www.postgresql.org/download/](http://www.postgresql.org/download/)
    免费下载。建议下载 PostgreSQL 9.x 的最新稳定版本，并使用简单的安装向导进行安装。如果您不需要完整的数据库，请记住，稍后我们还将向您展示如何使用
    WildFly 提供的内存数据库，这在开发期间可能是一个非常有用的替代方案。
- en: Setting up the database
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库
- en: We will create a database named `ticketsystem`; we will then add a user named
    `jboss` and assign him/her all privileges on the schemas.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `ticketsystem` 的数据库；然后我们将添加一个名为 `jboss` 的用户，并授予他在模式上的所有权限。
- en: 'Open a shell under the `bin` folder of your PostgreSQL installation and launch
    the executable `psql –U postgres`. Once logged in with the password from your
    installation, execute the following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 PostgreSQL 安装目录下的 `bin` 文件夹中打开一个 shell 并运行可执行文件 `psql –U postgres`。一旦使用安装密码登录，执行以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our simple schema will be made up of two tables: the `SEAT` table, which contains
    the list of all the available seats in the theatre, and the `SEAT_TYPE` table,
    which is used to categorize the seat types. The two tables are in a *1-n* relationship
    and the `SEAT` table hosts a foreign key that relates to the ID of the `SEAT_TYPE`
    table. We will, however, let JPA generate the schema for us, based on our class
    hierarchy, which we will model in a moment.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的模式将由两个表组成：包含剧院中所有可用座位列表的 `SEAT` 表，以及用于对座位类型进行分类的 `SEAT_TYPE` 表。这两个表之间是
    *1-n* 的关系，`SEAT` 表包含一个外键，与 `SEAT_TYPE` 表的 ID 相关联。然而，我们将让 JPA 根据我们的类层次结构为我们生成模式，我们将在稍后建模。
- en: Installing the JDBC driver in WildFly
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 WildFly 中安装 JDBC 驱动程序
- en: Database connectivity is carried out in Java using JDBC drivers, which are used
    either directly in your applications or behind the scenes in JPA. The PostgreSQL
    JDBC driver can be downloaded for free from [http://jdbc.postgresql.org/download.html](http://jdbc.postgresql.org/download.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接是通过 JDBC 驱动程序在 Java 中实现的，这些驱动程序可以直接在您的应用程序中使用，或者在 JPA 的幕后使用。可以从 [http://jdbc.postgresql.org/download.html](http://jdbc.postgresql.org/download.html)
    免费下载 PostgreSQL JDBC 驱动程序。
- en: Once the download is complete, place the `postgresql-9.X-X.jdbc41.jar` file
    at a convenient location on your filesystem. We will now see how to install the
    JDBC driver in WildFly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，将 `postgresql-9.X-X.jdbc41.jar` 文件放置在文件系统中的一个方便位置。现在我们将看到如何在 WildFly 中安装
    JDBC 驱动程序。
- en: In JBoss AS 5 and 6, you used to install the JDBC driver in the `common/lib`
    folder of your server distribution. In the new modular server architecture (introduced
    in JBoss AS 7), you have more than one option to install your JDBC driver. The
    recommended approach consists of installing the driver as a module.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JBoss AS 5 和 6 中，您通常在服务器分发的 `common/lib` 文件夹中安装 JDBC 驱动程序。在新的模块化服务器架构（在 JBoss
    AS 7 中引入）中，您有多个选项来安装您的 JDBC 驱动程序。推荐的方法是将驱动程序作为模块安装。
- en: The procedure to install a new module requires creating a module path under
    `JBOSS_HOME/modules` and placing the `.jar` libraries and the `module.xml` file
    (that declares the module name and its dependencies) there.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安装新模块的流程需要在 `JBOSS_HOME/modules` 下创建一个模块路径，并将 `.jar` 库和 `module.xml` 文件（声明模块名称及其依赖项）放置在那里。
- en: 'In our example, we will add the following units to our filesystem:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将向我们的文件系统添加以下单元：
- en: '`JBOSS_HOME/modules/org/postgresql/main/postgresql-9.3-1101.jdbc41.jar`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JBOSS_HOME/modules/org/postgresql/main/postgresql-9.3-1101.jdbc41.jar`'
- en: '`JBOSS_HOME/modules/org/postgresql/main/module.xml`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JBOSS_HOME/modules/org/postgresql/main/module.xml`'
- en: Start by simply creating the required directories in your WildFly installation
    (to which the `JBOSS_HOME` variable points), and copying the downloaded JAR file
    to them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在您的 WildFly 安装中（`JBOSS_HOME` 变量指向的位置）创建所需的目录，并将下载的 JAR 文件复制到其中。
- en: Now, in the main folder, add a file named `module.xml`. This file contains the
    actual module definition; the most interesting part of it is the module name (`org.postgresql`),
    which corresponds to the module attribute defined in your data source.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在主文件夹中添加一个名为 `module.xml` 的文件。此文件包含实际的模块定义；其中最有趣的部分是模块名称（`org.postgresql`），它与数据源中定义的模块属性相对应。
- en: 'Next, you need to state the path to the JDBC driver resource and the module
    dependencies, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要声明 JDBC 驱动程序资源路径和模块依赖项，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We are done with the module installation. Now we need to define a data source
    in our configuration that will use this module and hold a pool of connections
    in our PostgreSQL database. In order to do this, you can edit `standalone.xml/domain.xml`,
    adding a driver element to the data source''s subsystem (be sure to merge this
    configuration with any existing data sources in your configuration):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了模块的安装。现在我们需要在我们的配置中定义一个数据源，该数据源将使用此模块并在我们的 PostgreSQL 数据库中维护一个连接池。为了做到这一点，您可以编辑
    `standalone.xml/domain.xml`，向数据源的子系统添加一个驱动元素（确保将此配置与您配置中现有的任何数据源合并）：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the new configuration file borrows the same XML schema definition
    from the earlier JBoss AS configurations, so it should not be difficult to migrate
    to the new schema. Basically, you will define the connection path to the database
    using the `connection-url` string and the JDBC driver class with the `driver`
    section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，新的配置文件从早期的 JBoss AS 配置中借用了相同的 XML 架构定义，因此迁移到新架构应该不会很困难。基本上，您将使用 `connection-url`
    字符串和 `driver` 部分的 JDBC 驱动程序类来定义数据库的连接路径。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since JBoss AS 7.1.0, it's mandatory that the data source be bound to the `java:/`
    or `java:jboss/` JNDI namespace. This will standardize the resources definition
    among developers, avoiding bizarre JNDI bindings.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 JBoss AS 7.1.0 以来，数据源绑定到 `java:/` 或 `java:jboss/` JNDI 命名空间是强制性的。这将标准化开发人员之间的资源定义，避免奇特的
    JNDI 绑定。
- en: Using the command-line interface to create a new data source
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命令行界面创建新的数据源
- en: The application server provides more than one option to add a data source to
    your configuration. We will just mention the command-line interface approach,
    which can be quite useful, especially if you plan to modify your configuration
    using script files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务器提供了多种方法来将数据源添加到您的配置中。我们只提及命令行界面方法，这可能会非常有用，尤其是如果您计划使用脚本文件修改您的配置。
- en: 'Launch the `jboss-cli.sh` script (or `jboss-cli.bat`) and connect to the application
    server, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 `jboss-cli.sh` 脚本（或 `jboss-cli.bat`）并连接到应用程序服务器，如下所示：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now issue the following command, which actually creates a new data source,
    accomplishing the same goal we obtained by editing the configuration file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下命令，该命令实际上创建了一个新的数据源，实现了我们通过编辑配置文件所获得的目标：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The CLI should respond with a `success` message if everything goes well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，CLI 应该会响应一个 `success` 消息。
- en: Creating the Maven project
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Maven 项目
- en: The application that we're going to create in this chapter will require only
    standard Java EE 7 APIs from us. Having knowledge from previous chapters, you
    should be able to set up a project for this chapter by yourself! Just use your
    favorite IDE and create a Maven project with `war` type. Remember to include the
    configuration for Java SE 8, `beans.xml` and `faces-config.xml` files. If you
    face any problems, remember that code samples available with this book contain
    a full project based on this example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要创建的应用程序只需要我们使用标准的Java EE 7 API。有了前面章节的知识，你应该能够自己设置本章的项目！只需使用你喜欢的IDE，创建一个`war`类型的Maven项目。记得包括Java
    SE 8的配置，以及`beans.xml`和`faces-config.xml`文件。如果你遇到任何问题，请记住，本书中提供的代码示例包含一个基于此示例的完整项目。
- en: Adding the Maven configuration
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Maven配置
- en: 'Now that your Maven skeleton is set up, we will include the required dependencies
    so that Eclipse will be able to compile your classes as you code them. The only
    dependency you will need for this type is `javaee-api`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了Maven骨架，我们将包括所需的依赖项，以便Eclipse能够在你编码时编译你的类。你将需要的唯一依赖项是`javaee-api`：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cooking entities
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烹饪实体
- en: Now that we're done with the configuration part, we will add our entities to
    the project. Some valuable options exist to autogenerate our entities, starting
    with the database schema. For example, the Eclipse's **File** menu includes an
    option **JPA Entities from Table** that (once a connection has been set up in
    the database) allows you to reverse your DB schema (or a part of it) into Java
    entities.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了配置部分，我们将把我们的实体添加到项目中。有一些很有价值的选项可以自动生成我们的实体，从数据库模式开始。例如，Eclipse的**文件**菜单包括一个选项**从表生成JPA实体**，一旦在数据库中设置了连接，它允许你将你的DB模式（或其一部分）反向生成到Java实体。
- en: 'If you are willing to try this option, remember that you need to activate the
    **Eclipse JPA** facet in your project, from **Project Properties**, as shown in
    the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意尝试这个选项，请记住，你需要在你的项目中激活**Eclipse JPA**特性，从**项目属性**中，如图所示：
- en: '![Cooking entities](img/00045.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![烹饪实体](img/00045.jpeg)'
- en: One more option is mentioned in [Appendix](part0067_split_000.html#page "Appendix A. Rapid
    Development Using JBoss Forge"), *Rapid Development Using JBoss Forge*, which
    discusses JBoss Forge, a powerful, rapid application development (aimed at Java
    EE) and project comprehension tool.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在[附录](part0067_split_000.html#page "附录 A. Rapid Development Using JBoss Forge")中提到了另一个选项，即*使用JBoss
    Forge进行快速开发*，该附录讨论了JBoss Forge，这是一个强大的、针对Java EE的快速应用程序开发（旨在Java EE）和项目理解工具。
- en: 'In this chapter, we will focus on generating SQL scripts from Java classes.
    Whatever your strategy is, the expected outcome needs to conform to the following
    entities. Here is the first one, `SeatType`, which maps the table `SEAT_TYPE`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于从Java类生成SQL脚本。无论你的策略是什么，预期的结果都需要符合以下实体。以下是第一个实体，`SeatType`，它映射到`SEAT_TYPE`表：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first meaningful annotation is `@Entity [1]`, which declares the class `Entity`.
    The `@Table [2]` annotation is used to map the bean class with a database table.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个有意义的注解是`@Entity [1]`，它声明了`Entity`类。`@Table [2]`注解用于将bean类映射到数据库表。
- en: The `@Id` annotation, `[3]`, is a mandatory one; it describes the primary key
    of the table. Along with `@Id`, there is the `@GeneratedValue` annotation. This
    is used to declare that the database is in charge of generating the value. You
    can check the Javadoc of this class to explore other strategies for value generation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id`注解，`[3]`，是必须的；它描述了表的主键。与`@Id`一起，还有`@GeneratedValue`注解。这个注解用于声明数据库负责生成值。你可以查看这个类的Javadoc来探索其他值生成策略。'
- en: Moving along, the `@OneToMany` annotation `[4]` defines an association with
    one-to-many cardinality. Actually, the `SeatType` class has many seats. The corresponding
    `Seat` reference is contained in a list collection. We define the `mappedBy` attribute
    in order to set the field, which owns the relationship on the many side.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，`@OneToMany`注解`[4]`定义了一个一对一的关联。实际上，`SeatType`类有许多座位。相应的`Seat`引用包含在一个列表集合中。我们定义`mappedBy`属性来设置拥有关系的多边字段。
- en: The `fetch` attribute defines that JPA should fetch the list of seats whenever
    a `seat` type is loaded from the database. A lazy configuration for a relationship
    would cause the list to be fetched on the first call to that field.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`属性定义了每当从数据库加载`seat`类型时，JPA应该检索座位列表。对于关系的延迟配置会导致在第一次调用该字段时检索列表。'
- en: Finally, note that we have not included here, for the sake of brevity, the field
    getters and setters that have been generated.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，为了简洁起见，我们没有在此处包含生成的字段获取器和设置器。
- en: 'Let''s take a look at the `Seat` entity:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`Seat`实体：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the `Seat` entity has the corresponding `@ManyToOne [1]` annotation,
    which naturally complements the `@OneToMany` relationship. The `@JoinColumn [2]`
    notifies the JPA engine that the `seatType` field is mapped through the foreign
    key of the database's seat ID.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Seat`实体具有相应的`@ManyToOne [1]`注解，这自然补充了`@OneToMany`关系。`@JoinColumn [2]`通知JPA引擎`seatType`字段是通过数据库座位ID的外键进行映射的。
- en: Adding Bean Validation
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Bean Validation
- en: '**Bean Validation (JSR-303)** is a validation model available as part of the
    Java EE 6 platform. The new 1.1 version (**JSR-349**) is a part of Java EE 7\.
    The Bean Validation model is supported by constraints in the form of annotations
    placed on a field, method, or class of a JavaBeans component, such as a managed
    bean.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bean Validation (JSR-303)**是Java EE 6平台的一部分提供的验证模型。新的1.1版本（**JSR-349**）是Java
    EE 7的一部分。Bean Validation模型通过在JavaBeans组件的字段、方法或类上放置的注解形式的约束得到支持，例如管理Bean。'
- en: In our example, the `SeatType` entity will be created using an input form; therefore,
    we will need to validate the data that has been entered by the user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`SeatType`实体将通过输入表单创建；因此，我们需要验证用户输入的数据。
- en: 'In our example, we will place a `@javax.validation.constraints.NotNull` constraint
    in every field that is part of the `SeatType` entry form, and a more complex constraint
    in the `description` field, which will set the maximum size for the seat description
    to `25` (the `@javax.validation.constraints.Size` constraint) and allow just letters
    and spaces in it (the `@javax.validation.constraints.Pattern` constraint):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将在`SeatType`表单的每个字段上放置`@javax.validation.constraints.NotNull`约束，并在`description`字段上放置一个更复杂的约束，这将设置座位描述的最大长度为`25`（`@javax.validation.constraints.Size`约束）并允许其中仅包含字母和空格（`@javax.validation.constraints.Pattern`约束）：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we can also place a description on a constraint, which can be
    used to provide a customized error message to the JSF layer should the data fail
    to pass the constraint. You can check the Oracle documentation for a full list
    of constraints available at [http://docs.oracle.com/javaee/7/tutorial/doc/bean-validation001.htm#GIRCZ](http://docs.oracle.com/javaee/7/tutorial/doc/bean-validation001.htm#GIRCZ).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们还可以在约束条件上放置描述，这可以用于在数据未能通过约束条件时向JSF层提供自定义的错误消息。您可以通过Oracle文档查看可用的完整约束列表，网址为[http://docs.oracle.com/javaee/7/tutorial/doc/bean-validation001.htm#GIRCZ](http://docs.oracle.com/javaee/7/tutorial/doc/bean-validation001.htm#GIRCZ)。
- en: 'We also have added a seat position information to our seat type. It is a simple
    enum:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为我们座位类型添加了座位位置信息。它是一个简单的枚举：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we save our `SeatType` entity in the database, we will also store the
    enum value with it. Earlier versions of JPA gave us two options to address it
    automatically (besides manually managing their status), `@Enumarated(EnumType.STRING)`
    and `@Enumarated(EnumType.ORDINAL)`; both had their flaws. The first one is sensitive
    towards enum renaming; the entities in the database will have the full name of
    the enum stored (which sometimes is also a waste of the storage space). The second
    one could create problems when the order of enums would be changed (because it
    stored the index of the enum value). From JPA 2.1, we can create a converter,
    which will automatically convert our enum attributes to specific entries in the
    database. We only need to create an annotated class, which implements the `AttributeConverter`
    interface:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在数据库中保存`SeatType`实体时，我们还将存储与之相关的枚举值。JPA的早期版本提供了两种自动处理它的选项（除了手动管理它们的状态），`@Enumerated(EnumType.STRING)`和`@Enumerated(EnumType.ORDINAL)`；两者都有其缺陷。第一个对枚举重命名敏感；数据库中的实体将存储枚举的全名（这有时也是存储空间的浪费）。第二个在枚举值的顺序改变时可能会出现问题（因为它存储了枚举值的索引）。从JPA
    2.1开始，我们可以创建一个转换器，它将自动将我们的枚举属性转换为数据库中的特定条目。我们只需要创建一个实现了`AttributeConverter`接口的注解类：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That's all, no additional configuration is required. The `autoApply` attribute
    set to `true` signals JPA to take care of all of our `SeatPosition` enums in entities.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些，不需要额外的配置。将`autoApply`属性设置为`true`表示JPA将负责处理实体中的所有`SeatPosition`枚举。
- en: Configuring persistence
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置持久化
- en: The Entity API looks great and is very intuitive, but how does the server know
    which database is supposed to store/query the entity objects? The `persistence.xml`
    file, which will be placed under `src/main/resources/META-INF` of your project,
    is the standard JPA configuration file. By configuring this file, you can easily
    switch from one persistence provider to another and thus, also from one application
    server to another (believe it or not, this is a huge leap towards application
    server compatibility).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实体API看起来很棒，并且非常直观，但服务器如何知道应该存储/查询实体对象的是哪个数据库？位于您项目`src/main/resources/META-INF`下的`persistence.xml`文件是标准的JPA配置文件。通过配置此文件，您可以轻松地从一种持久化提供者切换到另一种，从而也可以从一种应用程序服务器切换到另一种（信不信由你，这向应用程序服务器兼容性迈出了巨大的一步）。
- en: 'In the `persistence.xml` file, we will basically need to specify the persistence
    provider and the underlying data source used. Simply create the following file
    under `src/main/resources/persistence.xml`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`persistence.xml`文件中，我们基本上需要指定持久化提供者和底层的数据源。只需在`src/main/resources/persistence.xml`下创建以下文件：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have highlighted the most important attributes in `persistence.xml`. The
    `name` attribute is a mandatory element, which will be used to reference the persistence
    unit from our Enterprise JavaBeans.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`persistence.xml`中突出了最重要的属性。`name`属性是一个必需的元素，它将被用来从我们的企业JavaBeans中引用持久化单元。
- en: In the example code, we use the WildFly built-in memory H2 database ([http://www.h2database.com/](http://www.h2database.com/))
    available by default at `java:jboss/datasources/ExampleDS` (so that it is possible
    to run the example without any setup). However, you can use a configured PostgreSQL
    connection here, `java:jboss/datasources/wflydevelopment`, which we created earlier.
    In Java EE 7, you could even omit the whole `jta-data-source` tag. Every container
    is now obliged to provide a default data source for applications to use. For WildFly,
    it would be the aforementioned H2 database.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码中，我们使用WildFly内置的内存H2数据库（[http://www.h2database.com/](http://www.h2database.com/）），默认情况下在`java:jboss/datasources/ExampleDS`处可用（这样就可以在不进行任何设置的情况下运行示例）。然而，您也可以在这里使用配置好的PostgreSQL连接，即`java:jboss/datasources/wflydevelopment`，这是我们之前创建的。在Java
    EE 7中，甚至可以省略整个`jta-data-source`标签。现在每个容器都必须为应用程序提供默认数据源。对于WildFly来说，将是上述的H2数据库。
- en: We also define the classes that should be considered as entities. This is an
    optional step; if the entities are in the same archive as the `persistence.xml`
    file, they will be autodiscovered.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了应被视为实体的类。这是一个可选步骤；如果实体与`persistence.xml`文件在同一存档中，它们将被自动发现。
- en: In previous JPA versions, almost every configuration needed some provider-specific
    properties. In JPA 2.1, a number of standard properties were added, such as presented
    `javax.persistence.schema-generation.database.action`. The `drop-and-create` value
    can be used to create and drop your database tables each time you deploy your
    application. This can be an advantage if you want to start with a clean storage
    each time you deploy the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的JPA版本中，几乎每个配置都需要一些提供者特定的属性。在JPA 2.1中，添加了一些标准属性，例如展示的`javax.persistence.schema-generation.database.action`。可以使用`drop-and-create`值在每次部署应用程序时创建和删除您的数据库表。如果您希望每次部署应用程序时都从一个干净的数据存储开始，这可能是一个优点。
- en: 'However, it is also possible to instruct JPA to generate SQL scripts for you,
    so you can manually apply them to the database. Simply add the following entries
    to your `persistence-unit` tag:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可以指示JPA为您生成SQL脚本，这样您可以手动将它们应用到数据库中。只需将以下条目添加到您的`persistence-unit`标签中：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you don't specify the location by specifying an additional property, then
    the generated scripts will be placed in the `JBOSS_HOME/bin` directory, with the
    names that you provided in the configuration. The names can be absolute paths,
    so you can get the scripts to any place in your filesystem (if WildFly is permitted
    to write them there of course).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不通过指定一个额外的属性来指定位置，那么生成的脚本将被放置在`JBOSS_HOME/bin`目录中，名称与配置中提供的名称相同。名称可以是绝对路径，这样您可以将脚本放置在文件系统的任何位置（当然，如果WildFly被允许写入那里的话）。
- en: Adding producer classes
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加生产者类
- en: Producer classes have been introduced in the earlier chapter as a means of providing
    some resources through CDI to our application. In this example, we will use it
    to produce many resources, such as the JPA Entity Manager and the list of objects
    that are transferred to the JSF views. For this reason, we provided the `LoggerProducer`,
    `FacesContextProducer`, and `EntityManagerProducer` classes that contain some
    general-purpose resources and single instances of the `SeatProducer` and `SeatTypeProducer`
    classes, which will be used to produce collections of entities.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 生产类在早期章节中被引入，作为通过CDI为我们应用程序提供一些资源的一种方式。在这个例子中，我们将使用它来生成许多资源，例如JPA实体管理器和传递给JSF视图的对象列表。因此，我们提供了包含一些通用资源以及`SeatProducer`和`SeatTypeProducer`类的单例的`LoggerProducer`、`FacesContextProducer`和`EntityManagerProducer`类，这些类将用于生成实体集合。
- en: 'Here''s the content of the three basic producer classes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是三个基本生产类的内容：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, these classes will be the factory for the following three kinds
    of resources:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些类将是以下三种资源的工厂：
- en: '`EntityManager`: This will resolve the primary persistence unit since there
    is just one persistence unit defined'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntityManager`：这将解析主持久化单元，因为只定义了一个持久化单元'
- en: '`java.util.Logger`: This will trace some information on the server console'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Logger`：这将记录服务器控制台上的某些信息'
- en: '`FacesContext`: This will be used to output some JSF messages on the screen'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FacesContext`：这将用于在屏幕上输出一些JSF消息'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Producers versus the Java EE 5 @Resource injection**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**生产者与Java EE 5 @Resource注入的比较**'
- en: If you have never used the dependency injections framework before, you might
    wonder what the benefit of adding an extra layer to produce some container resources
    is. The reason becomes evident once you need to change some configuration elements,
    such as the persistence unit. With the older Java EE 5 approach, you will be forced
    to change the `@Resource` injection's details wherever they are used; however,
    using a producer method for it will centralize resource creation, making changes
    trivial.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未使用过依赖注入框架，你可能会想知道添加一个额外的层来生成一些容器资源有什么好处。一旦你需要更改一些配置元素，例如持久化单元，原因就会变得明显。使用较旧的Java
    EE 5方法，你将被迫在所有使用的地方更改`@Resource`注入的细节；然而，使用生产方法将使资源创建集中化，使更改变得简单。
- en: 'Next, we will add some entity producers; let''s add the `SeatTypeProducer`
    and `SeatProducer` classes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些实体生产者；让我们添加`SeatTypeProducer`和`SeatProducer`类：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you have gone through our example in [Chapter 4](part0028_split_000.html#page
    "Chapter 4. Learning Context and Dependency Injection"), *Learning Context and
    Dependency Injection*, you will find nothing new here; as you can see, the class
    will merely produce a collection of `seatTypes`, which is tagged as `@Named` so
    that they can be accessed from JSF EL as well. Additionally, the class contains
    an `observer` handler method (`onListChanged`), which will be fired when data
    in the collection is changed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经通过了我们第4章的例子[第4章](part0028_split_000.html#page "第4章。学习上下文和依赖注入")，您在这里将找不到任何新内容；如您所见，该类仅生成一个标记为`@Named`的`seatTypes`集合，以便可以从JSF
    EL中访问。此外，该类包含一个`observer`处理方法（`onListChanged`），当集合中的数据发生变化时，该方法将被触发。
- en: 'The collection data is filled using the `retrieveAllSeatTypes` method (loaded
    the first and only time when the class is constructed) of the `SeatTypeDao` CDI
    Bean. We will define this bean in a moment; right now, we will add the last producer
    class used in this example, the `SeatProducer` bean:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 集合数据是通过`SeatTypeDao` CDI Bean的`retrieveAllSeatTypes`方法（在类构造时首次和唯一加载）填充的。我们将在稍后定义这个bean；现在，我们将添加这个例子中使用的最后一个生产类，即`SeatProducer`
    bean：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding bean will be used to produce the list of `Seat` objects that will
    actually be available for booking.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的bean将被用来生成实际可用于预订的`Seat`对象列表。
- en: Coding queries for your application
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的应用程序编写查询代码
- en: 'As you can see from the earlier code, the producer classes make use of beans
    named `SeatDao` and `SeatTypeDao` to fill their collections of data. These beans
    perform some simple finds on the `Seat` and `SeatType` objects, as shown in the
    following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中看到的，生产类使用了名为`SeatDao`和`SeatTypeDao`的bean来填充它们的数据集合。这些bean对`Seat`和`SeatType`对象执行一些简单的查找，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, both `SeatDao` and `SeatTypeDao` beans extend the generic `AbstractDao`
    class. It wraps `EntityManager` and provides basic type-safe CRUD operations such
    as `findAll`, `persist`, and so on using the JPA Criteria API. JPA allows execution
    of the following three types of queries:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`SeatDao`和`SeatTypeDao`这两个bean都扩展了通用的`AbstractDao`类。它封装了`EntityManager`，并使用JPA
    Criteria API提供了基本的类型安全CRUD操作，例如`findAll`、`persist`等。JPA允许执行以下三种类型的查询：
- en: '**Native SQL**: These queries use the standard SQL language. When using this
    type of queries, you have to remember queries can be incompatible when migrating
    between different databases.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生SQL**：这些查询使用标准SQL语言。在使用此类查询时，你必须记住查询在迁移到不同数据库时可能会不兼容。'
- en: '**Java Persistence Query Language** (**JPQL**): These queries can be formed
    using special language similar to SQL. In practice, this method is often hard
    to maintain without good IDE support, especially during refactoring. These queries
    can also be compiled at startup, which means that they are not resolved multiple
    times. Finally, they can be used by a caching mechanism to avoid unnecessary database
    operations for queries that are called frequently. You can define a query and
    its name in the entity in the `@NamedQuery(name="…", query="…")` annotation.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java持久化查询语言**（**JPQL**）：这些查询可以使用类似于SQL的特殊语言形成。在实践中，如果没有良好的IDE支持，这种方法通常很难维护，尤其是在重构期间。这些查询也可以在启动时编译，这意味着它们不会被多次解析。最后，它们可以通过缓存机制用于频繁调用的查询，以避免不必要的数据库操作。你可以在`@NamedQuery(name="…",
    query="…")`注解中定义查询及其名称。'
- en: '**Criteria API**: These queries can be formed by simply executing Java methods
    and the usage of appropriate objects. Since JPA 2.1, it''s possible to perform
    bulk updates and deletions through this API.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Criteria API**：这些查询可以通过简单地执行Java方法和使用适当的对象来形成。自JPA 2.1以来，可以通过此API执行批量更新和删除。'
- en: 'Let''s make a simple comparison of these three methods using an example. We
    want to just get all the objects of a given type. Using native SQL, this query
    would look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子简单比较这三种方法。我们只想获取给定类型的所有对象。使用原生SQL，这个查询看起来是这样的：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, it uses standard SQL in the form of a string. Now let''s look
    at JPQL:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它使用字符串形式的标准SQL。现在让我们看看JPQL：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It''s easy to notice its similarity to SQL but a bit different. It uses, for
    example, class name instead of table name. However, again, it''s a query in a
    string. The last example is the Criteria API:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易注意到它与SQL的相似性，但略有不同。例如，它使用类名而不是表名。然而，再次强调，它是一个字符串形式的查询。最后一个例子是Criteria API：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At first glance, it looks like the most complicated one, but it has some advantage,
    that is, it does not use any strings (which are usually error-prone and hard to
    refactor). Both JPQL and Criteria API have many improvements in the newest JPA
    version, concerning join operations using the `on` condition, database functions
    support, and arithmetic subqueries.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，它似乎是最复杂的，但它有一些优势，即它不使用任何字符串（通常是易出错的且难以重构）。JPQL和Criteria API在最新版本的JPA中都有许多改进，包括使用`on`条件进行连接操作、数据库函数支持和算术子查询。
- en: You may ask yourself, "Which one should I use?" It's a hard question because
    all of them have their pros and cons so it depends on the specific case. Basically,
    Criteria query and named queries are normally a safe bet. Native SQL should have
    a really good justification, as it's usually not portable between different vendors
    and cannot be validated by JPA before the execution.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，“我应该使用哪一个？”这是一个难题，因为它们都有其优缺点，所以这取决于具体的情况。基本上，Criteria查询和命名查询通常是安全的赌注。原生SQL应该有很好的理由，因为它通常在不同供应商之间不可移植，并且在执行之前不能由JPA验证。
- en: Adding services to your application
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将服务添加到您的应用程序中
- en: 'Until now, we coded all the information that will be visible to the user through
    the application screen. What is obviously missing here is all the business logic
    that translates ultimately into inserting data or updating the existing data.
    For this reason, we will now add two classes; first, under `com.packtpub.wflydevelopment.chapter5.control`
    package and second under `com.packtpub.wflydevelopment.chapter5.controller`. The
    first one is `TicketService`, which is a stateless EJB that will be used to perform
    the core business logic of this application, and the second one is our `stateful`
    EJB''s counterpart, the `BookerService` class. Let''s start with the stateless
    EJB:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过应用程序屏幕可见的所有信息都是我们编写的。显然，这里缺少的是所有最终转化为插入数据或更新现有数据的业务逻辑。因此，我们现在将添加两个类；第一个位于
    `com.packtpub.wflydevelopment.chapter5.control` 包下，第二个位于 `com.packtpub.wflydevelopment.chapter5.controller`
    包下。第一个是 `TicketService`，这是一个无状态的 EJB，将被用来执行此应用程序的核心业务逻辑，第二个是我们的 `stateful` EJB
    对应的 `BookerService` 类。让我们从无状态的 EJB 开始：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Why has this component been coded as an EJB instead of a CDI Bean?**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这个组件被编码为 EJB 而不是 CDI Bean？**'
- en: One of the main advantages of using EJBs is that they are inherently transactional
    components. However, in Java EE 7, we can use CDI Beans with an additional `@Transactional`
    annotation. The choice now is up to the developer, but EJBs can still prove useful
    in some cases, even for local calls; for example, we can easily demarcate security
    for them (which we will do in the future chapters).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 EJB 的一大主要优势是它们本质上是事务性组件。然而，在 Java EE 7 中，我们可以使用带有额外 `@Transactional` 注解的
    CDI Beans。现在的选择取决于开发者，但 EJB 在某些情况下仍然可能很有用，即使是对于本地调用；例如，我们可以轻松地为它们划分安全权限（我们将在未来的章节中这样做）。
- en: This service is made up of four methods. The first is the `createSeatType` method,
    which will be used in the first application screen to add a new `SeatType` object
    to our theatre. The next method, `createTheatre`, will be invoked once we are
    done with setting up our theatre; so we create the list of seats that will be
    available for booking in the next screen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务由四个方法组成。第一个是 `createSeatType` 方法，它将在第一个应用程序屏幕中用来向我们的剧院添加一个新的 `SeatType` 对象。下一个方法
    `createTheatre` 将在我们完成剧院设置后调用；因此，我们在下一个屏幕中创建可供预订的座位列表。
- en: Next in the list is the `bookSeat` method, which, as you might have guessed,
    will be used to book a seat. Finally, the `doCleanUp` method is actually used
    to perform a cleanup if you want to restart the application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是列表中的 `bookSeat` 方法，正如你可能猜到的，它将被用来预订座位。最后，`doCleanUp` 方法实际上用于执行清理操作，如果你想要重新启动应用程序的话。
- en: 'The last piece of our puzzle is the `BookerService` class, which adds a tiny
    session layer to your application:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拼图中的最后一部分是 `BookerService` 类，它为您的应用程序添加了一个微小的会话层：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding class uses the view scope, which we already described in the previous
    chapters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类使用了视图作用域，我们已经在之前的章节中描述过。
- en: Adding a controller to drive user requests
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加控制器来驱动用户请求
- en: 'The link between the persistence layer and the user''s view falls on the `TheatreSetupService`
    bean, which will drive requests to the actual services exposed by our application.
    Since this bean will be bound to `RequestScope` and we need to expose it to our
    views as well (using `@Named`), we can use the convenient `@Model` annotation
    for it, which is a sum of the following two attributes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化层和用户视图之间的链接落在 `TheatreSetupService` 实例上，它将驱动对应用程序暴露的实际服务的请求。由于此实例将被绑定到 `RequestScope`，并且我们需要将其暴露给我们的视图（使用
    `@Named`），我们可以使用方便的 `@Model` 注解，它是以下两个属性的组合：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `TheatreSetupService` class is expected to complete the following tasks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`TheatreSetupService` 类预计要完成以下任务：'
- en: At first, the `TheatreSetupService` class produces a `SeatType` object `[1]`
    and exposes it to the JSF View layer using the `@Named` annotation.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，`TheatreSetupService` 类生成一个 `SeatType` 对象 `[1]` 并使用 `@Named` 注解将其暴露给 JSF
    视图层。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This technique is a great addition provided by CDI since it removes the need
    to create a boilerplate object, `SeatType`, to transport the information from
    the view to the services. The `SeatType` object is produced by the controller
    and will be populated by the JSF view and persisted by the `TheatreSetupService`
    class.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术是 CDI 提供的伟大补充，因为它消除了创建一个样板对象 `SeatType` 来从视图传输信息到服务的需要。`SeatType` 对象由控制器生成，将由
    JSF 视图填充并由 `TheatreSetupService` 类持久化。
- en: It then drives user navigation between the application screens by returning
    to the home page `[4]`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过返回主页 `[4]` 来驱动用户在应用程序屏幕之间的导航。
- en: We are done with the Java classes. You should now check to make sure that your
    project structure matches the following screenshot:![Adding a controller to drive
    user requests](img/00046.jpeg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了Java类。你现在应该检查确保你的项目结构与以下截图匹配：![添加控制器以驱动用户请求](img/00046.jpeg)
- en: Coding the JSF view
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写JSF视图
- en: Now that our middle tier is completed, we just need to add a couple of JSF views
    to our application in the `views` folder of our web app. The first view, named
    `setup.xhtml`, will set up our theatre and the second one, named `book.xhtml`,
    will be used to book tickets, borrowing some of its code from the earlier chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了中间层，我们只需要在我们的Web应用的`views`文件夹中添加几个JSF视图。第一个视图，命名为`setup.xhtml`，将设置我们的剧院，第二个视图，命名为`book.xhtml`，将用于预订票务，其中一些代码借鉴了前面的章节。
- en: However, this time we would like to make our application a little bit more graphically
    appealing. To keep it simple, we will use **Bootstrap**, a very popular frontend
    framework that will nicely integrate with our JSF views. It heavily relies on
    JavaScript and CSS, but we will only need to use basic HTML to get it up and running
    in our application. Incorporating a strict frontend framework to our application
    will be an opportunity to show how to use Java EE 7 with the newest web technologies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次我们希望使我们的应用程序更具图形吸引力。为了保持简单，我们将使用**Bootstrap**，一个非常流行的前端框架，它将很好地与我们的JSF视图集成。它严重依赖于JavaScript和CSS，但我们在应用程序中只需要使用基本的HTML就能让它启动并运行。将严格的前端框架纳入我们的应用程序将是一个展示如何使用Java
    EE 7与最新Web技术的机会。
- en: You can get the latest version of Bootstrap from [http://getbootstrap.com/](http://getbootstrap.com/)
    and just place all files in the resources directory; however, we won't do it here.
    We will use the WebJars, which are simply JARs that pack client-side web libraries.
    You can find dependencies at [http://www.webjars.org/](http://www.webjars.org/),
    which after adding to your `pom.xml` file will work just like manually adding
    static files to the project. However, thanks to WebJars, we get Maven to control
    our versions, and don't need to worry about polluting our codebase with external
    code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://getbootstrap.com/](http://getbootstrap.com/)获取Bootstrap的最新版本，并将所有文件放置在资源目录中；然而，我们在这里不会这样做。我们将使用WebJars，它们只是打包客户端Web库的JAR文件。你可以在[http://www.webjars.org/](http://www.webjars.org/)找到依赖项，添加到你的`pom.xml`文件后，它们将像手动添加静态文件到项目中一样工作。然而，多亏了WebJars，我们可以让Maven控制我们的版本，并且不需要担心外部代码污染我们的代码库。
- en: 'Now, we need Bootstrap and jQuery, so we will add the following dependencies:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要Bootstrap和jQuery，所以我们将添加以下依赖项：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, when we have the Bootstrap''s libraries in place, we have to link them
    to our code. We will add them to our `WEB-INF/templates/default.xhtml` file along
    with a simple navigation bar:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们已经将Bootstrap的库放置到位后，我们必须将它们链接到我们的代码中。我们将它们添加到我们的`WEB-INF/templates/default.xhtml`文件中，以及一个简单的导航栏：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we will move to the content in `setup.xhtml`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向`setup.xhtml`中的内容：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the preceding view contains a form to enter a new seat type
    in the topmost section. The highlighted input text will actually pass data to
    the `SeatType` object, which will be transferred to the `TheatreSetupService`
    CDI Bean and ultimately persisted when the user clicks on the **Add** button.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前面的视图在顶部部分包含一个表单，用于输入新的座位类型。高亮显示的输入文本实际上会将数据传递给`SeatType`对象，该对象将被传输到`TheatreSetupService`
    CDI Bean，并在用户点击**添加**按钮时最终持久化。
- en: You may also notice many `class` attributes on the tags. These attributes refer
    to the CSS classes defined by Bootstrap; we use them to visualize our validation.
    If a user places some invalid data in a form input, a proper CSS class is assigned
    to it (Bootstrap's `has-error` method in our case). This is, however, a strictly
    frontend-related addition. The JSF validation message will be shown with or without
    it thanks to the `h:messages` tag and the Bean Validation constraints defined
    in the earlier part of this chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会注意到标签上有很多`class`属性。这些属性指的是Bootstrap定义的CSS类；我们使用它们来可视化我们的验证。如果用户在表单输入中放置了一些无效数据，就会给它分配一个合适的CSS类（在我们的例子中是Bootstrap的`has-error`方法）。然而，这只是一个严格的前端相关添加。JSF验证消息将随着`h:messages`标签和在本章前面部分定义的Bean
    Validation约束一起显示或隐藏。
- en: An interesting addition is the fact that we use one of the JSF 2.2 features,
    which eases integration with HTML5 frontend frameworks, the `pass-through` attributes.
    By using the `xmlns:p=http://xmlns.jcp.org/jsf/passthrough` namespacein `p:placeholder`,
    we instruct JSF to ignore an unknown attribute and pass it straight to the renderer.
    Then, Bootstrap's internal mechanisms can interpret the attribute, and provide
    our input controls with placeholder text, which disappears after a control gains
    focus.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的补充是，我们使用了JSF 2.2的一个特性，它简化了与HTML5前端框架的集成，即`pass-through`属性。通过在`p:placeholder`中使用`xmlns:p=http://xmlns.jcp.org/jsf/passthrough`命名空间，我们指示JSF忽略一个未知属性并将其直接传递给渲染器。然后，Bootstrap的内部机制可以解释该属性，并为我们的输入控件提供占位符文本，该文本在控件获得焦点后消失。
- en: 'The next part of the `setup.xhtml` file is available in the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.xhtml`文件的下一部分在以下代码中可用：'
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Each time you add a new block of seats to your theatre, the `dataTable` method
    contained in the lower part of the screen will be updated. When you are done with
    your setup, click on the **Finish** button, which will recall the `finish` method
    of the `TheatreSetupService` CDI Bean, creating the list of seats.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你为你的剧院添加一个新的座位块时，屏幕下方的`dataTable`方法将被更新。当你完成设置后，点击**完成**按钮，这将调用`TheatreSetupService`
    CDI Bean的`finish`方法，创建座位列表。
- en: 'This action will also redirect you to the next view, named `book.xhtml`, which
    is used to book seats:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作还将你重定向到下一个视图，名为`book.xhtml`，用于预订座位：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here''s a snapshot of the project, expanded at the **webapp** level (as you
    can see, we have also included a basic `index.html` screen and an `index.xhtml`
    screen to redirect the user to the initial screen, `setup.xhtml`):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是项目的快照，展开到**webapp**级别（正如你所见，我们还包括了一个基本的`index.html`屏幕和一个`index.xhtml`屏幕，用于将用户重定向到初始屏幕`setup.xhtml`）：
- en: '![Coding the JSF view](img/00047.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![编写JSF视图](img/00047.jpeg)'
- en: Running the example
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'Deploying the application requires, as usual, packaging it using the following
    Maven goal:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序通常需要使用以下Maven目标进行打包：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, provided that you have installed the WildFly Maven plugin, you can
    deploy your application using the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设你已经安装了WildFly Maven插件，你可以使用以下命令部署你的应用程序：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once the deployment has successfully completed, visit `http://localhost:8080/ticket-agency-jpa/`
    to view the application''s welcome page, as shown in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署成功完成，请访问`http://localhost:8080/ticket-agency-jpa/`以查看应用程序的欢迎页面，如下面的截图所示：
- en: '![Running the example](img/00048.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![运行示例](img/00048.jpeg)'
- en: 'Congratulations! You''re done. By clicking on the **Setup Theatre** link, you
    can start creating places in the `setup.xhtml` page. Feel free to experiment with
    the inputs, and try to fill some letters in the price box or numbers in the description,
    as shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了。点击**设置剧院**链接，你可以在`setup.xhtml`页面开始创建地点。请随意尝试输入一些字母到价格框或数字到描述中，如下面的截图所示：
- en: '![Running the example](img/00049.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![运行示例](img/00049.jpeg)'
- en: 'Once you click on the **Finalize the theatre setup** button, you will be redirected
    to the last screen, which performs seat booking in `book.xhtml`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击了**完成剧院设置**按钮，你将被重定向到最后一个屏幕，在该屏幕上在`book.xhtml`进行座位预订：
- en: '![Running the example](img/00050.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![运行示例](img/00050.jpeg)'
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The aim of the new Java Persistence API is to simplify the development of persistent
    entities. It meets this objective through a simple POJO-based persistence model,
    which reduces the number of required classes and interfaces.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Java持久化API的目标是简化持久化实体的开发。它通过一个简单的基于POJO的持久化模型来实现这一目标，该模型减少了所需的类和接口的数量。
- en: In this chapter, we covered a lot of ground, starting with the database schema
    that we reverse engineered using the JBoss tools plugins for Eclipse. Next, we
    coded the set of layers (producers, services, and controllers) that are part of
    the application, along with the JSF Facelets.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从使用Eclipse的JBoss工具插件逆向工程数据库模式开始，覆盖了大量的内容。接下来，我们编写了应用程序的一部分层（生产者、服务和控制器），以及JSF
    Facelets。
- en: In the next chapter, we will discuss developing applications using **JBoss Messaging
    Provider** (**HornetQ**) by introducing examples with message-driven beans using
    the new simplified Java EE 7 API.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过介绍使用新简化的Java EE 7 API的消息驱动Bean的示例来讨论使用**JBoss消息提供程序**（**HornetQ**）开发应用程序。
