- en: Building Modular Applications with Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java 9构建模块化应用程序
- en: In the last chapter, we covered changes in Java 9 with regards to variable handlers
    and how they related to the AtoMiC Toolkit. We also covered depreciation warnings
    and why they are now suppressed under specific circumstances. Five enhancements
    to changes introduced with Java 7 as part of *Project Coin* were also reviewed.
    Finally, we explored the improvements to import statement processing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了Java 9中关于变量处理器的变化以及它们与AtoMiC Toolkit的关系。我们还介绍了弃用警告以及为什么在特定情况下它们现在被抑制。我们还回顾了Java
    7中*Project Coin*引入的变化的五个增强功能。最后，我们探讨了导入语句处理的改进。
- en: In this chapter, we will examine the structure of a Java module as specified
    by *Project Jigsaw*. We will take a deep-dive into how *Project Jigsaw* is implemented
    as part of the Java platform. We will also review key internal changes to the
    Java platform as they relate to the modular system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查由*Project Jigsaw*指定的Java模块结构。我们将深入了解*Project Jigsaw*作为Java平台一部分的实现方式。我们还将回顾与模块化系统相关的Java平台的关键内部变化。
- en: 'The topics we will cover here are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里讨论的主题包括：
- en: An introduction to Java modularity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java模块化简介
- en: Review of the Java platform's module system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台模块系统的回顾
- en: Modularizing JDK source code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化JDK源代码
- en: Modular runtime images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化运行时镜像
- en: Getting to know the module system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解模块化系统
- en: Modular Java application packaging
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化Java应用程序打包
- en: The Java linker
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java链接器
- en: Encapsulation of internal APIs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部API的封装
- en: A modular primer
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化入门
- en: Before we dive into the Java 9 enhancements in this chapter, let's examine what
    modularity is in the context of Java.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入本章中Java 9的增强功能之前，让我们先考察一下在Java环境中模块化的含义。
- en: We can define the term **modular** as a type of design or construction, in our
    context, of computer software. This type of software design involves a set of
    modules that collectively comprise the whole. A house, for example, can be built
    as a single structure or in a modular fashion where each room is constructed independently
    and joined to create a home. With this analogy, you could selectively add or not
    add modules in the creation of your home. The collection of modules, in our analogy,
    becomes the design of your home. Your design does not need to use every module,
    only the ones you want. So, for example, if there are basement and bonus room
    modules and your design does not include those modular rooms, those modules are
    not used to build your home. The alternative would be that every home would include
    every room, not just the ones that are used. This, of course, would be wasteful.
    Let's see how that correlates to software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将术语**模块化**定义为一种设计或构建类型，在我们的上下文中，是计算机软件的设计。这种类型的软件设计涉及一组模块，这些模块共同构成了整体。例如，一栋房子可以作为一个单一的结构建造，或者以模块化的方式建造，其中每个房间都是独立建造的，然后连接起来形成一个家。通过这个类比，你可以在创建你的家时选择性地添加或不添加模块。在我们的类比中，模块的集合变成了你家的设计。你的设计不需要使用每个模块，只需要你想要的那些。所以，例如，如果有地下室和奖励室模块，而你的设计不包括这些模块化的房间，那么这些模块就不会用来建造你的家。另一种选择是每个家都包括每个房间，而不仅仅是那些被使用的房间。这当然是浪费的。让我们看看这如何与软件相关联。
- en: 'This concept can be applied to computer architecture and software systems.
    Our systems can be comprised of several components instead of one behemoth system.
    As you can likely imagine, this provides us with some specific benefits:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可以应用于计算机架构和软件系统。我们的系统可以由几个组件组成，而不是一个庞大的系统。正如你可能想象的那样，这为我们提供了一些特定的好处：
- en: We should be able to scale our Java applications to run on small devices
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够扩展我们的Java应用程序以在小型设备上运行
- en: Our Java applications will be smaller
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的Java应用程序将更小
- en: Our modular code can be more targeted
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的可模块化代码可以更加具有针对性
- en: Increased use of the object-oriented programming model
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程模型的使用增加
- en: Additional opportunities for encapsulation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加封装的机会
- en: Our code will be more efficient
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码将更高效
- en: Java applications will have increased performance
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java应用程序将具有更高的性能
- en: Overall system complexity is reduced
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体系统复杂性降低
- en: Testing and debugging is easier
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和调试更容易
- en: Code maintenance is easier
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码维护更容易
- en: 'The shift to a modular system for Java was necessary for several reasons. Here
    are the primary conditions of the Java platform as of Java 9 that led to the creation
    of the module system for the Java 9 platform:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于几个原因，Java转向模块化系统是必要的。以下是Java 9平台创建模块化系统的主要条件：
- en: The **Java Development Kit** (**JDK**) was simply too big. This made it difficult
    to support small devices. Even with the compact profiles discussed in the next
    section, supporting some small devices was difficult at best and, in some cases,
    not possible.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java开发工具包**（**JDK**）过于庞大。这使得支持小型设备变得困难。即使在下一节中讨论的紧凑配置文件中，支持某些小型设备也最多是困难的，在某些情况下甚至是不可能的。'
- en: Due to the over-sized JDK, it was difficult to support truly optimized performance
    with our Java applications. In this case, smaller is better.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于JDK过大，难以支持Java应用程序的真正优化性能。在这种情况下，越小越好。
- en: The **Java Runtime Environment** (**JRE**) was too large to efficiently test
    and maintain our Java applications. This results in time consuming, inefficient
    testing, and maintenance operations.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java运行时环境**（**JRE**）太大，无法有效地测试和维护我们的Java应用程序。这导致耗时、低效的测试和维护操作。'
- en: The **Java Archive** (**JAR**) files were also too large. This made supporting
    small devices problematic.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java归档**（**JAR**）文件也太大。这使得支持小型设备变得有问题。'
- en: Because the JDK and JRE were all encompassing, security was of great concern.
    Internal APIs, for example, that were not used by the Java application, were still
    available due to the nature of the public access modifier.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于JDK和JRE都是全面的，安全性是一个很大的担忧。例如，由于公共访问修饰符的性质，即使Java应用程序没有使用，内部API仍然可用。
- en: Finally, our Java applications were unnecessarily large.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们的Java应用程序是不必要地大的。
- en: 'Modular systems have the following requirements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化系统有以下要求：
- en: There must be a common interface to permit interoperability among all connected
    modules
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个公共接口以允许所有连接的模块之间的互操作性
- en: Isolated and connected testing must be supported
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须支持隔离和连接测试
- en: Compile time operations must be able to identify which modules are in use
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时操作必须能够识别正在使用的模块
- en: Runtime support for modules
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块运行时支持
- en: 'A module is a new concept and component in Java 9; it is a named collection
    of data and code. Specifically, modules are a collection of:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是Java 9中的一个新概念和组件；它是一组命名的数据和代码。具体来说，模块是一组：
- en: Packages
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包
- en: Classes
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Interfaces
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Code
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码
- en: Data
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Resources
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源
- en: 'Key to successful implementation, a module in Java 9 is self-described in its
    modular declaration. Module names must be unique and typically use the reverse
    domain name schema. Here is an example declaration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 成功实施的关键是，Java 9中的模块在其模块声明中自我描述。模块名称必须是唯一的，通常使用反向域名模式。以下是一个示例声明：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Module declarations are contained in a `module-info.java` file that should be
    in the module's root folder. As one might expect, this file is compiled into a
    `module-info.class` file and will be placed in the appropriate output directory.
    These output directories are established in the module source code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 模块声明包含在一个名为 `module-info.java` 的文件中，该文件应位于模块的根目录中。正如人们所期望的，此文件被编译成一个 `module-info.class`
    文件，并将放置在适当的输出目录中。这些输出目录是在模块源代码中建立的。
- en: In the next sections, we will look at specific changes for Java 9 in regards
    to modularity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨Java 9在模块化方面的具体变化。
- en: Reviewing Java's platform module system [JEP-200]
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查Java的平台模块系统 [JEP-200]
- en: 'The core aim of JEP-200 was to modularize the **Java Development Kit** (**JDK**)
    using the **Java Platform Module System** (**JPMS**). Prior to Java 9, our familiarity
    with the JDK includes awareness of its major components:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JEP-200的核心目标是使用**Java平台模块系统**（**JPMS**）对**Java开发工具包**（**JDK**）进行模块化。在Java 9之前，我们对JDK的了解包括对其主要组件的认识：
- en: Java runtime environment (JRE)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java运行时环境（JRE）
- en: The interpreter (java)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器（Java）
- en: Compiler (javac)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器（javac）
- en: The archiver (jar)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归档器（jar）
- en: Document generator (javadoc)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档生成器（javadoc）
- en: 'The task of modularizing the JDK was to break it into components that could
    be combined at compile time or runtime. The modular structure is based on the
    following modular profiles established as compact profiles in Java 8\. Each of
    the three profiles is detailed in the following tables:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将JDK模块化的任务是将其分解成可以在编译时或运行时组合的组件。模块结构基于以下模块配置文件，这些配置文件在Java 8中作为紧凑配置文件建立。以下表格详细说明了这三个配置文件：
- en: '**Compact profile 1**:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**紧凑配置文件 1**：'
- en: '| `java.io` | `java.lang.annotation` | `java.lang.invoke` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `java.io` | `java.lang.annotation` | `java.lang.invoke` |'
- en: '| `java.lang.ref` | `lava.lang.reflect` | `java.math` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `java.lang.ref` | `java.lang.reflect` | `java.math` |'
- en: '| `java.net` | `java.nio` | `java.nio.channels` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `java.net` | `java.nio` | `java.nio.channels` |'
- en: '| `java.nio.channels.spi` | `java.nio.charset` | `java.nio.charset.spi` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `java.nio.channels.spi` | `java.nio.charset` | `java.nio.charset.spi` |'
- en: '| `java.nio.file` | `java.nio.file.attribute` | `java.nio.file.spi` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `java.nio.file` | `java.nio.file.attribute` | `java.nio.file.spi` |'
- en: '| `java.security` | `java.security.cert` | `java.security.interfaces` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `java.security` | `java.security.cert` | `java.security.interfaces` |'
- en: '| `java.security.spec` | `java.text` | `java.text.spi` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `java.security.spec` | `java.text` | `java.text.spi` |'
- en: '| `java.time` | `java.time.chrono` | `java.time.format` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `java.time` | `java.time.chrono` | `java.time.format` |'
- en: '| `java.time.temporal` | `java.time.zone` | `java.util` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.temporal` | `java.time.zone` | `java.util` |'
- en: '| `java.util.concurrent` | `java.util.concurrent.atomic` | `java.util.concurrent.locks`
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.concurrent` | `java.util.concurrent.atomic` | `java.util.concurrent.locks`
    |'
- en: '| `java.util.function` | `java.util.jar` | `java.util.logging` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.function` | `java.util.jar` | `java.util.logging` |'
- en: '| `java.util.regex` | `java.util.spi` | `java.util.stream` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.regex` | `java.util.spi` | `java.util.stream` |'
- en: '| `java.util.zip` | `javax.crypto` | `javax.crypto.interfaces` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.zip` | `javax.crypto` | `javax.crypto.interfaces` |'
- en: '| `javax.crypto.spec` | `javax.net` | `javax.net.ssl` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `javax.crypto.spec` | `javax.net` | `javax.net.ssl` |'
- en: '| `javax.script` | `javax.security.auth` | `javax.security.auth.callback` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `javax.script` | `javax.security.auth` | `javax.security.auth.callback` |'
- en: '| `javax.security.auth.login` | `javax.security.auth.spi` | `javax.security.auth.spi`
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `javax.security.auth.login` | `javax.security.auth.spi` | `javax.security.auth.spi`
    |'
- en: '| `javax.security.auth.x500` | `javax.security.cert` |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `javax.security.auth.x500` | `javax.security.cert` |  |'
- en: '**Compact profile 2**:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**紧凑配置文件 2**:'
- en: '| `java.rmi` | `java.rmi.activation` | `java.rmi.dgc` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `java.rmi` | `java.rmi.activation` | `java.rmi.dgc` |'
- en: '| `java.rmi.registry` | `java.rmi.server` | `java.sql` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `java.rmi.registry` | `java.rmi.server` | `java.sql` |'
- en: '| `javax.rmi.ssl` | `javax.sql` | `javax.transaction` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `javax.rmi.ssl` | `javax.sql` | `javax.transaction` |'
- en: '| `javax.transaction.xa` | `javax.xml` | `javax.xml.database` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `javax.transaction.xa` | `javax.xml` | `javax.xml.database` |'
- en: '| `javax.xml.namespace` | `javax.xml.parsers` | `javax.xml.stream` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `javax.xml.namespace` | `javax.xml.parsers` | `javax.xml.stream` |'
- en: '| `javax.xml.stream.events` | `javax.xml.stream.util` | `javax.xml.transform`
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `javax.xml.stream.events` | `javax.xml.stream.util` | `javax.xml.transform`
    |'
- en: '| `javax.xml.transform.dom` | `javax.xml.transform.sax` | `javax.xml.transform.stax`
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `javax.xml.transform.dom` | `javax.xml.transform.sax` | `javax.xml.transform.stax`
    |'
- en: '| `javax.xml.transform.stream` | `javax.xml.validation` | `javax.xml.xpath`
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `javax.xml.transform.stream` | `javax.xml.validation` | `javax.xml.xpath`
    |'
- en: '| `org.w3c.dom` | `org.w3c.dom.bootstrap` | `org.w3c.dom.events` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `org.w3c.dom` | `org.w3c.dom.bootstrap` | `org.w3c.dom.events` |'
- en: '| `org.w3c.dom.ls` | `org.xml.sax` | `org.xml.sax.ext` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `org.w3c.dom.ls` | `org.xml.sax` | `org.xml.sax.ext` |'
- en: '| `org.xml.sax.helpers` |  |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `org.xml.sax.helpers` |  |  |'
- en: '**Compact profile 3**:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**紧凑配置文件 3**:'
- en: '| `java.lang.instrument` | `java.lang.management` | `java.security.acl` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `java.lang.instrument` | `java.lang.management` | `java.security.acl` |'
- en: '| `java.util.prefs` | `javax.annotation.processing` | `javax.lang.model` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `java.util.prefs` | `javax.annotation.processing` | `javax.lang.model` |'
- en: '| `javax.lang.model.element` | `javax.lang.model.type` | `javax.lang.model.util`
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `javax.lang.model.element` | `javax.lang.model.type` | `javax.lang.model.util`
    |'
- en: '| `javax.management` | `javax.management.loading` | `javax.management.modelmbean`
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `javax.management` | `javax.management.loading` | `javax.management.modelmbean`
    |'
- en: '| `javax.management.monitor` | `javax.management.openmbean` | `javax.management.relation`
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `javax.management.monitor` | `javax.management.openmbean` | `javax.management.relation`
    |'
- en: '| `javax.management.remote` | `javax.management.remote.rmi` | `javax.management.timer`
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `javax.management.remote` | `javax.management.remote.rmi` | `javax.management.timer`
    |'
- en: '| `javax.naming` | `javax.naming.directory` | `javax.naming.event` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `javax.naming` | `javax.naming.directory` | `javax.naming.event` |'
- en: '| `javax.naming.ldap` | `javax.naming.spi` | `javax.security.auth.kerberos`
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `javax.naming.ldap` | `javax.naming.spi` | `javax.security.auth.kerberos`
    |'
- en: '| `javax.security.sasl` | `javax.sql.rowset` | `javax.sql.rowset.serial` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `javax.security.sasl` | `javax.sql.rowset` | `javax.sql.rowset.serial` |'
- en: '| `javax.sql.rowest.spi` | `javax.tools` | `javax.xml.crypto` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `javax.sql.rowest.spi` | `javax.tools` | `javax.xml.crypto` |'
- en: '| `javax.xml.crypto.dom` | `javax.xml.crypto.dsig` | `javax.xml.crypto.dsig.dom`
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `javax.xml.crypto.dom` | `javax.xml.crypto.dsig` | `javax.xml.crypto.dsig.dom`
    |'
- en: '| `javax.xml.crypto.dsig.keyinfo` | `javax.xml.crypto.dsig.spec` | `org.ieft.jgss`
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `javax.xml.crypto.dsig.keyinfo` | `javax.xml.crypto.dsig.spec` | `org.ieft.jgss`
    |'
- en: 'The three compact module profiles represent the basis for the standardized
    modular system in Java 9\. The effectiveness of this standardization relies on
    the following six principles:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中标准模块化系统的基本由三个紧凑模块配置文件表示。这种标准化的有效性依赖于以下六个原则：
- en: All JCP-governed modules must start with the string `java.`. So, if a module
    on spatial utilities was being developed it would have a name such as `java.spatial.util`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有由 JCP 管理的模块都必须以字符串 `java.` 开头。因此，如果一个空间实用工具模块正在开发中，它将有一个类似于 `java.spatial.util`
    的名称。
- en: '**JCP** refers to the **Java Community Process**. JCP allows developers to
    create technical specifications for Java. You can learn more about JCP and become
    a member at the official JCP website--[http://www.jcp.org](http://www.jcp.org).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**JCP**指的是**Java社区进程**。JCP允许开发者为Java创建技术规范。您可以在官方JCP网站上了解更多关于JCP的信息并成为其会员--[http://www.jcp.org](http://www.jcp.org)。'
- en: Non-JCP modules are considered part of the JDK and their names must start with
    the string `jdk.`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非JCP模块被视为JDK的一部分，并且它们的名称必须以字符串`jdk.`开头。
- en: 'Ensure method invocation chaining works properly. This is best illustrated
    with the following flowchart:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保方法调用链正确工作。以下流程图可以最好地说明这一点：
- en: '![](img/5d18802b-2b33-41d5-a8da-ea1be31808e8.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d18802b-2b33-41d5-a8da-ea1be31808e8.png)'
- en: As you can see in the preceding flowchart, it only applies to modules that export
    a package.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的流程图中所见，它仅适用于导出包的模块。
- en: 'The fourth principle deals with both standard and non-standard API packages
    being used in a standard module. The following flowchart illustrates the implementation
    of this principle''s covenants:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个原则涉及在标准模块中使用标准和非标准API包。以下流程图说明了该原则的约定实施：
- en: '![](img/ac898d14-8304-4c49-95f1-1d7d6c282429.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac898d14-8304-4c49-95f1-1d7d6c282429.png)'
- en: The fifth design principle is that standard modules can be dependent upon more
    than one non-standard module. While this dependency is permitted, implied readability
    access to non-standard modules is not.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个设计原则是标准模块可以依赖于多个非标准模块。虽然这种依赖是被允许的，但对非标准模块的隐含可读性访问是不允许的。
- en: The final design principle ensures non-standard modules do not export standard
    API packages.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的设计原则确保非标准模块不导出标准API包。
- en: Modularizing JDK source code [JEP-201]
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化JDK源代码 [JEP-201]
- en: As previously mentioned, Project Jigsaw had the goal of modularization. The
    envisioned standard modular system would be applied to the Java SE platform and
    the JDK. In addition to efficiency gains, the modular shift would result in better
    security and ease maintainability. The enhancement detailed in JEP-201 focused
    on JDK source code reorganization. Let's take a closer look.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Project Jigsaw的目标是模块化。预期的标准模块化系统将应用于Java SE平台和JDK。除了效率提升外，模块化转型还将带来更好的安全性和易于维护性。JEP-201中详细描述的增强主要集中在JDK源代码重组上。让我们更深入地了解一下。
- en: 'Reorganizing the JDK''s source code is a significant task and was accomplished
    with the following subset of goals:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重组JDK的源代码是一项重大任务，并以下列目标集完成：
- en: Provide JDK developers insights and familiarity with the new Java 9 modular
    system. So, this goal was aimed at developers of the JDK, not mainstream developers.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为JDK开发者提供对新的Java 9模块化系统的见解和熟悉度。因此，这个目标针对的是JDK的开发者，而不是主流开发者。
- en: Ensure modular boundaries are established and maintained throughout the JDK
    build process. This was a necessary precaution so the modular system would be
    stable throughout Java 9's enhancements and, more specifically, in implementing
    the modular system.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在整个JDK构建过程中建立并维护模块边界。这是一项必要的预防措施，以确保模块化系统在Java 9的增强过程中以及更具体地，在实施模块化系统时保持稳定。
- en: The third goal was to ensure future enhancements, specifically with *Project
    Jigsaw*, could be easily integrated into the new modular system.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个目标是确保未来的增强，特别是与*Project Jigsaw*相关的增强能够轻松地集成到新的模块化系统中。
- en: The significance of this source code reorganization cannot be overstated. The
    pre-Java 9 source code organization is 20 years old. This overdue JDK source code
    reorganization will make the code much easier to maintain. Let's look at the previous
    organization of the JDK source code and then examine the changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这次源代码重组的重要性不容小觑。Java 9之前的源代码组织已有20年历史。这次久拖不决的JDK源代码重组将使代码维护变得更加容易。让我们先看看JDK源代码的先前组织结构，然后再探讨其中的变化。
- en: Pre-Java 9 JDK source code organization
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9之前的JDK源代码组织
- en: 'The JDK is a compilation of code files, tools, libraries, and more. The following
    illustration provides an overview of the JDK components:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JDK是一系列代码文件、工具、库等内容的集合。以下插图提供了JDK组件的概述：
- en: '![](img/e2bfb59d-d835-4190-9467-bb5287cb5735.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2bfb59d-d835-4190-9467-bb5287cb5735.png)'
- en: The pre-Java 9 organization of the JDK components in the preceding illustration
    are detailed in the next seven subsections.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一幅图示中，Java 9之前的JDK组件组织结构将在接下来的七个子节中详细介绍。
- en: Development tools
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具
- en: The development tools are located in the `\bin` directory. These tools include
    seven broad categorizations, each detailed in the subsequent sections.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 开发工具位于 `\bin` 目录中。这些工具包括七个广泛的分类，每个分类在后续章节中详细说明。
- en: Deployment
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'This is a set of tools intended to help deploy Java applications:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一套旨在帮助部署 Java 应用程序的工具：
- en: '`appletviewer`: This tool gives you the ability to run and debug Java applets
    without the need for a web browser.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appletviewer`: 这个工具允许你在不需要网络浏览器的情况下运行和调试 Java 小程序。'
- en: '`extcheck`: This tool allows you to find conflicts in JAR files.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extcheck`: 这个工具允许你查找 JAR 文件中的冲突。'
- en: '`jar`: This tool is used for creating and manipulating JAR files. JAR files
    are Java Archive files.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jar`: 这个工具用于创建和操作 JAR 文件。JAR 文件是 Java 归档文件。'
- en: '`java`: This is the Java application launcher.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java`: 这是 Java 应用程序启动器。'
- en: '`javac`: This is the Java Compiler.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac`: 这是 Java 编译器。'
- en: '`javadoc`: This tool generates API documentation.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javadoc`: 这个工具生成 API 文档。'
- en: '`javah`: This tool allows you to write native methods; it generates C header
    files.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javah`: 这个工具允许你编写本地方法；它生成 C 头文件。'
- en: '`javap`: This tool disassembles class files.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javap`: 这个工具可以反汇编类文件。'
- en: '`javapackager`: For signing and packaging Java applications, including JavaFX.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javapackager`: 用于签名和打包 Java 应用程序，包括 JavaFX。'
- en: '`jdb`: This is the Java debugger.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdb`: 这是 Java 调试器。'
- en: '`jdeps`: This is an analyzer for Java class dependencies.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdeps`: 这是一个 Java 类依赖分析器。'
- en: '`pack200`: This is a tool that compresses JAR files into `pack200` files. The
    compression ratio using this tool is impressive.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pack200`: 这是一个将 JAR 文件压缩成 `pack200` 文件的工具。使用此工具的压缩比令人印象深刻。'
- en: '`unpack200`: This tool unpacks `pack200` files resulting in JAR files.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unpack200`: 这个工具解包 `pack200` 文件，生成 JAR 文件。'
- en: Internationalization
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: 'If you are interested in creating localizable applications, the following tool
    might come in handy:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣于创建可本地化的应用程序，以下工具可能会很有用：
- en: '`native2ascii`: This tool creates Unicode Latin-1 from normal text.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native2ascii`: 这个工具将普通文本转换为 Unicode Latin-1。'
- en: Monitoring
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: 'Monitoring tools used for providing JVM performance data include:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 用于提供 JVM 性能数据的监控工具包括：
- en: '`jps`: This is the **JVM process status tool** (**jps**). It provides a list
    of HotSpot JVMs on a specific system.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jps`: 这是 **JVM 进程状态工具**（**jps**）。它提供特定系统上 HotSpot JVM 的列表。'
- en: '`jstat`: This is the JVM statistics monitoring tool. It collects log data and
    performance information from a machine with a HotSpot JVM.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jstat`: 这是一个 JVM 统计监控工具。它从具有 HotSpot JVM 的机器上收集日志数据和性能信息。'
- en: '`jstatd`: This is the **jstat** daemon tool. It runs an RMI server app for
    monitoring HotSpot JVM operations.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jstatd`: 这是 `jstat` 守护进程工具。它运行一个 RMI 服务器应用程序以监控 HotSpot JVM 操作。'
- en: RMI
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RMI
- en: '**RMI** tools are **Remote Method Invocation** tools. They help developers
    create applications that operate over a network to include the internet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**RMI** 工具是 **远程方法调用** 工具。它们帮助开发者创建在网络（包括互联网）上运行的应用程序：'
- en: '`rmic`: This tool can generate stubs and skeletons for objects over a network'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rmic`: 这个工具可以生成网络中对象的存根和骨架'
- en: '`rmiregistry`: This is a registry service for remote objects'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rmiregistry`: 这是一个远程对象的注册服务'
- en: '`rmid`: This tool is an activation system daemon for RMI'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rmid`: 这个工具是 RMI 的激活系统守护进程'
- en: '`serialver`: This tool returns the class `serialVersionUID` value'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialver`: 这个工具返回 `serialVersionUID` 类值'
- en: Security
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: 'This set of security tools empowers developers to create security policies
    that can be enforced on the developer''s computer system as well as on remote
    systems:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这套安全工具使开发者能够创建可以在开发者的计算机系统以及远程系统上实施的安全策略：
- en: '`keytool`: This tool manages security certificates and keystores'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keytool`: 这个工具管理安全证书和密钥库'
- en: '`jarsigner`: This tool generates and verifies JAR signatures for creating/opening
    JAR files'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jarsigner`: 这个工具生成和验证 JAR 签名，用于创建/打开 JAR 文件'
- en: '`policytool`: This tool has a graphical user interface that helps developers
    manage their security policy files'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`policytool`: 这个工具具有图形用户界面，可以帮助开发者管理他们的安全策略文件'
- en: Troubleshooting
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'These experimental troubleshooting tools are useful for very specific troubleshooting.
    They are experimental and, therefore, not officially supported:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实验性故障排除工具对于非常具体的故障排除非常有用。它们是实验性的，因此不受官方支持：
- en: '`jinfo`: This tool provides configuration information for specific processes,
    files, or servers.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jinfo`: 这个工具为特定进程、文件或服务器提供配置信息。'
- en: '`jhat`: This is a heap dump tool. It instantiates a web server so that a heap
    can be viewed with a browser.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jhat`: 这是一个堆转储工具。它实例化一个网络服务器，以便可以使用浏览器查看堆。'
- en: '`jmap`: This displays heap and shared object memory maps from a process, file,
    or server.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jmap`：它显示进程、文件或服务器中的堆和共享对象内存映射。'
- en: '`jsadebugd`: This is Java''s Serviceability Agent Debug Daemon. It acts as
    a debug server for a process or file.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsadebugd`：这是Java的服务性代理调试守护进程。它作为进程或文件的调试服务器。'
- en: '`jstack`: This is a Java Stack Trace tool that provides a thread stack trace
    for a process, file, or server.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jstack`：这是一个Java堆栈跟踪工具，为进程、文件或服务器提供线程堆栈跟踪。'
- en: Web services
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务
- en: 'This set of tools provides a utility that can be used with **Java Web Start**
    and other web services:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这套工具提供了一个可以与**Java Web Start**和其他网络服务一起使用的实用程序：
- en: '`javaws`: This is a command line tool that launches Java Web Start.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javaws`：这是一个命令行工具，用于启动Java Web Start。'
- en: '`schemagen`: This tool generates schemas for Java architecture. These schemas
    are used for XML binding.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schemagen`：这是一个用于生成Java架构模式的工具。这些模式用于XML绑定。'
- en: '`wsgen`: This tool is used for generating JAX-WS artifacts that are portable.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wsgen`：这是一个用于生成可移植JAX-WS组件的工具。'
- en: '`wsimport`: This tool is used for importing portable JAX-WS artifacts.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wsimport`：这是一个用于导入可移植JAX-WS组件的工具。'
- en: '`xjc`: This is the binding compiler that is used for XML binding.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xjc`：这是一个用于XML绑定的绑定编译器。'
- en: JavaFX tools
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaFX工具
- en: The JavaFX tools are located in a few different places including `\bin`, `\man`,
    and `\lib` directories.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX工具位于几个不同的位置，包括`\bin`、`\man`和`\lib`目录。
- en: Java runtime environment
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java运行时环境
- en: The **Java runtime environment** (**JRE**) is located in the `\jre` directory.
    Key contents include the **Java Virtual Machine** (**JVM**) and class libraries.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java运行时环境**（**JRE**）位于`\jre`目录中。关键内容包括**Java虚拟机**（**JVM**）和类库。'
- en: Source code
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码
- en: 'The JDK''s source code, pre-Java 9, has the following basic organizational
    schema:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: JDK的源代码，在Java 9之前，具有以下基本组织架构：
- en: '[PRE1]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s look at this a bit closer. After the source code, we have two options.
    If the code is cross-platform, then it is a shared directory; otherwise, it is
    operating system specific. For example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个。在源代码之后，我们有两种选择。如果代码是跨平台的，那么它是一个共享目录；否则，它是特定于操作系统的。例如：
- en: '[PRE2]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we have the classes directory or a native language directory. For example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有类目录或本地语言目录。例如：
- en: '[PRE3]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we have the name of the Java API package followed by the file extension.
    The file extensions depend on content such as `.java`, `.c`, and more.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有Java API包的名称，后面跟着文件扩展名。文件扩展名取决于内容，如`.java`、`.c`等。
- en: Libraries
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: 'The `\lib` directory houses class libraries that are needed by one or more
    of the development tools in the `\bin` directory. Here is a list of files in a
    typical Java 8 `\lib` directory:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`\lib`目录包含`\bin`目录中一个或多个开发工具所需的类库。以下是典型Java 8 `\lib`目录中的文件列表：'
- en: '![](img/7bc7f852-2a14-4e70-965b-d2e0ec699c01.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7bc7f852-2a14-4e70-965b-d2e0ec699c01.png)'
- en: 'Reviewing the directory listing does not provide a great level of granular
    insight. We can list the classes contained in any of the `.jar` files with the
    following command--`jar tvf fileName.jar`. As an example, here is the class listing
    generated from executing `jar tvf javafx-mx.jar` at the command line:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 查看目录列表并不能提供很高的粒度洞察力。我们可以使用以下命令列出任何`.jar`文件中的类--`jar tvf fileName.jar`。以下是一个示例，展示了在命令行中执行`jar
    tvf javafx-mx.jar`生成的类列表：
- en: '![](img/61ce95a2-dbe5-40f1-bc1f-d62543b5de69.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61ce95a2-dbe5-40f1-bc1f-d62543b5de69.png)'
- en: C header files
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C头文件
- en: 'The `/include` directory contains C header files. These files primarily support
    the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`/include`目录包含C头文件。这些文件主要支持以下内容：'
- en: '**Java Native Interface** (**JNI**): This is used for native-code programming
    support. The JNI is used to embed Java native methods and the JVM into native
    apps.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java本地接口**（**JNI**）：用于本地代码编程支持。JNI用于将Java本地方法和JVM嵌入到本地应用程序中。'
- en: '**JVM Tool Interface** (**JVM TI**): This is used by tools for state inspections
    and execution control for apps running the JVM.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JVM工具接口**（**JVM TI**）：由工具用于对运行JVM的应用程序进行状态检查和执行控制。'
- en: Database
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: 'The Apache Derby relational database is stored in the `/db` directory. You
    can learn more about Java DB at the following sites:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Derby关系数据库存储在`/db`目录中。您可以在以下网站了解更多关于Java DB的信息：
- en: '[http://docs.oracle.com/javadb/support/overview.html](http://docs.oracle.com/javadb/support/overview.html)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.oracle.com/javadb/support/overview.html](http://docs.oracle.com/javadb/support/overview.html)'
- en: '[http://db.apache.org/derby/manuals/#docs_10.11](http://db.apache.org/derby/manuals/#docs_10.11)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://db.apache.org/derby/manuals/#docs_10.11](http://db.apache.org/derby/manuals/#docs_10.11)'
- en: JDK source code reorganized
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDK源代码重新组织
- en: 'In a previous section, you learned that the pre-Java 9 source code organization
    schema was as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你了解到Java 9之前的源代码组织模式如下：
- en: '[PRE4]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Java 9, we have a new modular schema. That schema follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，我们有一个新的模块化模式。该模式如下：
- en: '[PRE5]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are a few differences in the new schema, most notably the module name.
    After the shared or OS-specific directory, there is either the classes directory,
    the native directory for C or C++ source files, or a configuration directory.
    This seemingly rudimentary organization schema changes results in a much more
    maintainable code base.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 新模式中存在一些差异，最显著的是模块名称。在共享或操作系统特定的目录之后，要么是类目录，要么是C或C++源文件的本地目录，或者是一个配置目录。这种看似简单的组织模式改变导致代码库更加易于维护。
- en: Understanding modular run-time images [JEP-220]
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模块化运行时图像 [JEP-220]
- en: 'Java 9''s modular system required changes to the runtime images for compatibility.
    Benefits of these changes include enhancements in the following areas:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9的模块化系统需要对运行时图像进行更改以实现兼容性。这些更改的好处包括以下方面的改进：
- en: Maintainability
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性
- en: Performance
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Security
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Core to these changes was a new URI schema used for resource naming. These resources
    include modules and classes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化的核心是一个用于资源命名的新的URI模式。这些资源包括模块和类。
- en: A **Uniform Resource Identifier** (**URI**) is similar to a **URL** (**Uniform
    Resource Locator**) in that it identifies the name and location of something.
    For a URL, that something is a web page; for a URI, it is a resource.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一资源标识符**（**URI**）与**统一资源定位符**（**URL**）类似，因为它标识了某物的名称和位置。对于URL，那是一个网页；对于URI，它是一个资源。'
- en: There were five primary goals for JEP-220 and these are detailed in the following
    sections.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: JEP-220有五个主要目标，以下各节将详细说明。
- en: Runtime format adoption
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时格式采用
- en: 'A run-time format was created for Java 9, for adoption by stored classes and
    other resource files. This format is applicable for stored classes and resources
    under the following circumstances:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为Java 9创建了一种运行时格式，供存储类和其他资源文件采用。此格式适用于以下情况下的存储类和资源：
- en: When the new run-time format has greater efficiencies (time and space) than
    the pre-Java 9 JAR format.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当新的运行时格式比Java 9之前的JAR格式具有更高的效率（时间和空间）时。
- en: A **JAR** file is a **Java ARchieve** file. This is a compressed file format
    based on the legacy ZIP format.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**JAR**文件是一个**Java ARchieve**文件。这是一种基于传统ZIP格式的压缩文件格式。'
- en: When stored classes and other resources can be individually isolated and loaded.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当存储类和其他资源可以单独隔离和加载时。
- en: When JDK and library classes and resources can be stored. This includes app
    modules as well.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当JDK和库类以及资源可以存储时。这包括应用程序模块。
- en: When they are devised in such a way as to promote future enhancements. This
    requires them to be extensible, documented, and flexible.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它们以促进未来增强的方式设计时。这要求它们是可扩展的、有文档的并且灵活的。
- en: Runtime image restructure
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时图像重构
- en: There are two types of runtime images in Java--JDK and JRE. With Java 9, both
    of these image types were restructured to differentiate between files that can
    be used and modified by users to internal files that can be used but not modified
    by developers and their apps.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Java中有两种运行时图像类型--JDK和JRE。随着Java 9的推出，这两种图像类型都被重构，以区分用户可以使用和修改的文件与开发者及其应用程序可以使用的但不能修改的内部文件。
- en: The JDK build system, prior to Java 9, produces both a JRE and a JDK. The JRE
    is a complete implementation of the Java platform. The JDK includes the JRE as
    well as other tools and libraries. A notable change in Java 9 is that the JRE
    subdirectory is no longer part of the JDK image. This change was made, in part,
    to ensure both image types (JDK and JRE) have identical image structures. With
    a common and reorganized structure, future changes will be more efficiently integrated.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9之前，JDK构建系统生成一个JRE和一个JDK。JRE是Java平台的完整实现。JDK包括JRE以及其他工具和库。Java 9的一个显著变化是JRE子目录不再属于JDK图像的一部分。这一变化部分是为了确保这两种图像类型（JDK和JRE）具有相同的图像结构。有了共同和重新组织过的结构，未来的更改将更加高效地集成。
- en: If you created custom plugins prior to Java 9 that address a specific structure,
    your app might not work in Java 9\. This is also true if you are explicitly addressing
    `tools.jar`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在Java 9之前创建了针对特定结构的自定义插件，那么你的应用程序可能在Java 9中无法工作。这也适用于你明确地引用`tools.jar`的情况。
- en: 'The following diagram provides a high-level view of the contents of each image
    before Java 9''s release:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了Java 9发布前每个图像内容的概览：
- en: '![](img/e49f91e4-fc08-4959-a30a-8e86eae30101.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e49f91e4-fc08-4959-a30a-8e86eae30101.png)'
- en: 'The Java 9 runtime images are illustrated in the following diagram. As shown,
    a full JDK image contains the same directories as a modular runtime image as well
    as demo, sample, man, and includes directories:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 Java 9 运行时映像。如图所示，一个完整的 JDK 映像包含与模块化运行时映像相同的目录，以及 demo、sample、man 和 includes
    目录：
- en: '![](img/9603215f-8be0-44b0-9cfd-dfce65051411.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9603215f-8be0-44b0-9cfd-dfce65051411.png)'
- en: There is no longer a difference between a JRE or JDK image. Now, with Java 9,
    a JDK image is a JRE image that contains a full set of dev tools.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不再有 JRE 或 JDK 映像之间的区别。现在，随着 Java 9 的推出，JDK 映像是一个包含完整开发工具的 JRE 映像。
- en: Supporting common operations
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持常见操作
- en: Developers occasionally must write code that performs operations requiring access
    to the runtime image. Java 9 includes support for these common operations. This
    is possible due to the restructuring and standardized JDK and JRE runtime image
    structures.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者有时必须编写执行需要访问运行时映像的操作的代码。Java 9 包括对这些常见操作的支持。这是由于对 JDK 和 JRE 运行时映像结构的重构和标准化而成为可能的。
- en: De-privileging JDK classes
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消 JDK 类的特权
- en: Java 9 allows privilege revocation for individual JDK classes. This change strengthens
    system security in that it ensures JDK classes only receive the permissions required
    for system operations.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 允许撤销单个 JDK 类的特权。这一变化加强了系统安全性，因为它确保 JDK 类只接收系统操作所需的权限。
- en: Preserving existing behaviors
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保留现有行为
- en: The final goal of the JEP-220 was to ensure currently existing classes are not
    negatively impacted. This refers to applications that do not have dependencies
    on internal JDK or JRE runtime images.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: JEP-220 的最终目标是确保现有类不受负面影响。这指的是没有依赖内部 JDK 或 JRE 运行时映像的应用程序。
- en: Getting to know the module system [JEP-261]
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解模块系统 [JEP-261]
- en: 'The purpose of this JEP was the implementation of the new module system for
    the Java platform. You will recall that the modular system was created to provide
    reliable configuration and strong encapsulation for Java programs. Key to this
    implementation was the concept of link time. As illustrated here, link time is
    an optional phase in between compile time and runtime. This phase allows the assembly
    of the appropriate modules into an optimized runtime image. This is possible,
    in part, due to the jlink linking tool which you will learn more about later in
    this chapter:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本 JEP 的目的是实现 Java 平台的新模块系统。您会记得，模块化系统是为了为 Java 程序提供可靠的配置和强大的封装而创建的。这一实现的关键是链接时间概念。如图所示，链接时间是编译时间和运行时间之间可选的阶段。这个阶段允许将适当的模块组装成优化的运行时映像。这在一定程度上是由于
    jlink 链接工具，您将在本章后面了解更多关于它的信息：
- en: '![](img/4cf43046-86d2-4a29-8326-475be2c778c5.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cf43046-86d2-4a29-8326-475be2c778c5.png)'
- en: Module paths
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块路径
- en: It is important to organize modules so that they can be easily located. The
    module path, a sequence of module components or directories, provides the organizational
    structure used by searches. These path components are searched for in order, returning
    the first path component that comprises a module.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 组织模块以便它们可以轻松定位是很重要的。模块路径，一系列模块组件或目录，提供了搜索使用的组织结构。这些路径组件按顺序搜索，返回第一个包含模块的路径组件。
- en: 'Modules and their paths should not be considered to be the same as packages
    or class paths. They are indeed different and have a greater level of fidelity.
    The key difference is that, with classpaths, a singular component is searched
    for. Module path searches return complete modules. This type of search is possible
    by searching the following paths, in the presented order, until a module is returned:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 模块及其路径不应被视为与包或类路径相同。它们确实是不同的，并且具有更高的保真度。关键区别在于，使用类路径时，搜索单个组件。模块路径搜索返回完整的模块。这种搜索可以通过以下路径进行，按此顺序搜索，直到返回一个模块：
- en: Compilation module path
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译模块路径
- en: Upgrade module path
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级模块路径
- en: System modules
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统模块
- en: Application module path
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序模块路径
- en: Let's briefly review each of these paths. The compilation module path is only
    applicable at compile time and contains the module definitions. The upgrade module
    path has the compiled module definitions. The system modules are built-in and
    include Java SE and JDK modules. The final path, the application module path,
    has the compiled module definitions from the application modules as well as the
    library modules.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下这些路径。编译模块路径仅在编译时适用，包含模块定义。升级模块路径包含编译后的模块定义。系统模块是内置的，包括Java SE和JDK模块。最后一个路径，应用程序模块路径，包含来自应用程序模块以及库模块的编译后的模块定义。
- en: Access-control boundary violations
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制边界违规
- en: As a professional developer, you always want your code to be secure, portable,
    and bug-free, which requires strict adherence to Java constructs such as encapsulation.
    There are occasions, such as with white box testing, that you need to break the
    encapsulation that the JVM mandates. This mandate permits cross-modular access.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名专业开发者，你总是希望你的代码是安全的、可移植的、无错误的，这需要严格遵守Java构造，如封装。在某些情况下，例如白盒测试，你需要打破JVM规定的封装。这个规定允许跨模块访问。
- en: 'To permit breaking the encapsulation, you can add an `add-exports` option in
    your module declaration. Here is the syntax you will use:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许打破封装，你可以在你的模块声明中添加一个`add-exports`选项。以下是你会使用的语法：
- en: '[PRE6]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's take a closer look at the preceding syntax. The `<source-module>` and
    `<target-module>` are module names and `<package>` is the name of the package.
    Using the `add-exports` option permits us to violate access-control boundaries.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看前面的语法。《source-module》和`<target-module>`是模块名称，`<package>`是包的名称。使用`add-exports`选项允许我们违反访问控制边界。
- en: 'There are two rules regarding using the add-exports option:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用`add-exports`选项有两个规则：
- en: It can be used multiple times in a module
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在模块中使用多次
- en: Each use must be of a unique pairing of `<source-module>` and `<target-module>`
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次使用都必须是`<source-module>`和`<target-module>`的唯一配对
- en: It is not recommended that the add-exports option be used unless absolutely
    necessary. Its use permits dangerous access to a library module's internal API.
    This type of use makes your code dependent on the internal API not changing, which
    is beyond your control.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议除非绝对必要，否则使用`add-exports`选项。它的使用允许对库模块的内部API进行危险访问。这种使用使得你的代码依赖于内部API不会改变，而这超出了你的控制范围。
- en: Runtime
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时
- en: 'The HotSpot virtual machine implements the `<options>` for the `jmod` and `jlink`
    command-line tools. Here is the list of `<options>` for the `jmod` command-line
    tool:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: HotSpot虚拟机实现了`jmod`和`jlink`命令行工具的`<options>`。以下是`jmod`命令行工具的`<options>`列表：
- en: '![](img/1a89984f-1a29-487b-bfeb-0fbd1b757f9e.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a89984f-1a29-487b-bfeb-0fbd1b757f9e.png)'
- en: 'Here is the list of `<options>` for the `jlink` command-line tool:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`jlink`命令行工具的`<options>`列表：
- en: '![](img/ce4f892d-5c15-4bc5-a95e-80790505bceb.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce4f892d-5c15-4bc5-a95e-80790505bceb.png)'
- en: Modular Java application packaging [JEP-275]
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化Java应用程序打包 [JEP-275]
- en: One of the great improvements in Java 9 is the size of the runtime binaries
    generated by the **Java Packager**. This is possible in part due to the **Java
    Linker**, which is covered in the next section. The Java Packager's workflow has
    essentially remained the same in Java 9 as it was in Java 8\. There have been,
    as you will see later in this section, new tools added to the workflow.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9的一个重大改进是**Java Packager**生成的运行时二进制文件的大小。这在很大程度上得益于下一节中将要介绍的**Java链接器**。Java
    Packager的工作流程在Java 9中基本上与Java 8相同。正如你将在本节后面看到的那样，工作流程中添加了新的工具。
- en: The Java Packager solely creates JDK 9 applications. This change to the Java
    Packager is intended to streamline and make the process of generating runtime
    images more efficient. So, the Java Packager will only create runtime images for
    the SDK version that it is associated with.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Java Packager仅创建JDK 9应用程序。这个对Java Packager的改变旨在简化并使生成运行时图像的过程更高效。因此，Java Packager将只为它关联的SDK版本创建运行时图像。
- en: Advanced look at the Java Linker
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级查看Java链接器
- en: Prior to the Java Linker tool, `jlink`, introduced in Java 9, runtime image
    creation included copying the entire JRE. Then, unused components are removed.
    Simply put, `jlink` facilitates the creation of runtime images with only the required
    modules. `jlink` is used by the Java Packager to generate an embedded runtime
    image.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 链接器工具 `jlink` 之前，Java 9 引入的运行时镜像创建包括复制整个 JRE。然后，删除未使用的组件。简单来说，`jlink`
    促进了仅包含所需模块的运行时镜像的创建。`jlink` 被 Java 打包器用于生成嵌入式运行时镜像。
- en: Java Packager options
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 打包器选项
- en: 'The syntax for the Java Packager is as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Java 打包器的语法如下：
- en: '[PRE7]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are five different commands (`-command`) that can be used. They are described
    as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个不同的命令（`-command`）可以使用。具体描述如下：
- en: '| **command** | **Description** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **command** | **描述** |'
- en: '| `-createbss` | This command is used for converting files from CSS to binary
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `-createbss` | 此命令用于将文件从 CSS 转换为二进制 |'
- en: '| `-createjar` | This command, used along with additional parameters, creates
    a JAR archive file |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `-createjar` | 此命令，结合其他参数，创建 JAR 归档文件 |'
- en: '| `-deploy` | This command is used to generate jnlp and HTML files |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `-deploy` | 此命令用于生成 jnlp 和 HTML 文件 |'
- en: '| `-makeall` | Combines the `-createjar`, `-deploy`, and compilation steps
    |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `-makeall` | 结合 `-createjar`、`-deploy` 和编译步骤 |'
- en: '| `-signJar` | This command creates and signs a JAR file |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `-signJar` | 此命令用于创建并签名 JAR 文件 |'
- en: 'The `[-options]` for the `-createbss` command include:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`-createbss` 命令的 `[-options]` 包括：'
- en: '![](img/496e7e6e-41df-4b22-9052-fdf1f1ed1f75.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/496e7e6e-41df-4b22-9052-fdf1f1ed1f75.png)'
- en: 'The `[-options]` for the `-createjar` command include:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`-createjar` 命令的 `[-options]` 包括：'
- en: '![](img/d5fb7d05-0220-42a0-8bb7-58ed847aae8d.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5fb7d05-0220-42a0-8bb7-58ed847aae8d.png)'
- en: 'The `[-options]` for the `-deploy` command include:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`-deploy` 命令的 `[-options]` 包括：'
- en: '![](img/cda27542-7ded-4b35-ac8b-f827ad8e57c9.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cda27542-7ded-4b35-ac8b-f827ad8e57c9.png)'
- en: 'Here are the remaining `[-options]` for the `-deploy` command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `-deploy` 命令剩余的 `[-options]`：
- en: '![](img/4ff87376-8853-4afd-903d-817cefb62f96.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ff87376-8853-4afd-903d-817cefb62f96.png)'
- en: 'The `[-options]` for the `-makeall` command include:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`-makeall` 命令的 `[-options]` 包括：'
- en: '![](img/0d0ccdef-57ea-449f-8c6a-751fb0716804.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d0ccdef-57ea-449f-8c6a-751fb0716804.png)'
- en: 'The `[-options]` for the `-signJar` include:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`-signJar` 的 `[-options]` 包括：'
- en: '![](img/991302ee-0d7d-4c7a-acc8-83f23ded78d5.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/991302ee-0d7d-4c7a-acc8-83f23ded78d5.png)'
- en: 'The Java Packager is divided into two modules:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Java 打包器分为两个模块：
- en: '[PRE8]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: JLink - The Java Linker [JEP-282]
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JLink - Java 链接器 [JEP-282]
- en: The Java Linker, commonly referred to as JLink, is a tool that was created to
    create custom runtime images. This tool collects the appropriate modules along
    with their dependencies, then optimizes them to create the image. This represents
    a big change for Java, with the release of Java 9\. Before the Java Linker tool,
    `jlink`, was available, runtime image creation included initially copying the
    entire JRE. In a subsequent step, the unused components were removed. In Java
    9, `jlink` creates runtime images with only the needed modules. `jlink` is used
    by the Java Packager to generate an embedded runtime image.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Java 链接器，通常称为 JLink，是一个创建自定义运行时镜像的工具。此工具收集适当的模块及其依赖项，然后对它们进行优化以创建镜像。这代表了 Java
    的一大变化，随着 Java 9 的发布。在 Java 链接器工具 `jlink` 可用之前，运行时镜像的创建最初包括复制整个 JRE。在后续步骤中，删除了未使用的组件。在
    Java 9 中，`jlink` 创建仅包含所需模块的运行时镜像。`jlink` 被用于 Java 打包器以生成嵌入式运行时镜像。
- en: As illustrated in a previous section, JEP-282 resulted in link time as an optional
    phase between compile time and runtime. It is in this phase that the appropriate
    modules are assembled into an optimized runtime image.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，JEP-282 导致链接时间成为编译时间和运行时间之间的一个可选阶段。在这一阶段，适当的模块被组装成一个优化的运行时镜像。
- en: 'JLink is a command-line linking tool that permits the creation of runtime images
    containing a smaller subset of the JDK modules. This results in smaller runtime
    images. The following syntax consists of four components--the `jlink` command,
    options, the module path, and the output path:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: JLink 是一个命令行链接工具，允许创建包含 JDK 模块较小子集的运行时镜像。这导致运行时镜像更小。以下语法包括四个组件--`jlink` 命令、选项、模块路径和输出路径：
- en: '[PRE9]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is a list of the options that can be used with the `jlink` tool along
    with brief descriptions of each:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `jlink` 工具可用的选项列表，以及每个选项的简要描述：
- en: '![](img/11aef842-1b97-4dd6-8084-e27a6158adca.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11aef842-1b97-4dd6-8084-e27a6158adca.png)'
- en: The module path tells the linker where to find the modules. The linker will
    not use exploded modules or JAR/JMOD files.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 模块路径告诉链接器在哪里找到模块。链接器将不会使用展开的模块或 JAR/JMOD 文件。
- en: The output path simply informs the linker where to save the custom run-time
    image.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 输出路径只是简单地通知链接器将自定义运行时镜像保存在哪里。
- en: Encapsulating most internal APIs [JEP-260]
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装大多数内部 API [JEP-260]
- en: JEP-260 was implemented to make the Java platform more secure. The core of this
    JEP's goal was to encapsulate the majority of internal APIs. Specifically, most
    of the JDK's internal APIs are no longer accessible by default. Currently, internal
    APIs deemed to be *critical* and *widely-used* remain accessible. In the future,
    we are likely to see functionality to replace them, and at that time, those internal
    APIs will not be accessible by default.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: JEP-260 的实施是为了使 Java 平台更加安全。这个 JEP 的核心目标是封装大多数内部 API。具体来说，JDK 的大多数内部 API 现在默认不再可访问。目前，被认为是**关键**和**广泛使用**的内部
    API 仍然可访问。在未来，我们可能会看到替代它们的功能，到那时，这些内部 API 将默认不可访问。
- en: So, why is this change necessary? There are a few widely-used APIs that are
    unstable and, in some cases, not standardized. Unsupported APIs should not have
    access to internal details of the JDK. Therefore, JEP-260 resulted in increased
    security of the Java platform. Generally speaking, you should not use unsupported
    APIs in your development projects.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么这个改动是必要的呢？有几个广泛使用的 API 不稳定，在某些情况下，还没有标准化。不支持的 API 不应该能够访问 JDK 的内部细节。因此，JEP-260
    导致了 Java 平台安全性的提高。一般来说，您不应该在开发项目中使用不支持的 API。
- en: 'The aforementioned critical APIs (internal to the JDK) are:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 上述关键 API（JDK 内部）如下：
- en: '`sun.misc`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc`'
- en: '`sun.misc.Unsafe`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc.Unsafe`'
- en: '`sun.reflect.Reflection`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.reflect.Reflection`'
- en: '`sun.reflect.ReflectionFactory.newConstrutorForSerialization`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.reflect.ReflectionFactory.newConstrutorForSerialization`'
- en: The aforementioned critical internal APIs are still accessible in JDK 9\. They
    will be accessible with the `jdk.unsupported` JDK module. Full JRE and JDK images
    will contain the `jdk.unsupported` module.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 上述关键内部 API 在 JDK 9 中仍然可访问。它们将通过 `jdk.unsupported` JDK 模块进行访问。完整的 JRE 和 JDK 镜像将包含
    `jdk.unsupported` 模块。
- en: You can use the Java Dependency Analysis Tool, `jdeps`, to help determine if
    your Java program has any dependencies on JDK internal APIs.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Java 依赖分析工具 `jdeps` 来帮助确定您的 Java 程序是否依赖于 JDK 内部 API。
- en: This is an interesting change to watch. It is likely that the currently accessible
    internal APIs will not be accessible by default when Java 10 is released.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个值得关注的有趣变化。很可能，当 Java 10 发布时，目前可访问的内部 API 将不会默认可访问。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined the structure of Java modules as specified by *Project
    Jigsaw* and took an in-depth look at how *Project Jigsaw* was implemented to improve
    the Java platform. We also reviewed key internal changes to the Java platform
    as they relate to the modular system. Our review started with a modular primer
    where we learned about Java 9's modular system in terms of benefits and requirements.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们检查了由 *Project Jigsaw* 指定的 Java 模块结构，并深入探讨了 *Project Jigsaw* 如何实现以改进 Java
    平台。我们还回顾了与模块化系统相关的 Java 平台的关键内部更改。我们的回顾从模块入门开始，我们学习了 Java 9 的模块化系统在优势和需求方面的内容。
- en: We explored how Java 9 introduced modularity to the JDK including its source
    code and organization of the same. The seven primary tool categories that make
    up the JDK were also explored. As we learned, modularity in Java 9 also extends
    to runtime images resulting in more maintainability, better performance, and increased
    security. The concept of **link time** was introduced as an optional phase between
    compile-time and runtime. We concluded the chapter with a look at the Java Linker
    and how Java 9 encapsulates internal APIs.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了 Java 9 如何将模块化引入 JDK，包括其源代码和组织结构。我们还探讨了构成 JDK 的七个主要工具类别。正如我们所学的，Java 9
    的模块化也扩展到运行时镜像，从而提高了可维护性、性能和安全性。我们引入了**链接时间**的概念，作为编译时间和运行时间之间的可选阶段。我们以查看 Java
    链接器和 Java 9 如何封装内部 API 来结束本章。
- en: In the next chapter, we will explore how to migrate our existing applications
    to the Java 9 platform. We will look at both manual and semi-automated migration
    processes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将现有应用程序迁移到 Java 9 平台。我们将探讨手动和半自动迁移过程。
