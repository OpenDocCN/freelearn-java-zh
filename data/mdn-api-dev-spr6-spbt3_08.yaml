- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Testing APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 API
- en: Proper automated testing helps you to reduce regression bugs and keeps your
    application stable. It makes sure that every change you make will fail during
    the build or testing phase if the change has any side effects on existing code.
    Investing in a test automation suite can give you peace of mind and will prevent
    any surprises in production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的自动化测试可以帮助您减少回归错误并保持应用程序稳定。它确保您所做的每个更改在构建或测试阶段都会失败，如果更改对现有代码有任何副作用。投资于测试自动化套件可以给您带来安心，并防止在生产中出现任何意外。
- en: This chapter will help you learn about test automation by showing you how to
    implement unit and integration test automation. You will learn how to test APIs
    manually and automatically. First, you will learn about automating unit and integration
    tests. After learning about these forms of automation, you will be able to make
    both types of testing an integral part of any build. You will also learn how to
    set up the **Java Code Coverage** (**JaCoCo**) tool to calculate different code
    coverage metrics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过向您展示如何实现单元和集成测试自动化来帮助您了解测试自动化。您将学习如何手动和自动测试 API。首先，您将学习如何自动化单元和集成测试。在了解这些自动化形式之后，您将能够使这两种类型的测试成为任何构建的组成部分。您还将学习如何设置**Java
    代码覆盖率**（**JaCoCo**）工具来计算不同的代码覆盖率指标。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Testing APIs and code manually
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试 API 和代码
- en: Testing automation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试自动化
- en: Let’s get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter is available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08)找到。
- en: Testing APIs and code manually
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动测试 API 和代码
- en: 'Testing is a continuous process in software development and maintenance cycles.
    You need to do full testing that covers all possible use cases and the respective
    code for each change. Different types of testing can be performed for APIs, including
    the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发和维护周期中的持续过程。您需要对每个更改的所有可能用例及其相应的代码进行全面测试。可以对 API 执行不同类型的测试，包括以下内容：
- en: '**Unit testing**: Unit testing is performed by developers to test the smallest
    unit (such as a class method) of code.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：单元测试由开发者执行，以测试代码的最小单元（例如类方法）。'
- en: '**Integration testing**: Integration testing is performed by developers to
    test the integration of different layers of components.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：集成测试由开发者执行，以测试不同层组件的集成。'
- en: '**Contract testing**: Contract testing is performed by developers to make sure
    any changes that are made to the API won’t break the consumer code. The consumer
    code should always comply with the producer’s contract (API). It is primarily
    required in microservices-based development.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**契约测试**：契约测试由开发者执行，以确保对 API 所做的任何更改都不会破坏消费者代码。消费者代码应始终符合生产者的契约（API）。这在基于微服务开发中是主要要求的。'
- en: '**End-to-end** (**E2E**) **testing**: E2E testing is performed by the **quality
    assurance** (**QA**) team to test end-to-end scenarios, such as from the UI (consumer)
    to the backend.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端**（**E2E**）**测试**：端到端测试由**质量保证**（**QA**）团队执行，以测试端到端场景，例如从 UI（消费者）到后端。'
- en: '**User acceptance testing** (**UAT**): UAT is performed by business users from
    a business perspective and may overlap with E2E testing.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户验收测试**（**UAT**）：UAT 由业务用户从业务角度进行，可能与端到端测试重叠。'
- en: You performed manual API testing by using the cURL and Postman tools earlier
    in this book. Every change requires the APIs to be completely tested – not only
    the impacted APIs. There is a reason for this. You may assume that it only impacts
    certain APIs, but what if your underlying assumptions are wrong? It may impact
    the other APIs that you skipped, which would lead to production issues. This can
    create panic and may require a release to be rolled over or a patch to be released
    with a fix.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本书早期使用 cURL 和 Postman 工具进行了手动 API 测试。每次更改都需要对 API 进行完全测试——不仅仅是受影响的 API。这有原因。您可能认为这只会影响某些
    API，但您的潜在假设如果错了怎么办？它可能会影响您跳过的其他 API，这可能导致生产问题。这可能会引起恐慌，可能需要回滚发布或发布带有修复补丁的补丁。
- en: You don’t want to be in such situations, so products have a separate QA team
    that ensures releases are delivered with the best possible quality. QA teams do
    the separate E2E and acceptance testing (along with business/domain users), apart
    from the testing that’s done by the development team.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您不希望处于这种情况下，因此产品有一个单独的QA团队，确保以最佳可能的质量交付发布。QA团队执行单独的端到端和验收测试（包括业务/领域用户），除了开发团队进行的测试之外。
- en: This extra assurance for high-quality deliverables needs more time and effort.
    The time taken now is much shorter because of automated testing. It was longer
    previously because we performed manual testing; therefore, software development
    cycles used to be huge in comparison to today. **Time to market** (**TTM**) is
    a huge factor in today’s competitive software industry. Today, you need faster
    release cycles. Moreover, quality checks, also known as testing, are an important
    and major part of release cycles.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对高质量交付成果的额外保证需要更多的时间和精力。由于自动化测试，现在所需的时间要短得多。之前因为进行了手动测试，所以时间更长；因此，与今天相比，软件开发周期曾经非常庞大。"上市时间"（**TTM**）是当今竞争激烈的软件行业中的一个重要因素。今天，您需要更快的发布周期。此外，质量检查，也称为测试，是发布周期中的重要和主要部分。
- en: You can reduce the testing time by automating the testing process and making
    it an integral part of the CI/CD pipeline. **CI** stands for **continuous integration**,
    which means *build > test > merge* in a code repository. **CD** stands for **continuous
    delivery** and/or **continuous deployment**, both of which may be used interchangeably.
    Continuous delivery is a process where code is automatically tested and released
    (read and uploaded) to an artifact repository or container registry. Then, it
    can be picked and deployed to a production environment after manual approval.
    Continuous deployment is one step ahead of continuous delivery and automates all
    the steps. Continuous deployment also performs the automatic deployment to production
    once all tests are passed. Products that don’t release their code for public access
    use this approach, such as Facebook and Twitter. On the other hand, products/services
    that are available publicly, such as the Spring Framework and Java, use continuous
    delivery pipelines.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过自动化测试流程并将其作为CI/CD管道的组成部分来减少测试时间。"CI"代表**持续集成**，意味着在代码仓库中的*构建 > 测试 > 合并*。**CD**代表**持续交付**和/或**持续部署**，两者可以互换使用。持续交付是一个过程，其中代码会自动测试并发布（读取和上传）到工件存储库或容器注册库。然后，在手动批准后，它可以被选中并部署到生产环境。持续部署比持续交付更进一步，并自动化所有步骤。持续部署在所有测试通过后也会执行自动部署到生产环境。不向公众开放代码的产品，如Facebook和Twitter，使用这种方法。另一方面，公开可用的产品/服务，如Spring框架和Java，使用持续交付管道。
- en: We’ll automate the manual testing we have done so far in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中自动化到目前为止所进行的手动测试。
- en: Testing automation
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试自动化
- en: Whatever testing you are doing manually can be automated and made part of the
    build. This means that any change or code commit will run the test suite as a
    part of the build. A build will only be successful if all the tests are passed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您正在手动执行什么测试，都可以自动化并将其作为构建的一部分。这意味着任何更改或代码提交都将作为构建的一部分运行测试套件。只有当所有测试都通过时，构建才会成功。
- en: You can add automated integration tests for all the APIs. So, instead of firing
    each API manually using cURL or Insomnia, the build will fire them, and the test
    result will be available at the end of the build.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为所有API添加自动化集成测试。因此，您不需要使用cURL或Insomnia手动触发每个API，构建将触发它们，测试结果将在构建结束时可用。
- en: In this section, you are going to write an integration test that will replicate
    the REST client call and test all the application layers, starting from the controller,
    all the way down to the persistence layer, including the database (H2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将编写一个集成测试，该测试将复制REST客户端调用并测试所有应用程序层，从控制器开始，一直到底层的持久化层，包括数据库（H2）。
- en: But before that, you will add the necessary unit tests. Ideally, these unit
    tests should have been added alongside the development process, or before the
    development process in the case of **test-driven** **development** (**TDD**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但在之前，您将添加必要的单元测试。理想情况下，这些单元测试应该在开发过程中添加，或者在**测试驱动开发**（**TDD**）的情况下在开发过程之前添加。
- en: Unit tests are tests that validate the expected results of small units of code,
    such as a class’s methods. You can avoid most bugs if you have proper tests in
    place with good code (90% or above) and branch coverage (80% and above). Code
    coverage refers to metrics such as the number of lines and branches (such as `if-else`),
    which are validated when the tests are executed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是验证小代码单元（如类的方法）预期结果的测试。如果你有良好的代码（90% 或以上）和分支覆盖率（80% 和以上）的适当测试，你可以避免大多数错误。代码覆盖率是指测试执行时验证的指标，如行数和分支（如
    `if-else`）。
- en: Some classes or methods have dependencies on other classes or infrastructure
    services. For example, controller classes have dependencies on service and assembler
    classes, while repository classes have dependencies on Hibernate APIs. You can
    create mocks to replicate dependency behaviors and assume these are working as
    expected or behave as per the defined tests. This approach will allow you to test
    the actual code unit (such as a method) and validate its behavior.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类或方法依赖于其他类或基础设施服务。例如，控制器类依赖于服务和组装类，而仓库类依赖于 Hibernate API。你可以创建模拟来复制依赖行为，并假设它们按预期或按定义的测试行为工作。这种方法将允许你测试实际的代码单元（如方法）并验证其行为。
- en: In the next section, we’ll explore how to add unit tests before writing the
    integration tests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨在编写集成测试之前如何添加单元测试。
- en: Unit testing
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'I advise you to go back to [*Chapter 6*](B19349_06.xhtml#_idTextAnchor148)
    as a base for this chapter’s code. You don’t have to add any additional dependencies
    for unit tests. You already have the following dependency in `build.gradle` ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle)):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你回到 [*第6章*](B19349_06.xhtml#_idTextAnchor148) 作为本章代码的基础。你不需要为单元测试添加任何额外的依赖项。你已经在
    `build.gradle` 中有了以下依赖项 ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle))：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, `spring-boot-starter-test` adds all the required test dependencies, not
    only for the unit tests but also for the integration tests. You are going to primarily
    use the following libraries for testing:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`spring-boot-starter-test` 添加了所有必需的测试依赖项，不仅用于单元测试，还用于集成测试。你将主要使用以下库进行测试：
- en: '`junit-platform-commons`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junit-platform-commons`.'
- en: '`junit-jupiter-engine` that allows you to run Jupiter-based tests on the JUnit
    Platform. It also provides the `junit-jupiter`, `junit-jupiter-api`, and `junit-jupiter-params`
    libraries.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junit-jupiter-engine` 允许你在 JUnit 平台上运行基于 Jupiter 的测试。它还提供了 `junit-jupiter`、`junit-jupiter-api`
    和 `junit-jupiter-params` 库。'
- en: '**JUnit Vintage** supports older versions of JUnit, such as versions 3 and
    4\. You are going to use the latest version in this book, which is 5, so you don’t
    need this bundle.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JUnit Vintage** 支持JUnit的旧版本，如3和4版本。在这本书中，你将使用最新版本，即5，因此你不需要这个包。'
- en: You can find out more about JUnit at [https://junit.org/](https://junit.org/).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://junit.org/](https://junit.org/) 上了解更多关于 JUnit 的信息。
- en: '**AssertJ**: AssertJ is a test assertion library that simplifies assertion
    writing by providing fluent APIs. It is also extendable. You can write custom
    assertions for your domain objects. You can find more about it at [https://assertj.github.io/doc/](https://assertj.github.io/doc/).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AssertJ**: AssertJ 是一个测试断言库，通过提供流畅的 API 简化了断言的编写。它也是可扩展的。你可以为你的领域对象编写自定义断言。你可以在
    [https://assertj.github.io/doc/](https://assertj.github.io/doc/) 上了解更多信息。'
- en: '**Hamcrest**: Hamcrest is another assertion library that provides assertions
    based on matchers. It also allows you to write custom matchers. You’ll find an
    example of both in this chapter, though AssertJ is preferable because it has fluent
    APIs. Chained methods help IDEs to suggest appropriate assertions based on a given
    object. You can choose one of the assertion libraries or both based on your use
    cases and liking. You can find out more about it at [http://hamcrest.org/](http://hamcrest.org/).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hamcrest**: Hamcrest 是另一个基于匹配器的断言库，它还允许你编写自定义匹配器。你将在本章中找到这两个示例，尽管 AssertJ
    更受欢迎，因为它具有流畅的 API。链式方法帮助 IDE 根据给定的对象建议适当的断言。你可以根据你的用例和喜好选择其中一个断言库或两者都使用。你可以在 [http://hamcrest.org/](http://hamcrest.org/)
    上了解更多信息。'
- en: '**Mockito**: Mockito is a mocking framework that allows you to mock objects
    (read dependencies) and to stub method calls. You can find out more about it at
    [https://site.mockito.org/](https://site.mockito.org/).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mockito**：Mockito是一个允许你模拟对象（读取依赖项）和存根方法调用的模拟框架。你可以在[https://site.mockito.org/](https://site.mockito.org/)了解更多信息。'
- en: You already know that unit tests test the smallest testable code unit. But how
    can we write a unit test for controller methods? The controller runs on web servers
    and has the Spring web application context. If you write a test that uses `WebApplicationContext`
    and is running on top of a web server, then you can call it an integration test
    rather than a unit test.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道单元测试测试的是最小的可测试代码单元。但我们是怎样为控制器方法编写单元测试的呢？控制器在Web服务器上运行，并且拥有Spring Web应用上下文。如果你编写了一个使用`WebApplicationContext`并且运行在Web服务器之上的测试，那么你可以称它为集成测试而不是单元测试。
- en: Unit tests should be lightweight and must be executed quickly. Therefore, you
    must use `MockMvc`, a special class provided by the Spring test library, to test
    the controllers. You can use the standalone setup for `MockMvc` for unit testing.
    You can also use `MockitoExtension` to run the unit test on the JUnit Platform
    (JUnit 5 provides an extension for runners), which supports object mocking and
    method stubbing. You will also use the Mockito library to mock the required dependencies.
    These tests are fast and help developers build faster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该是轻量级的，并且必须快速执行。因此，你必须使用Spring测试库提供的特殊类`MockMvc`来测试控制器。你可以为单元测试使用`MockMvc`的独立设置。你也可以使用`MockitoExtension`在JUnit平台（JUnit
    5为运行器提供了扩展）上运行单元测试，它支持对象模拟和方法存根。你还将使用Mockito库来模拟所需的依赖项。这些测试速度快，有助于开发者更快地构建。
- en: Let’s write our test using AssertJ assertions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用AssertJ断言来编写我们的测试。
- en: Testing using AssertJ assertions
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AssertJ断言进行测试
- en: 'Let’s write our first unit test for `ShipmentController`. The following code
    can be found in `src/test/java/com/packt/modern/api/controller/ ShipmentControllerTest.java`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写第一个针对`ShipmentController`的单元测试。以下代码可以在`src/test/java/com/packt/modern/api/controller/ShipmentControllerTest.java`文件中找到：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/ShipmentControllerTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/ShipmentControllerTest.java)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/ShipmentControllerTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/ShipmentControllerTest.java)'
- en: Here, our test is using a Jupiter-based annotation (`ExtendWith`) that registers
    the extension (`MockitoExtension`) for running tests and supporting Mockito-based
    mocks and stubbing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的测试使用了一个基于Jupiter的注解（`ExtendWith`），它注册了用于运行测试和支持基于Mockito的模拟和存根的扩展（`MockitoExtension`）。
- en: The Spring test library provides the `MockMvc` class, which allows you to mock
    the Spring MVC. As a result, you can execute the controller methods by calling
    the associated API endpoints’ URI. The dependencies of the `ShipmentController`
    controller class, such as the service and assembler, are marked with `@Mock` annotations
    to create the mock instances of its dependencies. You can also use `Mockito.mock(classOrInterface)`
    to create the mock objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Spring测试库提供了`MockMvc`类，它允许你模拟Spring MVC。因此，你可以通过调用相关API端点的URI来执行控制器方法。`ShipmentController`控制器类的依赖项，如服务和组装器，被标记为`@Mock`注解以创建其依赖项的模拟实例。你也可以使用`Mockito.mock(classOrInterface)`来创建模拟对象。
- en: 'Another noticeable annotation is `@InjectMocks` on the controller declaration.
    It finds out all the declared mocks that are required for a testing class and
    injects them automatically. `ShipmentController` uses the `ShipmentService` and
    `ShipmentRepresentation``     ModelAssembler` instances, which are injected using its constructor. The Mockito-based
    `InjectMocks` annotation finds the dependencies in the `ShipmentController` class
    (service and assembler). Then, it looks for mocks of the service and assembler
    in the test class. Once it finds them, it injects these mock objects into the
    `ShipmentController` class. If required, you can also create an instance of the
    testing class using a constructor instead of using `@InjectsMocks`, as shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的注解是控制器声明上的`@InjectMocks`。它会找出测试类所需的全部已声明模拟对象，并自动注入它们。`ShipmentController`使用`ShipmentService`和`ShipmentRepresentation`模型组装器实例，这些实例通过其构造函数注入。基于Mockito的`InjectMocks`注解在`ShipmentController`类中查找依赖（服务和组装器）。然后，它在测试类中寻找服务和组装器的模拟对象。一旦找到，它将这些模拟对象注入到`ShipmentController`类中。如果需要，你也可以使用构造函数创建测试类的实例，而不是使用`@InjectMocks`，如下所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A mock of `MessageSource` is created for `RestApiHandler`, which is being used
    in the setup method. You’ll explore it further in the following code block.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为`RestApiHandler`创建了一个`MessageSource`的模拟对象，该对象在设置方法中使用。你将在下面的代码块中进一步探索它。
- en: The last part of the declaration is `JacksonTester`, which is part of the Spring
    testing library. `JacksonTester` is a custom JSON assertion class that’s created
    using the AssertJ and Jackson libraries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 声明书的最后一部分是`JacksonTester`，它是Spring测试库的一部分。`JacksonTester`是一个使用AssertJ和Jackson库创建的自定义JSON断言类。
- en: The JUnit Jupiter API provides the `@BeforeAll` and `@BeforeEach` method annotations,
    which can be used to set up the prerequisites. As their names suggest, `@BeforeAll`
    is run once per test class, while `@BeforeEach` gets executed before each test
    execution. `@BeforeEach` can be placed on public non-static methods, whereas `@BeforeAll`
    should be used to annotate public static methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit Jupiter API提供了`@BeforeAll`和`@BeforeEach`方法注解，可以用来设置先决条件。正如它们的名称所暗示的，`@BeforeAll`在每个测试类中只运行一次，而`@BeforeEach`在每个测试执行前执行。`@BeforeEach`可以放置在公共非静态方法上，而`@BeforeAll`应该用来注解公共静态方法。
- en: Similarly, JUnit provides the `@AfterAll` and `@AfterEach` annotations, which
    execute the associated methods after each test is executed and after each test
    is executed, respectively.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，JUnit提供了`@AfterAll`和`@AfterEach`注解，分别用于在每个测试执行后和每个测试执行后执行相关的方法。
- en: 'Let’s use the `@BeforeEach` annotation to set up the prerequisites for the
    `ShipmentControll``     erTest` class, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`@BeforeEach`注解来设置`ShipmentControllerTest`类的先决条件，如下所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we initialize the `JacksonTester` fields with the object mapper instance
    received from `AppConfig`. This creates a custom message converter instance (`MappingJackson2HttpMes``sageConverter`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用从`AppConfig`接收到的对象映射器实例初始化`JacksonTester`字段。这创建了一个自定义消息转换器实例（`MappingJackson2HttpMessageConverter`）。
- en: Next, you can create a `mockMvc` instance using the standalone setup and initialize
    the controller advice using its setter method. The `RestApiErrorHandler` instance
    uses the mock object of the `MessageResource` class. You can also set the message
    converter to `mockMvc` before building it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用独立设置创建一个`mockMvc`实例，并使用其setter方法初始化控制器建议。`RestApiErrorHandler`实例使用`MessageResource`类的模拟对象。在构建之前，你也可以将消息转换器设置为`mockMvc`。
- en: Finally, you initialize the instances of `ShipmentEntity` and `Shipment` (model).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你初始化`ShipmentEntity`和`Shipment`（模型）的实例。
- en: 'Next, you are going to write the test for the `GET /api/v1/shipping/{id}` call,
    which uses the `getShipmentByOrderI``d()` method of the `ShipmentController` class.
    Tests are marked with `@Test`. You can also use `@DisplayName` to customize a
    test’s name in the test reports:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将要编写针对`GET /api/v1/shipping/{id}`调用的测试，该调用使用`ShipmentController`类的`getShipmentByOrderId()`方法。测试用`@Test`标记。你也可以使用`@DisplayName`来自定义测试报告中的测试名称：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, you are using the `Given > When > Then` language ([https://cucumber.io/docs/gherkin/](https://cucumber.io/docs/gherkin/)),
    which can be defined as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在使用`Given > When > Then`语言（[https://cucumber.io/docs/gherkin/](https://cucumber.io/docs/gherkin/)），它可以定义为如下：
- en: '`Given`: Context of the test'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Given`: 测试的上下文'
- en: '`When`: Test action'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`When`: 测试动作'
- en: '`Then`: Test result, followed by validation'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Then`: 测试结果，随后进行验证'
- en: 'Let’s read this test from a BDD perspective:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从BDD（行为驱动开发）的角度来阅读这个测试：
- en: '`Given`: The service is available and returns the list of shipments based on
    the given order ID and an assembler, which converts the list of entities into
    a list of models. It also adds HATEOAS links.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Given`: 服务可用，并根据提供的订单 ID 和一个将实体列表转换为模型列表的组装器返回运输列表。它还添加了 HATEOAS 链接。'
- en: '`When`: The user calls the API via `GET /``api/shipping/a1b9b31d-e73c- 4112-af7c-b68530f38222`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`When`: 用户通过 `GET /api/shipping/a1b9b31d-e73c-4112-af7c-b68530f38222` 调用 API。'
- en: '`Then`: The test validates the received shipments associated with the given
    order ID.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Then`: 测试验证了与给定订单 ID 相关的接收到的运输。'
- en: Mockito’s `MockitoBDD` class provides the `given()` fluent API to stub the mock
    objects methods. When `mockMvc.perform()` is called, internally, it calls the
    respective service and assembler mocks, which, in turn, call the stubbed methods
    and return the values defined in the stub (using `given()`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 的 `MockitoBDD` 类提供了 `given()` 流畅 API 来存根模拟对象的方法。当调用 `mockMvc.perform()`
    时，内部它会调用相应的服务和组装器模拟，这些模拟反过来调用存根方法并返回在存根中定义的值（使用 `given()`）。
- en: 'The `andDo(MockMvcResultHandlers.print())` method logs the request and response
    trace, including the payload and response body. If you want to trace all the `mockMvc`
    logs inside a test class, then you can configure them directly while initializing
    `mockMvc` instead of defining them individually in `mockMvc.perform()` calls,
    as shown here (the highlighted code):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`andDo(MockMvcResultHandlers.print())` 方法记录请求和响应跟踪，包括有效载荷和响应体。如果你想在测试类中跟踪所有的
    `mockMvc` 日志，那么你可以在初始化 `mockMvc` 时直接配置它们，而不是在 `mockMvc.perform()` 调用中单独定义，如下所示（高亮代码）：'
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At the end, you perform assertions (whether the status is `200 OK` or not and
    whether the returned JSON object matches the expected object or not) using AssertJ
    fluent APIs. First, you use the `Asserts.assertThat()` function, which takes the
    actual object and compares it with the expected object using the `isEqualTo()`
    method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用 AssertJ 流畅 API 执行断言（状态是否为 `200 OK` 以及返回的 JSON 对象是否与预期对象匹配）。首先，你使用 `Asserts.assertThat()`
    函数，它接受实际对象并使用 `isEqualTo()` 方法将其与预期对象进行比较。
- en: So far, you have used AssertJ assertions. Similarly, you can also use Spring
    and Hamcrest assertions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经使用了 AssertJ 断言。同样，你也可以使用 Spring 和 Hamcrest 断言。
- en: Testing using Spring and Hamcrest assertions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Spring 和 Hamcrest 断言进行测试
- en: 'At this point, you know how to write JUnit 5 tests using `MockitoExtension`.
    You’ll use the same approach to write a unit test, except with assertions. This
    time, you will write an assertion using Hamcrest assertions, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你知道如何使用 `MockitoExtension` 编写 JUnit 5 测试。你将使用相同的方法编写单元测试，除了使用断言。这次，你将使用
    Hamcrest 断言编写一个断言，如下所示：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/AddressControllerTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/AddressControllerTest.java)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/AddressControllerTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/controller/AddressControllerTest.java)'
- en: You have captured the `MockHttpResponse` instance from the `mockMvc.perform()`
    call in the previous test example – that is, `testGetShipmentByOrderId()`. This
    time, you will directly use the returned value of the `mockMvc.perform()` call
    rather than calling an extra `andReturn().getResponse()` on it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经从之前的测试示例中的 `mockMvc.perform()` 调用中捕获了 `MockHttpResponse` 实例——即 `testGetShipmentByOrderId()`。这次，你将直接使用
    `mockMvc.perform()` 调用的返回值，而不是在它上面调用额外的 `andReturn().getResponse()`。
- en: 'The `ResultAction` class provides the `andExpect()` assertion method, which
    takes `ResultMatcher` as an argument. The `StatusResultMatchers.status(). isOk()`
    result matcher evaluates the HTTP status returned by the `perform()` call. The
    `VerifyJson()` method evaluates the JSON response object, as shown in the following
    code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultAction` 类提供了 `andExpect()` 断言方法，它接受 `ResultMatcher` 作为参数。`StatusResultMatchers.status().isOk()`
    结果匹配器评估 `perform()` 调用返回的 HTTP 状态。`VerifyJson()` 方法评估 JSON 响应对象，如下面的代码所示：'
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the `MockMvcResultMatchers.jsonPath()` result matcher takes two arguments
    – a JSON path expression and a matcher. Therefore, first, you must pass the JSON
    field name and then the Hamcrest matcher known as `Is.is()`, which is a shortcut
    for `Is.is(equalsTo(entity.getCity()))`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MockMvcResultMatchers.jsonPath()`结果匹配器接受两个参数——一个JSON路径表达式和一个匹配器。因此，首先，你必须传递JSON字段名，然后是称为`Is.is()`的Hamcrest匹配器，它是`Is.is(equalsTo(entity.getCity()))`的快捷方式。
- en: Writing the unit test for a service is much easier compared to writing one for
    the controller because you don’t have to deal with `MockMvc`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与编写控制器的单元测试相比，编写服务的单元测试要容易得多，因为你不需要处理`MockMvc`。
- en: You will learn how to test private methods in the next subsection.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一小节中学习如何测试私有方法。
- en: Testing private methods
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试私有方法
- en: 'Unit testing a private method is a challenge. The Spring test library provides
    the `ReflectionTestUtils` class, which provides a method called `invokeMethod`.
    This method allows to you invoke private methods. The `invokeMethod` method takes
    three arguments – the target class, the method’s name, and the method’s arguments
    (using variable arguments). Let’s use it to test the `AddressServiceImpl.toEntity()`
    private method, as shown in the following code block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试私有方法是一个挑战。Spring测试库提供了`ReflectionTestUtils`类，它提供了一个名为`invokeMethod`的方法。这个方法允许你调用私有方法。`invokeMethod`方法接受三个参数——目标类、方法名称和方法参数（使用可变参数）。让我们使用它来测试`AddressServiceImpl.toEntity()`私有方法，如下面的代码块所示：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/service/AddressServiceTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/service/AddressServiceTest.java)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/service/AddressServiceTest.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/test/java/com/packt/modern/api/service/AddressServiceTest.java)'
- en: In the preceding code, you can see that when you call `ReflectionTestUtils.invokeMethod()`
    with the given arguments, it returns the `AddressEntity` instance, which has been
    converted using the given argument’s `AddAddressReq` model instance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到当你使用给定的参数调用`ReflectionTestUtils.invokeMethod()`时，它返回一个`AddressEntity`实例，该实例已经使用给定的参数的`AddAddressReq`模型实例进行了转换。
- en: Here, you are using a third kind of assertion using AssertJ’s `BDDAssertions`
    class. The `BDDAssertions` class provides methods that resonate with the BDD style.
    `BDDAssertions.then()` takes the actual value that you want to verify. The `as()`
    method describes the assertion and should be added before you perform the assertion.
    Finally, you perform verification using AssertJ’s assertion methods, such as `isEqualTo()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在使用AssertJ的`BDDAssertions`类提供的第三种断言方式。`BDDAssertions.then()`接受你想要验证的实际值。`as()`方法描述了断言，应该在执行断言之前添加。最后，你使用AssertJ的断言方法，如`isEqualTo()`，来执行验证。
- en: You will learn how to test void methods in the next subsection.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一小节中学习如何测试无返回值的方法。
- en: Testing void methods
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试无返回值的方法
- en: A method that returns a value can easily be stubbed, but how can we stub a method
    that returns nothing? Mockito provides the `doNothing()` method for this. It has
    a wrapper `willDoNothing()` method in the `BDDMockito` class that internally uses
    `doNothing()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值的函数很容易模拟，但如何模拟一个不返回任何值的函数呢？Mockito提供了`doNothing()`方法来处理这种情况。在`BDDMockito`类中有一个包装器`willDoNothing()`方法，它内部使用`doNothing()`。
- en: 'This is very handy, especially when you want such methods to do nothing while
    you’re spying, as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，尤其是在你想要在监视时让这些方法什么都不做的时候，就像这里所示：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `linkedList` is a real object and not a mock. However, if you want to
    stub a specific method, then you can use `spy()`. Here, when the `clear()` method
    is called on `spyLinkedList`, it will do nothing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`linkedList`是一个真实对象，而不是模拟对象。然而，如果你想模拟一个特定的方法，那么你可以使用`spy()`。在这里，当在`spyLinkedList`上调用`clear()`方法时，它将不会做任何事情。
- en: 'Let’s use `willDoNothing` to stub the void method and see how it helps test
    void methods:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`willDoNothing`来模拟无返回值的方法，看看它如何帮助测试无返回值的方法：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, `AddressRepository.deleteById()` is being stubbed using
    Mockito’s `willDoNothing()` method. Now, you can use the `verify()` method of
    Mockito, which takes two arguments – the mock object and its verification mode.
    Here, the `times()` verification mode is used, which determines how many times
    a method is invoked.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`AddressRepository.deleteById()` 正在使用 Mockito 的 `willDoNothing()` 方法进行模拟。现在，你可以使用
    Mockito 的 `verify()` 方法，它接受两个参数——模拟对象和其验证模式。在这里，使用的是 `times()` 验证模式，它确定一个方法被调用的次数。
- en: We’ll learn how to unit-test exceptional scenarios in the next subsection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将学习如何对异常场景进行单元测试。
- en: Testing exceptions
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试异常
- en: 'Mockito provides `thenThrow()` for stubbing methods with exceptions. BDDMockito’s
    `willThrow()` is a wrapper that uses it internally. You can pass the `Throwable`
    argument and test it like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 提供了 `thenThrow()` 用于模拟带有异常的方法。BDDMockito 的 `willThrow()` 是一个包装器，它内部使用它。你可以传递
    `Throwable` 参数并像这样进行测试：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you basically catch the exception and perform assertions on it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你基本上是捕获异常并对它进行断言。
- en: With that, you have explored the unit tests that you can perform for both controllers
    and services. You can make use of these examples and write unit tests for the
    rest of the classes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经探索了可以对控制器和服务执行的单元测试。你可以使用这些示例并为其他类编写单元测试。
- en: Executing unit tests
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行单元测试
- en: 'You can run the following command to execute unit tests:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行以下命令来执行单元测试：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will generate the unit test reports at `Chapter08/build/reports/tests/test/index.html`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `Chapter08/build/reports/tests/test/index.html` 生成单元测试报告。
- en: 'A generated test report will look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的测试报告看起来像这样：
- en: '![Figure 8.1 – Unit test report](img/Figure_08.1_B19349.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 单元测试报告](img/Figure_08.1_B19349.jpg)'
- en: Figure 8.1 – Unit test report
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 单元测试报告
- en: You can click on the links to drill down further. If the test fails, it also
    shows the cause of the error.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击链接进行进一步深入。如果测试失败，它也会显示错误的原因。
- en: Let’s move on to the next section to learn how to configure code coverage for
    unit tests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一节，学习如何为单元测试配置代码覆盖率。
- en: Code coverage
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Code coverage provides important metrics, including line and branch coverage.
    You are going to use the **JaCoCo** tool to perform and report your code coverage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率提供了重要的指标，包括行和分支覆盖率。你将使用 **JaCoCo** 工具来执行和报告代码覆盖率。
- en: 'First, you need to add the `jacoco` Gradle plugin to the `build.gradle` file,
    as shown in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将 `jacoco` Gradle 插件添加到 `build.gradle` 文件中，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/build.gradle)'
- en: 'Next, configure the `jacoco` plugin by providing its version and reports directory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过提供其版本和报告目录来配置 `jacoco` 插件：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, create a new task called `jacocoTestReport` that depends on the `test`
    task because code coverage can only be evaluated after test execution. You don’t
    want to calculate coverage for auto-generated code, so add the `exclude` block.
    Exclusion can be added by configuring `afterEvaluate`, as shown in the following
    code block:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `jacocoTestReport` 的新任务，它依赖于 `test` 任务，因为只有在测试执行之后才能评估代码覆盖率。你不想为自动生成的代码计算覆盖率，所以添加
    `exclude` 块。可以通过配置 `afterEvaluate` 来添加排除，如下面的代码块所示：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, you need to configure `jacocoTestCoverageVerification`, which defines
    the violation rules. We have added instructions to cover the ratio rule in the
    following code block. This will set the expected ratio to a minimum of 90%. If
    the ratio is below 0.9, then it will fail the build. You can find out more about
    such rules at https://docs.gradle.org/current/userguide/jacoco_plugin.html#sec:jacoco_report_violation_rules:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要配置 `jacocoTestCoverageVerification`，它定义了违规规则。我们在下面的代码块中添加了关于覆盖率比率的说明。这将设置期望的比率至少为
    90%。如果比率低于 0.9，则构建将失败。你可以在 https://docs.gradle.org/current/userguide/jacoco_plugin.html#sec:jacoco_report_violation_rules
    了解更多此类规则：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add `finalizedBy(jacocoTestReport)` to the test task, which ensures that
    the `jacocoTestReport` task will execute after performing the tests:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `finalizedBy(jacocoTestReport)` 添加到测试任务中，这确保了 `jacocoTestReport` 任务将在执行测试后执行：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s run the following command to generate the code coverage report:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令来生成代码覆盖率报告：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The previous command will not only run the test but also generate the code
    coverage report, along with the test reports. The code coverage report is available
    at `Chapter08/build/jacoco/test/html/index.html` and looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令不仅会运行测试，还会生成代码覆盖率报告以及测试报告。代码覆盖率报告可在`Chapter08/build/jacoco/test/html/index.html`找到，如下所示：
- en: '![Figure 8.2 – Code coverage report](img/Figure_08.2_B19349.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 代码覆盖率报告](img/Figure_08.2_B19349.jpg)'
- en: Figure 8.2 – Code coverage report
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 代码覆盖率报告
- en: Here, you can see that our instruction coverage is only at 29%, while our branch
    coverage is only at 3%. You can add more tests and increase these percentages.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们的指令覆盖率只有29%，而我们的分支覆盖率只有3%。你可以添加更多测试来提高这些百分比。
- en: You will learn about integration testing in the next section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一节中了解集成测试。
- en: Integration testing
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Once you have the automated integration tests in place, you can ensure that
    any changes you make won’t produce bugs, provided you cover all the testing scenarios.
    You don’t have to add any additional plugins or libraries to support integration
    testing in this chapter. The Spring test library provides all the libraries required
    to write and perform integration testing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了自动化的集成测试，你可以确保你做的任何更改都不会产生错误，前提是你覆盖了所有测试场景。你不需要添加任何额外的插件或库来支持本章中的集成测试。Spring测试库提供了编写和执行集成测试所需的所有库。
- en: Let’s add the configuration for integration testing in the next subsection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一小节中添加集成测试的配置。
- en: Configuring the Integration testing
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置集成测试
- en: 'First, you need a separate location for your integration tests. This can be
    configured in `build.gradle`, as shown in the following code block:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为你的集成测试提供一个单独的位置。这可以在`build.gradle`中配置，如下面的代码块所示：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, you add the integration tests and their resources to source sets. Gradle
    then picks the tests when a relevant Gradle command (`integrationTest`, `build`)
    gets executed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以将集成测试及其资源添加到源集中。当执行相关的Gradle命令（`integrationTest`、`build`）时，Gradle会选择这些测试。
- en: 'Next, you can configure the integration test’s implementation and runtime so
    that it’s extended from the test’s implementation and runtime, as shown in the
    following code block:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以配置集成测试的实现和运行时，使其扩展自测试的实现和运行时，如下面的代码块所示：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, create a task called `integrationTest` that will not only use the JUnit
    Platform but also use our `classpath` and test `classpath` from `sourceSets.`
    `integrationTest`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`integrationTest`的任务，该任务不仅将使用JUnit平台，还将使用我们的`classpath`和`sourceSets`中的测试`classpath`。`integrationTest`。
- en: 'Finally, configure the check task so that it depends on the `integrationTest`
    task and run `integrationTest` after the test task. You can remove the last line
    in the following code block if you want to run `integrationTest` separately:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，配置检查任务，使其依赖于`integrationTest`任务，并在测试任务之后运行`integrationTest`。如果你想单独运行`integrationTest`，可以删除以下代码块中的最后一行：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we can start writing the integration tests. Before writing integration
    tests, first, let’s write the supporting Java classes in the next subsection.
    First, let’s create the `TestUtils` class. This will contain a method that returns
    an instance of `ObjectMapper`. It will contain a method to check whether the JWT
    has expired.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写集成测试。在编写集成测试之前，首先，让我们在下一小节中编写支持Java类。首先，让我们创建`TestUtils`类。这个类将包含一个返回`ObjectMapper`实例的方法。它将包含一个检查JWT是否已过期的方法。
- en: Writing supporting classes for integration tests
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为集成测试编写支持类
- en: 'The `ObjectMapper` instance was retrieved from the `AppConfig` class and added
    an extra configuration so that we can accept a single value as an array. For example,
    a JSON string field value might be `{[{…}, {…}]}`. If you take a closer look at
    it, you will see that it is an array wrapped as a single value. When you convert
    this value into an object, `ObjectMapper` treats it as an array. The complete
    code for this class is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从`AppConfig`类中检索到的`ObjectMapper`实例添加了额外的配置，以便我们可以将单个值作为数组接受。例如，一个JSON字符串字段值可能是`{[{…},
    {…}]}`。如果你仔细观察，你会发现它是一个被单个值包裹的数组。当你将此值转换为对象时，`ObjectMapper`将其视为数组。此类的完整代码如下：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/TestUtils.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/TestUtils.java)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/TestUtils.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/TestUtils.java)'
- en: Next, you need a client that lets you log in so that you can retrieve the JWT.
    `RestTemplate` is an HTTP client in Spring that provides support for making HTTP
    calls. The `AuthClient` class makes use of `TestRestTemplate`, which is a replica
    of `RestTemplate` from a testing perspective.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要一个客户端，允许你登录以便检索JWT。`RestTemplate`是Spring中的一个HTTP客户端，它提供了发起HTTP调用的支持。`AuthClient`类利用`TestRestTemplate`，从测试的角度来看，它是`RestTemplate`的一个副本。
- en: 'Let’s write this `AuthClient` class, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式编写这个`AuthClient`类：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/AuthClient.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/AuthClient.java)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/AuthClient.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter08/src/integration/java/com/packt/modern/api/AuthClient.java)'
- en: The Spring test library provides `MockMvc`, `WebTestClient`, and `TestRestTemplate`
    for performing integration testing. You have already used `MockMvc` in unit testing.
    The same approach can be used for integration testing as well. However, instead
    of using mocks, you can use the actual objects by adding the `@SpringBootTest`
    annotation to the test class. `@SpringBootTest`, along with `SpringExtension`,
    provides all the necessary Spring context, such as the actual application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Spring测试库提供了`MockMvc`、`WebTestClient`和`TestRestTemplate`来执行集成测试。你已经在单元测试中使用了`MockMvc`。同样的方法也可以用于集成测试。然而，而不是使用模拟，你可以通过在测试类中添加`@SpringBootTest`注解来使用实际的对象。`@SpringBootTest`，连同`SpringExtension`一起，提供了所有必要的Spring上下文，例如实际的应用程序。
- en: '`@TestPropertySource` provides the location of the test properties file.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`@TestPropertySource`提供了测试属性文件的位置。'
- en: '`WebTestClient` is used to test the reactive applications. However, to test
    REST services, you must use `TestRestTemplate`, which is a replica of `RestTemplate`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebTestClient`用于测试响应式应用程序。然而，为了测试REST服务，你必须使用`TestRestTemplate`，它是`RestTemplate`的一个副本。'
- en: The integration test you are going to write is a fully fleshed-out test that
    doesn’t contain any mocks. It will use Flyway scripts, like the actual application,
    which we added to `src/integration/resources/db/migration`. The integration test
    will also have its own `application.properties` located in `src/integration/resources`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的集成测试是一个完整的测试，不包含任何模拟。它将使用与实际应用程序相同的Flyway脚本，我们将它们添加到了`src/integration/resources/db/migration`。集成测试还将拥有自己的`application.properties`文件，位于`src/integration/resources`。
- en: Therefore, the integration test will be as good as if you are hitting the REST
    endpoints from REST clients such as cURL or Postman. These Flyway scripts create
    the tables and data required in the H2 memory database. This data will then be
    used by the RESTful web service. You can also use other databases, such as Postgres
    or MySQL, using their test containers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，集成测试将和直接从REST客户端（如cURL或Postman）调用REST端点一样好。这些Flyway脚本在H2内存数据库中创建了所需的表和数据。然后，这些数据将被RESTful
    Web服务使用。你也可以使用其他数据库，如Postgres或MySQL，使用它们的测试容器。
- en: 'Let’s create a new integration test called `AddressControllerIT` in `src/ integration/java`
    in an appropriate package and add the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`src/integration/java`目录下的一个合适的包中创建一个新的集成测试，名为`AddressControllerIT`，并添加以下代码：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java)'
- en: Here, `SpringExtension` is now being used to run the unit test on the JUnit
    Platform. The `SpringBootTest` annotation provides all the dependencies and context
    for the test class. A random port is being used to run the test server. You are
    also using `@TestMethodOrder`, along with the `@Order` annotation, to run the
    test in a particular order. You are going to execute the test in a particular
    order so that the `POST` HTTP method on the `addresses` resource is only called
    before the `DELETE` HTTP method on the `addresses` resource. This is because you
    are passing the newly created address ID in the `DELETE` call. Normally, tests
    run in a random order. If the `DELETE` call is made before the `POST` call, then
    the build will fail, without testing the proper scenarios.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`SpringExtension`现在被用来在JUnit平台上运行单元测试。`SpringBootTest`注解为测试类提供了所有依赖项和上下文。测试服务器正在使用随机端口运行。你还在使用`@TestMethodOrder`，结合`@Order`注解，以特定的顺序运行测试。你将按照特定的顺序执行测试，以确保在`addresses`资源上的`POST`
    HTTP方法仅在`addresses`资源上的`DELETE` HTTP方法之前调用。这是因为你在`DELETE`调用中传递了新创建的地址ID。通常，测试以随机顺序运行。如果`DELETE`调用在`POST`调用之前进行，则构建将失败，而不会测试适当的场景。
- en: '`@TestInstance` sets the life cycle of the test instance to per class (`TestInstance.Lifecycle.PER_CLASS`)
    because we want to clean and migrate the database before integration test execution.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`@TestInstance`将测试实例的生命周期设置为每个类（`TestInstance.Lifecycle.PER_CLASS`），因为我们希望在集成测试执行之前清理和迁移数据库。'
- en: The static `init()` method is annotated with `@BeforeAll` and will be run before
    all the tests. You are setting up `objectMapper` and the `address` model in this
    method. You are also making use of the Flyway instance for cleaning the database
    schema and recreating the schema using the `migrate` command.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`init()`方法被注解为`@BeforeAll`，将在所有测试之前运行。在这个方法中，你设置了`objectMapper`和`address`模型。你还在这个方法中使用了Flyway实例来清理数据库模式，并使用`migrate`命令重新创建模式。
- en: The method’s setup will be run before each test is executed because it is marked
    with the `@BeforeEach` annotation. Here, you are making sure that the login call
    will only be made if `signedInUser` is null or the token has expired. The `TestInfo`
    instance helps us to assign different users – `scott2` (admin) and `scott` (non-admin)
    – for different tests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的设置将在每个测试执行之前运行，因为它被标记为`@BeforeEach`注解。在这里，你确保只有在`signedInUser`为null或令牌已过期时才会进行登录调用。`TestInfo`实例帮助我们为不同的测试分配不同的用户
    – `scott2`（管理员）和`scott`（非管理员）。
- en: 'Let’s add an integration test that will verify the `GET /api/v1/addresses`
    REST endpoint, as shown in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个集成测试，该测试将验证`GET /api/v1/addresses` REST端点，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter08/src/integration/java/com/packt/modern/api/controller/AddressControllerIT.java)'
- en: First, you must set the headers in the given section. Here, you are using the
    `signedInUser` instance to set the bearer token. Next, you must call the exchange
    method of `TestRestTemplate`, which takes four arguments – the URI, the `HTTP`
    method, `HttpEntity` (which contains the headers and payload if required), and
    the type of the returned value. You can also use optional fifth argument if the
    template is being used to set `urlVariables`, which expands the template.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须设置给定部分的标题。在这里，你使用`signedInUser`实例来设置bearer令牌。接下来，你必须调用`TestRestTemplate`的exchange方法，该方法接受四个参数
    – URI、`HTTP`方法、`HttpEntity`（如果需要，包含标题和有效负载），以及返回值的类型。你也可以使用可选的第五个参数，如果模板被用来设置`urlVariables`，这将扩展模板。
- en: Then, you must use the assertions to perform the verification process. Here,
    you can see that it replicates the actual calls.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须使用断言来执行验证过程。在这里，你可以看到它复制了实际的调用。
- en: 'Run the tests using the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行测试：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After this, you can find the test report in `Chapter08/build/ reports/tests/integrationTest`.
    The test report should look like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在`Chapter08/build/reports/tests/integrationTest`中找到测试报告。测试报告应该看起来像这样：
- en: '![Figure 8.3 – Integration test report](img/Figure_08.3_B19349.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 集成测试报告](img/Figure_08.3_B19349.jpg)'
- en: Figure 8.3 – Integration test report
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 集成测试报告
- en: You can find all the test address resources in `AddressControllerIT.java`, which
    contains tests for success, errors, authentication, and authorization. It has
    tests for all types of operations, including `create`, `read`, and `delete` operations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`AddressControllerIT.java`中找到所有的测试地址资源，它包含了成功、错误、认证和授权的测试。它对所有的操作类型都有测试，包括`创建`、`读取`和`删除`操作。
- en: You have now learned how to write integration tests. You can make use of this
    skill to write integration tests for other REST resources.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了如何编写集成测试。你可以利用这项技能为其他REST资源编写集成测试。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you explored both manual and automated testing. You learned
    how to write unit and integration tests using JUnit, the Spring test libraries,
    AssertJ, and Hamcrest. You also learned how to use the Gherkin `Given > When >
    Then` language to make tests more readable. You then learned how to separate unit
    and integration tests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你探索了手动和自动测试。你学习了如何使用JUnit、Spring测试库、AssertJ和Hamcrest编写单元和集成测试。你还学习了如何使用Gherkin的`Given
    > When > Then`语言使测试更易读。然后你学习了如何分离单元和集成测试。
- en: Finally, you learned about various test automation skills by automating unit
    and integration tests. This will help you to automate your tests and catch bugs
    and gaps before you deliver the code to quality analysts or customers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你通过自动化单元和集成测试学习了各种测试自动化技能。这将帮助你自动化测试，并在将代码交付给质量分析师或客户之前捕捉到错误和漏洞。
- en: In the next chapter, you will learn how to containerize an application and deploy
    it in Kubernetes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何将应用程序容器化并在Kubernetes中部署。
- en: Questions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between unit testing and integration testing?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试和集成测试之间的区别是什么？
- en: What is the advantage of having separate unit and integration tests?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分离单元和集成测试有什么优势？
- en: What is the difference between mocking and spying on an object?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象模拟和间谍行为之间的区别是什么？
- en: Answers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Unit testing is done to test the smallest code unit, such as a method, whereas
    integration testing is performed where either different layers or multiple modules
    are involved. In this chapter, integration testing has been performed for the
    entire application, which involves all the layers of the application, including
    the database, whereas unit testing has been performed class-wise for each of the
    methods. In the context of this chapter, unit testing is white-box testing, whereas
    API integration testing is a kind of black-box testing because you verify the
    API’s functional requirement.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试是为了测试最小的代码单元，例如一个方法，而集成测试是在涉及不同层或多个模块的地方进行的。在本章中，对整个应用程序进行了集成测试，涉及应用程序的所有层，包括数据库，而单元测试是按类对每个方法进行的。在本章的上下文中，单元测试是白盒测试，而API集成测试是一种黑盒测试，因为你要验证API的功能需求。
- en: Having separate unit and integration tests (and including their source location)
    allows you to manage tests easily. You can also have a configurable build setup
    that will perform unit testing during development or on demand because unit tests
    are faster. You can run only unit tests by using the `gradlew clean build –x integrationTest`
    command, whereas on merge request builds, you can execute the integration tests
    to verify the merge request. The default build (`gradlew clean build`) will execute
    both unit and integration tests.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单元和集成测试（包括它们的源位置）分开，可以让你轻松地管理测试。你也可以有一个可配置的构建设置，在开发期间或按需执行单元测试，因为单元测试更快。你可以使用`gradlew
    clean build –x integrationTest`命令仅运行单元测试，而在合并请求构建中，你可以执行集成测试以验证合并请求。默认的构建（`gradlew
    clean build`）将执行单元和集成测试。
- en: When you use `Mockito.mock()` or `@Mock`, it creates a complete fake object
    of the given class, and then you can stub its method based on the test requirement,
    whereas `Mockito.spy()` or `@Spy` creates the real object, on which you can stub
    the required methods. If stubbing is not done on the `spy` object, then its real
    methods will be called during the test.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你使用`Mockito.mock()`或`@Mock`时，它创建了一个给定类的完整伪造对象，然后你可以根据测试需求对该方法进行存根，而`Mockito.spy()`或`@Spy`创建了一个真实对象，你可以对其所需的方法进行存根。如果没有在`spy`对象上执行存根，那么在测试期间将调用其实际方法。
- en: Further reading
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'JUnit: [https://junit.org/](https://junit.org/)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'JUnit: [https://junit.org/](https://junit.org/)'
- en: 'AssertJ: [https://assertj.github.io/doc/](https://assertj.github.io/doc/)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AssertJ: [https://assertj.github.io/doc/](https://assertj.github.io/doc/)'
- en: 'Hamcrest: [http://hamcrest.org/](http://hamcrest.org/)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Hamcrest: [http://hamcrest.org/](http://hamcrest.org/)'
- en: 'Mockito: [https://site.mockito.org/](https://site.mockito.org/)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mockito: [https://site.mockito.org/](https://site.mockito.org/)'
- en: '*Test Automation Engineering* *Handbook*: [https://www.packtpub.com/product/test-automation-engineering-handbook/9781804615492](https://www.packtpub.com/product/test-automation-engineering-handbook/9781804615492)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试自动化工程* *手册*: [https://www.packtpub.com/product/test-automation-engineering-handbook/9781804615492](https://www.packtpub.com/product/test-automation-engineering-handbook/9781804615492)'
