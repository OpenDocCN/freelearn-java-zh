- en: Type inference
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: Type inference with local variables, or `var`, is one of the most talked about,
    star feature of Java 10\. It reduces the verbosity of the language, without compromising
    on Java's dependable static binding and type safety. The compiler infers the type
    using the information that is already available in the code and adds it to the
    bytecode it generates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用局部变量或`var`的类型推断是Java 10中最受讨论的明星特性之一。它减少了语言的冗长性，同时没有牺牲Java可靠的静态绑定和类型安全。编译器使用代码中已经可用的信息推断类型，并将其添加到它生成的字节码中。
- en: Every new concept has its own set of benefits, limitations and complexities.
    Using type inference with `var` is no exception. As you work through this chapter,
    you'll see how using `var` will enthrall you, frustrate you and yet emerge triumphant.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新概念都有自己的优点、局限性和复杂性。使用`var`进行类型推断也不例外。随着您学习本章，您将看到使用`var`将如何让您着迷、让您沮丧，但最终取得胜利。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is type inference?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类型推断？
- en: Type inference with `var`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`var`的类型推断
- en: Do's and don'ts of working with `var`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`var`一起工作的注意事项
- en: Type inference versus dynamic binding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断与动态绑定
- en: What is type inference?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是类型推断？
- en: 'Imagine solving a riddle, like the one shown in the following image with multiple
    constraints in the form of hints. You resolve the constraints to derive the answer.
    You can compare type inference with generating constraints and then resolving
    them to determine the data types in a programming language. Type inference is
    the capability of compiler to determine the type of the data, by using the information
    that is already available in the code; literal values, method invocations and
    their declaration. For a developer, type inference reduces verbosity:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下解决一个谜题，就像以下图像中所示的那样，它以提示的形式呈现多个约束。您通过解决约束来得出答案。您可以将类型推断与生成约束然后解决它们来比较，以确定编程语言中的数据类型。类型推断是编译器通过使用代码中已经可用的信息来确定数据类型的能力；字面值、方法调用及其声明。对于开发者来说，类型推断减少了冗长性：
- en: '![](img/ddbd1594-2680-4b3f-b98f-efdeb5ac4bec.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddbd1594-2680-4b3f-b98f-efdeb5ac4bec.png)'
- en: For your reference, answer to the preceding riddle is 87 (just invert the image
    and you'll find the numbers in a sequence).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的参考，前一个谜语的答案是87（只需翻转图像，你就能在序列中找到数字）。
- en: Type inference is not new to Java. It has been taken to the next level with
    introduction of `var` with local variables in Java 10.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断对Java来说并不新鲜。随着Java 10中引入局部变量`var`，它被提升到了一个新的水平。
- en: Let's deep dive using examples with `var`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`var`的示例进行深入研究。
- en: Type inference with var
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用var的类型推断
- en: 'The following lines of code show how you have been defining your local variable
    (and all other variables), prior to Java 10:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行显示了在Java 10之前您是如何定义局部变量（以及所有其他变量）的：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Starting with Java 10, using `var`, you can drop the mandatory explicit type
    in the declaration of local variables, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 10开始，使用`var`，您可以在局部变量的声明中省略强制显式类型，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Do you think that the preceding code doesn't seem to offer a lot of benefits?
    What if, instead of the following?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为前面的代码似乎没有提供很多好处吗？如果，而不是以下？
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You could use the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方法：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding example drops quite a lot of letters on the left-hand side, making
    it leaner.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例在左侧删除了很多字母，使其更加简洁。
- en: When you move away from stating the data type of the variables explicitly, the
    compiler takes over to determine or infer the variable type. Type inference is
    compiler's ability to evaluate the information already present in the code, like,
    the literal values, operations, method invocation or their declaration to determine
    the variable type. It follows a set of rules to infer the variable type. As a
    developer, when you choose type inference with `var`, you should be aware of compiler's
    inference algorithm and other rules, so that you don't get unexpected results.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不再明确声明变量的数据类型时，编译器接管以确定或推断变量类型。类型推断是编译器评估代码中已存在的信息的能力，例如，字面值、操作、方法调用或它们的声明，以确定变量类型。它遵循一系列规则来推断变量类型。作为开发者，当您选择使用`var`进行类型推断时，您应该了解编译器的推断算法和其他规则，以免得到意外结果。
- en: With every new feature, you should adhere to a few rules, restrictions and try
    to follow best practices to benefit from it. Let's start with the compulsory initialization
    of the variables that are defined using `var`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每当出现新功能时，您都应该遵守一些规则、限制，并尝试遵循最佳实践以从中受益。让我们从使用 `var` 定义的变量的强制初始化开始。
- en: Type inference with `var` is not dynamic typing; Java is still a strong static
    typed language. Usage of var makes your code leaner; you can drop the type of
    the local variable from its definition.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 的类型推断不是动态类型；Java 仍然是一种强静态类型语言。使用 `var` 可以使您的代码更简洁；您可以从局部变量的定义中省略其类型。
- en: Compulsory non-null initialization
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制非空初始化
- en: 'A local variable defined with `var` must be initialized with its declaration,
    or else the code won''t compile. The compiler can''t infer the type of an uninitialized
    variable or a variable that is assigned a null value. The following code won''t
    compile:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 定义的局部变量必须在声明时进行初始化，否则代码将无法编译。编译器无法推断未初始化变量或被赋予空值的变量的类型。以下代码将无法编译：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following image illustrates what would happen if the un-initialized variable
    `age` went to seek entrance to Mr. Java compiler place. The compiler won''t let
    it in:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像说明了如果未初始化的变量 `age` 去寻求进入 Mr. Java 编译器的位置会发生什么。编译器不会让它进入：
- en: '![](img/a6d20187-0b64-4afc-9f03-a0ffa1090cfc.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6d20187-0b64-4afc-9f03-a0ffa1090cfc.png)'
- en: Variable definition using `var` must always be accompanied with its initialization;
    or else the code will fail to compile.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 定义变量时，必须始终伴随其初始化；否则，代码将无法编译。
- en: Local variables
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部变量
- en: 'The usage of `var` is limited to the local variables. These variables are used
    to store intermediate values and have the shortest life span, when compared to
    the instance and static variables. The local variables are defined within a method,
    constructor or initializer blocks (both instance or static). Within a method or
    initializer, they can be defined within constructs such as `if`-`else` loops,
    `switch` statements or `try-with-resources` construct. Here''s an example of `Person`
    class, which defines local variables, at multiple places:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 的使用仅限于局部变量。这些变量用于存储中间值，与实例和静态变量相比，它们的生命周期最短。局部变量在方法、构造函数或初始化块（实例或静态）内定义。在方法或初始化块内，它们可以在
    `if`-`else` 循环、`switch` 语句或 `try-with-resources` 构造中定义。以下是一个 `Person` 类的示例，该类在多个地方定义了局部变量：'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since that''s a lot of places, you might find it difficult to remember them.
    We just requested Google Maps to find all its possible occurrences and this is
    what we got:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些地方很多，您可能觉得很难记住它们。我们刚刚请求 Google Maps 找到所有可能的实例，这是我们得到的结果：
- en: '![](img/be886487-7f1d-4450-9f41-848e72490309.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be886487-7f1d-4450-9f41-848e72490309.jpg)'
- en: This chapter includes a couple of code check exercises for you to quickly try
    out a new topic. The exercises use names of two hypothetical programmers Pavni
    and Aarav.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含一些代码检查练习，供您快速尝试新主题。练习使用了两位假设程序员的姓名，Pavni 和 Aarav。
- en: Code check – part 1
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查——第 1 部分
- en: 'One of our programmers, Aarav, refactored code by his team member, Pavni. The
    code no longer outputs the `char` and its corresponding ASCII numbers of the values
    stored by a `char` array. Can you help Aarav? Here''s the code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序员之一，Aarav，重构了他团队成员 Pavni 的代码。代码不再输出 `char` 及其对应的 ASCII 数字，这些数字存储在一个 `char`
    数组中。你能帮帮 Aarav 吗？以下是代码：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Answer to code check—`var` type can't be used to specify the type of exceptions
    in the catch handler `(var e)`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查的答案——`var` 类型不能用于指定捕获处理程序中的异常类型 `(var e)`。
- en: Using var with primitive data types
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `var` 与原始数据类型
- en: 'This seems to be simplest of all, but appearances can be deceptive. Try to
    execute the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是最简单的，但外表可能具有欺骗性。尝试执行以下代码：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might assume that an integer literal value (`9_009_998_992_887` in this
    case) that doesn''t fit into the range of primitive `int` type will be inferred
    to be a `long` type. However, this doesn''t happen. Since the default type of
    an integer literal value is `int`, you''ll need to append the preceding value
    with the suffix `L` or `l`, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会假设一个整数文字值（在这种情况下为 `9_009_998_992_887`）如果超出原始 `int` 类型的范围，将被推断为 `long` 类型。然而，事实并非如此。由于整数文字值的默认类型是
    `int`，您需要将前缀 `L` 或 `l` 添加到值之后，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, for an `int` literal value to be inferred as a `char` type, you
    must use an explicit cast, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了使一个 `int` 文字值被推断为 `char` 类型，您必须使用显式转换，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What is the result when you divide `5` by `2`? Did you say `2.5`? But this
    isn''t how it (always) works in Java! When integer values are used as operands
    in division, the result is not a decimal number, but an integer value. The fraction
    part is dropped to get the result as an integer. Though this is usual, this might
    seem to be weird, when you expect the compiler to infer the type of your variable.
    Here''s an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将`5`除以`2`时，结果是什么？你说`2.5`吗？但这在Java中（总是）不是这样工作的！当整数用作除法运算的操作数时，结果是整数而不是小数。小数部分被舍弃以得到整数结果。尽管这是常见的，但当你期望编译器推断变量类型时，这可能会显得有些奇怪。以下是一个例子：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Though these cases aren't specifically related to the `var` type, developer's
    assumption that the compiler will infer a specific type, results in a mismatch.
    Here's a quick image to help you remember this.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些情况与`var`类型没有直接关系，但开发者认为编译器会推断特定类型的假设，导致不匹配。以下是一个快速图像来帮助你记住这一点。
- en: '![](img/5e881452-9834-4f24-93d1-259747a883af.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e881452-9834-4f24-93d1-259747a883af.jpg)'
- en: The default type of integer literals is `int` and of floating point numbers
    is `double`. Assigning `100` to a variable defined with `var` will infer its type
    as `int`; not `byte` or `short`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面量的默认类型是`int`，浮点数的默认类型是`double`。将`100`赋值给使用`var`定义的变量将推断其类型为`int`；而不是`byte`或`short`。
- en: In an arithmetic operation, if either of the operand is `char`, `byte`, `short`
    or `int`, the result is at least promoted to an `int`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在算术运算中，如果任一操作数是`char`、`byte`、`short`或`int`，结果至少会被提升为`int`。
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, for an arithmetic operation that includes at least one operand as
    a `long`, `float`, or `double` value, the result is promoted to type `long`, `float`
    or `double` respectively:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于至少包含一个操作数为`long`、`float`或`double`值的算术运算，结果会被提升为相应的`long`、`float`或`double`类型：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Rules of implicit widening of primitive variables play an important role to
    understand how the Java compiler infers variables with primitive values.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 原始变量隐式扩展的规则在理解Java编译器如何推断具有原始值的变量时起着重要作用。
- en: Type inference with derived classes
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用派生类的类型推断
- en: With JDK 9 and previous versions, you could define a variable of base class
    and assign to it an instance of its derived class. The members that you could
    access using this variable was limited to the ones that were defined in the base
    class. This is no longer the case with `var`; since the type of the variable is
    inferred using the specific type of the instance that is assigned to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在JDK 9和之前的版本中，你可以定义一个基类变量并将其赋值为其派生类的实例。你可以使用这个变量访问的成员仅限于在基类中定义的成员。使用`var`之后就不再是这样了；因为变量的类型是通过分配给它的实例的具体类型来推断的。
- en: 'Imagine the `Child` class extends  the `Parent` class. When you create a local
    variable and assign it an instance of the `Child` class, the type of the variable
    is inferred as `Child`. This looks simple. Here''s an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Child`类扩展了`Parent`类。当你创建一个局部变量并将其赋值为`Child`类的实例时，变量的类型被推断为`Child`。这看起来很简单。以下是一个例子：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What happens, if you assign the value of the variable `obj` using a method
    that can return instance of class `Child` or `Parent`? Here''s the modified code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用一个可以返回`Child`类或`Parent`类实例的方法来赋值变量`obj`，会发生什么？以下是修改后的代码：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, the type of the instance returned by method `getObject()`
    can't be determined before the code execution. During compilation, type of variable
    `obj` is inferred as `Parent`; return type of the `getObject()` method. Since
    the `Parent` class doesn't define the `stand()`, `main()` method fails to compile.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，方法`getObject()`返回的实例类型在代码执行之前无法确定。在编译时，变量`obj`的类型被推断为`Parent`；因此`main()`方法无法编译。
- en: Type of variables defined using `var` are inferred at compile time. If the return
    type of a method is used to assign a variable defined using `var`, its inferred
    type is the return type of the method; not the type of instance returned during
    run time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`定义的变量类型是在编译时推断的。如果方法返回类型用于赋值使用`var`定义的变量，其推断类型是方法的返回类型；而不是在运行时返回的实例类型。
- en: Type inference – with interfaces
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断 – 使用接口
- en: 'Let''s extend our learning from the preceding section to usage of interfaces.
    Imagine a `Child` class implements an `MarathonRunner` interface:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面章节中学到的知识扩展到接口的使用。想象一下`Child`类实现了`MarathonRunner`接口：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s define a `obj` local variable assigning it an instance of the `Child` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个局部变量`obj`，将其赋值为`Child`类的实例：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the same variable is initialized using a method whose return type is `MarathonRunner`,
    its inferred type is `MarathonRunner` (irrespective of the type of the instance
    returned by it):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用返回类型为 `MarathonRunner` 的方法初始化相同的变量，其推断类型为 `MarathonRunner`（无论它返回的实例类型如何）：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using var with arrays
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `var` 与数组
- en: 'Using `var` doesn''t imply just dropping the type of the local variable; what
    remains should enable the compiler to infer its type. Imagine a method which defines
    an array of `char` type as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 并不意味着只是丢弃局部变量的类型；剩下的内容应该能够使编译器推断其类型。想象一下一个定义 `char` 类型数组的方法：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can''t drop its type and define it using either of the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能丢弃其类型，并使用以下任一代码来定义它：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s one of the ways to include relevant information to enable the compiler
    to infer the type:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是向编译器提供相关信息以使其能够推断类型的一种方法：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Seems like the Java compiler is already struggling with this assumption by
    the programmers, as shown in the following image:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 Java 编译器已经因为程序员的这个假设而感到有些吃力，如下面的图片所示：
- en: '![](img/474a407f-8ba4-4eb8-a9a0-edd3fcd0397f.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/474a407f-8ba4-4eb8-a9a0-edd3fcd0397f.jpg)'
- en: You can't just drop the data types to use `var`. What remains should enable
    the compiler to infer the type of the value being assigned.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能仅仅丢弃数据类型来使用 `var`。剩下的内容应该能够使编译器推断出被分配的值的类型。
- en: Type inference with generics
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型的类型推断
- en: The motivation of introducing generics was to include type safety. It enabled
    developers to specify their intention of using classes, interfaces and collection
    classes with fixed or range of types. Violations in these intentions were enforced
    with compilation errors, rather than runtime exception; raising compliance bar.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 引入泛型的动机是为了包含类型安全。它使开发者能够指定他们使用具有固定或类型范围的类、接口和集合类的意图。违反这些意图将通过编译错误强制执行，而不是运行时异常；提高合规性标准。
- en: 'For example, here''s how you would define an `ArrayList` to store `String`
    values (repeating `<String>` is optional on the right-hand side of the assignment):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是定义一个用于存储 `String` 值的 `ArrayList` 的方法（在赋值右侧重复 `<String>` 是可选的）：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, replacing `List<String>` with `var` will put type safety in generics
    at stake:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将 `List<String>` 替换为 `var` 将会使泛型中的类型安全受到威胁：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code allows addition of multiple data types to `names`, which
    is not the intention. With generics, the preferred approach is to make relevant
    information available to the compiler, so that it can infer its type correctly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许向 `names` 添加多个数据类型，这并不是意图。使用泛型时，首选的方法是向编译器提供相关信息，以便它可以正确推断其类型：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When using `var` with generics, ensure you pass relevant data types within the
    angular brackets on the right-hand side of the assignment; so that you don't lose
    type safety.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `var` 与泛型时，确保你在赋值右侧的尖括号内传递相关数据类型；这样你就不会失去类型安全。
- en: Time for our next code check.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行我们的下一个代码检查了。
- en: Code check – part 2
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码检查 – 第二部分
- en: One of our programmers, Pavni, tried using `var` with generics and collection
    classes, but her code doesn't seem to output the sorted collection of pens. Can
    you help?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序员之一，Pavni，尝试在泛型和集合类中使用 `var`，但她的代码似乎没有输出排序好的钢笔集合。你能帮忙吗？
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Answer to code check—the issue is trying to modify the immutable collection,
    using `Collections.sort()`. This is to emphasize that all issues are not related
    to the usage of `var`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查的答案——问题是尝试使用 `Collections.sort()` 修改不可变集合。这是为了强调所有问题并不都与 `var` 的使用相关。
- en: Passing inferred variables to a method
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将推断变量传递给方法
- en: Though the usage of `var` is limited to declaration of local variables, these
    variables (both primitive and reference) can be passed to methods as values. The
    inferred types and the types expected by the methods must match to let the code
    compile.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `var` 的使用仅限于局部变量的声明，但这些变量（包括原始类型和引用类型）可以作为值传递给方法。推断出的类型和方法期望的类型必须匹配，才能使代码编译。
- en: In the following example code, the `Child` class implements the `MarathonRunner`
    interface. The `start()` method in the `Marathon` class expects the `MarathonRunner`
    object (instances of class implementing this interface) as its method argument.
    Inferred type of variable, `aRunner` is `Child`. Since the `Child` class implements
    `MarathonRunner`, `aRunner` can be passed to the `start()` method, the inferred
    type of `aRunner` (`Child`) and expected type of `start()` (`MarathonRunner`)
    match, allowing the code to compile.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例代码中，`Child` 类实现了 `MarathonRunner` 接口。`Marathon` 类中的 `start()` 方法期望传入的参数是
    `MarathonRunner` 对象（实现此接口的类的实例）。变量 `aRunner` 的推断类型是 `Child`。由于 `Child` 类实现了 `MarathonRunner`，因此可以将
    `aRunner` 传递给 `start()` 方法，`aRunner` 的推断类型（`Child`）与 `start()` 方法期望的类型（`MarathonRunner`）相匹配，使得代码能够编译。
- en: 'Here''s the code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As long as the inferred type of a variable matches with the type of method parameter,
    it can be passed to it as an argument.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 只要变量的推断类型与方法参数的类型相匹配，就可以将其作为参数传递给它。
- en: Reassigning value to inferred variables
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将值重新赋给推断变量
- en: As applicable to all non-final variables, you can reassign a value to inferred
    variables. Just ensure that the reassigned value matches with the its inferred
    type. The type of a variable is inferred just once.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有非最终变量，你可以将值重新赋给推断变量。只需确保重新赋的值与其推断类型相匹配。变量的类型仅推断一次。
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The type of a local variable defined using `var` is inferred only once.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 定义的局部变量的类型仅推断一次。
- en: Explicit casting with inferred variables
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式类型转换与推断变量
- en: 'Imagine a co-programmer assigned `29` to an inferred local variable, say `age`,
    assuming the compiler would infer the type of variable `age` as `byte`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个同事将 `29` 赋值给一个推断的局部变量，比如 `age`，假设编译器会推断变量 `age` 的类型为 `byte`：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, the compiler would infer the type of the variable `age` as `int`,
    since the default type of an integer literal value is `int`.  To fix the preceding
    assumption, you can either use the explicit data type or override compiler''s
    default inference mechanism by using explicit casting, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器会推断变量 `age` 的类型为 `int`，因为整数字面量的默认类型是 `int`。要修复前面的假设，你可以使用显式数据类型，或者通过使用显式类型转换覆盖编译器的默认推断机制，如下所示：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By using explicit casting type inference, you can override the compiler's default
    type inference mechanism. This might be required to fix the assumptions in existing
    code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用显式类型推断，你可以覆盖编译器的默认类型推断机制。这可能是为了修复现有代码中的假设。
- en: 'Similarly, you can use explicit casting with other primitive data types like
    `char` and `float`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可以使用显式类型转换与其他原始数据类型，如 `char` 和 `float`：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Without the explicit casting in the preceding examples, variables that are assigned
    integer literal values would be inferred as `int` and decimal as `double`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果没有显式类型转换，赋值为整数字面量的变量会被推断为 `int` 类型，而小数会被推断为 `double` 类型。
- en: 'The following example is of explicit casting with reference variables:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用显式类型转换的引用变量示例：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Use explicit casting with type inference to fix any existing assumptions. I
    wouldn't recommend using explicit casting to initialize inferred variables; it
    beats the purpose of using `var`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型推断的显式类型转换来修复任何现有的假设。我不建议使用显式类型转换来初始化推断变量；这违背了使用 `var` 的目的。
- en: Assigning null with explicit casting
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显式类型转换赋值 null
- en: 'Again, though it doesn''t make sense to use explicit casting will null to assign
    it to a `var` type, it is a valid code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，虽然将 `null` 显式转换为 `var` 类型的值没有意义，但这是一种有效的代码：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Though the preceding line of code is correct syntax wise, it is a bad coding
    practice. Avoid it!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上一行代码在语法上是正确的，但这是一种不良的编码实践。请避免这样做！
- en: Type inference in previous versions of Java
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 早期版本中的类型推断
- en: Though `var` takes inference to a new level in Java 10, the concept of type
    inference existed in its previous versions. Let's see examples of type inference
    in the previous versions of Java.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `var` 在 Java 10 中将推断提升到了新的水平，但类型推断的概念在它的早期版本中就已经存在。让我们看看 Java 早期版本中类型推断的示例。
- en: Type inference in Java 5
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 5 中的类型推断
- en: Generics introduced a type system to enable the developers to abstract over
    types. It restricted a class, interface or method to work with instances of specified
    types, providing compile type safety. Generics were defined to add compile time
    safety to the Collection framework. Generics enables programs to detect certain
    bugs during compilation so they can't creep into the run time code. It's easier
    to fix a bug during development phase than fixing it in production.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型引入了一种类型系统，使开发者能够对类型进行抽象。它限制了类、接口或方法只能与指定类型的实例一起工作，提供了编译时的类型安全。泛型被定义为为集合框架添加编译时安全性。泛型使程序能够在编译期间检测到某些错误，从而防止它们在运行时代码中蔓延。在开发阶段修复错误比在生产阶段修复错误要容易。
- en: 'Java used type inference for generic method type arguments in Java 5\. Instead
    of the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在 Java 5 中为泛型方法类型参数使用了类型推断。而不是以下这样的代码：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You could use:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Type inference in Java 7
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 7 中的类型推断
- en: 'Java 7 introduced type inference for constructor arguments with generics. This
    essentially means that the following line of code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7 引入了泛型构造函数参数的类型推断。这实际上意味着以下这样的代码行：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'can be replaced with:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以替换为：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding shouldn''t be confused with the following, which is trying to
    mix the generics with the raw types:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容不应与以下内容混淆，后者试图将泛型与原始类型混合：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Java 7 also allowed type inference to invoke generic methods. For a generic
    method, say, `print()` defined in a class, say, `MyClass`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7 也允许对泛型方法进行类型推断。例如，在 `MyClass` 类中定义的泛型方法 `print()`：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It can be called as follows in either of the following ways (the third line
    of code uses type inference to infer type of argument passed to the method `print()`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以下两种方式之一调用（第三行代码使用类型推断来推断传递给 `print()` 方法的参数类型）：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Type inference in Java 8
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 8 中的类型推断
- en: 'Java 8 introduced functional programming in Java with lambda functions. The
    lambda expressions can infer the type of it''s formal parameters. So instead of
    the following line of code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 通过 lambda 函数引入了 Java 中的函数式编程。lambda 表达式可以推断其形式参数的类型。因此，可以不用以下这样的代码行：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can write:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Challenges
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: Usage of `var` isn't without its share of challenges, both for the developers
    of the Java language and for its users. Let's start with the reason why `var`
    has limited usage.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 的使用并非没有挑战，这既包括 Java 语言的开发者，也包括其用户。让我们从 `var` 使用受限的原因开始讨论。'
- en: Limiting the scope of failed assumptions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制失败假设的作用域
- en: As you know, the usage of `var` types is limited to the local variables in Java.
    They are not allowed in public API, as method parameters or as return type of
    methods. Some languages support type inference for all types of variables. Java
    may allow you to do so in future (who knows? Will it happen? If yes, when?).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`var` 类型的使用仅限于 Java 中的局部变量。它们不允许在公共 API 中使用，例如作为方法参数或方法的返回类型。一些语言支持对所有类型变量的类型推断。Java
    可能会在未来允许这样做（谁知道呢？会发生吗？如果会，什么时候？）。
- en: However, there are strong reasons for limiting the scope of the inferred variables,
    to spot the errors due to mismatch of assumptions and the actual, early on. The
    contracts of the public API's should be explicit. Type inference with public API
    would allow for these errors to be caught and corrected much later.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有强有力的理由限制推断变量的作用域，以便及早发现由于假设与实际情况不符而产生的错误。公共 API 的契约应该是明确的。使用公共 API 的类型推断将允许这些错误被捕获和纠正得晚一些。
- en: The contract of the public API should be explicit, they shouldn't depend on
    type inference.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 公共 API 的契约应该是明确的，它们不应该依赖于类型推断。
- en: Here's a practical example of how mismatch in the assumptions and actual can
    lead to errors.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个实际例子，说明了假设与实际情况不符可能导致错误。
- en: Recently my child was travelling overseas with her school for a student exchange
    program. The school asked me to send back a set of photographs for her visa application.
    I called up my photographer, requesting him to print photos for visa (specifying
    the country). Two days later, the school asked me to resubmit the photos because
    the earlier photos didn't match the rules.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我的孩子随学校出国参加学生交流项目。学校要求我为她签证申请发送一组照片。我打电话给我的摄影师，要求他打印签证照片（指定国家）。两天后，学校要求我重新提交照片，因为之前提交的照片不符合规则。
- en: What went wrong? Neither the school nor I were explicit with the specifications
    of the photograph. The school assumed that I would know the specifications; I
    assumed that the photographer would know the specifications (because he was doing
    it for years). In this case, at least one person assumed the result to conform
    to a specific output, without explicitly specifying the output. Without an explicit
    contract, there is always a scope of mismatch of expectation and actual.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么问题？学校和我都未明确说明照片的规格。学校认为我会知道规格；我则认为摄影师会知道规格（因为他已经做了很多年）。在这种情况下，至少有一个人假设结果符合特定的输出，而没有明确指定输出。没有明确的合同，期望和实际之间总是存在不匹配的范围。
- en: Despite the confusion, the mistake was spotted and corrected before the applications
    were submitted to the embassy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在困惑，错误在应用程序提交给大使馆之前被发现并得到了纠正。
- en: 'Here''s a fun image to reason why the usage of type inference is limited to
    local variables, when the local instance and static variables were competing in
    a race, only the local variables could make it to the finish line:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一张有趣的图片，可以解释为什么类型推断的使用仅限于局部变量，当局部实例和静态变量在比赛中竞争时，只有局部变量能够到达终点线：
- en: '![](img/47bc58b4-f8ac-4287-a2cc-9d746f7e5a9b.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47bc58b4-f8ac-4287-a2cc-9d746f7e5a9b.png)'
- en: Breaking existing code
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏现有代码
- en: 'Code that used `var` as name of a class, interface, method, method parameters
    or variables, will no longer compile with JDK 10 and later releases. Here''s an
    example of code that uses `var` at multiple places; and won''t compile:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`作为类、接口、方法、方法参数或变量名称的代码，在JDK 10及以后的版本中将无法编译。以下是一个在多个地方使用`var`的代码示例；它将无法编译：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Its important to test your production code with the latest Java release versions,
    even if you are not planning to deploy your production code to them. It will help
    iron-out any compatibility issues with your production code; helping to migrate
    it to a future Java version release.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要使用最新的Java发布版本测试你的生产代码，即使你并不打算将你的生产代码部署到它们上。这将有助于消除与你的生产代码的任何兼容性问题；有助于将其迁移到未来的Java版本发布。
- en: Non-denotable types
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可表示类型
- en: Java types that you can use in a program, like `int`, `Byte`, `Comparable` or
    `String` are called **denotable types**. The types used by a compiler internally,
    like, subclass of an anonymous class, which you can't write in your program, are
    called non-denotable types.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在程序中使用的一些Java类型，如`int`、`Byte`、`Comparable`或`String`，被称为**可表示类型**。编译器内部使用的类型，如匿名类的子类，你无法在程序中编写，被称为不可表示类型。
- en: Till now, type inference with variables seemed to be quite easy to implement,
    just get the information about the values passed to a method, returned from a
    method, and infer the type. But it isn't as simple as that, when it comes to inference
    with non-denotable types—`null` type, intersection types, anonymous class type
    and the capture types.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，变量的类型推断似乎很容易实现，只需获取传递给方法、从方法返回的值的有关信息，并推断类型。但当涉及到非可表示类型的推断——`null`类型、交叉类型、匿名类类型和捕获类型时，事情并不像那样简单。
- en: 'For example, what do you think is the type of the following inferred variables:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你认为以下推断变量的类型是什么：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding cases are not one of the types. They are neither banned from being
    inferred, nor are they normalized to a denotable type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的案例不是类型之一。它们既没有被禁止推断，也没有被规范化为可表示类型。
- en: Meaningful variable names
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有意义的变量名
- en: A new feature should be used responsibly. When you drop the explicit data type
    with a variable name, the name takes the center stage. With inferred types, it
    is your responsibility to use descriptive and appropriate variable names, so that
    they make more sense in code. As you know, a piece of code is written once, but
    read many times.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能应该负责任地使用。当你使用变量名删除显式数据类型时，名称就成为了焦点。使用推断类型时，你有责任使用描述性和适当的变量名，以便它们在代码中更有意义。正如你所知，一段代码只写一次，但会被阅读很多次。
- en: 'For example, the following line of code won''t make much sense to you after
    some time, or to your team members (especially with a big or distributed team):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码行在一段时间后对你或你的团队成员（尤其是大型或分布式团队）可能不会很有意义：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Key questions are - what is the variable `i` used for, what does the method
    `getData()` return? Imagine the plight of the maintenance team that will work
    with this code, after you leave.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 关键问题是——变量`i`是用来做什么的，方法`getData()`返回什么？想象一下在你离开后，将与这段代码一起工作的维护团队的困境。
- en: 'Also, it doesn''t help to define variables names that are mismatched with their
    purpose. For example, it doesn''t make much sense to create a connection object
    named `database` and assign a `URL` instance to it, or, say, to define a variable
    with the name `query` and assign a `Connection` instance to it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，定义与目的不匹配的变量名称也无济于事。例如，创建一个名为`database`的连接对象并将一个`URL`实例分配给它，或者定义一个名为`query`的变量并将一个`Connection`实例分配给它，都没有太多意义：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When you drop the explicit type of a local variable, its name takes the center
    stage. Choose their name carefully and responsibly, which makes their purpose
    unambiguous.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你省略局部变量的显式类型时，其名称就占据了中心舞台。仔细且负责任地选择它们的名称，这使它们的目的明确无误。
- en: Code refactoring
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码重构
- en: Type inference with `var` has been introduced to reduce the verbosity of the
    Java language. It will help the programmers to type less in their methods. The
    compiler infers the type of the variables declared using `var` and inserts it
    in the byte code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`的类型推断被引入以减少Java语言的冗长性。它将帮助程序员在方法中输入更少的代码。编译器推断使用`var`声明的变量的类型并将其插入到字节码中。
- en: I see no reason of refactoring existing or legacy code to replace explicit data
    types in the methods, replacing them with `var`. It won't offer any benefits in
    any dimension.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为没有理由重构现有或遗留代码，用`var`替换方法中的显式数据类型。这不会在任何方面带来任何好处。
- en: Don't refactor your existing or legacy code, replacing existing explicit types
    in methods with `var`. It doesn't offer any benefits.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重构你的现有或遗留代码，用`var`替换方法中的现有显式类型。这不会带来任何好处。
- en: Type inference versus dynamic binding
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断与动态绑定
- en: Type inference with `var` isn't pushing Java towards the dynamic binding domain.
    Java is still a strongly typed static language. Type inference in Java is syntactic
    sugar. The compiler infers the type and adds it to the byte code. In dynamic binding,
    a variable type is inferred at run time. This can lead to more errors being discovered,
    later.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`的类型推断并没有推动Java走向动态绑定的领域。Java仍然是一种强类型静态语言。Java中的类型推断是语法糖。编译器推断类型并将其添加到字节码中。在动态绑定中，变量类型在运行时推断。这可能导致更晚发现更多错误。
- en: Debugging an application is a costly affair, in terms of the time and efforts
    required to find a bug and then fix it. The sooner you can detect a bug, the easier
    it is to fix it. It is easier to fix a bug during unit testing than it is to fix
    the same bug during integration testing, or say, when it shows up months later
    after an application goes live. A bug is easier to fix in the development phase
    than it is to fix in the production of maintenance stage.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 调试应用程序是一笔昂贵的交易，在寻找错误并修复它所需的时间和精力方面。你越早发现错误，修复它就越容易。在单元测试期间修复错误比在集成测试期间修复相同的错误，或者说是当应用程序上线几个月后出现错误时，要容易得多。在开发阶段修复错误比在生产或维护阶段修复错误要容易。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you covered local variable inference, or `var`, introduced
    in Java 10\. The `var` type enables you to drop the explicit data type for a local
    variable in a method. You covered the various do's and don'ts for the usage of
    `var`. Limited to local variables, variables defined using `var` must be initialized
    with a non-null value. They can be used with all type of variables—primitives
    and objects. Variables defined with `var` can also be passed to methods and returned
    from methods, method declaration compatibility rules apply.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你介绍了Java 10中引入的局部变量推断，或称`var`。`var`类型使你能够在方法中省略局部变量的显式数据类型。你介绍了`var`使用的各种注意事项。限于局部变量，使用`var`定义的变量必须用非空值初始化。它们可以与所有类型的变量一起使用——原始类型和对象。使用`var`定义的变量也可以传递给方法并从方法返回，方法声明兼容性规则适用。
- en: To avoid risking your type safety with generics, ensure you pass relevant information,
    while using `var` with generics. Though it doesn't make a lot of sense, using
    explicit casting is allowed with variables defined using `var`. You also covered
    type inference existed in previous versions of Java, namely, 5, 7, and 8\. Towards
    the end, you also covered why type inference is limited to the local variables
    and not allowed in the public API.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在使用泛型时冒着类型安全的风险，确保你传递相关信息，同时使用`var`与泛型一起。尽管这没有太多意义，但使用`var`定义的变量允许显式类型转换。你同样也介绍了Java之前版本中存在的类型推断，即Java
    5、7和8版本。在最后，你还解释了为什么类型推断仅限于局部变量，而不允许在公共API中使用。
- en: Usage of meaning variable names has always been recommended and it is important.
    With `var`, it becomes more important. Since `var` offers syntactic sugar, it
    doesn't make any sense to refactor your existing or legacy code to use `var` in
    it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有意义的变量名一直被推荐，并且这一点非常重要。使用`var`之后，这一点变得更加重要。由于`var`提供了语法糖，因此没有必要重构现有的或遗留代码以在其中使用`var`。
