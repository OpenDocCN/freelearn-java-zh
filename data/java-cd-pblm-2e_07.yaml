- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Foreign (Function) Memory API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部（函数）内存API
- en: This chapter includes 28 problems covering the Foreign Memory API and Foreign
    Linker API. We’ll start with the classical approaches for calling foreign functions
    relying on the JNI API and the open-source JNA/JNR libraries. Next, we’ll introduce
    the new approach delivered under the code name Project Panama (third review in
    JDK 21 and final release in JDK 22 as JEP 454). We’ll dissect the most relevant
    APIs, such as `Arena`, `MemorySegment`, `MemoryLayout`, and so on. Finally, we’ll
    focus on the Foreign Linker API and the Jextract tool for calling foreign functions
    with different types of signatures, including callback functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括涵盖外部内存API和外部链接器API的28个问题。我们将从依赖于JNI API和开源JNA/JNR库调用外国函数的经典方法开始。接下来，我们将介绍名为Project
    Panama的新方法（在JDK 21中的第三次审查和JDK 22中的最终发布作为JEP 454）。我们将分析最相关的API，如`Arena`、`MemorySegment`、`MemoryLayout`等。最后，我们将关注外部链接器API和Jextract工具，用于调用具有不同类型签名的国外函数，包括回调函数。
- en: By the end of this chapter, you’ll be skilled in putting JNI, JNA, JNR, and,
    of course, Project Panama to work and you’ll be able to confidently answer any
    interview questions with this topic on the menu.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够熟练地使用JNI、JNA、JNR，当然还有Project Panama，并且能够自信地回答任何与这个主题相关的问题。
- en: Problems
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your programming prowess in manipulating
    off-heap memory and calling native foreign functions from Java. I strongly encourage
    you to give each problem a try before you turn to the solutions and download the
    example programs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在操作堆外内存和从Java调用原生外国函数方面的编程能力。我强烈建议你在查看解决方案并下载示例程序之前，尝试解决每个问题：
- en: '**Introducing Java Native Interface (JNI)**: Write a Java application that
    calls a C/C++ native foreign function via the JNI API (for instance, implement
    in C a function with the following signature: `long sumTwoInt(int x, int y)`).'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍Java Native Interface (JNI)**：编写一个Java应用程序，通过JNI API调用C/C++原生外国函数（例如，在C中实现以下签名的函数：`long
    sumTwoInt(int x, int y)`）。'
- en: '**Introducing Java Native Access (JNA)**: Write a Java application that calls
    a C/C++ native foreign function via the JNA API.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍Java Native Access (JNA)**：编写一个Java应用程序，通过JNA API调用C/C++原生外国函数。'
- en: '**Introducing Java Native Runtime (JNR)**: Write a Java application that calls
    a C/C++ native foreign function via the JNR API.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍Java Native Runtime (JNR)**：编写一个Java应用程序，通过JNR API调用C/C++原生外国函数。'
- en: '**Motivating and introducing Project Panama**: Provide a theoretical and meaningful
    transition from classical approaches of manipulating off-heap memory and foreign
    functions to the new Project Panama.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**激励并介绍Project Panama**：从操作堆外内存和外国函数的经典方法到新的Project Panama提供一个理论上有意义的过渡。'
- en: '**Introducing Panama’s architecture and terminology**: Provide a brief description
    of Project Panama, including architecture, terminology, and the main API components.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍Panama的架构和术语**：简要描述Project Panama，包括架构、术语和主要API组件。'
- en: '**Introducing Arena and MemorySegment**: Explain and exemplify via snippets
    of code the `Arena` and `MemorySegment` APIs.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍Arena和MemorySegment**：通过代码片段解释并举例说明`Arena`和`MemorySegment` API。'
- en: '**Allocating arrays into memory segments**: Write several approaches for allocating
    arrays into memory segments (via `Arena` and `MemorySegment`).'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将数组分配到内存段中**：编写几种将数组分配到内存段中的方法（通过`Arena`和`MemorySegment`）。'
- en: '**Understanding addresses (pointers)**: Exemplify the usage of memory addresses
    (pointers) in Java (`ValueLayout.ADDRESS`).'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**理解地址（指针）**：举例说明在Java中使用内存地址（指针）（`ValueLayout.ADDRESS`）的用法。'
- en: '**Introducing the sequence layout**: Explain and exemplify the usage of the
    sequence layout. Moreover, introduce the `PathElement` and `VarHandle` APIs.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍序列布局**：解释并举例说明序列布局的用法。此外，介绍`PathElement`和`VarHandle` API。'
- en: '**Shaping C-like structs into memory segments**: Exemplify the approach of
    shaping C-like structs via Java memory layouts (`StructLayout`).'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将C-like结构体塑造成内存段**：举例说明通过Java内存布局（`StructLayout`）塑造C-like结构体的方法。'
- en: '**Shaping C-like unions into memory segments**: Exemplify the approach of shaping
    C-like unions via Java memory layouts (`UnionLayout`).'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将C-like联合体塑造成内存段**：举例说明通过Java内存布局（`UnionLayout`）塑造C-like联合体的方法。'
- en: '**Introducing PaddingLayout**: Provide a detailed explanation and meaningful
    examples for explaining padding layout (introduce *size*, *alignment*, *stride*,
    *padding*, and *order* of bytes).'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 PaddingLayout**：详细解释并给出有意义的示例，解释填充布局（介绍 *size*、*alignment*、*stride*、*padding*
    和 *order* 的字节）。'
- en: '**Copying and slicing memory segments**: Exemplify different approaches for
    copying and slicing parts of a memory segment, including `asOverlappingSlice()`
    and `segmentOffset()`.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**复制和切片内存段**：举例说明复制和切片内存段部分的不同方法，包括 `asOverlappingSlice()` 和 `segmentOffset()`。'
- en: '**Tackling the slicing allocator**: Exemplify the usage of the slicing allocator
    (`SegmentAllocator`).'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理切片分配器**：举例说明切片分配器 (`SegmentAllocator`) 的使用。'
- en: '**Introducing the slice handle**: Explain and exemplify the usage of `sliceHandle()`.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍切片句柄**：解释并举例说明 `sliceHandle()` 的使用。'
- en: '**Introducing layout flattening**: Consider a hierarchical memory layout (for
    instance, two nested sequence layouts). Explain and exemplify how to flatten this
    model.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍布局扁平化**：考虑一个分层内存布局（例如，两个嵌套序列布局）。解释并举例说明如何扁平化此模型。'
- en: '**Introducing layout reshaping**: Provide an example that reshapes a hierarchical
    sequence layout.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍布局重塑**：提供一个示例，展示如何重塑分层序列布局。'
- en: '**Introducing the layout spreader**: Provide a brief explanation and a simple
    example of using the layout spreader (`asSpreader()`).'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍布局展开器**：简要解释并给出使用布局展开器 (`asSpreader()`) 的简单示例。'
- en: '**Introducing the memory segment view VarHandle**: Exemplify the usage of `MethodHandles.memorySegmentViewVarHandle(ValueLayout
    layout)` for creating a `VarHandle` that can be used to access a memory segment.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍内存段视图 VarHandle**：举例说明如何使用 `MethodHandles.memorySegmentViewVarHandle(ValueLayout
    layout)` 创建一个可以用于访问内存段的 `VarHandle`。'
- en: '**Streaming memory segments**: Write several snippets of code for combining
    memory segments with the Java Stream API.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**流式处理内存段**：编写几个代码片段，展示如何将内存段与 Java Stream API 结合使用。'
- en: '**Tackling mapped memory segments**: Provide a brief introduction of mapped
    memory segments and exemplify them in Java code.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理映射内存段**：简要介绍映射内存段，并在 Java 代码中举例说明。'
- en: '**Introducing the Foreign Linker API**: Provide a brief description of the
    Foreign Linker API, including `Linker`, `SymbolLookup`, *downcall*, and *upcall*.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Foreign Linker API**：简要描述 Foreign Linker API，包括 `Linker`、`SymbolLookup`、*downcall*
    和 *upcall*。'
- en: '**Calling the sumTwoInt() foreign function**: Write a Java application that
    calls the `sumTwoInt()` method (the `long sumTwoInt(int x, int y)` implemented
    in *Problem 144*) via the Foreign Linker API.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调用 sumTwoInt() 外部函数**：编写一个 Java 应用程序，通过 Foreign Linker API 调用 `sumTwoInt()`
    方法（在 *问题 144* 中实现的 `long sumTwoInt(int x, int y)`）。'
- en: '**Calling the modf() foreign function**: Use the Foreign Linker API to call
    the `modf()` foreign function – this function is part of the C standard library.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调用 modf() 外部函数**：使用 Foreign Linker API 调用 `modf()` 外部函数——此函数是 C 标准库的一部分。'
- en: '**Calling the strcat() foreign function**: Use the Foreign Linker API to call
    the `strcat()` foreign function – this function is part of the C standard library.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调用 strcat() 外部函数**：使用 Foreign Linker API 调用 `strcat()` 外部函数——此函数是 C 标准库的一部分。'
- en: '**Calling the bsearch() foreign function**: Use the Foreign Linker API to call
    the `bsearch()` foreign function – this function is part of the C standard library.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调用 bsearch() 外部函数**：使用 Foreign Linker API 调用 `bsearch()` 外部函数——此函数是 C 标准库的一部分。'
- en: '**Introducing Jextract**: Provide a brief description of the Jextract tool,
    including the main options.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 Jextract**：简要描述 Jextract 工具，包括主要选项。'
- en: '**Generating native binding for modf()**: Exemplify the combination of Jextract
    and the Foreign Linker API to call the `modf()` foreign function.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为 modf() 生成原生绑定**：举例说明如何结合 Jextract 和 Foreign Linker API 来调用 `modf()` 外部函数。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter07).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节描述了解决上述问题的方法。请记住，通常没有一种正确的方法来解决特定的问题。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节并实验程序，请访问
    [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter07)。
- en: 144\. Introducing Java Native Interface (JNI)
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 144. 介绍 Java 本地接口 (JNI)
- en: '**Java Native Interface** (**JNI**) was the first Java API meant to act as
    a bridge between JVM bytecode and native code written in another programming language
    (typically C/C++).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 本地接口**（**JNI**）是第一个旨在作为 JVM 字节码和用另一种编程语言（通常是 C/C++）编写的本地代码之间的桥梁的 Java
    API。'
- en: Let’s suppose that we plan to call via JNI a C function on a Windows 10, 64-bit
    machine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们计划在 Windows 10，64 位机器上通过 JNI 调用一个 C 函数。
- en: 'For instance, let’s consider that we have a C function for summing two integers
    called `sumTwoInt(int x, int y)`. This function is defined in a C shared library
    named `math.dll`. Calling such functions from Java (generally speaking, functions
    implemented by native shared libraries) starts with loading the proper shared
    native library via `System.loadLibrary(String library)`. Next, we declare the
    C function in Java via the `native` keyword. Finally, we call it with the following
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑我们有一个名为 `sumTwoInt(int x, int y)` 的 C 函数，用于计算两个整数的和。这个函数定义在一个名为 `math.dll`
    的 C 共享库中。从 Java（一般来说，由本地共享库实现的函数）调用此类函数，首先需要通过 `System.loadLibrary(String library)`
    加载适当的共享本地库。接下来，我们通过 `native` 关键字在 Java 中声明 C 函数。最后，我们用以下代码调用它：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, we focus on C implementation. We need the header file (the `.h` file)
    and the source file that implements this method (the `.cpp` file).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们关注 C 实现。我们需要头文件（`.h` 文件）和实现此方法的源文件（`.cpp` 文件）。
- en: Generating the header (.h) file
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成头文件 (.h)
- en: 'The header file (definition of the method) can be obtained by running `javac`
    with the `–h` option against our `Main.java` source, as in the following figure
    (before JDK 9, use `javah`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `Main.java` 源文件上运行 `javac` 命令并使用 `–h` 选项（在 JDK 9 之前使用 `javah`），我们可以获得头文件（方法的定义）：
- en: '![Figure 7.1.png](img/B19665_07_01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1.png](img/B19665_07_01.png)'
- en: 'Figure 7.1: Running javac –h to compile source code and generate the .h file'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：运行 javac –h 编译源代码并生成 .h 文件
- en: 'Or, as plain text:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为纯文本：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command compiles our code (`Main.java`) and places the resulting class
    in the `target/classes` folder. In addition, this command generates the C header
    `modern_challenge_Main.h` in `jni/cpp`. The important code of this file is listed
    here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令编译我们的代码（`Main.java`），并将生成的类放置在 `target/classes` 文件夹中。此外，此命令在 `jni/cpp` 中生成
    C 头文件 `modern_challenge_Main.h`。此文件的重要代码如下：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The function name was generated as `Java_modern_challenge_Main_sumTwoInt`.
    Moreover, we have here the following artifacts:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名称被生成为 `Java_modern_challenge_Main_sumTwoInt`。此外，我们还有以下工件：
- en: '`JNIEXPORT` – the function is marked as exportable'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JNIEXPORT` – 函数被标记为可导出'
- en: '`JNICALL` – sustains `JNIEXPORT` to guarantee that the function can be found
    by JNI'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JNICALL` – 维持 `JNIEXPORT` 以确保函数可以通过 JNI 被找到'
- en: '`JNIEnv` – represents a pointer to the JNI environment for accessing JNI functions'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JNIEnv` – 表示指向 JNI 环境的指针，用于访问 JNI 函数'
- en: '`jobject` – represents a reference to this Java object'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobject` – 表示对 Java 对象的引用'
- en: Implementing the modern_challenge_Main.cpp
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 modern_challenge_Main.cpp
- en: 'Next, we provide the C implementation in `src/main/java/modern/challenge/cpp`
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `src/main/java/modern/challenge/cpp` 中提供 C 实现如下：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compiling the C source code
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译 C 源代码
- en: So far, we have the C source code (the `.cpp` file) and the generated header
    (`.h`). Next, we have to compile the C source code, and for this, we need a C
    compiler. There are many options, like Cygwin, MinGW, and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有 C 源代码（`.cpp` 文件）和生成的头文件（`.h` 文件）。接下来，我们必须编译 C 源代码，为此我们需要一个 C 编译器。有许多选项，如
    Cygwin、MinGW 等。
- en: We decided to install MinGW ([https://sourceforge.net/projects/mingw-w64/](https://sourceforge.net/projects/mingw-w64/))
    for 64-bit platforms and use the G++ compiler.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定为64位平台安装MinGW ([https://sourceforge.net/projects/mingw-w64/](https://sourceforge.net/projects/mingw-w64/))
    并使用G++编译器。
- en: 'Having G++ in our hands, we have to trigger a specific command for compiling
    the C code, as in the following figure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手头有G++，必须触发一个特定的命令来编译C代码，如下面的图所示：
- en: '![Figure 7.2.png](img/B19665_07_02.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2.png](img/B19665_07_02.png)'
- en: 'Figure 7.2: Compiling the C source code'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：编译C源代码
- en: 'Or, as plain text:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以纯文本形式：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we have to pack everything in `math.dll`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将所有内容打包到`math.dll`中。
- en: Generating the native shared library
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成本地共享库
- en: 'It is time to create the native shared library, `math.dll`. For this, we use
    G++ again, as in the following figure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建本地共享库了，`math.dll`。为此，我们再次使用G++，如下面的图所示：
- en: '![Figure 7.3.png](img/B19665_07_03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3.png](img/B19665_07_03.png)'
- en: 'Figure 7.3: Creating the math.dll'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：创建math.dll
- en: 'Or, as plain text:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以纯文本形式：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that we have used the `–static` option. This option instructs G++ to
    add in `math.dll` all dependencies. If you dislike this approach, then you may
    need to manually add the dependencies in order to avoid `java.lang.UnsatisfiedLinkError`
    errors. To find out the missing dependencies, you can use a DLL dependency walker
    such as this one: [https://github.com/lucasg/Dependencies](https://github.com/lucasg/Dependencies).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`–static`选项。此选项指示G++将所有依赖项添加到`math.dll`中。如果你不喜欢这种方法，那么你可能需要手动添加依赖项，以避免`java.lang.UnsatisfiedLinkError`错误。要找出缺失的依赖项，你可以使用DLL依赖项遍历工具，例如这个：[https://github.com/lucasg/Dependencies](https://github.com/lucasg/Dependencies)。
- en: Finally, run the code
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后，运行代码
- en: 'Finally, we can run the code. Keep your fingers crossed and execute the command
    in the following figure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以运行代码。请交叉手指，并按照以下图中的命令执行：
- en: '![Figure 7.4.png](img/B19665_07_04.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4.png](img/B19665_07_04.png)'
- en: 'Figure 7.4: Executing the Java code'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：执行Java代码
- en: 'Or, as plain text:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以纯文本形式：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that we should set the library path; otherwise, Java will not be able
    to load `math.dll`. If everything worked fine, then you should see the output
    from this figure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们应该设置库路径；否则，Java将无法加载`math.dll`。如果一切顺利，那么你应该看到这个图中的输出。
- en: Well, as you can easily conclude, JNI is not easy to use. Imagine doing all
    this work for an entire C library like TensorFlow, which has 200+ functions. Besides
    being hard to use, JNI also faces a lot of shortcomings, for example, it is error-prone,
    hard to maintain, and brittle, it has poor exception support, JNI errors can crash
    the JVM, it has a maximum off-heap of 2 GB allocated via `ByteBuffer` that cannot
    be directly free (we have to wait for the garbage collector to do it), and many
    more. Despite all this, it is still worth learning this technique because, as
    you’ll surely know, management is often not quick to adopt new ways of doing things.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，正如你可以轻易得出的结论，JNI并不容易使用。想象一下，为像TensorFlow这样的整个C库（有200多个函数）做所有这些工作。JNI不仅难以使用，而且存在许多缺点，例如，它容易出错、难以维护、脆弱，它对异常的支持较差，JNI错误可能导致JVM崩溃，它通过`ByteBuffer`分配了最大2GB的堆外内存，这些内存不能直接释放（我们必须等待垃圾收集器来处理），还有更多。尽管如此，学习这项技术仍然值得，因为正如你肯定知道的，管理通常不会迅速采用新的做事方式。
- en: With this in mind, the community came up with other approaches that we will
    discuss in the next problems.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，社区提出了其他方法，我们将在下一个问题中进行讨论。
- en: 145\. Introducing Java Native Access (JNA)
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 145. 介绍Java本地访问（JNA）
- en: '**Java Native Access** (**JNA**) is a brave open-source attempt to address
    JNI complexity via a more intuitive and easy-to-use API. Being a third-party library,
    JNA must be added as a dependency in our project:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java本地访问**（**JNA**）是一个勇敢的开源尝试，通过更直观且易于使用的API来解决JNI的复杂性。作为一个第三方库，JNA必须作为依赖项添加到我们的项目中：'
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, let’s try to call the same `sumTwoInt()` method from *Problem 144*. This
    function is defined in a C native shared library named `math.dll` and stored in
    our project in the `jna/cpp` folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试从*问题144*中调用相同的`sumTwoInt()`方法。这个函数定义在名为`math.dll`的C本地共享库中，并存储在我们的项目中的`jna/cpp`文件夹中。
- en: 'We start by writing a Java interface that extends JNA’s `Library` interface.
    This interface contains declarations of methods and types that we plan to call
    from Java and are defined in native code. We write the `SimpleMath` interface
    containing the `sumTwoInt()` declaration as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个扩展JNA的`Library`接口的Java接口。该接口包含从Java调用并在本地代码中定义的方法和类型的声明。我们编写包含`sumTwoInt()`声明的`SimpleMath`接口如下：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we have to instruct JNA to load the `math.dll` library and generate a
    concrete implementation of this interface so we can call its methods. For this,
    we need the `jna.library.path` system property and JNA’s `Native` class, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须指导JNA加载`math.dll`库并生成该接口的具体实现，这样我们就可以调用其方法。为此，我们需要`jna.library.path`系统属性和JNA的`Native`类，如下所示：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we instruct JNA to load `math.dll` from `jna/cpp` via `System.setProperty()`,
    but you can also do it from a terminal via `–Djna.library.path=jna/cpp`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指导JNA从`jna/cpp`通过`System.setProperty()`加载`math.dll`，但您也可以通过终端使用`–Djna.library.path=jna/cpp`来完成此操作。
- en: Next, we call `Native.load()`, which takes two arguments. First, it takes the
    native library name, which in our case is `math` (without the `.dll` extension).
    Second, it takes the Java interface containing the declaration of the methods,
    which in our case is `SimpleMath.class`. The `load()` method returns a concrete
    implementation of `SimpleMath` that we use to call the `sumTwoInt()` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`Native.load()`，它接受两个参数。首先，它接受本地库名称，在我们的例子中是`math`（不带`.dll`扩展名）。其次，它接受包含方法声明的Java接口，在我们的例子中是`SimpleMath.class`。`load()`方法返回一个具体的`SimpleMath`实现，我们用它来调用`sumTwoInt()`方法。
- en: The JNA `Platform` helper allows us to provide the name of the native library
    specific to the current operating system. We have only `math.dll` for Windows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JNA的`Platform`辅助类允许我们提供针对当前操作系统的特定本地库的名称。我们只有Windows上的`math.dll`。
- en: Implementing the .cpp and .h files
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现.cpp和.h文件
- en: 'This time, there is no naming convention from the `.cpp` and `.h` files, so
    let’s name them `Arithmetic.cpp` and `Arithmetic.h` (the header file is optional).
    The source code of `Artihmetic.cpp` is basically plain C code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`.cpp`和`.h`文件没有命名约定，所以让我们将它们命名为`Arithmetic.cpp`和`Arithmetic.h`（头文件是可选的）。`Arithmetic.cpp`的源代码基本上是纯C代码：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, with JNA, there is no need to patch our code with the JNI-specific
    bridge code. It is only plain C code. The `Arithmetic.h` is optional and we can
    write it as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用JNA，我们不需要用JNI特定的桥接代码修补我们的代码。它只是纯C代码。《Arithmetic.h》是可选的，我们可以这样编写它：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we can compile our code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以编译我们的代码。
- en: Compiling the C source code
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译C源代码
- en: 'Compiling the C source code is done via the G++ compiler with the command from
    the following figure:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 编译C源代码是通过以下图中的G++编译器完成的：
- en: '![Figure 7.5.png](img/B19665_07_05.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.5.png](img/B19665_07_05.png)'
- en: 'Figure 7.5: Compiling the C++ code'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：编译C++代码
- en: 'Or, as plain text:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为纯文本：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we can generate the proper native library.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以生成适当的本地库。
- en: Generating the native shared library
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成本地共享库
- en: 'It is time to create the native shared library, `math.dll`. For this, we use
    G++ again as in the following figure:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建本地共享库`math.dll`了。为此，我们再次使用G++，如图所示：
- en: '![Figure 7.6.png](img/B19665_07_06.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.6.png](img/B19665_07_06.png)'
- en: 'Figure 7.6: Generating math.dll'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：生成math.dll
- en: 'Or, as plain text:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为纯文本：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, you should have `math.dll` in the `jna/cpp` folder.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经在`jna/cpp`文件夹中有`math.dll`。
- en: Finally, run the code
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后，运行代码
- en: 'Finally, we can run the code. If everything worked fine, then you’re done.
    Otherwise, if you get an exception such as `java.lang.UnsatisfiedLinkError:` *Error
    looking up function ''sumTwoInt'': The specified procedure could not be found*,
    then you have to fix it.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以运行代码。如果一切顺利，那么你就完成了。否则，如果你收到一个异常，比如`java.lang.UnsatisfiedLinkError:`
    *查找函数'sumTwoInt'时出错：指定的过程找不到*，那么你必须修复它。
- en: But what happened? Most probably, the G++ compiler has applied a technique referred
    to as *name mangling* (or, *name decoration*) – [https://en.wikipedia.org/wiki/Name_mangling](https://en.wikipedia.org/wiki/Name_mangling).
    In other words, the G++ compiler has renamed the `sumTwoInt()` method to something
    else that is not known to JNA.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但发生了什么？很可能是G++编译器应用了一种称为*名称混淆*（或，*名称装饰*）的技术——[https://en.wikipedia.org/wiki/Name_mangling](https://en.wikipedia.org/wiki/Name_mangling)。换句话说，G++编译器已经将`sumTwoInt()`方法重命名为JNA所不知道的另一个名称。
- en: 'Solving this issue can be done in two steps. First, we need to inspect `math.dll`
    with a DLL dependency walker such as this one, [https://github.com/lucasg/Dependencies](https://github.com/lucasg/Dependencies).
    As you can see in the following figure, G++ has renamed `sumTwoInt` to `_Z9sumTwoIntii`
    (of course, on your computer, it could be another name):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题可以分为两个步骤。首先，我们需要使用像这样的DLL依赖关系查看器来检查`math.dll`，例如这个：[https://github.com/lucasg/Dependencies](https://github.com/lucasg/Dependencies)。如图所示，G++已经将`sumTwoInt`重命名为`_Z9sumTwoIntii`（当然，在您的计算机上，它可能还有另一个名称）：
- en: '![Figure 7.7.png](img/B19665_07_07.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.7.png](img/B19665_07_07.png)'
- en: 'Figure 7.7: G++ has renamed sumToInt to _Z9sumTwoIntii'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：G++已将sumToInt重命名为_Z9sumTwoIntii
- en: 'Second, we have to tell JNA about this name (`_Z9sumTwoIntii`). Basically,
    we need to define a `Map` containing the corresponding mapping of names and pass
    this map to a flavor of `Native.load()` that takes this map as the last argument.
    The code is straightforward:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们必须告诉JNA这个名称（`_Z9sumTwoIntii`）。基本上，我们需要定义一个包含名称对应映射的`Map`，并将这个映射传递给一个接受此映射作为最后一个参数的`Native.load()`方法的变体。代码很简单：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Done! Now, you should obtain the result of 3+9\. Feel free to explore JNA further,
    and attempt to use C/C++ structures, unions, and pointers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，你应该得到3+9的结果。请随意进一步探索JNA，并尝试使用C/C++结构、联合和指针。
- en: 146\. Introducing Java Native Runtime (JNR)
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 146. 介绍Java Native Runtime (JNR)
- en: '**Java Native Runtime** (**JNR**) is another open-source attempt to address
    JNI’s complexity. It is a serious competitor for JNA, having a more intuitive
    and powerful API than JNI.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java Native Runtime**（**JNR**）是另一个开源尝试解决JNI复杂性的方法。它是对JNA的严肃竞争，拥有比JNI更直观和强大的API。'
- en: 'We can add it as a dependency as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其作为依赖项添加，如下所示：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s assume that we have the exact same C method (`sumTwoInt()`) and the native
    shared library (`math.dll`) from *Problem 145*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们拥有与*问题145*中完全相同的C方法（`sumTwoInt()`）和本地共享库（`math.dll`）。
- en: 'We start by writing a Java interface containing the declarations of methods
    and types that we plan to call from Java and are defined in native code. We write
    the `SimpleMath` interface containing the `sumTwoInt()` declaration as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个Java接口，其中包含我们计划从Java调用并在本地代码中定义的方法和类型的声明。我们编写包含`sumTwoInt()`声明的`SimpleMath`接口如下：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `@IgnoreError` annotation instructs JNR to not save the *errno value* ([https://www.geeksforgeeks.org/errno-constant-in-c/](https://www.geeksforgeeks.org/errno-constant-in-c/)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`@IgnoreError`注解指示JNR不要保存*errno值*（[https://www.geeksforgeeks.org/errno-constant-in-c/](https://www.geeksforgeeks.org/errno-constant-in-c/)）。'
- en: 'Next, we have to instruct JNR to load the `math.dll` library and generate a
    concrete implementation of this interface so we can call its methods. For this,
    we need the `LibraryLoader` and the following intuitive code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须指示JNR加载`math.dll`库并生成此接口的实体实现，这样我们就可以调用其方法。为此，我们需要`LibraryLoader`和以下直观的代码：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Via the `LibraryLoader` API, we prepare the playground. We instruct JNR that
    our library is located in `jnr/cpp` via the `search()` method. Moreover, we provide
    the proper mapping of the method’s names via the `map()` method (remember from
    *Problem 145* that G++ renames the method via *name mangling* (or, *name decoration*)
    from `sumTwoInt` to `_Z9sumTwoIntii`).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`LibraryLoader` API，我们准备游乐场。我们通过`search()`方法指示JNR我们的库位于`jnr/cpp`。此外，我们通过`map()`方法提供方法名称的正确映射（记得从*问题145*中，G++通过*名称修饰*（或，*名称装饰*）将方法从`sumTwoInt`重命名为`_Z9sumTwoIntii`）。
- en: Finally, we load the library via the `load()` method and call the `sumTwoInt()`
    method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过`load()`方法加载库，并调用`sumTwoInt()`方法。
- en: JNR provides many other features that you can exploit starting from [https://github.com/jnr](https://github.com/jnr).
    You may also be interested in JavaCPP, which is another alternative to JNI ([https://github.com/bytedeco/javacpp](https://github.com/bytedeco/javacpp)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JNR提供了许多其他功能，您可以从[https://github.com/jnr](https://github.com/jnr)开始利用。您可能还对JavaCPP感兴趣，它是JNI的另一个替代方案（[https://github.com/bytedeco/javacpp](https://github.com/bytedeco/javacpp)）。
- en: 147\. Motivating and introducing Project Panama
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 147. 介绍和激励Project Panama
- en: Project Panama, or the Foreign Function & Memory (FFM) API, is an elegant way
    of saying goodbye to JNI. This project started in JDK 17 as JEP 412 (first incubator).
    It continued in JDK 18 as JEP 419 (second incubator), JDK 19 as JEP 424 (first
    preview), JDK 20 as JEP 434 (second preview), and JDK 21 as JEP 442 (third preview).
    This is where things are at the time of writing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Project Panama，或Foreign Function & Memory (FFM) API，是告别JNI的一种优雅方式。这个项目始于JDK
    17作为JEP 412（第一个孵化器）。它继续在JDK 18作为JEP 419（第二个孵化器），JDK 19作为JEP 424（第一个预览），JDK 20作为JEP
    434（第二个预览），以及JDK 21作为JEP 442（第三个预览）。这就是撰写本文时的状况。
- en: To understand the goals of this project, we have to talk about accessing **off-heap**
    memory from Java applications. By off-heap memory, we mean the memory that is
    outside the JVM heap and is not managed by the garbage collector.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这个项目的目标，我们必须谈谈从Java应用程序访问**堆外**内存。通过堆外内存，我们指的是位于JVM堆之外且不由垃圾收集器管理的内存。
- en: 'Surfing off-heap is the job of JNI, JNA, and JNR. In one way or another, these
    APIs can work in off-heap land to handle different tasks. Among these tasks, we
    can enumerate the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆外内存中冲浪是JNI、JNA和JNR的工作。以某种方式，这些API可以在堆外空间中工作以处理不同的任务。在这些任务中，我们可以列举以下内容：
- en: Use native libraries (for instance, some common libraries are Open CL/GL, CUDA,
    TensorFlow, Vulkan, OpenSSL, V8, BLAS, cuDNN, and so on)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地库（例如，一些常见的库有Open CL/GL, CUDA, TensorFlow, Vulkan, OpenSSL, V8, BLAS, cuDNN等）
- en: Share memory across different processes
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同进程间共享内存
- en: Serialize/deserialize memory content to the so-called *mmaps*
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将内存内容序列化/反序列化到所谓的*mmaps*
- en: The Java *de facto* API for accomplishing these kinds of tasks is `ByteBuffer`,
    or better, the so-called *allocated direct buffers*, which are more efficient
    in accessing off-heap memory. Alternatively, we can use JNI, or as you saw, third-party
    libraries such as JNA and JNR.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Java完成这些任务的*事实上的* API是`ByteBuffer`，或者更好的是所谓的*分配的直接缓冲区*，在访问堆外内存方面更高效。或者，我们可以使用JNI，或者如您所见，第三方库如JNA和JNR。
- en: 'However, `ByteBuffer` and JNI have a lot of shortcomings that make them useful
    only in a limited number of scenarios. A few of their drawbacks are listed below:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`ByteBuffer`和JNI有很多缺点，使得它们仅在有限数量的场景中才有用。以下列出了一些它们的缺点：
- en: '`ByteBuffer`:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ByteBuffer`:'
- en: Brittle and error-prone
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脆弱且易出错
- en: Unstable memory addresses
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不稳定的内存地址
- en: Backed by an array that can be manipulated by the garbage collector
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由垃圾收集器可以操作的数组支持
- en: Allocated direct buffers
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配直接缓冲区
- en: Cannot scale when used as a general off-heap API
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用作通用off-heap API时无法扩展
- en: Works well only if used by power users who deeply understand its use
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当由深入了解其使用的强大用户使用时才表现良好
- en: No solution for deallocation/free memory
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有解决方案用于释放/释放内存
- en: 'JNI:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'JNI:'
- en: As you saw in *Problem 144*, JNI is hard to use (even for simple cases)
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您在*问题144*中看到的，JNI难以使用（即使是简单的情况）
- en: It is brittle and error-prone
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是脆弱且易出错的
- en: It is difficult/expensive to maintain
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护困难/昂贵
- en: There is poor error checking
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误检查较差
- en: It can crash the JVM
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能导致JVM崩溃
- en: 'These shortcomings and much more are behind the reason for the creation of
    Project Panama. The goal of this project is to become the new *de facto* API for
    interoperating with foreign data, functions, and memory in Java. To accomplish
    this goal, Project Panama has two main features:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缺点以及更多是Project Panama创建的原因。这个项目的目标是成为与Java中外国数据、函数和内存交互的新*事实上的* API。为了实现这个目标，Project
    Panama有两个主要特性：
- en: A future-proof API (low-level, efficient, robust, and safe) to replace the old-school
    API based on byte buffers – this is referred to as the memory access API and is
    capable of accessing on-heap and off-heap memory.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面向未来的API（低级、高效、健壮和安全），用于替换基于字节数组的旧式API——这被称为内存访问API，能够访问堆内和堆外内存。
- en: A brand-new paradigm replaces the JNI concepts and mechanisms, so now we have
    an intuitive, easy-to-use, and robust solution for creating Java bindings for
    native libraries. This is referred to as the Foreign Linker API.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全新的范式取代了JNI的概念和机制，因此现在我们有一个直观、易于使用且健壮的解决方案来创建Java绑定到本地库。这被称为外部链接器API。
- en: In the next problems, we will dive deeper into this project.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个问题中，我们将更深入地探讨这个项目。
- en: 148\. Introducing Panama’s architecture and terminology
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 148. 介绍Panama的架构和术语
- en: 'When we talk about architecture, it helps to present a meaningful diagram,
    so here it is:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论架构时，展示一个有意义的图表很有帮助，所以这就是它：
- en: '![Figure 7.8.png](img/B19665_07_08.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.8.png](img/B19665_07_08.png)'
- en: 'Figure 7.8: Project Panama architecture'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：Project Panama架构
- en: 'This diagram reveals the interoperability of Panama’s components. The climax
    of this diagram is the Jextract tool. As you’ll see in this chapter, Jextract
    is a very handy tool capable of consuming the headers of native libraries and
    producing low-level Java native bindings. These bindings are the unit of work
    for two major APIs of Project Panama:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此图揭示了Panama组件的互操作性。此图的顶峰是Jextract工具。正如您在本章中将要看到的，Jextract是一个非常实用的工具，能够消费本地库的头文件并生成低级Java本地绑定。这些绑定是Project
    Panama两个主要API的工作单元：
- en: Foreign Memory API – used to allocate/deallocate off-heap/on-heap memory
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部内存API——用于分配/释放堆外/堆内内存
- en: Foreign Linker API – used to call foreign functions directly from Java and vice
    versa
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部链接器API——用于从Java直接调用外国函数，反之亦然
- en: The process described so far is entirely mechanical. When these APIs and the
    low-level Java native bindings are not enough for our tasks, then we can take
    things a step further and create a set of higher-level Java bindings. Of course,
    this is not a task for novices, but it is very powerful. For instance, you may
    have an existing automation tool for generating JNI bindings and now you want
    to modernize your tool to generate a higher level of pure Java bindings in Panama’s
    style.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止描述的过程完全是机械的。当这些 API 和低级 Java 原生绑定不足以满足我们的任务时，我们可以进一步采取行动，创建一组高级 Java 绑定。当然，这不是新手的工作，但它非常强大。例如，你可能有一个现有的用于生成
    JNI 绑定的自动化工具，现在你想要将你的工具现代化，以便以 Panama 的风格生成更高层次的纯 Java 绑定。
- en: 'Among the abstractions used by Project Panama, we have the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Project Panama 使用的抽象中，我们有以下内容：
- en: '`java.lang.foreign.MemorySegment`: This API shapes a heap or native memory
    segment. A heap segment accesses on-heap memory, while a native segment accesses
    off-heap memory. In both cases, we’re talking about a contiguous region of memory
    that has a lifespan bounded by space and time.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.foreign.MemorySegment`：此 API 形成了堆或本地内存段。堆段访问堆内存，而本地段访问非堆内存。在两种情况下，我们谈论的是一个由空间和时间限制的内存连续区域。'
- en: '`java.lang.foreign.Arena` (or `MemorySession` in JDK versions earlier than
    20): This API can control the memory segment’s lifespan.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.foreign.Arena`（或在 JDK 20 之前的版本中为 `MemorySession`）：此 API 可以控制内存段的生存周期。'
- en: '`java.lang.foreign.MemorySegment.Scope`: This API represents the scope of a
    memory segment.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.foreign.MemorySegment.Scope`：此 API 表示内存段的范围。'
- en: '`java.lang.foreign.MemoryLayout`: This API describes the content of memory
    segments as *memory layouts*. For instance, among the available memory layouts,
    in the context of basic Java data types (`int`, `double`, `long`, and so on),
    we have *memory value layouts* (`java.lang.foreign.ValueLayout`).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.foreign.MemoryLayout`：此 API 将内存段的内容描述为 *内存布局*。例如，在基本 Java 数据类型（`int`、`double`、`long`
    等）的上下文中，我们有 *内存值布局*（`java.lang.foreign.ValueLayout`）。'
- en: Of course, next to these three pillars, we have many other classes and helpers.
    In the next problems, we will cover several scenarios meant to get us familiar
    with the major aspects of using Project Panama’s APIs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了这三个支柱之外，我们还有许多其他类和辅助工具。在接下来的问题中，我们将涵盖几个旨在让我们熟悉使用 Project Panama 的 API 的主要方面的场景。
- en: 149\. Introducing Arena and MemorySegment
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 149. 介绍 Arena 和 MemorySegment
- en: A `MemorySegment` shapes a heap or native memory segment. A heap segment accesses
    on-heap memory, while a native segment accesses off-heap memory. In both cases,
    we talk about a contiguous region of memory that has a lifespan bounded by space
    and time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemorySegment` 形成了堆或本地内存段。堆段访问堆内存，而本地段访问非堆内存。在两种情况下，我们谈论的是一个由空间和时间限制的内存连续区域。'
- en: 'Among its characteristics, a memory segment has a *size* in bytes, an *alignment*
    of bytes, and a *scope*. The scope is shaped via the `java.lang.foreign.MemorySegment.Scope`
    sealed interface and represents the lifespan of the memory segment. A native memory
    segment lifespan is controlled by a `java.lang.foreign.Arena` instance. An `Arena`
    has a scope that can be:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在其特征中，内存段有一个以字节为单位的 *大小*，一个字节的 *对齐*，以及一个 *范围*。范围通过 `java.lang.foreign.MemorySegment.Scope`
    封闭接口形成，并代表内存段的生存周期。本地内存段的生存周期由 `java.lang.foreign.Arena` 实例控制。`Arena` 有一个可以是的范围：
- en: 'The *arena global scope* (or *global arena*): The memory segments with the
    arena global scope are always accessible. In other words, the regions of memory
    allocated to these segments are never deallocated and their global scope remains
    alive forever.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*全局竞技场范围*（或 *全局竞技场*）：具有竞技场全局范围的内存段始终可访问。换句话说，分配给这些段的内存区域永远不会被释放，并且它们的全局范围将永远保持活跃。'
- en: 'Attempting to close (`close()`) this scope will result in `UnsupportedOperationException`.
    Here is an example of creating a native memory segment of 8 bytes in the arena
    global scope:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试关闭（`close()`）此范围将导致 `UnsupportedOperationException`。以下是在竞技场全局范围内创建 8 字节原生内存段的示例：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The *arena auto scope*: The memory segments with the arena automatic scope
    are managed by the garbage collector. In other words, the garbage collector determines
    when the regions of memory backing these segments can be safely deallocated.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动竞技场范围*：具有自动竞技场范围的内存段由垃圾收集器管理。换句话说，垃圾收集器决定何时可以安全地释放这些段背后的内存区域。'
- en: 'Attempting to close (`close()`) this scope will result in an `UnsupportedOperationException`.
    Here is an example of creating a native memory segment of 8 bytes in the auto
    scope:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试关闭（`close()`）此作用域将导致 `UnsupportedOperationException`。以下是在自动作用域中创建8字节数本机内存段的示例：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The *arena confined scope* (or, *confined arena*): Strict control of the memory
    segment’s lifespan (allocation/deallocation and lifetime) can be obtained via
    a confined arena. Typically, this scope lives in a `try-with-resources` block.
    When the `Arena` is closed (by explicitly calling `close()`, or by simply leaving
    the arena’s `try-with-resources` block), its scope is closed, all memory segments
    associated with this scope are destroyed, and memory is deallocated automatically.
    A confined arena is opened via `ofConfined()` and is owned by the current thread
    – the memory segments associated with the scope of a confined arena can only be
    accessed by the thread that created the arena.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*受限区域作用域*（或，*受限区域*）：通过受限区域可以获得对内存段生命周期的严格控制（分配/释放和生命周期）。通常，这个作用域存在于 `try-with-resources`
    块中。当 `Arena` 被关闭（通过显式调用 `close()`，或者简单地离开 `try-with-resources` 块），其作用域关闭，所有与该作用域关联的内存段被销毁，并且内存自动释放。受限区域通过
    `ofConfined()` 打开，并由当前线程拥有 – 受限区域作用域的内存段只能由创建该区域的线程访问。'
- en: 'In code lines, a confined arena can be created as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，可以创建一个受限区域，如下所示：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The *arena shared scope* (or, *shared arena*): A shared arena is typically
    opened in a `try-with-resources` block via `ofShared()` and can be shared by multiple
    threads – the memory segments associated with the scope of the shared arena can
    be accessed by any thread (for instance, this can be useful for performing parallel
    computations on memory segments). When the `Arena` is closed (by explicitly calling
    `close()`, or by simply leaving the arena’s `try-with-resources` block), its scope
    is closed, all memory segments associated with this scope are destroyed, and memory
    is deallocated automatically.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*共享区域作用域*（或，*共享区域*）：共享区域通常通过 `try-with-resources` 块中的 `ofShared()` 打开，并且可以被多个线程共享
    – 与共享区域作用域关联的内存段可以被任何线程访问（例如，这可以用于在内存段上执行并行计算）。当 `Arena` 被关闭（通过显式调用 `close()`，或者简单地离开
    `try-with-resources` 块），其作用域关闭，所有与该作用域关联的内存段被销毁，并且内存自动释放。'
- en: 'In code lines, a confined arena can be created as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，可以创建一个受限区域，如下所示：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By calling `arena.scope()`, we obtain the `MemorySegment.Scope` of the arena,
    and by calling `arena.scope().isAlive()`, we can find out if the current scope
    is alive or not. A memory segment is accessible only if its scope is alive, so
    as long as the arena’s scope is alive.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `arena.scope()`，我们获得区域的 `MemorySegment.Scope`，通过调用 `arena.scope().isAlive()`，我们可以找出当前作用域是否存活。只有当作用域存活时，内存段才是可访问的，因此只要区域的范围存活。
- en: 'Here, we have a memory segment of 8 bytes in the arena scope:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个8字节的内存段位于区域作用域中：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Summarizing the main characteristics of arena scopes in a table can be done
    as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式将区域作用域的主要特征总结到表中：
- en: '![Figure a0.png](img/B19665_07_09.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![Figure a0.png](img/B19665_07_09.png)'
- en: 'Figure 7.9: Summarizing the main characteristics of arena scopes'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：总结区域作用域的主要特征
- en: 'If you want to monitor the allocated native memory, then this article will
    help you to do so: [https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/](https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/).
    Before going further, let’s briefly introduce *memory layouts*.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想监控分配的本机内存，那么这篇文章将帮助你做到这一点：[https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/](https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/)。在继续之前，让我们简要介绍
    *内存布局*。
- en: Introducing memory layouts (ValueLayout)
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍内存布局（ValueLayout）
- en: '*Memory layouts* are shaped by the `java.lang.foreign.MemoryLayout` interface
    and their goal is to describe the content of memory segments.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存布局* 由 `java.lang.foreign.MemoryLayout` 接口定义，其目标是描述内存段的内容。'
- en: We have *simple memory layouts*, including `ValueLayout` and `PaddingLayout`,
    but we also have *complex memory layouts* for describing complex memory segments
    such as `SequenceLayout`, `StructLayout`, `UnionLayout`, and `GroupLayout`. The
    complex layouts are useful to model hierarchical user-defined data types such
    as C-like sequences, structures, unions, and so on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 *简单内存布局*，包括 `ValueLayout` 和 `PaddingLayout`，但我们也有 *复杂内存布局*，用于描述复杂内存段，如 `SequenceLayout`、`StructLayout`、`UnionLayout`
    和 `GroupLayout`。复杂布局对于建模层次化的用户定义数据类型非常有用，例如类似C的序列、结构、联合等。
- en: Allocating memory segments of value layouts
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配值布局的内存段
- en: For now, we are interested in `ValueLayout`. This is a simple memory layout
    that is useful to represent basic Java data types such as `int`, `float`, `double`,
    `char`, `byte`, and so on. In an API-specific example, a `ValueLayout.JAVA_LONG`
    is a layout whose *carrier* is `long.class`, a `ValueLayout.JAVA_DOUBLE` is a
    layout whose *carrier* is `double.class`, and so on. The *carrier* of a value
    layout can be obtained via the `carrier()` method.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们对`ValueLayout`感兴趣。这是一个简单的内存布局，用于表示基本Java数据类型，如`int`，`float`，`double`，`char`，`byte`等。在API特定的示例中，`ValueLayout.JAVA_LONG`是一个其*载体*为`long.class`的布局，`ValueLayout.JAVA_DOUBLE`是一个其*载体*为`double.class`的布局，等等。值布局的*载体*可以通过`carrier()`方法获得。
- en: 'For instance, let’s assume that we have a confined `arena` and need a memory
    segment for storing a single `int` value. We know that a Java `int` needs 4 bytes,
    so our segment can be allocated as follows (the first argument of `allocate()`
    is the `int` *byte size*, and the second argument is the `int` *byte alignment*):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个受限的`arena`并且需要一个内存段来存储单个`int`值。我们知道Java `int`需要4个字节，所以我们的段可以这样分配（`allocate()`的第一个参数是`int`的字节大小，第二个参数是`int`的字节对齐）：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But we can achieve the same thing via `ValueLayout` as follows (here, we use
    `allocate(MemoryLayout layout)` and `allocate(long byteSize, long byteAlignment)`):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以通过`ValueLayout`实现相同的功能如下（在这里，我们使用`allocate(MemoryLayout layout)`和`allocate(long
    byteSize, long byteAlignment)`）：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or, without specifying the *byte alignment*, via `allocate(long byteSize)`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，不指定*字节对齐*，通过`allocate(long byteSize)`：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is another example of allocating a memory segment for storing a Java `double`
    using the *byte alignment* specific to `ValueLayout.JAVA_DOUBLE`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个使用`ValueLayout.JAVA_DOUBLE`特定的*字节对齐*为存储Java `double`分配内存段的示例：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Or, allocating a memory segment for storing a Java `char` can be done as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为存储Java `char`分配一个内存段可以这样做：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that we know how to allocate a memory segment to different data types, let’s
    see how we can set/get some values.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何为不同数据类型分配内存段，让我们看看我们如何设置/获取一些值。
- en: Setting/getting the content of a memory segment
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置/获取内存段的内容
- en: 'The `Arena` API provides a set of `allocate()` methods inherited from `SegmentAllocator`
    that can be used to allocate a memory segment and set its content in the same
    line of code (in the previous section, we used only the `allocate()` flavors that
    allocate memory segments but don’t set their content). For instance, calling `allocate(OfInt
    layout, int value)` allocates a memory segment for storing an `int` and sets that
    `int` to the given `value` (`OfInt` is an interface that extends `ValueLayout`).
    Here, we consider the `int` as being `Integer.MAX_VALUE`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arena` API提供了一组从`SegmentAllocator`继承的`allocate()`方法，这些方法可以用于在同一行代码中分配一个内存段并设置其内容（在前一节中，我们只使用了分配内存段但不设置其内容的`allocate()`变体）。例如，调用`allocate(OfInt
    layout, int value)`会分配一个用于存储`int`的内存段并将该`int`设置为给定的`value`（`OfInt`是一个扩展`ValueLayout`的接口）。在这里，我们将`int`视为`Integer.MAX_VALUE`：'
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or, here we allocate a memory segment for a `char` and set that `char` to `a`
    (`allocate(OfChar layout, char value)`):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在这里我们为`char`分配一个内存段并将该`char`设置为`a`（`allocate(OfChar layout, char value)`）：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: But if we want to set the content of a memory segment later (not at the same
    time as the allocation), then we can use the `MemorySegment.set()` or `setAtIndex()`
    method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想在稍后设置内存段的内容（不是在分配时），则可以使用`MemorySegment.set()`或`setAtIndex()`方法。
- en: 'For instance, we can set the `Integer.MAX_VALUE` via `set(OfInt layout, long
    offset, int value)` as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过`set(OfInt layout, long offset, int value)`设置`Integer.MAX_VALUE`如下所示：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second argument is the `offset` (0, 4, 8, 12, …), which in this case must
    be 0\. Alternatively, we can use `setAtIndex(OfInt layout, long index, int value)`
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是`offset`（0，4，8，12，……），在这种情况下必须是0。或者，我们可以使用`setAtIndex(OfInt layout, long
    index, int value)`如下所示：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, the second argument represents an index exactly as in an array (0, 1,
    2, 3…). In this case, it must be 0 since we have a single integer stored in the
    memory segment.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第二个参数代表一个索引，正如在数组中一样（0，1，2，3……）。在这种情况下，它必须是0，因为我们只在一个内存段中存储一个整数。
- en: 'Getting content from a certain offset can be done via `get()` and from a certain
    index via `getAtIndex()` methods. For instance, getting the `int` stored at a
    certain offset can be done via `get(OfInt layout, long offset)`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从某个偏移量获取内容可以通过`get()`方法完成，从某个索引通过`getAtIndex()`方法完成。例如，可以通过`get(OfInt layout,
    long offset)`获取存储在某个偏移量处的`int`：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And, the `int` stored at a certain index via `getAtIndex(OfInt layout, long
    index)`, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，通过 `getAtIndex(OfInt layout, long index)` 在某个索引处存储的 `int`，如下所示：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the next problems, you’ll see more examples of using these methods.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的问题中，你将看到更多使用这些方法的示例。
- en: Working with Java strings
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理 Java 字符串
- en: 'Allocating a memory segment for storing a Java `String` is a special case.
    If we have an `Arena` instance, then we can allocate a memory segment and set
    its content as a Java `String` via `allocateUtf8String(String str)` as follows
    (here, the Java string is `abcd`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为存储 Java `String` 分配内存段是一个特殊情况。如果我们有一个 `Arena` 实例，那么我们可以分配一个内存段，并通过 `allocateUtf8String(String
    str)` 方法将其内容设置为 Java `String`，如下所示（这里，Java 字符串是 `abcd`）：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `allocateUtf8String(String str)` converts a Java `String` into a C-like
    string that is UTF-8-encoded and `null`-terminated. The size of the memory segment
    is obtained as `str.length` + 1.This means that we can allocate a segment for
    the `abcd` string as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`allocateUtf8String(String str)` 方法将 Java `String` 转换为 UTF-8 编码且以 `null` 结尾的类似
    C 的字符串。内存段的大小为 `str.length` + 1。这意味着我们可以为 `abcd` 字符串分配如下段：'
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Or, more expressive:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更具体地说：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Having the allocated memory segment, we can set the string via `setUtf8String(long
    offset, String str)` as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配了内存段之后，我们可以通过 `setUtf8String(long offset, String str)` 方法设置字符串，如下所示：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Getting the string stored in a memory segment can be done via `MemorySegment.getUtf8String(long
    offset)`, so we can do it as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `MemorySegment.getUtf8String(long offset)` 获取存储在内存段中的字符串，我们可以这样做：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can practice all these examples in the bundled code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中练习所有这些示例。
- en: 150\. Allocating arrays into memory segments
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 150. 将数组分配到内存段
- en: 'Now that we know how to create memory segments for storing single values, let’s
    take it a step further and try to store an array of integers. For instance, let’s
    define a memory segment for storing the following array: [11, 21, 12, 7, 33, 1,
    3, 6].'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何为存储单个值创建内存段，让我们更进一步，尝试存储一个整数数组。例如，让我们定义一个用于存储以下数组的内存段：[11, 21, 12,
    7, 33, 1, 3, 6]。
- en: 'A Java `int` needs 4 bytes (32 bits) and we have 8 integers, so we need a memory
    segment of 4 bytes x 8 = 32 bytes = 256 bits. If we try to represent this memory
    segment, then we can do it as in the following figure:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Java `int` 需要 4 个字节（32 位），我们有 8 个整数，所以我们需要一个 4 字节 x 8 = 32 字节 = 256 位的内存段。如果我们尝试表示这个内存段，那么我们可以像以下图示那样做：
- en: '![Figure 7.9.png](img/B19665_07_10.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.9.png](img/B19665_07_10.png)'
- en: 'Figure 7.10: A memory segment of 8 integers'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：一个包含 8 个整数的内存段
- en: 'In code lines, we can allocate this memory segment via any of the following
    approaches (`arena` is an instance of `Arena`):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，我们可以通过以下任何一种方法来分配这个内存段（`arena` 是 `Arena` 的一个实例）：
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we can use the `set(OfInt layout, long offset, int value)` method to
    populate the memory segment as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `set(OfInt layout, long offset, int value)` 方法填充内存段，如下所示：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or, we can use the `setAtIndex(OfInt layout, long index, int value)` method
    as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `setAtIndex(OfInt layout, long index, int value)` 方法如下：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We already know that we can access any of these integers via `get()` using
    the offset or via `getAtIndex()` using the index. This time, let’s try to use
    this memory segment to populate an `IntVector` (introduced in *Chapter 5*). The
    code should look as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们可以通过 `get()` 使用偏移量或通过 `getAtIndex()` 使用索引来访问这些整数中的任何一个。这次，让我们尝试使用这个内存段来填充一个
    `IntVector`（在 *第五章* 中介绍）。代码应该如下所示：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So, the Vector API exposes the `fromMemorySegment()` method, especially to populate
    a vector from a memory segment. The `ByteOrder` can be `nativeOrder()`, which
    means the platform’s native order of bytes, `BIG_ENDIAN` (big-endian byte order),
    or `LITTLE_ORDER` (little-endian byte order).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Vector API 提供了 `fromMemorySegment()` 方法，特别是用于从内存段填充向量。`ByteOrder` 可以是 `nativeOrder()`，这意味着平台的本地字节顺序，`BIG_ENDIAN`（大端字节顺序），或者
    `LITTLE_ENDIAN`（小端字节顺序）。
- en: 'A more convenient approach for populating the memory segment relies on a suite
    of `Arena.allocateArray()` methods inherited from `SegmentAllocator`. These methods
    create and populate the memory segment in a single line of code, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 填充内存段的一个更方便的方法依赖于从 `SegmentAllocator` 继承的 `Arena.allocateArray()` 方法集。这些方法可以在一行代码中创建并填充内存段，如下所示：
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Or, here it is a `char[]` array:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，这里是一个 `char[]` 数组：
- en: '[PRE45]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'All these examples allocate an off-heap memory segment. If we need an on-heap
    memory segment, then we can rely on `MemorySegment.ofArray()`, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都分配了一个堆外内存段。如果我们需要一个堆内内存段，那么我们可以依赖 `MemorySegment.ofArray()`，如下所示：
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For complete examples, please consider the bundled code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的示例，请考虑捆绑的代码。
- en: 151\. Understanding addresses (pointers)
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 151. 理解地址（指针）
- en: 'A memory segment has a memory address (*pointer*) expressed as a `long` number.
    An off-heap memory segment has a *physical address* that points out the memory
    region that backs the segment (*base address*). Each memory layout stored in this
    segment has its own memory address as well. For instance, here is an example of
    querying the *base address* of a memory segment via the `address()` method (`arena`
    is an instance of `Arena`):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 内存段有一个表示为`long`数字的内存地址（*指针*）。堆外内存段有一个*物理地址*，它指向支持该段的内存区域（*基地址*）。该段中存储的每个内存布局都有自己的内存地址。例如，这是通过`address()`方法查询内存段*基地址*的一个示例（`arena`是`Arena`的一个实例）：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: On the other hand, an on-heap memory segment has a *non-physical stable virtualized*
    address typically representing an offset within the memory region of that segment
    (the client sees a stable address while the garbage collector can reallocate the
    region of memory inside the heap). For instance, an on-heap segment created via
    one of the `ofArray()` factory methods has an address of 0.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，堆内存段有一个*非物理稳定的虚拟化*地址，通常表示该段内存区域内的偏移量（客户端看到一个稳定的地址，而垃圾收集器可以重新分配堆内存内部的内存区域）。例如，通过`ofArray()`工厂方法之一创建的堆段有一个地址为0。
- en: 'Next, let’s focus only on off-heap memory segments. Let’s consider the following
    three memory segments containing integer values (`arena` is an instance of `Arena`):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们只关注堆外内存段。让我们考虑以下包含整数值的三个内存段（`arena`是`Arena`的一个实例）：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Each of these segments has a memory address. Next, let’s create a segment containing
    their addresses (like a segment of pointers). First, we allocate such a segment
    via `ValueLayout.ADDRESS` as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这些段中的每一个都有一个内存地址。接下来，让我们创建一个包含它们地址的段（就像指针段一样）。首先，我们通过`ValueLayout.ADDRESS`分配这样一个段，如下所示：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since each address is a `long` value, the size of `addrs` is 24 bytes. We can
    use the `set()` method and the offsets 0, 8, and 16 to set the addresses of `i1`,
    `i2`, and `i3`, or we can use the `setAtIndex()` and refer to offsets as indexes
    0, 1, and 2:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个地址都是一个`long`值，`addrs`的大小为24字节。我们可以使用`set()`方法和偏移量0、8和16来设置`i1`、`i2`和`i3`的地址，或者我们可以使用`setAtIndex()`并引用偏移量作为索引0、1和2：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can represent this in the following diagram:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下图表来表示：
- en: '![Figure 7.11.png](img/B19665_07_11.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11.png](img/B19665_07_11.png)'
- en: 'Figure 7.11: Storing i1, i2, and i3 addresses in an array of addresses'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：将i1、i2和i3地址存储在地址数组中
- en: In other words, we set the address of `i1` at offset 0 in `addrs`, the address
    of `i2` at offset 8, and the address of `i3` at offset 16\. The `addrs` segment
    doesn’t hold the data of `i1`, `i2`, and `i3`. It is just a segment of pointers
    that points to the memory addresses of `i1`, `i2`, and `i3`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们在`addrs`的偏移量0处设置了`i1`的地址，在偏移量8处设置了`i2`的地址，在偏移量16处设置了`i3`的地址。`addrs`段不包含`i1`、`i2`和`i3`的数据。它只是一个指针段，指向`i1`、`i2`和`i3`的内存地址。
- en: 'If we call `get()`/`getAtIndex()`, we will get an address:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`get()`/`getAtIndex()`，我们将得到一个地址：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can represent this in the following diagram:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下图表来表示：
- en: '![Figure 7.11 - Copy.png](img/B19665_07_12.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 - Copy.png](img/B19665_07_12.png)'
- en: 'Figure 7.12: Getting addresses from the array of addresses'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：从地址数组中获取地址
- en: 'But check out the return type. It is not a `long` value! It is a `MemorySegment`.
    The returned native memory segments (`addr1`, `addr2`, and `addr3`) are automatically
    associated with the *global scope*. They have the size 0 (*limit: 0*) and each
    of them wraps the returned address of the given offset/index (the `long` value
    is available via `addr1`/`2`/`3.address()`). However, in the case of an *unbounded*
    address layout, the size is expected to be `Long.MAX_VALUE` (9223372036854775807).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 但检查一下返回类型。它不是一个`long`值！它是一个`MemorySegment`。返回的本地内存段（`addr1`、`addr2`和`addr3`）自动与*全局作用域*相关联。它们的大小为0（*限制：0*），每个段都封装了给定偏移量/索引返回的地址（`long`值可以通过`addr1`/`2`/`3.address()`获得）。然而，在*无界*地址布局的情况下，预期的大小将是`Long.MAX_VALUE`（9223372036854775807）。
- en: 'This means that we shouldn’t do this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不应该这样做：
- en: '[PRE52]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This causes an `IndexOutOfBoundsException` since `addr1` has a size of 0 bytes
    – this is known as a *zero-length memory segment*. Getting the integer value associated
    with an address can be done via the `ofAddress()` and a flavor of the `reinterpret()`
    methods, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致`IndexOutOfBoundsException`，因为`addr1`的大小为0字节——这被称为*零长度内存段*。通过`ofAddress()`和`reinterpret()`方法的一种变体，可以获取与地址相关联的整数值，如下所示：
- en: '[PRE53]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'First, we call `ofAddress()` and pass the `addr1` address. This will create
    a native memory segment with the size 0\. Next, we call the `reinterpret()` method
    and pass the size of the `int` type. This will return a new memory segment (a
    reinterpreted memory segment) with the same address and scope as this segment,
    but with the given size (4 bytes). Finally, we read the integer value stored at
    this address at offset 0\. The same thing can be done for `addr2` and `addr3`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`ofAddress()`并传递`addr1`地址。这将创建一个大小为0的本地内存段。接下来，我们调用`reinterpret()`方法并传递`int`类型的大小。这将返回一个新的内存段（重新解释的内存段），其地址和作用域与该段相同，但具有给定的大小（4字节）。最后，我们读取在偏移量0处存储的此地址的整数值。对于`addr2`和`addr3`也可以做同样的事情：
- en: '[PRE54]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Before using the `reinterpret()` or `withTargetLayout()` methods, please consider
    the following note:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`reinterpret()`或`withTargetLayout()`方法之前，请考虑以下注意事项：
- en: '**Important note**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The `reinterpret()` method (and all other methods for working with zero-length
    memory segments) is considered a *restricted* method. It should be used with caution
    since any mistake can lead to a VM crash when trying to access the memory segment.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`reinterpret()`方法（以及所有用于处理零长度内存段的方法）被视为*受限*方法。应谨慎使用，因为任何错误都可能导致在尝试访问内存段时虚拟机崩溃。'
- en: 'We can check whether two long addresses are equal via the `==` operator:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`==`运算符检查两个长地址是否相等：
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or, via `equals()`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过`equals()`：
- en: '[PRE56]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'At this point, we have that `i1`=1, `i2`=3, and `i3`=2\. Let’s manipulate only
    the addresses to obtain `i1`=1, `i2`=2, and `i3`=3\. So, we want to switch the
    integer values of `i2` and `i3` by switching the addresses, not the values. First,
    we store the `i2` address as a `long`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有`i1`=1, `i2`=3, 和 `i3`=2。现在，我们只想操作地址以获得`i1`=1, `i2`=2, 和 `i3`=3。因此，我们想要通过交换地址而不是值来交换`i2`和`i3`的整数值。首先，我们将`i2`地址存储为`long`：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we set the `i2` address as the `i3` address:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`i2`地址设置为`i3`地址：
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we set the address of `i3` as the address of `i2`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`i3`的地址设置为`i2`的地址：
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Done! Now, `i1`=1, `i2`=2, and `i3`=3\. I hope you found this exercise useful
    for understanding how to manipulate values, offsets, and memory addresses.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，`i1`=1, `i2`=2, 和 `i3`=3。我希望你发现这个练习对理解如何操作值、偏移量和内存地址有帮助。
- en: 152\. Introducing the sequence layout
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 152. 介绍序列布局
- en: In *Problem 149*, we already covered the `ValueLayout` for basic data types.
    Next, let’s talk about the *sequence layout* (`java.lang.foreign.SequenceLayout`).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在*问题149*中，我们已经涵盖了基本数据类型的`ValueLayout`。接下来，让我们谈谈*序列布局*（`java.lang.foreign.SequenceLayout`）。
- en: 'But before introducing the sequence layout, let’s take a moment to analyze
    the following snippet of code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 但在介绍序列布局之前，让我们花一点时间分析以下代码片段：
- en: '[PRE60]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We start by creating a native memory segment for storing 10 `double` values.
    Next, we rely on `setAtIndex()` to set these `double` values. Finally, we print
    them.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个用于存储10个`double`值的本地内存段。接下来，我们依靠`setAtIndex()`来设置这些`double`值。最后，我们打印它们。
- en: So, basically, we repeat the `ValueLayout.JAVA_DOUBLE` 10 times. When an *element
    layout* is repeated *n* times (a finite number of times), we can express the code
    via a sequence layout (`java.lang.foreign.SequenceLayout`). In other words, a
    sequence layout represents a repetition/sequence of a given *element layout* for
    a finite number of times.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，我们重复`ValueLayout.JAVA_DOUBLE` 10次。当一个*元素布局*被重复*n*次（有限次数）时，我们可以通过序列布局（`java.lang.foreign.SequenceLayout`）来表示代码。换句话说，序列布局表示给定*元素布局*的重复/序列，重复有限次数。
- en: 'The following code uses `SequenceLayout` to shape the previous snippet:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`SequenceLayout`来塑造前面的片段：
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The number of repetitions (*element count*) is 10, and the repeated *element
    layout* is `ValueLayout.JAVA_DOUBLE`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 重复次数（*元素计数*）为10，重复的*元素布局*为`ValueLayout.JAVA_DOUBLE`。
- en: But how do we set the values of a sequence layout? There are at least two approaches,
    and one of them relies on a combination of the `java.lang.invoke.VarHandle` API
    and the `java.lang.foreign.MemoryLayout.PathElement` API.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何设置序列布局的值？至少有两种方法，其中一种依赖于`java.lang.invoke.VarHandle` API和`java.lang.foreign.MemoryLayout.PathElement`
    API的组合。
- en: Introducing PathElement
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 PathElement
- en: In a nutshell, the `PathElement` API exposes a friendly approach for navigating
    a hierarchal memory layout via the so-called *layout path*. By chaining path elements
    in a layout path, we can locate an element layout, which can be a sequence layout
    (located via sequence path elements) or, as you’ll see in other problems, a group
    layout (which can be a struct layout or a union layout located via group path
    elements). Sequence layouts are traversed via `PathElement.sequenceElement()`,
    while group layouts via `PathElement.groupElement()`. Each element layout has
    a number of elements referred to as the *element count* (obtained via a method
    named `elementCount()`).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`PathElement` API 通过所谓的 *布局路径* 提供了一种友好的方法来通过层次化内存布局进行导航。通过在布局路径中链接路径元素，我们可以定位一个元素布局，这可以是一个序列布局（通过序列路径元素定位）或者，正如你将在其他问题中看到的那样，一个组布局（可以通过组路径元素定位，可以是结构布局或联合布局）。序列布局通过
    `PathElement.sequenceElement()` 进行遍历，而组布局通过 `PathElement.groupElement()` 进行遍历。每个元素布局都有一个称为
    *元素计数* 的元素数量（通过名为 `elementCount()` 的方法获得）。
- en: Introducing VarHandle
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 VarHandle
- en: '`VarHandle` is not new to town. It was introduced in JDK 9\. A `VarHandle`
    is a dynamic, immutable, non-visible-state, strongly typed reference to a variable
    that cannot be subclassed. Its goal is to provide read/write access to the handled
    variables under certain circumstances.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`VarHandle` 并非新事物。它在 JDK 9 中被引入。`VarHandle` 是一个动态的、不可变的、无状态、强类型的对变量的引用，不能被继承。其目标是提供在特定情况下对处理变量的读写访问。'
- en: 'A `VarHandle` is characterized by two aspects:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`VarHandle` 有两个特点：'
- en: The type of variables represented by this `VarHandle` as a generic type (`T`)
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由此 `VarHandle` 表示的变量类型作为泛型类型（`T`）
- en: A list of Coordinate Types (denoted CT) used to locate variables referenced
    by this `VarHandle`
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组用于定位此 `VarHandle` 引用的变量的坐标类型（表示为 CT）
- en: The CT list may be empty.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: CT 列表可能为空。
- en: Typically, a `VarHandle` method gets a variable number of `Object` arguments.
    Argument(s) checking is accomplished at runtime (static argument(s) checking is
    disabled). Different methods of `VarHandle` expect to have a variable number of
    arguments of different types.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`VarHandle` 方法会接收一个可变数量的 `Object` 参数。参数检查是在运行时完成的（静态参数检查被禁用）。`VarHandle`
    的不同方法期望接收不同类型的可变数量的参数。
- en: Putting PathElement and VarHandle together
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 PathElement 和 VarHandle 结合起来
- en: The path elements (layout path) are arguments of the `MemoryLayout.varHandle()`
    method, which is capable of returning a `VarHandle` that can be used to access
    a memory segment at the layout located via this layout path. The path is considered
    rooted in this layout.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 路径元素（布局路径）是 `MemoryLayout.varHandle()` 方法的参数，该方法能够返回一个 `VarHandle`，可以用来访问通过此布局路径定位的内存段。路径被认为是根在此布局中。
- en: 'So, in our simple case, we can obtain a `VarHandle` for `seq` as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的简单情况下，我们可以如下获得 `seq` 的 `VarHandle`：
- en: '[PRE62]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Our path layout is just a simple navigation via `PathElement.sequenceElement()`.
    The returned `VarHandle` represents variables of the type `double` and contains
    a CT of (`MemorySegment` and `long`).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路径布局只是通过 `PathElement.sequenceElement()` 的简单导航。返回的 `VarHandle` 代表 `double`
    类型的变量，并包含一个由 (`MemorySegment` 和 `long`) 组成的 CT。
- en: 'The `MemorySegment` represents the memory segment from this sequence layout
    and the `long` value represents the index in this memory segment. This means that
    we can set 10 `double` values, as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemorySegment` 代表从该序列布局开始的内存段，而 `long` 值代表在该内存段中的索引。这意味着我们可以设置 10 个 `double`
    值，如下所示：'
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Getting these 10 `double` values can be done as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 获取这 10 个 `double` 值可以这样做：
- en: '[PRE64]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A `VarHandle` can be created via `arrayElementVarHandle(int... shape)` as well.
    This method creates a `VarHandle` for accessing a memory segment as a multi-dimensional
    array (this is known as a *strided var handler)*. The `varargs` argument, `shape`,
    represents the size of each nested array dimension. You can find this example
    in the bundle code.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`VarHandle` 也可以通过 `arrayElementVarHandle(int... shape)` 创建。此方法创建一个 `VarHandle`，用于以多维数组的形式访问内存段（这被称为
    *带步长的 var 处理器)*。`varargs` 参数 `shape` 表示每个嵌套数组维度的尺寸。你可以在代码包中找到这个示例。'
- en: Next, let’s complicate things a little bit.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们稍微复杂化一下。
- en: Working with nested sequence layouts
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与嵌套序列布局一起工作
- en: 'Let’s consider the following sequence layout of 400 bytes (5 * 10 * 8 bytes):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下 400 字节的序列布局（5 * 10 * 8 字节）：
- en: '[PRE65]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'So, here we have 5 sequence layouts of 10 `ValueLayout.JAVA_DOUBLE` each. Navigating
    to the `ValueLayout.JAVA_DOUBLE` requires a layout path obtained by chaining two
    calls of `sequenceLayout()`, as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们有5个包含10个 `ValueLayout.JAVA_DOUBLE` 的序列布局。要导航到 `ValueLayout.JAVA_DOUBLE`，需要通过链式调用两个
    `sequenceLayout()` 获取布局路径，如下所示：
- en: '[PRE66]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Besides the memory segment, the `VarHandle` accepts two `long` values. The
    first `long` corresponds to the outer sequence layout, and the second `long` corresponds
    to the inner sequence layout. The number of elements (element count) for the outer
    sequence is 5, and it can be obtained as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内存段之外，`VarHandle` 还接受两个 `long` 值。第一个 `long` 对应于外部序列布局，第二个 `long` 对应于内部序列布局。外部序列的元素数（元素计数）为5，如下所示：
- en: '[PRE67]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The element count of the inner sequence is 10, and it can be obtained via the
    `select()` method, as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 内部序列的元素计数为10，可以通过以下方式通过 `select()` 方法获取：
- en: '[PRE68]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, `outer` fits the first `long` argument in the coordinate’s types of `nphandle`,
    while `inner` fits the second `long` argument. So, we can get/set the `double`
    values of our sequence as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`outer` 与 `nphandle` 坐标类型中的第一个 `long` 参数匹配，而 `inner` 与第二个 `long` 参数匹配。因此，我们可以按以下方式获取/设置序列的
    `double` 值：
- en: '[PRE69]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the bundled code, you can see an example relying on `ValueLayout.JAVA_DOUBLE.arrayElementVarHandle(5,
    10)` as well.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到一个依赖于 `ValueLayout.JAVA_DOUBLE.arrayElementVarHandle(5, 10)` 的示例。
- en: 153\. Shaping C-like structs into memory segments
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 153. 将类似 C 的结构体塑形为内存段
- en: 'Let’s consider the C-like struct from the following figure:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图中的类似 C 结构体：
- en: '![Figure 7.16.png](img/B19665_07_13.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16.png](img/B19665_07_13.png)'
- en: 'Figure 7.13: A C-like structure'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：类似 C 的结构体
- en: 'So, in *Figure 7.13*, we have a C-like struct named `point` to shape an (*x*,
    *y*) pair of `double` values. Moreover, we have 5 such pairs declared under the
    name `pointarr`. We can try to shape a memory segment to fit this model as follows
    (`arena` is an instance of `Arena`):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 *图7.13* 中，我们有一个名为 `point` 的类似 C 结构体，用于塑形 (*x*, *y*) 对的 `double` 值。此外，我们还有5个这样的对在
    `pointarr` 下声明。我们可以尝试塑形一个内存段来适应这个模型，如下所示（`arena` 是 `Arena` 的一个实例）：
- en: '[PRE70]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we should set (*x*, *y*) pairs into this segment. For this, we can visualize
    it as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该将 (*x*, *y*) 对设置到这个段中。为此，我们可以将其可视化如下：
- en: '![Figure 7.17.png](img/B19665_07_14.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图7.17.png](img/B19665_07_14.png)'
- en: 'Figure 7.14: Memory segment to store (x, y) pairs'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：存储 (x, y) 对的内存段
- en: '[PRE71]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: But another approach consists of using the `StructLayout`, which is more suitable
    for this scenario since it provides a wrapping structure around the data.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一种方法是通过使用 `StructLayout`，这对于此场景更为合适，因为它在数据周围提供了一个包装结构。
- en: Introducing StructLayout
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 StructLayout
- en: 'A `StructLayout` is a group layout. In this layout, the members (other memory
    layouts) are laid out one after the other exactly as in a C struct. This means
    that we can shape our C-like struct by laying out two `ValueLayout.JAVA_DOUBLE`
    as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`StructLayout` 是一种分组布局。在这个布局中，成员（其他内存布局）是依次排列的，就像在 C 结构体中一样。这意味着我们可以通过以下方式将类似
    C 的结构体布局为两个 `ValueLayout.JAVA_DOUBLE`：'
- en: '[PRE73]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'But we have 5 pairs of (*x*, *y*), so we need to nest this `StructLayout` in
    a `SequenceLayout` containing 5 `StructLayout`, as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们有5对 (*x*, *y*)，因此我们需要将这个 `StructLayout` 嵌套在一个包含5个 `StructLayout` 的 `SequenceLayout`
    中，如下所示：
- en: '[PRE74]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, as we already know from *Problem 152*, we need to define the proper layout
    paths via `PathElement` and get back the `VarHandle`. We need a `VarHandle` for
    *x* and one for *y*. Notice in the following code how we point them out via their
    names:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如我们从 *问题152* 中已经知道的，我们需要通过 `PathElement` 定义适当的布局路径，并获取回 `VarHandle`。我们需要一个
    `VarHandle` 用于 *x* 和一个用于 *y*。注意以下代码中我们如何通过它们的名称来指出它们：
- en: '[PRE75]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, we can use `VarHandle` and the element count for setting the data,
    as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `VarHandle` 和元素计数来设置数据，如下所示：
- en: '[PRE76]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Getting the data is straightforward:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据非常简单：
- en: '[PRE77]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Challenge yourself to implement this example via `ValueLayout.JAVA_DOUBLE.arrayElementVarHandle(int...
    shape)`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战自己通过 `ValueLayout.JAVA_DOUBLE.arrayElementVarHandle(int... shape)` 实现此示例。
- en: 154\. Shaping C-like unions into memory segments
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 154. 将类似 C 的联合塑形为内存段
- en: 'Let’s consider the C-like union from the following figure (the members of a
    C union share the same memory location (the member’s largest data type dictates
    the size of the memory location), so only one of the members has a value at any
    moment in time):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图中的类似 C 的联合（C 联合的成员共享相同的内存位置（成员的最大数据类型决定了内存位置的大小），因此在任何时刻只有一个成员有值）：
- en: '![Figure 7.18.png](img/B19665_07_15.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图7.18.png](img/B19665_07_15.png)'
- en: 'Figure 7.15: A C-like union'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：一个类似C的联合体
- en: 'In *Figure 7.15*, we have a C-like union named `product` to shape two members,
    `price` (`double`) and `sku` (`int`), while only one can have a value at any moment
    in time. We can shape a memory segment to fit this model as follows (`arena` is
    an instance of `Arena`):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.15*中，我们有一个名为`product`的类似C的联合体，用于形成两个成员，`price`（`double`）和`sku`（`int`），在任何时刻只有一个可以具有值。我们可以按如下方式形成内存段以适应此模型（`arena`是`Arena`的一个实例）：
- en: '[PRE78]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Because `double` needs 8 bytes and `int` needs only 4 bytes, we choose `ValueLayout.JAVA_DOUBLE`
    to shape the size of the memory segment. This way, the segment can accommodate
    a `double` and an `int` at the same offset.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`double`需要8字节，而`int`只需要4字节，我们选择`ValueLayout.JAVA_DOUBLE`来形成内存段的大小。这样，该段可以在同一偏移量处容纳一个`double`和一个`int`。
- en: 'Next, we can set the `price` or the `sku` and use it accordingly:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以设置`price`或`sku`并相应地使用它们：
- en: '[PRE79]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: When we set the `sku` (`int`), the value of `price` (`double`) became a *garbage
    value* and vice versa. For more details, check out the bundled code. Next, let’s
    see an alternative to this implementation based on `UnionLayout`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置`sku`（`int`）时，`price`（`double`）的值变成了*垃圾值*，反之亦然。更多详情，请查看附带代码。接下来，让我们看看基于`UnionLayout`的此实现的替代方案。
- en: Introducing UnionLayout
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍UnionLayout
- en: 'A `UnionLayout` is a group layout. In this layout, the members (other memory
    layouts) are laid out at the same starting offset exactly as in a C union. This
    means that we can shape our C-like union by laying out the `price` (`double`)
    and the `sku` (`int`) members as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnionLayout`是一种组合布局。在这个布局中，成员（其他内存布局）按照与C联合体中完全相同的起始偏移量排列。这意味着我们可以通过如下方式排列`price`（`double`）和`sku`（`int`）成员来形成我们的类似C的联合体：'
- en: '[PRE80]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, as we already know from *Problem 152*, we need to define the proper layout
    paths via `PathElement` and get back the `VarHandle`. We need a `VarHandle` for
    `price` and one for `sku`. Notice in the following code how we point them out
    via their names:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，正如我们从*问题152*中已经知道的，我们需要通过`PathElement`定义适当的布局路径并获取回`VarHandle`。我们需要一个`VarHandle`用于`price`，另一个用于`sku`。注意以下代码中我们如何通过它们的名称来指出它们：
- en: '[PRE81]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we can use `VarHandle` to set `price` or `sku`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`VarHandle`来设置`price`或`sku`：
- en: '[PRE82]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: When we set the `sku` (`int`), the value of `price` (`double`) became a *garbage
    value* and vice versa.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置`sku`（`int`）时，`price`（`double`）的值变成了*垃圾值*，反之亦然。
- en: 155\. Introducing PaddingLayout
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 155. 介绍PaddingLayout
- en: 'Data types are typically characterized by several properties: *size*, *alignment*,
    *stride*, *padding*, and *order* of bytes.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型通常由几个属性来表征：*大小*、*对齐*、*步长*、*填充*和*字节顺序*。
- en: '*The padding layout* (`java.lang.foreign.PaddingLayout`) allows us to specify
    the *padding*. In other words, `PaddingLayout` allows us to add at certain offsets
    some extra space that is usually ignored by the applications but is needed to
    align the member layouts of a memory segment.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*填充布局*（`java.lang.foreign.PaddingLayout`）允许我们指定*填充*。换句话说，`PaddingLayout`允许我们在某些偏移量添加一些额外的空间，这些空间通常被应用程序忽略，但却是内存段成员布局对齐所需的。'
- en: For instance, let’s consider the following two memory segments (the left-hand
    side is a memory segment without padding, while the right-hand side is a memory
    segment with two paddings of 4 bytes each).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下两个内存段（左侧是没有填充的内存段，而右侧是带有两个各4字节填充的内存段）。
- en: '![Figure 7.19.png](img/B19665_07_16.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图7.19.png](img/B19665_07_16.png)'
- en: 'Figure 7.16: Memory segments with (right-hand side)/without (left-hand side)
    padding'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：带（右侧）/不带（左侧）填充的内存段
- en: 'In code lines, the padding-free memory segment can be shaped as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，无填充的内存段可以按如下方式形成：
- en: '[PRE83]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Since the size of `JAVA_INT` is 4 bytes, we can set *x* and *y* as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`JAVA_INT`的大小为4字节，我们可以将*x*和*y*设置为如下：
- en: '[PRE84]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This code writes the value 23 at offset 0, and 54 at offset 4\. No surprises,
    right?
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在偏移量0处写入值23，在偏移量4处写入54。没有惊喜，对吧？
- en: '[PRE85]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we write the two `int` values (23 and 54) again:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次写入两个`int`值（23和54）：
- en: '[PRE87]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This time, the padding zones are skipped, and 23 is written to offset 4, while
    54 is written to offset 12\. Reading *x* and *y* should be done from offset 4
    and offset 12, respectively. From 0 to 3, and from 8 to 11, we have extra space
    added via `paddingLayout()` that is ignored by the application. Attempting to
    read an `int` from these zones results in values of 0 (default values).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，跳过了填充区，23被写入偏移量4，而54被写入偏移量12。读取*x*和*y*应分别从偏移量4和偏移量12开始。从0到3，以及从8到11，我们通过`paddingLayout()`添加了额外的空间，这些空间被应用程序忽略。尝试从这些区域读取`int`会导致值为0（默认值）。
- en: These examples have nicely and smoothly introduced the *padding* notion but
    they are not that useful in real scenarios. Remember that we said earlier that
    padding is useful for aligning the members of a memory segment. In order to understand
    this, let’s briefly hook a few more players.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例很好地介绍了*填充*概念，但在实际场景中并不那么有用。记住我们之前说过，填充对于对齐内存段的成员是有用的。为了理解这一点，让我们简要地介绍一些更多的参与者。
- en: Hooking size, alignment, stride, and padding
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询大小、对齐、步长和填充
- en: Before continuing to work with padding, we need to cover some notions that are
    closely related to each other and work hand in hand with padding.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理填充之前，我们需要介绍一些彼此密切相关且与填充协同工作的概念。
- en: Hooking size
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步长挂钩
- en: By *size*, we mean the amount of memory (in bytes/bits) occupied by a memory
    layout (data type, C-like struct, C-like union, sequence layout, and so on). We
    know that a Java `int` consumes 4 bytes, a Java `byte` consumes 1 byte, a C-like
    struct consumes a number of bytes calculated as the sum of each property’s size,
    a C-like union consumes a number of bytes equal to the bigger property’s size,
    and so on.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 通过“大小”，我们指的是内存布局（数据类型、类似C的结构体、类似C的联合体、序列布局等）占用的内存量（以字节/位为单位）。我们知道Java的`int`占用4字节，Java的`byte`占用1字节，类似C的结构体占用每个属性大小的总和的字节数，类似C的联合体占用最大的属性大小的字节数，等等。
- en: 'We can easily query the size via `byteSize()`/`bitSize()`. Here are some examples:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`byteSize()`/`bitSize()`轻松查询大小。以下是一些示例：
- en: '[PRE88]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The `npStruct` and `wpStruct` were introduced earlier in this problem.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，之前介绍了`npStruct`和`wpStruct`。
- en: Hooking alignment
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对齐挂钩
- en: We know that each member layout starts in a memory segment at a specific address.
    We say that this address is *k*-byte-aligned if this address is a multiple of
    *k* (where *k* is any power of 2) or if this address is evenly divisible by *k*.
    Commonly, *k* is 1, 2, 4, or 8\. Alignment is useful for sustaining CPU performance,
    which reads data in chunks of *k* bytes instead of reading byte by byte. If the
    CPU attempts to access a member layout that is not correctly aligned, then we’ll
    get an `IllegalArgumentException:` *Misaligned access at address …*.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道每个成员布局都从特定地址的内存段开始。我们说这个地址是*k*-字节对齐的，如果这个地址是*k*（其中*k*是2的任何幂）的倍数，或者如果这个地址可以被*k*整除。通常，*k*是1、2、4或8。对齐对于维持CPU性能是有用的，它以*k*字节的块读取数据而不是逐字节读取。如果CPU尝试访问未正确对齐的成员布局，那么我们会得到一个`IllegalArgumentException`：*地址…的对齐访问错误*。
- en: In the case of basic data types (`int`, `double`, `float`, `byte`, `char`, and
    so on), the alignment value is equal to their size. For instance, an 8-bit (1-byte)
    Java `byte` has a size of 1 byte and needs to be aligned to 1 byte. A 32-bit (4
    bytes) Java `int` has a size of 4 bytes and needs to be aligned to 4 bytes. In
    the case of a C-like struct/union, the alignment is the maximum alignment of all
    its member layouts.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本数据类型（`int`、`double`、`float`、`byte`、`char`等）的情况下，对齐值等于它们的大小。例如，8位（1字节）的Java
    `byte`大小为1字节，需要对齐到1字节。32位（4字节）的Java `int`大小为4字节，需要对齐到4字节。在类似C的结构体/联合体的情况下，对齐是所有成员布局的最大对齐。
- en: 'We can easily query the alignment via `byteAlignment()`/`bitAlignment()`. Here
    are some examples:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`byteAlignment()`/`bitAlignment()`轻松查询对齐。以下是一些示例：
- en: '[PRE89]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: So, in a nutshell, a member layout should start with an address that must be
    at a multiple of its alignment. This applies to any kind of member layout (basic
    data type, C-like struct, C-like union, and so on).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，成员布局应该从一个地址开始，这个地址必须是其对齐方式的倍数。这适用于任何类型的成员布局（基本数据类型、类似C的结构体、类似C的联合体等）。
- en: Hooking stride
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步长挂钩
- en: The minimum byte distance between two member layouts is called a *stride*. The
    stride can be greater than or equal to the size. When we don’t face any alignment
    issues, the stride is equal to the size. Otherwise, the stride is computed by
    rounding up the size to the next multiple of the alignment. When the stride is
    greater than the size, it means that we also have some padding. If we have a C-like
    struct/union named `foo`, then the stride is the minimum byte distance between
    two `foo` objects.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 两个成员布局之间的最小字节距离称为步长。步长可以大于或等于大小。当我们不面对任何对齐问题时，步长等于大小。否则，步长是通过将大小向上舍入到对齐方式的下一个倍数来计算的。当步长大于大小，这意味着我们也有一些填充。如果我们有一个名为`foo`的类似C的结构体/联合体，那么步长是两个`foo`对象之间的最小字节距离。
- en: Hooking padding
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充挂钩
- en: So, padding is the amount of extra space that we need to add in order to preserve
    a valid alignment of the member layouts.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，填充是我们需要添加的额外空间，以保持成员布局的有效对齐。
- en: Don’t worry if you are a little bit confused about all these statements. We
    will clarify everything via a bunch of examples.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些陈述感到有些困惑，不要担心。我们将通过一系列示例来澄清一切。
- en: Adding implicit extra space (implicit padding) to validate alignment
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加隐式额外空间（隐式填充）以验证对齐
- en: 'Let’s consider the following simple example:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下简单的例子：
- en: '[PRE90]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We have a memory segment of 12 bytes and we have set an `int` of 4 bytes at
    offset 0 and a `char` of 2 bytes at offset 4 (immediately after the `int`). So,
    we still have 6 free bytes. Let’s assume that we want to set one more `int` of
    4 bytes after the `char`, `a`. What should the offset be? Our first thought may
    be that the proper offset is 6 since the `char` consumed 2 bytes:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个12字节的内存段，我们在偏移量0处设置了一个4字节的`int`，在偏移量4处设置了一个2字节的`char`（紧接在`int`之后）。因此，我们还有6个空闲字节。假设我们想在`char`之后设置一个额外的4字节的`int`，那么偏移量应该是多少？我们首先可能认为合适的偏移量是6，因为`char`消耗了2字节：
- en: '[PRE91]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'But if we do this, then the result is `java.lang.IllegalArgumentException:`
    *Misaligned access at the address: …*. We have a misaligned member layout (the
    2000 `int` value) because 6 is not evenly divisible by 4, which is the byte alignment
    of `int`. Check out the following figure:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们这样做，那么结果将是`java.lang.IllegalArgumentException:` *地址处的访问未对齐：…*。我们有一个未对齐的成员布局（2000个`int`值），因为6不能被4整除，而4是`int`的字节对齐。查看以下图示：
- en: '![Figure 7.20.png](img/B19665_07_17.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![图7.20.png](img/B19665_07_17.png)'
- en: 'Figure 7.17: Fixing the misaligned issue'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17：修复未对齐问题
- en: 'But what should we do? We know that the current offset is 6 and 6 is not evenly
    divisible by 4 (the `int` alignment). So, we are looking for the next offset that
    is evenly divisible by 4 and is the closest and greater than 6\. Obviously, this
    is 8\. So, before we set the 2000 `int` value, we need a padding of 2 bytes (16
    bits). This padding will be automatically added if we simply specify the offset
    8 instead of 6:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们应该怎么做呢？我们知道当前的偏移量是6，而6不能被4整除（`int`的对齐）。因此，我们正在寻找下一个能被4整除且最接近且大于6的偏移量。显然，这是8。所以，在我们设置2000个`int`值之前，我们需要2个字节的填充（16位）。如果我们简单地指定偏移量为8而不是6，则此填充将自动添加：
- en: '[PRE92]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Since our memory segment has a size of 12 bytes, we fit this `int` exactly on
    bytes 8, 9, 10, and 11\. A smaller size of the segment leads to an `IndexOutOfBoundsException:`
    *Out of bound access on segment MemorySegment*.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的内存段大小为12字节，我们将这个`int`正好放在字节8、9、10和11上。较小的段大小会导致`IndexOutOfBoundsException:`
    *在内存段MemorySegment上的越界访问*。
- en: Adding explicit extra space (explicit padding) to validate alignment
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加显式额外空间（显式填充）以验证对齐
- en: 'Let’s consider the following C-like struct (let’s denote this as *Case 1*):'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下类似于C的结构（我们将其称为*案例1*）：
- en: '[PRE93]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `product` size returned via `byteSize()` is 7 bytes (4 + 2 + 1). The `product`
    alignment returned via `byteAlignment()` is 4 (the greater alignment of 4, 2,
    and 1). The byte offset of each member layout returned by `byteOffset()` is as
    follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`byteSize()`返回的`product`大小是7字节（4 + 2 + 1）。通过`byteAlignment()`返回的`product`对齐是4（4、2和1中较大的对齐）。通过`byteOffset()`返回的每个成员布局的字节偏移量如下：
- en: '[PRE94]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If we represent this via a diagram, we obtain the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过图表表示，我们得到以下图示：
- en: '![Figure 7.21.png](img/B19665_07_18.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![图7.21.png](img/B19665_07_18.png)'
- en: 'Figure 7.18: The representation of the struct'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：结构的表示
- en: 'Everything looks fine, so we can go further. Now, let’s use the same struct,
    but we arrange the member layouts as follows (let’s denote this as *Case 2*):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很正常，所以我们可以继续。现在，让我们使用相同的结构，但我们将成员布局安排如下（我们将其称为*案例2*）：
- en: '[PRE95]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: First, we place the `energy` (`char`) at offset 0\. Since `energy` (`char`)
    consumes 2 bytes, it is followed by `sku` (`int`) at offset 2\. Since `sku` (`int`)
    consumes 4 bytes, it is followed by `weight` (`byte`). But is this the correct
    logic? As you can see in the following figure (left-hand side), this logic is
    incorrect, because we have an invalid alignment error at offset 2 for the `sku`
    (`int`).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`energy`（`char`）放在偏移量0处。由于`energy`（`char`）消耗2字节，它后面跟着偏移量2处的`sku`（`int`）。由于`sku`（`int`）消耗4字节，它后面跟着`weight`（`byte`）。但这种逻辑正确吗？正如你在以下图示（左侧）中可以看到的，这种逻辑是错误的，因为我们有无效的对齐错误，偏移量为2的`sku`（`int`）。
- en: '![Figure 7.22.png](img/B19665_07_19.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图7.22.png](img/B19665_07_19.png)'
- en: 'Figure 7.19: Incorrect/correct padding'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：不正确/正确的填充
- en: The alignment of `energy` (`char`) is 2, so it can start only on 0, 2, 4, ….
    Since `energy` (`char`) is the first, we start with it on offset 0\. Next, the
    alignment of `sku` (`int`) is 4, so it can start only on 0, 4, 8, …. That is why
    the start address of `sku` is at 4 and not at 2\. Finally, the alignment of `weight`
    (`byte`) is 1, so it can go after `sku` (`int`) at offset 8.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`energy`（`char`）的对齐是2，所以它只能从0、2、4、……开始。由于`energy`（`char`）是第一个，所以我们从偏移量0开始。接下来，`sku`（`int`）的对齐是4，所以它只能从0、4、8、……开始。这就是为什么`sku`的起始地址是4而不是2。最后，`weight`（`byte`）的对齐是1，所以它可以在`sku`（`int`）之后偏移量8处开始。'
- en: 'So, by following the alignment rules, we conclude that the size of `product`
    is 9, not 7\. At this point, we know that to align `sku` (`int`), we should add
    a padding of 2 bytes (16 bits) at offset 2, so let’s do it:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过遵循对齐规则，我们得出结论，`product`的大小是9，而不是7。在这个时候，我们知道为了对齐`sku`（`int`），我们应该在偏移量2处添加2个字节的填充（16位），所以让我们这样做：
- en: '[PRE96]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Next, let’s assume that we want to repeat this C-like struct 2 times (or *n*
    times). For this, we nest the struct in a sequence layout as follows (let’s denote
    this as *Case 3*):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们假设我们想要重复这个类似C的结构2次（或*n*次）。为此，我们将结构嵌套在序列布局中，如下所示（让我们将其称为*情况3*）：
- en: '[PRE97]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This time, the code fails with an exception as `IllegalArgumentException:`
    *Element layout size is not multiple of alignment*. What’s happening now? Well,
    the first struct instance lies out from offset 0 to offset 8, and, conforming
    to our code, the second struct lies out from offset 9 to offset 18, as in the
    following figure (top diagram):'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，代码因为异常`IllegalArgumentException:`而失败，*元素布局大小不是对齐的倍数*。现在发生了什么？好吧，第一个结构实例从偏移量0到偏移量8，并且，根据我们的代码，第二个结构实例从偏移量9到偏移量18，如下面的图所示（顶部图）：
- en: '![Figure 7.23.png](img/B19665_07_20.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.23.png](img/B19665_07_20.png)'
- en: 'Figure 7.20: Calculating stride'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：计算步长
- en: But this is not correct, because the second instance of the struct (and the
    third, fourth, and so on) doesn’t follow the alignment rules. The alignment of
    the struct is 4, so an instance of the struct should be at 0, 4, 8, 12, 16, …,
    but not at 9\. This means that we need to calculate the *stride*, which gives
    us the minimum byte distance between two member layouts – here, two instances
    of our struct.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是不正确的，因为结构的第二个实例（以及第三个、第四个等）没有遵循对齐规则。结构的对齐是4，所以结构实例应该在0、4、8、12、16、……，而不是在9。这意味着我们需要计算步长，这给出了两个成员布局之间的最小字节距离——在这里，是我们结构的两个实例。
- en: 'We have that the size of the struct instance is 9 and its alignment is 4\.
    So, we need to find the offset evenly divisible by 4 that is greater and closest
    to 9\. This is 12\. Since the *stride* is 12, it means that the second instance
    of the struct starts at offset 12\. We need to add a padding of 3 (12-9) bytes:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道结构实例的大小是9，其对齐是4。因此，我们需要找到一个能被4整除的偏移量，它大于9且最接近9。这是12。由于步长是12，这意味着结构的第二个实例从偏移量12开始。我们需要添加3（12-9）字节的填充：
- en: '[PRE98]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Done! As you can see, the order of member layouts counts a lot. By being aware
    of the size, alignment, stride, and padding, we can optimize the memory allocation
    by simply arranging the member layouts in a proper order that requires 0 or minimum
    padding.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！正如你所见，成员布局的顺序非常重要。通过了解大小、对齐、步长和填充，我们可以通过简单地按正确的顺序排列成员布局来优化内存分配，这样就需要0或最小的填充。
- en: In the bundled code, you can find more examples of permutating the member layout
    of our struct.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到更多关于排列我们结构成员布局的示例。
- en: 156\. Copying and slicing memory segments
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 156. 复制和切片内存段
- en: 'Let’s consider the following memory segment (`arena` is an instance of `Arena`):'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下内存段（`arena` 是 `Arena` 的一个实例）：
- en: '[PRE99]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Next, let’s see how we can copy the content of this segment.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何复制这个段的全部内容。
- en: Copying a segment
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制一个段
- en: 'We can make a copy of this memory segment via `copyFrom(MemorySegment src)`
    as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`copyFrom(MemorySegment src)`来复制这个内存段，如下所示：
- en: '[PRE100]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We can easily see if the data was copied as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地看到数据是否被复制如下：
- en: '[PRE101]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This is a bulk operation that creates a full copy of the given memory segment.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个批量操作，它创建给定内存段的全拷贝。
- en: Copying a part of the segment into another segment (1)
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将段的一部分复制到另一个段中（1）
- en: 'Let’s suppose that we want to copy only a part of `srcSegment` into another
    segment (`dstSegment`). For instance, if we wanted to copy the last 8 elements
    ([22, 33, -1, -1, -1, -1, -1, 4]) from `srcSegment` to `dstSegment`, we’d start
    by allocating the `dstSegment` accordingly:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想将`srcSegment`的一部分复制到另一个段（`dstSegment`）中。例如，如果我们想将`srcSegment`的最后8个元素（[22,
    33, -1, -1, -1, -1, -1, 4]）复制到`dstSegment`中，我们首先会相应地分配`dstSegment`：
- en: '[PRE102]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Next, we call the `copy(MemorySegment srcSegment, long srcOffset, MemorySegment
    dstSegment, long dstOffset, long bytes)` method as in the following figure:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment,
    long dstOffset, long bytes)`方法，如图所示：
- en: '![Figure 7.24 - Copy.png](img/B19665_07_21.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![图7.24 - 复制.png](img/B19665_07_21.png)'
- en: 'Figure 7.21: Copying a part of a segment into another segment (1)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21：将段的一部分复制到另一个段中（1）
- en: 'So, we specify the source segment as `srcSsegment`, the source offset as 32
    (skip the first 8 elements), the destination segment as `dstSegment`, the destination
    offset as 0, and the number of bytes to be copied as 32 (the last 8 elements are
    copied):'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们指定源段为`srcSsegment`，源偏移量为32（跳过前8个元素），目标段为`dstSegment`，目标偏移量为0，要复制的字节数为32（复制最后8个元素）：
- en: '[PRE103]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Practically, we copied half of the `srcSegment` to `dstSegment`.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将`srcSegment`的一半复制到了`dstSegment`中。
- en: Copying a segment into an on-heap array
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将段复制到堆内存数组中
- en: 'Let’s suppose that we want to copy only a part of `srcSegment` into an on-heap
    Java regular array (`dstArray`). For instance, if we wanted to copy the last 8
    elements ([22, 33, -1, -1, -1, -1, -1, 4]) from `srcSegment` to `dstArray`, we’d
    start by creating the `dstArray` accordingly:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想将`srcSegment`的一部分复制到堆内存Java常规数组（`dstArray`）中。例如，如果我们想将`srcSegment`的最后8个元素（[22,
    33, -1, -1, -1, -1, -1, 4]）复制到`dstArray`中，我们首先会相应地创建`dstArray`：
- en: '[PRE104]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Next, we’d call `copy(MemorySegment srcSegment, ValueLayout srcLayout, long
    srcOffset, Object dstArray, int dstIndex, int elementCount)`, as in the following
    figure:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调用`copy(MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset,
    Object dstArray, int dstIndex, int elementCount)`，如图所示：
- en: '![Figure 7.24 - Copy - Copy.png](img/B19665_07_22.png)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图7.24 - 复制 - 复制.png](img/B19665_07_22.png)'
- en: 'Figure 7.22: Copying a segment into an on-heap array'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22：将段复制到堆内存数组中
- en: 'So, we specify the source segment as `srcSegment`, the source layout as `JAVA_INT`,
    the source offset as 32 (skip the first 8 elements), the destination array as
    `dstArray`, the destination array index as 0, and the number of elements to be
    copied as 8:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们指定源段为`srcSegment`，源布局为`JAVA_INT`，源偏移量为32（跳过前8个元素），目标数组为`dstArray`，目标数组索引为0，要复制的元素数量为8：
- en: '[PRE105]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Practically, we copied half of the off-heap `srcSegment` to the on-heap `dstArray`.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将非堆内存`srcSegment`的一半复制到了堆内存`dstArray`中。
- en: Copying an on-heap array into a segment
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将堆内存数组复制到段中
- en: 'Let’s suppose that we want to copy an on-heap array (or a part of it) into
    a segment. The given on-heap array is `srcArray`:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将堆内存数组（或其一部分）复制到段中。给定的堆内存数组是`srcArray`：
- en: '[PRE106]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The destination segment can hold 16 integer values:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 目标段可以容纳16个整数值：
- en: '[PRE107]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Next, we want to overwrite the last 8 elements from `dstSegment` with the elements
    from `srcArray`, while the first elements remain 0\. For this, we call `copy(Object
    srcArray, int srcIndex, MemorySegment dstSegment, ValueLayout dstLayout, long
    dstOffset, int elementCount)`, as in the following figure:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要用`srcArray`中的元素覆盖`dstSegment`的最后8个元素，而前面的元素保持为0。为此，我们调用`copy(Object
    srcArray, int srcIndex, MemorySegment dstSegment, ValueLayout dstLayout, long
    dstOffset, int elementCount)`，如图所示：
- en: '![Figure 7.24 - Copy - Copy - Copy.png](img/B19665_07_23.png)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![图7.24 - 复制 - 复制 - 复制.png](img/B19665_07_23.png)'
- en: 'Figure 7.23: Copying an on-heap array into a segment'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23：将堆内存数组复制到段中
- en: 'So, we specify the source array as `srcArray`, the source index as 0, the destination
    segment as `dstSegment`, the destination layout as `JAVA_INT`, the destination
    offset as 32 (skip the first 8 elements), and the number of elements to be copied
    as 8:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们指定源数组为`srcArray`，源索引为0，目标段为`dstSegment`，目标布局为`JAVA_INT`，目标偏移量为32（跳过前8个元素），要复制的元素数量为8：
- en: '[PRE108]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Practically, we copied the on-heap `srcArray` as the second half of the off-heap
    `destSegment`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将堆内存`srcArray`作为非堆内存`destSegment`的第二半进行复制。
- en: Copying a part of the segment into another segment (2)
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将段的一部分复制到另一个段中（2）
- en: 'Let’s consider the `srcSegment` (1, 2, 3, 4, -1, -1, -1, 52, 22, 33, -1, -1,
    -1, -1, -1, 4) and the `dstSegment` (0, 0, 0, 0, 0, 0, 0, 0, 10, 44, 2, 6, 55,
    65, 7, 89) from the previous sections. We want to copy the last 8 elements from
    `srcSegment` as the first 8 elements from `dstSegment` (22, 33, -1, -1, -1, -1,
    -1, 4, 10, 44, 2, 6, 55, 65, 7, 89). We know that this can be done via `copy(MemorySegment
    srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes)`,
    as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑前几节中的`srcSegment`（1, 2, 3, 4, -1, -1, -1, 52, 22, 33, -1, -1, -1, -1, -1,
    4）和`dstSegment`（0, 0, 0, 0, 0, 0, 0, 0, 10, 44, 2, 6, 55, 65, 7, 89）。我们希望将`srcSegment`的最后8个元素（22,
    33, -1, -1, -1, -1, -1, 4）复制为`dstSegment`的前8个元素（10, 44, 2, 6, 55, 65, 7, 89）。我们知道这可以通过`copy(MemorySegment
    srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes)`方法实现，如下所示：
- en: '[PRE109]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Alternatively, we can use `copy(MemorySegment srcSegment, ValueLayout srcElementLayout,
    long srcOffset, MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,
    long elementCount)`, as in the following figure:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long
    srcOffset, MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,
    long elementCount)`，如下图所示：
- en: '![Figure 7.24 - Copy - Copy (2).png](img/B19665_07_24.png)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![图7.24 - 复制 - 复制（2）.png](img/B19665_07_24.png)'
- en: 'Figure 7.24: Copying a part of a segment into another segment (2)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24：将段的一部分复制到另一个段（2）
- en: 'So, we specify the source segment as `srcSegment`, the source layout as `JAVA_INT`,
    the source offset as 32 (skip the first 8 elements), the destination segment as
    `dstSegment`, the destination layout as `JAVA_INT`, the destination offset as
    0, and the number of elements to be copied as 8:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们指定源段为`srcSegment`，源布局为`JAVA_INT`，源偏移量为32（跳过前8个元素），目标段为`dstSegment`，目标布局为`JAVA_INT`，目标偏移量为0，要复制的元素数量为8：
- en: '[PRE110]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Feel free to test this method with different value layouts. Next, let’s talk
    about slicing.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 随意测试这个方法与不同的值布局。接下来，让我们谈谈切片。
- en: Slicing a segment
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片一个段
- en: 'Next, let’s suppose that we want to slice the segment containing (1, 2, 3,
    4, -1, -1, -1, 52, 22, 33, -1, -1, -1, -1, -1, 4) into three separate `IntVector`
    instances the values that are not -1 without using the `copy()` methods. So, `v1`
    should contain [1, 2, 3, 4], `v2` should contain [52, 22, 33, 0], and `v3` should
    contain [4, 0, 0, 0]. Since an `int` needs 4 bytes, and we have a maximum of 4
    `int` values, we go for `SPECIES_128` (4 `int` values x 4 bytes = 16 bytes x 8
    bits = 128 bits):'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们想要将包含（1, 2, 3, 4, -1, -1, -1, 52, 22, 33, -1, -1, -1, -1, -1, 4）的段切割成三个独立的`IntVector`实例，而不使用`copy()`方法。因此，`v1`应包含[1,
    2, 3, 4]，`v2`应包含[52, 22, 33, 0]，而`v3`应包含[4, 0, 0, 0]。由于一个`int`需要4个字节，并且我们最多有4个`int`值，所以我们选择`SPECIES_128`（4个`int`值
    x 4字节 = 16字节 x 8位 = 128位）：
- en: '[PRE111]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Next, we need to slice the memory segment in order to eliminate the values
    of -1\. This can be accomplished via the `asSlice(long offset)` and `asSlice(long
    offset, long newSize)` methods. The first argument represents the starting offset.
    The second argument represents the size of the new memory segment. The following
    figure helps us to clear this up:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要切片内存段以消除-1的值。这可以通过`asSlice(long offset)`和`asSlice(long offset, long
    newSize)`方法实现。第一个参数表示起始偏移量。第二个参数表示新内存段的大小。以下图示有助于我们澄清这一点：
- en: '![Figure 7.24.png](img/B19665_07_25.png)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![图7.24.png](img/B19665_07_25.png)'
- en: 'Figure 7.25: Slicing a memory segment'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25：切片内存段
- en: 'The first memory segment starts at offset 0 and ends at offset 16, so it contains
    4 `int` values of 4 bytes (`asSlice(0, 16)`). The second memory segment starts
    at offset 28 and ends at offset 40, so it contains 3 `int` values of 4 bytes (`asSlice(28,
    12)`). Finally, the third memory segment starts at offset 60 and ends at the end
    of the segment, so it contains a single `int` value of 4 bytes (`asSlice(60)`
    or `asSlice(60, 4)`). The resulting code is listed here:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个内存段从偏移量0开始，到偏移量16结束，因此它包含4个4字节的`int`值（`asSlice(0, 16)`）。第二个内存段从偏移量28开始，到偏移量40结束，因此它包含3个4字节的`int`值（`asSlice(28,
    12)`）。最后，第三个内存段从偏移量60开始，到段末尾结束，因此它包含一个4字节的`int`值（`asSlice(60)`或`asSlice(60, 4)`）。相应的代码如下所示：
- en: '[PRE112]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Done! Of course, we can slice a memory segment in regular Java arrays as well.
    Here you go:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！当然，我们也可以在常规Java数组中切片内存段。如下所示：
- en: '[PRE113]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The `toArray()` method returns a Java regular array (here, `int[]`) from the
    sliced memory segment.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`toArray()`方法从切片内存段返回一个Java常规数组（此处为`int[]`）。'
- en: Using asOverlappingSlice()
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用asOverlappingSlice()
- en: 'The `asOverlappingSlice(MemorySegment other)` method returns a slice of this
    segment that overlaps the given segment as an `Optional<MemorySegment>`. Consider
    the following segment (`arena` is an instance of `Arena`):'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`asOverlappingSlice(MemorySegment other)` 方法返回一个重叠给定段作为 `Optional<MemorySegment>`
    的这个段的切片。考虑以下段（`arena` 是 `Arena` 的一个实例）：'
- en: '[PRE114]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'And, we slice it at offset 12, so at value 4:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在偏移量 12 处切片，所以值为 4：
- en: '[PRE115]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Finally, we call `asOverlappingSlice()` to see where the overlapping occurs:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `asOverlappingSlice()` 来查看重叠发生在哪里：
- en: '[PRE116]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The resulting array is [4, 6, 8, 4, 5, 3].
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数组是 [4, 6, 8, 4, 5, 3]。
- en: Using segmentOffset()
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 segmentOffset()
- en: 'The `segmentOffset(MemorySegment other)` returns the offset of the given segment
    (`other`) relative to this segment. Consider the following segment (`arena` is
    an instance of `Arena`):'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`segmentOffset(MemorySegment other)` 返回给定段（`other`）相对于这个段的偏移量。考虑以下段（`arena`
    是 `Arena` 的一个实例）：'
- en: '[PRE117]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'And, we slice it at offset 16, so at value 6:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在偏移量 16 处切片，所以值为 6：
- en: '[PRE118]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Next, we call `segmentOffset()` to find out at what offset in `segment` we
    have `subsegment`:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `segmentOffset()` 来找出在 `segment` 中 `subsegment` 的偏移量：
- en: '[PRE119]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: You can practice all these examples in the bundled code. Challenge yourself
    to explore `MemorySegment.mismatch()` further.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中练习所有这些示例。挑战自己进一步探索 `MemorySegment.mismatch()`。
- en: 157\. Tackling the slicing allocator
  id: totrans-535
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 157. 解决切片分配器问题
- en: 'Let’s consider the following three Java regular `int` arrays:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下三个 Java 常规 `int` 数组：
- en: '[PRE120]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Next, we want to allocate a memory segment to each of these arrays. A straightforward
    approach relies on `Arena.allocateArray()` introduced in *Problem 150*:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要为这些数组中的每一个分配一个内存段。一个直接的方法依赖于在 *问题 150* 中引入的 `Arena.allocateArray()`：
- en: '[PRE121]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This approach allocates enough memory to accommodate each of the given arrays.
    But, sometimes, we want to allocate only a certain amount of memory. If this fixed
    amount is not enough, then we want to tackle the problem differently. For this,
    we can rely on a `java.lang.foreign.SegmentAllocator`. Of course, there are many
    other scenarios when `SegmentAllocator` is useful, but for now, let’s tackle the
    following one.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法为每个给定的数组分配足够的内存。但是，有时我们只想分配一定量的内存。如果这个固定量不足，那么我们想以不同的方式解决这个问题。为此，我们可以依赖
    `java.lang.foreign.SegmentAllocator`。当然，还有许多其他场景下 `SegmentAllocator` 都很有用，但现在，让我们解决以下问题。
- en: 'Let’s assume that we allow allocating a fixed size of 10 * 4 = 40 bytes. This
    is a bulk amount of memory that should be sliced between our three arrays. First,
    we allocate these 40 bytes as follows:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们允许分配固定大小 10 * 4 = 40 字节。这是一大块内存，应该在三个数组之间切片。首先，我们这样分配这些 40 字节：
- en: '[PRE122]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Next, we use the `allocator` to allocate a slice from these 40 bytes to each
    array. The first array (`arr1`) has 6 values, so the memory segment gets 6 * 4
    = 24 bytes:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `allocator` 从这些 40 字节中为每个数组分配一个切片。第一个数组 (`arr1`) 有 6 个值，所以内存段获得 6 *
    4 = 24 字节：
- en: '[PRE123]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The segment allocator has available 40 – 24 = 16 more bytes. The second array
    (`arr2`) has 3 values, so the memory segment gets 3 * 4 = 12 bytes:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 分段分配器还可用 40 - 24 = 16 个额外的字节。第二个数组 (`arr2`) 有 3 个值，所以内存段获得 3 * 4 = 12 字节：
- en: '[PRE124]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The segment allocator has available 16 – 12 = 4 more bytes. The third array
    (`arr3`) has 5 values, so it needs a memory segment of 5 * 4 = 20 bytes, but only
    4 are available. This causes an `IndexOutOfBoundsException` and gives us the control
    to handle this corner case:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 分段分配器还可用 16 - 12 = 4 个额外的字节。第三个数组 (`arr3`) 有 5 个值，因此它需要一个 5 * 4 = 20 字节的内存段，但只有
    4 个可用。这导致 `IndexOutOfBoundsException` 并给我们控制权来处理这个特殊情况：
- en: '[PRE125]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'A possible approach to avoid this `IndexOutOfBoundsException` may consist of
    giving more memory to the segment allocator. In this case, we need to give it
    16 more bytes, so we can express it as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这个 `IndexOutOfBoundsException` 的一个可能方法可能是给分段分配器更多的内存。在这种情况下，我们需要给它 16 个额外的字节，所以我们可以这样表达：
- en: '[PRE126]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Of course, you don’t have to write 10 * 4 + 4 * 4\. You can say 14 * 4, or just
    56\. Basically, our three arrays have 14 elements of 4 bytes each, and initially,
    we covered only 10 of them. Next, we increased the memory to cover the remaining
    4 as well.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必写 10 * 4 + 4 * 4。你可以说是 14 * 4，或者只是 56。基本上，我们的三个数组有 14 个 4 字节的元素，最初我们只覆盖了其中的
    10 个。接下来，我们增加了内存以覆盖剩余的 4 个。
- en: 158\. Introducing the slice handle
  id: totrans-552
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 158. 引入切片句柄
- en: 'Let’s suppose that we have the following nested model (10 sequences of 5 `double`
    values each):'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下嵌套模型（每个有 5 个 `double` 值的 10 个序列）：
- en: '[PRE127]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Next, we define a `VarHandle` via `PathElement` and we populate this model
    accordingly with some random data:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过`PathElement`定义一个`VarHandle`，并相应地在这个模型中填充一些随机数据：
- en: '[PRE128]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'OK, you should be familiar with this code, so nothing new so far. Next, we
    plan to extract from this model the third sequence from 10 containing 5 sequences
    of `double` values. We can accomplish this via the `sliceHandle(PathElement...
    elements)` method, which returns a `java.lang.invoke.MethodHandle`. This `MethodHandle`
    takes a memory segment and returns a slice of it corresponding to the selected
    memory layout. Here is the code for our scenario:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你应该熟悉这段代码，到目前为止没有什么新的内容。接下来，我们计划从这个模型中提取包含5个`double`值序列的第三个序列。我们可以通过`sliceHandle(PathElement...
    elements)`方法来完成这个任务，它返回一个`java.lang.invoke.MethodHandle`。这个`MethodHandle`接受一个内存段，并返回一个与所选内存布局相对应的切片。以下是我们的场景代码：
- en: '[PRE129]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Done! Now, you know how to slice out a certain memory layout from the given
    memory segment.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，你知道如何从给定的内存段中切片出特定的内存布局。
- en: 159\. Introducing layout flattening
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 159. 引入布局扁平化
- en: 'Let’s suppose that we have the following nested model (the exact same model
    as in *Problem 158*):'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下嵌套模型（与*问题158*中的模型完全相同）：
- en: '[PRE130]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Next, we define a `VarHandle` via `PathElement` and we populate this model accordingly
    with some random data in a memory segment named `segment` (you can see the code
    listed in *Problem 158*).
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过`PathElement`定义一个`VarHandle`，并相应地在这个名为`segment`的内存段中填充一些随机数据（你可以在*问题158*中看到列出的代码）。
- en: 'Our goal is to take this nested model and obtain a flat model. So, instead
    of having 10 sequences of 5 `double` values each, we want one sequence of 50 `double`
    values. This can be achieved via the `flatten()` method, as follows:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将这个嵌套模型转换为平面模型。所以，我们希望有一个包含50个`double`值的序列，而不是10个序列，每个序列包含5个`double`值。这可以通过`flatten()`方法实现，如下所示：
- en: '[PRE131]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Notice the `PathElement`, which traverses a single sequence. This is the sequence
    that resulted after the flatten operation. We can go further and allocate another
    memory segment for this sequence and set new data:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`PathElement`，它遍历单个序列。这是扁平化操作后的序列。我们可以进一步分配另一个内存段给这个序列，并设置新的数据：
- en: '[PRE132]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Next, let’s see how we can reshape a memory layout.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何重塑内存布局。
- en: 160\. Introducing layout reshaping
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 160. 引入布局重塑
- en: 'Let’s suppose that we have the following nested model (the exact same model
    as in *Problem 158*):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下嵌套模型（与*问题158*中的模型完全相同）：
- en: '[PRE133]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Next, we define a `VarHandle` via `PathElement` and we populate this model accordingly
    with some random data (you can see the code listed in *Problem 158*).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过`PathElement`定义一个`VarHandle`，并相应地在这个模型中填充一些随机数据（你可以在*问题158*中看到列出的代码）。
- en: 'Our goal is to reshape this model to look as follows:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将这个模型重塑成以下样子：
- en: '[PRE134]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'So, instead of having 10 sequences of 5 `double` values each, we want 25 sequences
    of 2 `double` values each. In order to accomplish this reshaping goal, we can
    rely on the `reshape(long... elementCounts)` method. This method takes the elements
    of this sequence layout and re-arranges them into a multi-dimensional sequence
    layout conforming to the given list of element counts per sequence. So, in our
    case, we do it as follows:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望有25个序列，每个序列包含2个`double`值，而不是10个序列，每个序列包含5个`double`值。为了实现这个重塑目标，我们可以依赖`reshape(long...
    elementCounts)`方法。这个方法接受这个序列布局的元素，并将它们重新排列成符合给定元素计数列表的多维序列布局。所以，在我们的情况下，我们这样做：
- en: '[PRE135]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: You can see the complete example in the bundled code.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中看到完整的示例。
- en: 161\. Introducing the layout spreader
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 161. 引入布局展开器
- en: 'Let’s suppose that we have the following nested model (the exact same model
    as in *Problem 158*):'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下嵌套模型（与*问题158*中的模型完全相同）：
- en: '[PRE136]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Next, we define a `VarHandle` via `PathElement` and we populate this model accordingly
    with some random data in a memory segment named `segment` (you can see the code
    listed in *Problem 158*).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过`PathElement`定义一个`VarHandle`，并相应地在这个名为`segment`的内存段中填充一些随机数据（你可以在*问题158*中看到列出的代码）。
- en: 'Next, let’s assume that we want to extract the third `double` value from the
    seventh sequence (count starts from 0). Among the approaches, we can rely on `sliceHandle()`
    introduced in *Problem 158,* as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们想要从第七个序列中提取第三个`double`值（计数从0开始）。在众多方法中，我们可以依赖在*问题158*中引入的`sliceHandle()`，如下所示：
- en: '[PRE137]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Another approach consists of using an *array-spreading* method handle. In other
    words, by calling the `asSpreader(Class<?> arrayType, int arrayLength)` method,
    we can obtain a *spreader-array* that contains the positional arguments that we
    want to pass over and has a length equal to the given `arrayLength`. Since we
    have two pass-over `long` arguments (7L and 3L), we need a `long[]` array of length
    2:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过使用一个 *数组传播* 方法句柄。换句话说，通过调用 `asSpreader(Class<?> arrayType, int arrayLength)`
    方法，我们可以获得一个包含我们想要传递的位置参数的 *传播数组*，其长度等于给定的 `arrayLength`。由于我们有两个传递的 `long` 参数（7L
    和 3L），我们需要一个长度为 2 的 `long[]` 数组：
- en: '[PRE138]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: You may also be interested in `asCollector(Class<?> arrayType, int arrayLength)`,
    which is basically the opposite of `asSpreader()`. You give a list of arguments
    and this method collects them in an *array-collecting*.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还对 `asCollector(Class<?> arrayType, int arrayLength)` 感兴趣，这基本上是 `asSpreader()`
    的反义词。你提供一个参数列表，这个方法会将它们收集在一个 *数组收集器* 中。
- en: 162\. Introducing the memory segment view VarHandle
  id: totrans-587
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 162. 介绍内存段视图 VarHandle
- en: 'Let’s consider the following simple memory segment for storing an int (`arena`
    is an instance of `Arena`):'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下简单的内存段来存储一个 int (`arena` 是 `Arena` 的一个实例)：
- en: '[PRE139]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'We know that we can create a `VarHandle` via `PathElement`:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们可以通过 `PathElement` 创建一个 `VarHandle`：
- en: '[PRE140]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Or, via `arrayElementVarHandle()`:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过 `arrayElementVarHandle()`：
- en: '[PRE141]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The `MethodHandles.memorySegmentViewVarHandle(ValueLayout layout)` is another
    approach for creating a `VarHandle` that can be used to access a memory segment.
    The returned `VarHandle` perceives/views the content of the memory segment as
    a sequence of the given `ValueLayout`. In our case, the code looks as follows:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`MethodHandles.memorySegmentViewVarHandle(ValueLayout layout)` 是创建可以用于访问内存段的
    `VarHandle` 的另一种方法。返回的 `VarHandle` 将内存段的内容视为给定 `ValueLayout` 的序列。在我们的例子中，代码如下：'
- en: '[PRE142]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Next, we can rely on `insertCoordinates(VarHandle target, int pos, Object...
    values)` to specify the set of *bound coordinates* before the `VarHandle` is actually
    invoked. In other words, the returned `VarHandle` will expose fewer Coordinate
    Types (CTs) than the given `target`.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以依靠 `insertCoordinates(VarHandle target, int pos, Object... values)`
    来指定在 `VarHandle` 实际调用之前的一组 *绑定坐标*。换句话说，返回的 `VarHandle` 将暴露比给定的 `target` 更少的坐标类型（CTs）。
- en: 'In our example, the `target` argument (invoked after inserting the set of *bound
    coordinates*) is `viewhandle`. The position of the first coordinate is 1, and
    we have a single *bound coordinate* representing the offset 0 of type `long`:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`target` 参数（在插入一组 *绑定坐标* 之后调用）是 `viewhandle`。第一个坐标的位置是 1，我们有一个表示类型 `long`
    的偏移量 0 的单个 *绑定坐标*：
- en: '[PRE143]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Now, when we call the popular `VarHandle.set/get(Object...)` on the returned
    `VarHandler`, the incoming coordinate values are automatically joined with the
    given *bound coordinate* values. The result is passed to the target `VarHandle`:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们调用流行的 `VarHandle.set/get(Object...)` 在返回的 `VarHandler` 上时，传入的坐标值会自动与给定的
    *绑定坐标* 值连接。结果传递给目标 `VarHandle`：
- en: '[PRE144]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Done! Now, you know three ways to create a `VarHandle` for dereferencing a memory
    segment.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，你知道了创建用于解引用内存段的 `VarHandle` 的三种方法。
- en: 163\. Streaming memory segments
  id: totrans-602
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 163. 流式传输内存段
- en: Combining the Java Stream API with memory segments can be achieved via the `elements(MemoryLayout
    elementLayout)` method. This method gets an element layout and returns a `Stream<MemorySegment>`,
    which is a sequential stream over disjointed slices in this segment. The stream
    size matches the size of the specified layout.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `elements(MemoryLayout elementLayout)` 方法将 Java Stream API 与内存段结合使用可以实现。此方法获取一个元素布局，并返回一个
    `Stream<MemorySegment>`，它在这个段中的非重叠切片上是一个顺序流。流的大小与指定布局的大小相匹配。
- en: 'Let’s consider the following memory layout:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下内存布局：
- en: '[PRE145]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Next, we declare two `VarHandle` and set some data:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明两个 `VarHandle` 并设置一些数据：
- en: '[PRE146]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Let’s assume that we want to sum up all data. For this, we can do the following:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要汇总所有数据。为此，我们可以这样做：
- en: '[PRE147]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Or, we can simply pass the proper layout and even empower parallel processing:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以简单地传递适当的布局，甚至启用并行处理：
- en: '[PRE148]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Both approaches return 28 = 5 + 9 + 6 + 8.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都返回 28 = 5 + 9 + 6 + 8。
- en: 'How about summing only the values from the first (*x*, *y*) pair? For this,
    we have to slice the layout corresponding to the first (*x*, *y*) pair via `sliceHandle()`
    – we introduced this method in *Problem 151*:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 那么只从第一个 (*x*, *y*) 对中汇总值怎么样？为此，我们必须通过 `sliceHandle()` 切片与第一个 (*x*, *y*) 对对应的布局——我们在
    *问题 151* 中介绍了这个方法：
- en: '[PRE149]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Next, we slice the segment of the first (*x*, *y*) pair (if we replace 0 with
    1, then we obtain the segment of the second (*x*, *y*) pair):'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们切割第一个（*x*，*y*）对的段（如果我们用1替换0，那么我们得到第二个（*x*，*y*）对的段）：
- en: '[PRE150]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'And, we use it to calculate the needed sum:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用它来计算所需的和：
- en: '[PRE151]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The result is clear, 14 = 5 + 9.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 结果很清晰，14 = 5 + 9。
- en: 'How about summing *y* from the first pair with the second pair (*x*, *y*)?
    For this, we can slice the proper segment via `asSlice()` – we introduced this
    method in *Problem 156*:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将第一对*y*与第二对（*x*，*y*）相加？为此，我们可以通过`asSlice()`切割适当的段——我们在*问题156*中介绍了这个方法：
- en: '[PRE152]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The `asSlice(4)` simply skips the first *x* since this is stored at offset 0
    and consumes 4 bytes. From offset 4 to the end, we have the first *y*, and the
    second pair (*x*, *y*). So, the result is 23 = 9 + 6 + 8.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '`asSlice(4)`简单地跳过了第一个*x*，因为这是存储在偏移量0处，消耗了4个字节。从偏移量4到末尾，我们有第一个*y*，以及第二对（*x*，*y*）。所以，结果是23
    = 9 + 6 + 8。'
- en: Notice that, this time, we have used a shared arena (`Arena.ofShared()`). This
    is needed for parallel computations since the segment should be shared between
    multiple threads.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这次，我们使用了共享区域（`Arena.ofShared()`）。这是必要的，因为段应该在多个线程之间共享。
- en: Done! Feel free to challenge yourself to solve more such scenarios.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！请随意挑战自己解决更多此类场景。
- en: 164\. Tackling mapped memory segments
  id: totrans-625
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 164. 解决映射内存段问题
- en: We know that a computer has limited physical memory, referred to as RAM. Common
    sense, though, tells us that we cannot allocate a memory segment larger than the
    available RAM (this should lead to an out-of-memory error). But this is not quite
    true! Here is where *mapped memory segments* come into the discussion.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道计算机有有限的物理内存，这被称为RAM。然而，常识告诉我们，我们不能分配比可用RAM更大的内存段（这应该导致内存不足错误）。但这并不完全正确！这正是*映射内存段*进入讨论的地方。
- en: The mapped memory segment represents virtual memory and can be huge (gigabytes,
    terabytes, or whatever you may think of). This virtual memory is actually memory
    mapped by files or shortly *memory-mapped files* (a file can be from a regular
    file to any other kind of file descriptor).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的内存段代表虚拟内存，可以非常大（千兆字节、太字节，或者你可以想到的任何大小）。这个虚拟内存实际上是文件或简称为*内存映射文件*（一个文件可以是普通文件，也可以是任何其他类型的文件描述符）映射的。
- en: Obviously, at any time, only a part of the virtual memory lives in the real
    memory. This is why we can allocate terabytes of virtual memory on a laptop with
    much less real RAM. Practically, a portion of missing mapped memory is loaded
    on demand in the real RAM. While loading, the process operating on this memory
    is temporarily suspended.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在任何时候，只有虚拟内存的一部分存在于实际内存中。这就是为什么我们可以在拥有较少实际RAM的笔记本电脑上分配TB级的虚拟内存。实际上，缺失的映射内存部分会在需要时加载到实际RAM中。在加载过程中，操作此内存的进程会暂时挂起。
- en: The goal of mapped memory files is to drastically reduce the I/O operations.
    The standard read/write operations rely on copying data into buffers, while mapped
    files put the file data directly into the process address space. This is much
    faster and sharable across processes.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 映射内存文件的目标是极大地减少I/O操作。标准的读写操作依赖于将数据复制到缓冲区，而映射文件将文件数据直接放入进程地址空间。这要快得多，并且可以在进程间共享。
- en: 'In Java, we can set a mapped memory file via the `java.nio.channels.FileChannel`
    API, more precisely, via the `map(MapMode mode, long offset, long size, Arena
    arena)` method. Here is an example of setting a mapped memory file of 1 MB and
    writing/reading some text into it (feel free to try it on your machine for a file
    that is 1 GB (1,073,741,824 bytes) or larger:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们可以通过`java.nio.channels.FileChannel` API设置映射内存文件，更确切地说，通过`map(MapMode
    mode, long offset, long size, Arena arena)`方法。以下是一个设置1 MB映射内存文件并写入/读取一些文本到其中的示例（你可以在你的机器上尝试一个1
    GB（1,073,741,824字节）或更大的文件）：
- en: '[PRE153]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: When a file contains a significant number of empty bytes (so-called holes, `\x00`)
    it becomes a good candidate to become a *sparse* file. In a sparse file, these
    holes are no longer kept on the storage device, so they no longer consume physical
    memory. This is an attempt at using memory more efficiently and stops consuming
    physical memory with zero-byte blocks. Each operating system has its own way of
    handling sparse files, but generally speaking, the zero-byte blocks are simply
    reduced to some meaningful metadata useful for dynamically generating them. For
    more details and a useful diagram, consider this Wikipedia article ([https://en.wikipedia.org/wiki/Sparse_file](https://en.wikipedia.org/wiki/Sparse_file)).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个文件包含大量空字节（所谓的空洞，`\x00`）时，它就成为一个很好的候选稀疏文件。在稀疏文件中，这些空洞不再保留在存储设备上，因此不再消耗物理内存。这是尝试更有效地使用内存并停止使用零字节块消耗物理内存的一种尝试。每个操作系统都有自己处理稀疏文件的方式，但一般来说，零字节块被简化为一些有用的元数据，这些元数据对于动态生成它们是有意义的。有关更多详细信息和一个有用的图表，请考虑这篇维基百科文章（[https://en.wikipedia.org/wiki/Sparse_file](https://en.wikipedia.org/wiki/Sparse_file)）。
- en: 'In Java, we can create a sparse file by adding the `java.nio.file.StandardOpenOption.SPARSE`
    option to the list of options next to `CREATE_NEW`:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们可以通过将`java.nio.file.StandardOpenOption.SPARSE`选项添加到`CREATE_NEW`旁边的选项列表中，来创建一个稀疏文件：
- en: '[PRE154]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Depending on your operating system (machine), you should use dedicated tools
    to inspect these files in detail and get a deeper insight into how they work.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的操作系统（机器），你应该使用专用工具来详细检查这些文件，并深入了解它们的工作原理。
- en: 'If you find yourself using mapped memory files quite often, then you may prefer
    to extend the `Arena` interface and provide your own implementation starting from
    a simple skeleton, as follows:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常使用映射内存文件，那么你可能更喜欢扩展`Arena`接口，并从以下简单骨架开始提供自己的实现：
- en: '[PRE155]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Using the `MappedArena` is straightforward:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MappedArena`非常简单：
- en: '[PRE156]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Of course, you can improve/modify this code to obtain other configurations.
    Maybe you want a confined arena (here, we have a shared arena), maybe you want
    to delete the files after the arena is closed (here, the files remain on disk,
    so you can inspect them), maybe you don’t need sparse files (here, we use sparse
    files), maybe you prefer another file name (here, we concatenate the given name
    with `System.currentTimeMillis()` and the `.txt` extension), or maybe you need
    to take into account byte alignment.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以改进/修改此代码以获得其他配置。也许你想要一个受限的竞技场（这里，我们有一个共享竞技场），也许你希望在竞技场关闭后删除文件（这里，文件保留在磁盘上，因此你可以检查它们），也许你不需要稀疏文件（这里，我们使用稀疏文件），也许你更喜欢另一个文件名（这里，我们将给定名称与`System.currentTimeMillis()`和`.txt`扩展名连接），或者也许你需要考虑字节对齐。
- en: 165\. Introducing the Foreign Linker API
  id: totrans-641
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 165. 介绍Foreign Linker API
- en: The main goal of the Foreign Linker API is to provide a robust and easy-to-use
    API (no need to write C/C++ code) for sustaining interoperability between the
    Java code and C/C++ foreign functions of native shared libraries (in the future,
    other programming languages will be supported via this API).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: Foreign Linker API的主要目标是提供一个强大且易于使用的API（无需编写C/C++代码），以维持Java代码和原生共享库的C/C++外部函数之间的互操作性（未来，将通过此API支持其他编程语言）。
- en: 'The journey of calling foreign code starts with the `java.lang.foreign.SymbolLookup`
    functional interface. This interface represents the entry point and consists of
    looking up the address of a given symbol in a loaded native shared library. There
    are three ways of doing this, as follows:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 调用外部代码的旅程始于`java.lang.foreign.SymbolLookup`功能接口。此接口代表入口点，并包括在已加载的原生共享库中查找给定符号的地址。有三种方法可以实现这一点，如下所示：
- en: '`Linker.defaultLookup()` – as its name suggests, `defaultLookup()` represents
    a *default lookup* that scans and locates all the symbols of the commonly used
    native shared libraries depending on the current operating system:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`Linker.defaultLookup()` – 如其名所示，`defaultLookup()`表示一个*默认查找*，它根据当前操作系统扫描并定位常用原生共享库的所有符号：'
- en: '[PRE157]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '`SymbolLookup.loaderLookup()` – represents a *loader lookup* that scans and
    locates all the symbols in all the native shared libraries loaded in the current
    class loader (via `System.loadLibrary()` and `System.load()` based on `java.library.path`):'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymbolLookup.loaderLookup()` – 表示一个*加载器查找*，它扫描并定位当前类加载器（通过`System.loadLibrary()`和`System.load()`基于`java.library.path`）加载的所有原生共享库中的所有符号：'
- en: '[PRE158]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '`SymbolLookup.libraryLookup(String name, Arena arena)` – represents a *library
    lookup* capable of scanning and loading in the arena scope a native shared library
    with the given name. It also creates a symbol lookup for all symbols in that native
    shared library. Alternatively, we can specify a `Path` via `SymbolLookup.libraryLookup(Path
    path, Arena arena)`:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymbolLookup.libraryLookup(String name, Arena arena)` – 表示一个*库查找*，能够在指定的区域范围内扫描和加载具有给定名称的本地共享库。它还为此本地共享库中的所有符号创建符号查找。或者，我们也可以通过`SymbolLookup.libraryLookup(Path
    path, Arena arena)`指定一个`Path`：'
- en: '[PRE159]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: If this step is successfully accomplished, then we can choose the symbol(s)
    corresponding to the foreign function(s) that we want to call. Finding a foreign
    function can be done by its name via the `SymbolLookup.find(String name)` method.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一步成功完成，那么我们可以选择我们想要调用的外部函数对应的符号。可以通过`SymbolLookup.find(String name)`方法通过其名称找到外部函数。
- en: 'If the pointed method exists among the located symbols, then `find()` returns
    a zero-length memory segment wrapped in an `Optional (Optional<MemorySegment>)`.
    The *base address* of this segment points to the foreign function’s entry point:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指向的方法在找到的符号中存在，则`find()`返回一个零长度的内存段，该段被`Optional (Optional<MemorySegment>)`包装。此段的*基本地址*指向外部函数的入口点：
- en: '[PRE160]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'So far, we have located the native shared library and found one of its methods
    (`fooFunc`). Next, we have to link Java code to this foreign function. This is
    accomplished via the `Linker` API, which is based on two concepts:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定位了本地共享库并找到了其方法之一（`fooFunc`）。接下来，我们必须将Java代码链接到这个外部函数。这是通过基于两个概念的`Linker`
    API完成的：
- en: '*downcall* – call the native code from Java code'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*downcall* – 从Java代码调用本地代码'
- en: '*upcall –* call the Java code from the native code'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*upcall –* 从本地代码调用Java代码'
- en: 'These two concepts are materialized by the `Linker` interface. *downcall* is
    mapped in two methods with the following signatures:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个概念通过`Linker`接口实现。*downcall*通过以下签名的两个方法映射：
- en: '[PRE161]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Typically, the `default` method is used via the `MemorySegment` obtained earlier
    via the `find()` method, a function descriptor that describes the signature of
    the foreign function, and an optional set of linker options. The returned `MethodHandle`
    is used later to invoke the foreign function via `invoke()`, `invokeExact()`,
    and so on. Via `invoke()` or `invokeExact()`, we pass arguments to the foreign
    function and access the returned result of running the foreign function (if any).
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过`find()`方法获得的`MemorySegment`来使用`default`方法，该方法描述了外部函数的签名，以及一个可选的链接器选项集。返回的`MethodHandle`随后用于通过`invoke()`、`invokeExact()`等方法调用外部函数。通过`invoke()`或`invokeExact()`，我们向外部函数传递参数，并访问外部函数运行返回的结果（如果有）。
- en: '*upcall* is mapped by the following method:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '*upcall*通过以下方法映射：'
- en: '[PRE162]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Typically, the `target` argument refers to a Java method, the `function` argument
    describes the Java method signature, and the `arena` argument represents the arena
    associated with the returned `MemorySegment`. This `MemorySegment` is passed later
    as an argument of the Java code that invokes (`invoke()`/`invokeExact()`) a *downcall*
    method handle. As a consequence, this `MemorySegment` acts as a function pointer.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`target`参数指的是Java方法，`function`参数描述了Java方法的签名，而`arena`参数代表与返回的`MemorySegment`关联的区域。这个`MemorySegment`随后作为Java代码的参数传递，该Java代码调用（`invoke()`/`invokeExact()`）一个*downcall*方法句柄。因此，这个`MemorySegment`充当了函数指针。
- en: 'If we glue this knowledge together, then we can write a classical example of
    calling the `getpid()` method (on Windows 10, `_getpid()` – [https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getpid](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getpid))
    as follows (consider reading the meaningful comments to get insight on each step):'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些知识结合起来，就可以编写一个经典的调用`getpid()`方法（在Windows 10上，为`_getpid()` – [https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getpid](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getpid)）的示例，如下所示（请阅读有意义的注释以了解每一步的细节）：
- en: '[PRE163]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This code was tested on Windows 10\. If you run a different operating system,
    then consider informing yourself about this foreign function to adjust the code
    accordingly.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码已在Windows 10上进行了测试。如果您运行的是不同的操作系统，那么请考虑了解此外部函数以相应地调整代码。
- en: 166\. Calling the sumTwoInt() foreign function
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 166. 调用sumTwoInt()外部函数
- en: Do you remember the `sumTwoInt()` function? We have defined this C function
    in a native shared library named `math.dll` (check *Problems 144*, *145*, and
    *146*). Let’s assume that we have placed the `math.dll` library in the project
    folder under the `lib/cpp` path.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得 `sumTwoInt()` 函数吗？我们已经在名为 `math.dll` 的本地共享库中定义了这个 C 函数（检查 *问题 144*、*145*
    和 *146*）。假设我们已经将 `math.dll` 库放置在项目文件夹下的 `lib/cpp` 路径中。
- en: 'We can call this foreign function in almost the same manner as we’ve called
    `_getpid()`. Since `math.dll` is a user-defined library that is not commonly used,
    it cannot be loaded via `defaultLookup()`. The solution is to explicitly load
    the library from the `lib/cpp` path, as follows:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几乎与调用 `_getpid()` 相同的方式调用此外部函数。由于 `math.dll` 是一个用户定义的库，不常使用，因此不能通过 `defaultLookup()`
    加载。解决方案是从 `lib/cpp` 路径显式加载库，如下所示：
- en: '[PRE164]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Next, we have to find in `math.dll` the foreign function by name. If your C
    compiler (for instance, G++) has applied the *mangling* (or *name decoration*)
    technique, then `sumTwoInt` will have been renamed in the library to something
    else (here, `_Z9sumTwoIntii`) and that name should be used:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须在 `math.dll` 中通过名称查找外部函数。如果你的 C 编译器（例如，G++）已经应用了 *mangling*（或 *name
    decoration*）技术，那么 `sumTwoInt` 在库中已经被重命名为其他名称（这里，`_Z9sumTwoIntii`），应该使用这个名称：
- en: '[PRE165]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Next, we define the `MethodHandle` for this *downcall*:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义此 *downcall* 的 `MethodHandle`：
- en: '[PRE166]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Finally, we can invoke the foreign function and get the result:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以调用外部函数并获取结果：
- en: '[PRE167]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The result should be 12\. Check out the complete code in the bundled code.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是 12。查看捆绑代码中的完整代码。
- en: 167\. Calling the modf() foreign function
  id: totrans-676
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 167. 调用 modf() 外部函数
- en: 'Let’s consider that we want to call the `modf()` foreign function. This function
    is part of the C standard library with the following syntax ([https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/modf-modff-modfl](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/modf-modff-modfl)):'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们想要调用 `modf()` 外部函数。此函数是 C 标准库的一部分，具有以下语法 ([https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/modf-modff-modfl](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/modf-modff-modfl))：
- en: '[PRE168]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: This method gets a `double x` and returns the signed fractional part of `x`.
    The `intptr` is a pointer argument used to point to the memory address where the
    integer part should be stored as a `double` value.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法获取一个 `double x` 并返回 `x` 的有符号小数部分。`intptr` 是一个指针参数，用于指向应该将整数部分存储为 `double`
    值的内存地址。
- en: 'Since this method is part of UCRT, it can be found via `defaultLookup()`:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此方法属于 UCRT，可以通过 `defaultLookup()` 找到：
- en: '[PRE169]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Nothing new so far! Next, we need to define the proper `MethodHandle`. Because
    the second argument of `modf()` is a pointer, we need to specify a value layout
    of type `ADDRESS`:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止没有什么新内容！接下来，我们需要定义适当的 `MethodHandle`。因为 `modf()` 的第二个参数是一个指针，所以我们需要指定一个类型为
    `ADDRESS` 的值布局：
- en: '[PRE170]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'If we could invoke the foreign function at this point, we could collect the
    fractional part of the given `x`, but we cannot obtain the integer part. We have
    to create a memory segment and pass this memory segment to the foreign function
    at invocation time. The foreign function will write the integer part in this memory
    segment, which should be capable of storing a `double` value:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在能够调用外部函数，我们可以收集给定 `x` 的分数部分，但我们无法获得整数部分。我们必须创建一个内存段，并在调用时将此内存段传递给外部函数。外部函数将在这个内存段中写入整数部分，这个内存段应该能够存储一个
    `double` 值：
- en: '[PRE171]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The fractional part is returned by the foreign key. The integer part is read
    from the memory segment at offset 0:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 小数部分由外部键返回。整数部分从偏移量 0 的内存段中读取：
- en: '[PRE172]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'If `x` = 89.76655, then the output will be:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` = 89.76655，那么输出将是：
- en: '[PRE173]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Challenge yourself to adapt this code to call `modff()` and `modfl()` foreign
    functions.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战自己将此代码修改为调用 `modff()` 和 `modfl()` 外部函数。
- en: 168\. Calling the strcat() foreign function
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 168. 调用 strcat() 外部函数
- en: 'The `strcat()` foreign function is part of the C standard library and has the
    following signature ([https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcat-wcscat-mbscat](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcat-wcscat-mbscat)):'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcat()` 外部函数是 C 标准库的一部分，具有以下签名 ([https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcat-wcscat-mbscat](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcat-wcscat-mbscat))：'
- en: '[PRE174]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'This function appends the `strSource` at the end of the `strDestination`. The
    function doesn’t get these strings. It gets two pointers to these strings (so,
    two `ADDRESS`) and doesn’t return a value, so we rely on `FunctionDescriptor.ofVoid()`,
    as follows:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将 `strSource` 追加到 `strDestination` 的末尾。该函数不获取这些字符串。它获取指向这些字符串的指针（因此，两个 `ADDRESS`）并且不返回值，所以我们依赖于
    `FunctionDescriptor.ofVoid()`，如下所示：
- en: '[PRE175]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Since the arguments of `strcat()` are two pointers (`ADDRESS`), we have to
    create two memory segments and set the strings accordingly:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `strcat()` 的参数是两个指针（`ADDRESS`），我们必须创建两个内存段并相应地设置字符串：
- en: '[PRE176]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Notice the size of `segmentStrDestination`. Since `strcat()` appends the source
    string (`strSource`) at the end of the destination string (`strDestination`),
    we have to prepare the size of `segmentStrDestination` to fit the source string
    as well, so its size is `strSource.length() + 1 + strDestination.length() + 1`.
    Next, we can invoke the foreign function as follows:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `segmentStrDestination` 的大小。由于 `strcat()` 将源字符串（`strSource`）追加到目标字符串（`strDestination`）的末尾，我们必须准备
    `segmentStrDestination` 的大小以适应源字符串，因此其大小是 `strSource.length() + 1 + strDestination.length()
    + 1`。接下来，我们可以如下调用外部函数：
- en: '[PRE177]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Finally, we read the result from `segmentStrDestination`:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从 `segmentStrDestination` 读取结果：
- en: '[PRE178]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: So, the `World` string was appended at the end of `Hello`.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`World` 字符串被添加到了 `Hello` 的末尾。
- en: 169\. Calling the bsearch() foreign function
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 169. 调用 bsearch() 外部函数
- en: 'The `bsearch()` foreign function is part of the C standard library and has
    the following signature ([https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/bsearch](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/bsearch)):'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '`bsearch()` 外部函数是 C 标准库的一部分，具有以下签名 ([https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/bsearch](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/bsearch)):'
- en: '[PRE179]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: In a nutshell, this method gets pointers to a key, a sorted array (`base`),
    and a comparator. Its goal is to use the given comparator to perform a binary
    search of the given `key` in the given array. More precisely, `bsearch()` gets
    a pointer to the `key`, a pointer to the array, the number of elements in the
    array (`num`), the size of an element in bytes (`width`), and the comparator as
    a callback function.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，此方法获取键、排序数组（`base`）和比较器的指针。其目标是使用给定的比较器在给定的数组中对给定的 `key` 执行二分搜索。更确切地说，`bsearch()`
    获取 `key` 的指针、数组的指针、数组中的元素数量（`num`）、元素的字节大小（`width`）以及作为回调函数的比较器。
- en: The callback function gets a pointer to `key` and a pointer to the current element
    of the array to be compared with `key`. It returns the result of comparing these
    two elements.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数获取 `key` 的指针以及要与之比较的当前数组元素的指针。它返回比较这两个元素的结果。
- en: The `bsearch()` function returns a pointer in the array pointing to the occurrence
    of the key. If the given key is not found, then `bsearch()` returns `NULL`.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '`bsearch()` 函数返回指向数组中键出现的指针。如果给定的键未找到，则 `bsearch()` 返回 `NULL`。'
- en: 'We can start by coding the comparator callback function as a Java method:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先从编写比较回调函数作为 Java 方法开始：
- en: '[PRE180]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The `i1` memory segment is the pointer to `key`, and the `i2` memory segment
    is the pointer to the current element of the array to be compared with `key`.
    This method will be called by the foreign function (native code calls Java code),
    so an *upcall stub* should be prepared. First, we need a method handle pointing
    to this comparator:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '`i1` 内存段是 `key` 的指针，`i2` 内存段是指向要与之比较的当前数组元素的指针。此方法将由外部函数（本地代码调用 Java 代码）调用，因此应该准备一个
    *upcall stub*。首先，我们需要一个指向此比较器的方法句柄：'
- en: '[PRE181]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Second, we create the *upcall stub*. For this, we need the `Linker`:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们创建 *upcall stub*。为此，我们需要 `Linker`：
- en: '[PRE182]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'And we are ready to use the confined arena:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好使用受限的竞技场：
- en: '[PRE183]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Here, we have used the `withTargetLayout()` method to create an *unbounded*
    address. The *unbounded* `ADDRESS` means addresses for which we don’t know the
    size, so it is better to ensure that enough space will be available by setting
    them as *unbounded*. Practically, by creating a target sequence layout without
    an explicit size, we obtain a native memory segment with maximal size. Next, we
    find the `bsearch()` method and define its method handle.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了 `withTargetLayout()` 方法创建一个 *无界* 地址。*无界* 的 `ADDRESS` 指的是我们不知道大小的地址，因此最好通过将它们设置为
    *无界* 来确保有足够的空间。实际上，通过创建一个没有显式大小的目标序列布局，我们获得了一个最大大小的本地内存段。接下来，我们找到 `bsearch()`
    方法并定义其方法句柄。
- en: 'Next, we prepare the `key` and the `array` arguments as `MemorySegment`:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `key` 和 `array` 参数作为 `MemorySegment` 准备：
- en: '[PRE184]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'We have all the needed arguments, so we can invoke `bsearch()`:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了所有需要的参数，因此我们可以调用 `bsearch()`：
- en: '[PRE185]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Keep in mind that `bsearch()` returns a pointer in the `array` pointing to
    the first occurrence of the `key`, or it returns `NULL` if the given `key` is
    not found in the given `array`. If `bsearch()` returned `NULL`, then the result
    should match `MemorySegment.NULL`, which is a zero-length native segment representing
    a `NULL` address:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`bsearch()` 返回一个指向 `array` 中 `key` 首次出现的指针，或者如果给定 `key` 在给定 `array` 中未找到，则返回
    `NULL`。如果 `bsearch()` 返回 `NULL`，则结果应匹配 `MemorySegment.NULL`，这是一个表示 `NULL` 地址的零长度本地段：
- en: '[PRE186]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Otherwise, we know that the result represents a pointer in the given `array`.
    So, we can rely on the `segmentOffset()` method (introduced in *Problem 149*)
    to find the offset of the result relative to `array`:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们知道结果表示给定 `array` 中的指针。因此，我们可以依靠 `segmentOffset()` 方法（在 *问题 149* 中介绍）来找到结果相对于
    `array` 的偏移量：
- en: '[PRE187]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: For our `key` (14) and `array`, the returned offset is 24.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `key`（14）和 `array`，返回的偏移量是 24。
- en: 170\. Introducing Jextract
  id: totrans-727
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 170. 介绍 Jextract
- en: Jextract ([https://github.com/openjdk/jextract](https://github.com/openjdk/jextract))
    is a very handy tool capable of consuming the headers of native libraries (`*.h`
    files) and producing low-level Java native bindings. Via this tool, we can save
    a lot of time since we can focus only on calling native code without caring about
    the mechanical steps of loading libraries, writing method handles, or *downcall*
    and *upcall stubs*.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: Jextract ([https://github.com/openjdk/jextract](https://github.com/openjdk/jextract))
    是一个非常实用的工具，能够消费本地库的头文件 (`*.h` 文件) 并生成低级 Java 本地绑定。通过此工具，我们可以节省大量时间，因为我们只需关注调用本地代码，而无需关心加载库、编写方法句柄或
    *下调用* 和 *上调用* 桩的机械步骤。
- en: 'Jextract is a command-line tool that can be downloaded from [https://jdk.java.net/jextract](https://jdk.java.net/jextract).
    The main options of this tool are listed here:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: Jextract 是一个可以从 [https://jdk.java.net/jextract](https://jdk.java.net/jextract)
    下载的命令行工具。此工具的主要选项在此列出：
- en: '`--source`: When we write `jextract --source`, we instruct Jextract to generate
    from the given header file the corresponding source files without classes. When
    this option is omitted, Jextract will generate classes.'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--source`: 当我们编写 `jextract --source` 时，我们指示 Jextract 从给定的头文件生成相应的源文件，而不包含类。当省略此选项时，Jextract
    将生成类。'
- en: '`-- output path`: By default, the generated files are placed in the current
    folder. Via this option, we can point out the path where these files should be
    placed.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-- 输出路径`: 默认情况下，生成的文件放置在当前文件夹中。通过此选项，我们可以指定这些文件应该放置的路径。'
- en: '`-t <package>`: By default, Jextract uses the unnamed package name. Via this
    option, we can specify the package name for the generated classes.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t <package>`: 默认情况下，Jextract 使用未命名的包名。通过此选项，我们可以指定生成类的包名。'
- en: '`-I <dir>`: Specify one or more paths that should be appended to the existing
    search paths. The given order is respected during the search.'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-I <dir>`: 指定一个或多个应附加到现有搜索路径的路径。在搜索过程中，给定的顺序是受尊重的。'
- en: '`--dump-includes <String>`: This option allows you to filter the symbols. First,
    use this option to extract all symbols in a file. Next, edit the file to keep
    only the needed symbols. Finally, pass this file to Jextract.'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dump-includes <String>`: 此选项允许您过滤符号。首先，使用此选项提取文件中的所有符号。然后，编辑文件以保留所需的符号。最后，将此文件传递给
    Jextract。'
- en: The complete list of options is available at [https://github.com/openjdk/jextract](https://github.com/openjdk/jextract).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的选项列表可在 [https://github.com/openjdk/jextract](https://github.com/openjdk/jextract)
    上找到。
- en: 171\. Generating native binding for modf()
  id: totrans-736
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 171. 为 modf() 生成本地绑定
- en: In *Problem 160*, we located, prepared, and called the `modf()` foreign function
    via the Foreign Linker API. Now, let’s use Jextract to generate the native binding
    needed to call `modf()`.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *问题 160* 中，我们通过 Foreign Linker API 定位、准备并调用了 `modf()` 外部函数。现在，让我们使用 Jextract
    生成调用 `modf()` 所需的本地绑定。
- en: 'For Windows, the `modf()` foreign function is described in the `math.h` header
    file. If you have installed MinGW ([https://sourceforge.net/projects/mingw-w64/](https://sourceforge.net/projects/mingw-w64/))
    for 64-bit, then this header file is available in the `mingw64\x86_64-w64-mingw32\include`
    folder. If we want to generate the native bindings for `math.h`, we can do it
    as follows:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，`modf()` 外部函数在 `math.h` 头文件中描述。如果您已安装 MinGW ([https://sourceforge.net/projects/mingw-w64/](https://sourceforge.net/projects/mingw-w64/))
    64 位版本，则此头文件位于 `mingw64\x86_64-w64-mingw32\include` 文件夹中。如果我们想为 `math.h` 生成本地绑定，可以这样做：
- en: '![Figure 7.25.png](img/B19665_07_26.png)'
  id: totrans-739
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.25.png](img/B19665_07_26.png)'
- en: 'Figure 7.26: Generating the native bindings from math.h'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.26：从 math.h 生成原生绑定
- en: 'Or, as plain text:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为纯文本：
- en: '[PRE188]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: So, we generated the source files (`--sources`) in the `src\main\java` subfolder
    of the current project (`--output`), in the package `c.lib.math` (`-t`). The `math.h`
    is loaded from `mingw64\x86_64-w64-mingw32\include`.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在当前项目的 `src\main\java` 子文件夹中生成源文件（`--sources`），在包 `c.lib.math` 中（`-t`）。`math.h`
    从 `mingw64\x86_64-w64-mingw32\include` 加载。
- en: 'After running this command, you’ll find in `c.lib.math` the native bindings
    for all the symbols found in `math.h`. Most probably, this is not what we want,
    since we’re calling only the `modf()` foreign function. Filtering symbols is a
    two-step process. First, we generate a *dump* of all symbols, as follows:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，你将在 `c.lib.math` 中找到 `math.h` 中找到的所有符号的原生绑定。很可能是我们想要的，因为我们只调用 `modf()`
    外部函数。过滤符号是一个两步过程。首先，我们生成所有符号的 *dump*，如下所示：
- en: '![Figure 7.26.png](img/B19665_07_27.png)'
  id: totrans-745
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.26.png](img/B19665_07_27.png)'
- en: 'Figure 7.27: Creating a dump file containing all symbols from math.h'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.27：创建包含 math.h 中所有符号的 dump 文件
- en: 'Or, as plain text:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为纯文本：
- en: '[PRE189]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'This command will write in the project root a file named `includes.txt` containing
    all symbols found in `math.h`. The second step consists of editing this file.
    For instance, we have kept only the symbol for `modf()`, as follows:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在项目根目录中创建一个名为 `includes.txt` 的文件，其中包含 `math.h` 中找到的所有符号。第二步是编辑此文件。例如，我们只保留了
    `modf()` 符号，如下所示：
- en: '![Figure 7.27.png](img/B19665_07_28.png)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.27.png](img/B19665_07_28.png)'
- en: 'Figure 7.28: Editing the includes.txt to keep only the needed symbols'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.28：编辑 includes.txt 以保留所需的符号
- en: 'Next, we pass the edited `includes.txt` to Jextract, as follows:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编辑后的 `includes.txt` 传递给 Jextract，如下所示：
- en: '![Figure 7.28.png](img/B19665_07_29.png)'
  id: totrans-753
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.28.png](img/B19665_07_29.png)'
- en: 'Figure 7.29: Run Jextract with the filtered includes.txt'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.29：使用过滤后的 includes.txt 运行 Jextract
- en: 'Or, as plain text:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为纯文本：
- en: '[PRE190]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'This time, in `c.lib.math`, you’ll find the native bindings only for the `modf()`
    foreign function. Take your time to inspect each of these files and see how they
    interact at the code level. Since we generate only the sources, we have to compile
    the project to obtain the classes. If you prefer to generate the classes directly
    via Jextract, then you can use the following command (now, the sources will not
    be generated, only the classes):'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在 `c.lib.math` 中，你只会找到 `modf()` 外部函数的原生绑定。花时间检查这些文件，看看它们在代码层面是如何交互的。由于我们只生成源代码，我们必须编译项目以获取类。如果你希望直接通过
    Jextract 生成类，则可以使用以下命令（现在，将不会生成源代码，只会生成类）：
- en: '![Figure 7.29.png](img/B19665_07_30.png)'
  id: totrans-758
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 7.29.png](img/B19665_07_30.png)'
- en: 'Figure 7.30: Generating the classes of native bindings'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.30：生成原生绑定的类
- en: 'Or, as plain text:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为纯文本：
- en: '[PRE191]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Next, we can use the generated bindings in a Java application to call the `modf()`
    function. The code is straightforward (we don’t need to write the method handle
    and there is no need to explicitly use `invoke()`/`invokeExact()`):'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在 Java 应用程序中使用生成的绑定来调用 `modf()` 函数。代码很简单（我们不需要编写方法句柄，也不需要显式使用 `invoke()`/`invokeExact()`）：
- en: '[PRE192]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: The `modf()` function is imported from the `c.lib.math.math_h` package.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '`modf()` 函数是从 `c.lib.math.math_h` 包导入的。'
- en: Summary
  id: totrans-765
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered 28 problems. Most of them were focused on the new Foreign
    (Function) Memory APIs, or Project Panama. As you saw, this API is much more intuitive
    and powerful than the classical approaches of using JNI, JNA, and JNR. Moreover,
    the Jextract tool is very handy for generating native bindings from the headers
    of native shared libraries and saves us a lot of mechanical work.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 28 个问题。其中大部分都集中在新的 Foreign (Function) Memory APIs，或 Project Panama。正如你所见，这个
    API 比使用 JNI、JNA 和 JNR 的经典方法更加直观和强大。此外，Jextract 工具对于从原生共享库的头文件中生成原生绑定非常方便，并为我们节省了大量机械工作。
- en: Join our community on Discord
  id: totrans-767
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
- en: '![](img/QR_Code1139613064111216156.png)'
  id: totrans-770
  prefs: []
  type: TYPE_IMG
  zh: '![img/QR_Code1139613064111216156.png](img/QR_Code1139613064111216156.png)'
