- en: Adding Reporting Capabilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加报告功能
- en: Many business applications require the generation of reports as part of their
    functionality. A *report* is the representation of data in a certain format for
    a particular audience. A *R**eport Generator* (or *R**eport Viewer*) is an application
    or an application module that allows end users to visualize and download reports.
    Very often, a report generator takes data from a database and produces a document
    in a format suitable for printing on paper. We will focus on this type of report
    generator in this chapter. There are many ready-to-use report generators with
    advanced features, such as business intelligence and analytics, but these systems
    are out of the scope of this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多商业应用程序需要生成报告作为其功能的一部分。*报告*是以特定格式向特定受众展示数据的一种表示。*报告生成器*（或*报告查看器*）是一个应用程序或应用程序模块，允许最终用户可视化并下载报告。通常，报告生成器从数据库中获取数据，并生成适合打印在纸上的文档。在本章中，我们将关注这种类型的报告生成器。有许多具有高级功能（如商业智能和分析）的现成报告生成器，但这些系统超出了本书的范围。
- en: In this chapter, we'll learn how to render `JasperReports` in a Vaadin application
    without having to deal with report designers or XML design formats. Instead, we'll
    use a Java API to design the reports, similarly to how you use Java to design
    a web UI using Vaadin Framework. We'll also discuss background report generation
    and Server Push, a mechanism that allows us to update the client from a separate
    thread running on the server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在Vaadin应用程序中渲染`JasperReports`，而无需处理报告设计人员或XML设计格式。相反，我们将使用Java API来设计报告，类似于使用Vaadin框架用Java设计Web
    UI的方式。我们还将讨论后台报告生成和服务器推送，这是一种允许我们从服务器上运行的单独线程更新客户端的机制。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Integrating `JasperReports` with Vaadin
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`JasperReports`与Vaadin集成
- en: Rendering runtime-generated HTML
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染运行时生成的HTML
- en: Long-running background tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长运行的后台任务
- en: Server Push
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器推送
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be required to have Java SE Development Kit and Java EE SDK version
    8 or later. You also need Maven version 3 or later. A Java IDE with Maven support,
    such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the
    Git repository of this book, you need to install Git.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要具备Java SE开发工具包和Java EE SDK版本8或更高版本。您还需要Maven版本3或更高版本。建议使用具有Maven支持的Java IDE，例如IntelliJ
    IDEA、Eclipse或NetBeans。最后，为了使用本书的Git仓库，您需要安装Git。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-08](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-08)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-08](https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-08)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：
- en: '[https://goo.gl/9sdD5q](https://goo.gl/9sdD5q)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://goo.gl/9sdD5q](https://goo.gl/9sdD5q)'
- en: The example application
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例应用程序
- en: 'Throughout the chapter, we''ll develop a Report Viewer. The following is a
    screenshot of the finished application:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个报告查看器。以下是为完成的应用程序的截图：
- en: '![](img/87b75f20-24db-4db6-8cc1-817384e4ad7d.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87b75f20-24db-4db6-8cc1-817384e4ad7d.png)'
- en: The data model
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据模型
- en: 'The data model is based on a simple SQL table, `Call`, that contains columns
    for the ID, client name, phone number, city, start time, duration, and status.
    The following is a JPA Entity representing this table:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型基于一个简单的SQL表，`Call`，其中包含ID、客户名称、电话号码、城市、开始时间、持续时间以及状态列。以下是一个代表此表的JPA实体：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Status` and `City` are simple Java `enums` that define some test values:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Status`和`City`是简单的Java `enum`，定义了一些测试值：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice the `@Enumerated` annotations in the `city` and `status` fields of the
    `Call` class. This is used to persist the value as a string in the database instead
    of an integer representing the value, which allows us to use simpler SQL queries
    for the reports.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Call`类的`city`和`status`字段中的`@Enumerated`注解。这用于将值作为字符串而不是表示值的整数持久化到数据库中，这使得我们可以为报告使用更简单的SQL查询。
- en: We'll use two persistence frameworks in this application. For parts of the application
    that require saving data or running business logic, we'll use JPA. For reports
    data, we'll use MyBatis. In your applications you can, of course, use only one
    framework. The reason behind choosing MyBatis for report generation is that it's
    a great fit for constructing and maintaining complex SQL queries. SQL, in turn,
    is a powerful language and a perfect fit for reporting. The ability to copy an
    SQL query from your code and run it directly on a SQL client eases implementation
    and maintenance as you can quickly see the data you'd get in a report without
    having to compile or execute the application. Each report has its own **data transfer
    model** (**DTO**), a class that encapsulates the data to be rendered in a report
    in a convenient format. The advantage of this is that we don't have to query extra
    data not used in the report and so free the web server from data processing to
    some extent.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，我们将使用两个持久化框架。对于需要保存数据或运行业务逻辑的应用部分，我们将使用JPA。对于报表数据，我们将使用MyBatis。当然，在你的应用中你也可以只使用一个框架。选择MyBatis进行报表生成的原因是它非常适合构建和维护复杂的SQL查询。SQL反过来又是一种强大的语言，非常适合报表。能够从你的代码中复制SQL查询并在SQL客户端直接运行它，简化了实现和维护，因为你可以快速看到报告中会得到的数据，而无需编译或执行应用程序。每个报表都有自己的**数据传输模型**（**DTO**），这是一个封装在方便格式中的类，用于在报表中呈现数据。这种做法的优势在于我们不必查询报表中未使用的额外数据，从而在一定程度上减轻了Web服务器的数据处理负担。
- en: The configuration of both frameworks is implemented in the `JPAService` and
    `MyBatisService` classes and the `persistence.xml` and `mybatis-config.xml` files.
    A file-based H2 database is used by default, but you'll find configuration examples
    for MySQL and PostgreSQL as comments in the configuration files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 两个框架的配置都实现在`JPAService`和`MyBatisService`类以及`persistence.xml`和`mybatis-config.xml`文件中。默认使用基于文件的H2数据库，但在配置文件中你可以找到MySQL和PostgreSQL的配置示例作为注释。
- en: You can find the complete source code of this chapter's example in the `Data-centric-Applications-with-Vaadin-8\chapter-08`
    Maven project of the source code that accompanies this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书附带的源代码的`Data-centric-Applications-with-Vaadin-8\chapter-08` Maven项目中找到本章示例的完整源代码。
- en: Since a report viewer doesn't make sense without data, the example application
    includes a random data generator that populates the `Call` table with random data.
    When the table is empty, the generator will fill it with initial data representing
    phone calls made in the past 6 months at a rate of one million calls per year.
    If the table is not empty, the generator will "fill" the time span between the
    time of the last call in the table and the current time using the same rate. Additionally,
    the generator runs a background thread that inserts random data at runtime. This
    generator is meant to simulate a real-life situation in which data is constantly
    inserted into the database, sometimes even when the application is not running.
    You can find the implementation in the `DataGenerator` class. The `DataGenerator`
    functionality is invoked from a `ServletContextListener` that is defined in the
    `WebConfig` class. The initial time span and the rate used in the generator is
    configurable via parameters, in case you want to use different values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有数据，报表查看器就没有意义，因此示例应用包含一个随机数据生成器，用于向`Call`表填充随机数据。当表为空时，生成器将以每年一千万个电话的速率填充过去6个月内的电话数据。如果表不为空，生成器将使用相同的速率“填充”表中最后一条通话时间和当前时间之间的时间段。此外，生成器还运行一个后台线程，在运行时插入随机数据。这个生成器旨在模拟现实生活中的情况，数据不断被插入到数据库中，有时甚至在应用程序未运行时也是如此。你可以在`DataGenerator`类中找到其实现。`DataGenerator`功能是通过在`WebConfig`类中定义的`ServletContextListener`调用的。生成器中使用的初始时间范围和速率可以通过参数进行配置，以防你想使用不同的值。
- en: The Vaadin UI
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vaadin UI
- en: 'The `VaadinServlet` is configured in the `WebConfig` class. The `UI` implementation
    is realized in the `VaadinUI` class. For reference, the following snippet of code
    shows the implementation of the layout of the example application:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`VaadinServlet`在`WebConfig`类中进行配置。`UI`实现是在`VaadinUI`类中完成的。为了参考，以下代码片段显示了示例应用的布局实现：'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are going to develop three different reports. The `showLastHourCallReport`,
    `showMonthlyCapacityReport`, and `generateAnnualLegalReport` methods include the
    logic to modify the UI in order to show the respective report inside the `panel`
    component.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发三个不同的报告。`showLastHourCallReport`、`showMonthlyCapacityReport` 和 `generateAnnualLegalReport`
    方法包含修改 UI 的逻辑，以便在 `panel` 组件内显示相应的报告。
- en: Integrating JasperReports with Vaadin
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 JasperReports 与 Vaadin 集成
- en: '`JasperReports` is an open-source reporting engine to produce reports that
    can be rendered in a variety of formats, such as HTML, PDF, Microsoft Excel, ODT
    (OpenOffice), and others. Typically, reports are designed in a visual editor (iReport
    Designer) or XML files (JRXML). The design is compiled into a Jasper file (`*.jasper`),
    filled with data, and exported to the desired format.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`JasperReports` 是一个开源的报告引擎，可以生成可以在多种格式中渲染的报告，例如 HTML、PDF、Microsoft Excel、ODT（OpenOffice）等。通常，报告是在视觉编辑器（iReport
    Designer）或 XML 文件（JRXML）中设计的。设计被编译成 Jasper 文件（`*.jasper`），填充数据，并导出为所需的格式。'
- en: '`DynamicJasper` and `DynamicReports` are two open-source libraries that abstract
    away the JRXML format and provide APIs to design reports in Java. This is a good
    match for the philosophy of the Vaadin Framework which allows you to implement
    HTML-based web applications in Java. In this chapter, we''ll use `DynamicJasper`,
    but the concepts are similar if you prefer `DynamicReports`. Some of the concepts
    can be also used if you plan to design reports in JRXML files directly or through
    the iReport Designer tool.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`DynamicJasper` 和 `DynamicReports` 是两个开源库，它们抽象了 JRXML 格式并提供 API 以在 Java 中设计报告。这与
    Vaadin 框架的哲学相吻合，该框架允许您使用 Java 实现基于 HTML 的网络应用程序。在本章中，我们将使用 `DynamicJasper`，但如果您更喜欢
    `DynamicReports`，概念是相似的。如果您计划直接在 JRXML 文件中或通过 iReport 设计师工具设计报告，一些概念也可以使用。'
- en: 'You can include `DynamicJasper` by adding the following dependency to your
    `pom.xml` file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 `pom.xml` 文件中添加以下依赖项来包含 `DynamicJasper`：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to export to Microsoft Office formats, you need to add Apache POI
    as a dependency:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了导出 Microsoft Office 格式，您需要添加 Apache POI 作为依赖项：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting the data
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据
- en: A crucial part of report generation is data gathering. Data is arguably the
    most important input in a report. Having good "infrastructure code" for data gathering
    will highly improve maintainability in report modules. In this chapter, we'll
    use an SQL database, since it's probably the most common kind of data store in
    use. This means reports are filled with data queried using SQL. Reporting doesn't
    require saving data, only reading. SQL queries in reports tend to have multiple
    lines and are sometimes generated dynamically. MyBatis seems to be an excellent
    choice for reporting modules. MyBatis allows query definition in XML files, which,
    unlike Java Strings, help with long multi-line SQL queries and dynamic query definitions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 报告生成的一个关键部分是数据收集。数据可以说是报告中最重要的输入。拥有良好的“基础设施代码”进行数据收集将极大地提高报告模块的可维护性。在本章中，我们将使用
    SQL 数据库，因为它可能是使用中最常见的数据库类型。这意味着报告是用 SQL 查询填充的。报告不需要保存数据，只需读取。报告中的 SQL 查询通常有多行，有时是动态生成的。MyBatis
    似乎是报告模块的一个很好的选择。MyBatis 允许在 XML 文件中定义查询，与 Java 字符串不同，这有助于处理长多行 SQL 查询和动态查询定义。
- en: 'To use XML-based mappers with MyBatis, specify the name of the XML file using
    the `resource` attribute of the `mapper` element in the MyBatis configuration
    file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用基于 XML 的 MyBatis 映射器，请在 MyBatis 配置文件中 `mapper` 元素的 `resource` 属性中指定 XML 文件的名称：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ReportsMapper.xml` file is defined as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReportsMapper.xml` 文件定义如下：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This file defines the mapper Java interface to use. All queries defined inside
    the `mapper` element are mapped to the corresponding methods in the `ReportsMapper`
    class. For example, we can define a method to get all the calls before a given
    time as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件定义了要使用的映射 Java 接口。在 `mapper` 元素内部定义的所有查询都映射到 `ReportsMapper` 类中的相应方法。例如，我们可以定义一个方法来获取给定时间之前的所有调用，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that we are not using the JPA Entity as a result type. Instead, we are
    using a DTO with, and only with, the required Java fields to store the data from
    the SQL query:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不是使用 JPA 实体作为结果类型。相反，我们使用 DTO，并且仅使用所需的 Java 字段来存储 SQL 查询中的数据：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can map an SQL query to the `findCallsBefore` method as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 SQL 查询映射到 `findCallsBefore` 方法，如下所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The UI doesn''t consume the mapper interface directly. Instead, we can define
    more high-level methods in a service class. For example, the *Worldwide Calls
    in the Last Hour* report, the data from which the previous query comes, uses the
    `lastHourCalls` method in the `ReportsService` class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: UI 不直接消耗映射接口。相反，我们可以在服务类中定义更高级的方法。例如，*过去一小时的全球通话* 报告，该报告的数据来自之前的查询，它使用了 `ReportsService`
    类中的 `lastHourCalls` 方法：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This allows for reusing queries when the data is the same but different processing
    (such as formatting, or computation of input parameters) is required.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在数据相同但需要不同处理（如格式化或计算输入参数）时重用查询。
- en: Designing the report
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计报告
- en: 'Let''s start with the implementation of a simple report, the *Worldwide Calls
    in the Last Hour* report, shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现一个简单的报告开始，即 *过去一小时的全球通话* 报告，如下面的截图所示：
- en: '![](img/4767d103-c821-450a-af22-404e3574a55c.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/4767d103-c821-450a-af22-404e3574a55c.png)'
- en: To create a report using `DynamicJasper`, you have to create an object of type
    `DynamicReport`. This is done by using the `DynamicReportBuilder` class, which
    provides methods to add the title, header, columns, and other elements that form
    the report. The `DynamicReportBuilder` class implements the *builder pattern*
    to allow creating the report step by step and a method to build the `DynamicReport`
    instance. There are several subclasses of `DynamicReportBuilder`; we'll follow
    the examples given in the official documentation and use the `FastReportBuilder`
    class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `DynamicJasper` 创建报告，你必须创建一个 `DynamicReport` 类型的对象。这是通过使用 `DynamicReportBuilder`
    类来完成的，它提供了添加标题、页眉、列和其他构成报告的元素的方法。`DynamicReportBuilder` 类实现了 *建造者模式*，允许逐步创建报告，并提供了一个构建
    `DynamicReport` 实例的方法。`DynamicReportBuilder` 有几个子类；我们将遵循官方文档中给出的示例，并使用 `FastReportBuilder`
    类。
- en: 'We can start by configuring the title and header information, enabling full
    page width, setting the text to show when there''s no data, and enabling a background
    color for odd rows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先配置标题和页眉信息，启用全页宽，设置无数据时显示的文本，并启用奇数行的背景色：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice how, after configuring the report, we end the sentence by calling the
    `build` method, which returns an instance of `DynamicReport`. All configuration
    calls happen between the instantiation (`new FastReportBuilder()`) and the call
    to `build()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在配置报告后，我们通过调用 `build` 方法来结束句子，该方法返回一个 `DynamicReport` 实例。所有配置调用都发生在实例化（`new
    FastReportBuilder()`）和调用 `build()` 之间。
- en: 'The report data is defined by columns. Columns are configured with the `addColumn`
    method. The `addColumn` method accepts an instance of type `AbstractColumn` that
    we can create by using `ColumnBuilder`, also a builder class. The following snippet
    of code demonstrates how to create the seven columns that make up the report:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 报告数据由列定义。列通过 `addColumn` 方法进行配置。`addColumn` 方法接受一个类型为 `AbstractColumn` 的实例，我们可以通过使用
    `ColumnBuilder`（也是一个构建类）来创建它。以下代码片段演示了如何创建构成报告的七个列：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For each column, we have to specify the name of the corresponding Java property
    in the `CallDto` class and its type. We can also specify the title and *text formatters*
    when needed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一列，我们必须指定 `CallDto` 类中相应的 Java 属性的名称及其类型。在需要时，我们还可以指定标题和 *文本格式化器*。
- en: 'The `DynamicReport` instance defines the visual structure of the report. With
    this in place, we can create a `JasperPrint` object, which represents a page-oriented
    document that can be later exported to multiple formats. We first need to get
    the data from the service class, and then pass the `DynamicReport` instance and
    the data to the `generateJasperPrint` method of the `DynamicJasperHelper` class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`DynamicReport` 实例定义了报告的视觉结构。有了这个基础，我们可以创建一个 `JasperPrint` 对象，它代表一个面向页面的文档，可以稍后导出为多种格式。我们首先需要从服务类中获取数据，然后将
    `DynamicReport` 实例和数据传递给 `DynamicJasperHelper` 类的 `generateJasperPrint` 方法：'
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Rendering a report as HTML
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将报告渲染为 HTML
- en: 'The `JasperPrint` instance can be exported to several formats. Since we are
    interested in rendering the report in a Vaadin web application, we can export
    the report to HTML and use a `Label` configured with `ContentMode.HTML` as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`JasperPrint` 实例可以导出为多种格式。由于我们感兴趣的是在 Vaadin 网络应用程序中渲染报告，我们可以将报告导出为 HTML，并使用配置了
    `ContentMode.HTML` 的 `Label`，如下所示：'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `HtmlExporter` class sends its output to an `OutputStream`, which we can
    convert to `String` and set as a `Label` value. This `Label` can be added to any
    Vaadin layout, as shown in this snippet of code, which also takes into account
    exception handling and resources:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`HtmlExporter` 类将输出发送到 `OutputStream`，我们可以将其转换为 `String` 并设置为 `Label` 的值。这个
    `Label` 可以添加到任何 Vaadin 布局中，如以下代码片段所示，同时也考虑了异常处理和资源管理：'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Adding charts
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加图表
- en: 'Adding charts with `DynamicJasper` is done through the `addChart` method of
    the `FastReportBuilder` class. The following snippet of code shows the full configuration
    of the *Monthly Capacity Report*:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DynamicJasper` 添加图表是通过 `FastReportBuilder` 类的 `addChart` 方法完成的。以下代码片段显示了
    *月度容量报告* 的完整配置：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how we need a reference to the columns containing the data we want to
    use in the chart. The `setCategory` and `addSeries` methods accept these references.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何需要引用包含我们想要在图表中使用的数据的列。`setCategory` 和 `addSeries` 方法接受这些引用。
- en: 'In order to render charts, we must configure an `ImageServlet`, which is provided
    by the `JasperReports` library. This servlet serves the images that make up the
    charts. In the example application for this chapter, the servlet is declared in
    the `WebConfig` class as a static inner class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染图表，我们必须配置一个 `ImageServlet`，这是由 `JasperReports` 库提供的。这个 servlet 提供了构成图表的图像。在本章的示例应用程序中，servlet
    在 `WebConfig` 类中声明为一个静态内部类：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can use any suitable URL. This needs to be configured in the output used
    by the exporter class (for example, `HTMLExporter`). Additionally, the `JasperPrint`
    instance has to be set in the HTTP session. The following snippet of code shows
    the extra configuration needed when rendering charts:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何合适的 URL。这需要在导出类（例如，`HTMLExporter`）使用的输出中进行配置。此外，`JasperPrint` 实例必须在 HTTP
    会话中设置。以下代码片段显示了在渲染图表时所需的额外配置：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `WebHtmlResourceHandler` constructor accepts a string with the URL pattern
    to use by the internal image handler in the exporter. Notice how the pattern starts
    with `image`. This is the same value used in the `ImageServlet` mapping.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebHtmlResourceHandler` 构造函数接受一个字符串，该字符串用于导出器内部图像处理程序使用的 URL 模式。注意模式以 `image`
    开头。这是在 `ImageServlet` 映射中使用的相同值。'
- en: Generating a report in a background task
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后台任务中生成报告
- en: Report generation may involve expensive computation due to large amounts of
    data, connections to external systems, and data processing. In many situations,
    report data is gathered directly from the original source, typically an SQL database.
    This has two clear drawbacks. The first problem is that as the application runs,
    more and more data is added into the database, making reports run slower with
    time. The second problem is that report generation may heavily use the database
    at certain times, interfering with the usage of other parts of the application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大量数据、与外部系统的连接以及数据处理，报告生成可能涉及昂贵的计算。在许多情况下，报告数据直接从原始来源收集，通常是 SQL 数据库。这有两个明显的缺点。第一个问题是随着应用程序的运行，越来越多的数据被添加到数据库中，使得报告随着时间的推移运行速度变慢。第二个问题是报告生成可能在某些时候过度使用数据库，干扰应用程序其他部分的用法。
- en: 'One step toward improving this situation is to progressively and continuously
    generate the data required for reporting. For example, consider the following
    query that calculates the average on a column:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 改善这种情况的一个步骤是逐步和持续地生成报告所需的数据。例如，考虑以下查询，它计算某一列的平均值：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instead of using this query, you can use the following formula to continuously
    calculate the average (*an*) from the previous average value (*a[n-1]*) every
    time a new value (*x[n]*) is persisted:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用这个查询，你可以使用以下公式来连续计算每次新值 (*x[n]*) 持久化时的平均值 (*an*)，从上一个平均值值 (*a[n-1]*) 开始：
- en: '![](img/60ffbf40-b3f8-49ab-9fda-9919bf948027.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60ffbf40-b3f8-49ab-9fda-9919bf948027.png)'
- en: This, of course, doesn't take into account *delete* operations, and requires
    calculating the average any time a new value is persisted in the database, but
    the key idea of this simple example is to try to *help* the application to pre-generate
    data for reporting, as data is added, modified, or deleted in order to minimize
    the amount of computational power required at report generation time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这没有考虑到 *删除* 操作，并且需要在数据库中持久化新值时计算平均值，但这个简单示例的关键思想是尝试 *帮助* 应用程序预先生成报告数据，因为数据被添加、修改或删除，以最大限度地减少报告生成时间所需的计算能力。
- en: 'When pre-processing data, or when there are computations that depend on time
    or external data sources, report generation may take longer than a normal request
    to the application. In these cases, you can use background threads to generate
    the report and notify the user when the report is ready. In the example application,
    you can see an Annual legal report option in the Reports menu. Generating this
    report is expensive in terms of application time, so instead of locking the application''s
    usage until the report is ready, the application shows a notification saying that
    the report is being generated and starts the process in a background thread, letting
    users visualize other reports in the meantime:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在预处理数据时，或者当有依赖于时间或外部数据源的计算时，报告生成可能比正常的应用程序请求花费更长的时间。在这些情况下，您可以使用后台线程生成报告，并在报告准备就绪时通知用户。在示例应用程序中，您可以在报告菜单中看到一个年度法律报告选项。生成此报告在应用程序时间上代价高昂，因此，而不是锁定应用程序的使用直到报告准备就绪，应用程序显示一个通知，说明报告正在生成，并在后台线程中启动此过程，同时允许用户在此期间可视化其他报告：
- en: '![](img/90ca15da-48ba-4d88-8ec1-c13cec185d20.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90ca15da-48ba-4d88-8ec1-c13cec185d20.png)'
- en: 'When the report is ready, the application notifies you again and shows a button
    that allows you to download the report:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当报告准备就绪时，应用程序会再次通知您，并显示一个按钮，允许您下载报告：
- en: '![](img/c8567025-ebb9-4d95-9c83-5de508691eb4.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8567025-ebb9-4d95-9c83-5de508691eb4.png)'
- en: The next sections explain how to implement this behavior.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个章节将解释如何实现这种行为。
- en: Exporting a report to a PDF
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将报告导出为 PDF
- en: HTML is the best option to render a report in a browser. However, `JasperReports`
    and `DynamicJasper` support many other formats. These formats are available as
    implementations of the `JRExporter` interface. One of them is the `JRPdfExporter`
    class. The example application includes the `LastHourCallReport` class, which,
    in contrast to previous report implementations, is not a Vaadin UI component.
    Since we want to allow users to download this report, we don't really need a UI
    component for it. Instead, `LastHourCallReport` is a helper class that configures
    the report, exports it as a PDF, and exposes the content of the file through an
    `OutputStream` suitable for the `FileDownloader` class, part of Vaadin Framework.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 是在浏览器中渲染报告的最佳选择。然而，`JasperReports` 和 `DynamicJasper` 支持许多其他格式。这些格式作为 `JRExporter`
    接口的实现而可用。其中之一是 `JRPdfExporter` 类。示例应用程序包括 `LastHourCallReport` 类，与之前的报告实现不同，它不是一个
    Vaadin UI 组件。由于我们希望允许用户下载此报告，我们实际上不需要为它创建 UI 组件。相反，`LastHourCallReport` 是一个辅助类，用于配置报告，将其导出为
    PDF，并通过适合 `FileDownloader` 类的 `OutputStream` 暴露文件内容，`FileDownloader` 类是 Vaadin
    框架的一部分。
- en: 'Omitting the details about the report configuration, which we already covered
    in previous sections, the following is the implementation of the `LastHourCallReport`
    class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 省略了关于报告配置的细节，这些细节我们在前面的章节中已经介绍过，以下是对 `LastHourCallReport` 类的实现：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We need to call the `getOutputStream` method from a new thread and modify the
    UI, also from this new thread, to add a button that downloads the PDF file. In
    order to modify the UI from a separate thread, we need to enable and use Server
    Push.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从新线程中调用 `getOutputStream` 方法，并从同一新线程修改 UI，以添加一个下载 PDF 文件的按钮。为了从单独的线程修改 UI，我们需要启用并使用服务器推送。
- en: Server Push
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器推送
- en: 'Let''s examine what happens if we modify the UI from a separate thread without
    using Server Push:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们不使用服务器推送，从单独的线程修改 UI 会发生什么：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the user clicks the corresponding option in the menu, the `generateAnnualLegalReport`
    method is called. The method starts a new thread, so we end up with two threads;
    the one that started when the HTTP request happened (the menu option is clicked)
    and the one started by the `generateAnnualLegalReport` method. When the HTTP request
    finishes, the user is able to continue using the application in the browser. At
    some point later, the `AnnualLegalReport.getOutputStream()` method finishes and
    the application tries to modify the UI. However, this is happening in a separate
    background thread in the server. All changes to the UI are lost or may fail, since
    the thread is not associated with the UI instance, and `NullPointerExceptions`
    may be thrown by the framework (this is the case with the `Notification.show`
    method).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击菜单中的相应选项时，会调用`generateAnnualLegalReport`方法。该方法启动一个新线程，所以我们最终有两个线程；一个是在HTTP请求发生时启动的（菜单选项被点击），另一个是由`generateAnnualLegalReport`方法启动的。当HTTP请求完成后，用户能够继续在浏览器中使用应用程序。在稍后的某个时刻，`AnnualLegalReport.getOutputStream()`方法完成，应用程序尝试修改UI。然而，这发生在服务器的一个单独的后台线程中。所有对UI的更改都会丢失或可能失败，因为线程没有与UI实例关联，并且框架可能会抛出`NullPointerExceptions`（这是`Notification.show`方法的情况）。
- en: 'You can get a lock on the session in order to guarantee a UI instance is available
    and avoid `NullPointerExceptions` by wrapping any code that modifies the UI from
    outside a request-handling thread with the `UI.access(Runnable)` method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过锁定会话来确保有一个UI实例可用，并通过使用`UI.access(Runnable)`方法将任何修改UI的代码（从请求处理线程外部）包装起来，以避免`NullPointerExceptions`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There''s still one problem; the server needs to send the changes to the browser,
    something we can achieve by enabling **Server Push**. Server Push is a technique
    that starts a communication process from the server to the client, in opposition
    to a typical HTTP request where the communication is initiated by the client (web
    browser). In order to use Server Push, you need to add the `vaadin-push` dependency
    in your `pom.xml` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一个问题；服务器需要将更改发送到浏览器，我们可以通过启用**服务器推送**来实现这一点。服务器推送是一种从服务器到客户端启动通信过程的技术，与典型的HTTP请求相反，其中通信是由客户端（网页浏览器）发起的。为了使用服务器推送，您需要在`pom.xml`文件中添加`vaadin-push`依赖项：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To enable Server Push, you can annotate the UI implementation class with `@Push`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用服务器推送，您可以使用`@Push`注解UI实现类：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Push` annotation accepts two optional parameters: `value` and `transport`.The
    first one, `value`, configures the *push mode* to use. There are two main options:
    `PushMode.AUTOMATIC` and `PushMode.MANUAL`. `AUTOMATIC` means all changes to the
    UI are automatically sent to the client once the `UI.access` method finishes (technically,
    once the session lock is released). `MANUAL` means you have to call `UI.push`
    to make the UI changes available in the browser. The second parameter, `transport`,
    configures the *transport type* to use. There are three options: `Transport.WEBSOCKET`
    (which uses the standard *WebSockets* protocol, a different protocol than HTTP,
    for all communications between the server and the client), `Transport.WEBSOCKET_XHR`
    (which uses WebSockets for server-to-client communication and XHR for client-to-server
    communication), and `Transport.LONG_POLLING` (a technique that uses the standard
    HTTP protocol where the client requests the server for data, the server holds
    the request until new data is available, and the process is repeated again).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Push`注解接受两个可选参数：`value`和`transport`。第一个参数，`value`，配置要使用的*推送模式*。主要有两种选项：`PushMode.AUTOMATIC`和`PushMode.MANUAL`。`AUTOMATIC`表示一旦`UI.access`方法完成（技术上，一旦会话锁释放），所有对UI的更改都会自动发送到客户端。`MANUAL`表示您必须调用`UI.push`来使UI更改在浏览器中可用。第二个参数，`transport`，配置要使用的*传输类型*。有三个选项：`Transport.WEBSOCKET`（使用标准*WebSockets*协议，与HTTP不同的协议，用于服务器和客户端之间的所有通信），`Transport.WEBSOCKET_XHR`（使用WebSockets进行服务器到客户端通信，使用XHR进行客户端到服务器通信），以及`Transport.LONG_POLLING`（一种使用标准HTTP协议的技术，客户端请求服务器数据，服务器保持请求直到有新数据可用，然后再次重复此过程）。'
- en: 'You also have to enable the asynchronous operation mode for the `VaadinServlet`
    in order to optimize resources and allow XHR as a fallback mechanism when WebSockets
    is not available:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须为`VaadinServlet`启用异步操作模式，以优化资源并允许在WebSockets不可用时将XHR作为后备机制：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to render `JasperReports` in Vaadin applications.
    We used `DynamicJasper`, which allowed us to use the Java Programming Language
    to design the reports. We also learned how to generate a report in a background
    thread running on the server and notify the client once the report is ready by
    using Server Push.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 Vaadin 应用程序中渲染 `JasperReports`。我们使用了 `DynamicJasper`，这使得我们可以使用
    Java 编程语言来设计报告。我们还学习了如何在服务器上运行的背景线程中生成报告，并通过使用服务器推送在报告准备好后通知客户端。
- en: In the next chapter, you will learn about how to handle large volumes of data
    in UIs by using lazy loading.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过使用懒加载来在 UI 中处理大量数据。
