- en: Chapter 8. Optimizing Your Requests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章.优化您的请求
- en: In this chapter, we will be looking at different techniques to improve our application's
    performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的技术来提高我们应用程序的性能。
- en: 'We will implement classical ways of optimizing a web application: cache control
    headers, Gzipping, an application cache, and ETags, as well as more reactive stuff,
    such as asynchronous method calls and WebSockets.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现优化Web应用程序的经典方法：缓存控制头、Gzipping、应用程序缓存和ETags，以及更反应性的内容，例如异步方法调用和WebSockets。
- en: A production profile
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产配置文件
- en: In the previous chapter, we saw how to define an application properties file
    that will only be read while launching the application with a specific profile.
    We will use the same approach and create an `application-prod.properties` file
    in `src/main/resources`, right next to the existing `application.properties` file.
    This way, we will be able to configure the production environment with optimized
    settings.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何定义一个应用程序属性文件，该文件仅在以特定配置文件启动应用程序时读取。我们将使用相同的方法，并在`src/main/resources`中创建一个`application-prod.properties`文件，紧挨着现有的`application.properties`文件。这样，我们将能够使用优化设置配置生产环境。
- en: We will put a few properties in this file to get started. In [Chapter 3](ch03.html
    "Chapter 3. Handling Forms and Complex URL Mapping"), *Handling Forms and Complex
    URL Mapping*, we deactivated the Thymeleaf cache and forced translation bundles
    to reload on every access.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个文件中放入一些属性以开始。在[第3章](ch03.html "第3章.处理表单和复杂URL映射")中，*处理表单和复杂URL映射*，我们停用了Thymeleaf缓存并强制翻译捆绑包在每次访问时重新加载。
- en: 'This is great for developing but is useless and time consuming in production.
    So let''s fix that:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于开发来说很棒，但在生产中却毫无用处且浪费时间。所以让我们来解决这个问题：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A cache period of `-1` means caching the bundle forever.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`-1` 的缓存周期意味着永久缓存捆绑包。'
- en: Now, if we launch our application with the "prod" profile, templates and bundles
    should be cached forever.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用“prod”配置文件启动我们的应用程序，模板和捆绑包应该会永久缓存。
- en: The properties coming from the "prod" profile will indeed overwrite the ones
    declared in our `application.properties` file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 来自“prod”配置文件的性质确实会覆盖我们在`application.properties`文件中声明的那些。
- en: Gzipping
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gzipping
- en: '**Gzipping** is a compression algorithm widely understood by browsers. Your
    server will serve compressed responses, which will consume a few more CPU cycles
    but will save bandwidth.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gzipping** 是一种被浏览器广泛理解的压缩算法。您的服务器将提供压缩响应，这将会消耗更多的CPU周期，但可以节省带宽。'
- en: The client browser will then be charged for unzipping the resources and displaying
    them to the user.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端浏览器将负责解压缩资源并向用户显示它们。
- en: 'To leverage Tomcat''s Gzipping abilities, simply add the following line to
    the `application-prod.properties` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用Tomcat的Gzipping压缩能力，只需将以下行添加到`application-prod.properties`文件中：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will enable Tomcat's Gzipping compression when serving any file matching
    the MIME types specified in the list, and whose length is greater than 2048 bytes.
    You can set `server.tomcat.compression` to `force` to enforce compression or set
    it to a numerical value if you want to change the value for the minimal length
    of Gzipped assets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启用Tomcat在服务任何匹配列表中指定的MIME类型且长度大于2048字节的文件时的Gzipping压缩。您可以将`server.tomcat.compression`设置为`force`以强制压缩，或者将其设置为数值以更改Gzipped资产的最小长度值。
- en: If you want more control over the compression, say over the level of compression,
    or want to exclude user agents from compression, you can use the `GzipFilter`
    class in Jetty by adding the `org.eclipse.jetty:jetty-servlets` dependency to
    your project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要对压缩有更多的控制，比如说对压缩级别进行控制，或者想要排除压缩的用户代理，您可以通过将`org.eclipse.jetty:jetty-servlets`依赖项添加到项目中，在Jetty中使用`GzipFilter`类。
- en: This will automatically trigger the `GzipFilterAutoConfiguration` class, which
    can be configured with a handful of properties prefixed by `spring.http.gzip`.
    Have a look at `GzipFilterProperties` to understand its level of customization.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动触发`GzipFilterAutoConfiguration`类，可以通过以`spring.http.gzip`为前缀的一组属性进行配置。查看`GzipFilterProperties`以了解其可定制的程度。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the documentation at [http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#how-to-enable-http-response-compression](http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#how-to-enable-http-response-compression)
    for additional information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#how-to-enable-http-response-compression](http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#how-to-enable-http-response-compression)文档以获取更多信息。
- en: Cache control
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存控制
- en: Cache control is a set of HTTP headers sent by the server to control how the
    user's browser is allowed to cache resources.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存控制是一组由服务器发送的HTTP头，用于控制用户的浏览器允许缓存资源的方式。
- en: In the previous chapter, we have seen that Spring Security automatically disables
    caching for secured resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了Spring Security自动禁用受保护资源的缓存。
- en: 'If we want to benefit from cache control, we must first disable that feature:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从缓存控制中受益，我们首先必须禁用该功能：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, launch the application, go to the main page, and check the Chrome developer
    console. You will see that our JavaScript files are Gzipped and cached, as marked
    in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动应用程序，转到主页，并检查Chrome开发者控制台。你将看到我们的JavaScript文件被Gzipped并缓存，如下面的截图所示：
- en: '![Cache control](img/2117_08_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![缓存控制](img/2117_08_01.jpg)'
- en: 'If you want more control over your cache, you could add handlers for your own
    resources in your configuration:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对自己的缓存有更多控制，你可以在配置中添加自己资源的处理器：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We could also override the Spring Security default settings. If we want to
    deactivate the "no cache control" policy for our API, we can change the `ApiSecurityConfiguration`
    class like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以覆盖Spring Security的默认设置。如果我们想为我们的API禁用“无缓存控制”策略，我们可以像这样更改`ApiSecurityConfiguration`类：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Application cache
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序缓存
- en: Now that our web requests have been compressed and cached, the next step we
    can take to reduce server load is to put the results of costly operations in a
    cache. The Twitter search takes some time and will consume our application request
    ratio on the Twitter API. With Spring, we can easily cache the search and return
    the same result each time the search is called with the same parameters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经压缩并缓存了Web请求，下一步我们可以采取以减少服务器负载的是将昂贵操作的输出放入缓存。Twitter搜索需要一些时间，并将消耗我们的应用程序请求比率在Twitter
    API上。使用Spring，我们可以轻松缓存搜索，并在每次使用相同参数调用搜索时返回相同的结果。
- en: 'The first thing that we need to do is activate Spring caching with the `@EnableCache`
    annotation. We also need to create a `CacheManager` that will resolve our caches.
    Let''s create a `CacheConfiguration` class in the `config` package:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是使用`@EnableCache`注解激活Spring缓存。我们还需要创建一个`CacheManager`来解析我们的缓存。让我们在`config`包中创建一个`CacheConfiguration`类：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous example, we use the simplest possible cache abstraction. Other
    implementations are also available, such as `EhCacheCacheManager` or `GuavaCacheManager`,
    which we will use in a moment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了最简单的缓存抽象。其他实现也可用，例如`EhCacheCacheManager`或`GuavaCacheManager`，我们将在稍后使用。
- en: Now that we have configured our cache, we can use the `@Cacheable` annotation
    on our methods. When we do that, Spring will automatically cache the result of
    the method and associate it with the current parameters for retrieval.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了缓存，我们可以在我们的方法上使用`@Cacheable`注解。当我们这样做时，Spring将自动缓存方法的结果，并将其与当前参数关联以供检索。
- en: Spring needs to create a proxy around beans whose methods are cached. This typically
    means that calling a cached method inside of the same bean will not fail to use
    Spring's cache.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Spring需要在缓存的bean周围创建代理。这通常意味着在同一个bean内部调用缓存的函数不会失败，并且可以使用Spring的缓存。
- en: In our case, in the `SearchService` class, the part where we call the search
    operations, would benefit greatly from caching.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，在`SearchService`类中，调用搜索操作的部分将极大地受益于缓存。
- en: 'As a preliminary step, it would be good to put the code responsible for creating
    the `SearchParameters` class in a dedicated object called `SearchParamsBuilder`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初步步骤，将负责创建`SearchParameters`类的代码放入一个名为`SearchParamsBuilder`的专用对象中会很好：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will help us to create search parameters in our service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助我们在我们的服务中创建搜索参数。
- en: Now we want to create a cache for our search results. We want each call to the
    Twitter API to be cached. Spring cache annotations rely on proxies to instrument
    the `@Cacheable` methods. We therefore need a new class with a method annotated
    with the `@Cacheable` annotation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要为我们的搜索结果创建一个缓存。我们希望Twitter API的每次调用都被缓存。Spring缓存注解依赖于代理来对`@Cacheable`方法进行检测。因此，我们需要一个新的类，其中包含一个用`@Cacheable`注解的方法。
- en: When you use the Spring abstraction API, you don't know about the underlying
    implementation of the cache. Many will require both the return type and the parameter
    types of the cached method to be Serializable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Spring抽象API时，你不知道缓存的底层实现。许多实现将需要缓存的返回类型和参数类型都是可序列化的。
- en: '`SearchParameters` is not Serializable, that''s why we will pass both the search
    type and the keyword (both strings) in the cached method.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchParameters`不是可序列化的，这就是为什么我们将在缓存方法中传递搜索类型和关键字（都是字符串）。'
- en: 'Since we want to put the `LightTweets` object in cache, we want to make them
    `Serializable`; this will ensure that they can always be written and read from
    any cache abstraction:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要将`LightTweets`对象放入缓存，我们希望它们是`Serializable`的；这将确保它们可以从任何缓存抽象中始终被写入和读取：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s create a `SearchCache` class and put it in the `search.cache` package:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`SearchCache`类并将其放入`search.cache`包中：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It can't really get simpler than that. We used the `@Cacheable` annotation to
    specify the name of the cache that will be used. Different caches may have different
    policies.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上没有比这更简单的方法了。我们使用了`@Cacheable`注解来指定将要使用的缓存名称。不同的缓存可能有不同的策略。
- en: Note that we manually created a new `TwitterTemplate` method rather than injecting
    it like before. That's because we will have to access the cache from other threads
    a little bit later. In Spring Boot's `TwitterAutoConfiguration` class, the `Twitter`
    bean is bound to the request scope and is therefore not available outside of a
    Servlet thread.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们手动创建了一个新的`TwitterTemplate`方法，而不是像以前那样注入它。这是因为我们稍后需要从其他线程访问缓存。在Spring Boot的`TwitterAutoConfiguration`类中，`Twitter`bean绑定到请求作用域，因此它不能在Servlet线程之外使用。
- en: 'With those two new objects, the code of our `SearchService` class simply becomes
    this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个新对象，我们的`SearchService`类的代码就简单成这样：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we annotated the service with `@Profile("!async")`. This means that
    we only create this bean if the profile `async` is not activated.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`@Profile("!async")`注解了服务。这意味着只有当`async`配置没有被激活时，我们才会创建这个bean。
- en: Later, we will create another implementation of the `TwitterSearch` class to
    be able to switch between the two.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将创建`TwitterSearch`类的另一个实现，以便能够在两者之间切换。
- en: 'Neat! Say we restart our application and try a big request such as the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！假设我们重启我们的应用程序并尝试一个大的请求，如下所示：
- en: '`http://localhost:8080/search/mixed;keywords=docker,spring,spring%20boot,spring%20mvc,groovy,grails`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/search/mixed;keywords=docker,spring,spring%20boot,spring%20mvc,groovy,grails`'
- en: 'It will take a little time at first, but then our console will display the
    following log:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可能需要一点时间，但之后我们的控制台将显示以下日志：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After that, if we hit refresh, the result will be displayed immediately and
    no cache miss will be seen in the console.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，如果我们刷新页面，结果将立即显示，并且控制台不会看到缓存未命中。
- en: 'That''s it for our cache, but there is much more to the cache API. You can
    annotate methods with the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的缓存功能，但缓存API还有很多其他功能。你可以使用以下注解来注解方法：
- en: '`@CachEvict`: This will remove an entry from the cache'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CachEvict`：这将从缓存中删除一个条目'
- en: '`@CachePut`: This will put the result of a method into a cache without interfering
    with the method itself'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CachePut`：这将把方法的结果放入缓存，而不会干扰方法本身'
- en: '`@Caching`: This regroups the caching annotation'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Caching`：这重新组合了缓存注解'
- en: '`@CacheConfig`: This points to different caching configurations'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CacheConfig`：这指向不同的缓存配置'
- en: The `@Cacheable` annotation can also be configured to cache results on certain
    conditions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Cacheable`注解也可以配置为在特定条件下缓存结果。'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on Spring cache, please see the following documentation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Spring缓存的更多信息，请参阅以下文档：
- en: '[http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html)'
- en: Cache invalidation
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存失效
- en: 'Currently, search results will be cached forever. Using the default simple
    cache manager doesn''t give us a lot of options. There is one more thing that
    we can do to improve our application caching. Since we have Guava in our classpath,
    we can replace the existing cache manager in the cache configuration with the
    following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，搜索结果将永久缓存。使用默认的简单缓存管理器给我们提供的选项不多。我们还可以做一件事来提高我们的应用程序缓存。由于我们的类路径中有Guava，我们可以用以下代码替换缓存配置中现有的缓存管理器：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will build a cache expiring after 10 minutes and using soft values, meaning
    that the entries will be cleaned up if the JVM runs low on memory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建一个10分钟后过期的缓存，并使用软值，这意味着如果JVM内存不足，条目将被清理。
- en: Try to fiddle around with Guava's cache builder. You can specify a smaller time
    unit for your testing, and even specify different cache policies.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整Guava的缓存构建器。你可以为你的测试指定更小的时间单位，甚至指定不同的缓存策略。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See the documentation at [https://code.google.com/p/guava-libraries/wiki/CachesExplained](https://code.google.com/p/guava-libraries/wiki/CachesExplained).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://code.google.com/p/guava-libraries/wiki/CachesExplained](https://code.google.com/p/guava-libraries/wiki/CachesExplained)中的文档。
- en: Distributed cache
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式缓存
- en: 'We already have a Redis profile. If Redis is available, we could also use it
    as our cache provider. It would allow us to distribute the cache across multiple
    servers. Let''s change the `RedisConfig` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了Redis配置文件。如果Redis可用，我们也可以将其用作我们的缓存提供者。这将允许我们在多个服务器之间分布缓存。让我们更改`RedisConfig`类：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this configuration, if we run our application with the "Redis" profile,
    the Redis cache manager will be used instead of the one defined in the `CacheConfig`
    class since it is annotated with `@Primary`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，如果我们以“Redis”配置文件运行我们的应用程序，由于它被标注为`@Primary`，将使用Redis缓存管理器而不是`CacheConfig`类中定义的缓存管理器。
- en: This will allow the cache to be distributed in case we want to scale on more
    than one server. The Redis template is used to serialize the cache return values
    and parameters, and will require objects to be `Serializable`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许缓存在我们在多个服务器上进行扩展时进行分布式。Redis模板用于序列化缓存返回值和参数，并且需要对象实现`Serializable`接口。
- en: Async methods
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步方法
- en: There is still a bottleneck in our application; when a user searches ten keywords,
    each search will be executed sequentially. We could easily improve the speed of
    our application by using different threads and launching all the searches at the
    same time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中仍然存在瓶颈；当用户搜索十个关键词时，每个搜索将依次执行。我们可以通过使用不同的线程同时启动所有搜索来轻松提高我们应用程序的速度。
- en: To enable Spring's asynchronous capabilities, one must use the `@EnableAsync`
    annotation. This will transparently execute any method annotated with `@Async`
    using a `java.util.concurrent.Executor`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Spring的异步功能，必须使用`@EnableAsync`注解。这将透明地执行任何标注了`@Async`的方法，使用`java.util.concurrent.Executor`。
- en: 'It is possible to customize the default executor used by implementing the `AsyncConfigurer`
    interface. Let''s create a new configuration class called `AsyncConfig` in the
    `config` package:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`AsyncConfigurer`接口，可以自定义默认的执行器。让我们在`config`包中创建一个新的配置类，称为`AsyncConfig`。
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this configuration, we ensure that no more than 10 threads will be allocated
    to handle our asynchronous tasks in the whole application. This is very important
    in a web application where each client has a dedicated thread. The more threads
    you use and the longer they block, the fewer client requests you can process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，我们确保整个应用程序中分配给处理异步任务的最大线程数不超过10个。在一个Web应用程序中，每个客户端都有一个专用的线程，这非常重要。你使用的线程越多，它们阻塞的时间越长，你能够处理的客户端请求就越少。
- en: Let's annotate our search method and make it asynchronous. We will need to make
    it return a subtype of `Future`, a java concurrent class that represents an asynchronous
    result.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们标注我们的搜索方法并使其异步。我们需要使其返回`Future`的子类型，这是一个表示异步结果的Java并发类。
- en: We will create a new implementation of the `TwitterSearch` class that will query
    the search API in different threads. The implementation is a bit tricky so I'll
    break it down into small parts.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`TwitterSearch`类实现，该实现将在不同的线程中查询搜索API。实现有点复杂，所以我将其分解成几个小部分。
- en: 'First, we need to annotate the method that will query the API with the `@Async`
    annotation to tell Spring to schedule the task using our executor. Again, Spring
    will use proxy to do its magic so this method has to be in a different class to
    the service calling it. It would also be nice if this component could use our
    cache. That would lead us to create this component:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 `@Async` 注解来注释将要查询 API 的方法，以告诉 Spring 使用我们的执行器来安排任务。同样，Spring 将使用代理来完成其魔法，因此此方法必须在与调用它的服务不同的类中。如果这个组件也能使用我们的缓存那就更好了。这将导致我们创建这个组件：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Don't create this class yet. Let's see what our service needs first.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还不要创建这个类。让我们先看看我们的服务需要什么。
- en: The `ListenableFuture` abstraction allows us to add callbacks after the completion
    of the future, either in the case of correct results or if an exception occurs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListenableFuture` 抽象允许我们在未来完成之后添加回调，无论是正确结果还是发生异常的情况。'
- en: 'The algorithm to wait for a bunch of asynchronous tasks would look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一组异步任务的算法看起来像这样：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you don't know the `CountDownLatch` method, it is just a simple blocking
    counter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道 `CountDownLatch` 方法，它只是一个简单的阻塞计数器。
- en: The `await()` method will wait until the latch reaches 0 to unlock the thread.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`await()` 方法将等待直到闩锁达到 0 以解锁线程。'
- en: The `asyncFetch` method, shown in the preceding code, will attach a callback
    to each of our `asynFetch` methods. The callback will add the results to the `allTweets`
    list and decrement the latch. Once each callback has been called, the method will
    return all the tweets.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中显示的 `asyncFetch` 方法将为我们的每个 `asynFetch` 方法附加一个回调。回调将结果添加到 `allTweets`
    列表并减少闩锁。一旦每个回调都被调用，该方法将返回所有推文。
- en: 'Got it? Here is the final code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？以下是最终的代码：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, to use this implementation, we need to run the application with the `async`
    profile.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用这个实现，我们需要使用 `async` 配置文件来运行应用程序。
- en: 'We can run it with multiple profiles active at the same time by separating
    them with commas, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用逗号分隔来同时运行具有多个活动配置文件，如下所示：
- en: '`--spring.profiles.active=redis,async`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`--spring.profiles.active=redis,async`'
- en: 'If we launch a search on multiple terms, we can see something like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在多个术语上启动搜索，我们可以看到类似这样的内容：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This shows that the different searches are done in parallel.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明不同的搜索是并行进行的。
- en: 'Java 8 actually introduced a new type called `CompletableFuture`, which is
    a much better API to manipulate futures. The main problem with completable futures
    is that no executor can work with them without a bit of code. This is outside
    of the scope of the article, but you can check my blog for an article on the subject:
    [http://geowarin.github.io/spring/2015/06/12/completable-futures-with-spring-async.html](http://geowarin.github.io/spring/2015/06/12/completable-futures-with-spring-async.html).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 实际上引入了一种名为 `CompletableFuture` 的新类型，这是一个更好的 API，用于操作未来。可完成未来的主要问题是没有任何执行器可以在不写一些代码的情况下与它们一起工作。这超出了本文的范围，但你可以查看我的博客上关于这个主题的文章：[http://geowarin.github.io/spring/2015/06/12/completable-futures-with-spring-async.html](http://geowarin.github.io/spring/2015/06/12/completable-futures-with-spring-async.html)。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Disclaimer**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**免责声明**'
- en: The following sections contains a lot of JavaScript. Obviously, I think you
    should have a look at the code, especially if JavaScript is not your favorite
    language. It is time to learn it. That being said, even if WebSocket is insanely
    cool, it is not a requirement. You can safely skip ahead to the last chapter and
    deploy your application right now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分包含大量的 JavaScript。显然，我认为你应该看看代码，特别是如果你不是 JavaScript 的粉丝。是时候学习了。话虽如此，即使 WebSocket
    非常酷，它也不是必需的。你可以安全地跳到最后一个章节，并立即部署你的应用程序。
- en: ETags
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ETags
- en: Our Twitter results are neatly cached, so a user refreshing the result page
    will not trigger an additional search on the Twitter API. However, the response
    will be sent to this user multiple times even if the results do not change, which
    will waste bandwidth.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Twitter 结果被整洁地缓存，所以用户刷新结果页面不会触发对 Twitter API 的额外搜索。然而，即使结果没有变化，响应也会多次发送给这个用户，这会浪费带宽。
- en: An ETag is a hash of the data of a web response and is sent as a header. The
    client can memorize the ETag of a resource and send the last known version to
    the server with the `If-None-Match` header. This allows the server to answer `304
    Not Modified` if the request does not change in the meantime.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ETag 是网页响应数据的哈希，作为头部发送。客户端可以记住资源的 ETag 并通过 `If-None-Match` 头部将最后已知版本发送到服务器。这允许服务器在请求在此期间没有变化的情况下回答
    `304 Not Modified`。
- en: 'Spring has a special Servlet filter, called `ShallowEtagHeaderFilter`, to handle
    ETags. Simply add it as a bean in the `MasterSpringMvc4Application` configuration
    class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Spring有一个特殊的Servlet过滤器，称为`ShallowEtagHeaderFilter`，用于处理ETag。只需将其作为bean添加到`MasterSpringMvc4Application`配置类中：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will automatically generate ETags for your responses as long as the response
    has no cache control headers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动为你的响应生成ETag，只要响应没有缓存控制头。
- en: 'Now if we interrogate our RESTful API, we can see that an ETag is sent along
    with the server response:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们查询我们的RESTful API，我们可以看到ETag随服务器响应一起发送：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now if we request the same resource one more time, specifying the last ETag
    that we know of in the `If-None-Match` headers, the server will automatically
    respond with a `304 Not Modified` status:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们再次请求相同的资源，指定我们在`If-None-Match`头中知道的上一个ETag，服务器将自动响应`304 Not Modified`状态：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Due to the parallel nature of our search, the tweets fetched for different keywords
    might arrive in different orders, which will make the ETag change. If you want
    this technique to work for multiple searches, please consider ordering your search
    results before sending them to the client.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的搜索具有并行性，针对不同关键词获取的推文可能会以不同的顺序到达，这将导致ETag发生变化。如果你想让这种技术适用于多个搜索，请在将搜索结果发送给客户端之前考虑对搜索结果进行排序。
- en: If we want to take advantage of that, we obviously need to rewrite our client
    code to handle them. We will see a simple solution to do that with jQuery, using
    the local storage of the browser to save the latest query of the user.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要利用这一点，显然我们需要重写我们的客户端代码来处理它们。我们将使用jQuery的简单解决方案来实现这一点，利用浏览器的本地存储来保存用户的最新查询。
- en: First, remove the `tweets` variable from our model; we won't do the search from
    the server anymore. You will have to modify a test or two to reflect this change.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从我们的模型中移除`tweets`变量；我们不会再从服务器进行搜索。你可能需要修改一个或两个测试来反映这一变化。
- en: 'Before going further, let''s add lodash to our JavaScript libraries. If you
    don''t know lodash, let''s say it is the Apache Utils of JavaScript. You can add
    it to your project dependencies like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们将lodash添加到我们的JavaScript库中。如果你不知道lodash，可以说它是JavaScript的Apache Utils。你可以像这样将lodash添加到你的项目依赖中：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add it to the `default.html` layout, just under the materialize''s JavaScript:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到`default.html`布局中，位于materialize的JavaScript之下：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will modify the `resultPage.html` file and leave the part where the tweets
    should appear empty:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`resultPage.html`文件，并将显示推文的区域留空：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we will add a script element at the bottom of the page, just before closing
    the body:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在页面的底部添加一个脚本元素，就在关闭body之前：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding script will just be in charge of constructing the URL for our
    request. We will use it by issuing a simple jQuery AJAX call:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的脚本将负责构建我们的请求的URL。我们将通过发出一个简单的jQuery AJAX调用使用它：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will use the `beforeSend` callback to have a chance to modify the request
    headers just before the call is made:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`beforeSend`回调在调用之前修改请求头：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we can easily read and write from local storage. The gotcha
    here is that local storage only works with strings so we have to parse and serialize
    the query object to JSON.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以轻松地从本地存储中读取和写入。这里的难点是本地存储只支持字符串，因此我们必须解析和序列化查询对象为JSON。
- en: 'We can handle the response by retrieving the content from local storage if
    the HTTP status is `304 Not Modified`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP状态是`304 Not Modified`，我们可以通过从本地存储检索内容来处理响应：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For the `addTweet` function that you will see next, I''m using lodash, a very
    useful JavaScript utility library, to generate templates. The function to add
    tweets to the page can be written as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你将要看到的`addTweet`函数，我使用lodash，一个非常有用的JavaScript实用库，来生成模板。向页面添加推文的函数可以写成如下：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That was a lot of JavaScript! It would make more sense to generalize this pattern
    in a Single Page Application using a library such as Backbone.js. Hopefully, though,
    this will serve as a simple example of how to implement ETags in your application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是大量的JavaScript！在单页应用中使用像Backbone.js这样的库来泛化这个模式更有意义。不过，希望这能作为一个简单的例子，说明如何在你的应用程序中实现ETag。
- en: 'If you try to refresh the search page multiple times, you will see that the
    contents do not change and will be displayed immediately:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试多次刷新搜索页面，你会看到内容没有变化，并且会立即显示：
- en: '![ETags](img/2117_08_02.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![ETags](img/2117_08_02.jpg)'
- en: There are other uses for ETags, such as optimistic locking for transactions
    (it lets you know on which version of an object the client is supposed to be working
    on at any time). It is also extra work on the server side to hash the data before
    sending it across, but it will save bandwidth.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ETags还有其他用途，例如用于事务的乐观锁定（它能让您知道客户端在任何时候应该基于对象的哪个版本进行工作）。在发送数据之前在服务器端对数据进行哈希处理也是额外的工作，但它将节省带宽。
- en: WebSockets
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket
- en: Another kind of optimization we can think about is sending the data to the client
    as it becomes available to the server. Since we fetch results of the search in
    multiple threads, the data will come in multiple chunks. We could send them bit
    by bit instead of waiting for all the results.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以考虑的一种优化是将数据作为它对服务器可用时发送给客户端。由于我们在多个线程中检索搜索结果，数据将分多个块到来。我们可以分块发送它们，而不是等待所有结果。
- en: Spring has excellent support for WebSockets, which is a protocol that allows
    clients to maintain a long-running connection to the server. Data can be pushed
    in web sockets on both ends of the connection and consumers will get the data
    in real-time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Spring对WebSocket协议提供了出色的支持，该协议允许客户端与服务器保持长时间运行的连接。数据可以在连接的两端通过WebSocket推送，并且消费者将实时获取数据。
- en: We will use a JavaScript library called SockJS to ensure compatibility with
    all browsers. Sockjs will transparently fall back on another strategy if our users
    have an outdated browser.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为SockJS的JavaScript库来确保与所有浏览器的兼容性。如果用户使用的是过时的浏览器，SockJS将透明地回退到另一种策略。
- en: We will also use StompJS to connect to our message broker.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用StompJS连接到我们的消息代理。
- en: 'Add the following library to your build:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下库添加到您的构建中：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the WebJars to our default Thymeleaf template:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将WebJars添加到我们的默认Thymeleaf模板中：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To configure WebSockets in our application, we need to add a bit of configuration
    as well:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中配置WebSocket，我们需要添加一些配置：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will configure the different channels available in our application. SockJS
    clients will connect to the `twitterSearch` endpoint and will push data to the
    server on `/ws/ channel` and be able to listen to `/topic/` for changes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置我们应用程序中可用的不同频道。SockJS客户端将连接到`twitterSearch`端点，并将数据推送到服务器的`/ws/频道`，并且能够监听`/topic/`以获取变化。
- en: 'This will allow us to inject a `SimpMessagingTemplate` in a new controller
    to push data to the client in the `/topic/searchResult` channel, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们在新的控制器中注入`SimpMessagingTemplate`，以便在`/topic/searchResult`频道中向客户端推送数据，如下所示：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In our `resultPage`, the JavaScript code is really simple:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`resultPage`中，JavaScript代码非常简单：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `displayTweets` function remains essentially the same as before:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayTweets`函数与之前基本相同：'
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here you go! The client will now receive the results of all the searches in
    the application-- live!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了！客户端现在将接收到应用程序中所有搜索的结果——实时！
- en: 'Before pushing this to production, it will require a little bit more work.
    Here are some ideas:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此推送到生产环境之前，还需要做更多的工作。以下是一些想法：
- en: Create subchannels for clients to privately listen to changes
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为客户端创建子频道以私密地监听变化
- en: Close the channel when a client is done using it
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端完成使用频道时关闭频道
- en: Add CSS transitions to the new tweets so the user can feel that it's real-time
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为新推文添加CSS过渡效果，让用户感觉到它是实时的
- en: Use a real broker, such as RabbitMQ, to allow the backend to scale with connections
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用真实的代理，如RabbitMQ，以允许后端随着连接的增多而扩展
- en: There is much more to WebSocket than just this simple example. Don't forget
    to have a look at the documentation at [http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html)
    for more information.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket远不止这个简单的例子。别忘了查看[http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html)文档以获取更多信息。
- en: The check point
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点
- en: 'In this chapter, we created two new configurations: `AsyncConfiguration`, which
    will allow us to use the `@Async` annotation to submit tasks to an executor, and
    `CacheConfiguration`, which will create a `CacheManager` interface and allow us
    to use the `@Cacheable` annotation. Since we can use Redis as a cache manager,
    we also amended the `RedisConfig` class.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了两个新的配置：`AsyncConfiguration`，它将允许我们使用`@Async`注解将任务提交给执行器，以及`CacheConfiguration`，它将创建一个`CacheManager`接口并允许我们使用`@Cacheable`注解。由于我们可以使用Redis作为缓存管理器，我们还修改了`RedisConfig`类。
- en: 'We created a `SearchCache` class, which contained a cache of tweets, and we
    now have two `TwitterSearch` implementations to choose from: good old `SearchService`,
    which will fetch each result synchronously, and `ParallelSearchService`, which
    will issue each query in a different thread:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`SearchCache`类，其中包含了一个推文的缓存，现在我们有两种`TwitterSearch`实现可供选择：传统的`SearchService`，它将同步获取每个结果，以及`ParallelSearchService`，它将在不同的线程中发出每个查询：
- en: '![The check point](img/2117_08_03.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![检查点](img/2117_08_03.jpg)'
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen two different philosophies relating to performance
    improvement. At the beginning, we tried to reduce the bandwidth used by our clients
    by caching data and using as few connections to our server as possible.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了两种与性能改进相关的不同理念。一开始，我们试图通过缓存数据和尽可能少地与服务器建立连接来减少客户端使用的带宽。
- en: In the second part, though, we began to do something more advanced by allowing
    searches to be run in parallel and each client to remain in sync with a persistent
    connection to the server through web sockets. This will allow clients to receive
    updates in real time, and our application will feel more reactive but consume
    more threads.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第二部分，我们开始做一些更高级的操作，允许并行运行搜索，并且每个客户端通过WebSocket与服务器保持持久的连接同步。这将允许客户端实时接收更新，我们的应用程序将感觉更加反应灵敏，但会消耗更多的线程。
- en: I strongly encourage you to polish the result before we move on to the next
    chapter and deploy our application for good!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议我们在进入下一章并部署我们的应用程序之前，先对结果进行润色！
