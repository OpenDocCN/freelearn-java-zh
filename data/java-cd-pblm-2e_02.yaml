- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Objects, Immutability, Switch Expressions, and Pattern Matching
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象、不可变性、Switch 表达式和模式匹配
- en: This chapter includes 30 problems, tackling, among others, some less-known features
    of `java.util.Objects`, some interesting aspects of immutability, the newest features
    of `switch` expressions, and deep coverage of the cool pattern matching capabilities
    of `instanceof` and `switch` expressions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括 30 个问题，涉及其他一些 `java.util.Objects` 的不太为人所知的功能，不可变性的有趣方面，`switch` 表达式的最新功能，以及
    `instanceof` 和 `switch` 表达式的酷模式匹配能力的深入探讨。
- en: At the end of this chapter, you’ll be up to date with all these topics, which
    are non-optional in any Java developer’s arsenal.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解所有这些主题，这些主题是任何 Java 开发者工具箱中的非可选内容。
- en: Problems
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your programming prowess on `Objects`, immutability,
    `switch` expressions, and pattern matching. I strongly encourage you to give each
    problem a try before you turn to the solutions and download the example programs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在 `Objects`、不可变性、`switch` 表达式和模式匹配方面的编程能力。我强烈建议你在查看解决方案和下载示例程序之前尝试解决每个问题：
- en: '**Explaining and exemplifying UTF-8, UTF-16, and UTF-32**: Provide a detailed
    explanation of what UTF-8, UTF-16, and UTF-32 are. Include several snippets of
    code to show how these work in Java.'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解释和示例 UTF-8、UTF-16 和 UTF-32**：提供关于 UTF-8、UTF-16 和 UTF-32 的详细解释。包括几个代码片段，以展示这些在
    Java 中的工作方式。'
- en: '**Checking a sub-range in the range from 0 to length**: Write a program that
    checks whether the given sub-range [*given start*, *given start* + *given end*)
    is within the bounds of the range from [*0*, *given length*). If the given sub-range
    is not in the [*0*, *given length*) range, then throw an `IndexOutOfBoundsException`.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查从 0 到长度的范围内的子范围**：编写一个程序，检查给定的子范围 [*给定开始*, *给定开始* + *给定结束*) 是否在从 [*0*,
    *给定长度*) 范围内。如果给定的子范围不在 [*0*, *给定长度*) 范围内，则抛出 `IndexOutOfBoundsException`。'
- en: '**Returning an identity string**: Write a program that returns a string representation
    of an object without calling the overridden `toString()` or `hashCode()`.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**返回一个身份字符串**：编写一个程序，返回对象的无重叠字符串表示，而不调用重写的 `toString()` 或 `hashCode()`。'
- en: '**Hooking unnamed classes and instance main methods**: Give a quick introduction
    to JDK 21 unnamed classes and instance main methods.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挂钩未命名的类和实例主方法**：简要介绍 JDK 21 的未命名字类和实例主方法。'
- en: '**Adding code snippets in Java API documentation**: Provide examples of adding
    code snippets in Java API documentation via the new `@snippet` tag.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 Java API 文档中添加代码片段**：通过新的 `@snippet` 标签提供在 Java API 文档中添加代码片段的示例。'
- en: '**Invoking default methods from** `Proxy` **instances**: Write several programs
    that invoke interface `default` methods from `Proxy` instances in JDK 8, JDK 9,
    and JDK 16.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从 `Proxy` 实例调用默认方法**：编写几个程序，在 JDK 8、JDK 9 和 JDK 16 中从 `Proxy` 实例调用接口 `default`
    方法。'
- en: '**Converting between bytes and hex-encoded strings**: Provide several snippets
    of code for converting between bytes and hex-encoded strings (including byte arrays).'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在字节和十六进制编码字符串之间转换**：提供几个代码片段，用于在字节和十六进制编码字符串（包括字节数组）之间进行转换。'
- en: '**Exemplify the initialization-on-demand holder design pattern**: Write a program
    that implements the initialization-on-demand holder design pattern in the classical
    way (before JDK 16) and another program that implements this design pattern based
    on the fact that, from JDK 16+, Java inner classes can have static members and
    static initializers.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**示例初始化按需持有者设计模式**：编写一个程序，以经典方式（在 JDK 16 之前）实现初始化按需持有者设计模式，并编写另一个程序，基于从 JDK
    16+ 开始，Java 内部类可以拥有静态成员和静态初始化器的这一事实来实现此设计模式。'
- en: '**Adding nested classes in anonymous classes**: Write a meaningful example
    that uses nested classes in anonymous classes (pre-JDK 16, and JDK 16+).'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在匿名类中添加嵌套类**：编写一个使用嵌套类在匿名类中的有意义的示例（JDK 16 之前，以及 JDK 16+）。'
- en: '**Exemplify erasure vs. overloading**: Explain in a nutshell what type erasure
    in Java and polymorphic overloading are, and exemplify how they work together.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**示例擦除与重载**：简要解释 Java 中的类型擦除和多态重载是什么，并示例它们是如何一起工作的。'
- en: '**Xlinting default constructors**: Explain and exemplify the JDK 16+ hint for
    classes with default constructors,`-Xlint:missing-explicit-ctor`.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Xlinting 默认构造函数**：解释并示例 JDK 16+ 为具有默认构造函数的类提供的提示 `-Xlint:missing-explicit-ctor`。'
- en: '**Working with the receiver parameter**: Explain the role of the Java receiver
    parameter and exemplify its usage in code.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用接收器参数**：解释 Java 接收器参数的作用，并通过代码示例展示其用法。'
- en: '**Implementing an immutable stack**: Provide a program that creates an immutable
    stack implementation from zero (implement `isEmpty()`, `push()`, `pop()`, and
    `peek()` operations).'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实现不可变栈**: 提供一个程序，从零开始创建不可变栈实现（实现 `isEmpty()`、`push()`、`pop()` 和 `peek()`
    操作）。'
- en: '**Revealing a common mistake with Strings**: Write a simple use case of strings
    that contain a common mistake (for instance, related to the `String` immutability
    characteristic).'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**揭示与 Strings 相关的常见错误**: 编写一个简单的字符串使用案例，其中包含一个常见错误（例如，与 `String` 的不可变特性相关）。'
- en: '**Using the enhanced NullPointerException**: Exemplify, from your experience,
    the top 5 causes of `NullPointerException` and explain how JDK 14 improves NPE
    messages.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用增强的 NullPointerException**: 根据你的经验，举例说明 `NullPointerException` 的前 5 个常见原因，并解释
    JDK 14 如何改进 NPE 消息。'
- en: '**Using yield in switch expressions**: Explain and exemplify the usage of the
    `yield` keyword with `switch` expressions in JDK 13+.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 switch 表达式中使用 yield**: 解释并举例说明在 JDK 13+ 中使用 `yield` 关键字与 `switch` 表达式的用法。'
- en: '**Tackling the case null clause in switch**: Write a bunch of examples to show
    different approaches for handling `null` values in `switch` expressions (including
    JDK 17+ approaches).'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理 switch 中的 null 情况子句**: 编写一些示例，展示在 `switch` 表达式中处理 `null` 值的不同方法（包括 JDK
    17+ 的方法）。'
- en: '**Taking on the hard way to discover equals()**: Explain and exemplify how
    `equals()` is different from the `==` operator.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以困难的方式发现 equals() 的不同**: 解释并举例说明 `equals()` 与 `==` 操作符的不同。'
- en: '**Hooking instanceof in a nutshell**: Provide a brief overview with snippets
    of code to highlight the main aspect of the `instanceof` operator.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简要介绍 instanceof 的用法**: 提供一个简短的概述和代码片段，以突出 `instanceof` 操作符的主要方面。'
- en: '**Introducing pattern matching**: Provide a theoretical dissertation including
    the main aspects and terminology for *pattern matching* in Java.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍模式匹配**: 提供一个关于 Java 中模式匹配的理论论文，包括主要方面和术语。'
- en: '**Introducing type pattern matching for instanceof**: Provide the theoretical
    and practical support for using the *type pattern matching* for `instanceof`.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 instanceof 的类型模式匹配**: 提供使用类型模式匹配的理论和实践支持。'
- en: '**Handling the scope of a binding variable in type patterns for instanceof**:
    Explain in detail, including snippets of code, the scope of *binding variables*
    in *type patterns* for `instanceof`.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理类型模式中绑定变量的作用域**: 详细解释，包括代码片段，类型模式中绑定变量的作用域。'
- en: '**Rewriting equals() via type patterns for instanceof**: Exemplify in code
    the implementation of `equals()` (including for generic classes) before and after
    *type patterns* for `instanceof` have been introduced.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过类型模式重写 instanceof 的 equals()**: 在引入 `instanceof` 的类型模式之前和之后，以代码示例展示 `equals()`
    的实现（包括泛型类）。'
- en: '**Tackling type patterns for instanceof and generics**: Provide several examples
    that use the combo *type patterns* for `instanceof` and generics.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理 instanceof 和泛型中的类型模式**: 提供几个使用 `instanceof` 的类型模式和泛型的组合示例。'
- en: '**Tackling type patterns for instanceof and streams**: Can we use *type patterns*
    for `instanceof` and the Stream API together? If yes, provide at least an example.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理 instanceof 和流中的类型模式**: 我们能否同时使用 `instanceof` 和 Stream API 的类型模式？如果是，请至少提供一个示例。'
- en: '**Introducing type pattern matching for switch**: *Type patterns* are available
    for `instanceof` but are also available for `switch`. Provide here the theoretical
    headlines and an example of this topic.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 switch 中的类型模式匹配**: 对于 `instanceof`，有类型模式可用，但对于 `switch` 也有。在此提供该主题的理论标题和示例。'
- en: '**Adding guarded pattern labels in switch**: Provide a brief coverage of *guarded
    pattern labels* in `switch` for JDK 17 and 21.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在 switch 中添加受保护的模式标签**: 简要介绍 JDK 17 和 21 中 `switch` 的受保护模式标签。'
- en: '**Dealing with pattern label dominance in switch**: Pattern label dominance
    in `switch` is a cool feature, so exemplify it here in a comprehensive approach
    with plenty of examples.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理 switch 中的模式标签优先级**: `switch` 中的模式标签优先级是一个酷特性，因此在此以综合方法举例说明，并提供大量示例。'
- en: '**Dealing with completeness (type coverage) in pattern labels for switch**:
    This is another cool topic for `switch` expressions. Explain and exemplify it
    in detail (theory ad examples).'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理 switch 中模式标签的完整性（类型覆盖）**: 这是 `switch` 表达式的另一个酷话题。详细解释并举例说明（理论和示例）。'
- en: '**Understanding the unconditional patterns and nulls in switch expressions**:
    Explain how `null` values are handled by unconditional patterns of `switch` expressions
    before and after JDK 19.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**理解switch表达式中的无条件模式和nulls**：解释在JDK 19之前和之后，`null`值是如何被`switch`表达式的无条件模式处理的。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter02).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节描述了解决前面问题的方案。请记住，通常没有解决特定问题的唯一正确方法。还请注意，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节并实验程序，请访问[https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter02)。
- en: 38\. Explain and exemplifying UTF-8, UTF-16, and UTF-32
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 38. 解释并举例说明UTF-8、UTF-16和UTF-32
- en: 'Character encoding/decoding is important for browsers, databases, text editors,
    filesystems, networking, and so on, so it’s a major topic for any programmer.
    Check out the following figure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字符编码/解码对于浏览器、数据库、文本编辑器、文件系统、网络等都非常重要，因此它是任何程序员的主要话题。查看以下图示：
- en: '![Figure 2.1.png](img/B19665_02_01.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1.png](img/B19665_02_01.png)'
- en: 'Figure 2.1: Representing text with different char sets'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：使用不同的字符集表示文本
- en: In *Figure 2.1*, we see several Chinese characters represented in UTF-8, UTF-16,
    and ANSI on a computer screen. But, what are these? What is ANSI? What is UTF-8
    and how did we get to it? Why don’t these characters look normal in ANSI?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图2.1*中，我们看到几个中文字符在计算机屏幕上以UTF-8、UTF-16和ANSI的形式表示。但是，这些是什么？ANSI是什么？UTF-8是什么，我们是如何得到它的？为什么这些字符在ANSI中看起来不正常？
- en: Well, the story may begin with computers trying to represent characters (such
    as letters from the alphabet or digits or punctuation marks). The computers understand/process
    everything from the real world as a binary representation, so as a sequence of
    0 and 1\. This means that every character (for instance, A, 5, +, and so on) has
    to be mapped to a sequence of 0 and 1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个故事可能始于计算机试图表示字符（例如字母表中的字母、数字或标点符号）。计算机将现实世界中的所有东西都理解为二进制表示，因此是一个0和1的序列。这意味着每个字符（例如，A、5、+等）都必须映射到一个0和1的序列。
- en: The process of mapping a character to a sequence of 0 and 1 is known as *character
    encoding* or simply *encoding*. The reverse process of un-mapping a sequence of
    0 and 1 to a character is known as *character decoding* or simply *decoding*.
    Ideally, an encoding-decoding cycle should return the same character; otherwise,
    we obtain something that we don’t understand or we cannot use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符映射到一系列0和1的过程被称为*字符编码*，或简单地称为*编码*。将一系列0和1反映射回字符的过程被称为*字符解码*，或简单地称为*解码*。理想情况下，编码-解码周期应该返回相同的字符；否则，我们得到的是我们不理解或无法使用的东西。
- en: For instance, the Chinese character, ![](img/B19665_02_001.png), should be encoded
    in the computer’s memory as a sequence of 0 and 1\. Next, when this sequence is
    decoded, we expect back the same Chinese letter, ![](img/B19665_02_002.png). In
    *Figure 2.1*, this happens in the left and middle screenshots, while in the right
    screenshot, the returned character is ![](img/B19665_02_003.png)…. A Chinese speaker
    will not understand this (actually, nobody will), so something went wrong!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，中文字符，![](img/B19665_02_001.png)，应该在计算机的内存中编码为一个0和1的序列。接下来，当这个序列被解码时，我们期望返回相同的中文字母，![](img/B19665_02_002.png)。在*图2.1*的左中和右图中，这种情况发生了，而在右图中，返回的字符是![](img/B19665_02_003.png)……一个中文使用者将不会理解这一点（实际上，没有人会），所以出了点问题！
- en: Of course, we don’t have only Chinese characters to represent. We have many
    other sets of characters grouped in alphabets, emoticons, and so on. A set of
    characters has well-defined content (for instance, an alphabet has a certain number
    of well-defined characters) and is known as a *character set* or, in short, a
    *charset*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不仅仅有中文字符需要表示。我们还有许多其他字符集，这些字符集被分组在字母、表情符号等中。一组字符具有定义良好的内容（例如，字母表有定义良好的字符数量）并且被称为*字符集*，简称*charset*。
- en: Having a charset, the problem is to define a set of rules (a standard) that
    clearly explains how the characters of this charset should be encoded/decoded
    in the computer memory. Without having a clear set of rules, the encoding and
    decoding may lead to errors or indecipherable characters. Such a standard is known
    as an *encoding scheme*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个字符集后，问题是要定义一组规则（一个标准），清楚地说明这个字符集的字符应该如何在计算机内存中编码/解码。如果没有明确的规则集，编码和解码可能会导致错误或无法识别的字符。这样的标准被称为*编码方案*。
- en: One of the first encoding schemes was ASCII.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最早的编码方案之一是ASCII。
- en: Introducing ASCII encoding scheme (or single-byte encoding)
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍ASCII编码方案（或单字节编码）
- en: 'ASCII stands for American Standard Code for Information Interchange. This encoding
    scheme relies on a 7-bit binary system. In other words, each character that is
    part of the ASCII charset ([http://ee.hawaii.edu/~tep/EE160/Book/chap4/subsection2.1.1.1.html](http://ee.hawaii.edu/~tep/EE160/Book/chap4/subsection2.1.1.1.html))
    should be representable (encoded) on 7 bits. A 7-bit number can be a decimal between
    0 and 127, as in the next figure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII代表美国信息交换标准代码。这个编码方案依赖于7位二进制系统。换句话说，ASCII字符集中的每个字符都应该能在7位上表示（编码）。一个7位数可以是0到127之间的十进制数，如下面的图示所示：
- en: '![Figure 2.2.png](img/B19665_02_02.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2.png](img/B19665_02_02.png)'
- en: 'Figure 2.2: ASCII charset encoding'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：ASCII字符集编码
- en: 'So, ASCII is an encoding scheme based on a 7-bit system that supports 128 different
    characters. But, we know that computers operate on bytes (octets) and a byte has
    8 bits. This means that ASCII is a single-byte encoding scheme that leaves a bit
    free for each byte. See the following figure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ASCII是一种基于7位系统的编码方案，支持128个不同的字符。但我们知道计算机在字节（八位组）上操作，一个字节有8位。这意味着ASCII是一种单字节编码方案，每个字节都留有一位空闲。请看以下图示：
- en: '![Figure 2.3.png](img/B19665_02_03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3.png](img/B19665_02_03.png)'
- en: 'Figure 2.3: The highlighted bit is left free in ASCII encoding'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：在ASCII编码中，高亮的部分是留空的
- en: 'In ASCII encoding, the letter A is 65, the letter B is 66, and so on. In Java,
    we can easily check this via the existing API, as in the following simple code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASCII编码中，字母A是65，字母B是66，以此类推。在Java中，我们可以通过现有的API轻松检查这一点，如下面的简单代码所示：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, let’s see the encoding of the text *Hello World*. This time, we added the
    free bit as well, so the result will be 01001000 01100101 01101100 01101100 01101111
    0100000 01010111 01101111 01110010 01101100 01100100:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，让我们看看文本“Hello World”的编码。这次，我们也加入了留空的位，所以结果将是01001000 01100101 01101100 01101100
    01101111 0100000 01010111 01101111 01110010 01101100 01100100：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we perform a match, then we see that 01001000 is *H*, 01100101 is *e*, 01101100
    is *l*, 01101111 is *o*, 0100000 is space, 01010111 is *W*, 01110010 is *r*, and
    01100100 is *d*. So, besides letters, the ASCII encoding can represent the English
    alphabet (upper and lower case), digits, space, punctuation marks, and some special
    characters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进行匹配，那么我们会看到01001000是*H*，01100101是*e*，01101100是*l*，01101111是*o*，0100000是空格，01010111是*W*，01110010是*r*，01100100是*d*。所以，除了字母之外，ASCII编码还可以表示英语字母（大写和小写）、数字、空格、标点符号和一些特殊字符。
- en: Besides the core ASCII for English, we also have ASCII extensions, which are
    basically variations of the original ASCII to support other alphabets. Most probably,
    you’ve heard about the ISO-8859-1 (known as ISO Latin 1), which is a famous ASCII
    extension. But, even with ASCII extensions, there are still a lot of characters
    in the world that cannot be encoded yet. There are countries that have a lot more
    characters than ASCII can encode, and even countries that don’t use alphabets.
    So, ASCII has its limitations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了核心的ASCII编码用于英语之外，我们还有ASCII扩展，这些扩展基本上是原始ASCII的变体，以支持其他字母表。很可能你已经听说过ISO-8859-1（也称为ISO拉丁1），这是一个著名的ASCII扩展。但是，即使有ASCII扩展，世界上仍然有很多字符尚未编码。有些国家的字符数量比ASCII能编码的要多，甚至有些国家不使用字母表。因此，ASCII有其局限性。
- en: I know what you are thinking … let’s use that free bit (2⁷+127). Yes, but even
    so, we can go up to 256 characters. Still not enough! It is time to encode characters
    using more than 1 byte.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么……让我们使用那个留空的位（2⁷+127）。是的，但即便如此，我们也只能达到256个字符。还不够！是时候使用超过1个字节的编码来表示字符了。
- en: Introducing multi-byte encoding
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍多字节编码
- en: In different parts of the world, people started to create multi-byte encoding
    schemes (commonly, 2 bytes). For instance, speaker of the Chinese language, which
    has a lot of characters, created Shift-JIS and Big5, which use 1 or 2 bytes to
    represent characters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在世界各地的不同地区，人们开始创建多字节编码方案（通常是2字节）。例如，中文语言的说话者，由于有很多字符，创建了Shift-JIS和Big5，它们使用1或2个字节来表示字符。
- en: But, what happens when most of the countries come up with their own multi-byte
    encoding schemes trying to cover their special characters, symbols, and so on?
    Obviously, this leads to a huge incompatibility between the encoding schemes used
    in different countries. Even worse, some countries have multiple encoding schemes
    that are totally incompatible with each other. For instance, Japan has three different
    incompatible encoding schemes, which means that encoding a document with one of
    these encoding schemes and decoding with another will lead to a garbled document.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当大多数国家试图通过自己的多字节编码方案来覆盖其特殊字符、符号等时，会发生什么情况呢？显然，这导致了不同国家使用的编码方案之间存在着巨大的不兼容性。更糟糕的是，一些国家拥有多个彼此完全不兼容的编码方案。例如，日本有三种不同的不兼容编码方案，这意味着使用其中一种编码方案编码文档，然后用另一种解码，会导致文档混乱。
- en: However, this incompatibility was not such a big issue before the Internet,
    since which documents have been massively shared all around the globe using computers.
    At that moment, the incompatibility between the encoding schemes conceived in
    isolation (for instance, countries and geographical regions) started to be painful.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在互联网出现之前，这种不兼容性并不是一个大问题，因为那时文档是通过计算机在全球范围内大量共享的。在那个时刻，独立构思的编码方案之间的不兼容性（例如，国家和地理区域）开始变得痛苦。
- en: It was the perfect moment for the Unicode Consortium to be created.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Unicode联盟成立的完美时机。
- en: Unicode
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unicode
- en: In a nutshell, Unicode ([https://unicode-table.com/en/](https://unicode-table.com/en/))
    is a universal encoding standard capable of encoding/decoding every possible character
    in the world (we are talking about hundreds of thousands of characters).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Unicode ([https://unicode-table.com/en/](https://unicode-table.com/en/))
    是一种通用的编码标准，能够编码/解码世界上所有可能的字符（我们说的是数十万个字符）。
- en: Unicode needs more bytes to represent all these characters. But, Unicode didn’t
    get involved in this representation. It just assigned a number to each character.
    This number is named a *code point*. For instance, the letter *A* in Unicode is
    associated with the code point 65 in decimal, and we refer to it as U+0041\. This
    is the constant U+ followed by 65 in hexadecimal. As you can see, in Unicode,
    *A* is 65, exactly as in the ASCII encoding. In other words, Unicode is backward
    compatible with ASCII. As you’ll see soon, this is big, so keep it in mind!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode需要更多的字节来表示所有这些字符。但是，Unicode并没有涉及这种表示。它只是为每个字符分配了一个数字。这个数字被称为*代码点*。例如，Unicode中的字母*A*与十进制的65相关联，我们称之为U+0041。这是以U+开头，后面跟着65的十六进制数。正如你所看到的，在Unicode中，*A*是65，这与ASCII编码中的相同。换句话说，Unicode与ASCII向后兼容。正如你很快就会看到的，这是一个很大的问题，所以请记住这一点！
- en: 'Early versions of Unicode contain characters having code points less than 65,535
    (0xFFFF). Java represents these characters via the 16-bit `char` data type. For
    instance, the French ![](img/B19665_02_004.png) (*e* with circumflex) is associated
    with the Unicode 234 decimal or U+00EA hexadecimal. In Java, we can use `charAt()`
    to reveal this for any Unicode character less than 65,535:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode的早期版本包含小于65,535（0xFFFF）的代码点。Java通过16位的`char`数据类型来表示这些字符。例如，法语中的 ![](img/B19665_02_004.png)
    (*e* with circumflex) 与Unicode 234十进制或U+00EA十六进制相关联。在Java中，我们可以使用`charAt()`来揭示任何小于65,535的Unicode字符：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also may see the binary representation of this character:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能看到这个字符的二进制表示：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Later, Unicode added more and more characters up to 1,114,112 (0x10FFFF). Obviously,
    the 16-bit Java `char` was not enough to represent these characters, and calling
    `charAt()` was not useful anymore.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，Unicode添加了越来越多的字符，直到1,114,112（0x10FFFF）。显然，16位的Java `char`不足以表示这些字符，调用`charAt()`也不再有用。
- en: '**Important note**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Java 19+ supports Unicode 14.0\. The `java.lang.Character` API supports Level
    14 of the **Unicode Character Database** (**UCD**). In numbers, we have 47 new
    emojis, 838 new characters, and 5 new scripts. Java 20+ supports Unicode 15.0,
    which means 4,489 new characters for `java.lang.Character`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java 19+ 支持 Unicode 14.0。`java.lang.Character` API 支持 **Unicode 字符数据库**（**UCD**）的第
    14 级。具体来说，我们有 47 个新的表情符号，838 个新的字符和 5 个新的脚本。Java 20+ 支持 Unicode 15.0，这意味着 `java.lang.Character`
    将有 4,489 个新的字符。
- en: In addition, JDK 21 has added a set of methods especially for working with emojis
    based on their code point. Among these methods, we have `boolean isEmoji(int codePoint)`,
    `boolean isEmojiPresentation(int codePoint)`, `boolean isEmojiModifier(int codePoint)`,
    `boolean isEmojiModifierBase(int` `codePoint)`, `boolean isEmojiComponent(int
    codePoint)`, and `boolean isExtendedPictographic(int codePoint)`. In the bundled
    code, you can find a small application showing you how to fetch all available
    emojis and check if a given string contains emoji. So, we can easily obtain the
    code point of a character via `Character.codePointAt()` and pass it as an argument
    to these methods to determine whether the character is an emoji or not.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JDK 21 增加了一组专门用于基于其代码点处理表情符号的方法。在这些方法中，我们有 `boolean isEmoji(int codePoint)`、`boolean
    isEmojiPresentation(int codePoint)`、`boolean isEmojiModifier(int codePoint)`、`boolean
    isEmojiModifierBase(int codePoint)`、`boolean isEmojiComponent(int codePoint)`
    和 `boolean isExtendedPictographic(int codePoint)`。在捆绑的代码中，你可以找到一个小的应用程序，展示如何获取所有可用的表情符号并检查给定的字符串是否包含表情符号。因此，我们可以通过
    `Character.codePointAt()` 获取字符的代码点，并将其作为参数传递给这些方法，以确定字符是否为表情符号。
- en: However, Unicode doesn’t get involved in how these code points are encoded into
    bits. This is the job of special encoding schemes within Unicode, such as the
    **Unicode Transformation Format** (**UTF**) schemes. Most commonly, we use UTF-32,
    UTF-16, and UTF-8.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Unicode 并不涉及这些代码点如何编码成比特。这是 Unicode 内部特殊编码方案的工作，例如 **Unicode 转换格式**（**UTF**）方案。最常见的是使用
    UTF-32、UTF-16 和 UTF-8。
- en: UTF-32
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UTF-32
- en: 'UTF-32 is an encoding scheme for Unicode that represents every code point on
    4 bytes (32 bits). For instance, the letter *A* (having code point 65), which
    can be encoded on a 7-bit system, is encoded in UTF-32 as in the following figure
    next to the other two characters:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-32 是一种用于 Unicode 的编码方案，它使用 4 个字节（32 位）来表示每个代码点。例如，字母 *A*（代码点为 65），在 7 位系统中可以编码，在
    UTF-32 中的编码方式如下所示，位于其他两个字符旁边：
- en: '![Figure 2.4.png](img/B19665_02_04.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.4.png](img/B19665_02_04.png)'
- en: 'Figure 2.4: Three characters sample encoded in UTF-32'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 2.4: UTF-32 中编码的三个字符示例'
- en: As you can see in *Figure 2.4*, UTF-32 uses 4 bytes (fixed length) to represent
    every character. In the case of the letter *A*, we see that UTF-32 wasted 3 bytes
    of memory. This means that converting an ASCII file to UTF-32 will increase its
    size by 4 times (for instance, a 1KB ASCII file is a 4KB UTF-32 file). Because
    of this shortcoming, UTF-32 is not very popular.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 *Figure 2.4* 中所见，UTF-32 使用 4 个字节（固定长度）来表示每个字符。在字母 *A* 的例子中，我们看到 UTF-32 浪费了
    3 个字节的内存。这意味着将 ASCII 文件转换为 UTF-32 将使其大小增加 4 倍（例如，1KB 的 ASCII 文件将变成 4KB 的 UTF-32
    文件）。正因为这个缺点，UTF-32 并不太受欢迎。
- en: Java doesn’t support UTF-32 as a standard charset but it relies on *surrogate
    pairs* (introduced in the next section).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Java 不支持 UTF-32 作为标准字符集，但它依赖于 *代理对*（将在下一节中介绍）。
- en: UTF-16
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UTF-16
- en: 'UTF-16 is an encoding scheme for Unicode that represents every code point on
    2 or 4 bytes (not on 3 bytes). UTF-16 has a variable length and uses an optional
    **Byte-Order Mark** (**BOM**), but it is recommended to use UTF-16BE (BE stands
    for Big-Endian byte order), or UTF-16LE (LE stands for Little-Endian byte order).
    While more details about Big-Endian vs. Little-Endian are available at [https://en.wikipedia.org/wiki/Endianness](https://en.wikipedia.org/wiki/Endianness),
    the following figure reveals how the orders of bytes differ in UTF-16BE (left
    side) vs. UTF-16LE (right side) for three characters:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16 是一种用于 Unicode 的编码方案，它使用 2 或 4 个字节（而不是 3 个字节）来表示每个代码点。UTF-16 具有可变长度，并使用可选的
    **字节顺序标记**（**BOM**），但建议使用 UTF-16BE（BE 代表大端字节顺序），或 UTF-16LE（LE 代表小端字节顺序）。虽然有关大端与小端更详细的信息可在
    [https://en.wikipedia.org/wiki/Endianness](https://en.wikipedia.org/wiki/Endianness)
    找到，但以下图示揭示了 UTF-16BE（左侧）与 UTF-16LE（右侧）在三个字符中的字节顺序差异：
- en: '![Figure 2.5.png](img/B19665_02_05.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.5.png](img/B19665_02_05.png)'
- en: 'Figure 2.5: UTF-16BE (left side) vs. UTF-16LE (right side)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 2.5: UTF-16BE（左侧）与 UTF-16LE（右侧）'
- en: 'Since the figure is self-explanatory, let’s move forward. Now, we have to tackle
    a trickier aspect of UTF-16\. We know that in UTF-32, we take the *code point*
    and transform it into a 32-bit number and that’s it. But, in UTF-16, we can’t
    do that every time because we have code points that don’t accommodate 16 bits.
    This being said, UTF-16 uses the so-called 16-bit *code units*. It can use 1 or
    2 *code units* per *code point*. There are three types of code units, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图示已经足够说明，让我们继续前进。现在，我们必须处理 UTF-16 的一个更复杂的问题。我们知道在 UTF-32 中，我们将 *码点* 转换为一个
    32 位的数字，然后就这样了。但在 UTF-16 中，我们并不能每次都这样做，因为有些码点无法适应 16 位。话虽如此，UTF-16 使用所谓的 16 位
    *码单元*。它可以使用 1 或 2 个 *码单元* 来表示一个 *码点*。有三种类型的码单元，如下所示：
- en: 'A code point needs a single code unit: these are 16-bit code units (covering
    U+0000 to U+D7FF, and U+E000 to U+FFFF)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个码点需要一个单个码单元：这些是 16 位码单元（覆盖 U+0000 到 U+D7FF，和 U+E000 到 U+FFFF）
- en: 'A code point needs 2 code units:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个码点需要 2 个码单元：
- en: The first code unit is named *high surrogate* and it covers 1,024 values (U+D800
    to U+DBFF)
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个码单元被称为 *高代理*，它覆盖了 1,024 个值（U+D800 到 U+DBFF）
- en: The second code unit is named *low surrogate* and it covers 1,024 values (U+DC00
    to U+DFFF)
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个码单元被称为 *低代理*，它覆盖了 1,024 个值（U+DC00 到 U+DFFF）
- en: A *high surrogate* followed by a *low surrogate* is named a *surrogate pair*.
    Surrogate pairs are needed to represent the so-called *supplementary* Unicode
    characters or characters having a code point larger than 65,535 (0xFFFF).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *高代理* 后跟一个 *低代理* 被称为 *代理对*。代理对用于表示所谓的 *补充* Unicode 字符或码点大于 65,535（0xFFFF）的字符。
- en: 'Characters such as the letter A (65) or the Chinese ![](img/B19665_02_005.png)
    (26263) have a code point that can be represented via a single code unit. The
    following figure shows these characters in UTF-16BE:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像字母 A (65) 或中文 ![img/B19665_02_005.png](img/B19665_02_005.png) (26263) 这样的字符，它们的码点可以通过单个码单元来表示。以下图示展示了这些字符在
    UTF-16BE 中的表示：
- en: '![Figure 2.6.png](img/B19665_02_06.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.6.png](img/B19665_02_06.png)'
- en: 'Figure 2.6: UTF-16 encoding of A and ![](img/B19665_02_006.png)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：A 和 ![img/B19665_02_006.png](img/B19665_02_006.png) 的 UTF-16 编码
- en: 'This was easy! Now, let’s consider the following figure (encoding of Unicode,
    *Smiling Face with Heart-Shaped Eyes*):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！现在，让我们考虑以下图示（Unicode 的编码，*带心形眼的笑脸*）：
- en: '![Figure 2.7.png](img/B19665_02_07.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.7.png](img/B19665_02_07.png)'
- en: 'Figure 2.7: UTF-16 encoding using a surrogate pair'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：使用代理对的 UTF-16 编码
- en: The character from this figure has a code point of 128525 (or, 1 F60D) and is
    represented on 4 bytes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图中这个字符的码点是 128525（或，1 F60D），并且用 4 个字节来表示。
- en: 'Check the first byte: the sequence of 6 bits, 110110, identifies a high surrogate.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 检查第一个字节：6 位序列 110110 识别了一个高代理。
- en: 'Check the third byte: the sequence of 6 bits, 110111, identifies a low surrogate.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 检查第三个字节：6 位序列 110111 识别了一个低代理。
- en: 'These 12 bits (identifying the high and low surrogates) can be dropped and
    we keep the rest of the 20 bits: 00001111011000001101\. We can compute this number
    as 2⁰ + 2² + 2³ + 2⁹ + 2^(10) + 2^(12) + 2^(13) + 2^(14) + 2^(15) = 1 + 4 + 8
    + 512 + 1024 + 4096 + 8192 + 16384 + 32768 = 62989 (or, the hexadecimal, F60D).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这 12 位（标识高代理和低代理）可以被丢弃，我们保留剩下的 20 位：00001111011000001101。我们可以将这个数字计算为 2⁰ + 2²
    + 2³ + 2⁹ + 2^(10) + 2^(12) + 2^(13) + 2^(14) + 2^(15) = 1 + 4 + 8 + 512 + 1024
    + 4096 + 8192 + 16384 + 32768 = 62989（或，十六进制，F60D）。
- en: Finally, we have to compute F60D + 0x10000 = 1 F60D, or in decimal 62989 + 65536
    = 128525 (the code point of this Unicode character). We have to add 0x10000 because
    the characters that use 2 code units(a surrogate pair) are always of form 1 F…
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须计算 F60D + 0x10000 = 1 F60D，或者用十进制表示为 62989 + 65536 = 128525（这个 Unicode
    字符的码点）。我们必须加上 0x10000，因为使用 2 个码单元（代理对）的字符总是形式为 1 F…
- en: Java supports UTF-16, UTF-16BE, and UTF-16LE. Actually, UTF-16 is the native
    character encoding for Java.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Java 支持 UTF-16、UTF-16BE 和 UTF-16LE。实际上，UTF-16 是 Java 的原生字符编码。
- en: UTF-8
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UTF-8
- en: UTF-8 is an encoding scheme for Unicode that represents every code point on
    1, 2, 3, or 4 bytes. Having this 1- to 4-byte flexibility, UTF-8 uses space in
    a very efficient way.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 是一种 Unicode 编码方案，它使用 1、2、3 或 4 个字节来表示每个码点。有了这种 1 到 4 字节的灵活性，UTF-8 以非常高效的方式使用空间。
- en: '**Important note**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: UTF-8 is the most popular encoding scheme that dominates the Internet and applications.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 是最流行的编码方案，它主导着互联网和应用程序。
- en: 'For instance, we know that the code point of the letter A is 65 and it can
    be encoded using a 7-bit binary representation. The following figure represents
    this letter encoded in UTF-8:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们知道字母 A 的码点是 65，它可以使用 7 位二进制表示来编码。以下图示展示了这个字母在 UTF-8 中的编码：
- en: '![Figure 2.8.png](img/B19665_02_08.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.8.png](img/B19665_02_08.png)'
- en: 'Figure 2.8: Letter A encoded in UTF-8'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：字母 A 以 UTF-8 编码
- en: 'This is very cool! UTF-8 has used a single byte to encode A. The first (leftmost)
    0 signals that this is a single-byte encoding. Next, let’s see the Chinese character,
    ![](img/B19665_02_007.png):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常酷！UTF-8 使用单个字节来编码 A。第一个（最左边的）0 表示这是一个单字节编码。接下来，让我们看看中文字符，![](img/B19665_02_007.png)：
- en: '![Figure 2.9.png](img/B19665_02_09.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.9.png](img/B19665_02_09.png)'
- en: 'Figure 2.9: Chinese character, ![](img/B19665_02_006.png), encoded in UTF-8'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：中文字符，![](img/B19665_02_006.png)，以 UTF-8 编码
- en: The code point of ![](img/B19665_02_007.png) is 26263, so UTF-8 uses 3 bytes
    to represent it. The first byte contains 4 bits (1110) that signal that this is
    a 3-byte encoding. The next two bytes start with 2 bits of 10\. All these 8 bits
    can be dropped and we keep only the remaining 16 bits, which gives us the expected
    code point.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B19665_02_007.png) 的代码点是 26263，所以 UTF-8 使用 3 个字节来表示它。第一个字节包含 4 位（1110），表示这是一个
    3 字节编码。接下来的两个字节以 2 位 10 开头。所有这些 8 位都可以丢弃，我们只保留剩下的 16 位，这给我们期望的代码点。'
- en: 'Finally, let’s tackle the following figure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们处理以下图：
- en: '![Figure 2.10.png](img/B19665_02_10.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.10.png](img/B19665_02_10.png)'
- en: 'Figure 2.10: UTF-8 encoding with 4 bytes'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：使用 4 个字节的 UTF-8 编码
- en: This time, the first byte signals that this is a 4-byte encoding via 11110\.
    The remaining 3 bytes start with 10\. All these 11 bits can be dropped and we
    keep only the remaining 21 bits, 000011111011000001101, which gives us the expected
    code point, 128525.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，第一个字节通过 11110 表示这是一个 4 字节编码。接下来的 3 个字节以 10 开头。所有这些 11 位都可以丢弃，我们只保留剩下的 21
    位，000011111011000001101，这给我们期望的代码点，128525。
- en: 'In the following figure you can see the UTF-8 template used for encoding Unicode
    characters:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到用于编码 Unicode 字符的 UTF-8 模板：
- en: '![Figure 2.11.png](img/B19665_02_11.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.11.png](img/B19665_02_11.png)'
- en: 'Figure 2.11: UTF-8 template used for encoding Unicode characters'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：用于编码 Unicode 字符的 UTF-8 模板
- en: Did you know that 8 zeros in a row (00000000 – U+0000) are interpreted as NULL?
    A NULL represents the end of the string, so sending it “accidentally” will be
    a problem because the remaining string will not be processed. Fortunately, UTF-8
    prevents this issue, and sending a NULL can be done only if we effectively send
    the U+0000 code point.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？一串连续的 8 个零（00000000 – U+0000）被解释为 NULL？NULL 表示字符串的结尾，所以“意外”发送它将是一个问题，因为剩余的字符串将不会被处理。幸运的是，UTF-8
    防止了这个问题，并且只有当我们有效地发送 U+0000 代码点时，才能发送 NULL。
- en: Java and Unicode
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 和 Unicode
- en: 'As long as we use characters with code points less than 65,535 (0xFFFF), we
    can rely on the `charAt()` method to obtain the code point. Here are some examples:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们使用代码点小于 65,535（0xFFFF）的字符，我们就可以依赖 `charAt()` 方法来获取代码点。以下是一些示例：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Based on these examples, we may write a helper method that returns the binary
    representation of strings having code points less than 65,535 (0xFFFF) as follows
    (you already saw the imperative version of the following functional code earlier):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些示例，我们可能可以编写一个辅助方法，返回代码点小于 65,535（0xFFFF）的字符串的二进制表示，如下所示（你之前已经看到了以下功能代码的命令式版本）：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you run this code against a Unicode character having a code point greater
    than 65,535 (0xFFFF), then you’ll get the wrong result. You’ll not get an exception
    or any kind of warning.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用这个代码对代码点大于 65,535（0xFFFF）的 Unicode 字符进行操作，那么你会得到错误的结果。你不会得到异常或任何警告。
- en: 'So, `charAt()` covers only a subset of Unicode characters. For covering all
    Unicode characters, Java provides an API that consists of several methods. For
    instance, if we replace `charAt()` with `codePointAt()`, then we obtain the correct
    code point in all cases, as you can see in the following figure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`charAt()` 只覆盖了 Unicode 字符的一个子集。为了覆盖所有 Unicode 字符，Java 提供了一个由几个方法组成的 API。例如，如果我们用
    `codePointAt()` 替换 `charAt()`，那么在所有情况下我们都会得到正确的代码点，如下图所示：
- en: '![Figure 2.12.png](img/B19665_02_12.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.12.png](img/B19665_02_12.png)'
- en: 'Figure 2.12: charAt() vs. codePointAt()'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12：charAt() 与 codePointAt()
- en: 'Check out the last example, `c2`. Since `codePointAt()` returns the correct
    code point (128525), we can obtain the binary representation as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 查看最后一个例子，`c2`。由于 `codePointAt()` 返回正确的代码点（128525），我们可以得到以下二进制表示：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, if we need a method that returns the binary encoding of any Unicode character,
    then we can replace the `chars()` call with the `codePoints()` call. The `codePoints()`
    method returns the code points of the given sequence:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们需要一个返回任何 Unicode 字符的二进制编码的方法，那么我们可以将 `chars()` 调用替换为 `codePoints()` 调用。`codePoints()`
    方法返回给定序列的代码点：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `codePoints()` method is just one of the methods provided by Java to work
    around code points. The Java API also includes `codePointAt()`, `offsetByCodePoints()`,
    `codePointCount()`, `codePointBefore()`, `codePointOf()`, and so on. You can find
    several examples of them in the bundled code next to this one for obtaining a
    `String` from a given code point:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`codePoints()` 方法只是 Java 提供的用于处理代码点的方法之一。Java API 还包括 `codePointAt()`、`offsetByCodePoints()`、`codePointCount()`、`codePointBefore()`、`codePointOf()`
    等等。您可以在与这个示例相邻的捆绑代码中找到它们的几个示例，用于从给定的代码点获取 `String`：'
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `toChars()` method gets a code point and returns the UTF-16 representation
    via a `char[]`. The string returned by the first example (`str1`) has a length
    of 1 and is the letter A. The second example returns a string of length 2 since
    the character having the code point 128525 needs a surrogate pair. The returned
    `char[]` contains both the high and low surrogates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`toChars()` 方法获取一个代码点并通过 `char[]` 返回 UTF-16 表示。第一个示例（`str1`）返回的字符串长度为 1，是字母
    A。第二个示例返回长度为 2 的字符串，因为具有代码点 128525 的字符需要一个代理对。返回的 `char[]` 包含高代理和低代理。'
- en: 'Finally, let’s have a helper method that allows us to obtain the binary representation
    of a string for a given encoding scheme:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们有一个辅助方法，它允许我们获取给定编码方案的字符串的二进制表示：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using this method is quite simple, as you can see in the following examples:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法非常简单，如下面的示例所示：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can practice more examples in the bundled code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在捆绑代码中练习更多示例。
- en: JDK 18 defaults the charset to UTF-8
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JDK 18 默认字符集为 UTF-8
- en: Before JDK 18, the default charset was determined based on the operating system
    charset and locale (for instance, on a Windows machine, it could be windows-1252).
    Starting with JDK 18, the default charset is UTF-8 (`Charset.defaultCharset()`
    returns the string, UTF-8). Or, having a `PrintStream` instance, we can find out
    the used charset via the `charset()` method (starting with JDK 18).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 18 之前，默认字符集是根据操作系统字符集和区域设置确定的（例如，在 Windows 机器上，它可能是 windows-1252）。从 JDK
    18 开始，默认字符集是 UTF-8（`Charset.defaultCharset()` 返回字符串，UTF-8）。或者，如果我们有一个 `PrintStream`
    实例，我们可以通过 `charset()` 方法（从 JDK 18 开始）找出使用的字符集。
- en: 'But, the default charset can be explicitly set via the `file.encoding` and
    `native.encoding` system properties at the command line. For instance, you may
    need to perform such modification to compile legacy code developed before JDK
    18:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，可以通过命令行中的 `file.encoding` 和 `native.encoding` 系统属性显式设置默认字符集。例如，您可能需要执行以下修改来编译在
    JDK 18 之前开发的旧代码：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, since JDK 18, classes that use encoding (for instance, `FileReader`/`FileWriter`,
    `InputStreamReader`/`OutputStreamWriter`, `PrintStream`, `Formatter`, `Scanner`,
    and `URLEncoder`/`URLDecoder`) can take advantage of UTF-8 out of the box. For
    instance, using UTF-8 before JDK 18 for reading a file can be accomplished by
    explicitly specifying this charset encoding scheme as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从 JDK 18 开始，使用编码的类（例如，`FileReader`/`FileWriter`、`InputStreamReader`/`OutputStreamWriter`、`PrintStream`、`Formatter`、`Scanner`
    和 `URLEncoder`/`URLDecoder`）可以默认使用 UTF-8。例如，在 JDK 18 之前使用 UTF-8 读取文件可以通过显式指定以下字符集编码方案来完成：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Accomplishing the same thing in JDK 18+ doesn’t require explicitly specifying
    the charset encoding scheme:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 18+ 中完成相同的事情不需要显式指定字符集编码方案：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, for `System.out` and `System.err`, JDK 18+ still uses the default
    system charset. So, if you are using `System.out`/`err` and you see question marks
    (?) instead of the expected characters, then most probably you should set UTF-8
    via the new properties `-Dstdout.encoding` and `-Dstderr.encoding`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 `System.out` 和 `System.err`，JDK 18+ 仍然使用默认的系统字符集。所以，如果您正在使用 `System.out`/`err`
    并且看到问号 (?) 而不是预期的字符，那么您很可能会通过新的属性 `-Dstdout.encoding` 和 `-Dstderr.encoding` 将
    UTF-8 设置为：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or, you can set them as environment variables to set them globally:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将它们设置为环境变量以全局设置：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the bundled code you can see more examples.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑代码中您可以看到更多示例。
- en: 39\. Checking a sub-range in the range from 0 to length
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 39. 检查从 0 到长度的范围内的子范围
- en: Checking that a given sub-range is in the range from 0 to the given length is
    a common check in a lot of problems. For instance, let’s consider that we have
    to write a function responsible for checking if the client can increase the pressure
    in a water pipe. The client gives us the current average pressure (`avgPressure`),
    the maximum pressure (`maxPressure`), and the amount of extra pressure that should
    be applied (`unitsOfPressure`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 检查给定的子范围是否在从 0 到给定长度的范围内是许多问题中的常见检查。例如，让我们考虑我们必须编写一个函数来检查客户是否可以增加水管中的压力。客户给我们当前的平均压力（`avgPressure`）、最大压力（`maxPressure`）和应该施加的额外压力量（`unitsOfPressure`）。
- en: 'But, before we can apply our secret algorithm, we have to check that the inputs
    are correct. So, we have to ensure that none of the following cases happens:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在我们应用我们的秘密算法之前，我们必须检查输入是否正确。因此，我们必须确保以下情况都不会发生：
- en: '`avgPressure` is less than 0'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`avgPressure` 小于 0'
- en: '`unitsOfPressure` is less than 0'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unitsOfPressure` 小于 0'
- en: '`maxPressure` is less than 0'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxPressure` 小于 0'
- en: The range [`avgPressure`, `avgPressure` + `unitsOfPressure`) is out of bounds
    represented by `maxPressure`
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围 `[avgPressure, avgPressure + unitsOfPressure)` 超出了由 `maxPressure` 表示的界限
- en: 'So, in code lines, our function may look as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在代码行中，我们的函数可能看起来如下：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Writing composite conditions such as ours is prone to accidental mistakes.
    It is better to rely on the Java API whenever possible. And, for this use case,
    it is possible! Starting with JDK 9, in `java.util.Objects`, we have the method
    `checkFromIndexSize(int fromIndex, int size, int length)`, and starting with JDK
    16, we also have a flavor for `long` arguments, `checkFromIndexSize(int fromIndex,
    int size, int length)`. If we consider that `avgPressure` is `fromIndex`, `unitsOfPressure`
    is `size`, and `maxPressure` is `length`, then `checkFromIndexSize()` performs
    the arguments validation and throws an `IndexOutOfBoundsException` if something
    goes wrong. So, we write the code as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编写类似于我们这样的复合条件容易出错。尽可能依靠 Java API 会更好。而且，对于这个用例，这是可能的！从 JDK 9 开始，在 `java.util.Objects`
    中，我们有了 `checkFromIndexSize(int fromIndex, int size, int length)` 方法，从 JDK 16 开始，我们也为
    `long` 参数提供了类似的方法，`checkFromIndexSize(int fromIndex, int size, int length)`。如果我们考虑
    `avgPressure` 是 `fromIndex`，`unitsOfPressure` 是 `size`，而 `maxPressure` 是 `length`，那么
    `checkFromIndexSize()` 执行参数验证，如果出现问题则抛出 `IndexOutOfBoundsException`。因此，我们编写代码如下：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the code bundle, you can see one more example of using `checkFromIndexSize()`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码包中，你可以看到使用 `checkFromIndexSize()` 的另一个示例。
- en: Besides `checkFromIndexSize()`, in `java.util.Objects`, we can find several
    other companions that cover common composite conditions such as `checkIndex(int
    index, int length)` – JDK 9, `checkIndex(long index, long length)` – JDK 16, `checkFromToIndex(int
    fromIndex, int toIndex, int length)` – JDK 9, and `checkFromToIndex(long fromIndex,
    long toIndex, long length)` – JDK 16.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `checkFromIndexSize()`，在 `java.util.Objects` 中，我们还可以找到其他几个伴侣，它们涵盖了常见的复合条件，如
    `checkIndex(int index, int length)` – JDK 9，`checkIndex(long index, long length)`
    – JDK 16，`checkFromToIndex(int fromIndex, int toIndex, int length)` – JDK 9，以及
    `checkFromToIndex(long fromIndex, long toIndex, long length)` – JDK 16。
- en: And, by the way, if we switch the context to strings, then JDK 21 provides an
    overload of the well-known `String.indexOf()`, capable of searching a character/substring
    in a given string between a given begin index and end index. The signature is
    `indexOf(String str, int beginIndex, int endIndex)` and it returns the index of
    the first occurrence of `str`, or -1 if `str` is not found. Basically, this is
    a neat version of `s.substring(beginIndex, endIndex).indexOf(str) + beginIndex`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果我们切换到字符串上下文，那么 JDK 21 提供了知名 `String.indexOf()` 方法的重载，能够在给定的字符串中搜索一个字符/子字符串，在给定的开始索引和结束索引之间。其签名是
    `indexOf(String str, int beginIndex, int endIndex)`，它返回 `str` 的首次出现索引，如果 `str`
    未找到则返回 -1。基本上，这是一个 `s.substring(beginIndex, endIndex).indexOf(str) + beginIndex`
    的整洁版本。
- en: 40\. Returning an identity string
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 40. 返回一个身份字符串
- en: 'So, what’s an *identity string*? An identity string is a string built from
    an object without calling the overridden `toString()` or `hashCode()`. It is equivalent
    to the following concatenation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是 *身份字符串*？身份字符串是从对象构建的字符串，而不调用重写的 `toString()` 或 `hashCode()`。它等同于以下连接：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Starting with JDK 19, this string is wrapped in `Objects.toIdentityString(Object
    object)`. Consider the following class (`object`):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 19 开始，这个字符串被包装在 `Objects.toIdentityString(Object object)` 中。考虑以下类（`object`）：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By calling `toIdentityString()`, we obtain something as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `toIdentityString()`，我们得到如下内容：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Obviously, the overridden `MyPoint.toString()` method was not called. If we
    print out the hash code of `p`, we get `76ed5528`, which is exactly what `toIdentityString()`
    returned. Now, let’s override `hashCode()` as well:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，重写的`MyPoint.toString()`方法没有被调用。如果我们打印出`p`的哈希码，我们得到`76ed5528`，这正是`toIdentityString()`返回的。现在，让我们也重写`hashCode()`：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This time, `toIdentityString()` returns the same thing, while our `hashCode()`
    returns `14ef3`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`toIdentityString()`返回相同的内容，而我们的`hashCode()`返回`14ef3`。
- en: 41\. Hooking unnamed classes and instance main methods
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 41. 钩子匿名类和实例主方法
- en: 'Imagine that you have to initiate a student in Java. The classical approach
    of introducing Java is to show the student a *Hello World!* Example, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你必须向学生介绍Java。介绍Java的经典方法是通过展示一个*Hello World!*示例，如下所示：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the simplest Java example but it is not simple to explain to the student
    what `public` or `static` or `String[]` are. The ceremony involved in this simple
    example may scare the student – *if this is a simple example, then how is it a
    more complex one*?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的Java示例，但向学生解释`public`、`static`或`String[]`等概念并不简单。这个简单示例中涉及的仪式可能会让学生感到害怕——*如果这是一个简单示例，那么更复杂的示例又是怎样的呢*？
- en: 'Fortunately, starting with JDK 21 (JEP 445), we have *instance main methods*,
    which is a preview feature that allows us to shorten the previous example as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，从JDK 21（JEP 445）开始，我们有了*实例主方法*，这是一个预览功能，允许我们将之前的示例缩短如下：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can even go further and remove the explicit class declaration as well. This
    feature is known as *unnamed classes*. An unnamed class resides in the unnamed
    package that resides in the unnamed module:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更进一步，移除显式的类声明。这个特性被称为*匿名类*。匿名类位于匿名包中，而匿名包位于匿名模块中：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Java will generate the class on our behalf. The name of the class will be the
    same as the name of the source file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Java会代表我们生成类。类的名称将与源文件名称相同。
- en: That’s all we need to introduce Java to a student. I strongly encourage you
    to read JEP 445 (and the new JEPs that will continue this JDK 21 preview feature
    work) to discover all the aspects involved in these features.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们向学生介绍Java所需的所有内容。我强烈建议你阅读JEP 445（以及将继续进行JDK 21预览功能工作的新JEPs），以了解这些功能的所有方面。
- en: 42\. Adding code snippets in Java API documentation
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 42. 在Java API文档中添加代码片段
- en: I’m sure that you are familiar with generating **Java API documentation** (**Javadoc**)
    for your projects. We can do it via the `javadoc` tool from the command line,
    via IDE support, via the Maven plugin (`maven-javadoc-plugin`), and so on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你熟悉为你的项目生成**Java API文档**（**Javadoc**）。我们可以通过命令行的`javadoc`工具、IDE支持、Maven插件（`maven-javadoc-plugin`）等方式来完成。
- en: 'A common case in writing the Javadoc consists of adding snippets of code to
    exemplify the usage of a non-trivial class or method. Before JDK 18, adding snippets
    of code in documentation can be done via `{@code...}` or the `<pre>` tag. The
    added code is treated as plain text, is not validated for correctness, and is
    not discoverable by other tools. Let’s quickly see an example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Javadoc时，一个常见的做法是添加代码片段来举例说明非平凡类或方法的使用。在JDK 18之前，可以在文档中通过`{@code...}`或`<pre>`标签添加代码片段。添加的代码被视为纯文本，不会进行正确性验证，并且不会被其他工具发现。让我们快速看一个例子：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the bundled code, you can see the full example. The Javadoc is generated
    at build time via the Maven plugin (`maven-javadoc-plugin`), so simply trigger
    a build.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到完整的示例。Javadoc是在构建时通过Maven插件（`maven-javadoc-plugin`）生成的，因此只需简单地触发构建。
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A screenshot of the output is in the following figure:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了输出截图：
- en: '![Figure 2.13.png](img/B19665_02_13.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13.png](img/B19665_02_13.png)'
- en: 'Figure 2.13: Simple output from @snippet'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：@snippet的简单输出
- en: 'The effective code starts from the newline placed after the colon (`:`) and
    ends before the closing right curly bracket (`}`). The code indentation is treated
    as in code blocks, so the compiler removes the incidental white spaces and we
    can indent the code with respect to the closing right curly bracket (`}`). Check
    out the following figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有效代码从冒号后面的换行符开始，到关闭的右大括号`}`之前结束。代码缩进被处理为代码块中的缩进，因此编译器会移除意外的空白，我们可以根据关闭的右大括号`}`缩进代码。查看以下图示：
- en: '![Figure 2.14.png](img/B19665_02_14.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14.png](img/B19665_02_14.png)'
- en: 'Figure 2.14: Indentation of code snippets'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：代码片段的缩进
- en: In the top example, the closing right curly bracket is aligned under the opening
    left curly bracket, while in the bottom example, we shifted the closing right
    curly bracket to the right.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，关闭的右花括号与打开的左花括号对齐，而在下面的例子中，我们将关闭的右花括号移到了右边。
- en: Adding attributes
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加属性
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the generated HTML, you’ll easily identify this attribute as:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的HTML中，你可以轻松地识别这个属性为：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the code is a structured text such as a *properties* file, then you can
    follow this example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码是一个结构化文本，例如*属性*文件，那么你可以参考以下示例：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the generated HTML, you’ll have:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的HTML中，你将会有：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, let’s see how can we alter what is displayed in a snippet.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何改变片段中显示的内容。
- en: Using markup comments and regions
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标记注释和区域
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Highlighting
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 突出显示
- en: 'Highlighting a whole line can be done via `@highlight` without arguments, as
    in the following figure:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`@highlight`不带参数可以突出显示整行，如下面的图所示：
- en: '![Figure 2.15.png](img/B19665_02_15.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15.png](img/B19665_02_15.png)'
- en: 'Figure 2.15: Highlighting a whole line of code'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：突出显示整行代码
- en: As you can see in this figure, the first line of code was bolded.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，代码的第一行被加粗了。
- en: 'If we want to highlight multiple lines, then we can define *regions*. A region
    can be treated as anonymous or have an explicit name. An anonymous region is demarcated
    by the word `region` placed as an argument of the markup tag and the `@end` tag
    placed at the end of the region. Here is an example for highlighting two regions
    (an anonymous one and a named one (`R1`)):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想突出显示多行，则可以定义*区域*。区域可以被视为匿名或具有显式名称。匿名区域由作为标记标签参数放置的单词`region`和位于区域末尾的`@end`标签界定。以下是一个突出显示两个区域（一个匿名和一个名为`R1`的区域）的示例：
- en: '![Figure 2.16.png](img/B19665_02_16.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16.png](img/B19665_02_16.png)'
- en: 'Figure 2.16: Highlighting a block of code using regions'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：使用区域突出显示代码块
- en: 'Regular expressions allow us to highlight a certain part of the code. For instance,
    highlighting everything that occurs between quotes can be done via `@highlight
    regex=''".*"''`. Or, highlighting only the word *Calibrate* can be done via the
    `substring="Calibrate"` argument, as in the following figure:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式允许我们突出显示代码的某个部分。例如，通过`@highlight regex='".*"'`可以突出显示所有在引号之间发生的内容。或者，通过`substring="Calibrate"`参数，可以仅突出显示单词*Calibrate*，如下面的图所示：
- en: '![Figure 2.17.png](img/B19665_02_17.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17.png](img/B19665_02_17.png)'
- en: 'Figure 2.17: Highlighting only the word “Calibrate”'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：仅突出显示单词“Calibrate”
- en: Next, let’s talk about adding links in code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈如何在代码中添加链接。
- en: Linking
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Figure 2.18.png](img/B19665_02_18.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图2.18.png](img/B19665_02_18.png)'
- en: 'Figure 2.18: Adding links in code'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：在代码中添加链接
- en: Next, let’s see how we can modify the code’s text.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何修改代码的文本。
- en: Modifying the code’s text
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改代码的文本
- en: 'Sometimes we may need to alter the code’s text. For instance, instead of `Telemeter.Calibrate.at(0.00001,
    "HIGH");`, we want to render in documentation `Telemeter.Calibrate.at(eps, "HIGH");`.
    So, we need to replace `0.00001` with `eps`. This is the perfect job for the `@replace`
    tag. Common arguments include `substring="…"` (or, `regex="…"`) and `replacement="..."`.
    Here is the snippet:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要更改代码的文本。例如，我们不想用`Telemeter.Calibrate.at(0.00001, "HIGH");`，而想在文档中渲染`Telemeter.Calibrate.at(eps,
    "HIGH");`。因此，我们需要将`0.00001`替换为`eps`。这正是`@replace`标签的完美工作。常见的参数包括`substring="…"`（或，`regex="…"`）和`replacement="..."`。以下是一个片段：
- en: '![Figure 2.19.png](img/B19665_02_19.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图2.19.png](img/B19665_02_19.png)'
- en: 'Figure 2.19: Replacing the code’s text'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：替换代码的文本
- en: 'If you need to perform multiple replacements in a block of code, then rely
    on regions. In the following example, we apply a regular expression to a block
    of code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在代码块中执行多个替换，则依赖于区域。在以下示例中，我们对代码块应用正则表达式：
- en: '![Figure 2.20.png](img/B19665_02_20.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图2.20.png](img/B19665_02_20.png)'
- en: 'Figure 2.20: Applying multiple replacements via a simple regex and an anonymous
    region'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：通过简单的正则表达式和匿名区域应用多个替换
- en: If you need to perform more replacements on the same line, then just chain multiple
    `@replace` tags (this statement applies to all tags such as `@highlight`, `@link`,
    and so on).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在同一行上执行更多替换，则只需链式多个`@replace`标签（此声明适用于所有标签，如`@highlight`、`@link`等）。
- en: Using external snippets
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用外部片段
- en: So far, we have used only inlined snippets. But, there are scenarios when using
    inlined snippets is not a convenient approach (for instance, if we need to repeat
    some parts of the documentation) or it is not possible to use them (for instance,
    if we want to embed `/*…*/` comments, which cannot be added in inlined snippets).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了内联片段。但是，在某些情况下，使用内联片段并不是一个方便的方法（例如，如果我们需要重复文档中的某些部分）或者它们无法使用（例如，如果我们想嵌入`/*…*/`注释，这些注释不能添加在内联片段中）。
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![Figure 2.21.png](img/B19665_02_21.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图2.21.png](img/B19665_02_21.png)'
- en: 'Figure 2.21: External snippets in snippet-files'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：片段文件中的外部片段
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'But, we can also customize the place and folder name of external snippets.
    For instance, let’s place the external snippets in a folder named `snippet-src`,
    as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 但，我们也可以自定义外部片段的位置和文件夹名称。例如，让我们将外部片段放在名为`snippet-src`的文件夹中，如下所示：
- en: '![Figure 2.22.png](img/B19665_02_22.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图2.22.png](img/B19665_02_22.png)'
- en: 'Figure 2.22: External snippets in a custom folder and place'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：自定义文件夹中的外部片段和位置
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This path is relative to your machine, so feel free to adjust it accordingly
    in `pom.xml`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此路径相对于您的机器，因此您可以在`pom.xml`中相应地调整它。
- en: 'Next, `AtSnippet.txt` and `ParamDefaultSnippet.properties` can be loaded exactly
    as you saw earlier for `MainSnippet.txt`. However, loading Java sources, such
    as `DistanceSnippet.java`, can be done via `{@snippet class…}`, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`AtSnippet.txt`和`ParamDefaultSnippet.properties`可以像之前加载`MainSnippet.txt`时那样加载。然而，加载Java源代码，如`DistanceSnippet.java`，可以通过`{@snippet
    class…}`来完成，如下所示：
- en: '[PRE40]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'But, do not add explicitly the `.java` extension because you’ll get an error
    such as *file not found on source path or snippet path: DistanceSnippet/java.java*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 但，不要显式添加`.java`扩展名，因为你会得到一个错误，例如*在源路径或片段路径上找不到文件：DistanceSnippet/java.java*：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When using Java sources as external snippets, pay attention to the following
    note.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Java源代码作为外部片段时，请注意以下注意事项。
- en: '**Important note**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Regions in external snippets
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部片段中的区域
- en: 'The external snippets support regions via `@start region=…` and `@end region=…`.
    For instance, in `AtSnippet.txt`, we have the following region:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 外部片段支持通过`@start region=…`和`@end region=…`来指定区域。例如，在`AtSnippet.txt`中，我们有以下区域：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, if we load the region as:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们按如下方式加载区域：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We obtain only the code from the region without the text, *// This is an example
    used in the documentation*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只获取区域中的代码，而不包括文本，*// 这是在文档中使用的示例*。
- en: 'Here is another example of a properties file with two regions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个具有两个区域的属性文件示例：
- en: '[PRE45]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The region `dist` is used to show the default values for the arguments of the
    `distance()` method in the documentation:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 区域`dist`用于在文档中显示`distance()`方法参数的默认值：
- en: '![Figure 2.23.png](img/B19665_02_23.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图2.23.png](img/B19665_02_23.png)'
- en: 'Figure 2.23: Using the dist region'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23：使用dist区域
- en: 'And, the `at` region is used to show the default values for the arguments of
    the `at()` method in the documentation:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`at`区域用于在文档中显示`at()`方法参数的默认值：
- en: '![Figure 2.24.png](img/B19665_02_24.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图2.24.png](img/B19665_02_24.png)'
- en: 'Figure 2.24: Using the “at” region'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24：使用“at”区域
- en: 'In external snippets, we can use the same tags as in the inlined snippets.
    For instance, in the following figure, you can see the complete source of `AtSnippet.txt`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部片段中，我们可以使用与内联片段相同的标签。例如，在下面的图中，你可以看到`AtSnippet.txt`的完整源代码：
- en: '![Figure 2.25.png](img/B19665_02_25.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图2.25.png](img/B19665_02_25.png)'
- en: 'Figure 2.25: Source of AtSnippet.txt'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25：AtSnippet.txt的源代码
- en: Notice the presence of `@highlight` and `@replace`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`@highlight`和`@replace`的存在。
- en: '**Important note**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: Starting with JDK 19, the Javadoc search feature was also improved. In other
    words, JDK 19+ can generate a standalone search page for searching in the Javadoc
    API documentation. Moreover, the search syntax has been enhanced to support multiple
    search words.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 19开始，Javadoc搜索功能也得到了改进。换句话说，JDK 19+可以为Javadoc API文档生成一个独立的搜索页面。此外，搜索语法也得到了增强，以支持多个搜索词。
- en: You can practice these examples in the bundled code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中练习这些示例。
- en: 43\. Invoking default methods from Proxy instances
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 43. 从代理实例调用默认方法
- en: 'Starting with JDK 8, we can define `default` methods in interfaces. For instance,
    let’s consider the following interfaces (for brevity, all methods from these interfaces
    are declared as `default`):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 8开始，我们可以在接口中定义`default`方法。例如，让我们考虑以下接口（为了简洁，这些接口中的所有方法都被声明为`default`）：
- en: '![Figure 2.26.png](img/B19665_02_26.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图2.26.png](img/B19665_02_26.png)'
- en: 'Figure 2.26: Interfaces: Printable, Writable, Draft, and Book'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26：接口：Printable、Writable、Draft 和 Book
- en: Next, let’s assume that we want to use the Java Reflection API to invoke these
    default methods. As a quick reminder, the `Proxy` class goal is used to provide
    support for creating dynamic implementations of interfaces at runtime.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们想使用 Java 反射 API 来调用这些默认方法。作为一个快速提醒，`Proxy` 类的目的是在运行时提供创建接口动态实现的支撑。
- en: That being said, let’s see how we can use the Proxy API for calling our `default`
    methods.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们看看我们如何使用 Proxy API 来调用我们的 `default` 方法。
- en: JDK 8
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 8
- en: Calling a `default` method of an interface in JDK 8 relies on a little trick.
    Basically, we create from scratch a *package-private* constructor from the Lookup
    API. Next, we make this constructor accessible – this means that Java will not
    check the access modifiers to this constructor and, therefore, will not throw
    an `IllegalAccessException` when we try to use it. Finally, we use this constructor
    to wrap an instance of an interface (for instance, `Printable`) and use reflective
    access to the `default` methods declared in this interface.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 8 中调用接口的 `default` 方法依赖于一个小技巧。基本上，我们使用 Lookup API 从头创建一个 *包私有* 构造函数。接下来，我们使这个构造函数可访问——这意味着
    Java 不会检查此构造函数的访问修饰符，因此当我们尝试使用它时，不会抛出 `IllegalAccessException`。最后，我们使用这个构造函数来包装接口的一个实例（例如，`Printable`），并使用反射访问在此接口中声明的
    `default` 方法。
- en: 'So, in code lines, we can invoke the default method `Printable.print()` as
    follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在代码行中，我们可以如下调用默认方法 `Printable.print()`：
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, let’s focus on the `Writable` and `Draft` interfaces. `Draft` extends
    `Writable` and overrides the `default write()`method. Now, every time we explicitly
    invoke the `Writable.write()` method, we expect that the `Draft.write()` method
    is invoked automatically behind the scenes. A possible implementation looks as
    follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们专注于 `Writable` 和 `Draft` 接口。`Draft` 扩展了 `Writable` 并覆盖了 `default write()`
    方法。现在，每次我们显式调用 `Writable.write()` 方法时，我们期望在幕后自动调用 `Draft.write()` 方法。一个可能的实现如下：
- en: '[PRE47]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finally, let’s focus on the `Printable` and `Book` interfaces. `Book` extends
    `Printable` and doesn’t define any methods. So, when we call the inherited `print()`
    method, we expect that the `Printable.print()` method is invoked. While you can
    check this solution in the bundled code, let’s focus on the same tasks using JDK
    9+.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们专注于 `Printable` 和 `Book` 接口。`Book` 扩展了 `Printable` 并没有定义任何方法。因此，当我们调用继承的
    `print()` 方法时，我们期望调用 `Printable.print()` 方法。虽然你可以在捆绑的代码中检查此解决方案，但让我们专注于使用 JDK
    9+ 完成相同的任务。
- en: JDK 9+, pre-JDK 16
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 9+，JDK 16 之前
- en: As you just saw, before JDK 9, the Java Reflection API provides access to non-public
    class members. This means that external reflective code (for instance, third-party
    libraries) can have deep access to JDK internals. But, starting with JDK 9, this
    is not possible because the new module system relies on strong encapsulation.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在 JDK 9 之前，Java 反射 API 提供了对非公共类成员的访问。这意味着外部反射代码（例如，第三方库）可以深入访问 JDK 内部。但是，从
    JDK 9 开始，这是不可能的，因为新的模块系统依赖于强封装。
- en: 'For a smooth transition from JDK 8 to JDK 9, we can use the `--illegal-access`
    option. The values of this option range from `deny` (sustains strong encapsulation,
    so no illegal reflective code is permitted) to `permit` (the most relaxed level
    of strong encapsulation, allowing access to platform modules only from unnamed
    modules). Between `permit` (which is the default in JDK 9) and `deny`, we have
    two more values: `warn` and `debug`. However, `--illegal-access=permit;` support
    was removed in JDK 17.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 JDK 8 到 JDK 9 的平滑过渡，我们可以使用 `--illegal-access` 选项。此选项的值范围从 `deny`（保持强封装，因此不允许任何非法反射代码）到
    `permit`（最宽松的强封装级别，仅允许从未命名的模块访问平台模块）。在 `permit`（JDK 9 中的默认值）和 `deny` 之间，我们还有两个额外的值：`warn`
    和 `debug`。然而，`--illegal-access=permit;` 的支持已在 JDK 17 中移除。
- en: 'In this context, the previous code may not work in JDK 9+, or it might still
    work but you’ll see a warning such as *WARNING: An illegal reflective access operation
    has occurred*.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '在此上下文中，之前的代码可能在 JDK 9+ 中不起作用，或者可能仍然起作用，但你可能会看到如下警告：*WARNING: An illegal reflective
    access operation has occurred*。'
- en: But, we can “fix” our code to avoid illegal reflective access via `MethodHandles`.
    Among its goodies, this class exposes lookup methods for creating method handles
    for fields and methods. Once we have a `Lookup`, we can rely on its `findSpecial()`
    method to gain access to the `default` methods of an interface.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以通过`MethodHandles`“修复”我们的代码以避免非法反射访问。在其优点中，这个类公开了用于创建字段和方法方法句柄的查找方法。一旦我们有了`Lookup`，我们就可以依赖其`findSpecial()`方法来访问接口的`default`方法。
- en: 'Based on `MethodHandles`, we can invoke the default method `Printable.print()`
    as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`MethodHandles`，我们可以如下调用默认方法`Printable.print()`：
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: While in the bundled code, you can see more examples; let’s tackle the same
    topic starting with JDK 16.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在捆绑的代码中你可以看到更多示例；但让我们从JDK 16开始探讨相同的话题。
- en: JDK 16+
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 16+
- en: 'Starting with JDK 16, we can simplify the previous code thanks to the new static
    method, `InvocationHandler.invokeDefault()`. As its name suggests, this method
    is useful for invoking `default` methods. In code lines, our previous examples
    for calling `Printable.print()` can be simplified via `invokeDefault()` as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 16开始，我们可以通过新的静态方法`InvocationHandler.invokeDefault()`简化之前的代码。正如其名称所暗示的，这个方法对于调用`default`方法很有用。在代码行中，我们可以通过`invokeDefault()`简化之前调用`Printable.print()`的示例，如下所示：
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the next example, every time we explicitly invoke the `Writable.write()`
    method, we expect that the `Draft.write()` method is invoked automatically behind
    the scenes:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，每次我们显式调用`Writable.write()`方法时，我们期望在幕后自动调用`Draft.write()`方法：
- en: '[PRE50]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the bundled code, you can practice more examples.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以练习更多示例。
- en: 44\. Converting between bytes and hex-encoded strings
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 44. 在字节和十六进制编码字符串之间转换
- en: Converting bytes to hexadecimal (and vice versa) is a common operation in applications
    that manipulate fluxes of files/messages, perform encoding/decoding tasks, process
    images, and so on.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 将字节转换为十六进制（反之亦然）是处理文件/消息流、执行编码/解码任务、处理图像等应用中的常见操作。
- en: 'A Java byte is a number in the [-128, +127] range and is represented using
    1 signed byte (8 bits). A hexadecimal (base 16) is a system based on 16 digits
    (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F). In other words, those 8
    bits of a byte value accommodate exactly 2 hexadecimal characters in the range
    00 to FF. The decimal <-> binary <-> hexadecimal mapping is resumed in the following
    figure:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Java的字节是一个范围在[-128, +127]的数字，使用1个有符号字节（8位）表示。十六进制（基数为16）是一个基于16个数字（0, 1, 2,
    3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, 和 F）的系统。换句话说，一个字节的8位正好可以容纳2个十六进制字符，范围在00到FF之间。十进制
    <-> 二进制 <-> 十六进制的映射总结在下图中：
- en: '![Figure 2.27.png](img/B19665_02_27.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.27.png](img/B19665_02_27.png)'
- en: 'Figure 2.27: Decimal to binary to hexadecimal conversion'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27：十进制到二进制到十六进制转换
- en: For instance, 122 in binary is 01111010\. Since 0111 is in hexadecimal 7, and
    1010 is A, this results in 122 being 7A in hexadecimal (also written as 0x7A).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，二进制的122是01111010。由于0111在十六进制中是7，1010是A，因此122在十六进制中是7A（也可以写作0x7A）。
- en: How about a negative byte? We know from the previous chapter that Java represents
    a negative number as *two’s complement* of the positive number. This means that
    -122 in binary is 10000110 (retain the first 7 bits of positive 122 = 1111010,
    flip(1111010) = 0000101, add(0000001) = 00000110, and append sign bit 1, 10000110)
    and in hexadecimal, is 0x86.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一个负字节呢？我们从上一章知道，Java将负数表示为正数的*二进制补码*。这意味着-122的二进制是10000110（保留正数122的前7位= 1111010，取反(1111010)
    = 0000101，加1(0000001) = 00000110，并添加符号位1，10000110)，在十六进制中是0x86。
- en: Converting a negative number to hexadecimal can be done in several ways, but
    we can easily obtain the lower 4 bits as 10000110 & 0xF = 0110, and the higher
    four bits as (10000110>> 4) & 0xF = 1000 & 0xF = 1000 (here, the 0xF (binary,
    1111) mask is useful only for negative numbers). Since, 0110 = 6 and 1000 = 8,
    we see that 10000110 is in hexadecimal 0x86\.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 将负数转换为十六进制可以有多种方式，但我们可以轻松地获得低4位为10000110 & 0xF = 0110，高4位为(10000110>> 4) & 0xF
    = 1000 & 0xF = 1000（在这里，0xF（二进制，1111）掩码对于负数是很有用的）。由于0110 = 6和1000 = 8，我们看到10000110在十六进制中是0x86。
- en: If you need a deep coverage of bits manipulation in Java or you simply face
    issues in understanding the current topic, then please consider the book *The
    Complete Coding Interview Guide in Java*, especially *Chapter 9*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要深入了解Java中的位操作，或者你只是面对理解当前主题的问题，那么请考虑阅读《Java完全编码面试指南》这本书，特别是*第9章*。
- en: 'So, in code lines, we can rely on this simple algorithm and `Character.forDigit(int
    d, int r)`, which returns the character representation for the given digit (`d`)
    in the given radix (`r`):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在代码行中，我们可以依赖这个简单的算法和`Character.forDigit(int d, int r)`，它返回给定基数（`r`）中给定数字（`d`）的字符表示：
- en: '[PRE51]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'There are many other ways to solve this problem (in the bundled code, you can
    see another flavor of this solution). For example, if we know that the `Integer.toHexString(int
    n)` method returns a string that represents the unsigned integer in base 16 of
    the given argument, then all we need is to apply the 0xFF (binary, 11111111) mask
    for negatives as:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法有很多（在捆绑的代码中，您可以查看这种解决方案的另一种形式）。例如，如果我们知道`Integer.toHexString(int n)`方法返回一个表示给定参数无符号整数16进制字符串，那么我们只需要对负数应用0xFF（二进制，11111111）掩码即可：
- en: '[PRE52]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If there is an approach that we should avoid, then that is the one based on
    `String.format()`. The `String.format("%02x ", byte_nr)` approach is concise but
    very slow!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种我们应该避免的方法，那么就是基于`String.format()`的方法。`String.format("%02x ", byte_nr)`方法简洁但非常慢！
- en: 'How about the reverse process? Converting a given hexadecimal string (for instance,
    7d, 09, and so on) to a byte is quite easy. Just take the first (`d1`) and second
    (`d2`) character of the given string and apply the relation, `(byte) ((d1 << 4)
    + d2)`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来呢？将给定的十六进制字符串（例如，7d，09等）转换为字节相当简单。只需取给定字符串的第一个（`d1`）和第二个（`d2`）字符，并应用关系，`(byte)
    ((d1 << 4) + d2)`：
- en: '[PRE53]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: More examples are available in the bundled code. If you rely on third-party
    libraries, then check Apache Commons Codec (`Hex.encodeHexString()`), Guava (`BaseEncoding`),
    Spring Security (`Hex.encode()`), Bouncy Castle (`Hex.toHexString()`), and so
    on.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中还有更多示例。如果您依赖第三方库，那么请检查Apache Commons Codec（`Hex.encodeHexString()`）、Guava（`BaseEncoding`）、Spring
    Security（`Hex.encode()`）、Bouncy Castle（`Hex.toHexString()`）等。
- en: JDK 17+
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 17+
- en: 'Starting with JDK 17, we can use the `java.util.HexFormat` class. This class
    has plenty of static methods for handling hexadecimal numbers, including `String
    toHexDigits(byte value)` and `byte[]parseHex(CharSequence string)`. So, we can
    convert a byte to a hexadecimal string as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 17开始，我们可以使用`java.util.HexFormat`类。这个类有很多静态方法用于处理十六进制数，包括`String toHexDigits(byte
    value)`和`byte[] parseHex(CharSequence string)`。因此，我们可以将字节转换为十六进制字符串如下：
- en: '[PRE54]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And, vice versa as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 反之亦然，如下所示：
- en: '[PRE55]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the bundled code, you can also see the extrapolation of these solutions for
    converting an array of bytes (`byte[]`) to a `String`, and vice versa.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，您还可以看到这些解决方案的扩展，用于将字节数组（`byte[]`）转换为`String`，反之亦然。
- en: 45\. Exemplify the initialization-on-demand holder design pattern
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 45. 举例说明按需初始化持有者设计模式
- en: Before we tackle the solution of implementing the initialization-on-demand holder
    design pattern, let’s quickly recap a few ingredients of this solution.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们着手解决实现按需初始化持有者设计模式之前，让我们快速回顾一下这个解决方案的一些关键要素。
- en: Static vs. non-static blocks
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态与非静态块
- en: 'In Java, we can have *initialization non-static blocks* and *static blocks*.
    An initialization non-static block (or simply, a non-static block) is automatically
    called every single time we instantiate the class. On the other hand, an initialization
    static block (or simply, a static block) is called a single time when the class
    itself is initialized. No matter how many subsequent instances of that class we
    create, the static block will never get executed again. In code lines:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们可以有*非静态初始化块*和*静态块*。一个非静态初始化块（或简单地，非静态块）在每次实例化类时都会自动调用。另一方面，一个静态初始化块（或简单地，静态块）在类本身初始化时只调用一次。无论我们创建多少个该类的后续实例，静态块都不会再次执行。在代码行中：
- en: '[PRE56]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, let’s run the following test code to create three instances of `A`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们运行以下测试代码来创建三个`A`的实例：
- en: '[PRE57]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output reveals that the static initializer is called only once, while the
    non-static initializer is called three times:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示静态初始化器只调用一次，而非静态初始化器调用三次：
- en: '[PRE58]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Moreover, the static initializer is called before the non-static one. Next,
    let’s talk about nested classes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，静态初始化器在非静态初始化器之前被调用。接下来，让我们谈谈嵌套类。
- en: Nested classes
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套类
- en: 'Let’s look at a quick example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个快速示例：
- en: '[PRE59]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Nested classes can be static or non-static. A non-static nested class is referred
    to as an *inner clas*s; further, it can be a *local inner class* (declared in
    a method) or an *anonymous inner class* (class with no name). On the other hand,
    a nested class that is declared static is referred to as a *static nested class*.
    The following figure clarifies these statements:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类可以是静态的或非静态的。一个非静态的嵌套类被称为*内部类*；进一步地，它可以是*局部内部类*（在方法中声明）或*匿名内部类*（没有名称的类）。另一方面，声明为静态的嵌套类被称为*静态嵌套类*。以下图解说明了这些概念：
- en: '![Figure 2.28.png](img/B19665_02_28.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.28.png](img/B19665_02_28.png)'
- en: 'Figure 2.28: Java nested classes'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28：Java 嵌套类
- en: Since `B` is a static class declared in `A`, we say that `B` is a static nested
    class.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `B` 是在 `A` 中声明的静态类，我们说 `B` 是一个静态嵌套类。
- en: Tackling the initialization-on-demand holder design pattern
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决初始化按需持有设计模式
- en: 'The initialization-on-demand holder design pattern refers to a thread-safe
    lazy-loaded singleton (single instance) implementation. Before JDK 16, we can
    exemplify this design pattern in code as follows (we want a single thread-safe
    instance of `Connection`):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化按需持有设计模式指的是线程安全的延迟加载单例（单个实例）实现。在 JDK 16 之前，我们可以在代码中举例说明这种设计模式如下（我们希望有一个线程安全的
    `Connection` 单例）：
- en: '[PRE60]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: No matter how many times a thread (multiple threads) calls `Connection.get()`,
    we always get the same instance of `Connection`. This is the instance created
    when we called `get()` for the first time (first thread), and Java has initialized
    the `LazyConnection` class and its statics. In other words, if we never call `get()`,
    then the `LazyConnection` class and its statics are never initialized (this is
    why we name it lazy initialization). And, this is thread-safe because static initializers
    can be constructed (here, `INSTANCE`) and referenced without explicit synchronization
    since they are run before any thread can use the class (here, `LazyConnection`).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 无论线程（多个线程）调用 `Connection.get()` 多少次，我们总是得到相同的 `Connection` 实例。这是我们在第一次调用 `get()`
    时创建的实例（第一个线程），Java 已经初始化了 `LazyConnection` 类及其静态成员。换句话说，如果我们从未调用 `get()`，那么 `LazyConnection`
    类及其静态成员永远不会被初始化（这就是为什么我们称之为延迟初始化）。而且，这是线程安全的，因为静态初始化器可以在没有显式同步的情况下构造（这里，`INSTANCE`）和引用，因为它们在任何线程可以使用该类之前运行（这里，`LazyConnection`）。
- en: JDK 16+
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 16+
- en: 'Until JDK 16, an inner class could contain static members as constant variables
    but it couldn’t contain static initializers. In other words, the following code
    would not compile because of the static initializer:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 JDK 16，内部类可以包含静态成员作为常量变量，但不能包含静态初始化器。换句话说，以下代码由于静态初始化器而无法编译：
- en: '[PRE61]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: But, starting with JDK 16, the previous code is compiled without issues. In
    other words, starting with JDK 16, Java inner classes can have static members
    and static initializers.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，从 JDK 16 开始，之前的代码可以无问题编译。换句话说，从 JDK 16 开始，Java 内部类可以有静态成员和静态初始化器。
- en: 'This allows us to tackle the initialization-on-demand holder design pattern
    from another angle. We can replace the static nested class, `LazyConnection`,
    with a local inner class as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们从另一个角度解决初始化按需持有设计模式。我们可以将静态嵌套类 `LazyConnection` 替换为局部内部类，如下所示：
- en: '[PRE62]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, the `LazyConnection` is visible only in its containing method, `get()`.
    As long as we don’t call the `get()` method, the connection will not be initialized.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`LazyConnection` 只在其包含的方法 `get()` 中可见。只要我们不调用 `get()` 方法，连接就不会被初始化。
- en: 46\. Adding nested classes in anonymous classes
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 46. 在匿名类中添加嵌套类
- en: 'In the previous problem, we had a brief overview of nested classes. As a quick
    reminder, an anonymous class (or, anonymous inner class) is like a local inner
    class without a name. Their purpose is to provide a more concise and expressive
    code. However, the code readability may be affected (look ugly), but it may be
    worth it if you can perform some specific task without having to do a full-blown
    class. For instance, an anonymous class is useful for altering the behavior of
    an existing method without spinning a new class. Java uses them typically for
    event handling and listeners (in GUI applications). Probably the most famous example
    of an anonymous class is this one from Java code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个问题中，我们简要概述了嵌套类。作为一个快速提醒，匿名类（或匿名内部类）就像一个没有名字的局部内部类。它们的目的在于提供更简洁和表达性更强的代码。然而，代码的可读性可能会受到影响（看起来很丑），但如果可以执行一些特定任务而不必创建一个完整的类，那么这可能是有价值的。例如，匿名类在不需要创建新类的情况下改变现有方法的行为时很有用。Java
    通常用于事件处理和监听器（在 GUI 应用程序中）。Java 代码中最著名的匿名类例子如下：
- en: '[PRE63]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Nevertheless, while local inner classes are actually class declarations, anonymous
    classes are expressions. To create an anonymous class, we have to extend an existing
    class or implement an interface, as shown in the following figure:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管局部内部类实际上是类声明，匿名类是表达式。要创建一个匿名类，我们必须扩展一个现有的类或实现一个接口，如下面的图所示：
- en: '![Figure 2.28.png](img/B19665_02_29.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.28.png](img/B19665_02_29.png)'
- en: 'Figure 2.29: Anonymous class via class extension and interface implementation'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29：通过类扩展和接口实现匿名类
- en: Because they don’t have names, anonymous classes must be declared and instantiated
    in a single expression. The resulting instance can be assigned to a variable that
    can be referred to later. The standard syntax for expressions looks like calling
    a regular Java constructor having the class in a code block ending with a semi-colon
    (`;`). The presence of a semi-colon is a hint that an anonymous class is an expression
    that must be part of a statement.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们没有名字，匿名类必须在单个表达式中声明和实例化。结果实例可以被分配给一个变量，稍后可以引用。表达式的标准语法看起来像调用一个常规 Java 构造函数，该构造函数在代码块中以分号（`;`）结束。分号的存在是一个提示，表明匿名类是一个表达式，必须作为语句的一部分。
- en: Finally, anonymous classes cannot have explicit constructors, be abstract, have
    a single instance, implement multiple interfaces, or be extended.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，匿名类不能有显式的构造函数，不能是抽象的，不能是单例的，不能实现多个接口，也不能被扩展。
- en: 'Next, let’s tackle a few examples of nesting classes in anonymous classes.
    For instance, let’s consider the following interface of a printing service:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们解决一些匿名类中嵌套类的例子。例如，让我们考虑以下打印服务的接口：
- en: '[PRE64]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We use the `Printer` interface all over the place in our printing service,
    but we also want to have a helper method that is compact and simply tests our
    printer functions without requiring further actions or an extra class. We decided
    to hide this code in a static method named `printerTest()`, as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的打印服务中到处使用 `Printer` 接口，但我们还想要一个紧凑的辅助方法，简单地测试我们的打印机功能，而不需要进一步的操作或额外的类。我们决定将此代码隐藏在名为
    `printerTest()` 的静态方法中，如下所示：
- en: '[PRE65]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Testing the `best` quality print requires some extra settings wrapped in the
    inner `Tools` class. As you can see, the inner `Tools` class is nested in the
    anonymous class. Another approach consists of moving the `Tools` class inside
    the `print()` method. So, `Tools` becomes a local inner class as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `best` 质量打印需要一些额外的设置，这些设置被封装在内部 `Tools` 类中。正如你所见，内部 `Tools` 类嵌套在匿名类中。另一种方法是将
    `Tools` 类移动到 `print()` 方法内部。因此，`Tools` 成为一个局部内部类，如下所示：
- en: '[PRE66]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The problem with this approach is that the `Tools` class cannot be used outside
    of `print()`. So, this strict encapsulation will restrict us from adding a new
    method (next to `print()`) that also needs the `Tools` class.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是 `Tools` 类不能在 `print()` 之外使用。因此，这种严格的封装将限制我们添加一个也需要 `Tools` 类的新方法（在
    `print()` 旁边）。
- en: JDK 16+
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JDK 16+
- en: 'But, remember from the previous problem that, starting with JDK 16, Java inner
    classes can have static members and static initializers. This means that we can
    drop the `Tools` class and rely on two static methods as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，记住从上一个问题开始，从 JDK 16 开始，Java 内部类可以有静态成员和静态初始化器。这意味着我们可以删除 `Tools` 类，并依赖于以下两个静态方法：
- en: '[PRE67]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you find it more convenient to pick up these helpers in a static class,
    then do it:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得在静态类中获取这些辅助工具更方便，那么就去做吧：
- en: '[PRE68]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You can practice these examples in the bundled code.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在捆绑的代码中练习这些例子。
- en: 47\. Exemplify erasure vs. overloading
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 47. 举例说明擦除与重载的区别
- en: Before we join them in an example, let’s quickly tackle erasure and overloading
    separately.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们用一个例子将它们结合起来之前，让我们快速处理擦除和重载。
- en: Erasure in a nutshell
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 擦除概述
- en: Java uses *type erasure* at compile time in order to enforce type constraints
    and backward compatibility with old bytecode. Basically, at compilation time,
    all type arguments are replaced by `Object` (any generic must be convertible to
    `Object`) or type bounds (`extends` or `super`). Next, at runtime, the type erased
    by the compiler will be replaced by our type. A common case of type erasure implies
    generics.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在编译时使用 *类型擦除* 来强制执行类型约束和与旧字节码的向后兼容性。基本上，在编译时，所有类型参数都被替换为 `Object`（任何泛型都必须可转换为
    `Object`）或类型界限（`extends` 或 `super`）。接下来，在运行时，编译器擦除的类型将被我们的类型替换。类型擦除的一个常见情况是泛型。
- en: Erasure of generic types
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型类型的擦除
- en: 'Practically, the compiler erases the unbound types (such as `E`, `T`, `U`,
    and so on) with the bounded `Object`. This enforces type safety, as in the following
    example of *class type erasure*:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，编译器使用有界类型（如 `E`、`T`、`U` 等）擦除未绑定类型。这强制执行类型安全，如下面的 *类类型擦除* 示例所示：
- en: '[PRE69]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The compiler applies type erasure to replace `E` with `Object`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器应用类型擦除将 `E` 替换为 `Object`：
- en: '[PRE70]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If the `E` parameter is bound, then the compiler uses the first bound class.
    For instance, in a class such as `class Node<T extends Comparable<T>> {...}`,
    the compiler will replace `T` with `Comparable`. In the same manner, in a class
    such as `class Computation<T extends Number> {...}`, all occurrences of `T` would
    be replaced by the compiler with the upper bound `Number`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `E` 参数是有界的，那么编译器将使用第一个界限类。例如，在一个类如 `class Node<T extends Comparable<T>> {...}`
    中，编译器将用 `Comparable` 替换 `T`。同样，在一个类如 `class Computation<T extends Number> {...}`
    中，所有 `T` 的出现都将被编译器替换为上限 `Number`。
- en: 'Check out the following case, which is a classical case of *method type erasure*:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下情况，这是一个 *方法类型擦除* 的经典案例：
- en: '[PRE71]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How does this work? When we call `listOf(1, "one")`, we are actually passing
    two different types to the generic parameters `T` and `R`. The compiler type erasure
    has replaced `T` with `Object`. In this way, we can insert different types in
    the `ArrayList` and the code works just fine.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？当我们调用 `listOf(1, "one")` 时，我们实际上向泛型参数 `T` 和 `R` 传递了两种不同的类型。编译器的类型擦除将
    `T` 替换为 `Object`。这样，我们可以在 `ArrayList` 中插入不同的类型，代码运行良好。
- en: Erasure and bridge methods
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 擦除和桥接方法
- en: '*Bridge methods* are created by the compiler to cover corner cases. Specifically,
    when the compiler encounters an implementation of a parameterized interface or
    an extension of a parameterized class, it may need to generate a bridge method
    (also known as a synthetic method) as part of the type erasure phase. For instance,
    let’s consider the following parameterized class:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '*桥接方法* 是由编译器创建的，以覆盖边缘情况。具体来说，当编译器遇到参数化接口的实现或参数化类的扩展时，它可能需要生成一个桥接方法（也称为合成方法），作为类型擦除阶段的一部分。例如，让我们考虑以下参数化类：'
- en: '[PRE72]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And, an extension of this class:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个类的一个扩展：
- en: '[PRE73]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Type erasure modifies `Puzzle.setPiece(E)` as `Puzzle.setPiece(Object)`. This
    means that the `FunPuzzle.setPiece(String)` method does not override the `Puzzle.setPiece(Object)`
    method. Since the signatures of the methods are not compatible, the compiler must
    accommodate the polymorphism of generic types via a bridge (synthetic) method
    meant to guarantee that sub-typing works as expected. Let’s highlight this method
    in the code:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除修改了 `Puzzle.setPiece(E)` 为 `Puzzle.setPiece(Object)`。这意味着 `FunPuzzle.setPiece(String)`
    方法并没有覆盖 `Puzzle.setPiece(Object)` 方法。由于方法的签名不兼容，编译器必须通过一个桥接（合成）方法来适应泛型类型的多态性，以确保子类型按预期工作。让我们在代码中突出显示这个方法：
- en: '[PRE74]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now, whenever you see a bridge method in the stack trace, you will know what
    it is and why it is there.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当你看到堆栈跟踪中的桥接方法时，你将知道它是什么以及为什么存在。
- en: Type erasure and heap pollution
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型擦除和堆污染
- en: Have you ever seen an unchecked warning? I’m sure you have! It’s one of those
    things that is common to all Java developers. They may occur at compile-time as
    the result of type checking, or at runtime as a result of a cast or method call.
    In both cases, we talk about the fact that the compiler cannot validate the correctness
    of an operation, which implies some parameterized types. Not every unchecked warning
    is dangerous, but there are cases when we have to consider and deal with them.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否见过未检查的警告？我相信你一定见过！这是所有Java开发者都常见的事情。它们可能作为类型检查的结果在编译时发生，或者作为类型转换或方法调用的结果在运行时发生。在两种情况下，我们都在谈论编译器无法验证操作正确性的事实，这暗示了一些参数化类型。并非每个未检查的警告都是危险的，但有些情况下我们必须考虑和处理它们。
- en: A particular case is represented by *heap pollution.* If a parameterized variable
    of a certain type points to an object that is not of that type, then we are prone
    to deal with a code that leads to heap pollution. A good candidate for such scenarios
    involves methods with `varargs` arguments.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊情况是*堆污染*。如果一个特定类型的参数化变量指向的不是该类型的对象，那么我们很容易处理导致堆污染的代码。在这种情况下，一个合适的例子是带有`varargs`参数的方法。
- en: 'Check out this code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码：
- en: '[PRE75]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `listOf()` declaration will cause this warning: *Possible heap pollution
    from parameterized vararg type T*. So, what’s happening here?'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`listOf()`声明将导致以下警告：*从参数化vararg类型T可能导致可能的堆污染*。那么这里发生了什么？'
- en: The story begins when the compiler replaces the formal `T...` parameter into
    an array. After applying type erasure, the `T...` parameter becomes `T[]`, and
    finally `Object[]`. Consequently, we opened a gate to possible heap pollution.
    But, our code just added the elements of `Object[]` into a `List<Object>`, so
    we are in the safe area.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 故事从编译器将形式参数`T...`替换为数组开始。在应用类型擦除后，`T...`参数变为`T[]`，最终变为`Object[]`。因此，我们打开了一扇可能导致堆污染的大门。但是，我们的代码只是将`Object[]`的元素添加到了`List<Object>`中，所以我们处于安全区域。
- en: 'In other words, if you know that the body of the `varargs` method is not prone
    to generate a specific exception (for example, `ClassCastException`) or to use
    the `varargs` parameter in an improper operation, then we can instruct the compiler
    to suppress these warnings. We can do it via the `@SafeVarargs` annotation as
    follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果你知道`varargs`方法的主体不太可能生成特定的异常（例如，`ClassCastException`）或者在不恰当的操作中使用`varargs`参数，那么我们可以指示编译器抑制这些警告。我们可以通过以下方式使用`@SafeVarargs`注解来实现：
- en: '[PRE76]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `@SafeVarargs` is a hint that sustains that the annotated method will use
    the `varargs` formal parameter only in proper operations. More common, but less
    recommended, is to use `@SuppressWarnings({"unchecked", "varargs"})`, which simply
    suppresses such warnings without claiming that the `varargs` formal parameter
    is not used in improper operations.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SafeVarargs`是一个提示，表明被注解的方法将只在不恰当的操作中使用`varargs`形式参数。更常见但不太推荐的做法是使用`@SuppressWarnings({"unchecked",
    "varargs"})`，这简单地抑制了这些警告，而不声称`varargs`形式参数没有被用于不恰当的操作。'
- en: 'Now, let’s tackle this code:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来处理这段代码：
- en: '[PRE77]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This time, the type erasure transforms the `List<Integer>...` into `List[]`,
    which is a subtype of `Object[]`. This allows us to do the assignment: `Object[]
    listsAsArray = lists;`. But, check out the last two lines of code where we create
    a `List<String>` and store it in `listsAsArray[0]`. In the last line, we try to
    access the first `Integer` from `lists[0]`, which obviously leads to a `ClassCastException`.
    This is an improper operation of using `varargs`, so it is not advisable to use
    `@SafeVarargs` in this case. We should have taken the following warnings seriously:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，类型擦除将`List<Integer>...`转换为`List[]`，它是`Object[]`的子类型。这允许我们执行以下赋值操作：`Object[]
    listsAsArray = lists;`。但是，检查一下代码的最后两行，我们在其中创建了一个`List<String>`并将其存储在`listsAsArray[0]`中。在最后一行，我们试图从`lists[0]`中访问第一个`Integer`，这显然会导致`ClassCastException`。这是使用`varargs`的不恰当操作，因此在这种情况下不建议使用`@SafeVarargs`。我们应该认真对待以下警告：
- en: '[PRE78]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now, that you are familiar with type erasure, let’s briefly cover polymorphic
    overloading.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然你已经熟悉了类型擦除，让我们简要地介绍一下多态重载。
- en: Polymorphic overloading in a nutshell
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简而言之，多态重载
- en: Since *overloading* (also known as “ad hoc” polymorphism) is a core concept
    of **Object-Oriented Programming** (**OOP**), I’m sure you are familiar with Java
    method overloading, so I’ll not insist on the basic theory of this concept.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*重载*（也称为“临时多态”）是**面向对象编程**（**OOP**）的核心概念，我相信你对Java方法重载已经很熟悉了，所以我就不再坚持这个概念的基本理论了。
- en: Also, I’m aware that some people don’t agree that overloading can be a form
    of polymorphism, but that is another topic that we will not tackle here.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我也知道有些人不同意重载可以是多态的一种形式，但这将是另一个我们不在这里解决的问题。
- en: 'We will be more practical and jump into a suite of quizzes meant to highlight
    some interesting aspects of overloading. More precisely, we will discuss *type
    dominance*. So, let’s tackle the first quiz (`wordie` is an initially empty string):'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更加实际，跳入一系列旨在突出重载有趣方面的测验。更确切地说，我们将讨论*类型优先级*。所以，让我们解决第一个测验（`wordie`最初是一个空字符串）：
- en: '[PRE79]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'What will happen? If you answered that the compiler will point out that there
    is no suitable method found for `kaboom(1)`, then you’re right. The compiler looks
    for a method that gets an integer argument, `kaboom(int)`. Okay, that was easy!
    Here is the next one:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 会发生什么？如果你回答编译器会指出没有找到适合`kaboom(1)`的方法，那么你是对的。编译器寻找一个接受整数参数的方法，`kaboom(int)`。好吧，那很简单！接下来是下一个：
- en: '[PRE80]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We know that the first two `kaboom()` instances are useless. How about `kaboom(long)`
    and `kaboom(Integer)`? You are right, `kaboom(long)` will be called. If we remove
    `kaboom(long)`, then `kaboom(Integer)` is called.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道前两个`kaboom()`实例是无用的。那么`kaboom(long)`和`kaboom(Integer)`呢？你说得对，`kaboom(long)`会被调用。如果我们移除`kaboom(long)`，那么`kaboom(Integer)`会被调用。
- en: '**Important note**'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: In primitive overloading, the compiler starts by searching for a one-to-one
    match. If this attempt fails, then the compiler searches for an overloading flavor
    taking a primitive broader domain than the primitive current domain (for instance,
    for an `int`, it looks for `int`, `long`, `float`, or `double`). If this fails
    as well, then the compiler checks for overloading taking boxed types (`Integer`,
    `Float`, and so on).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始类型重载中，编译器首先尝试寻找一对一匹配。如果这个尝试失败，那么编译器将寻找比原始当前域更广的原始类型重载（例如，对于`int`，它会寻找`int`、`long`、`float`或`double`）。如果这也失败了，那么编译器将检查接受装箱类型（`Integer`、`Float`等）的重载。
- en: 'Following the previous statements, let’s have this one:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的说明，让我们来看这个例子：
- en: '[PRE81]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This time, `wordie` will be `i`. The `kaboom(Integer)` is called since there
    is no `kaboom(int`/`long`/`float`/`double)`. If we had a `kaboom(double)`, then
    that method has higher precedence than `kaboom(Integer)`. Interesting, right?!
    On the other hand, if we remove `kaboom(Integer)`, then don’t expect that `kaboom(Long)`
    will be called. Any other `kaboom(boxed type)` with a broader/narrow domain than
    `Integer` will not be called. This is happening because the compiler follows the
    inheritance path based on an IS-A relationship, so after `kaboom(Integer)`, it
    looks for `kaboom(Number)`, since `Integer` is a `Number`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`wordie`将是`i`。由于没有`kaboom(int)`/`long`/`float`/`double)`，将调用`kaboom(Integer)`。如果我们有一个`kaboom(double)`，那么这个方法比`kaboom(Integer)`有更高的优先级。有趣，对吧？！另一方面，如果我们移除`kaboom(Integer)`，那么不要期望会调用`kaboom(Long)`。任何比`Integer`更广/窄域的`kaboom(boxed
    type)`都不会被调用。这是因为在编译器遵循基于IS-A关系的继承路径时发生的，所以`kaboom(Integer)`之后，它会寻找`kaboom(Number)`，因为`Integer`是`Number`。
- en: '**Important note**'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: In boxed type overloading, the compiler starts by searching for a one-to-one
    match. If this attempt fails, then the compiler will not consider any overloading
    flavor taking a boxed type with a broader domain than the current domain (of course,
    a narrow domain is ignored as well). It looks for `Number` as being the superclass
    of all boxed types. If `Number` is not found, the compiler goes up in the hierarchy
    until it reaches the `java.lang.Object`, which is the end of the road.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在装箱类型重载中，编译器首先尝试寻找一对一匹配。如果这个尝试失败，那么编译器将不会考虑任何比当前域更广的装箱类型重载（当然，窄域也会被忽略）。它寻找`Number`作为所有装箱类型的超类。如果找不到`Number`，编译器将沿着继承层次向上查找，直到达到`java.lang.Object`，这是路的尽头。
- en: 'Okay, let’s complicate things a little bit:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们稍微复杂一点：
- en: '[PRE82]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: So, which method will be called this time? I know, you think `kaboom(Number)`,
    right? At least, my simple logic pushes me to think that this is a common-sense
    choice. And it is correct!
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这次会调用哪个方法？我知道，你认为`kaboom(Number)`，对吧？至少，我的简单逻辑推动我这么想，这是一个常识性的选择。而且，这是正确的！
- en: If we remove `kaboom(Number)`, then the compiler will call the `varargs` method,
    `kaboom(Number...)`. This makes sense since `kaboom(1)` uses a single argument,
    so `kaboom(Number)` should have higher precedence than `kaboom(Number...)`. This
    logic reverses if we call `kaboom(1,2,3)` since `kaboom(Number)` is no longer
    representing a valid overloading for this call, and `kaboom(Number...)` is the
    right choice.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除`kaboom(Number)`，编译器将调用`varargs`方法，`kaboom(Number...)`。这很有道理，因为`kaboom(1)`使用单个参数，所以`kaboom(Number)`应该比`kaboom(Number...)`有更高的优先级。如果我们调用`kaboom(1,2,3)`，这种逻辑就会反转，因为`kaboom(Number)`不再代表对这个调用有效的重载，而`kaboom(Number...)`是正确的选择。
- en: But, this logic applies because `Number` is the superclass of all boxed classes
    (`Integer`, `Double`, `Float`, and so on).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这个逻辑成立是因为`Number`是所有装箱类（`Integer`、`Double`、`Float`等）的超类。
- en: How about now?
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在怎么样？
- en: '[PRE83]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This time, the compiler will “bypass” `kaboom(File...)` and will call `kaboom(Object...)`.
    Based on the same logic, a call of `kaboom(1, 2, 3)` will call `kaboom(Object...)`
    since there is no `kaboom(Number...)`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，编译器将“绕过”`kaboom(File...)`并调用`kaboom(Object...)`。根据同样的逻辑，调用`kaboom(1, 2, 3)`将调用`kaboom(Object...)`，因为没有`kaboom(Number...)`。
- en: '**Important note**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: In overloading, if the call has a single argument, then the method with a single
    argument has higher precedence than its `varargs` counterpart. On the other hand,
    if the call has more arguments of the same type, then the `varargs` method is
    called since the one-argument method is not suitable anymore. When the call has
    a single argument but only the `varargs` overloading is available, then this method
    is called.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在重载中，如果调用有一个单个参数，那么具有单个参数的方法比其`varargs`对应方法有更高的优先级。另一方面，如果调用有相同类型的更多参数，那么将调用`varargs`方法，因为单参数方法不再适用。当调用有一个单个参数但只有`varargs`重载可用时，则调用此方法。
- en: 'This leads us to the following example:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了以下示例：
- en: '[PRE84]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This time, `kaboom()` has no arguments and the compiler cannot find a unique
    match. This means that the reference to `kaboom()` is ambiguous since both methods
    match (`kaboom(java.lang.Number...)` in `modern.challenge.Main` and method `kaboom(java.io.File...)`
    in `modern.challenge.Main`).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`kaboom()`没有参数，编译器找不到唯一的匹配项。这意味着对`kaboom()`的引用是模糊的，因为两种方法都匹配（`modern.challenge.Main`中的`kaboom(java.lang.Number...)`和`modern.challenge.Main`中的方法`kaboom(java.io.File...)`）。
- en: In the bundled code, you can play even more with polymorphic overloading and
    test your knowledge. Moreover, try to challenge yourself and introduce generics
    in the equation as well.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以玩更多关于多态重载的游戏，并测试你的知识。此外，尝试挑战自己，并在等式中引入泛型。
- en: Erasure vs. overloading
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消除与重载
- en: 'Okay, based on the previous experience, check out this code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，基于之前的经验，来看看这段代码：
- en: '[PRE85]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'What will happen? Well, this is a case where overloading and type erasure collide.
    The type erasure will replace `List<A>` with `List<Object>` and `List<B>` with
    `List<Object>` as well. So, overloading is not possible and we get an error such
    as *name clash: print(java.util.List<modern.challenge.B>) and print (java.util.List<modern.challenge.A>)
    have the same erasure*.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 会发生什么？嗯，这是一个重载和类型擦除冲突的例子。类型擦除会将`List<A>`替换为`List<Object>`，也将`List<B>`替换为`List<Object>`。因此，无法进行重载，我们得到一个错误，例如*名称冲突：print(java.util.List<modern.challenge.B>)和print(java.util.List<modern.challenge.A>)有相同的擦除*。
- en: 'In order to solve this issue, we can add a dummy argument to one of these two
    methods:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在这两个方法之一中添加一个虚拟参数：
- en: '[PRE86]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, we can have the same call for both methods:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对两个方法进行相同的调用：
- en: '[PRE87]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Done! You can practice these examples in the bundled code.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！你可以在捆绑的代码中练习这些示例。
- en: 48\. Xlinting default constructors
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 48. 检查默认构造函数
- en: 'We know that a Java class with no explicit constructor automatically gets an
    “invisible” default constructor for setting default values of the instance variables.
    The following `House` class falls in this scenario:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，没有显式构造函数的Java类会自动获得一个“不可见”的默认构造函数，用于设置实例变量的默认值。以下`House`类就属于这种情况：
- en: '[PRE88]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If this is exactly what we wanted, then it is no problem. But, if we are concerned
    about the fact that the default constructors are exposed by classes to publicly
    exported packages, then we have to consider using JDK 16+.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这正是我们想要的，那就没问题。但是，如果我们担心默认构造函数被类公开导出到公共导出包的事实，那么我们必须考虑使用 JDK 16+。
- en: 'JDK 16+ added a dedicated *lint* meant to warn us about the classes that have
    default constructors. In order to take advantage of this *lint*, we have to follow
    two steps:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 16+添加了一个专门的*lint*，用于警告我们具有默认构造函数的类。为了利用这个*lint*，我们必须遵循两个步骤：
- en: Export the package containing that class
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出包含该类的包
- en: Compile with `-Xlint:missing-explicit-ctor` (or `-Xlint`, `-Xlint:all`)
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-Xlint:missing-explicit-ctor`（或`-Xlint`，`-Xlint:all`）编译
- en: 'In our case, we export the package `modern.challenge` in `module-info` as follows:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们在`module-info`中如下导出`modern.challenge`包：
- en: '[PRE89]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Once you compile the code with `-Xlint:missing-explicit-ctor`, you’ll see a
    warning like in the following figure:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你用`-Xlint:missing-explicit-ctor`编译代码，你将看到如图所示的警告：
- en: '![Figure 2.30.png](img/B19665_02_30.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![图2.30.png](img/B19665_02_30.png)'
- en: 'Figure 2.30: The warning produced by -Xlint:missing-explicit-ctor'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.30：由`-Xlint:missing-explicit-ctor`产生的警告
- en: Now, you can easily find out which classes have default constructors.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以轻松地找出哪些类有默认构造函数。
- en: 49\. Working with the receiver parameter
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 49. 使用接收者参数
- en: 'Starting with JDK 8, we can enrich any of our instance methods with the optional
    *receiver parameter*. This is a purely syntactic parameter of enclosing type exposed
    via the `this` keyword. The following two snippets of code are identical:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 8开始，我们可以用可选的*接收者参数*丰富我们的任何实例方法。这是一个通过`this`关键字暴露的封装类型的纯语法参数。以下两个代码片段是相同的：
- en: '[PRE90]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Do not conclude that `revision2()` is an overloading of `revision1()`, or vice
    versa. Both methods have the same output, the same signature, and produce the
    same bytecode.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 不要得出结论说`revision2()`是`revision1()`的覆盖，或者反之亦然。两种方法都有相同的输出、相同的签名和产生相同的字节码。
- en: 'The receiver parameter can be used in inner classes as well. Here is an example:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者参数也可以在内部类中使用。以下是一个示例：
- en: '[PRE91]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Okay, but why use the receiver parameter? Well, JDK 8 introduced so-called
    *type annotations*, which are exactly as the name suggests: annotations that can
    be applied to types. In this context, the receiver parameter was added for annotating
    the type of object for which the method is called. Check out the following code:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但为什么使用接收者参数呢？嗯，JDK 8引入了所谓的*类型注解*，正如其名所示：可以应用于类型的注解。在这种情况下，接收者参数被添加用于注解被调用方法的对象类型。查看以下代码：
- en: '[PRE92]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Or, check this more elaborate example:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，查看这个更详细的示例：
- en: '[PRE93]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Every client of a `Parcel` must call these methods in a precise sequence drawn
    via type annotations and receiver parameters. In other words, an order can be
    placed only if it is a new order, it can be shipped only if the order was placed,
    it can be delivered only if it was shipped, it can be paid only if it was delivered,
    and it can be closed only if it was paid.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Parcel`客户端都必须按照通过类型注解和接收者参数绘制的精确顺序调用这些方法。换句话说，只有当它是一个新订单时，才能下单；只有当订单已下单时，才能发货；只有当已发货时，才能交付；只有当已交付时，才能付款；只有当已付款时，才能关闭。
- en: At this moment, this strict sequence is pointed out only by these hypothetical
    annotations. But, this is the right road to implement further a static analysis
    tool that will understand the meaning of these annotations and trigger warnings
    every time a client of `Parcel` doesn’t follow this precise sequence.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个严格的顺序仅由这些假设的注解指出来。但，这是实现进一步静态分析工具的正确道路，该工具将理解这些注解的含义，并在`Parcel`的客户端每次不遵循这个精确顺序时触发警告。
- en: 50\. Implementing an immutable stack
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 50. 实现一个不可变栈
- en: 'A common coding challenge in interviews is this: Implement an immutable stack
    in Java.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 面试中常见的编码挑战是这样的：在Java中实现一个不可变栈。
- en: 'Being an abstract data type, a stack needs at least this contract:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种抽象数据类型，栈至少需要这个契约：
- en: '[PRE94]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Having this contract, we can focus on the immutable implementation. Generally
    speaking, an immutable data structure stays the same until an operation attempts
    to change it (for instance, to add, put, remove, delete, push, and so on). If
    an operation attempts to alter the content of an immutable data structure, a new
    instance of that data structure must be created and used by that operation, while
    the previous instance remains unchanged.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个契约，我们可以专注于不可变实现。一般来说，不可变数据结构在尝试更改其内容（例如，添加、put、删除、push等）之前保持不变。如果操作尝试更改不可变数据结构的内容，必须创建该数据结构的新实例，并由该操作使用，而之前的实例保持不变。
- en: 'Now, in our context, we have two operations that can alter the stack content:
    push and pop. The push operation should return a new stack containing the pushed
    element, while the pop operation should return the previous stack. But, in order
    to accomplish this, we need to start from somewhere, so we need an empty initial
    stack. This is a singleton stack that can be implemented as follows:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的上下文中，我们有两个可以改变栈内容的操作：push和pop。push操作应该返回包含已推入元素的新栈，而pop操作应该返回之前的栈。但是，为了完成这个任务，我们需要从一个地方开始，因此我们需要一个空的初始栈。这是一个单例栈，可以如下实现：
- en: '[PRE95]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `StackIterator` is a trivial implementation of the Java `Iterator`. Nothing
    fancy here:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackIterator`是Java `Iterator`的一个简单实现。这里没有太多花哨的东西：'
- en: '[PRE96]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'So far, we have the `Iterator` and an empty stack singleton. Finally, we can
    implement the logic of the immutable stack as follows:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了`Iterator`和一个空的栈单例。最后，我们可以如下实现不可变栈的逻辑：
- en: '[PRE97]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Creating a stack starts by calling the`ImmutableStack.empty()` method, as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 创建栈首先调用`ImmutableStack.empty()`方法，如下所示：
- en: '[PRE98]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the bundled code, you can how this stack can be used further.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以看到这个栈如何被进一步使用。
- en: 51\. Revealing a common mistake with Strings
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 51. 揭示与字符串相关的常见错误
- en: Everybody knows that `String` is an immutable class.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道`String`是一个不可变类。
- en: 'Even so, we are still prone to accidentally write code that ignores the fact
    that `String` is immutable. Check out this code:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，我们仍然容易不小心编写忽略`String`不可变性的代码。看看这段代码：
- en: '[PRE99]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Somehow, it is logical to think that the `replace()` call has replaced the text
    *start* with *stop* and now `str` is *stop*. This is the cognitive power of words
    (*replace* is a verb that clearly induces the idea that the text was replaced).
    But, `String` is immutable! Oh… we already know that! This means that `replace()`
    cannot alter the original `str`. There are many such silly mistakes that we are
    prone to accidentally make, so pay extra attention to such simple things, since
    they can waste your time in the debugging stage.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 某种程度上，认为`replace()`调用已经用`stop`替换了文本`start`，现在`str`是`stop`，这是合乎逻辑的。这是文字的力量（`replace`是一个动词，清楚地诱导出文本被替换的想法）。但是，`String`是不可变的！哦……我们已经知道了！这意味着`replace()`不能改变原始的`str`。我们容易犯很多这样的愚蠢错误，所以请特别注意这些简单的事情，因为它们可能会在调试阶段浪费你的时间。
- en: 'The solution is obvious and self-explanatory:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案很明显，一目了然：
- en: '[PRE100]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Or, simply:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，简单地说：
- en: '[PRE101]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Don’t forget that `String` is immutable!
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记`String`是不可变的！
- en: 52\. Using the enhanced NullPointerException
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 52. 使用增强的NullPointerException
- en: 'Take your time to dissect the following trivial code and try to identify the
    parts that are prone to cause a `NullPointerException` (these parts are marked
    as numbered warnings, which will be explained after the snippet):'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细分析以下简单代码，并尝试识别可能导致`NullPointerException`的部分（这些部分被标记为编号警告，将在代码片段之后解释）：
- en: '[PRE102]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You noticed the warnings? Of course, you did! There are five major scenarios
    behind most **NullPointerException** (**NPEs**) and each of them is present in
    the previous class. Prior to JDK 14, an NPE doesn’t contain detailed information
    about the cause. Look at this exception:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了警告吗？当然，你注意到了！大多数**NullPointerException**（**NPE**）背后有五个主要场景，而且每个场景在前一个类中都有体现。在JDK
    14之前，NPE不包含有关原因的详细信息。看看这个异常：
- en: '[PRE103]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This message is just a starting point for the debugging process. We don’t know
    the root cause of this NPE or which variable is `null`. But, starting with JDK
    14 (JEP 358), we have really helpful NPE messages. For example, in JDK 14+, the
    previous message looks as follows:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息只是调试过程的起点。我们不知道这个NPE的根本原因或哪个变量是`null`。但是，从JDK 14（JEP 358）开始，我们有了非常有帮助的NPE消息。例如，在JDK
    14+中，之前的消息如下所示：
- en: '[PRE104]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The highlighted part of the message gives us important information about the
    root cause of this NPE. Now, we know that the `str` variable is `null`, so no
    need to debug further. We can just focus on how to fix this issue.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 消息中突出显示的部分提供了关于这个NPE根本原因的重要信息。现在，我们知道`str`变量是`null`，因此无需进一步调试。我们只需关注如何解决这个问题。
- en: Next, let’s tackle each of the five major root causes of NPEs.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们逐一解决NPE的五个主要根本原因。
- en: WARNING 1! NPE when calling an instance method via a null object
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警告 1！通过空对象调用实例方法时发生NPE
- en: 'Consider the following code written by a client of `ChainSaw`:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下由`ChainSaw`的客户编写的代码：
- en: '[PRE105]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The client passes a chainsaw model that is not supported by this class, so
    the `initChainSaw()` method returns `null`. This is really bad because every time
    the client uses the `cs` variable, they will get back an NPE as follows:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 客户传递了一个这个类不支持的手锯模型，因此 `initChainSaw()` 方法返回 `null`。这真的很糟糕，因为每次客户端使用 `cs` 变量时，他们都会得到一个如下的
    NPE：
- en: '[PRE106]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Instead of returning `null`, it is better to throw an explicit exception that
    informs the client that they cannot continue because we don’t have this chainsaw
    model (we can go for the classical `IllegalArgumentException` or, the more suggestive
    one in this case (but quite uncommon for `null` value handling), `UnsupportedOperationException`).
    This may be the proper fix in this case, but it is not universally true. There
    are cases when it is better to return an empty object (for example, an empty string,
    collection, or array) or a default object (for example, an object with minimalist
    settings) that doesn’t break the client code. Since JDK 8, we can use `Optional`
    as well. Of course, there are cases when returning `null` makes sense but that
    is more common in APIs and special situations.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 与返回 `null` 相比，抛出一个明确的异常来通知客户端他们不能继续，因为我们没有这个手锯模型（我们可以选择经典的 `IllegalArgumentException`
    或者，在这种情况下更有说服力的（但处理 `null` 值时相当不常见）`UnsupportedOperationException`）。在这种情况下，这可能是一个合适的修复，但并不总是如此。有些情况下，返回一个空对象（例如，一个空字符串、集合或数组）或默认对象（例如，具有最小化设置的对象）可能更好，这样就不会破坏客户端代码。自从
    JDK 8 以来，我们还可以使用 `Optional`。当然，有些情况下返回 `null` 是有意义的，但这更常见于 API 和特殊情况下。
- en: WARNING 2! NPE when accessing (or modifying) the field of a null object
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警告 2！访问（或修改）空对象的字段时出现 NPE
- en: 'Consider the following code written by a client of `ChainSaw`:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下由 `ChainSaw` 客户编写的代码：
- en: '[PRE107]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Practically, the NPE, in this case, has the same root cause as the previous
    case. We try to access the `started` field of `ChainSaw`. Since this is a primitive
    `boolean`, it was initialized by JVM with `false`, but we cannot “see” that since
    we try to access this field through a `null` variable represented by `cs`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这个情况下，NPE 的根本原因与上一个案例相同。我们试图访问 `ChainSaw` 的 `started` 字段。由于这是一个原始的 `boolean`
    类型，它被 JVM 初始化为 `false`，但我们无法“看到”这一点，因为我们试图通过一个由 `cs` 表示的 `null` 变量来访问这个字段。
- en: WARNING 3! NPE when null is passed in the method argument
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警告 3！当方法参数为 `null` 时出现 NPE
- en: 'Consider the following code written by a client of `ChainSaw`:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下由 `ChainSaw` 客户编写的代码：
- en: '[PRE108]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'You are not a good citizen if you want a `null ChainSaw`, but who am I to judge?
    It is possible for this to happen and will lead to the following NPE:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个 `null ChainSaw`，那么你不是一个好公民，但我是谁来判断呢？这种情况可能发生，并且会导致以下 NPE：
- en: '[PRE109]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The message is crystal clear. We attempt to call the `String.endWith()` method
    with a `null` argument represented by the `model` variable. To fix this issue,
    we have to add a guard condition to ensure that the passed `model` argument is
    not `null` (and eventually, not empty). In this case, we can throw an `IllegalArgumentException`
    to inform the client that we are here and we are guarding. Another approach may
    consist of replacing the given `null` with a dummy model that passes through our
    code without issues (for instance, since the model is a `String`, we can reassign
    an empty string, **““**). However, personally, I don’t recommend this approach,
    not even for small methods. You never know how the code will evolve and such dummy
    reassignments can lead to brittle code.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 消息非常明确。我们尝试使用 `model` 变量作为 `null` 参数调用 `String.endWith()` 方法。为了解决这个问题，我们必须添加一个保护条件来确保传递的
    `model` 参数不是 `null`（并且最终不是空的）。在这种情况下，我们可以抛出一个 `IllegalArgumentException` 来通知客户端我们在这里，并且我们在进行保护。另一种方法可能包括用一个不会引起问题的虚拟模型替换给定的
    `null`（例如，由于模型是一个 `String`，我们可以重新分配一个空字符串，**““**）。然而，我个人不推荐这种方法，即使是对于小方法也不推荐。你永远不知道代码会如何演变，这样的虚拟重新赋值可能会导致脆弱的代码。
- en: WARNING 4! NPE when accessing the index value of a null array/collection
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警告 4！访问空数组/集合的索引值时出现 NPE
- en: 'Consider the following code written by a client of `ChainSaw`:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下由 `ChainSaw` 客户编写的代码：
- en: '[PRE110]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Creating an array of `ChainSaw` was quite challenging in this example. We accidentally
    slipped a `null` value (actually, we did it intentionally) and an unsupported
    model. In return, we get the following NPE:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中创建一个 `ChainSaw` 数组相当具有挑战性。我们意外地（实际上是有意为之）插入了一个 `null` 值和一个不受支持的模型。作为回报，我们得到了以下
    NPE：
- en: '[PRE111]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The message informs us that the `cs` variable is `null`. This is happening
    at line 37 in `ChainSaw`, so in the for loop of the `performance()` method. While
    looping the given array, our code iterated over the `null` value, which doesn’t
    have the `speed` field. Pay attention to this kind of scenario: even if the given
    array/collection itself is not `null`, it doesn’t mean that it cannot contain
    `null` items. So, adding a guarding check before handling each item can save us
    from an NPE in this case. Depending on the context, we can throw an `IllegalArgumentException`
    when the loop passes over the first `null` or simply ignore `null` values and
    don’t break the flow (in general, this is more suitable). Of course, using a collection
    that doesn’t accept `null` values is also a good approach (Apache Commons Collection
    and Guava have such collections).'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 消息通知我们 `cs` 变量是 `null`。这发生在 `ChainSaw` 的第 37 行，因此是在 `performance()` 方法的 for
    循环中。当遍历给定的数组时，我们的代码遍历了 `null` 值，该值没有 `speed` 字段。请注意这种情况：即使给定的数组/集合本身不是 `null`，并不意味着它不能包含
    `null` 项。因此，在处理每个项之前添加保护检查可以让我们避免这种情况下的 NPE。根据上下文，当循环通过第一个 `null` 时，我们可以抛出 `IllegalArgumentException`，或者简单地忽略
    `null` 值，不中断流程（通常这更合适）。当然，使用不接受 `null` 值的集合也是一个好方法（Apache Commons Collection 和
    Guava 有这样的集合）。
- en: WARNING 5! NPE when accessing a field via a getter
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 警告 5！通过 getter 访问字段时发生 NPE
- en: 'Consider the following code written by a client of `ChainSaw`:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下由 `ChainSaw` 的客户端编写的代码：
- en: '[PRE112]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And, the associated NPE:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，相关的 NPE：
- en: '[PRE113]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Practically, the getter `getPower()` returned `null` since the `power` field
    is `null`. Why? The answer is in the line `return new ChainSaw(model, null, (int)
    (Math.random() * 100));` of the `initChainSaw()` method. Because we didn’t decide
    yet on the algorithm for calculating the power of a chainsaw, we passed `null`
    to the `ChainSaw` constructor. Further, the constructor simply sets the `power`
    field as `this.power = power`. If it was a public constructor, then most probably
    we would have added some guarded conditions, but being a private constructor,
    it is better to fix the issue right from the root and not pass that `null`. Since
    the `power` is a `String`, we can simply pass an empty string or a suggestive
    string such as `UNKNOWN_POWER`. We also may leave a TODO comment in code such
    as `// TODO (JIRA ####): replace UNKNOWN_POWER with code`. This will remind us
    to fix this in the next release. Meanwhile, the code has eliminated the NPE risk.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，getter `getPower()` 返回 `null`，因为 `power` 字段是 `null`。为什么？答案是 `initChainSaw()`
    方法中的这一行 `return new ChainSaw(model, null, (int) (Math.random() * 100));`。因为我们还没有决定计算链锯功率的算法，所以我们向
    `ChainSaw` 构造函数传递了 `null`。此外，构造函数简单地设置了 `power` 字段为 `this.power = power`。如果它是一个公共构造函数，那么我们很可能会添加一些保护条件，但作为一个私有构造函数，最好从根源上修复这个问题，而不是传递那个
    `null`。由于 `power` 是一个 `String`，我们可以简单地传递一个空字符串或一个提示字符串，例如 `UNKNOWN_POWER`。我们还可以在代码中留下
    TODO 注释，例如 `// TODO (JIRA ####): replace UNKNOWN_POWER with code`。这将提醒我们在下一个版本中修复这个问题。同时，代码已经消除了
    NPE 风险。'
- en: 'Okay, after we fixed all these five NPE risks, the code has become the following
    (the added code is highlighted):'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在我们修复了这五个 NPE 风险之后，代码变成了以下这样（新增的代码已高亮显示）：
- en: '[PRE114]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Done! Now, our code is NPE-free. At least until reality contradicts us and a
    new NPE occurs.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，我们的代码没有 NPE。至少直到现实与我们对立，新的 NPE 发生。
- en: 53\. Using yield in switch expressions
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 53. 在 switch 表达式中使用 yield
- en: Here, we’re going to look at how `switch` expressions have evolved in JDK 13+.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将探讨 `switch` 表达式在 JDK 13+ 中的演变。
- en: Java SE 13 added the new `yield` statement, which can be used instead of the
    `break` statement in switch expressions.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE 13 添加了新的 `yield` 语句，该语句可以用作 switch 表达式中的 `break` 语句的替代。
- en: 'We know that a JDK 12+ `switch` expression can be written as follows (`playerType`
    is a Java enum):'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 JDK 12+ 的 `switch` 表达式可以写成以下形式（`playerType` 是一个 Java 枚举）：
- en: '[PRE115]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Moreover, we know that a label’s arrow can point to a curly-braces block as
    well (this works only in JDK 12, **not in JDK 13+**):'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们知道标签的箭头可以指向花括号块（这仅在 JDK 12 中有效，**在 JDK 13+ 中无效**）：
- en: '[PRE116]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Since `break` can be confusing because it can be used in old-school `switch`
    statements and in the new `switch` expressions, JDK 13 added the `yield` statement
    to be used instead of `break`. The `yield` statement takes one argument representing
    the value produced by the current case. The previous examples can be written from
    JDK 13+ as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `break` 可能会令人困惑，因为它可以用于老式的 `switch` 语句和新的 `switch` 表达式，JDK 13 添加了 `yield`
    语句来代替 `break`。`yield` 语句接受一个参数，表示当前 case 生成的值。以下示例可以从 JDK 13+ 开始编写：
- en: '[PRE117]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In other words, starting with JDK 13+, a `switch` expression can rely on `yield`
    but not on `break`, and a `switch` statement can rely on `break` but not on `yield`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，从 JDK 13+ 开始，`switch` 表达式可以依赖于 `yield` 但不依赖于 `break`，而 `switch` 语句可以依赖于
    `break` 但不依赖于 `yield`。
- en: 54\. Tackling the case null clause in switch
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 54. 解决 switch 语句中的 null 子句
- en: 'Before JDK 17, a `null` case in a `switch` was commonly coded as a guarding
    condition outside the `switch`, as in the following example:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 17 之前，`switch` 语句中的 `null` 情况通常会被编码为在 `switch` 语句外部的保护条件，如下面的示例所示：
- en: '[PRE118]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Starting with JDK 17+ (JEP 427), we can treat a `null` case as any other common
    case. For instance, here we have a `null` case that is responsible for handling
    the scenarios when the passed argument is `null`:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 17+（JEP 427）开始，我们可以将 `null` 情况视为任何其他常见情况。例如，这里有一个负责处理传入参数为 `null` 的场景的
    `null` 情况：
- en: '[PRE119]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'In certain contexts, `null` and `default` have the same meaning, so we can
    chain them in the same `case` statement:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些上下文中，`null` 和 `default` 有相同的意义，因此我们可以在同一个 `case` 语句中将它们链接起来：
- en: '[PRE120]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Or you might find it more readable like this:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可能更喜欢以下这种更易读的格式：
- en: '[PRE121]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Personally, I suggest you think twice before patching your `switch` expressions
    with `case null`, especially if you plan to do it only for silently sweeping these
    values. Overall, your code may become brittle and exposed to unexpected behaviors/results
    that ignore the presence of `null` values. In the bundled code, you can test the
    complete examples.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 个人建议，在用 `case null` 修补 `switch` 表达式之前，请三思，尤其是如果您计划仅为了静默清除这些值。总体而言，您的代码可能会变得脆弱，并容易受到忽略
    `null` 值存在的不预期的行为/结果的影响。在捆绑的代码中，您可以测试完整的示例。
- en: 55\. Taking on the hard way to discover equals()
  id: totrans-568
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 55. 以艰难的方式发现 equals()
- en: 'Check out the following code:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码：
- en: '[PRE122]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: So, initially, `listOfInt1` and `listOfInt2` have the same items, [`x1`=14,
    `y1`=14, `x2`=129, `y2`=129]. But, what will contain `listOfInt1`/`listOfInt2`
    after executing the code based on `removeIf()` and `==`, respectively `equals()`?
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最初，`listOfInt1` 和 `listOfInt2` 有相同的项，[`x1`=14, `y1`=14, `x2`=129, `y2`=129]。但是，根据
    `removeIf()` 和 `==` 或 `equals()` 执行代码后，`listOfInt1`/`listOfInt2` 将包含什么？
- en: The first list will remain with a single item, [129]. When `t` is `x1`, we know
    that `x1 == x1`, so 14 is removed. But, why is `x2` removed? When `t` is `y1`,
    we know that `y1 == x1` should be `false` since, via `==`, we compare the object’s
    references in memory, not their values. Obviously, `y1` and `x1` should have different
    references in the memory… or shouldn’t they ? Actually, Java has an internal rule
    to cache integers in -127 … 128\. Since `x1`=14 is cached, `y1`=14 uses the cache
    so no new `Integer` is created. This is why `y1 == x1` and `y1` is removed as
    well. Next, `t` is `x2`, and `x2 == x2`, so `x2` is removed. Finally, `t` is `y2`,
    but `y2 == x2` returns `false`, since 129 > 128 is not cached, so `x2` and `y2`
    have different references in memory.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个列表将保留一个单独的项目，[129]。当 `t` 是 `x1` 时，我们知道 `x1 == x1`，所以 14 被移除。但是，为什么 `x2` 会被移除？当
    `t` 是 `y1` 时，我们知道 `y1 == x1` 应该是 `false`，因为通过 `==`，我们比较的是对象在内存中的引用，而不是它们的值。显然，`y1`
    和 `x1` 应该在内存中有不同的引用……或者不是吗？实际上，Java 有一个内部规则，将整数缓存于 -127 … 128 之间。由于 `x1`=14 被缓存，`y1`=14
    使用了缓存，因此没有创建新的 `Integer`。这就是为什么 `y1 == x1` 和 `y1` 也会被移除。接下来，`t` 是 `x2`，且 `x2 ==
    x2`，所以 `x2` 也会被移除。最后，`t` 是 `y2`，但 `y2 == x2` 返回 `false`，因为 129 > 128 没有被缓存，所以
    `x2` 和 `y2` 在内存中有不同的引用。
- en: On the other hand, when we use `equals()`, which is the recommended approach
    for comparing the object’s values, the resulting list is empty. When `t` is `x1`,
    `x1` =`x1`, so 14 is removed. When `t` is `y1`, `y1` =`x1`, so `y1` is removed
    as well. Next, `t` is `x2`, and `x2`= `x2`, so `x2` is removed. Finally, `t` is
    `y2`, and `y2` =`x2`, so `y2` is removed as well.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们使用 `equals()` 方法，这是比较对象值推荐的方法，结果列表将是空的。当 `t` 是 `x1` 时，`x1` =`x1`，因此
    14 被移除。当 `t` 是 `y1` 时，`y1` =`x1`，因此 `y1` 也会被移除。接下来，`t` 是 `x2`，且 `x2`= `x2`，所以
    `x2` 也会被移除。最后，`t` 是 `y2`，且 `y2` =`x2`，所以 `y2` 也会被移除。
- en: 56\. Hooking instanceof in a nutshell
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 56. 简而言之，挂钩 instanceof
- en: 'Having an object (`o`) and a type (`t`), we can use the `instanceof` operator
    to test if `o` is of type `t` by writing `o instanceof t`. This is a `boolean`
    operator that is very useful to ensure the success of a subsequent casting operation.
    For instance, check the following:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个对象（`o`）和一个类型（`t`），我们可以使用 `instanceof` 操作符通过编写 `o instanceof t` 来测试 `o` 是否为类型
    `t`。这是一个非常有用的 `boolean` 操作符，可以确保后续类型转换操作的成功。例如，检查以下内容：
- en: '[PRE123]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '`instanceof` returns `true` if we test the object (for instance, `Wardrobe`)
    against the type itself:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 如果我们测试对象（例如，`Wardrobe`）与类型本身，则返回 `true`：'
- en: '[PRE124]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '`instanceof` returns true if the tested object (for instance, `Wardrobe`) is
    an instance of a subclass of the type (for instance `Plywood`):'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试对象（例如，`Wardrobe`）是类型的子类的实例（例如 `Plywood`），则 `instanceof` 返回 `true`：
- en: '[PRE125]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '`instanceof` returns `true` if the tested object (for instance, `Wardrobe`)
    implements the interface represented by the type (for instance, `Furniture`):'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试对象（例如，`Wardrobe`）实现了由类型表示的接口（例如，`Furniture`），则 `instanceof` 返回 `true`：
- en: '[PRE126]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Based on this, consider the following note:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，请注意以下内容：
- en: '**Important note**'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: The logic behind `instanceof` relies on the IS-A relationship (this is detailed
    in *The Complete Coding Interview Guide in Java*, *Chapter 6*, *What is inheritance?*).
    In a nutshell, this relationship is based on interface implementation or class
    inheritance. For instance, `wardrobe instanceof Plywood` returns `true` because
    `Wardrobe` extends `Plywood`, so `Wardrobe` IS A `Plywood`. Similarly, `Wardrobe`
    IS A `Furniture`. On the other hand, `Plywood` IS-not-A `Furniture`, so `plywood
    instanceof Furniture` returns `false`. In this context, since every Java class
    extends `Object`, we know that `foo instanceof Object` returns `true` as long
    as `foo` is an instance of a Java class. In addition, `null instanceof Object`
    (or any other object) returns `false`, so this operator doesn’t require an explicit
    `null` check.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 的逻辑依赖于 IS-A 关系（这在 *Java 完整编码面试指南*，第 6 章，*什么是继承？* 中有详细说明）。简而言之，这种关系基于接口实现或类继承。例如，`wardrobe
    instanceof Plywood` 返回 `true`，因为 `Wardrobe` 扩展了 `Plywood`，所以 `Wardrobe` 是 `Plywood`
    的一个实例。同样，`Wardrobe` 是 `Furniture` 的一个实例。另一方面，`Plywood` 不是 `Furniture` 的一个实例，所以
    `plywood instanceof Furniture` 返回 `false`。在此上下文中，由于每个 Java 类都扩展了 `Object`，我们知道只要
    `foo` 是一个 Java 类的实例，`foo instanceof Object` 就会返回 `true`。此外，`null instanceof Object`（或任何其他对象）返回
    `false`，因此这个操作符不需要显式的 `null` 检查。'
- en: 'Finally, keep in mind that `instanceof` works only with reified types (reified
    type information is available at runtime), which include:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，`instanceof` 只与可重载类型一起使用（可重载类型信息在运行时可用），包括：
- en: Primitive types (`int`, `float`)
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本类型（`int`, `float`）
- en: Raw types (`List`, `Set`)
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型（`List`, `Set`）
- en: Non-generic classes/interfaces (`String`)
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非泛型类/接口（`String`）
- en: Generic types with unbounded wildcards (`List<?>`, `Map<?, ?>`)
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有未绑定通配符的泛型类型（`List<?>`, `Map<?, ?>`）
- en: Arrays of reifiable types (`String[]`, `Map<?, ?>[]`, `Set<?>[]`)
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重载类型的数组（`String[]`, `Map<?, ?>[]`, `Set<?>[]`）
- en: This means that we cannot use the `instanceof` operator (or casts) with parameterized
    types because the type erasures alter all type parameters in generic code, so
    we cannot say which parameterized type for a generic type is in use at runtime.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们无法在参数化类型中使用 `instanceof` 操作符（或类型转换），因为类型擦除会改变泛型代码中的所有类型参数，所以我们无法在运行时确定泛型类型所使用的参数化类型。
- en: 57\. Introducing pattern matching
  id: totrans-593
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 57. 介绍模式匹配
- en: JDK 16 has introduced one of the major and complex features of Java, referred
    to as *pattern matching*. The future is wide open for this topic.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 16 引入了 Java 的一些主要且复杂的特性之一，称为 *模式匹配*。这个主题的未来前景广阔。
- en: In a nutshell, *pattern matching* defines a synthetic expression for checking/testing
    whether a given variable has certain properties. If those properties are met,
    then automatically extract one or more parts of that variable into other variables.
    From this point forward, we can use those extracted variables.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*模式匹配*定义了一个用于检查/测试给定变量是否具有某些属性的合成表达式。如果这些属性满足条件，则自动将变量的一个或多个部分提取到其他变量中。从这一点开始，我们可以使用这些提取的变量。
- en: 'A pattern matching instance (pay attention, this has nothing to do with design
    patterns) is a structure made of several components as follows (this is basically
    the pattern matching terminology):'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配实例（请注意，这与设计模式无关）是由以下几个组件组成的结构（这基本上是模式匹配的术语）：
- en: 'The *target operand* or the argument of the predicate: This is a variable (or
    an expression) that we aim to match.'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*目标操作数*或谓词的参数：这是我们旨在匹配的变量（或表达式）。'
- en: 'The *predicate* (or *test*): This is a check that takes place at runtime and
    aims to determine if the given *target operand* does or doesn’t have one or more
    properties (we match the *target operand* against the properties).'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*谓词*（或*测试*）：这是一个在运行时进行的检查，旨在确定给定的 *目标操作数* 是否具有一个或多个属性（我们将 *目标操作数* 与属性进行匹配）。'
- en: 'One or more variables are referred to as *pattern variables* or *binding variables*:
    these variables are automatically extracted from the *target operand* if and only
    if the *predicate*/*test* succeeds.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个变量被称为*模式变量*或*绑定变量*：这些变量仅在谓词/测试成功时自动从*目标操作数*中提取。
- en: Finally, we have the *pattern* itself, which is represented by the *predicate*
    + *binding variables*.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有*模式*本身，它由*谓词* + *绑定变量*表示。
- en: '![Figure 2.31.png](img/B19665_02_31.png)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
  zh: '![图2.31.png](img/B19665_02_31.png)'
- en: 'Figure 2.31: Pattern matching components'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.31：模式匹配组件
- en: 'So, we can say that Java pattern matching is a synthetic expression of a complex
    solution composed of four components: target operand, predicate/test, binding
    variable(s), and pattern = predicate + binding variable(s).'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以这样说，Java的模式匹配是一个由四个组件组成的复杂解决方案的合成表达式：目标操作数、谓词/测试、绑定变量（s）和模式 = 谓词 + 绑定变量（s）。
- en: The scope of binding variables in pattern matching
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配中绑定变量的作用域
- en: The compiler decides the scope (visibility) of the binding variables, so we
    don’t have to bother with such aspects via special modifiers or other tricks.
    In the case of predicates that always pass (like an `if(true) {}`), the compiler
    scopes the binding variables exactly as for the Java *local variables*.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器决定绑定变量的作用域（可见性），所以我们不需要通过特殊修饰符或其他技巧来处理这些方面。在谓词始终通过的情况下（如`if(true) {}`），编译器将绑定变量的作用域精确地设置为Java的*局部变量*。
- en: But, most patterns make sense precisely because the predicate may fail. In such
    cases, the compiler applies a technique called *flow scoping*. That is actually
    a combination of the *regular scoping* and *definitive assignment*.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，大多数模式之所以有意义，正是因为谓词可能会失败。在这种情况下，编译器应用一种称为*流作用域*的技术。这实际上是*常规作用域*和*确定赋值*的组合。
- en: The *definitive assignment* is a technique used by the compiler based on the
    structure of statements and expressions to ensure that a local variable (or blank
    `final` field) is definitely assigned before it is accessed by the code. In a
    pattern-matching context, a binding variable is assigned only if the predicate
    passes, so the *definitive assignment* aim is to find out the precise place when
    this is happening. Next, the regular block scope represents the code where the
    binding variable is in scope.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**确定赋值**是编译器根据语句和表达式的结构使用的一种技术，以确保在代码访问之前，局部变量（或空白`final`字段）确实被赋值。在模式匹配的上下文中，只有当谓词通过时，绑定变量才会被赋值，因此**确定赋值**的目标是找出这种赋值发生的精确位置。接下来，常规代码块作用域表示绑定变量在作用域内的代码。'
- en: Do you want this as a simple important note? Here it is.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要这个简单的重要提示吗？这里就是。
- en: '**Important note**'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: In pattern matching, the binding variable is flow-scoped. In other words, the
    scope of a binding variable covers only the block where the predicate passed.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式匹配中，绑定变量是流作用域的。换句话说，绑定变量的作用域仅覆盖传递谓词的代码块。
- en: We will cover this topic in *Problem 59*.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*问题59*中介绍这个主题。
- en: Guarded patterns
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 守卫模式
- en: So far, we know that a pattern relies on a predicate/test for deciding whether
    the binding variables should be extracted from the target operand or not. In addition,
    sometimes we need to refine this predicate by appending to it extra `boolean`
    checks based on the extracted binding variables. We name this a *guarded pattern*.
    In other words, if the predicate evaluates to `true`, then the binding variables
    are extracted and they enter in further `boolean` checks. If these checks are
    evaluated to `true`, we can say that the target operand matches this guarded pattern.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道模式依赖于谓词/测试来决定是否应从目标操作数中提取绑定变量。此外，有时我们需要通过附加基于提取的绑定变量的额外`boolean`检查来细化这个谓词。我们称这为*守卫模式*。换句话说，如果谓词评估为`true`，则提取绑定变量，并且它们进入进一步的`boolean`检查。如果这些检查评估为`true`，我们可以说目标操作数与这个守卫模式匹配。
- en: We cover this in *Problem 64*.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*问题64*中介绍这一点。
- en: Type coverage
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型覆盖率
- en: In a nutshell, the `switch` expressions and `switch` statements that use `null`
    and/or pattern labels should be exhaustive. In other words, we must cover all
    the possible values with `switch case` labels.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用`null`和/或模式标签的`switch`表达式和`switch`语句应该是详尽的。换句话说，我们必须使用`switch case`标签涵盖所有可能的值。
- en: We cover this in *Problem 66*.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*问题66*中介绍这一点。
- en: Current status of pattern matching
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式匹配的当前状态
- en: Currently, Java supports type pattern matching for `instanceof` and `switch`,
    and record pattern-destructuring patterns for records (covered in *Chapter 4*).
    These are the final releases in JDK 21.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Java支持`instanceof`和`switch`的类型模式匹配，以及记录的记录模式解构（在第4章中介绍）。这些是JDK 21的最终发布版本。
- en: 58\. Introducing type pattern matching for instanceof
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 58. 介绍`instanceof`的类型模式匹配
- en: '[PRE127]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'You’re right…type checking and casting are burdensome to write and read. Moreover,
    those check-cast sequences are error-prone (it is easy to change the checked type
    or the casted type and forget to change the type of the other object). Basically,
    in each conditional statement, we do three steps, as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 你说得对……类型检查和转型既难以编写也难以阅读。此外，那些检查转型序列容易出错（很容易更改检查的类型或转型的类型，而忘记更改另一个对象类型）。基本上，在每一个条件语句中，我们执行三个步骤，如下所示：
- en: First, we do a type check (for instance, `o instanceof File`).
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们进行类型检查（例如，`o instanceof File`）。
- en: Second, we do a type conversion via cast (for instance, `(File) o`).
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，我们通过转型进行类型转换（例如，`(File) o`）。
- en: Third, we do a variable assignment (for instance, `File file =`).
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三，我们进行变量赋值（例如，`File file =`）。
- en: 'But, starting with JDK 16 (JEP 394), we can use *type pattern matching for
    instanceof* to perform the previous three steps in one expression. The type pattern
    is the first category of patterns supported by Java. Let’s see the previous code
    rewritten via the *type pattern*:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，从JDK 16（JEP 394）开始，我们可以使用`instanceof`的*类型模式匹配*来在一个表达式中执行前面的三个步骤。类型模式是Java支持的第一个模式类别。让我们看看通过*类型模式*重写的之前的代码：
- en: '[PRE129]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In each `if`-`then` statement, we have a test/predicate to determine the type
    of `Object o`, a cast of `Object o` to `File`, `Path`, or `String`, and a destructuring
    phase for extracting either the length or the size from `Object o`.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`if-then`语句中，我们有一个测试/谓词来确定`Object o`的类型，将`Object o`转换为`File`、`Path`或`String`，以及从`Object
    o`中提取长度或大小的解构阶段。
- en: The piece of code, (`o instanceof File file`) is not just some syntactic sugar.
    It is not just a convenient shortcut of the old-fashioned code to reduce the ceremony
    of conditional state extraction. This is a *type pattern* in action!
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码（`o instanceof File file`）不仅仅是某种语法糖。它不仅仅是旧式代码的便捷快捷方式，以减少条件状态提取的仪式。这是一个正在运行的*类型模式*！
- en: 'Practically, we match the variable `o` against `File file`. More precisely,
    we match the type of `o` against the type `File`. We have that `o` is the *target
    operand* (the argument of the predicate), `instanceof File` is the predicate,
    and the variable `file` is the *pattern* or *binding variable* that is automatically
    created only if `instanceof File` returns `true`. Moreover, `instanceof File file`
    is the *type pattern*, or in short, `File file` is the pattern itself. The following
    figure illustrates this statement:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将变量`o`与`File file`进行匹配。更准确地说，我们将`o`的类型与`File`类型进行匹配。我们有`o`是*目标操作数*（谓词的参数），`instanceof
    File`是谓词，而变量`file`是*模式*或*绑定变量*，只有当`instanceof File`返回`true`时才会自动创建。此外，`instanceof
    File file`是*类型模式*，简而言之，`File file`就是模式本身。以下图示说明了这个语句：
- en: '![Figure 2.32.png](img/B19665_02_32.png)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![图2.32.png](img/B19665_02_32.png)'
- en: 'Figure 2.32: Type pattern matching for instanceof'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.32：`instanceof`的类型模式匹配
- en: 'In the type pattern for `instanceof`, there is no need to perform explicit
    `null` checks (exactly as in the case of plain `instanceof`), and no upcasting
    is allowed. Both of the following examples generate a compilation error in JDK
    16-20, but not in JDK 14/15/21 (this is weird indeed):'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在`instanceof`的类型模式中，不需要执行显式的`null`检查（正如在普通`instanceof`的情况下），也不允许向上转型。以下两个示例在JDK
    16-20中会生成编译错误，但在JDK 14/15/21中不会（这确实很奇怪）：
- en: '[PRE130]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The compilation error points out that the expression type cannot be a subtype
    of pattern type (no upcasting is allowed). However, with plain `instanceof`, this
    works in all JDKs:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误指出，表达式类型不能是模式类型的子类型（不允许向上转型）。然而，使用普通的`instanceof`，这在所有JDK中都是可行的：
- en: '[PRE131]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Next, let’s talk about the scope of binding variables.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈绑定变量的作用域。
- en: 59\. Handling the scope of a binding variable in type patterns for instanceof
  id: totrans-639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 59. 处理`instanceof`类型模式中的绑定变量作用域
- en: 'From *Problem 57*, we know the headlines of scoping the binding variables in
    pattern matching. Moreover, we know from the previous problem that in the type
    pattern for `instanceof`, we have a single binding variable. It is time to see
    some practical examples, so let’s quickly crop this snippet from the previous
    problem:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *问题 57* 中，我们知道在模式匹配中绑定变量的作用域。此外，从上一个问题中我们知道，在 `instanceof` 的类型模式中，我们有一个单一的绑定变量。是时候看看一些实际例子了，所以让我们快速从上一个问题中提取这个代码片段：
- en: '[PRE132]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The conditional part that starts with the `&&` short-circuit operator is evaluated
    by the compiler only if the `instanceof` operator is evaluated to `true`. This
    means that you cannot use the `||` operator instead of `&&`. For instance, is
    not logical to write this:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `&&` 短路运算符开始的条件部分只有在 `instanceof` 运算符评估为 `true` 时才会由编译器评估。这意味着你不能用 `||` 运算符代替
    `&&`。例如，以下写法是不合逻辑的：
- en: '[PRE134]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'On the other hand, this is perfectly acceptable:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这是完全可以接受的：
- en: '[PRE135]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'We can also extend the scope of the binding variable as follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扩展绑定变量的作用域如下：
- en: '[PRE136]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Since we negate the `if`-then statement, the `str` binding variable is available
    in the `else` branch. Following this logic, we can use *early returns* as well:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们否定了 `if-then` 语句，`str` 绑定变量在 `else` 分支中可用。按照这个逻辑，我们还可以使用 *早期返回*：
- en: '[PRE137]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Thanks to flow scoping, the compiler can set up strict boundaries for the scope
    of binding variables. For instance, in the following code, there is no risk of
    overlapping even if we keep using the same name for the binding variables:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了流作用域，编译器可以为绑定变量的作用域设置严格的边界。例如，在以下代码中，即使我们继续使用相同的绑定变量名称，也不会有重叠的风险：
- en: '[PRE138]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Here, each `nr` binding variable has a scope that covers only its own branch.
    No overlapping, no conflicts! However, using the same name for the multiple binding
    variables can be a little bit confusing, so it is better to avoid it. For instance,
    we can use `intNr` and `longNr` instead of simple `nr`.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个 `nr` 绑定变量的作用域仅覆盖其自身的分支。没有重叠，没有冲突！然而，使用相同的名称为多个绑定变量可能会有些混乱，因此最好避免这样做。例如，我们可以使用
    `intNr` 和 `longNr` 而不是简单的 `nr`。
- en: 'Another confusing scenario that is highly recommended to be avoided implies
    binding variables that hide fields. Check out this code:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应该避免的令人困惑的场景是隐藏字段的绑定变量。查看以下代码：
- en: '[PRE139]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: So, using the same name for binding variables (this is true for any local variable
    as well) and fields is a bad practice that should be avoided.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为绑定变量（这同样适用于任何局部变量以及字段）使用相同的名称是一种不良实践，应该避免。
- en: 'In JDK 14/15, we cannot reassign binding variables because they are declared
    `final` by default. However, JDK 16+ solved the asymmetries that may occur between
    local and binding variables by removing the `final` modifier. So, starting with
    JDK 16+, we can reassign binding variables as in the following snippet:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 14/15 中，我们不能重新赋值绑定变量，因为它们默认被声明为 `final`。然而，JDK 16+ 通过移除 `final` 修饰符解决了本地变量和绑定变量之间可能出现的非对称性。因此，从
    JDK 16+ 开始，我们可以像以下代码片段那样重新赋值绑定变量：
- en: '[PRE140]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Even if this is possible, it is highly recommended to avoid such *code smells*
    and keep the world clean and happy by not re-assigning your binding variables.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这是可能的，也强烈建议避免这种 *代码异味*，通过不重新赋值你的绑定变量来保持世界清洁和愉快。
- en: 60\. Rewriting equals() via type patterns for instanceof
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 60. 通过类型模式重写 `instanceof` 的 `equals()`
- en: 'It is not mandatory to rely on `instanceof` to implement the `equals()` method,
    but it is a convenient approach to write something as follows:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方法 `equals()` 不必依赖于 `instanceof`，但将其编写如下是一种方便的方法：
- en: '[PRE141]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'If you are a fan of the previous approach for implementing `equals()`, then
    you’ll love rewriting it via a type pattern for `instanceof`. Check out the following
    snippet:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢之前实现 `equals()` 的方法，那么你将喜欢通过类型模式重写 `instanceof`。查看以下代码片段：
- en: '[PRE142]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'If `MyPoint` is generic (`MyPoint<E>`) then simply use a wildcard as follows
    (more details are available in the next problem):'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `MyPoint` 是泛型 (`MyPoint<E>`)，则可以简单地使用通配符如下（更多细节将在下一个问题中提供）：
- en: '[PRE143]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Cool, right?! However, pay attention that using `instanceof` to express the
    `equals()` contract imposes the usage of a `final` class of `final equals()`.
    Otherwise, if subclasses are allowed to override `equals()`, then `instanceof`
    may cause transitivity/symmetry bugs. A good approach is to pass `equals()` through
    a dedicated verifier such as equals verifier ([https://github.com/jqno/equalsverifier](https://github.com/jqno/equalsverifier)),
    which is capable of checking the validity of the `equals()` and `hashCode()` contracts.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧？！然而，请注意，使用`instanceof`来表示`equals()`契约强制使用`final`类和`final equals()`。否则，如果子类允许覆盖`equals()`，那么`instanceof`可能会导致传递性/对称性错误。一种好的方法是使用专门的验证器（如equals验证器[https://github.com/jqno/equalsverifier](https://github.com/jqno/equalsverifier)）传递`equals()`，该验证器能够检查`equals()`和`hashCode()`契约的有效性。
- en: 61\. Tackling type patterns for instanceof and generics
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 61. 解决instanceof和泛型的类型模式问题
- en: '[PRE144]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: As we know from *Problem 56*, we can combine `instanceof` with generic types
    via unbounded wildcards, such as our `EnumMap<?, ? extends V>` (or `EnumMap<?,
    ?>`, but not `EnumMap<K, ? extends V>`, `EnumMap<K, ?>`, or `EnumMap<K, V>`).
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从*问题56*中得知，我们可以通过无界通配符将`instanceof`与泛型类型结合使用，例如我们的`EnumMap<?, ? extends V>`（或`EnumMap<?,
    ?>`，但不能是`EnumMap<K, ? extends V>`、`EnumMap<K, ?>`或`EnumMap<K, V>`）。
- en: 'This code can be written more concisely via the type pattern for `instanceof`
    as follows:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以通过`instanceof`的类型模式更简洁地编写如下：
- en: '[PRE146]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: In the example based on plain `instanceof`, we can also replace `EnumMap<?,
    ? extends V>` with `Map<?, ? extends V>`. But, as we know from *Problem 53*, this
    is not possible with type patterns because the expression type cannot be a subtype
    of pattern type (upcasting is allowed). However, this is not an issue anymore
    starting with JDK 21.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于普通`instanceof`的示例中，我们还可以将`EnumMap<?, ? extends V>`替换为`Map<?, ? extends V>`。但是，如我们从*问题53*中得知，由于表达式类型不能是模式类型的子类型（允许向上转型），因此这不可能通过类型模式实现。然而，从JDK
    21开始，这不再是问题。
- en: 62\. Tackling type patterns for instanceof and streams
  id: totrans-675
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 62. 解决instanceof和流的类型模式问题
- en: 'Let’s consider a `List<Engine>` where `Engine` is an interface implemented
    by several classes such as `HypersonicEngine`, `HighSpeedEngine`, and `RegularEngine`.
    Our goal is to filter this `List` and eliminate all `RegularEngine` classes that
    are electric and cannot pass our autonomy test. So, we can write code as follows:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个`List<Engine>`，其中`Engine`是一个由几个类（如`HypersonicEngine`、`HighSpeedEngine`和`RegularEngine`）实现的接口。我们的目标是过滤这个`List`并消除所有电动且无法通过我们的自主性测试的`RegularEngine`类。因此，我们可以编写如下代码：
- en: '[PRE147]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'But, starting with JDK 8, we can safely remove from a `List` without using
    an `Iterator` via a `default` method from `java.util.Collection` named `public
    default boolean removeIf(Predicate<? super E> filter)`. If we combine this method
    (and, therefore, the Stream API) with type patterns for `instanceof`, then we
    can simplify the previous code as follows:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，从JDK 8开始，我们可以通过`java.util.Collection`的`default`方法`public default boolean
    removeIf(Predicate<? super E> filter)`安全地从`List`中移除元素，而无需使用`Iterator`。如果我们结合这个方法（以及因此，Stream
    API）与`instanceof`的类型模式，那么我们可以将之前的代码简化如下：
- en: '[PRE148]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: So, whenever you have the chance to use type patterns with the Stream API, don’t
    hesitate.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，每当有机会使用Stream API与类型模式结合时，不要犹豫。
- en: 63\. Introducing type pattern matching for switch
  id: totrans-681
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 63. 引入switch的类型模式匹配
- en: JDK 17 (JEP 406) added type pattern matching for `switch` as a preview feature.
    A second preview was available in JDK 18 (JEP 420). The final release is available
    in JDK 21 as JEP 441.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 17（JEP 406）作为预览功能添加了`switch`的类型模式匹配。第二个预览版本在JDK 18（JEP 420）中可用。最终版本在JDK
    21作为JEP 441发布。
- en: Type pattern matching for `switch` allows the *selector expression* (that is,
    `o` in `switch(o)`) to be of any type not just an `enum` constant, number, or
    string. By “any type,” I mean any type (any object type, `enum` type, array type,
    record type, or sealed type)! The type pattern matching is not limited to a single
    hierarchy as it happens in the case of inheritance polymorphism. The `case` labels
    can have type patterns (referred to as case pattern labels or, simply, pattern
    labels), so the selector expression (`o`) can be matched against a type pattern,
    not only against a constant.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`的类型模式匹配允许*选择表达式*（即`switch(o)`中的`o`）为任何类型，而不仅仅是枚举常量、数字或字符串。这里的“任何类型”指的是任何类型（任何对象类型、枚举类型、数组类型、记录类型或密封类型）！类型模式匹配不仅限于单个继承层次，这在继承多态的情况下是常见的。`case`标签可以有类型模式（称为case模式标签或简单地称为模式标签），因此选择表达式（`o`）可以与类型模式匹配，而不仅仅是与常量匹配。'
- en: '[PRE149]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The following figure identifies the main players of a `switch` branch:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 下图标识了`switch`分支的主要参与者：
- en: '![Figure 2.33.png](img/B19665_02_33.png)'
  id: totrans-687
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.33.png](img/B19665_02_33.png)'
- en: 'Figure 2.33: Type pattern matching for switch'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.33：开关的类型模式匹配
- en: The `case` for `null` is not mandatory. We have added it just for the sake of
    completeness. On the other hand, the `default` branch is a must, but this topic
    is covered later in this chapter.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `null` 的 `case` 不是强制的。我们只是为了完整性而添加它。另一方面，`default` 分支是必须的，但这个主题将在本章后面讨论。
- en: 64\. Adding guarded pattern labels in switch
  id: totrans-690
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 64. 在开关中添加守卫模式标签
- en: 'Do you remember that type patterns for `instanceof` can be refined with extra
    `boolean` checks applied to the binding variables to obtain fine-grained use cases?
    Well, we can do the same for the `switch` expressions that use pattern labels.
    The result is named *guarded pattern labels*. Let’s consider the following code:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得 `instanceof` 的类型模式可以通过对绑定变量应用额外的 `boolean` 检查来细化，以获得更精细的使用案例吗？嗯，我们也可以对使用模式标签的
    `switch` 表达式做同样的事情。结果是称为 *守卫模式标签*。让我们考虑以下代码：
- en: '[PRE151]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Having a `Stove` and a `Chimney`, this `switch` decides where to make a fire
    based on pattern labels. But, what will happen if `Chimney` is electric? Obviously,
    we will have to plug `Chimney` in instead of firing it up. This means that we
    should add a guarded pattern label that helps us to make the difference between
    an electric and non-electric `Chimney`:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `Stove` 和一个 `Chimney`，这个 `switch` 根据模式标签决定在哪里生火。但是，如果 `Chimney` 是电的会怎样？显然，我们必须插上
    `Chimney` 而不是点燃它。这意味着我们应该添加一个守卫模式标签，帮助我们区分电 `Chimney` 和非电 `Chimney`：
- en: '[PRE152]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Well, that was easy, wasn’t it? Let’s have another example that starts from
    the following code:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很简单，对吧？让我们再看一个从以下代码开始的例子：
- en: '[PRE153]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'For each `Vehicle`, we know the fuel type and how many gallons of fuel fit
    in the tank. Now, we can write a `switch` that can rely on guarded pattern labels
    to try to guess the type of the vehicle based on this information:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 `Vehicle`，我们知道燃料类型和油箱中可以容纳多少加仑的燃料。现在，我们可以编写一个 `switch`，它可以通过守卫模式标签来尝试根据这些信息猜测车辆的类型：
- en: '[PRE154]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Notice that the pattern labels are the same in all cases (`Vehicle v`) and
    the decision is refined via the guarded conditions. The previous examples work
    just fine in JDK 17 and 18, but they don’t work starting with JDK 19+. Because
    the `&&` operator was considered confusing, starting with JDK 19+, we have to
    deal with a refinement syntax. Practically, instead of the `&&` operator, we use
    the new context-specific keyword `when` between the pattern label and the refining
    `boolean` checks. So, in JDK 19+, the previous code becomes:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在所有情况下模式标签都是相同的（`Vehicle v`），决策是通过守卫条件来细化的。之前的例子在 JDK 17 和 18 中运行良好，但从 JDK
    19+ 开始就不适用了。因为 `&&` 运算符被认为容易混淆，从 JDK 19+ 开始，我们必须处理一种细化语法。实际上，我们不再使用 `&&` 运算符，而是在模式标签和细化
    `boolean` 检查之间使用新的上下文特定关键字 `when`。因此，在 JDK 19+ 中，之前的代码变为：
- en: '[PRE155]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: In the bundled code, you can find both versions for JDK 17/18, and JDK 19+.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在捆绑的代码中，你可以找到 JDK 17/18 和 JDK 19+ 的两个版本。
- en: 65\. Dealing with pattern label dominance in switch
  id: totrans-702
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 65. 在开关中处理模式标签的优先级
- en: 'The compiler matches the selector expression against the available pattern
    labels by testing the selector expression against each label starting from top
    to bottom (or, from the first to the last) in the exact order in which we wrote
    them in the `switch` block. This means that the first match wins. Let’s assume
    that we have the following base class (`Pill`) and some pills (`Nurofen`, `Ibuprofen`,
    and `Piafen`):'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通过从上到下（或，从第一个到最后一个）按我们在 `switch` 块中编写的确切顺序测试选择表达式与每个标签的匹配来匹配选择表达式与可用的模式标签。这意味着第一个匹配获胜。假设我们有以下基类（`Pill`）和一些药片（`Nurofen`、`Ibuprofen`
    和 `Piafen`）：
- en: '[PRE156]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Hierarchically speaking, `Nurofen`, `Ibuprofen`, and `Piafen` are three classes
    placed at the same hierarchical level since all of them have the `Pill` class
    as the base class. In an IS-A inheritance relationship, we say that `Nurofen`
    is a `Pill`, `Ibuprofen` is a `Pill`, and `Piafen` is also a `Pill`. Next, let’s
    use a `switch` to serve our clients the proper headache pill:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 从层次结构上来说，`Nurofen`、`Ibuprofen` 和 `Piafen` 是三个处于相同层次级别的类，因为它们都以 `Pill` 类为基础类。在
    IS-A 继承关系中，我们说 `Nurofen` 是 `Pill`，`Ibuprofen` 是 `Pill`，`Piafen` 也是 `Pill`。接下来，让我们使用
    `switch` 为我们的客户提供适当的头痛药片：
- en: '[PRE157]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Calling `headache(new Nurofen())` will match the first pattern label, `Nurofen
    nurofen`. In the same manner, `headache(new Ibuprofen())` matches the second pattern
    label, and `headache(new Piafen())` matches the third one. No matter how we mix
    the order of these label cases, they will work as expected because they are on
    the same level and none of them dominate the others.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `headache(new Nurofen())` 将匹配第一个模式标签 `Nurofen nurofen`。以同样的方式，`headache(new
    Ibuprofen())` 匹配第二个模式标签，而 `headache(new Piafen())` 匹配第三个。无论我们如何混合这些标签情况的顺序，它们都将按预期工作，因为它们处于同一级别，并且没有哪一个支配其他标签。
- en: 'For instance, since people don’t want headaches, they order a lot of Nurofen,
    so we don’t have any anymore. We represent this by removing/comment the corresponding
    case:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于人们不想头疼，他们订购了很多 Nurofen，所以我们已经没有更多的了。我们通过删除/注释相应的案例来表示这一点：
- en: '[PRE158]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: So, what happens when a client wants Nurofen? You’re right … the `default` branch
    will take action since `Ibuprofen` and `Piafen` don’t match the selector expression.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当客户想要 Nurofen 时会发生什么？你说得对……由于 `Ibuprofen` 和 `Piafen` 不匹配选择表达式，`default` 分支将采取行动。
- en: But, what will happen if we modify the `switch` as follows?
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们按如下方式修改 `switch`，会发生什么？
- en: '[PRE159]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Adding the `Pill` base class as a pattern label case allows us to remove the
    `default` branch since we cover all possible values (this is covered in detail
    in *Problem 66*). This time, the compiler will raise an error to inform us that
    the `Pill` label case dominates the rest of the label cases. Practically, the
    first label case `Pill pill` dominates all other label cases because every value
    that matches any of the `Nurofen nurofen`, `Ibuprofen ibuprofen`, `Piafen piafen`
    patterns also matches the pattern `Pill pill`. So, `Pill pill` always wins while
    the rest of the label cases are useless. Switching `Pill pill` with `Nurofen nurofen`
    will give a chance to `Nurofen nurofen`, but `Pill pill` will still dominate the
    remaining two. So, we can eliminate the dominance of the base class `Pill` by
    moving its label case to the last position:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Pill` 基类作为模式标签情况添加，使我们能够移除 `default` 分支，因为我们涵盖了所有可能值（这将在 *问题 66* 中详细说明）。这次，编译器将引发一个错误来通知我们
    `Pill` 标签情况支配了其他标签情况。实际上，第一个标签情况 `Pill pill` 支配了所有其他标签情况，因为任何与 `Nurofen nurofen`、`Ibuprofen
    ibuprofen`、`Piafen piafen` 模式匹配的值也匹配 `Pill pill` 模式。所以，`Pill pill` 总是获胜，而其他标签情况都是无用的。将
    `Pill pill` 与 `Nurofen nurofen` 交换将给 `Nurofen nurofen` 一个机会，但 `Pill pill` 仍然支配剩下的两个。因此，我们可以通过将它的标签情况移到最后位置来消除基类
    `Pill` 的支配性：
- en: '[PRE160]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Now, every pattern label has a chance to win.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个模式标签都有机会获胜。
- en: 'Let’s have another example that starts from this hierarchy:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个从这个层次结构开始的例子：
- en: '[PRE161]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'This time, we have seven classes disposed of in a multi-level hierarchy. If
    we exclude the base class `Drink`, we can represent the rest of them in a `switch`
    as follows:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们有七个类在一个多层次层次结构中排列。如果我们排除基类 `Drink`，我们可以如下表示其余的类：
- en: '[PRE162]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The order of pattern labels is imposed by the class hierarchy and is quite strict,
    but we can make some changes without creating any dominance issues. For instance,
    since `Extra` and `Large` are subclasses of `Medium`, we can switch their positions.
    Some things apply to `Jumbo` and `Huge` since they are both subclasses of `Medium`
    via `Extra`, respectively `Large`.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 模式标签的顺序由类层次结构决定，相当严格，但我们可以在不创建任何支配问题时进行一些更改。例如，由于 `Extra` 和 `Large` 都是 `Medium`
    的子类，我们可以交换它们的位置。由于 `Jumbo` 和 `Huge` 都是通过 `Extra` 分别 `Large` 成为 `Medium` 的子类，所以一些规则也适用于它们。
- en: 'In this context, the compiler evaluates the selection expression by trying
    to match it against this hierarchy via an IS-A inheritance relationship. For instance,
    let’s order a `Jumbo` drink while there are no more `Jumbo` and `Extra` drinks:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，编译器通过尝试通过 IS-A 继承关系将选择表达式与这个层次结构匹配来评估选择表达式。例如，当没有更多的 `Jumbo` 和 `Extra`
    饮料时，让我们点一杯 `Jumbo` 饮料：
- en: '[PRE163]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'If we order `Jumbo` (`o` is `Jumbo`), then we will get `Medium`. Why? The compiler
    matches `Jumbo` against `Huge` without success. The same result is obtained while
    matching `Jumbo` against `Large`. However, when it matches `Jumbo` against `Medium`,
    it sees that `Jumbo` is a `Medium` subclass via the `Extra` class. So, since `Jumbo`
    is `Medium`, the compiler chooses the `Medium m` pattern label. At this point,
    `Medium` matches `Jumbo`, `Extra`, and `Medium`. So, soon we will be out of `Medium`
    as well:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按 `Jumbo` 排序（`o` 是 `Jumbo`），那么我们将得到 `Medium`。为什么？编译器在匹配 `Jumbo` 与 `Huge`
    时没有成功。匹配 `Jumbo` 与 `Large` 时也会得到相同的结果。然而，当它匹配 `Jumbo` 与 `Medium` 时，它看到 `Jumbo`
    通过 `Extra` 类是 `Medium` 的子类。因此，由于 `Jumbo` 是 `Medium`，编译器选择了 `Medium m` 模式标签。在这个时候，`Medium`
    匹配 `Jumbo`、`Extra` 和 `Medium`。所以，很快我们也会用完 `Medium`：
- en: '[PRE164]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: This time, any request for `Jumbo`, `Extra`, `Medium`, or `Small` will give
    us a `Small`. I think you get the idea.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，任何对 `Jumbo`、`Extra`、`Medium` 或 `Small` 的请求都会给我们一个 `Small`。我想你已经明白了这个想法。
- en: 'Let’s take a step further, and analyze this code:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，分析以下代码：
- en: '[PRE165]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Have you spotted the problem? A pattern label case dominates a constant label
    case, so the compiler will complain about the fact that the second case (`case
    0`) is dominated by the first case. This is normal, since 0 is an `Integer` as
    well, so it will match the pattern label. The solution requires switching the
    cases:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现了问题吗？一个模式标签案例支配了一个常量标签案例，所以编译器会抱怨第二个案例（`case 0`）被第一个案例支配。这是正常的，因为 0 也是一个
    `Integer`，所以它将匹配模式标签。解决方案需要交换案例：
- en: '[PRE166]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Here is another case to enforce this type of dominance:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个强制执行此类优势的案例：
- en: '[PRE167]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'In this case, the constant is `HULK` and it is dominated by the `Hero h` pattern
    label case. This is normal, since `HULK` is also a Marvel hero, so `Hero h` will
    match all Marvel heroes including `HULK`. Again, the fix relies on switching the
    cases:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，常量是 `HULK`，它被 `Hero h` 模式标签案例支配。这是正常的，因为 `HULK` 也是一个漫威英雄，所以 `Hero h`
    将匹配所有漫威英雄，包括 `HULK`。同样，修复依赖于交换案例：
- en: '[PRE168]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Okay, finally, let’s tackle this snippet of code:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，最后，让我们来处理这段代码：
- en: '[PRE169]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'You may think that if we enforce the `Integer i` pattern label with a condition
    that forces `i` to be strictly positive, then the constant label will not be dominated.
    But, this is not true; a guarded pattern label still dominates a constant label.
    The proper order places the constant labels first, followed by guarded pattern
    labels, and finally, by non-guarded pattern labels. The next code fixes the previous
    one:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，如果我们通过一个强制 `i` 严格为正的条件来强制 `Integer i` 模式标签，那么常量标签就不会被支配。但这不是真的；受保护的模式标签仍然支配常量标签。正确的顺序是将常量标签放在前面，然后是受保护的模式标签，最后是非受保护的模式标签。下一个代码修复了上一个代码：
- en: '[PRE170]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Okay, I think you get the idea. Feel free to practice all these examples in
    the bundled code.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我想你已经明白了这个想法。请随意在捆绑的代码中练习所有这些示例。
- en: 66\. Dealing with completeness (type coverage) in pattern labels for switch
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 66. 在模式标签中处理完整性（类型覆盖）的 `switch`
- en: 'In a nutshell, `switch` expressions and `switch` statements that use null and/or
    pattern labels should be exhaustive. In other words, we must cover with explicit
    switch case labels all the possible values. Let’s consider the following example:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用 null 和/或模式标签的 `switch` 表达式和 `switch` 语句应该是详尽的。换句话说，我们必须使用显式的 `switch`
    案例标签来覆盖所有可能的值。让我们考虑以下示例：
- en: '[PRE171]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'If we continue by adding another vehicle such as `class Truck extends Vehicle
    {}`, then this will be handled by the `default` branch. If we plan to use `Vehicle`
    as an independent class (for instance, to enrich it with methods and functionalities),
    then we will prefer to add a `case Vehicle` as follows:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续添加另一个车辆，例如 `class Truck extends Vehicle {}`，那么这将由 `default` 分支处理。如果我们计划将
    `Vehicle` 作为独立的类（例如，通过添加方法和功能来丰富它），那么我们更愿意添加一个 `case Vehicle`，如下所示：
- en: '[PRE173]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: This time, the `Truck` class will match the `case Vehicle` branch. Of course,
    we can add a `case Truck` as well.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`Truck` 类将匹配 `case Vehicle` 分支。当然，我们也可以添加一个 `case Truck`。
- en: '**Important note**'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'The `Vehicle v` pattern is named a *total type pattern*. There are two labels
    that we can use to match all possible values: the total type pattern (for instance,
    a base class or an interface) and the `default` label. Generally speaking, a total
    pattern is a pattern that can be used instead of the `default` label.'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle v` 模式被命名为一个 *完全类型模式*。我们可以使用两个标签来匹配所有可能的值：完全类型模式（例如，一个基类或接口）和 `default`
    标签。一般来说，一个完全模式是可以用来代替 `default` 标签的模式。'
- en: In the previous example, we can accommodate all possible values via the total
    pattern or the `default` label but not both. This makes sense since the `whatAmI(Vehicle
    vehicle)` method gets `Vehicle` as an argument. So, in this example, the selector
    expression can be only `Vehicle` or a subclass of `Vehicle`. How about modifying
    this method as `whatAmI(Object o)`?
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们可以通过总模式或`default`标签来容纳所有可能的值，但不能同时使用两者。这很有道理，因为`whatAmI(Vehicle vehicle)`方法接收`Vehicle`作为参数。所以，在这个例子中，选择表达式只能是`Vehicle`或`Vehicle`的子类。那么，将这个方法修改为`whatAmI(Object
    o)`怎么样？
- en: '[PRE174]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Now, the selector expression can be any type, which means that the total pattern
    `Vehicle v` is not total anymore. While `Vehicle v` becomes an optional ordinary
    pattern, the new total pattern is `case Object obj`. This means that we can cover
    all possible values by adding the `default` label or the `case Object obj` total
    pattern:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择表达式可以是任何类型，这意味着总模式`Vehicle v`不再是总模式了。当`Vehicle v`变成一个可选的普通模式时，新的总模式是`case
    Object obj`。这意味着我们可以通过添加`default`标签或`case Object obj`总模式来覆盖所有可能的值：
- en: '[PRE175]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'I think you get the idea! How about using an interface for the base type? For
    instance, here is an example based on the Java built-in `CharSequence` interface:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你已经明白了这个想法！那么，使用接口作为基类怎么样？例如，这里有一个基于Java内置`CharSequence`接口的例子：
- en: '[PRE176]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'At this moment, the `switch` expression doesn’t cover the `CoolChar` type.
    So, we still need a `default` label or the total pattern, `case CharSequence charseq`,
    as follows:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，`switch`表达式没有覆盖`CoolChar`类型。所以，我们仍然需要一个`default`标签或总模式`case CharSequence
    charseq`，如下所示：
- en: '[PRE178]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Okay, let’s tackle this scenario on the `java.lang.constant.ClassDesc` built-in
    interface:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来处理这个场景，它涉及到`java.lang.constant.ClassDesc`内置接口：
- en: '[PRE179]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'This code compiles! There is no `default` label and no total pattern but the
    `switch` expression covers all possible values. How so?! This interface is declared
    as sealed via the `sealed` modifier:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译！没有`default`标签和总模式，但`switch`表达式覆盖了所有可能的值。怎么会这样？！这个接口是通过`sealed`修饰符声明的密封接口：
- en: '[PRE180]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Sealed interfaces/classes were introduced in JDK 17 (JEP 409) and we will cover
    this topic in *Chapter 8*. However, for now, it is enough to know that sealing
    allows us to have fine-grained control of inheritance so classes and interfaces
    define their permitted subtypes. This means that the compiler can determine all
    possible values in a `switch` expression. Let’s consider a simpler example that
    starts as follows:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 密封接口/类是在JDK 17（JEP 409）中引入的，我们将在*第8章*中介绍这个主题。然而，现在，只需要知道密封允许我们精细控制继承，因此类和接口定义了它们的允许子类型。这意味着编译器可以确定`switch`表达式中所有可能的值。让我们考虑一个更简单的例子，它开始如下：
- en: '[PRE181]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'And, let’s have a `switch` expression covering all possible values for `Player`:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们有一个覆盖`Player`所有可能值的`switch`表达式：
- en: '[PRE182]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The compiler is aware that the `Player` interface has only three implementations
    and all of them are covered via pattern labels. We can add a `default` label or
    the total pattern `case Player player`, but you most probably don’t want to do
    that. Imagine that we add a new implementation of the sealed `Player` interface
    named `Golf`:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器知道`Player`接口只有三个实现，并且它们都通过模式标签被覆盖。我们可以添加一个`default`标签或总模式`case Player player`，但你很可能不想这么做。想象一下，我们添加了一个名为`Golf`的新实现，它是密封的`Player`接口：
- en: '[PRE183]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: If the `switch` expression has a `default` label, then `Golf` values will be
    handled by this `default` branch. If we have the total pattern `Player player`,
    then this pattern will handle the `Golf` values. On the other hand, if none of
    the `default` labels or total patterns are present, the compiler will immediately
    complain that the `switch` expression doesn’t cover all possible values. So, we
    are immediately informed, and once we add a `case Golf g`, the error disappears.
    This way, we can easily maintain our code and have a guarantee that our `switch`
    expressions are always up to date and cover all possible values. The compiler
    will never miss the chance to inform us when a new implementation of `Player`
    is available.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`switch`表达式有一个`default`标签，那么`Golf`值将由这个`default`分支处理。如果我们有总模式`Player player`，那么这个模式将处理`Golf`值。另一方面，如果没有`default`标签或总模式，编译器会立即抱怨`switch`表达式没有覆盖所有可能的值。所以，我们会立即得到通知，一旦我们添加`case
    Golf g`，错误就会消失。这样，我们可以轻松地维护我们的代码，并保证我们的`switch`表达式始终是最新的，并覆盖所有可能的值。编译器永远不会错过通知我们`Player`的新实现的机会。
- en: 'A similar logic applies to Java enums. Consider the following `enum`:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的逻辑也适用于Java枚举。考虑以下`enum`：
- en: '[PRE184]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The compiler is aware of all the possible values for `PlayerTypes`, so the
    following `switch` expression compiles successfully:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器知道`PlayerTypes`的所有可能值，所以下面的`switch`表达式编译成功：
- en: '[PRE185]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Again, we can add a `default` label or the total pattern, `case PlayerTypes
    pt`. But, if we add a new value in the `enum` (for instance, `GOLF`), the compiler
    will delegate the `default` label or the total pattern to handle it. On the other
    hand, if none of these are available, the compiler will immediately complain that
    the `GOLF` value is not covered, so we can add it (`case GOLF g`) and create a
    golf player whenever required.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以添加一个`default`标签或总模式`case PlayerTypes pt`。但是，如果我们向`enum`中添加一个新值（例如，`GOLF`），编译器将委托`default`标签或总模式来处理它。另一方面，如果没有这些可用，编译器将立即抱怨`GOLF`值没有被覆盖，因此我们可以添加它（`case
    GOLF g`）并在需要时创建高尔夫球手。
- en: 'So far, so good! Now, let’s consider the following context:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！现在，让我们考虑以下上下文：
- en: '[PRE186]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'The sealed interface `Sport` allows only two subtypes: `PlayerClub` (a class)
    and `PlayerTypes` (an enum). If we write a `switch` that covers all possible values
    for `Sport`, then it will look as follows:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 密封接口`Sport`只允许两种子类型：`PlayerClub`（一个类）和`PlayerTypes`（一个枚举）。如果我们编写一个涵盖`Sport`所有可能值的`switch`，那么它将如下所示：
- en: '[PRE187]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'We immediately observe that writing case `PlayerTypes p when p == PlayerTypes.TENNIS`
    is not quite neat. What we actually want is `case PlayerTypes.TENNIS` but, until
    JDK 21, this is not possible since qualified enum constants cannot be used in
    `case` labels. However, starting with JDK 21, we can use qualified names of enum
    constants as labels, so we can write this:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即观察到编写`case PlayerTypes p when p == PlayerTypes.TENNIS`并不十分整洁。我们实际上想要的是`case
    PlayerTypes.TENNIS`，但是，直到JDK 21，这是不可能的，因为合格的枚举常量不能用于`case`标签。然而，从JDK 21开始，我们可以使用枚举常量的合格名称作为标签，因此我们可以写出这个：
- en: '[PRE188]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Done! Now you know how to deal with type coverage in `switch` expressions.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在你知道如何处理`switch`表达式的类型覆盖了。
- en: 67\. Understanding the unconditional patterns and nulls in switch expressions
  id: totrans-780
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 67. 理解`switch`表达式中无条件模式和`null`值
- en: 'Let’s imagine that we use JDK 17 and we have the following code:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们使用JDK 17，并且我们有以下代码：
- en: '[PRE189]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Notice the call, `drive(null)`. This call will hit the `Vehicle vehicle` total
    pattern, so even `null` values match total patterns. But, this means that the
    binding variable `vehicle` will also be `null`, which means that this branch is
    prone to `NullPointerException` (for instance, if we call a hypothetical method,
    `vehicle.start()`):'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到调用，`drive(null)`。这个调用将匹配`Vehicle vehicle`总模式，所以即使是`null`值也会匹配总模式。但是，这意味着绑定变量`vehicle`也将是`null`，这意味着这个分支容易抛出`NullPointerException`（例如，如果我们调用一个假设的方法，`vehicle.start()`）：
- en: '[PRE190]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Because `Vehicle vehicle` matches all possible values, it is known as a total
    pattern but also as an *unconditional pattern* since it matches everything unconditionally.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Vehicle vehicle`匹配所有可能的值，所以它被称为总模式，但也称为*无条件模式*，因为它无条件地匹配一切。
- en: 'But, as we know from *Problem 54*, starting with JDK 17+ (JEP 427), we can
    have a pattern label for `null` itself, so we can handle the previous shortcoming
    as follows:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如我们从*问题54*中知道的，从JDK 17+（JEP 427）开始，我们可以为`null`本身有一个模式标签，因此我们可以如下处理之前的不足：
- en: '[PRE191]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Yes, everybody agrees that adding a `case null` between vehicles looks awkward.
    Adding it at the end is not an option since will raise a dominance issue. So,
    starting with JDK 19+, adding this `case null` is no longer needed in this kind
    of scenario. Basically, the idea remains the same meaning that the unconditional
    pattern still only matches `null` values so it will not allow the execution of
    that branch. Actually, when a `null` value occurs, the `switch` expressions will
    throw a `NullPointerException` without even looking at the patterns. So, in JDK
    19+, this code will throw an NPE right away:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，每个人都同意在车辆之间添加`case null`看起来很尴尬。将其添加到末尾不是选项，因为它将引发优先级问题。所以，从JDK 19+开始，在这种情况下不再需要添加这个`case
    null`。基本上，这个想法保持不变，意味着无条件模式仍然只匹配`null`值，因此它不会允许执行该分支。实际上，当出现`null`值时，`switch`表达式会立即抛出`NullPointerException`，甚至不会查看模式。所以，在JDK
    19+中，这段代码会立即抛出NPE：
- en: '[PRE192]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'The NPE message reveals that `vehicle.start()` was never called. The NPE occurred
    much earlier:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: NPE消息表明`vehicle.start()`从未被调用。NPE发生得早得多：
- en: '[PRE193]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: We will expand on this topic later when we will talk about Java records.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在讨论Java记录时进一步探讨这个话题。
- en: Summary
  id: totrans-793
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'That’s all folks! This was a comprehensive chapter that covered four main topics,
    among others: `java.util.Objects`, immutability, `switch` expressions, and pattern
    matching for `instanceof` and `switch` expressions.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！这是一个全面章节，涵盖了四个主要主题，包括：`java.util.Objects`、不可变性、`switch` 表达式以及 `instanceof`
    和 `switch` 表达式的模式匹配。
- en: Join our community on Discord
  id: totrans-795
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ)'
- en: '![](img/QR_Code1139613064111216156.png)'
  id: totrans-798
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1139613064111216156.png)'
