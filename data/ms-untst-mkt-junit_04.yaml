- en: Chapter 4. Progressive Mockito
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。渐进式 Mockito
- en: This chapter distills the Mockito framework to its main core and provides technical
    examples. No previous knowledge of mocking is necessary.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提炼了 Mockito 框架的主要核心，并提供了技术示例。不需要对模拟有任何先前的知识。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Overview of Mockito
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mockito 概述
- en: Exploring Mockito APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Mockito API
- en: Advanced Mockito examples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级 Mockito 示例
- en: Behavior-driven development (BDD) with Mockito
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mockito 进行行为驱动开发（BDD）
- en: Working with Mockito
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Mockito 一起工作
- en: Mockito is an open source mock unit testing framework for Java. In the previous
    chapter, we read about test doubles and mock objects. Mockito allows mock object
    creation, verification, and stubbing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 是一个开源的 Java 模拟单元测试框架。在上一章中，我们阅读了有关测试替身和模拟对象的内容。Mockito 允许创建模拟对象、验证和存根。
- en: 'To find out more about Mockito, visit the following link:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Mockito 的信息，请访问以下链接：
- en: '[http://code.google.com/p/mockito/](http://code.google.com/p/mockito/)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://code.google.com/p/mockito/](http://code.google.com/p/mockito/)'
- en: Why should you use Mockito?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你为什么应该使用 Mockito？
- en: Automated tests are safety nets. They run and notify the user if the system
    is broken so that the offending code can be fixed very quickly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试是安全网。它们会运行并通知用户系统是否出现故障，以便可以非常快速地修复有问题的代码。
- en: If a test suite runs for an hour, the purpose of quick feedback is compromised.
    Unit tests should act as a safety net and provide quick feedback; this is the
    main principle of TDD.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试套件运行了一个小时，快速反馈的目的就受到了损害。单元测试应作为安全网并提供快速反馈；这是 TDD 的主要原则。
- en: I worked with an environment where when a piece of code is checked-in, the automated
    tests would run and would take hours to complete. So, a developer had to wait
    for an hour to check-in the new code unless the previous build/test run was complete.
    A developer can check-in the code in the middle of a build, but the best practice
    is to monitor the status before signing off; otherwise, the new code can break
    the next build and cause problem for the other developers. So, the developer has
    to wait for an additional hour to monitor the next build. This kind of slow build
    environment blocks the progress of development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个环境中工作，当一段代码被提交时，自动化测试会运行，需要花费数小时才能完成。因此，开发者必须等待一个小时才能提交新代码，除非之前的构建/测试运行完成。开发者可以在构建过程中提交代码，但最佳实践是在签出之前监控状态；否则，新代码可能会破坏下一个构建并给其他开发者带来问题。因此，开发者必须额外等待一个小时来监控下一个构建。这种缓慢的构建环境阻碍了开发进度。
- en: 'A test may take time to execute due to the following reasons:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以下原因，测试可能需要花费时间来执行：
- en: Sometimes a test acquires a connection from the database that fetches/updates
    data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时测试会从数据库获取连接以获取/更新数据
- en: It connects to the Internet and downloads files
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它连接到互联网并下载文件
- en: It interacts with an SMTP server to send e-mails
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与 SMTP 服务器交互以发送电子邮件
- en: It performs I/O operations
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它执行 I/O 操作
- en: Now the question is do we really need to acquire a database connection or download
    files to unit test code?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们是否真的需要在单元测试代码时获取数据库连接或下载文件？
- en: The answer is yes. If it doesn't connect to a database or download the latest
    stock price, few parts of the system remain untested. So, DB interaction or network
    connection is mandatory for a few parts of the system, and these are integration
    tests. To unit test these parts, the external dependencies need to be mocked out.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的。如果它没有连接到数据库或下载最新的股票价格，系统中的许多部分将未经过测试。因此，数据库交互或网络连接对于系统的某些部分是强制性的，这些是集成测试。为了对这些部分进行单元测试，需要模拟外部依赖。
- en: Mockito plays a key role in mocking out external dependencies. It mocks out
    the database connection or any external I/O behavior so that the actual logic
    can be unit tested.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 在模拟外部依赖方面发挥着关键作用。它模拟数据库连接或任何外部 I/O 行为，以便实际逻辑可以进行单元测试。
- en: Unit tests should adhere to a number of principles for flexibility and maintainability.
    The next section will elucidate the principles that we will follow throughout
    this journey.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应遵循多个原则以实现灵活性和可维护性。下一节将阐明我们将遵循的原则。
- en: Qualities of unit testing
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试的品质
- en: 'Unit tests should adhere to the following principles:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应遵循以下原则：
- en: '**Order independent and isolated**: The `ATest.java` test class should not
    be dependent on the output of the `BTest.java` test class, or a `when_an_user_is_deleted_the_associated_id_gets_deleted()`
    test should not depend on the execution of another `when_a_new_user_is_created_an_id_is_returned()`
    test. The tests shouldn''t fail if `BTest.java` is executed after `ATest.java`,
    or the `when_a_new_user_is_created_an_id_is_returned()`test is executed after
    `when_an_user_is_deleted_the_associated_id_gets_deleted()`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序无关和隔离**：`ATest.java` 测试类不应依赖于 `BTest.java` 测试类的输出，或者 `when_an_user_is_deleted_the_associated_id_gets_deleted()`
    测试不应依赖于另一个 `when_a_new_user_is_created_an_id_is_returned()` 测试的执行。如果 `BTest.java`
    在 `ATest.java` 之后执行，或者 `when_a_new_user_is_created_an_id_is_returned()` 测试在 `when_an_user_is_deleted_the_associated_id_gets_deleted()`
    之后执行，测试不应失败。'
- en: '**Trouble-free setup and run**: Unit tests should not require a DB connection
    or an Internet connection or a clean-up temp directory.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无障碍设置和运行**：单元测试不应需要数据库连接或互联网连接或清理临时目录。'
- en: '**Effortless execution**: Unit tests should run fine on all computers, not
    just on a specific computer.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松执行**：单元测试应在所有计算机上运行良好，而不仅仅是特定计算机上。'
- en: '**Formula 1 execution**: A test should not take more than a second to finish
    the execution.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一级方程式执行**：测试的执行时间不应超过一秒。'
- en: Mockito provides APIs to mock out the external dependencies and achieve the
    qualities mentioned here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 提供了模拟外部依赖项并实现此处提到的特性的 API。
- en: Drinking Mockito
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 喝 Mockito
- en: 'Download the latest Mockito binary from the following link and add it to the
    project dependency:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下链接下载最新的 Mockito 二进制文件并将其添加到项目依赖项中：
- en: '[http://code.google.com/p/mockito/downloads/list](http://code.google.com/p/mockito/downloads/list)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://code.google.com/p/mockito/downloads/list](http://code.google.com/p/mockito/downloads/list)'
- en: As of February 2014, the latest Mockito version is 1.9.5.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2014 年 2 月，最新的 Mockito 版本是 1.9.5。
- en: Configuring Mockito
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Mockito
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following Gradle script snippet will add a Mockito dependency to a Gradle
    project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Gradle 脚本片段将 Mockito 依赖项添加到 Gradle 项目中：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Mocking in action
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态模拟
- en: This section demonstrates the mock objects with a stock quote example. In the
    real world, people invest money on the stock market—they buy and sell stocks.
    A stock symbol is an abbreviation used to uniquely identify shares of a particular
    stock on a particular market, such as stocks of Facebook are registered on NASDAQ
    as FB and stocks of Apple as AAPL.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过股票报价示例演示了模拟对象。在现实世界中，人们会在股票市场上投资金钱——购买和出售股票。股票符号是用于在特定市场上唯一标识特定股票的缩写，例如
    Facebook 的股票在纳斯达克注册为 FB，而苹果的股票为 AAPL。
- en: 'We will build a stock broker simulation program. The program will watch the
    market statistics, and depending on the current market data, you can perform any
    of the following actions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个股票经纪人模拟程序。程序将监视市场统计数据，并根据当前市场数据执行以下任何操作：
- en: Buy stocks
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 买入股票
- en: Sell stocks
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卖出股票
- en: Hold stocks
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持有股票
- en: The domain classes that will be used in the program are `Stock`, `MarketWatcher`,
    `Portfolio`, and `StockBroker`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中将使用的域类有 `Stock`、`MarketWatcher`、`Portfolio` 和 `StockBroker`。
- en: '`Stock` represents a real-world stock. It has a symbol, company name, and price.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stock` 代表现实世界的股票。它有一个符号、公司名称和价格。'
- en: '`MarketWatcher` looks up the stock market and returns the quote for the stock.
    A real implementation of a market watcher can be implemented from [http://www.wikijava.org/wiki/Downloading_stock_market_quotes_from_Yahoo!_finance](http://www.wikijava.org/wiki/Downloading_stock_market_quotes_from_Yahoo!_finance).
    Note that the real implementation will connect to the Internet and download the
    stock quote from a provider.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketWatcher` 查找股票市场并返回股票报价。一个市场观察者的真实实现可以从 [http://www.wikijava.org/wiki/Downloading_stock_market_quotes_from_Yahoo!_finance](http://www.wikijava.org/wiki/Downloading_stock_market_quotes_from_Yahoo!_finance)
    实现。请注意，真实实现将连接到互联网并从提供商下载股票报价。'
- en: '`Portfolio` represents a user''s stock data such as the number of stocks and
    price details. `Portfolio` exposes APIs for getting the average stock price and
    buying and selling stocks. Suppose on day one someone buys a share at a price
    of $10.00, and on day two, the customer buys the same share at a price of $8.00\.
    So, on day two the person has two shares and the average price of the share is
    $9.00.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Portfolio` 代表用户的股票数据，例如股票数量和价格详情。`Portfolio` 提供了获取平均股票价格和买卖股票的 API。假设第一天某人以
    $10.00 的价格购买了一股股票，第二天，客户以 $8.00 的价格购买了同一股股票。因此，第二天这个人有两股股票，平均股价为 $9.00。'
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Look at the `perform` method. It takes a `portfolio` object and a `stock` object,
    calls the `getQuote` method of `MarketWatcher`, and passes a `stock` symbol. Then,
    it gets the average stock price from `portfolio` and compares the current market
    price with the average stock price. If the current stock price is 10 percent greater
    than the average price, then the `StockBroker` program sells 10 stocks from `Portfolio`;
    however, if the current stock price goes down by 10 percent, then the program
    buys shares from the market to average out the loss.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 `perform` 方法。它接受一个 `portfolio` 对象和一个 `stock` 对象，调用 `MarketWatcher` 的 `getQuote`
    方法并传递一个 `stock` 符号。然后，它从 `portfolio` 获取平均股价并与当前市场价格进行比较。如果当前股价比平均价格高 10%，则 `StockBroker`
    程序从 `Portfolio` 中卖出 10 股股票；然而，如果当前股价下跌 10%，则程序从市场上购买股份以平均损失。
- en: Why do we sell 10 stocks? This is just an example and 10 is just a number; this
    could be anything you want.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们卖出 10 股股票？这只是一个例子，10 只是一个数字；这可以是任何你想要的东西。
- en: '`StockBroker` depends on `Portfolio` and `MarketWatcher`; a real implementation
    of `Portfolio` should interact with a database, and `MarketWatcher` needs to connect
    to the Internet. So, if we write a unit test for the broker, we need to execute
    the test with a database and an Internet connection. A database connection will
    take time and Internet connectivity depends on the Internet provider. So, the
    test execution will depend on external entities and will take a while to finish.
    This will violate the quick test execution principle. Also, the database state
    might not be the same across all test runs. This is also applicable for the Internet
    connection service. Each time the database might return different values, and
    therefore asserting a specific value in your unit test is very difficult.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockBroker` 依赖于 `Portfolio` 和 `MarketWatcher`；`Portfolio` 的真实实现应该与数据库交互，而
    `MarketWatcher` 需要连接到互联网。因此，如果我们为经纪人编写单元测试，我们需要在数据库和互联网连接的情况下执行测试。数据库连接将花费时间，互联网连接取决于互联网提供商。因此，测试执行将依赖于外部实体，并且需要一段时间才能完成。这将违反快速测试执行原则。此外，数据库状态可能不会在所有测试运行中相同。这也适用于互联网连接服务。每次数据库可能返回不同的值，因此在单元测试中断言特定值是非常困难的。'
- en: We'll use Mockito to mock the external dependencies and execute the test in
    isolation. So, the test will no longer be dependent on real external service,
    and therefore it will be executed quickly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Mockito 模拟外部依赖并独立执行测试。因此，测试将不再依赖于真实的外部服务，因此它将快速执行。
- en: Mocking objects
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟对象
- en: 'A mock can be created with the help of a static `mock()` method as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用静态 `mock()` 方法创建模拟，如下所示：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Otherwise, you can use Java''s static import feature and static import the
    `mock` method of the `org.mockito.Mockito` class as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以使用 Java 的静态导入功能，并如下静态导入 `org.mockito.Mockito` 类的 `mock` 方法：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s another alternative; you can use the `@Mock` annotation as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另外还有一个选择；你可以如下使用 `@Mock` 注解：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The test method name is `when_ten_percent_gain_then_the_stock_is_sold`; a test
    name should explain the intention of the test. We use underscores to make the
    test name readable. We will use the `when_<<`something happens`>>_then_<<`the
    action is taken`>>` convention for the tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法名为 `when_ten_percent_gain_then_the_stock_is_sold`；测试名称应该解释测试的意图。我们使用下划线使测试名称可读。我们将使用
    `when_<<`something happens`>>_then_<<`the action is taken`>>` 测试约定。
- en: In the preceding test example, the `getAvgPrice()` method of `portfolio` is
    stubbed to return $10.00, then the `getQuote` method is stubbed to return a hardcoded
    `stock` object with a current stock price of $11.20\. The `broker` logic should
    sell the stock as the stock price goes up by 12 percent.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试示例中，`portfolio` 的 `getAvgPrice()` 方法被模拟以返回 $10.00，然后 `getQuote()` 方法被模拟以返回一个硬编码的
    `stock` 对象，其当前股价为 $11.20。当股价上涨 12% 时，`broker` 逻辑应该卖出股票。
- en: The `portfolio` object is a mock object. So, unless we stub a method, by default,
    all the methods of portfolio are autostubbed to return a default value, and for
    the `void` methods, no action is performed. The `sell` method is a `void` method;
    so, instead of connecting to a database to update the stock count, the autostub
    will do nothing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`portfolio` 对象是一个模拟对象。因此，除非我们模拟一个方法，否则默认情况下，`portfolio` 的所有方法都会自动模拟以返回默认值，对于
    `void` 方法，则不执行任何操作。`sell` 方法是一个 `void` 方法；因此，而不是连接到数据库以更新股票数量，自动模拟将不执行任何操作。'
- en: However, how will we test whether the `sell` method was invoked? We use `Mockito.verify`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何测试 `sell` 方法是否被调用呢？我们使用 `Mockito.verify`。
- en: The `verify()` method is a static method, which is used to verify the method
    invocation. If the method is not invoked, or the argument doesn't match, then
    the verify method will raise an error to indicate that the code logic has issues.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`verify()`方法是一个静态方法，用于验证方法调用。如果方法没有被调用，或者参数不匹配，则verify方法将引发错误，以指示代码逻辑存在问题。'
- en: Verifying the method invocation
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证方法调用
- en: To verify a redundant method invocation, or to verify whether a stubbed method
    was not called but was important from the test perspective, we should manually
    verify the invocation; for this, we need to use the static `verify` method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证冗余方法调用，或者验证被模拟的方法没有被调用但根据测试角度来说很重要，我们应该手动验证调用；为此，我们需要使用静态的`verify`方法。
- en: Why do we use verify?
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么我们使用verify？
- en: Mock objects are used to stub external dependencies. We set an expectation,
    and a mock object returns an expected value. In some conditions, a behavior or
    method of a mock object should not be invoked, or sometimes, we may need to call
    the method N (a number) times. The `verify` method verifies the invocation of
    mock objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象用于模拟外部依赖。我们设置一个期望值，模拟对象返回一个预期值。在某些条件下，模拟对象的行为或方法不应该被调用，或者有时我们可能需要调用方法N（一个数字）次。`verify`方法用于验证模拟对象的调用。
- en: Mockito does not automatically verify all stubbed calls.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito不会自动验证所有模拟调用。
- en: If a stubbed behavior should not be called but the method is called due to a
    bug in the code, `verify` flags the error though we have to verify that manually.
    The `void` methods don't return values, so you cannot assert the returned values.
    Hence, `verify` is very handy to test the `void` methods.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个被模拟的行为不应该被调用，但由于代码中的错误该方法被调用，`verify`会标记错误，尽管我们不得不手动验证。`void`方法不返回值，因此你不能断言返回值。因此，`verify`对于测试`void`方法非常有用。
- en: Verifying in depth
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 深入验证
- en: The `verify()` method has an overloaded version that takes `Times` as an argument.
    `Times` is a Mockito framework class of the `org.mockito.internal.verification`
    package, and it takes `wantedNumberOfInvocations` as an integer argument.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`verify()`方法有一个重载版本，它接受`Times`作为参数。`Times`是`org.mockito.internal.verification`包中的Mockito框架类，它接受`wantedNumberOfInvocations`作为整数参数。'
- en: If `0` is passed to `Times`, it infers that the method will not be invoked in
    the testing path. We can pass `0` to `Times(0)` to make sure that the `sell` or
    `buy` methods are not invoked. If a negative number is passed to the `Times` constructor,
    Mockito throws `MockitoException - org.mockito.exceptions.base.MockitoException`,
    and this shows the **Negative value is not allowed here** error.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`0`传递给`Times`，它意味着在测试路径中方法不会被调用。我们可以将`0`传递给`Times(0)`以确保`sell`或`buy`方法不会被调用。如果将负数传递给`Times`构造函数，Mockito将抛出`MockitoException
    - org.mockito.exceptions.base.MockitoException`，这表明**不允许负值**错误。
- en: 'The following methods are used in conjunction with `verify`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法与`verify`一起使用：
- en: '`times(int wantedNumberOfInvocations)`: This method is invoked exactly *n*
    times; if the method is not invoked `wantedNumberOfInvocations` times, then the
    test fails.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`times(int wantedNumberOfInvocations)`: 这个方法恰好被调用*n*次；如果方法没有被调用`wantedNumberOfInvocations`次，则测试失败。'
- en: '`never()`: This method signifies that the stubbed method is never called or
    you can use `times(0)` to represent the same scenario. If the stubbed method is
    invoked at least once, then the test fails.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`never()`: 这个方法表示被模拟的方法从未被调用，或者你可以使用`times(0)`来表示相同的情况。如果被模拟的方法至少被调用一次，那么测试将失败。'
- en: '`atLeastOnce()`: This method is invoked at least once, and it works fine if
    it is invoked multiple times. However, the operation fails if the method is not
    invoked.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atLeastOnce()`: 这个方法至少被调用一次，如果多次调用则操作正常。然而，如果没有被调用，则操作失败。'
- en: '`atLeast(int minNumberOfInvocations)`: This method is called at least *n* times,
    and it works fine if the method is invoked more than the `minNumberOfInvocations`
    times. However, the operation fails if the method is not called `minNumberOfInvocations`
    times.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atLeast(int minNumberOfInvocations)`: 这个方法至少被调用*n*次，如果方法被调用次数超过`minNumberOfInvocations`，则操作正常。然而，如果方法没有被调用`minNumberOfInvocations`次，则操作失败。'
- en: '`atMost(int maxNumberOfInvocations)`: This method is called at the most `n`
    times. However, the operation fails if the method is called more than `minNumberOfInvocations`
    times.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atMost(int maxNumberOfInvocations)`: 这个方法最多被调用*n*次。然而，如果方法被调用次数超过`minNumberOfInvocations`次，则操作失败。'
- en: '`only()`: The `only` method called on a mock fails if any other method is called
    on the mock object. In our example, if we use `verify(portfolio, only()).sell(aCorp,10);`,
    the test will fail with the following output:![Verifying in depth](img/00052.jpeg)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`only()`: 在模拟对象上调用 `only` 方法时，如果模拟对象上还调用了其他方法，则测试失败。在我们的例子中，如果我们使用 `verify(portfolio,
    only()).sell(aCorp,10);`，测试将失败，输出如下：![深入验证](img/00052.jpeg)'
- en: The test fails in line 15 as `portfolio.getAvgPrice(stock)` is called.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第 15 行测试失败，因为调用了 `portfolio.getAvgPrice(stock)`。
- en: '`timeout(int millis)`: This method is interacted in a specified time range.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout(int millis)`: 此方法在指定的时间范围内进行交互。'
- en: Verifying zero and no more interactions
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证零和更多交互
- en: The `verifyZeroInteractions(Object... mocks)` method verifies whether no interactions
    happened on the given mocks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyZeroInteractions(Object... mocks)` 方法验证给定的模拟对象上是否没有发生任何交互。'
- en: 'The following test code directly calls `verifyZeroInteractions` and passes
    the two mock objects. Since no methods are invoked on the mock objects, the test
    passes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试代码直接调用 `verifyZeroInteractions` 并传递两个模拟对象。由于没有在模拟对象上调用任何方法，测试通过：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `verifyNoMoreInteractions(Object... mocks)` method checks whether any of
    the given mocks has any unverified interaction. We can use this method after verifying
    a mock method to make sure that nothing else was invoked on the mock.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyNoMoreInteractions(Object... mocks)` 方法检查给定的模拟对象中是否有任何未验证的交互。我们可以在验证模拟方法之后使用此方法，以确保没有在模拟对象上调用其他方法。'
- en: 'The following test code demonstrates `verifyNoMoreInteractions`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试代码演示了 `verifyNoMoreInteractions`：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the JUnit output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 JUnit 输出：
- en: '![Verifying zero and no more interactions](img/00053.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![验证零和更多交互](img/00053.jpeg)'
- en: The following are the rationales and examples of argument matchers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对参数匹配器的理由和示例。
- en: Using argument matcher
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用参数匹配器
- en: '`ArgumentMatcher` is a Hamcrest matcher with a predefined `describeTo()` method.
    `ArgumentMatcher` extends the `org.hamcrest.BaseMatcher` package. It verifies
    the indirect inputs into a mocked dependency.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArgumentMatcher` 是一个具有预定义的 `describeTo()` 方法的 Hamcrest 匹配器。`ArgumentMatcher`
    扩展了 `org.hamcrest.BaseMatcher` 包。它验证对模拟依赖项的间接输入。'
- en: The `Matchers.argThat(Matcher)` method is used in conjunction with the `verify`
    method to verify whether a method is invoked with a specific argument value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matchers.argThat(Matcher)` 方法与 `verify` 方法一起使用，以验证方法是否以特定的参数值被调用。'
- en: '`ArgumentMatcher` plays a key role in mocking. The following section describes
    the context of `ArgumentMatcher`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArgumentMatcher` 在模拟中扮演着关键角色。以下部分描述了 `ArgumentMatcher` 的上下文。'
- en: Mock objects return expected values, but when they need to return different
    values for different arguments, argument matcher comes into play. Suppose we have
    a method that takes a player name as input and returns the total number of runs
    (a run is a point scored in a cricket match) scored as output. We want to stub
    it and return `100` for `Sachin` and `10` for `xyz`. We have to use argument matcher
    to stub this.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象返回预期值，但当它们需要为不同的参数返回不同的值时，参数匹配器就派上用场。假设我们有一个方法，它接受一个玩家名称作为输入，并返回作为输出的总得分（得分是板球比赛中得分的点数）。我们想要模拟它，并为
    `Sachin` 返回 `100`，为 `xyz` 返回 `10`。我们必须使用参数匹配器来模拟这个。
- en: 'Mockito returns expected values when a method is stubbed. If the method takes
    arguments, the argument must match during the execution; for example, the `getValue(int
    someValue)` method is stubbed in the following way:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 在方法被模拟时返回预期值。如果方法接受参数，则参数必须在执行期间匹配；例如，以下方式模拟了 `getValue(int someValue)`
    方法：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the `getValue` method is called with `mockObject.getValue(100)`. Then,
    the parameter doesn't match (it is expected that the method will be called with
    1, but at runtime, it encounters 100), so the mock object fails to return the
    expected value. It will return the default value of the return type—if the return
    type is Boolean, it'll return false; if the return type is object, then null,
    and so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`getValue` 方法被调用为 `mockObject.getValue(100)`。然后，参数不匹配（预期该方法将以 1 被调用，但在运行时遇到
    100），因此模拟对象未能返回预期值。它将返回返回类型的默认值——如果返回类型是布尔型，则返回 false；如果返回类型是对象，则返回 null，依此类推。
- en: Mockito verifies argument values in natural Java style by using an `equals()`
    method. Sometimes, we use argument matchers when extra flexibility is required.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 通过使用 `equals()` 方法以自然 Java 风格验证参数值。有时，当需要额外灵活性时，我们会使用参数匹配器。
- en: Mockito provides built-in matchers such as `anyInt()`, `anyDouble()`, `anyString()`,
    `anyList()`, and `anyCollection()`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 提供了内置匹配器，如 `anyInt()`、`anyDouble()`、`anyString()`、`anyList()` 和 `anyCollection()`。
- en: 'More built-in matchers and examples of custom argument matchers or Hamcrest
    matchers can be found at the following link:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 更多内置匹配器和自定义参数匹配器或Hamcrest匹配器的示例可以在以下链接找到：
- en: '[http://docs.mockito.googlecode.com/hg/latest/org/mockito/Matchers.html](http://docs.mockito.googlecode.com/hg/latest/org/mockito/Matchers.html)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.mockito.googlecode.com/hg/latest/org/mockito/Matchers.html](http://docs.mockito.googlecode.com/hg/latest/org/mockito/Matchers.html)'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we are using argument matchers, all arguments have to be provided by matchers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用参数匹配器，所有参数都必须由匹配器提供。
- en: 'We''re passing three arguments and all of them are passed using matchers:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了三个参数，并且所有参数都是通过匹配器传递的：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following example will fail because the first and the third arguments are
    not passed using matcher:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将失败，因为第一个和第三个参数没有使用匹配器传递：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The ArgumentMatcher class
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`ArgumentMatcher`类'
- en: The `ArgumentMatcher` class allows the creation of customized argument matchers.
    `ArgumentMatcher` is a Hamcrest matcher with the predefined `describeTo()` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArgumentMatcher`类允许创建自定义参数匹配器。`ArgumentMatcher`是一个具有预定义的`describeTo()`方法的Hamcrest匹配器。'
- en: Use the `Matchers.argThat(org.hamcrest.Matcher)` method and pass an instance
    of the Hamcrest matcher.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Matchers.argThat(org.hamcrest.Matcher)`方法并传递Hamcrest匹配器的实例。
- en: Consider the `MarketWatcher` class; it takes a stock symbol and then gets the
    quote from the market.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`MarketWatcher`类；它接受一个股票代码，然后从市场获取报价。
- en: We will create a mock for the `MarketWatcher.getQuote` method that takes a `String`
    object. We wish to make this method conditional. If a blue chip stock symbol is
    passed to the method, then the method will return $1000.00; otherwise, it will
    return $5.00.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`MarketWatcher.getQuote`方法创建一个模拟，该方法接受一个`String`对象。我们希望使此方法具有条件性。如果传递给方法的股票代码是蓝筹股，则该方法将返回$1000.00；否则，它将返回$5.00。
- en: How will we identify a blue chip share? A blue chip share is a common stock
    of a well-known company whose value and dividends are reliable and usually safe
    for investment. For example, if the stock symbol is FB or AAPL, we will consider
    the stock as a blue chip stock.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何识别蓝筹股？蓝筹股是知名公司的普通股票，其价值和股息可靠且通常对投资安全。例如，如果股票代码是FB或AAPL，我们将该股票视为蓝筹股。
- en: 'Let us create a custom matcher to identify blue chip stocks. The following
    code shows a custom argument matcher:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个自定义匹配器来识别蓝筹股。以下代码展示了自定义参数匹配器：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following class extends `BlueChipStockMatcher` and then negates the result
    to indicate that the stock is not a blue chip stock:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类扩展了`BlueChipStockMatcher`，然后否定结果以指示该股票不是蓝筹股：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following test uses the custom matchers to sell the shares:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试使用自定义匹配器来卖出股票：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, `marketWatcher` is stubbed to return a blue chip share
    when the stock symbol is `FB` or `AAPL`; otherwise, it returns a normal stock.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`marketWatcher`被模拟，当股票代码是`FB`或`AAPL`时返回蓝筹股；否则，它返回普通股票。
- en: Throwing exceptions
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出异常
- en: Unit tests are not meant for only happy path testing. We should test our code
    for the failure conditions too. Mockito provides an API to raise an error during
    testing. Suppose we are testing a flow where we compute a value and then print
    it to a printer. If the printer is not configured, or a network error happens,
    or a page is not loaded, the system throws an exception. We can test this using
    Mockito's exception APIs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不仅仅是为了测试成功的路径。我们还应该测试我们的代码的失败条件。Mockito提供了一个在测试期间引发错误的API。假设我们正在测试一个流程，其中我们计算一个值然后打印到打印机。如果打印机未配置，或发生网络错误，或页面未加载，系统将抛出异常。我们可以使用Mockito的异常API来测试这种情况。
- en: How do we test exceptional conditions such as database access failure?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何测试异常条件，例如数据库访问失败？
- en: Mockito provides a method called `thenThrow(Throwable)`; this method throws
    an exception when the stubbed method is invoked.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito提供了一个名为`thenThrow(Throwable)`的方法；当模拟的方法被调用时，此方法将抛出异常。
- en: 'We will stub the `getAvgPrice` method to throw an exception when the method
    is called, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟`getAvgPrice`方法，在调用该方法时抛出异常，如下所示：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We are stubbing `portfolio` to throw an exception when `getAvgPrice()` is invoked.
    The following is the syntax to throw an exception from a method that returns `void`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在模拟`portfolio`，在调用`getAvgPrice()`时抛出异常。以下是从返回`void`的方法中抛出异常的语法：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `buy` method in `Portfolio` is a `void` method; we will stub the `buy`
    method to throw an exception. The following test code throws `IllegalStateException`
    when the `buy` method is invoked on the `portfolio` object. Note that `doThrow().when()`
    will be used to raise the error from the `buy` method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Portfolio` 中的 `buy` 方法是一个 `void` 方法；我们将模拟 `buy` 方法以抛出异常。以下测试代码在调用 `portfolio`
    对象上的 `buy` 方法时抛出 `IllegalStateException`。请注意，将使用 `doThrow().when()` 来从 `buy` 方法引发错误：'
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Stubbing consecutive calls
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟连续调用
- en: 'Stubbing a method for consecutive calls is required in the following situations:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下需要为连续调用模拟方法：
- en: Calling a stubbed method in a loop when you need different results for different
    calls
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在循环中调用模拟方法，需要不同调用返回不同结果时
- en: When you need one invocation to throw an exception and other invocations to
    return a value
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要一次调用抛出异常，而其他调用返回值时
- en: We need to test a condition where the first call will return a value, the next
    call should not find any value, and then again it should return a value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要测试一个条件，即第一次调用将返回一个值，下一次调用不应找到任何值，然后再次返回一个值。
- en: 'The varargs version of `thenReturn(objects...)` takes comma-separated return
    values and returns the arguments in order such that if we pass two arguments to
    the `thenReturn` method, then the first call to the stubbed method will return
    the first argument. Thereafter, all other calls will return the second argument,
    as shown in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`thenReturn(objects...)` 的可变参数版本接受逗号分隔的返回值，并按顺序返回参数，因此如果我们向 `thenReturn` 方法传递两个参数，则模拟方法的第一次调用将返回第一个参数。之后，所有其他调用将返回第二个参数，如下面的代码所示：'
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that `thenReturn` takes two values: `BigDecimal.TEN` and `BigDecimal.ZERO`.
    The first call to `getAvgPrice` will return `BigDecimal.TEN`, and then each call
    will return `BigDecimal.ZERO`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`thenReturn` 接受两个值：`BigDecimal.TEN` 和 `BigDecimal.ZERO`。`getAvgPrice` 的第一次调用将返回
    `BigDecimal.TEN`，然后每次调用将返回 `BigDecimal.ZERO`。
- en: This can be done in another way—Mockito methods return stub objects and follow
    a builder pattern to allow a chain of calls.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以用另一种方式完成——Mockito 方法返回模拟对象，并遵循构建器模式以允许一系列调用。
- en: 'In the following example, `thenReturn` and `thenThrow` are combined to build
    a chain of response. After the second call, each `getAvgPrice` invocation will
    throw an exception:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`thenReturn` 和 `thenThrow` 被组合起来构建响应链。在第二次调用之后，每次 `getAvgPrice` 调用都将抛出异常：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Stubbing with an Answer
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `Answer` 进行模拟
- en: Stubbed methods return a hardcoded value but cannot return an on the fly result.
    The Mockito framework provides the callbacks to compute the on the fly results.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的方法返回硬编码的值，但不能返回即时结果。Mockito 框架提供了回调来计算即时结果。
- en: Mockito allows stubbing with the generic `Answer` interface. This is a callback;
    when a stubbed method on a mock object is invoked, the `answer(InvocationOnMock
    invocation)` method of the `Answer` object is called. This `Answer` object's `answer()`
    method returns the actual object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 允许使用泛型 `Answer` 接口进行模拟。这是一个回调；当在模拟对象上调用模拟的方法时，将调用 `Answer` 对象的 `answer(InvocationOnMock
    invocation)` 方法。此 `Answer` 对象的 `answer()` 方法返回实际对象。
- en: The syntax of `Answer` is `when(mock.someMethod()).thenAnswer(new Answer() {…});`
    or `when(mock.someMethod()).then(answer);`, which is similar to `thenReturn()`
    and `thenThrow()`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Answer` 的语法是 `when(mock.someMethod()).thenAnswer(new Answer() {…});` 或 `when(mock.someMethod()).then(answer);`，这与
    `thenReturn()` 和 `thenThrow()` 类似。'
- en: 'The `Answer` interface is defined as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Answer` 接口定义如下：'
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `InvocationOnMock` argument is an important part of callback. It can return
    the arguments passed to the method and also return the mock object as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvocationOnMock` 参数是回调的一个重要部分。它可以返回传递给方法的参数，也可以返回模拟对象，如下所示：'
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: One can buy 10 stocks of Facebook or 10 different stocks. The `stockMap` object
    stores a key-value pair. The key is the `Stock` symbol and the value is a list
    of stocks. 10 Facebook stocks will add a single key, `FB,` and a list of 10 Facebook
    stocks. An Apple stock will add another entry to the map with an `AAPL` key and
    value and a list with a single Apple stock.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以购买 10 股 Facebook 或 10 种不同的股票。`stockMap` 对象存储键值对。键是 `Stock` 符号，值是股票列表。10 股
    Facebook 股票将添加一个单独的键 `FB` 和一个包含 10 股 Facebook 股票的列表。一股苹果股票将添加另一个条目到映射中，具有 `AAPL`
    键和值以及一个包含单一苹果股票的列表。
- en: 'The following `Answer` implementation is called when the `buy` method is invoked.
    The `invocationOnMock` object returns the arguments, and the `buy` method accepts
    only one argument, that is, a `Stock` object. So, type casted the 0^(th) argument
    to `Stock`. Then, insert `Stock` to the `stockMap` object:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`buy`方法时，以下`Answer`实现被调用。`invocationOnMock`对象返回参数，而`buy`方法只接受一个参数，即一个`Stock`对象。因此，将0^(th)参数转换为`Stock`类型。然后，将`Stock`插入到`stockMap`对象中：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following `answer` object implements the total price computation logic:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`answer`对象实现了总价计算逻辑：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `getCurrentValue()` method will be stubbed to return the preceding answer
    implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCurrentValue()`方法将被模拟以返回前面的答案实现。'
- en: 'The following JUnit test code uses the `TotalPriceAnswer` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下JUnit测试代码使用了`TotalPriceAnswer`方法：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Check that the `stockMap` object is cleared to remove existing data. Then, the
    `void` `buy` method is stubbed to add stocks to `stockMap` using the `doAnswer`
    method, and then the `getCurrentValue` method is stubbed to the `TotalPriceAnswer`
    answer.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`stockMap`对象是否已清除以删除现有数据。然后，使用`doAnswer`方法模拟`void` `buy`方法以向`stockMap`添加股票，然后模拟`getCurrentValue`方法为`TotalPriceAnswer`答案。
- en: Spying objects
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 间谍对象
- en: A Mockito `spy` object allows us to use real objects instead of mocks by replacing
    some of the methods with the stubbed ones. This behavior allows us to test the
    legacy code; one cannot mock a class that needs to be tested. Legacy code comes
    with methods that cannot be tested, but other methods use them; so, these methods
    need to be stubbed to work with the other methods. A `spy` object can stub the
    nontestable methods so that other methods can be tested easily.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito的`spy`对象允许我们通过用模拟的方法替换一些方法来使用真实对象，而不是使用模拟对象。这种行为允许我们测试遗留代码；不能模拟需要被测试的类。遗留代码带有无法测试的方法，但其他方法使用它们；因此，这些方法需要被模拟以与其他方法一起工作。`spy`对象可以模拟不可测试的方法，以便其他方法可以轻松地进行测试。
- en: Once an expectation is set for a method on a `spy` object, then `spy` no longer
    returns the original value. It starts returning the stubbed value, but still it
    exhibits the original behavior for the other methods that are not stubbed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为`spy`对象上的方法设置了一个期望值，那么`spy`就不再返回原始值。它开始返回模拟值，但仍然表现出未模拟的其他方法的原始行为。
- en: Mockito can create a `spy` of a real object. Unlike stubbing, when we use `spy`,
    the real methods are called (unless a method was stubbed).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito可以创建一个真实对象的`spy`。与模拟不同，当我们使用`spy`时，会调用真实方法（除非方法已被模拟）。
- en: '`Spy` is also known as partial mock; one example of the use of `spy` in the
    real world is dealing with legacy code.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spy`也被称为部分模拟；`spy`在现实世界中的一个例子是处理遗留代码。'
- en: 'Declaration of `spy` is done using the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码声明`spy`：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is a self-explanatory example of `spy`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个自解释的`spy`示例：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Stubbing void methods
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟void方法
- en: In the *Throwing exceptions* section of this chapter, we learned that `doThrow`
    is used for throwing exceptions for the `void` methods. The *Stubbing with an
    Answer* section of this chapter showed you how to use `doAnswer` for the void
    methods.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的*抛出异常*部分，我们了解到`doThrow`用于为`void`方法抛出异常。本章的*使用Answer进行模拟*部分展示了如何使用`doAnswer`对`void`方法进行模拟。
- en: 'In this section, we will explore the other `void` methods: `doNothing`, `doReturn`,
    `doThrow`, and `doCallRealMethod`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨其他`void`方法：`doNothing`、`doReturn`、`doThrow`和`doCallRealMethod`。
- en: 'The `doNothing()` API does nothing. By default, all the `void` methods do nothing.
    However, if you need consecutive calls on a `void` method, the first call is to
    throw an error, the next call is to do nothing, and then the next call to perform
    some logic using `doAnswer()` and then follow this syntax:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`doNothing()` API什么都不做。默认情况下，所有`void`方法都不做任何事情。但是，如果你需要在`void`方法上连续调用，第一次调用是抛出错误，下一次调用是不做任何事情，然后下一次调用使用`doAnswer()`执行一些逻辑，然后遵循以下语法：'
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `doCallRealMethod()` API is used when you want to call the real implementation
    of a method on a mock or a `spy` object as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在模拟或`spy`对象上调用方法的实际实现时，使用`doCallRealMethod()` API，如下所示：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `doReturn()` method is similar to stubbing a method and returning an expected
    value. However, this is used only when `when(mock).thenReturn(return)` cannot
    be used.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`doReturn()`方法与模拟方法并返回预期值类似。然而，这仅在`when(mock).thenReturn(return)`无法使用时使用。'
- en: The `when-thenReturn` method is more readable than `doReturn()`; also, `doReturn()`
    is not a safe type. The `thenReturn` method checks the method return types and
    raises a compilation error if an unsafe type is passed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`when-thenReturn` 方法比 `doReturn()` 更易读；此外，`doReturn()` 不是一个安全类型。`thenReturn`
    方法检查方法返回类型，如果传递了不安全的类型，则会引发编译错误。'
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following screenshot shows how the test fails:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了测试失败的情况：
- en: '![Stubbing void methods](img/00054.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![模拟空方法](img/00054.jpeg)'
- en: Spying real objects and calling real methods on a spy has side effects; to counter
    this side effect, use `doReturn()` instead of `thenReturn()`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在间谍对象上调用真实方法会产生副作用；为了抵消这种副作用，请使用 `doReturn()` 而不是 `thenReturn()`。
- en: 'The following code describes the side effect of spying and calling `thenReturn()`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码描述了间谍和调用 `thenReturn()` 的副作用：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, the spy object calls a real method while trying to stub
    `get(index)`, and unlike the mock objects, the real method was called and it failed
    with an `ArrayIndexOutOfBounds` error.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，间谍对象在尝试模拟 `get(index)` 时调用了一个真实方法，并且与模拟对象不同，真实方法被调用并因 `ArrayIndexOutOfBounds`
    错误而失败。
- en: 'The following screenshot displays the failure message:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了失败信息：
- en: '![Stubbing void methods](img/00055.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![模拟空方法](img/00055.jpeg)'
- en: 'This can be protected using `doReturn()` as shown in the following code, but
    note that typically we don''t mock lists or domain objects; this is just an example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下代码中的 `doReturn()` 进行保护，但请注意，我们通常不会模拟列表或域对象；这只是一个例子：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Capturing arguments with ArgumentCaptor
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ArgumentCaptor 捕获参数
- en: '`ArgumentCaptor` is used to verify the arguments passed to a stubbed method.
    Sometimes, we compute a value, then create another object using the computed value,
    and then call a mock object using that new object. This computed value is not
    returned from the original method, but it is used for some other computation.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArgumentCaptor` 用于验证传递给模拟方法的参数。有时，我们计算一个值，然后使用这个计算值创建另一个对象，接着使用这个新对象调用一个模拟对象。这个计算值不会从原始方法返回，但它被用于其他一些计算。'
- en: '`ArgumentCaptor` provides an API to access objects that are instantiated within
    the method under the test.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArgumentCaptor` 提供了一个 API，用于访问在测试方法中实例化的对象。'
- en: 'The following code snippet explains the problem behind the inaccessibility
    of the method arguments:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段解释了方法参数不可访问的问题：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We are passing a first name, middle name, last name, and an age to the `buildPerson`
    method. This method creates a `Person` object and sets the name and age to it.
    Finally, it invokes the `personService` class and saves the `person` object to
    a database.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `buildPerson` 方法传递了名字、中间名、姓氏和年龄。此方法创建一个 `Person` 对象，并将名称和年龄设置到其中。最后，它调用
    `personService` 类并将 `person` 对象保存到数据库中。
- en: Here, we cannot stub the `save` behavior of `personService` from a JUnit test
    with a specific value since the `Person` object is created inside the method.
    We can mock `save` using a generic matcher object such as `isA(Person.class)`
    and then verify whether the `Person` object contains the correct name and age
    using the argument captor.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于 `Person` 对象是在方法内部创建的，我们无法从 JUnit 测试中用特定值模拟 `personService` 的 `save` 行为。我们可以使用一个通用匹配器对象，如
    `isA(Person.class)` 来模拟 `save`，然后使用参数捕获器验证 `Person` 对象是否包含正确的姓名和年龄。
- en: Mockito verifies argument values in natural Java style by using an `equals()`
    method. This is also the recommended way of matching arguments because it makes
    tests clean and simple. In some situations though, it is necessary to assert on
    certain arguments after the actual verification.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 通过使用 `equals()` 方法以自然 Java 风格验证参数值。这也是推荐匹配参数的方式，因为它使测试变得简洁简单。然而，在某些情况下，在验证之后对某些参数进行断言是必要的。
- en: 'The following code uses two `ArgumentCaptors` and verifies whether it uses
    a specific stock symbol, `A,` and not any other value while calling the method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用两个 `ArgumentCaptors` 并验证在调用方法时是否使用了特定的股票符号 `A`，而不是任何其他值：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Check that `ArgumentCaptor` takes a `Class` type in the `forClass` method and
    then the captor is passed to the `verify` method to collect the argument details.
    The `sell` method takes two arguments, `Stock` and `Integer`. So, two `ArgumentCaptors`
    are created. The `stockCaptor` object captures the `Stock` argument and `stockSellCountCaptor`
    captures the stock quantity. Finally, the values are compared to verify whether
    the correct values were passed to the `sell` method.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`ArgumentCaptor`在`forClass`方法中接受一个`Class`类型，然后捕获器被传递给`verify`方法以收集参数细节。`sell`方法接受两个参数，`Stock`和`Integer`。因此，创建了两个`ArgumentCaptors`。`stockCaptor`对象捕获`Stock`参数，而`stockSellCountCaptor`捕获股票数量。最后，比较这些值以验证是否将正确的值传递给了`sell`方法。
- en: Verifying the invocation order
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证调用顺序
- en: Mockito facilitates verifying if interactions with a mock were performed in
    a given order using the `InOrder` API. It allows us to create `InOrder` of mocks
    and verify the call order of all calls of all mocks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito通过使用`InOrder` API简化了验证模拟交互是否按给定顺序执行。它允许我们创建模拟的`InOrder`并验证所有模拟的所有调用顺序。
- en: 'The following test sequentially invokes the `getAvgPrice`, `getCurrentValue`,
    `getQuote`, and `buy` methods, but verifies whether the `buy()` method is invoked
    before the `getAvgPrice()` method. So, the verification order is wrong and hence
    the test fails:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试按顺序调用了`getAvgPrice`、`getCurrentValue`、`getQuote`和`buy`方法，但验证了`buy()`方法是否在`getAvgPrice()`方法之前被调用。因此，验证顺序是错误的，所以测试失败了：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following screenshot shows the error message output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了错误信息输出：
- en: '![Verifying the invocation order](img/00056.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![验证调用顺序](img/00056.jpeg)'
- en: 'Reordering the verification sequence, we fixed the test as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 重新排序验证顺序，我们按以下方式修复了测试：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Changing the default settings
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改默认设置
- en: We learned that nonstubbed methods of a mock object return default values such
    as null for an object and false for a Boolean. However, Mockito allows us to change
    the default settings.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到模拟对象的非存根方法返回默认值，例如对象为null，布尔值为false。然而，Mockito允许我们更改默认设置。
- en: 'The following are the allowed settings:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以设置的允许值：
- en: '**RETURNS_DEFAULTS**: This is the default setting. It returns null for object,
    false for Boolean, and so on.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RETURNS_DEFAULTS**: 这是默认设置。对于对象返回null，对于布尔值返回false，等等。'
- en: '**RETURNS_SMART_NULLS**: This returns `spy` of a given type.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RETURNS_SMART_NULLS**: 这返回给定类型的`spy`。'
- en: '**RETURNS_MOCKS**: This returns mocks for objects and the default value for
    primitives.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RETURNS_MOCKS**: 这返回对象模拟和原语类型的默认值。'
- en: '**RETURNS_DEEP_STUBS**: This returns a deep stub.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RETURNS_DEEP_STUBS**: 这返回一个深度存根。'
- en: '**CALLS_REAL_METHODS**: This calls a real method.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CALLS_REAL_METHODS**: 这将调用一个实际方法。'
- en: 'The following example overrides the default Mockito settings and uses different
    return types:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例覆盖了默认的Mockito设置并使用了不同的返回类型：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following screenshot shows the console output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了控制台输出：
- en: '![Changing the default settings](img/00057.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![更改默认设置](img/00057.jpeg)'
- en: Resetting mock objects
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置模拟对象
- en: A static method `reset(T…)` enables resetting mock objects. The `reset` method
    should be handled with special care; if you need to reset a mock, you will most
    likely need another test.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静态方法`reset(T…)`可以重置模拟对象。`reset`方法应该特别小心处理；如果你需要重置一个模拟，你很可能还需要另一个测试。
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Exploring Mockito annotations
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索Mockito注解
- en: 'We learned that Mockito supports the `@Mock` annotation for mocking. Just like
    `@Mock`, Mockito supports the following three useful annotations:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到Mockito支持`@Mock`注解进行模拟。就像`@Mock`一样，Mockito还支持以下三个有用的注解：
- en: '`@Captor`: This simplifies the creation of `ArgumentCaptor`, which is useful
    when the argument to capture is a super generic class, such as `List<Map<String,Set<String>>.`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Captor`: 这简化了`ArgumentCaptor`的创建，这在需要捕获的参数是一个超级通用类时很有用，例如`List<Map<String,Set<String>>>`。'
- en: '`@Spy`: This creates a `spy` of a given object. Use it instead of `spy (object)`.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Spy`: 这创建了一个给定对象的`spy`。用它代替`spy (object)`。'
- en: '`@InjectMocks`: This injects `mock` or `spy` fields into the tested object
    automatically using a constructor injection, setter injection, or field injection.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@InjectMocks`: 这自动使用构造函数注入、setter注入或字段注入将`mock`或`spy`字段注入到测试对象中。'
- en: Working with inline stubbing
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内联存根工作
- en: Mockito allows us to create mocks while stubbing it. Basically, it allows creating
    a stub in one line of code. This can be helpful to keep the test code clean.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito允许我们在存根的同时创建模拟。基本上，它允许在一行代码中创建存根。这有助于保持测试代码的整洁。
- en: 'For example, some stubs can be created and stubbed at field initialization
    in a test. We use the `Stock` objects in almost all tests. We can create a global
    mock `Stock` and stub it at definition, as shown in the following code snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以在测试中创建并初始化字段时模拟一些存根。我们在几乎所有的测试中都使用 `Stock` 对象。我们可以创建一个全局模拟 `Stock` 并在定义时对其进行存根，如下面的代码片段所示：
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Determining mocking details
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定模拟细节
- en: '`Mockito.mockingDetails` identifies whether a particular object is a mock or
    a spy, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mockito.mockingDetails` 识别特定对象是否是模拟或间谍，如下所示：'
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Behavior-driven development with Mockito
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Mockito 进行行为驱动开发
- en: BDD is a software engineering process based on TDD. BDD combines the best practices
    of TDD, **domain-driven** **development** (**DDD**), and **object-oriented programming**
    (**OOP**).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 是基于 TDD 的软件工程流程。BDD 结合了 TDD、**领域驱动开发**（**DDD**）和**面向对象编程**（**OOP**）的最佳实践。
- en: In an agile team, scoping a feature is a mammoth task. The business stakeholders
    talk about business interests, and the development team talks about technical
    challenges. BDD provides a universal language that allows useful communication
    and feedback between the stakeholders.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷团队中，确定功能范围是一项艰巨的任务。业务利益相关者讨论业务利益，而开发团队讨论技术挑战。BDD 提供了一种通用语言，允许利益相关者之间进行有用的沟通和反馈。
- en: 'Dan North developed BDD, created the **JBehave** framework for BDD, and proposed
    the following best practices:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Dan North 开发了 BDD，创建了 BDD 的 **JBehave** 框架，并提出了以下最佳实践：
- en: Unit test names should start with the word *should* and *should* be written
    in the order of the business value
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试名称应该以单词 *should* 开头，并且 *should* 按照业务价值的顺序编写
- en: '**Acceptance tests** (**AT**) should be written in a user story manner, such
    as "As a (role) I want (feature) so that (benefit)"'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**（**AT**）应该以用户故事的方式编写，例如“作为（角色）我想（功能）以便（好处）”'
- en: Acceptance criteria should be written in terms of scenarios and implemented
    as "Given (initial context), when (event occurs), then (ensure some outcomes)"
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收标准应该以场景的形式编写，并实现为“Given（初始上下文），when（事件发生），then（确保某些结果）”
- en: 'Let''s write a user story for our stock broker simulation:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的股票经纪人模拟编写一个用户故事：
- en: '**Story**: A stock is sold'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**故事**：股票被卖出'
- en: '**In order** to maximize profit'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为了** 最大化利润'
- en: '**As a** Stock broker'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为** 股票经纪人'
- en: '**I want** to sell a stock **when** the price goes up by 10 percent'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我想** 在价格上升 10% 时卖出股票'
- en: 'The following is a scenario example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个场景示例：
- en: '**Scenario**: 10 percent increase in stock price should sell the stock in the
    market'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**：股票价格上升 10% 应该在市场上卖出股票'
- en: '**Given** a customer previously bought FB stocks at $10.00 per share'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Given** 客户之前以每股 $10.00 的价格购买了 FB 股票'
- en: '**And** he currently has 10 shares left in his portfolio'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并且** 他目前在投资组合中还有 10 股剩余'
- en: '**When** the FB stock price becomes $11.00'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当** Facebook 股票价格变为 $11.00'
- en: '**Then** I should sell all the FB stocks and the portfolio should have zero
    FB stocks'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**那么** 我应该卖出所有的 Facebook 股票，并且投资组合应该没有 Facebook 股票'
- en: Mockito supports the BDD style of writing tests using the `given-when-then`
    syntax.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 支持使用 `given-when-then` 语法编写 BDD 风格的测试。
- en: Writing tests in BDD style
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以 BDD 风格编写测试
- en: In BDD, `given` represents the initial context and `when` represents the event
    or condition. However, Mockito already has a `when` style of (initial context
    definition) method stubbing; therefore, `when` doesn't go well with BDD. Thus,
    the `BDDMockito` class introduces an alias so that we can stub method calls with
    the `given(object)` method.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BDD 中，`given` 代表初始上下文，而 `when` 代表事件或条件。然而，Mockito 已经有一个（初始上下文定义）方法存根的 `when`
    风格；因此，`when` 与 BDD 不太搭配。因此，`BDDMockito` 类引入了一个别名，这样我们就可以使用 `given(object)` 方法存根方法调用。
- en: 'The following JUnit test is implemented in BDD style:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 JUnit 测试是以 BDD 风格实现的：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that the test name starts with a `should` statement. The `given` syntax
    of `Mockito` is used to set the initial context that the portfolio already has
    `FB` stocks bought at $10.00 per share and the current `FB` stock price is $11.00
    per share.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，测试名称以 `should` 语句开头。`Mockito` 的 `given` 语法用于设置初始上下文，即投资组合已经以每股 $10.00 的价格购买了
    `FB` 股票，并且当前的 `FB` 股票价格为每股 $11.00。
- en: 'The following screenshot shows the test execution output:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了测试执行输出：
- en: '![Writing tests in BDD style](img/00058.jpeg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![以 BDD 风格编写测试](img/00058.jpeg)'
- en: The BDD syntax
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BDD 语法
- en: 'The following methods are used in conjunction with `given`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法与 `given` 一起使用：
- en: '`willReturn`(a value to be returned): This returns a given value'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`willReturn`(要返回的值)：这返回一个给定的值'
- en: '`willThrow`(a throwable to be thrown): This throws a given exception'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`willThrow`(要抛出的异常): 这将抛出一个给定的异常'
- en: '`will`(`Answer` answer) and `willAnswer`(`Answer` answer): This is similar
    to `then`(answer) and `thenAnswer`(answer)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`will`(Answer answer) 和 `willAnswer`(Answer answer): 这与 `then`(answer) 和 `thenAnswer`(answer)
    类似'
- en: '`willCallRealMethod()`: This calls the real method on the mock object or spy'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`willCallRealMethod()`: 这将在模拟对象或间谍对象上调用实际方法'
- en: Note
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `jMock` and `EasyMock` frameworks are the other two Java-based unit testing
    frameworks that support mocking for automated unit tests.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`jMock` 和 `EasyMock` 框架是另外两个支持模拟自动化单元测试的基于 Java 的单元测试框架。'
- en: 'The `jMock` and `EasyMock` frameworks provide mocking capabilities, but the
    syntax is not as simple as Mockito. You can visit the following URLs to explore
    the frameworks:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`jMock` 和 `EasyMock` 框架提供了模拟功能，但其语法不如 Mockito 简单。您可以访问以下网址来探索这些框架：'
- en: '[http://jmock.org/](http://jmock.org/)'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://jmock.org/](http://jmock.org/)'
- en: '[http://easymock.org/](http://easymock.org/)'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://easymock.org/](http://easymock.org/)'
- en: To learn more about BDD and JBehave, visit [http://jbehave.org/](http://jbehave.org/).
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要了解更多关于 BDD 和 JBehave 的信息，请访问 [http://jbehave.org/](http://jbehave.org/).
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, Mockito is described in detail and technical examples are provided
    to demonstrate the capability of Mockito.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，Mockito 将被详细描述，并提供技术示例以展示 Mockito 的功能。
- en: By the end of this chapter, you will be able to use advanced features of the
    Mockito framework, and start BDD with Mockito.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用 Mockito 框架的高级功能，并开始使用 Mockito 进行行为驱动开发 (BDD)。
- en: The next chapter will explain the importance of code coverage, line and branch
    coverage, how to measure code coverage, Eclipse plugins, setting up Cobertura,
    and generating coverage report using Ant, Gradle, and Maven.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将解释代码覆盖率的重要性，包括行和分支覆盖率，如何衡量代码覆盖率，Eclipse 插件，设置 Cobertura，以及使用 Ant、Gradle
    和 Maven 生成覆盖率报告。
