- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Web Services with Jakarta XML Web Services
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jakarta XML Web Services 的 Web 服务
- en: '**Web services** are application programming interfaces that can be invoked
    remotely. Web services can be invoked from clients written in any language.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web 服务**是可以远程调用的应用程序编程接口。Web 服务可以从任何语言的客户端调用。'
- en: Jakarta EE includes the XML Web Services API as one of its technologies. We
    can use **XML Web Services** to develop **SOAP** (**Simple Object Access Protocol**)
    web services in the Java platform. Jakarta XML Web Services is a high-level API;
    invoking web services via Jakarta XML Web Services is done via remote procedure
    calls.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta EE 将 XML Web Services API 作为其技术之一。我们可以在 Java 平台上使用 **XML Web Services**
    来开发 **SOAP**（**简单对象访问协议**）Web 服务。Jakarta XML Web Services 是一个高级 API；通过 Jakarta
    XML Web Services 调用 Web 服务是通过远程过程调用完成的。
- en: SOAP-based web services are now a legacy technology. In most cases, RESTful
    web services are preferred to SOAP-based services for new development. Knowledge
    of SOAP-based web services is primarily useful for maintaining legacy applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 基于SOAP的Web服务现在是一种过时的技术。在大多数情况下，对于新开发，人们更倾向于使用 RESTful Web 服务而不是基于 SOAP 的服务。对基于
    SOAP 的 Web 服务的了解主要用于维护遗留应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Developing web services with Jakarta XML Web Services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jakarta XML Web Services 开发 Web 服务
- en: Exposing Enterprise Beans as web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将企业 Bean 公开为 Web 服务
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The example source code for this chapter can be found on GitHub at the following
    link: [https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch14_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch14_src).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可以在 GitHub 上找到，链接如下：[https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch14_src](https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch14_src)。
- en: Developing web services with Jakarta XML Web Services
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jakarta XML Web Services 开发 Web 服务
- en: 'Jakarta XML Web Services is a high-level API that simplifies the development
    of SOAP-based web services. Developing a web service with Jakarta XML Web Services
    consists of writing a class with public methods to be exposed as web services.
    The class needs to be annotated with `@WebService`. All public methods in the
    class are automatically exposed as web services; they can optionally be annotated
    with `@WebMethod`. The following example illustrates this process:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta XML Web Services 是一个高级 API，它简化了基于 SOAP 的 Web 服务的开发。使用 Jakarta XML Web
    Services 开发 Web 服务包括编写一个具有公开方法的类，这些方法将被公开为 Web 服务。该类需要使用 `@WebService` 注解。类中的所有公共方法都自动公开为
    Web 服务；它们可以选择性地使用 `@WebMethod` 注解。以下示例说明了这个过程：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding class exposes its two methods as web services. The `add()` method
    simply adds the two `int` primitives it receives as parameters and returns the
    result, and the `substract()` method subtracts its two parameters and returns
    the result.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类将其两个方法公开为 Web 服务。`add()` 方法简单地将它接收的两个 `int` 原始参数相加并返回结果，而 `substract()`
    方法从其两个参数中减去并返回结果。
- en: We indicate that the class implements a web service by decorating it with the
    `@WebService` annotation. Any methods that we would like to expose as web services
    can be decorated with the `@WebMethod` annotation, but this isn’t necessary. Since
    all public methods are automatically exposed as web services, we can still use
    the `@WebMethod` annotation for clarity, but it isn’t strictly necessary. To deploy
    our web service, we simply need to package it in a WAR file as usual.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `@WebService` 注解来装饰类，表明该类实现了 Web 服务。我们希望公开为 Web 服务的任何方法都可以用 `@WebMethod`
    注解来装饰，但这不是必需的。由于所有公共方法都自动公开为 Web 服务，我们仍然可以使用 `@WebMethod` 注解以提高清晰度，但这不是严格必要的。要部署我们的
    Web 服务，我们只需像往常一样将其打包到 WAR 文件中即可。
- en: Web service clients need a **WSDL** (**Web Services Definition Language**) file
    in order to generate executable code that they can use to invoke the web service.
    WSDL is an XML-based language that describes the functionality offered by a SOAP-based
    web service. WSDL files are typically placed in a web server and accessed by the
    client via its URL.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务客户端需要一个 **WSDL**（**Web 服务定义语言**）文件来生成可执行代码，以便它们可以用来调用 Web 服务。WSDL 是一种基于
    XML 的语言，用于描述基于 SOAP 的 Web 服务提供的功能。WSDL 文件通常放置在 Web 服务器上，并通过其 URL 被客户端访问。
- en: 'When deploying web services developed using Jakarta XML Web Services, a WSDL
    is automatically generated for us. The exact URL for the generated WSDL varies
    depending on the Jakarta EE runtime we are using. When using GlassFish, URLs for
    the generated WSDLs follow the following format:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署使用Jakarta XML Web Services开发的Web服务时，会自动为我们生成一个WSDL。生成的WSDL的确切URL取决于我们使用的Jakarta
    EE运行时。当使用GlassFish时，生成的WSDL的URL遵循以下格式：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In our example, the URL for our web service’s WSDL (when deployed to GlassFish)
    would be `http://localhost:8080/calculatorservice/CalculatorService?wsdl` (assuming
    GlassFish is running on our local workstation, and GlassFish is listening for
    HTTP connections in its default `8080` port).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们的Web服务的WSDL（当部署到GlassFish时）的URL将是`http://localhost:8080/calculatorservice/CalculatorService?wsdl`（假设GlassFish运行在我们的本地工作站上，并且GlassFish在其默认的`8080`端口上监听HTTP连接）。
- en: We can see the generated WSDL by pointing the browser to its URL, as illustrated
    in *Figure 14**.1.*
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将浏览器指向其URL来查看生成的WSDL，如图14.1所示。
- en: '![Figure 14.1 – Automatically generated WSDL](img/B21231_14_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 自动生成的WSDL](img/B21231_14_01.jpg)'
- en: Figure 14.1 – Automatically generated WSDL
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 自动生成的WSDL
- en: The specifics of the WSDL aren’t really relevant to the discussion. It can be
    considered as “behind-the-scenes plumbing,” which is necessary for SOAP-based
    web services to work correctly. The WSDL URL though, is needed when developing
    web service clients.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: WSDL的具体内容与讨论无关。它可以被认为是“幕后管道”，这对于基于SOAP的Web服务正确工作来说是必要的。不过，当开发Web服务客户端时，需要WSDL的URL。
- en: Developing a web service client
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发Web服务客户端
- en: As we mentioned earlier, web service clients need to generate executable code
    from a web service’s WSDL. A web service client will then invoke this executable
    code to access the web service.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Web服务客户端需要从Web服务的WSDL生成可执行代码。然后，Web服务客户端将调用此可执行代码来访问Web服务。
- en: In order to generate Java code from a WSDL, we need to use a tool called `wsimport`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从WSDL生成Java代码，我们需要使用一个名为`wsimport`的工具。
- en: The `wsimport` tool can be obtained by downloading Eclipse Metro, at [https://eclipse-ee4j.github.io/metro-wsit/](https://eclipse-ee4j.github.io/metro-wsit/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过下载Eclipse Metro来获取`wsimport`工具，网址为[https://eclipse-ee4j.github.io/metro-wsit/](https://eclipse-ee4j.github.io/metro-wsit/)。
- en: 'The only required argument for `wsimport` is the URL of the WSDL corresponding
    to the web service, which is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsimport`的唯一必需参数是与Web服务对应的WSDL的URL，如下所示：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command will generate a number of compiled Java classes that allow client
    applications to access our web service:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将生成多个编译后的Java类，允许客户端应用程序访问我们的Web服务：
- en: '`Add.class`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add.class`'
- en: '`AddResponse.class`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddResponse.class`'
- en: '`Calculator.class`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Calculator.class`'
- en: '`CalculatorService.class`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CalculatorService.class`'
- en: '`ObjectFactory.class`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObjectFactory.class`'
- en: '`package-info.class`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package-info.class`'
- en: '`Subtract.class`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subtract.class`'
- en: '`SubtractResponse.class`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubtractResponse.class`'
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the source code for the generated class files is automatically deleted.
    It can be kept by passing the `-keep` parameter to `wsimport`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生成的类文件的源代码会自动删除。可以通过传递`-keep`参数来保留它。
- en: These classes need to be added to the client’s `CLASSPATH` in order for them
    to be accessible to the client’s code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类需要添加到客户端的`CLASSPATH`中，以便它们可以被客户端代码访问。
- en: 'If we are using Apache Maven to build our code, we can take advantage of the
    JAX-WS Maven plugin to automatically invoke `wsimport` when building our client
    code. This approach is illustrated in the following `pom.xml` file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Apache Maven来构建我们的代码，我们可以利用JAX-WS Maven插件在构建客户端代码时自动调用`wsimport`。这种方法在下面的`pom.xml`文件中得到了说明：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding `pom.xml` Maven build file will automatically invoke the `wsimport`
    utility whenever we build our code via the `mvn package` or `mvn` `install` commands.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`pom.xml` Maven构建文件将在我们通过`mvn package`或`mvn install`命令构建代码时自动调用`wsimport`实用程序。
- en: 'At this point, we are ready to develop a simple client to access our web service.
    We will implement our client as a Jakarta Faces application; the most relevant
    parts of our client application source are shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好开发一个简单的客户端来访问我们的Web服务。我们将实现我们的客户端作为一个Jakarta Faces应用程序；客户端应用程序源代码中最相关的部分如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `@WebServiceRef` annotation injects an instance of the web service into
    our client application. Its `wsdlLocation` attribute contains the URL of the WSDL
    corresponding to the web service we are invoking.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebServiceRef`注解将Web服务的实例注入到我们的客户端应用程序中。它的`wsdlLocation`属性包含我们正在调用的Web服务对应的WSDL的URL。'
- en: Notice that the web service class is an instance of a class called `CalculatorService`.
    This class was created when we invoked the `wsimport` utility, as `wsimport` always
    generates a class whose name is the name of the class we implemented plus the
    “Service” suffix. We use this service class to obtain an instance of the web service
    class we developed. In our example, we do this by invoking the `getCalculatorPort()`
    method on the `CalculatorService` instance. In general, the method to invoke an
    instance of our web service class follows the pattern of `getNamePort()`, where
    `Name` is the name of the class we wrote to implement the web service. Once we
    get an instance of our web service class, we can simply invoke its methods like
    with any regular Java object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Web 服务类是名为 `CalculatorService` 的类的实例。当我们调用 `wsimport` 工具时创建了此类，因为 `wsimport`
    总是生成一个类，其名称是我们实现的类的名称加上“Service”后缀。我们使用这个服务类来获取我们开发的 Web 服务类的实例。在我们的例子中，我们通过在
    `CalculatorService` 实例上调用 `getCalculatorPort()` 方法来完成此操作。一般来说，调用我们 Web 服务类实例的方法遵循
    `getNamePort()` 模式，其中 `Name` 是我们编写的实现 Web 服务的类的名称。一旦我们获得了我们 Web 服务类的实例，我们就可以像调用任何常规
    Java 对象一样调用其方法。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Strictly speaking, the `getNamePort()` method of the service class returns an
    instance of a class implementing an interface generated by `wsimport`. This interface
    is given the name of our web service class and declares all of the methods we
    declared to be web services. For all practical purposes, the object returned is
    equivalent to our web service class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，服务类的 `getNamePort()` 方法返回一个实现由 `wsimport` 生成的接口的类的实例。这个接口被命名为我们的 Web 服务类，并声明了我们声明的所有作为
    Web 服务的函数。从所有实际目的来看，返回的对象等同于我们的 Web 服务类。
- en: 'The user interface for our simple client application is developed using Facelets,
    as customary when developing Jakarta Faces applications. The following code snippet
    shows the most relevant markup for our Jakarta Faces Facelets client:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单客户端应用程序的用户界面是使用 Facelets 开发的，这在开发 Jakarta Faces 应用程序时是惯例。以下代码片段显示了我们的 Jakarta
    Faces Facelets 客户端最相关的标记：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The user interface uses Ajax to invoke the relevant methods on the `CalculatorClientController`
    CDI named bean (refer to [*Chapter 6*](B21231_06.xhtml#_idTextAnchor073) for details).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面使用 Ajax 调用 `CalculatorClientController` CDI 命名豆（有关详细信息，请参阅[*第 6 章*](B21231_06.xhtml#_idTextAnchor073)）上的相关方法。
- en: After deploying our code, our browser should render our page as shown in *Figure
    14**.2* (this is shown after entering some data and clicking the corresponding
    buttons).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署我们的代码后，我们的浏览器应该将页面渲染成如图 *图 14**.2* 所示（这是在输入一些数据并点击相应按钮后显示的）。
- en: '![Figure 14.2 – XML Web Service Client in action](img/B21231_14_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – XML Web服务客户端运行时](img/B21231_14_02.jpg)'
- en: Figure 14.2 – XML Web Service Client in action
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – XML Web服务客户端运行时
- en: In this example, we passed the `Integer` objects as parameters and return values.
    Of course, it is also possible to pass primitive types both as parameters and
    as return values. Unfortunately, not all standard Java classes or primitive types
    can be used as method parameters or return values when invoking SOAP-based web
    services implemented with Jakarta XML Web Services. The reason for this is that
    behind the scenes, method parameters and return types get mapped to XML definitions,
    and not all types can be properly mapped.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们传递了 `Integer` 对象作为参数和返回值。当然，也可以将原始类型作为参数和返回值传递。不幸的是，当使用 Jakarta XML
    Web Services 实现基于 SOAP 的 Web 服务时，并非所有标准 Java 类或原始类型都可以用作方法参数或返回值。这是因为幕后，方法参数和返回类型被映射到
    XML 定义，并且并非所有类型都可以正确映射。
- en: 'Valid types that can be used in Jakarta XML Web Service calls are listed here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列出可用于 Jakarta XML Web 服务调用的有效类型：
- en: '`java.awt.Image`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.awt.Image`'
- en: '`java.lang.Object`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Object`'
- en: '`Java.lang.String`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Java.lang.String`'
- en: '`java.math.BigDecimal`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.math.BigDecimal`'
- en: '`java.math.BigInteger`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.math.BigInteger`'
- en: '`java.net.URI`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.net.URI`'
- en: '`java.util.Calendar`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Calendar`'
- en: '`java.util.Date`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Date`'
- en: '`java.util.UUID`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.UUID`'
- en: '`jakarta.activation.DataHandler`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jakarta.activation.DataHandler`'
- en: '`javax.xml.datatype.Duration`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.datatype.Duration`'
- en: '`javax.xml.datatype.XMLGregorianCalendar`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.datatype.XMLGregorianCalendar`'
- en: '`javax.xml.namespace.QName`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.namespace.QName`'
- en: '`javax.xml.transform.Source`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.xml.transform.Source`'
- en: 'Additionally, the following primitive types can be used:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下原始类型也可以使用：
- en: '`boolean`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`'
- en: '`byte`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`byte[]`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte[]`'
- en: '`double`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`float`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`int`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`long`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`short`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`'
- en: We can also use our own custom classes as method parameters and/or return values
    for web service methods, but member variables of our classes must be one of the
    listed types.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将我们自己的自定义类用作Web服务方法的参数和/或返回值，但我们的类的成员变量必须是列出的类型之一。
- en: Additionally, it is legal to use arrays both as method parameters or return
    values. However, when executing `wsimport`, these arrays get converted to Lists,
    generating a mismatch between the method signature in the web service and the
    method call invoked in the client. For this reason, it is preferred to use Lists
    as method parameters and/or return values, since this is also legal and does not
    create a mismatch between the client and the server.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用数组作为方法参数或返回值是合法的。然而，在执行`wsimport`时，这些数组会被转换为列表，导致Web服务中的方法签名与客户端调用的方法调用之间产生不匹配。因此，更倾向于使用列表作为方法参数和/或返回值，因为这也是合法的，并且不会在客户端和服务器之间产生不匹配。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Jakarta XML Web Services internally uses the **Jakarta XML Binding API** to
    create SOAP messages from method calls. The types we are allowed to use for method
    calls and return values are the ones that Jakarta XML Binding supports. For more
    information, see https://jakarta.ee/specifications/xml-binding/.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Jakarta XML Web Services内部使用**Jakarta XML Binding API**从方法调用创建SOAP消息。我们允许用于方法调用和返回值的类型是Jakarta
    XML Binding支持的类型。有关更多信息，请参阅https://jakarta.ee/specifications/xml-binding/。
- en: Sending attachments to web services
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Web服务发送附件
- en: 'In addition to sending and accepting the data types discussed in the previous
    sections, web service methods can send and accept file attachments. The following
    example illustrates how to do this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发送和接受上一节中讨论的数据类型外，Web服务方法还可以发送和接受文件附件。以下示例说明了如何做到这一点：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order to write a web service method that receives one or more attachments,
    all we need to do is add a parameter of the `jakarta.activation.DataHandler` type
    for each attachment the method will receive. In our example, the `attachFile()`
    method takes a single parameter of this type and simply writes it to the file
    system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写一个接收一个或多个附件的Web服务方法，我们只需要为方法将接收到的每个附件添加一个`jakarta.activation.DataHandler`类型的参数。在我们的例子中，`attachFile()`方法接受一个此类参数并将其简单地写入文件系统。
- en: Just like with any standard web service, the web service code needs to be packaged
    in a `WAR` file and deployed. Once deployed, a WSDL will automatically be generated.
    We then need to execute the `wsimport` utility to generate the code that our web
    service client can use to access the web service. As previously discussed, the
    `wsimport` can be invoked from the command line or via an Apache Maven plugin.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何标准Web服务一样，Web服务代码需要打包在一个`WAR`文件中并部署。一旦部署，就会自动生成WSDL。然后我们需要执行`wsimport`实用程序来生成我们的Web服务客户端可以用来访问Web服务的代码。如前所述，`wsimport`可以从命令行或通过Apache
    Maven插件调用。
- en: 'Once we have executed `wsimport` to generate code to access the web service,
    we can write and compile our client code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们执行了`wsimport`来生成访问Web服务的代码，我们就可以编写和编译我们的客户端代码：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Web service attachments need to be sent as a byte array to the web service;
    therefore, web service clients need to convert the file to attach to this type.
    In our example, we send an image as an attachment, we load the image into memory
    by creating an instance of `java.net.URL`, passing the URL of the image in question
    as a parameter to its constructor. We then obtain an `InputStream` instance corresponding
    to the image by invoking the `openStream()` method on our URL instance, convert
    our `InputStream` instance to a byte array, and then pass this byte array to the
    web service method that expects an attachment.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务附件需要以字节数组的形式发送到Web服务；因此，Web服务客户端需要将文件转换为这种类型。在我们的例子中，我们发送一个图像作为附件，我们通过创建一个`java.net.URL`实例并将图像的URL作为参数传递给其构造函数来将图像加载到内存中。然后，我们通过在URL实例上调用`openStream()`方法来获取与图像对应的`InputStream`实例，将我们的`InputStream`实例转换为字节数组，然后将这个字节数组传递给期望附件的Web服务方法。
- en: Notice that, unlike when passing standard parameters, the parameter type used
    when the client invokes a method expecting an attachment is different from the
    parameter type of the method in the web server code. The method in the web server
    code expects an instance of `jakarta.activation.DataHandler` for each attachment;
    however, the code generated by `wsimport` expects an array of bytes for each attachment.
    These arrays of bytes are converted to the right type (`jakarta.activation.DataHandler`)
    behind the scenes by the `wsimport` generated code. We as application developers
    don’t need to concern ourselves with the details of why this happens, we just
    need to keep in mind that when sending attachments to a web service method, the
    parameter types will be different in the web service code and in the client invocation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与传递标准参数不同，当客户端调用期望附件的方法时使用的参数类型与 Web 服务器代码中方法的参数类型不同。Web 服务器代码中的方法期望每个附件都是一个
    `jakarta.activation.DataHandler` 实例；然而，由 `wsimport` 生成的代码期望每个附件都是一个字节数组。这些字节数组在
    `wsimport` 生成的代码背后被转换为正确的类型（`jakarta.activation.DataHandler`）。我们作为应用程序开发者不需要关心为什么会发生这种情况的细节，我们只需要记住，当向
    Web 服务方法发送附件时，参数类型在 Web 服务代码和客户端调用中将不同。
- en: Exposing Enterprise Beans as web services
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将企业 Bean 公开为 Web 服务
- en: 'In addition to creating web services as described in the previous section,
    public methods of stateless session beans can easily be exposed as web services
    by simply adding an annotation to the Enterprise Bean class. The following example
    illustrates how to do this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在上一节中描述的创建 Web 服务之外，通过简单地向企业 Bean 类添加注解，无状态会话 Bean 的公共方法可以轻松地公开为 Web 服务。以下示例说明了如何进行此操作：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, the only thing we need to do to expose a stateless session bean’s
    public methods as web services is to decorate its class declaration with the `@WebService`
    annotation. Needless to say, since the class is a session bean, it also needs
    to be decorated with the `@``Stateless` annotation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，要将无状态会话 Bean 的公共方法公开为 Web 服务，我们只需要用 `@WebService` 注解装饰其类声明。不用说，由于该类是一个会话
    Bean，它还需要用 `@Stateless` 注解装饰。
- en: Just like regular stateless session beans, the ones whose methods are exposed
    as web services need to be deployed in a JAR file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规的无状态会话 Bean 一样，那些将方法公开为 Web 服务的需要部署在一个 JAR 文件中。
- en: Just like standard web services, WSDL URLs for Enterprise Beans web services
    depend on the application server being used. You can consult your application
    server documentation for details.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标准 Web 服务一样，企业 Bean Web 服务的 WSDL URL 依赖于所使用的应用服务器。您可以查阅您的应用服务器文档以获取详细信息。
- en: Enterprise Beans web service clients
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 企业 Bean Web 服务客户端
- en: 'The following class illustrates the procedure to be followed to access an Enterprise
    Beans web service from a client application:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类说明了从客户端应用程序访问企业 Bean Web 服务的步骤：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, nothing special needs to be done when accessing an Enterprise
    Beans web service from a client. The procedure is the same as with standard web
    services.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当从客户端访问企业 Bean Web 服务时，不需要做任何特别的事情。该过程与标准 Web 服务相同。
- en: The preceding class is a CDI named bean. *Figure 14**.3* illustrates a simple
    Jakarta Faces user interface utilizing the preceding class to invoke our web service.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类是一个 CDI 命名 Bean。*图 14.3* 展示了一个简单的 Jakarta Faces 用户界面，该界面使用前面的类来调用我们的 Web
    服务。
- en: '![Figure 14.3 – Enterprise Bean Web Service Client](img/B21231_14_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 企业 Bean Web 服务客户端](img/B21231_14_03.jpg)'
- en: Figure 14.3 – Enterprise Bean Web Service Client
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 企业 Bean Web 服务客户端
- en: Clicking on the **Int to Hex** button generates a call to the web service, which
    returns a hexadecimal value equivalent to the decimal value the user entered in
    the text input field.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **十进制转十六进制** 按钮，会生成对 Web 服务的调用，该调用返回与用户在文本输入字段中输入的十进制值等效的十六进制值。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to develop web services and web service clients
    via the Jakarta XML Web Service API.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何通过 Jakarta XML Web 服务 API 开发 Web 服务和 Web 服务客户端。
- en: 'This chapter covered the following topics:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: How to develop SOAP-based web services using Jakarta XML Web Services
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Jakarta XML Web 服务开发基于 SOAP 的 Web 服务
- en: How to incorporate web service code generation for web service clients when
    using Maven as a build tool
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在将 Maven 作为构建工具时，将 Web 服务客户端的代码生成集成到 Web 服务中
- en: Valid data types that can be used for remote method calls via Jakarta XML Web
    Services
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用于通过 Jakarta XML Web 服务进行远程方法调用的有效数据类型
- en: How to send attachments to a web service
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向Web服务发送附件
- en: How to expose Enterprise Beans methods as web services
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将企业Bean方法公开为Web服务
- en: Armed with the knowledge in this chapter, we can now develop SOAP-based web
    services, as well as maintain existing SOAP-based applications.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有本章的知识，我们现在可以开发基于SOAP的Web服务，以及维护现有的基于SOAP的应用程序。
