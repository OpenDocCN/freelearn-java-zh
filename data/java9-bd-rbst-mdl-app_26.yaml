- en: Photo Management with PhotoBeans
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PhotoBeans进行照片管理
- en: So far, we've written libraries. We've written command-line utilities. We've
    also written GUIs using JavaFX. In this chapter, we're going to try something
    completely different. We're going to build a photo management system, which, of
    course, needs to be a graphical application, but we're going to take a different
    approach. Rather than using pure JavaFX and building everything from the ground
    up, we'll use an existing application framework. That framework is the NetBeans
    **Rich Client Platform** (**RCP**), a mature, stable, and powerful framework,
    that powers not just the NetBeans IDE we've been using, but countless applications
    in a myriad of industries from oil and gas to air and space.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写了库。我们编写了命令行工具。我们还使用JavaFX编写了GUI。在本章中，我们将尝试一些完全不同的事情。我们将构建一个照片管理系统，这当然需要一个图形应用程序，但我们将采取不同的方法。而不是使用纯JavaFX从头开始构建一切，我们将使用现有的应用程序框架。这个框架就是NetBeans
    **富客户端平台**（**RCP**），这是一个成熟、稳定且强大的框架，不仅为我们在使用的NetBeans IDE提供动力，还为从石油和天然气到航空和太空的无数行业中的无数应用程序提供动力。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to bootstrap a NetBeans RCP project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何启动NetBeans RCP项目
- en: How to integrate JavaFX with the NetBeans RCP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将JavaFX集成到NetBeans RCP中
- en: The fundamentals of an RCP application such as Nodes, Actions, Lookups, Services,
    and TopComponents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RCP应用程序的基本要素，如节点、动作、查找、服务和TopComponents
- en: Without further ado then, let's jump right in.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么就不再多说了，让我们直接进入正题。
- en: Getting started
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Probably the question at or near the top of your list is, **Why would I want
    to use NetBeans RCP?**. Before we get into the details of the application, let's
    address this very fair question, and try to understand why we're building it the
    way we are.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你列表中排在最前面的问题就是，**我为什么要使用NetBeans RCP**？在我们深入探讨应用程序的细节之前，让我们来回答这个非常合理的问题，并尝试理解我们为什么要以这种方式构建它。
- en: One of the first things you'll notice when you start looking into the NetBeans
    platform is the strong notion of modularity. With the Java Module System being
    such a prominent feature of Java 9, this may seem like a minor detail, but NetBeans
    exposes this concept to us at the application level, making plugins incredibly
    simple, as well as allowing us to update the application on a piecemeal basis.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始研究NetBeans平台时，你首先会注意到的是模块化的强烈概念。鉴于Java模块系统是Java 9的一个突出特性，这可能会显得是一个小细节，但NetBeans将这个概念暴露给我们，使我们能够在应用层面进行操作，使得插件变得极其简单，同时也允许我们分块更新应用程序。
- en: The RCP also provides a robust, well-tested framework for handling windows,
    menus, actions, nodes, services, and so on. If we were to build this application
    from scratch, as we've done in the previous chapters using **plain** JavaFX, we
    would have to manually define areas on the screen, then handle window placement
    by hand. With the RCP, we have a rich windowing specification already defined,
    which we can easily use. It offers features such as maximizing/minimizing windows,
    sliding, detaching, and docking windows, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: RCP还提供了一个强大、经过良好测试的框架来处理窗口、菜单、动作、节点、服务和等等。如果我们像前几章中使用**纯**JavaFX那样从头开始构建这个应用程序，我们就必须手动定义屏幕上的区域，然后手动处理窗口位置。有了RCP，我们已经有了一个丰富的窗口规范，我们可以轻松地使用。它提供了诸如最大化/最小化窗口、滑动、分离和停靠窗口等功能。
- en: The RCP also provides a strong notion of **nodes**, an encapsulation of domain-specific
    data in a user interface concept, which is most often seen as entries in a tree
    view on the left side of an application, as well as actions that can be associated
    with these nodes (or menu items) to act on the data they represent. Again, all
    of this can be done in JavaFX (or Swing), but you would have to code all of these
    features yourself. In fact, there are a number of open source frameworks that
    offer to do just that, such as Canoo's Dolphin Platform ([http://www.dolphin-platform.io](http://www.dolphin-platform.io/)),
    though none have had the years of production hardening and testing that the NetBeans
    RCP has had, so we'll keep our focus here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RCP还提供了一种对**节点**的强烈概念，这是在用户界面概念中对特定领域数据的封装，通常在应用程序左侧的树视图中看到，以及可以与这些节点（或菜单项）关联的动作来操作它们所代表的数据。再次强调，所有这些都可以在JavaFX（或Swing）中完成，但你必须自己编写所有这些功能。实际上，有一些开源框架提供这样做，例如Canoo的Dolphin平台([http://www.dolphin-platform.io](http://www.dolphin-platform.io/))，尽管它们都没有像NetBeans
    RCP那样经过多年的生产强化和测试，所以我们将保持关注点在这里。
- en: Bootstrapping the project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动项目
- en: How you create a NetBeans RCP project will have a very fundamental impact on
    how the rest of the project will be approached. By default, NetBeans uses Ant
    as the build system for all RCP apps. Almost all of the online documentation from
    the NetBeans project, and blog entries from the NetBeans evangelists, often reflect
    this preference as well. We've been using Maven for every other project, and we're
    not going to change that here. Fortunately, NetBeans does allow us to create an
    RCP project with Maven, which is what we'll do.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何创建 NetBeans RCP 项目将对整个项目的处理方式产生非常根本的影响。默认情况下，NetBeans 使用 Ant 作为所有 RCP 应用程序的构建系统。NetBeans
    项目的大部分在线文档和博客条目通常也反映了这种偏好。我们一直在使用 Maven 进行其他所有项目，并且我们不会改变这一点。幸运的是，NetBeans 允许我们使用
    Maven 创建 RCP 项目，这正是我们将要做的。
- en: '![](img/097ca796-1bf9-49c9-acc6-c68813bf2cb7.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/097ca796-1bf9-49c9-acc6-c68813bf2cb7.png)'
- en: In the New Project window, we select Maven, then NetBeans Application. On the
    next screen, we configure the project as usual, specifying the project name, photobeans,
    project location, package, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在新项目窗口中，我们选择 Maven，然后是 NetBeans 应用程序。在下一屏幕上，我们像往常一样配置项目，指定项目名称、photobeans、项目位置、包等。
- en: 'When we click on Next, we''ll be presented with the Module Options step of
    the New Project wizard. In this step, we configure some basic aspects of the RCP
    application. Specifically, we need to specify the version of the NetBeans APIs
    we''ll use, and whether or not we want to use OSGi bundles as dependencies, as
    seen in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“下一步”时，我们将进入新项目向导的模块选项步骤。在此步骤中，我们配置 RCP 应用程序的一些基本方面。具体来说，我们需要指定我们将使用的 NetBeans
    API 版本，以及我们是否希望将 OSGi 打包作为依赖项，如以下截图所示：
- en: '![](img/f789b36a-43db-41d1-8e79-e61d9566e0ca.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f789b36a-43db-41d1-8e79-e61d9566e0ca.png)'
- en: At the time of writing, the latest platform version is RELEASE82\. By the time
    Java 9 ships, it is reasonable to expect that NetBeans 9.0, and, therefore RELEASE90,
    will be available. We want the latest version available, but note that, depending
    on the release schedule of the NetBeans project, it may very well *not* be 9.0\.
    For the Allow OSGi bundles as dependencies option we can safely accept the default,
    though changing it won't cause us any issues, and we can easily change the value
    later should the need arise.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最新平台版本是 RELEASE82。到 Java 9 发布时，我们可以合理地预期 NetBeans 9.0 和因此 RELEASE90 将会可用。我们希望使用可用的最新版本，但请注意，根据
    NetBeans 项目的发布计划，它可能根本不是 9.0。对于允许 OSGi 打包作为依赖项的选项，我们可以安全地接受默认设置，尽管更改它不会给我们带来任何问题，如果需要，我们也可以轻松地稍后更改该值。
- en: 'Once the project is created, we should see three new entries in the projects
    window: `PhotoBeans-parent`, `PhotoBeans-app`, and `PhotoBeans-branding`. The
    `-parent` project has no real deliverables. Like the `master` projects from other
    chapters, this serves merely to organize related modules, coordinate dependencies,
    and so on.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建项目，我们应该在项目窗口中看到三个新的条目：`PhotoBeans-parent`、`PhotoBeans-app` 和 `PhotoBeans-branding`。`-parent`
    项目没有实际的交付物。像其他章节的`master`项目一样，这只是为了组织相关模块、协调依赖关系等。
- en: Branding your application
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序添加品牌
- en: 'The `-branding` module is where we can define, as you may have already guessed,
    the details of the application''s branding. You can access these branding properties
    by right-clicking on the branding module, and selecting `Branding...` near the
    bottom of the content menu. Upon doing so, you will be prompted with a screen
    like this one:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`-branding` 模块是我们定义应用程序品牌细节的地方。正如你可能已经猜到的，你可以通过右键单击品牌模块，并在内容菜单底部选择`Branding...`来访问这些品牌属性。这样做后，你会看到一个类似于这样的屏幕：'
- en: '![](img/d735d72c-57cb-4d36-b07b-d5c692d6ede1.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d735d72c-57cb-4d36-b07b-d5c692d6ede1.png)'
- en: In this preceding tab, you can set or change the name of the application, as
    well as specify the application icon.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在此 preceding 标签页中，你可以设置或更改应用程序的名称，以及指定应用程序图标。
- en: 'In the Splash Screen tab, you can configure, most importantly, the image that
    is displayed on the splash screen as the application loads. You can also enable
    or disable the progress bar, and set the colors, font sizes, and positions of
    the progress bar and startup messages:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动屏幕标签页中，你可以配置，最重要的是，当应用程序加载时在启动屏幕上显示的图像。你还可以启用或禁用进度条，并设置进度条和启动信息的颜色、字体大小和位置：
- en: '![](img/67ceebc4-ef35-49f9-b1e0-dfbbcd90ec0e.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67ceebc4-ef35-49f9-b1e0-dfbbcd90ec0e.png)'
- en: 'The only other tab that is of interest to us at the moment is the Window System
    tab. In this tab, we can configure a number of features such as window drag and
    drop, window sliding, closing, and so on:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前对我们来说，唯一感兴趣的另一个标签页是“窗口系统”标签页。在这个标签页中，我们可以配置许多功能，例如窗口拖放、窗口滑动、关闭等：
- en: '![](img/9b96bcc7-18cf-4162-8c8b-d326e24059a3.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b96bcc7-18cf-4162-8c8b-d326e24059a3.png)'
- en: More likely than not, the defaults are acceptable for our purposes here. However,
    in your own NetBeans RCP application, this screen may be much more important.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，默认设置对我们的目的来说是可接受的。然而，在你自己的NetBeans RCP应用程序中，这个屏幕可能要重要得多。
- en: Our main interest is the `-app` module. This module is the one that will define
    all of the application's dependencies, and will be its entry point. Unlike the
    JavaFX applications we've seen in previous chapters, though, we don't need to
    define a `public static void main` method, as NetBeans handles that for us. In
    fact, the `-app` module doesn't have any Java classes in it at all, yet the app
    can run right out-of-the-box, though it doesn't do much. We'll fix that now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要兴趣是`-app`模块。这个模块将定义应用程序的所有依赖项，并将作为其入口点。然而，与我们在前几章中看到的JavaFX应用程序不同，我们不需要定义`public
    static void main`方法，因为NetBeans会为我们处理这个。实际上，`-app`模块根本不包含任何Java类，但应用程序可以立即运行，尽管它目前并没有做什么。我们现在将解决这个问题。
- en: NetBeans modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NetBeans模块
- en: 'One of the strengths of the NetBeans platform is its modularity. If you''ve
    ever used the NetBeans IDE itself (before, say, reading this book), you''ve seen
    this modularity in action when working with plugins: every NetBeans plugin is
    made up of one or more modules. In fact, NetBeans itself is composed of numerous
    modules. That''s how RCP applications are designed to work. It promotes decoupling,
    and makes extending and upgrading the application much simpler.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans平台的一个优势是其模块化。如果你曾经使用过NetBeans IDE本身（比如在阅读本书之前），你会在使用插件时看到这种模块化的实际应用：每个NetBeans插件都由一个或多个模块组成。实际上，NetBeans本身由许多模块组成。这就是RCP应用程序设计成这样工作的原因。它促进了解耦，使得扩展和升级应用程序变得更加简单。
- en: 'The generally accepted pattern is to, say, put the API classes in one module
    and the implementations in another. This makes the API classes reusable by other
    implementers, can help enforce low coupling by hiding private classes, and so
    on. To keep things simple as we learn the platform, though, we are going to create
    just one module that will provide all of the core functionality. To do that, we
    right-click on the Modules node under the parent project, and select Create New
    Module...: as shown in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常接受的模式是将API类放在一个模块中，将实现放在另一个模块中。这使得API类可以被其他实现者重用，有助于通过隐藏私有类来强制低耦合，等等。然而，为了在我们学习平台时保持简单，我们将创建一个模块，该模块将提供所有核心功能。为此，我们在父项目下的“模块”节点上右键单击，并选择“创建新模块...”，如下面的截图所示：
- en: '![](img/65839393-7da8-4b95-97a6-e23bed8b59fe.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65839393-7da8-4b95-97a6-e23bed8b59fe.png)'
- en: 'Once selected, you will be shown the New Project window. Here, you will need
    to select the Maven category, and the NetBeans Module project type, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择，你将看到“新建项目”窗口。在这里，你需要选择Maven类别，以及NetBeans模块项目类型，如下所示：
- en: '![](img/b83bfd3d-7014-4b07-96f8-bfd0347f681a.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b83bfd3d-7014-4b07-96f8-bfd0347f681a.png)'
- en: Clicking on Next will get you the Name and Location step we've seen several
    times already in this book. On this pane, we'll name the module `main`, set the
    package to `com.steeplesoft.photobeans.main`, and accept the defaults for the
    other fields. On the next pane, Module Options, we will make sure that the NetBeans
    Version is the same as was selected earlier, and click on Finish.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”将带你去到我们在本书中已经多次见过的“名称和位置”步骤。在这个面板上，我们将模块命名为`main`，设置包为`com.steeplesoft.photobeans.main`，并接受其他字段的默认设置。在下一个面板“模块选项”中，我们将确保NetBeans版本与之前选择的版本相同，然后点击“完成”。
- en: TopComponent - the class for tabs and windows
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TopComponent - 标签页和窗口的类
- en: 'We now have a module that is mostly empty. NetBeans created a few artifacts
    for us, but we need not concern ourselves with those, as the build will manage
    those for us. What we do need to do, though, is create our first GUI element,
    which will be something that NetBeans calls a TopComponent. From the NetBeans
    Javadoc, found at [http://bits.netbeans.org/8.2/javadoc/](http://bits.netbeans.org/8.2/javadoc/),
    we find this definition:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个主要为空的模块。NetBeans为我们创建了一些工件，但我们不需要担心这些，因为构建将为我们管理这些。不过，我们需要做的是创建我们的第一个GUI元素，这将是NetBeans称为TopComponent的东西。从NetBeans
    Javadoc中，网址为[http://bits.netbeans.org/8.2/javadoc/](http://bits.netbeans.org/8.2/javadoc/)，我们找到了以下定义：
- en: Embeddable visual component to be displayed in NetBeans. This is the basic unit
    of display--windows should not be created directly, but rather use this class.
    A top component may correspond to a single window, but may also be a tab (e.g.)
    in a window. It may be docked or undocked, have selected nodes, supply actions,
    etc.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可嵌入的视觉组件，将在NetBeans中显示。这是显示的基本单元--窗口不应直接创建，而应使用此类。顶级组件可能对应单个窗口，也可能是一个窗口中的标签页（例如）。它可以停靠或取消停靠，有选定的节点，提供操作等。
- en: As we'll see, this class is the main component of a NetBeans RCP application.
    It will hold and control various related user interface elements. It is, to put
    it another way, at the top of a component hierarchy in the user interface. To
    create TopComponent, we can use the NetBeans wizard by right-clicking on our now
    empty package in the Project Explorer tree, and selecting New | Window. If Window
    is not an option, select Other | Module Development | Window.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，这个类是NetBeans RCP应用程序的主要组件。它将持有并控制各种相关的用户界面元素。换句话说，它是用户界面组件层次结构中的顶层。要创建TopComponent，我们可以通过在项目资源管理器树中右键单击现在为空的包，并选择“新建
    | 窗口”来使用NetBeans向导。如果“窗口”不是选项，请选择“其他 | 模块开发 | 窗口”。
- en: 'You should now see the following Basic Settings window:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到以下基本设置窗口：
- en: '![](img/727678b4-39df-4316-9037-de24bae2dab2.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/727678b4-39df-4316-9037-de24bae2dab2.png)'
- en: 'We have a number of options in the preceding window. What we''re creating is
    a window that will show a list of photos, so some reasonable settings would be
    to select the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的窗口中，我们有多个选项。我们正在创建一个将显示照片列表的窗口，因此一些合理的设置可能是选择以下选项：
- en: Open on Application Start
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序启动时打开
- en: Closing not allowed
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭不允许
- en: Maximization not allowed
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化不允许
- en: 'These options seem pretty straightforward, but what is Window Position? Another
    of the benefits of using the NetBeans RCP as opposed to writing everything from
    scratch is that the platform provides a number of predefined concepts and facilities
    so that we don''t need to worry about them. One such concern is window positioning
    and placement. The NetBeans user interface specification (which can be found on
    the NetBeans site at [https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html](https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html))
    defines the following areas:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项看起来相当直接，但窗口位置是什么意思？与从头开始编写相比，使用NetBeans RCP的一个好处是，平台提供了一系列预定义的概念和功能，这样我们就不必担心它们。其中一个关注点是窗口定位和放置。NetBeans用户界面规范（可在NetBeans网站上找到，网址为[https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html](https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html)）定义了以下区域：
- en: '**Explorer:** This is used for all windows that provide access to user objects,
    usually in tree browsers'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理器：** 这用于提供对用户对象访问的所有窗口，通常在树浏览器中'
- en: '**Output:** This is used for the Output window and VCS Output window by default'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出：** 默认情况下，这用于输出窗口和VCS输出窗口'
- en: '**Debugger:** This is used for all the debugger windows and other supporting
    windows that require a horizontal layout'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器：** 这用于所有调试窗口和其他需要水平布局的支持窗口'
- en: '**Palette:** This is used for the component palette window'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调色板：** 这用于组件调色板窗口'
- en: '**Inspector:** This is used for the component inspector window'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查器：** 这用于组件检查器窗口'
- en: '**Properties:** This is used for the properties window'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性：** 这用于属性窗口'
- en: '**Documents:** This is used for all the document windows'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档：** 这用于所有文档窗口'
- en: 'The documentation also provides this helpful illustration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 文档还提供了这个有用的插图：
- en: '![](img/6f98b02c-9eb7-446b-8faf-6f6a9bc276e0.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f98b02c-9eb7-446b-8faf-6f6a9bc276e0.png)'
- en: 'The specification page has a great deal of additional information, but this
    should be enough for now to get you going. We would like our photo list to be
    on the left side of the application window, so we select editor for the window
    position. Clicking on Next, we configure the name and icon for the component.
    Strictly speaking, we don''t need to specify an icon for TopComponent, so we can
    just enter `PhotoList` for Class Name Prefix:, and click on Finish:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 规范页面有大量的附加信息，但这对现在来说应该足够了，可以让你开始。我们希望我们的照片列表显示在应用程序窗口的左侧，所以我们选择窗口位置的编辑器。点击下一步，我们配置组件的名称和图标。严格来说，我们不需要为TopComponent指定图标，所以我们可以在“类名前缀”中输入`PhotoList`，然后点击完成：
- en: '![](img/2ff6d649-af7d-49d8-8e51-afe9137ad476.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ff6d649-af7d-49d8-8e51-afe9137ad476.png)'
- en: When you click on Finish here, NetBeans will create a couple of files for you,
    though only one will show up in the Project Explorer tree, that being `PhotoListTopComponent.java`.
    There is also a file called `PhotoListTopComponent.form` that you need to know
    about, though you will never edit it directly. NetBeans provides a very nice **WYSIWYG**
    (what you see is what you get) editor for building your user interface. The user
    interface definition is stored in the `.form` file, which is simply an XML file.
    As you make changes, NetBeans modifies this file for you, and generates the equivalent
    Java code in a method called `initComponents()`. You'll also notice that NetBeans
    will not allow you to modify the method. You can, of course, use another editor
    to do so, but any changes you make that way will be lost if you make changes in
    the GUI editor, so it's best just to leave the method alone. What does the rest
    of TopComponent look like?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在这里点击完成时，NetBeans会为你创建几个文件，尽管只有一个会在项目资源管理器树中显示，那就是`PhotoListTopComponent.java`。还有一个名为`PhotoListTopComponent.form`的文件，你需要了解它，尽管你永远不会直接编辑它。NetBeans提供了一个非常棒的**WYSIWYG**（所见即所得）编辑器来构建你的用户界面。用户界面定义存储在`.form`文件中，它只是一个XML文件。当你进行更改时，NetBeans会为你修改这个文件，并在名为`initComponents()`的方法中生成等效的Java代码。你还会注意到NetBeans不会允许你修改这个方法。当然，你可以使用另一个编辑器来这样做，但如果你在GUI编辑器中进行更改，那么你通过这种方式所做的任何更改都将丢失，所以最好还是不要修改这个方法。TopComponent的其他部分看起来是什么样子？
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's a lot of annotations, but is also a good reminder of how much the NetBeans
    platform is doing for you. During the build process, these annotations are processed
    to create the metadata that the platform will use at runtime to configure and
    wire together your application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多注解，但也是一个很好的提醒，说明NetBeans平台为你做了多少工作。在构建过程中，这些注解被处理以创建平台在运行时用于配置和连接你的应用程序的元数据。
- en: 'Some of the highlights are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些亮点如下：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This registers our `TopComponent`, and reflects our choices of where to put
    it and when to open it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这注册了我们的`TopComponent`，并反映了我们放置它的位置和打开它的时间的选择。
- en: 'We also have some internationalization and localization work being done for
    us, as shown next:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些国际化本地化工作正在进行，如下所示：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Without getting too far into the details and risking confusing things, the
    first three annotations register an open Action, and expose an item in the `Window`
    menu of our application. The last annotation, `@Messages`, is used to define the
    localization keys and strings. When this class is compiled, a class called `Bundle`
    is created in the same package, which defines methods using the specified keys
    to return the localized string. For example, for `CTL_PhotoListAction`, we get
    the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，以免混淆，前三个注解注册了一个打开动作，并暴露了应用程序`Window`菜单中的一个项目。最后一个注解`@Messages`用于定义本地化键和字符串。当这个类编译时，在同一个包中创建了一个名为`Bundle`的类，它使用指定的键定义方法来返回本地化字符串。例如，对于`CTL_PhotoListAction`，我们得到以下：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This preceding code looks up the key in the standard Java `.properties` file
    for a localized message. These key/value pairs are merged with any entries found
    in the `Bundle.properties` file that the NetBeans wizard generated for us.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在标准的Java `.properties`文件中查找用于本地化消息的键。这些键/值对与NetBeans向导为我们生成的`Bundle.properties`文件中的任何条目合并。
- en: 'The following constructor of our `TopComponent` is also of interest:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`TopComponent`的以下构造函数也很有趣：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding constructor, we can see how the component's name and tool tip
    are set, as well as where our window-related options are set.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的构造函数中，我们可以看到组件的名称和工具提示是如何设置的，以及我们的窗口相关选项设置在哪里。
- en: 'If we run our application now, we won''t see any changes. What we need to do,
    then, is add a dependency on the `main` module to the application. We do that
    by right-clicking on the Dependencies node of the app module, as shown in this
    screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用程序，我们不会看到任何变化。那么，我们需要做的是将`main`模块的依赖项添加到应用程序中。我们通过在应用程序模块的“依赖项”节点上右键单击来完成此操作，如图所示：
- en: '![](img/11499e06-50f5-42d6-b683-4630c41fd4e7.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11499e06-50f5-42d6-b683-4630c41fd4e7.png)'
- en: 'You should now see the Add Dependency window. Select the Open Projects tab,
    then select `main` as shown in this screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看到“添加依赖”窗口。选择“打开项目”选项卡，然后选择如图所示的`main`：
- en: '![](img/86ef5273-a784-42a1-bca0-480786969a39.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86ef5273-a784-42a1-bca0-480786969a39.png)'
- en: 'Once we''ve added the dependency, we need to build both modules, first `main`
    and then `app`, and then we''ll be ready to run PhotoBeans for the first time:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了依赖项，我们需要构建这两个模块，首先是`main`，然后是`app`，然后我们就可以第一次运行PhotoBeans了：
- en: '![](img/413c0faa-c309-4627-b2a7-e8a6d378bd0b.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/413c0faa-c309-4627-b2a7-e8a6d378bd0b.png)'
- en: Notice the odd date in the window title in the preceding screen? That's the
    build date of the NetBeans platform, and it's not very pretty in our app, so,
    let's fix that. We have two options. The first is to use the Branding user interface
    we looked at earlier. The other is to edit the file directly. To keep things interesting,
    and to help understand where things are on the disk, we'll use this second approach.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到前面屏幕窗口标题中的奇怪日期吗？那是NetBeans平台的构建日期，在我们的应用程序中看起来并不美观，所以，让我们来修复它。我们有两种选择。第一种是使用我们之前查看的品牌用户界面。另一种是直接编辑文件。为了保持事情有趣，并帮助理解磁盘上的位置，我们将使用第二种方法。
- en: 'In the branding module, under Other Sources | nbm-branding, you should find
    the `modules/org-netbeans-core-windows.jar/org/netbeans/core/windows/ view/ui/Bundle.properties`
    file. In this file, you should see these lines:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在品牌模块中，在“其他来源”|“nbm-branding”下，你应该能找到`modules/org-netbeans-core-windows.jar/org/netbeans/core/windows/view/ui/Bundle.properties`文件。在这个文件中，你应该能看到以下几行：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All we need to do is remove the `{0}` portions, rebuild this module and the
    app, and our title bar is much prettier. While that looks better, what about our
    TopComponent? To fix that, we need to learn a few new concepts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是移除`{0}`部分，重新构建此模块和应用程序，我们的标题栏就会变得更加美观。虽然这样看起来更好，但我们的TopComponent怎么办？为了修复它，我们需要学习一些新的概念。
- en: Nodes, a NetBeans presentation object
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点，NetBeans演示对象
- en: You've already heard the term Node. I've used it several times to describe what
    and where to click. Officially, a Node represents one element in a hierarchy of
    objects (beans). It provides all the methods that are needed for communication
    between an explorer view and the bean. In the explorer section of our application,
    we want to represent a list of photos to the user. We'll represent each photo,
    as well as the year and month in which it was taken, as a Node. To display these
    Nodes, we'll use a NetBeans class called the `BeanTreeView`, which will display
    this node hierarchy as a tree. There are a few more concepts to learn, but let's
    start with what we have first.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经听说过“节点”这个词。我已经多次用它来描述点击什么和在哪里点击。正式来说，节点代表对象（bean）层次结构中的一个元素。它提供了在探索视图和bean之间进行通信所需的所有方法。在我们的应用程序的探索部分，我们希望向用户展示照片列表。我们将每个照片以及它被拍摄的年份和月份表示为一个节点。为了显示这些节点，我们将使用一个名为`BeanTreeView`的NetBeans类，它将以树的形式显示这个节点层次结构。还有更多概念需要学习，但让我们先从我们已有的开始。
- en: We'll begin by defining our Nodes, which will serve as a sort of wrapper or
    bridge between our application's business domain model and the NetBeans APIs.
    We have not, of course, defined such a model, so we need to settle on that now.
    Our basic data item is a photograph, a file on disk that holds an image. In the
    application, we're going to display these photos in a nested tree structure, grouping
    the photos by year, then month. If you expand a year node, you'll see a list of
    month Nodes, and if you expand a month Node, you'll see a list of photo Nodes.
    It's a very basic, somewhat naive data model, but it's both, effective enough
    to demonstrate the concepts, and simple enough that we don't obscure the concepts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义我们的节点开始，这些节点将作为我们应用程序的业务领域模型和NetBeans API之间的一种包装器或桥梁。当然，我们还没有定义这样的模型，所以我们需要现在确定它。我们的基本数据项是一张照片，一个存储图像的磁盘文件。在应用程序中，我们将以嵌套的树结构显示这些照片，按年份分组，然后按月份。如果你展开一个年份节点，你会看到一个月份节点列表，如果你展开一个月份节点，你会看到一个照片节点列表。这是一个非常基础、有些天真的数据模型，但它既足够有效以展示概念，又足够简单，以至于我们不会掩盖概念。
- en: 'As with all hierarchies, we need a root node, so we''ll start with that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所有层次结构一样，我们需要一个根节点，所以我们将从这里开始：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The base class of all nodes is, technically, Node, but extending that class
    puts much more of a burden on us, so we use the NetBeans-provided `AbstractNode`,
    which implements a fair amount of the basic behavior of the node for us with reasonable
    defaults.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点的基类在技术上来说是Node，但扩展该类给我们带来了更大的负担，因此我们使用NetBeans提供的`AbstractNode`，它为我们实现了一部分节点的基本行为，并提供了合理的默认值。
- en: 'Next, we define some constructors as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一些构造函数，如下所示：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we have two constructors, one `public` and one `protected`. The reason
    for that is that we want to create and capture an instance of `InstanceContent`,
    which can be used by us, the creators of this class' Lookup, to control what is
    actually in the lookup. Since we need to pass `Lookup` to our class' parent constructor,
    we have this two-step approach to object instantiation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有两个构造函数，一个是`public`的，另一个是`protected`的。之所以这样，是因为我们想要创建和捕获一个`InstanceContent`的实例，这个实例可以被我们，即这个类Lookup的创建者，用来控制实际上在lookup中的内容。由于我们需要将`Lookup`传递给我们的类的父构造函数，所以我们采用了这种两步对象实例化的方法。
- en: Lookup, a NetBeans fundamental
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lookup，NetBeans的基本组成部分
- en: What's a Lookup? It is a **general registry permitting clients to find instances
    of services (implementation of a given interface)**. To put it another way, it
    is a mechanism by which we can publish various artifacts, and other parts of the
    system can look up these artifacts by a key (either a `Class` or a `Lookup.Template`,
    which we'll not discuss here), with no coupling between the modules.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Lookup？它是一个**通用注册表，允许客户端查找服务实例（给定接口的实现）**。换句话说，它是一种机制，我们可以通过它发布各种工件，而系统的其他部分可以通过键（可以是`Class`或`Lookup.Template`，这里我们不讨论）查找这些工件，而模块之间没有耦合。
- en: This is often used, as we'll see, to look up the implementations of a service
    interface. Do you recall earlier when I mentioned that often we see APIs defined
    in one module and implementations in another? This is where that comes in especially
    handy. Suppose you're developing an API to retrieve photos from an online service
    (which would be a great feature for this application!). You plan to deliver an
    implementation for one service, say Google Photos, but want to enable a third-party
    developer to provide an implementation for, say, Flickr. If you put the required
    API interfaces, classes, and so on in one module, and your Google Photos implementation
    in another, the third-party developer can depend on your API module alone, and
    avoid the weight of your implementation module. The Flickr module would declare
    an implementation of the photo service API, and we could load both that and our
    own Google Photos implementation via a request to the Lookup. In a nutshell, the
    system allows for decoupling the API definition, implementation, and instance
    acquisition in a very clean, simple API.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这通常用于查找服务接口的实现。你还记得我之前提到过，我们经常看到API在一个模块中定义，实现却在另一个模块中吗？这正是这种做法特别有用之处。假设你正在开发一个用于从在线服务检索照片的API（这对这个应用程序来说将是一个很棒的功能！）。你计划为一种服务提供实现，比如Google
    Photos，但希望第三方开发者能够为Flickr提供实现。如果你将所需的API接口、类等放在一个模块中，而将Google Photos的实现放在另一个模块中，第三方开发者就可以仅依赖于你的API模块，避免你的实现模块的负担。Flickr模块将声明对照片服务API的实现，我们可以通过向Lookup发送请求来加载这两个实现。简而言之，该系统允许以非常干净、简单的方式解耦API定义、实现和实例获取。
- en: That's Lookup, but what is `InstanceContent`? The Lookup API only exposes methods
    for getting items. There is no mechanism for adding items to the Lookup, which
    makes sense as the Lookup instance is used by unknown third parties, and we don't
    want them changing the contents of our Lookup randomly. We, however, may actually
    want to change those contents, and we do that via `InstanceContent`, which exposes
    the methods we need to add or remove items. We'll see a demonstration of this
    concept later in the application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那是Lookup，但`InstanceContent`是什么？Lookup API只公开了获取项的方法。没有将项添加到Lookup的机制，这是有道理的，因为Lookup实例被未知第三方使用，我们不希望他们随机更改Lookup的内容。然而，我们实际上可能想要更改这些内容，我们通过`InstanceContent`来实现，它公开了我们需要添加或删除项的方法。我们将在应用程序的后面部分看到这个概念的演示。
- en: Writing our own nodes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们自己的节点
- en: 'The preceding section covered those two classes, but what is `YearChildFactory`?
    The class `RootNode` defines for the system the root node of what will become
    our tree. Each node, though, if it has children, is responsible for loading and
    building those child Nodes, which is done through this `ChildFactory` class. Our
    instance looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节介绍了这两个类，但`YearChildFactory`是什么？`RootNode`类为系统定义了将成为我们树根的根节点。然而，每个节点（如果它有子节点），都要负责加载和构建这些子节点，这是通过这个`ChildFactory`类来完成的。我们的实例看起来是这样的：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are creating a `ChildFactory` interface that will return nodes that operate
    on Strings. If you have a more complex data model, one that uses, for example,
    POJOs, you would specify that class as the parameterized type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个`ChildFactory`接口，该接口将返回操作字符串的节点。如果你有一个更复杂的数据模型，例如使用POJOs的模型，你将指定该类作为参数化类型。
- en: 'In our constructor, we see an example of finding a service implementation via
    the Lookup, which is this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们看到通过Lookup找到服务实现的一个例子，这是这样的：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We'll look at defining services later, but, for now, all you need to understand
    is that we're asking the global Lookup (which is, unlike the Lookup we created
    previously, not tied to a particular class) for an instance of the `PhotoManager`
    interface. Perhaps naively, we assume there is only one instance of this interface,
    but since we're not exporting the interface, we are safe in our assumption. We
    do, though, check to make sure there is at least one, exiting the application
    if there is not.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后定义服务，但，现在你需要理解的是，我们正在请求全局Lookup（与之前创建的Lookup不同，它不绑定到特定类）的`PhotoManager`接口实例。也许有些天真，我们假设只有一个这样的接口实例，但由于我们没有导出接口，我们的假设是安全的。然而，我们确实检查了至少有一个实例，如果没有，则退出应用程序。
- en: The next two methods are how the factory is used to create the child Nodes.
    The first method, `createKeys(List<String> list)`, is called by the system to
    generate a list of keys for the child nodes. In our implementation, we ask the
    `PhotoManager` interface for a list of years (which, as we'll see, is a simple
    query of the database to get a list of the years for which we have photos in the
    system). The platform then takes these keys, and passes them, one at a time, to
    `createNodeForKey(String key)` to create the actual node. Here, we create an instance
    of `YearNode` to represent the year.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法是如何使用工厂来创建子节点的。第一个方法`createKeys(List<String> list)`是由系统调用来生成子节点键列表的。在我们的实现中，我们向`PhotoManager`接口请求年份列表（正如我们将看到的，这是一个简单的数据库查询，以获取系统中照片的年份列表）。然后平台将这些键逐个传递给`createNodeForKey(String
    key)`来创建实际的节点。在这里，我们创建了一个`YearNode`实例来表示年份。
- en: '`YearNode`, like `RootNode`, extends `AbstractNode`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`YearNode`，像`RootNode`一样，扩展了`AbstractNode`。'
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding is clearly a simpler node, but the basics are the same--we create
    `ChildFactory` to create our children, and we create a Lookup, which, in this
    case, holds a single value, the year that the Node represents.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的确实是更简单的节点，但基本原理是相同的--我们创建`ChildFactory`来创建我们的子节点，并创建一个Lookup，在这个例子中，它持有一个单一值，即节点所代表的年份。
- en: '`MonthNodeFactory` looks almost exactly like `YearNodeFactory` with the exception
    that it loads months for the given year, so we''ll not show the source here. It
    also creates `MonthNode` instances for each month in the list. Like `YearNode`,
    `MonthNode` is pretty simple, as you can see in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonthNodeFactory`几乎与`YearNodeFactory`完全相同，除了它为给定的年份加载月份，所以我们在这里不展示源代码。它还为列表中的每个月份创建`MonthNode`实例。像`YearNode`一样，`MonthNode`相当简单，如下面的代码片段所示：'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We do a bit more work to give the Node a meaningful name and display name,
    but it''s pretty much the same. Note also that we have yet another `ChildFactory`
    that will generate, as the name implies, the PhotoNodes we''ll need as children.
    The factory itself has nothing new of interest, but `PhotoNode` does, so let''s
    take a look at that:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了一些额外的工作来给节点一个有意义的名称和显示名称，但基本上是相同的。注意，我们还有一个`ChildFactory`，正如其名所示，将生成我们需要作为子节点的PhotoNodes。工厂本身没有什么新奇的，但`PhotoNode`有，所以让我们看看：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we again see the dual constructor approach, though, in this case, we do
    make use of `InstanceContent`. Note that the first parameter to `super()` is `Children.LEAF`,
    indicating that this Node does not have any children. We also pass the now familiar
    `new AbstractLookup(ic)`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次看到双重构造方法，尽管在这种情况下，我们确实使用了`InstanceContent`。注意，`super()`的第一个参数是`Children.LEAF`，表示这个节点没有子节点。我们还传递了现在熟悉的`new
    AbstractLookup(ic)`。
- en: 'After setting the name and display name, we add a lambda to our `InstanceContent`
    object. The non-lambda version of this would look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置名称和显示名称之后，我们在 `InstanceContent` 对象中添加了一个 lambda 表达式。这个 lambda 表达式的非 lambda
    版本看起来像这样：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What is `OpenCookie`? It's a child of the marker interface `Node.Cookie`, and
    a cookie is **a design pattern used to add behaviors to existing data objects
    and nodes, or to separate implementation from the main object**. Using this cookie,
    we can neatly abstract away the signaling that something can be opened as well
    as how to open it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 `OpenCookie`？它是标记接口 `Node.Cookie` 的子类，而 cookie 是 **一种用于向现有数据对象和节点添加行为，或将实现与主要对象分离的设计模式**。使用这个
    cookie，我们可以优雅地抽象出表示某物可以打开以及如何打开它的信号。
- en: In this case, when the system tries to open the photo represented by the node,
    it will call our definition of `OpenCookie.open()`, which will attempt to find
    an open instance of the photo. Whether it finds an existing one or needs to create
    a new one, it instructs the system to make it active (or give it focus).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当系统尝试打开节点表示的图片时，它将调用我们定义的 `OpenCookie.open()`，这将尝试找到打开的图片实例。无论它找到现有的实例还是需要创建一个新的实例，它都会指示系统使其活动（或给予它焦点）。
- en: 'Note that the open photo is represented by another TopComponent. To find it,
    we have this method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，打开的图片由另一个 TopComponent 表示。为了找到它，我们有这个方法：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We ask the Lookup of `WindowManager` for all the opened TopComponents, then
    iterate through each, comparing `String photo`, which is the full path of the
    image, with any `String` stored in the Lookup of TopComponent. If there's a match,
    we return that TopComponent. This lookup by `String` is somewhat naive though,
    and could, in more complex applications, result in unexpected matches. We're likely
    safe enough in this application, but you'll need to make sure in your own application
    that the matching criteria are strict and unique enough to avoid false hits.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `WindowManager` 的 Lookup 请求所有打开的 TopComponent，然后遍历每个组件，比较 `String photo`，即图像的完整路径，与
    TopComponent Lookup 中存储的任何 `String`。如果匹配，我们返回该 TopComponent。这种通过 `String` 的查找方法虽然有些简单，但在更复杂的应用中可能会导致意外的匹配。在这个应用中我们可能足够安全，但你需要确保在自己的应用中匹配标准严格且唯一，以避免错误匹配。
- en: Performing Actions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行操作
- en: We'll look at `PhotoViewerTopComponent` in a moment, but there are a few more
    items we need to look at before moving on to that.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将查看 `PhotoViewerTopComponent`，但在继续之前，我们还需要查看一些其他项目。
- en: '`PhotoNode` overrides two additional methods, which are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`PhotoNode` 覆盖了两个额外的方法，具体如下：'
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unsurprisingly, the `getActions()` method returns an array of Actions for this
    Node. Actions are an abstraction (from Swing, not NetBeans) that allow us to add
    items to menus, and provide a means for a user to interact with the system. Each
    entry you see in the main menu or a context menu is backed by an Action. In our
    case, we're associating the NetBeans-defined `OpenAction` with our node, which
    will, when clicked, look for an `OpenCookie` instance in the Node's lookup and
    call `OpenCookie.open()`, which we defined previously.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不足为奇，`getActions()` 方法返回一个包含该节点动作的数组。动作是一种抽象（来自 Swing，而非 NetBeans），它允许我们向菜单中添加项目，并为用户提供与系统交互的手段。主菜单或上下文菜单中的每个条目都由一个动作支持。在我们的例子中，我们将
    NetBeans 定义的 `OpenAction` 与我们的节点关联，当点击时，将在节点的 Lookup 中查找 `OpenCookie` 实例并调用我们之前定义的
    `OpenCookie.open()`。
- en: We also override `getPreferredAction()`, which lets us define the behavior for
    when a Node is double-clicked. The combination of these two methods makes it possible
    for the user to right-click a Node and select `Open`, or double-click a Node,
    with the end result being that the TopComponent for that Node is opened.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还覆盖了 `getPreferredAction()` 方法，这让我们可以定义当节点被双击时的行为。这两个方法的组合使得用户可以通过右键单击节点并选择“打开”，或者双击节点，最终结果是打开该节点的
    TopComponent。
- en: Services - exposing decoupled functionality
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务 - 暴露解耦的功能
- en: 'Before looking at the definition of our `TopComponent`, let''s look at `PhotoManager`,
    and learn a bit about its services. The `PhotoManager` interface itself is pretty
    simple:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我们的 `TopComponent` 定义之前，让我们先看看 `PhotoManager`，并了解一下它的服务。`PhotoManager` 接口本身相当简单：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is little of interest in the preceding code beyond the `extends Lookup.Provider`
    portion. Adding this here, we can force implementations to implement the lone
    method on that interface, as we''ll need that later. The interesting part comes
    from the implementation, which is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，除了`extends Lookup.Provider`部分外，没有太多有趣的内容。在这里添加它，我们可以强制实现该接口上的唯一方法，因为我们需要在以后使用它。有趣的部分来自实现，如下所示：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That is all it takes to register a service with the platform. The annotation
    specifies the metadata needed, and the build takes care of the rest. Let''s take
    a look at the rest of the implementation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注册服务到平台所需的就是这些。注解指定了所需的元数据，构建过程会处理其余部分。让我们看看其余的实现：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this preceding, very simple, implementation, we're going to use SQLite to
    store information about the photos we find. The service will provide the code
    to scan the configured source directories, store information about the photos
    found, and expose methods for retrieving those pieces of that information that
    vary in specificity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常简单的实现中，我们将使用SQLite来存储我们找到的照片信息。该服务将提供扫描配置的源目录、存储找到的照片信息以及公开检索这些信息片段的方法。
- en: To start with, we need to make sure that the database is properly set up if
    this is the first time the application is run. We could include a prebuilt database,
    but creating it on the user's machine adds a bit of resilience for those situations
    where the database is accidentally deleted.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保如果这是应用程序第一次运行，数据库已经正确设置。我们可以包含一个预构建的数据库，但在用户的机器上创建它为那些意外删除数据库的情况增加了一丝弹性。
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we ask for a reference to the NetBeans preferences for the module `PhotoManager`.
    We'll look at managing preferences later in the chapter where we'll delve into
    this API in more detail, but, for now, we'll say only that we are going to ask
    the system for the `sourceDirs` preference, which we'll then use to configure
    our scanning code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们请求模块`PhotoManager`的NetBeans首选项引用。我们将在本章的后面部分讨论首选项管理，但现在我们只能说，我们将请求系统的`sourceDirs`首选项，然后我们将使用它来配置我们的扫描代码。
- en: We also create `PreferenceChangeListener` to capture when the user changes the
    preferences. In this listener, we verify that the preference we care about, `sourceDirs`,
    was changed, and, if it was, we store the new value in our `PhotoManager` instance,
    and initiate a directory scan.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了`PreferenceChangeListener`来捕捉用户更改首选项的情况。在这个监听器中，我们验证我们关心的首选项`sourceDirs`是否已更改，如果是，我们将新值存储在我们的`PhotoManager`实例中，并启动目录扫描。
- en: Finally, we create `InstanceContent`, create and store a Lookup, and start a
    directory scan to make sure the application is up-to-date with the state of the
    photos on disk.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建`InstanceContent`，创建并存储一个查找，并启动目录扫描以确保应用程序与磁盘上照片的状态保持最新。
- en: 'The `getYears()`, `getMonths()`, and `getPhotos()` methods are largely the
    same, differing only, of course, in the type of data they''re working with, so
    we''ll let `getYears()` serve as an explanation of all three:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`getYears()`、`getMonths()`和`getPhotos()`方法在很大程度上是相同的，只是在处理的数据类型上有所不同，因此我们将`getYears()`作为这三个方法的解释：'
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you are familiar with JDBC, this should not be surprising. We use Java 7's
    `try-with-resources` syntax to declare and instantiate both our `Statement` and
    our `ResultSet` objects. For those not familiar with this construct, it allows
    us to declare certain types of resource, and not have to worry about closing them
    as the system automatically closes them for us once the scope of the `try` terminates.
    The major restriction to be aware of with this, however, is that the class must
    implement `AutoCloseable`; a `Closeable` will not work. The other two `get*` methods
    are logically similar, so they are not shown here.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉JDBC，这应该不会让你感到惊讶。我们使用Java 7的`try-with-resources`语法来声明和实例化我们的`Statement`和`ResultSet`对象。对于那些不熟悉这个结构的人来说，它允许我们声明某些类型的资源，并且不必担心关闭它们，因为系统会在`try`的作用域结束时自动为我们关闭它们。然而，需要注意的是，类必须实现`AutoCloseable`；`Closeable`将不起作用。其他两个`get*`方法在逻辑上是相似的，所以这里没有展示。
- en: 'The last major piece of functionality here is the scanning of source directories,
    which is coordinated by the `scanSourceDirs()` method, given as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最后的主要功能是扫描源目录，这由`scanSourceDirs()`方法协调，如下所示：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To speed the process up a bit, we create Future for each configured source directory,
    which we pass to our `ExecutorService`. We have it configured at a maximum of
    five threads in the pool, which is largely arbitrary. A more sophisticated approach
    might make this configurable, or perhaps, auto-tuned, but this should be sufficient
    for our purposes here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快处理过程，我们为每个配置的源目录创建一个Future，并将其传递给我们的`ExecutorService`。我们在池中将其配置为最多五个线程，这基本上是随意的。一个更复杂的方法可能会使这可配置，或者可能是自动调整的，但这应该足以满足我们的需求。
- en: Once the Futures are created, we iterate over the list, requesting each result.
    If the number of source directories exceeds the size of our thread pool, the excess
    Futures will wait until a Thread becomes available, at which point the `ExecutorService`
    will pick one to run. Once they're all done, the calls to `.get()` will no longer
    block, and the application can continue. Note that we're not blocking the user
    interface to allow this to work, as we pass the bulk of this method as a lambda
    to `RequestProcessor.getDefault().execute()` to request that this run off the
    user interface thread.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了Futures，我们就遍历列表，请求每个结果。如果源目录的数量超过线程池的大小，额外的Futures将等待直到有线程可用，此时`ExecutorService`将选择一个来运行。一旦它们都完成了，对`.get()`的调用将不再阻塞，应用程序可以继续。请注意，我们没有阻塞用户界面以允许这样做，因为我们把大部分这个方法作为lambda传递给`RequestProcessor.getDefault().execute()`，以请求在用户界面线程上运行。
- en: 'When the list of photos has been built and returned, we process those photos
    with this method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当照片列表构建并返回后，我们使用此方法处理这些照片：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `isImageRecorded()` method checks to see if the image path is already in
    the database, returning true if it is. We `filter()` the stream based on the result
    of this test, so `forEach()` only operates on previously unknown images, which
    are then inserted into the database via `insertImage()`. Those two methods look
    like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`isImageRecorded()`方法检查图像路径是否已经在数据库中，如果是，则返回true。我们根据这个测试的结果`filter()`流，所以`forEach()`只对之前未知的图像操作，然后通过`insertImage()`将它们插入到数据库中。这两个方法看起来是这样的：'
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are using `PreparedStatement`, as it is, generally, unwise to create SQL
    statements via concatenation, which can, and often does, lead to SQL injection
    attacks, so we can't use `try-with-resources` fully in the first method, requiring
    us to close the `ResultSet` manually.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`PreparedStatement`，因为通常通过连接创建SQL语句是不明智的，这可能导致，并且经常导致SQL注入攻击，所以我们不能在第一个方法中完全使用`try-with-resources`，这需要我们手动关闭`ResultSet`。
- en: PhotoViewerTopComponent
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PhotoViewerTopComponent
- en: We can now find images, but we still can't tell the system where to look. Before
    turning our attention to handling preferences with the NetBeans platform, though,
    we have one more TopComponent to look at--`PhotoViewerTopComponent`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以找到图像，但我们仍然不知道系统在哪里查找。在将注意力转向使用NetBeans平台处理首选项之前，我们还有一个TopComponent要查看--`PhotoViewerTopComponent`。
- en: 'If you think back to our discussion of the areas provided by the NetBeans window
    system, when we view an image, we want the image to be loaded in the `Editor`
    area. To create a TopComponent for that, we instruct NetBeans to create a new
    `Window` by right-clicking on the desired package, and selecting New | Window:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下我们对NetBeans窗口系统提供的区域进行的讨论，当我们查看图像时，我们希望图像在`Editor`区域加载。为了创建一个TopComponent，我们指示NetBeans通过在所需的包上右键单击并选择“新建
    | 窗口”来创建一个新`Window`：
- en: '![](img/8c47fa0a-0bea-49e4-9902-cb6e79b0524b.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c47fa0a-0bea-49e4-9902-cb6e79b0524b.png)'
- en: 'In the next pane, we specify a class name prefix for our new TopComponent--`PhotoViewer`
    as seen in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个面板中，我们为我们的新TopComponent指定一个类名前缀--如以下截图所示的`PhotoViewer`：
- en: '![](img/2ec6f7a0-b7f3-49f5-b133-e919072c0608.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ec6f7a0-b7f3-49f5-b133-e919072c0608.png)'
- en: NetBeans will now create the files `PhotoViewerTopComponent.java` and `PhotoViewerTopComponent.form`
    just as was discussed earlier. For this TopComponent, though, we need to make
    a couple of changes. When we open the `Window`, we need to specify an image for
    it to load, so we need to provide a constructor that takes the path to the image.
    However, TopComponents must have a no-argument constructor, so we leave it but
    have it call our new constructor with an empty image path.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans现在将创建`PhotoViewerTopComponent.java`和`PhotoViewerTopComponent.form`文件，正如之前讨论的那样。然而，对于这个TopComponent，我们需要做一些更改。当我们打开`Window`时，我们需要指定一个图像让它加载，因此我们需要提供一个接受图像路径的构造函数。但是，TopComponents必须有一个无参构造函数，所以我们保留它，但让它调用我们的新构造函数，并使用空图像路径。
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'While it may seem like a lot, the steps here are simple: we save the photo
    path in an instance variable, we create a `File` instance from it to get the file
    name more easily, add the photo path to TopComponent''s Lookup (which is how we
    find the TopComponent for a given photo), change the layout, and then initialize
    the window.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然步骤看起来可能很多，但这些步骤很简单：我们将照片路径保存在一个实例变量中，我们从中创建一个`File`实例以更容易地获取文件名，将照片路径添加到TopComponent的Lookup（这是我们找到给定照片的TopComponent的方式），更改布局，然后初始化窗口。
- en: Integrating JavaFX with the NetBeans RCP
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JavaFX与NetBeans RCP集成
- en: The `init()` method is interesting, though, in that we're going to do something
    slightly different; we're going to use JavaFX to view the image. There's no reason
    we couldn't use Swing like we are in our other TopComponent, but this gives us
    a good opportunity to demonstrate both how to integrate JavaFX and Swing, as well
    as JavaFX and the NetBeans platform.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`init()`方法很有趣，因为我们将要做一些稍微不同的事情；我们将使用JavaFX来查看图片。我们没有理由不能像我们在其他TopComponent中那样使用Swing，但这也为我们提供了一个很好的机会来展示如何集成JavaFX和Swing，以及JavaFX和NetBeans平台。
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`JFXPanel` is a Swing component that is used to embed JavaFX into Swing. Our
    Window''s layout is `BorderLayout`, so we add our `JFXPanel` to it in the `CENTER`
    area, and let it expand to fill the `Window`. Any complex layout of the JavaFX
    components will be handled by yet another container inside our `JFXPanel`. Our
    user interface, though, is fairly simple. As with our earlier JavaFX systems,
    we define our user interface via FXML as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`JFXPanel`是一个用于将JavaFX嵌入Swing的Swing组件。我们的窗口布局是`BorderLayout`，所以我们将其添加到`CENTER`区域，并让它填充整个`Window`。JavaFX组件的任何复杂布局都将由我们`JFXPanel`内的另一个容器处理。然而，我们的用户界面相当简单。就像我们之前的JavaFX系统一样，我们通过以下方式定义我们的用户界面：'
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since FXML needs a root element, we specify a `BorderLayout`, which, as discussed,
    gives us a `BorderLayout` in a `JFXPanel` in a `BorderLayout`. That may sound
    really odd, but that''s how embedding JavaFX works. Note also that we still specify
    a controller. In that controller, our `initialize()` method looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于FXML需要一个根元素，我们指定了一个`BorderLayout`，正如讨论的那样，这在我们位于`BorderLayout`中的`JFXPanel`中提供了一个`BorderLayout`。这听起来可能真的很奇怪，但这就是嵌入JavaFX的方式。注意，我们仍然指定了一个控制器。在这个控制器中，我们的`initialize()`方法看起来是这样的：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this last method, all we're doing is binding the width and height properties
    to those of the border pane. We've also set `preserveRatio` to `True` in the FXML,
    so the image won't be distorted. This will be important as we rotate the image
    next.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的方法中，我们只是在将宽度和高度属性绑定到边框面板的属性上。我们还在FXML中将`preserveRatio`设置为`True`，所以图片不会变形。当我们接下来旋转图片时，这将非常重要。
- en: 'We haven''t seen the code for rotation, so let''s look at that now. We''ll
    start by adding a button as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到旋转的代码，所以现在让我们看看。我们将首先添加一个按钮，如下所示：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To the `top` section of `BorderPane`, we add `ButtonBar`, to which we add a
    single `SplitMenuButton`. That gives us a button like the one to the right. In
    its non-focused state, it looks like a normal button. When the user clicks on
    the arrow, the menu, as seen here, is presented to the user, offering the ability
    to rotate the image in the directions listed:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`ButtonBar`添加到`BorderPane`的`top`部分，然后向其中添加一个单独的`SplitMenuButton`。这给了我们一个像右边那样的按钮。在其非聚焦状态下，它看起来像一个正常的按钮。当用户点击箭头时，就像这里看到的那样，菜单会呈现给用户，提供旋转图片在列出的方向上的能力：
- en: '![](img/56cf767c-e5e9-404e-ab9d-6dc972baa744.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56cf767c-e5e9-404e-ab9d-6dc972baa744.png)'
- en: 'We''ve tied those MenuItems to the appropriate methods in the controller in
    our FXML definition:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将那些菜单项绑定到我们的FXML定义中控制器的相应方法：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using the APIs provided by the JavaFX `ImageView`, we set the image rotation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaFX `ImageView`提供的API，我们设置了图片的旋转。
- en: We can find images, view them, and rotate them, but we still can't tell the
    system where to look for those images. It's time to fix that.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找到图片，查看它们，并旋转它们，但我们仍然无法告诉系统在哪里寻找这些图片。是时候解决这个问题了。
- en: NetBeans preferences and the Options panel
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NetBeans首选项和选项面板
- en: 'The key to managing preferences is two-fold: `NbPreferences` and the Options
    panel. `NbPreferences` is the means by which preferences are stored and loaded,
    and the options panel is the means by which the user is presented with a user
    interface for editing those preferences. We''ll start by looking at how to add
    an Options panel, which will lead naturally to the `NbPreferences` discussion.
    Next is the NetBeans Options window:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 管理首选项的关键有两点：`NbPreferences`和选项面板。`NbPreferences`是存储和加载首选项的手段，而选项面板是向用户提供编辑这些首选项的用户界面的手段。我们将首先查看如何添加选项面板，这将自然地引出对`NbPreferences`的讨论。接下来是NetBeans选项窗口：
- en: '![](img/b108fe68-8693-4927-8069-83f284306812.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b108fe68-8693-4927-8069-83f284306812.png)'
- en: 'In the preceding window, we can see the two types of Options panel--primary
    and secondary. A primary Options panel is represented by icons across the top:
    General, Editor, Fonts & Colors, and so on. A secondary Options panel is a tab
    like we see in the middle section: Diff, Files, Output, and Terminal. When adding
    an Options panel, you must choose either primary or secondary. We''d like to add
    a new primary panel, as it will separate our preferences from the rest of the
    panels visually as well as giving us an opportunity to create both types of panel.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的窗口中，我们可以看到两种类型的选项面板——主选项面板和二级选项面板。主选项面板由顶部的图标表示：常规、编辑器、字体和颜色等。二级选项面板类似于我们在中间部分看到的标签：差异、文件、输出和终端。当添加选项面板时，您必须选择主选项面板或二级选项面板。我们希望添加一个新的主选项面板，因为它不仅可以从视觉上区分我们的首选项与其他面板，还给我们一个机会创建两种类型的面板。
- en: Adding a primary panel
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加主面板
- en: 'To create a primary Options panel, right-click on the desired package or the
    project node, and click on New | Options Panel. If Options Panel is not visible,
    select New | Other | Module Development | Options Panel. Next, select Create Primary
    Panel:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个主选项面板，在所需的包或项目节点上右键单击，然后点击新建 | 选项面板。如果选项面板不可见，请选择新建 | 其他 | 模块开发 | 选项面板。接下来，选择创建主面板：
- en: '![](img/6518b75c-104d-4656-be9a-7e14daa5c644.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6518b75c-104d-4656-be9a-7e14daa5c644.png)'
- en: We must specify a label, which is the text we'll see under the icon. We must
    also select an icon. The system will let you select something other than a 32x32
    image, but if it's not the right size, it will look strange in the user interface;
    so, choose carefully. The system will also require you to enter keywords, which
    will be used if the user applies a filter to the Options window. Finally, select
    Allow Secondary Panels. The primary panel doesn't have any real content and serves
    only to display secondary panels, which we'll create shortly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须指定一个标签，这是我们将在图标下看到的文本。我们还必须选择一个图标。系统将允许您选择除32x32图像之外的内容，但如果它的大小不正确，它将在用户界面中看起来很奇怪；因此，请仔细选择。系统还将要求您输入关键词，如果用户在选项窗口中应用过滤器，将使用这些关键词。最后，选择允许二级面板。主面板没有任何实际内容，仅用于显示我们即将创建的二级面板。
- en: 'When you click on Next, you will be asked for the class prefix and package:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击下一步时，您将被要求输入类前缀和包：
- en: '![](img/749d7480-78b1-447e-b2ee-d47db788dd16.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/749d7480-78b1-447e-b2ee-d47db788dd16.png)'
- en: 'When you click on Finish, NetBeans will create this single file, `package-info.java`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击完成时，NetBeans将创建此单个文件，`package-info.java`：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Adding a secondary panel
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加二级面板
- en: 'With the primary panel defined, we''re ready to create the secondary panel,
    which will do our work. We right-click on the package again, and select New |
    Options Panel, this time selecting Create Secondary Panel:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了主选项面板后，我们准备创建二级面板，它将执行我们的工作。我们再次在包上右键单击，并选择新建 | 选项面板，这次选择创建二级面板：
- en: '![](img/114cafff-12a4-467e-847e-93e147c93cd1.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/114cafff-12a4-467e-847e-93e147c93cd1.png)'
- en: Since we've defined our own primary panel, we can select that as our parent,
    and we set the title and keywords as we did before. Click on Next, select and/or
    verify the class prefix and package, then click on Finish. This will create three
    artifacts--`SourceDirectoriesOptionPanelController.java`, `SourceDirectoriesPanel.java`,
    and `SourceDirectoriesPanel.form`, and NetBeans will present you with the GUI
    editor for your panel.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经定义了自己的主选项面板，我们可以选择它作为父面板，并设置标题和关键词，就像之前做的那样。点击下一步，选择并/或验证类前缀和包，然后点击完成。这将创建三个工件——`SourceDirectoriesOptionPanelController.java`、`SourceDirectoriesPanel.java`和`SourceDirectoriesPanel.form`，NetBeans将向您展示您的面板的GUI编辑器。
- en: 'We want to add four elements to our panel--a label, a list view, and two buttons.
    We add those by dragging them from the palette on the right, and arranging them
    in the form as shown next:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在面板中添加四个元素——一个标签、一个列表视图和两个按钮。我们通过从右侧的调色板拖动它们并将它们按照下面的形式排列来实现这一点：
- en: '![](img/cd85e87d-c291-4bb6-99da-9d4e8e943446.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd85e87d-c291-4bb6-99da-9d4e8e943446.png)'
- en: 'To make working with these user interface elements more meaningful, we need
    to set the variable names. We also need to set the text of the user interface
    so that each element is meaningful for the user. We can do both by right-clicking
    on each element, as shown in this screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使与这些用户界面元素一起工作更有意义，我们需要设置变量名。我们还需要设置用户界面的文本，以便每个元素对用户都有意义。我们可以通过在每个元素上右键单击来实现这两点，如以下截图所示：
- en: '![](img/7df36ce5-86ec-4fe6-a815-9d54afd9a885.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7df36ce5-86ec-4fe6-a815-9d54afd9a885.png)'
- en: 'In the preceding screen, we can see the three items of interest--Edit Text,
    Change Variable Name..., and Events | Action | actionPeformed [buttonAddActionPerformed].
    For our buttons, we need to use all three, so we set the text to `Add` (or `Remove`),
    change the variable name to `buttonAdd`/`buttonRemove`, and select `actionPerformed`.
    Back in our Java source, we see a method created for us, which we need to fill
    out:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕中，我们可以看到三个感兴趣的项目——编辑文本、更改变量名...和事件 | 操作 | actionPeformed [buttonAddActionPerformed]。对于我们的按钮，我们需要使用所有三个，所以我们设置文本为`添加`（或`删除`），更改变量名为`buttonAdd`/`buttonRemove`，并选择`actionPerformed`。回到我们的Java源代码中，我们看到为我们创建了一个方法，我们需要填写它：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have quite a bit going on here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行中：
- en: We start by retrieving the `lastDir` preference value. If set, we'll use this
    as the starting point for selecting the directories to add. Typically, at least
    in my experience, the directories of interest are, usually, pretty close to one
    another in the filesystem, so we use this preference to save the user some clicks.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检索`lastDir`首选项值。如果已设置，我们将使用它作为选择要添加的目录的起点。通常，至少在我的经验中，感兴趣的目录在文件系统中通常彼此很近，所以我们使用这个首选项来节省用户一些点击。
- en: Next we create `JFileChooser`, which is the Swing class that will allow us to
    choose the directory.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们创建`JFileChooser`，这是Swing类，它将允许我们选择目录。
- en: If `lastDir` is not null, we pass it to `setCurrentDirectory()`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`lastDir`不为空，我们将其传递给`setCurrentDirectory()`。
- en: We set the title of the dialog to something meaningful.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将对话框的标题设置为有意义的名称。
- en: We specify that the dialog should only let us choose directories.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定对话框应只允许我们选择目录。
- en: Finally, we disable the Select All file filter option.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们禁用“全选”文件过滤器选项。
- en: We call `chooser.showOpenDialog()` to present the dialog to the user, and wait
    for it close.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`chooser.showOpenDialog()`向用户展示对话框，并等待其关闭。
- en: If the return code from the dialog is `APPROVE_OPTION`, we need to add the chosen
    directory to our model.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对话框的返回代码是`APPROVE_OPTION`，我们需要将所选目录添加到我们的模型中。
- en: We get the canonical path for the selected file.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取所选文件的规范路径。
- en: We call `ensureModel()`, which we'll look at in a moment, to get the model for
    our `ListView`, then add this new path to it.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`ensureModel()`，稍后我们将对其进行探讨，以获取我们的`ListView`模型，然后向其中添加这个新路径。
- en: Finally, we store the chosen path as `lastDir` in our preferences to set the
    starting directory as discussed earlier.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所选路径作为`lastDir`存储到我们的首选项中，以设置之前讨论的起始目录。
- en: 'The action for the Remove button is much simpler, and is as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除按钮的动作要简单得多，如下所示：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When we are removing items from the model, we remove them by the item index.
    However, when we remove an item, the index numbers for anything after that change.
    What we do here, then, is create a List of the selected indices, sort it to make
    sure it's in the right order (which is possibly excessive here, but it's a relatively
    inexpensive operation, and makes the next operation safer), then we reverse the
    order of the List. With our indices now in descending order, we can iterate over
    the List, removing each index from our model.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从模型中删除项目时，我们通过项目索引来删除它们。然而，当我们删除一个项目时，之后任何内容的索引号都会改变。因此，我们在这里创建一个包含所选索引的列表，对其进行排序以确保它处于正确的顺序（这里可能有些过度，但这是一个相对低成本的运算，并且使下一个操作更安全），然后我们反转列表的顺序。现在我们的索引现在是降序的，我们可以遍历列表，从我们的模型中删除每个索引。
- en: 'We''ve used `ensureModel()` a couple of times now, so let''s see what that
    looks like:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`ensureModel()`几次了，所以让我们看看它的样子：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It's important that we treat the model as `DefaultListModel` rather than the
    `ListModel` type that `ListView` expects, as the latter does not expose any methods
    for mutating the contents of the model, whereas the former does. By dealing with
    `DefaultListModel`, we can add and remove items as needed, as we've done here.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是我们以`DefaultListModel`而不是`ListView`期望的`ListModel`类型来处理模型，因为后者不公开任何用于修改模型内容的方法，而前者则公开。通过处理`DefaultListModel`，我们可以根据需要添加和删除项目，就像我们在这里所做的那样。
- en: Loading and saving preferences
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和保存首选项
- en: 'There are two more methods we need to look at in this class, the ones that
    load and store the options represented in the panel. We''ll start with `load()`,
    which is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们还需要查看另外两个方法，即加载和存储面板中表示的选项。我们将从`load()`开始，如下所示：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`NbPreferences` does not support storing a list of strings, so, as we''ll see
    below, we store the list of source directories as a semicolon-delimited list of
    strings. Here, we load the value of `sourceDirs`, and, if not null, we split on
    the semicolon, and add each entry to our `DefaultListModel`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`NbPreferences`不支持存储字符串列表，因此，正如我们下面将要看到的，我们将源目录列表存储为一个分号分隔的字符串列表。在这里，我们加载`sourceDirs`的值，如果它不为null，我们就用分号分割它，并将每个条目添加到我们的`DefaultListModel`中。'
- en: 'Saving the source directories is also fairly straightforward:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 保存源目录也是相当直接的：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We iterate over `ListModel`, adding each directory to a local `HashSet` instance,
    which helps us remove any duplicate directories. If `Set` is not empty, we use
    `String.join()` to create our delimited list, and `put()` it into our preferences
    store. If it is empty, we remove the preference entry from the store to clear
    out any old data that may have been persisted earlier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历`ListModel`，将每个目录添加到本地的`HashSet`实例中，这有助于我们删除任何重复的目录。如果`Set`不为空，我们使用`String.join()`创建我们的分隔列表，并将其`put()`到我们的首选项存储中。如果它是空的，我们就从存储中删除首选项条目以清除可能之前持久化的任何旧数据。
- en: Reacting to changes in preferences
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对首选项更改做出反应
- en: 'Now that we can persist changes, we need to make the application react to the
    changes. Fortunately, the NetBeans RCP provides a neat, decoupled way to handle
    that. We need not explicitly call a method from our code here. We can attach a
    listener at the point in the system where we''re interested in the change. We''ve
    already seen this code back in `PhotoManagerImpl`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够持久化更改，我们需要让应用程序对更改做出反应。幸运的是，NetBeans RCP提供了一个整洁的解耦方式来处理这个问题。我们在这里不需要显式地调用代码中的方法。我们可以在系统中我们感兴趣更改的点附加一个监听器。我们已经在`PhotoManagerImpl`中看到了这段代码：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When we save any preference for the `PhotoManager` module, this listener is
    called. We simply check to make sure it's for a key that we're interested in,
    and act accordingly, which, as we've seen, involves restarting the source directory
    scanning process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为`PhotoManager`模块保存任何首选项时，这个监听器就会被调用。我们只是简单地检查确保它是对我们感兴趣的关键，然后相应地采取行动，正如我们所看到的，这涉及到重新启动源目录扫描过程。
- en: 'Once new data has been loaded, how do we make the user interface reflect that
    change? Do we have to update the user interface manually? Again, thanks to the
    RCP, the answer is no. We''ve seen the first half at the end of `scanSourceDirs()`,
    which is this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新数据被加载，我们如何让用户界面反映这个变化？我们是否必须手动更新用户界面？再次感谢RCP，答案是肯定的。我们在`scanSourceDirs()`的末尾看到了第一部分，如下所示：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'NetBeans has a number of cookie classes for indicating that certain actions
    should take place. While we don''t share the class hierarchy (due to the unfortunate
    dependency on the Nodes API), we do share the same nomenclature with the hope
    of stealing, so to speak, a bit of the familiarity. So what does `ReloadCookie`
    look like? There''s not much to it; it is given like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans提供了一些cookie类来指示某些动作应该发生。虽然我们不共享类层次结构（由于不幸依赖于Nodes API），但我们确实共享相同的命名约定，以便可以说“借鉴”一点熟悉感。那么`ReloadCookie`看起来是什么样子呢？它并不复杂；它看起来是这样的：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In our case, we just have an empty class. We don''t intend for this to be used
    elsewhere, so we don''t need to encode any functionality in the class. We will
    just be using this as an indicator, as we see in the constructor of `RootNode`,
    which is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只有一个空类。我们并不打算在其他地方使用它，所以我们不需要在类中编码任何功能。我们只是将其用作指示器，正如我们在`RootNode`的构造函数中看到的那样，如下所示：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Lookup.Template` is used to define the pattern by which the system can filter
    our `Lookup` requests. Using our template, we create a `Lookup.Result` object,
    `reloadResult`, and add a listener to it via a lambda. The lambda creates a new
    set of children using `Children.create()` and the `YearChildFactory` we looked
    at earlier, and passes those to `setChildren()` to update the user interface.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lookup.Template` 用于定义系统可以过滤我们的 `Lookup` 请求的模式。使用我们的模板，我们创建了一个 `Lookup.Result`
    对象，`reloadResult`，并通过 lambda 表达式添加一个监听器。lambda 表达式使用 `Children.create()` 和之前查看过的
    `YearChildFactory` 创建一组新的子节点，并将它们传递给 `setChildren()` 以更新用户界面。'
- en: That may seem like a fair bit of code just to update the user interface when
    a preference is changed, but the decoupling is certainly worth it. Imagine a more
    complicated application or a dependent module tree. Using this listener approach,
    we need not expose methods, or even classes, to the outside world, allowing our
    internal code to be modified without breaking client code. That is, in short,
    one of the primary reasons for decoupled code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来为了在预设改变时更新用户界面而需要编写相当多的代码，但解耦的好处无疑是值得的。想象一个更复杂的应用或一个依赖的模块树。使用这种监听器方法，我们不需要向外界暴露方法，甚至不需要暴露类，这样我们的内部代码就可以在不破坏客户端代码的情况下进行修改。简而言之，这就是解耦代码的一个主要原因。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Once again, we've come to the end of another application. You learned how to
    bootstrap a Maven-based NetBeans Rich Client Platform application. You learned
    about RCP modules, and how to include those modules in our application build.
    You also learned the basics of the NetBeans RCP Node API, how to create our own
    nodes, and how to nest child nodes. We explained how to use the NetBeans Preferences
    API, including creating new Options panels for editing preferences, how to load
    and store them, and how to react to changes in preferences.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们又完成了一个应用的开发。你学习了如何启动基于 Maven 的 NetBeans 富客户端平台应用。你了解了 RCP 模块，以及如何在我们的应用构建中包含这些模块。你还学习了
    NetBeans RCP 节点 API 的基础知识，如何创建我们自己的节点，以及如何嵌套子节点。我们解释了如何使用 NetBeans 预设 API，包括创建新的选项面板来编辑预设，如何加载和存储它们，以及如何对预设的变化做出反应。
- en: One final word on the NetBeans RCP--While we have built a respectable application
    here, we have in no way pushed the limits of the RCP. I have attempted to cover
    just enough of the platform to get you going, but you will almost certainly need
    to learn more if you are to continue using the platform. While the official documentation
    is helpful, the go-to source for comprehensive coverage is *NetBeans Platform
    for Beginners* by Jason Wexbridge and Walter Nyland ([https://leanpub.com/nbp4beginners](https://leanpub.com/nbp4beginners)).
    It's a great book, and I highly recommend it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于 NetBeans RCP 的一点——虽然我们在这里构建了一个令人尊重的应用，但我们并没有完全发挥 RCP 的潜力。我试图涵盖足够多的平台内容以帮助你开始，但如果你要继续使用这个平台，你几乎肯定需要学习更多。虽然官方文档很有帮助，但全面覆盖的入门指南是
    Jason Wexbridge 和 Walter Nyland 所著的《NetBeans 平台入门》（[https://leanpub.com/nbp4beginners](https://leanpub.com/nbp4beginners)）。这是一本很好的书，我强烈推荐它。
- en: In the next chapter, we're going to dip our toes into the waters of client/server
    programming, and implement our own note-taking application. It won't be as robust
    and full-featured as the competitors already in the market, but we'll make good
    headway in that direction and, hopefully, learn a lot along the way.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将尝试涉足客户端/服务器编程的领域，并实现我们自己的记事应用。它可能不会像市场上已有的竞争对手那样功能强大和全面，但我们将在这个方向上取得良好的进展，并且有望在过程中学到很多。
