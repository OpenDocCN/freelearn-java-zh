- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Garbage Collection and Memory Profiling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收与内存分析
- en: In the intricate dance of **Java Virtual Machine** (**JVM**) internals, where
    bytecode is compiled and programs are executed within the confines of register
    memory, an indispensable aspect emerges the artful orchestration of memory resources.
    After traversing the realms of bytecode compilation and program execution, it
    is paramount to delve into the nuanced domain of memory management within the
    JVM. This chapter embarks on a comprehensive exploration of **garbage collectors**
    (**GCs**), unraveling the intricate tapestry governing Java programs’ sustenance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java虚拟机（JVM）内部的复杂舞蹈中，其中字节码被编译，程序在寄存器内存的范围内执行，一个不可或缺的方面是内存资源的巧妙编排艺术。在穿越字节码编译和程序执行的领域之后，深入JVM内存管理的微妙领域变得至关重要。本章将全面探索垃圾收集器（GC），揭示管理Java程序生存的复杂织锦。
- en: Our journey through the inner workings of the JVM reaches a crucial juncture
    as we unravel the mysteries of memory allocation, heap structures, and the ever-pivotal
    garbage collection mechanisms. By comprehending the nuances of memory management,
    including distinctions between heap and stack, and mastering the intricacies of
    garbage collection, you will enhance your understanding of JVM internals and acquire
    the skills to wield precise control over memory usage. Join us as we navigate
    the intricate terrain of GCs, unlocking the keys to optimizing memory efficiency
    in Java applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对JVM内部运作的旅程达到一个关键转折点，当我们揭开内存分配、堆结构和至关重要的垃圾收集机制的奥秘。通过理解内存管理的微妙之处，包括堆和栈之间的区别，并掌握垃圾收集的复杂性，你将增强对JVM内部的理解，并获得精确控制内存使用的技能。加入我们，我们将导航GC的复杂地形，解锁优化Java应用程序内存效率的钥匙。
- en: 'In this chapter, we’ll explore the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: GC overview
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收概述
- en: JVM tuning and ergonomics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM调优与人体工程学
- en: GC overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收概述
- en: In the intricate landscape of JVM internals, the GC role stands as a critical
    component, influencing the efficiency and reliability of Java applications. Our
    exploration delves into the fundamental concept of garbage collection and its
    pivotal role in managing memory within the JVM.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM内部的复杂景观中，GC的作用作为一个关键组件，影响着Java应用程序的效率和可靠性。我们的探索深入到垃圾收集的基本概念及其在JVM内存管理中的关键作用。
- en: At its core, the purpose of the GC is to automatically reclaim memory occupied
    by objects no longer in use by the program. In languages such as Java, which employ
    automatic memory management, developers are spared the burden of explicitly deallocating
    memory, enhancing productivity and reducing the likelihood of memory-related errors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: GC的核心目的是自动回收程序不再使用的对象所占据的内存。在像Java这样的采用自动内存管理的语言中，开发者免去了显式释放内存的负担，提高了生产效率并减少了内存相关错误的可能性。
- en: Imagine a scenario where each dynamically allocated object had to be manually
    deallocated by the programmer. Not only does this introduce a considerable cognitive
    load, but it also opens the door to memory leaks and inefficiencies. In the absence
    of a GC, the responsibility of memory management falls entirely on the developer’s
    shoulders, increasing the likelihood of bugs and hindering the development process.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样一个场景：每个动态分配的对象都必须由程序员手动释放。这不仅引入了相当大的认知负担，而且还为内存泄漏和低效打开了大门。在没有GC的情况下，内存管理的责任完全落在开发者的肩上，增加了出现错误的可能性并阻碍了开发过程。
- en: Java, with its *Write Once, Run Anywhere* philosophy, utilizes garbage collection
    to provide a seamless and robust memory management system. The JVM’s GC identifies
    and reclaims unreachable objects, preventing memory leaks and ensuring optimal
    resource utilization. The Java approach allows developers to focus on application
    logic rather than micromanaging memory, contributing to the language’s popularity
    in enterprise-level applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java以其“一次编写，到处运行”的哲学，利用垃圾回收提供无缝且健壮的内存管理系统。JVM的GC识别并回收不可达的对象，防止内存泄漏并确保最佳资源利用。Java的方法允许开发者专注于应用程序逻辑，而不是微观管理内存，这有助于该语言在企业级应用中的普及。
- en: While Java champions automatic memory management through its GC, other programming
    languages have embraced various memory management strategies. For instance, languages
    such as C and C++ frequently depend on manual memory management, granting developers
    explicit control but also leaving them susceptible to potential pitfalls. Conversely,
    languages such as Python and C# implement their own garbage collection mechanisms,
    each meticulously crafted to address the unique requirements of their respective
    languages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java通过其GC推崇自动内存管理，但其他编程语言已经采用了各种内存管理策略。例如，C和C++等语言通常依赖于手动内存管理，这赋予开发者显式控制权，但也使他们容易受到潜在陷阱的影响。相反，Python和C#等语言实现了自己的垃圾回收机制，每个机制都精心设计以解决各自语言独特的需求。
- en: Even among languages with garbage collection, the implementations can differ
    significantly. Java’s GC is known for its generational approach, dividing the
    heap into different generations (young and old) and applying different collection
    algorithms to each. Within the JVM itself, multiple GCs exist, each with its strategies
    and trade-offs. This contrasts with, for instance, Python’s reference counting
    mechanism or the GCs used in languages such as Go or C#.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在具有垃圾回收机制的语言中，实现方式也可能存在显著差异。Java的GC以其代际方法而闻名，将堆分为不同的代（年轻代和旧代）并对每一代应用不同的收集算法。在JVM内部，存在多个GC，每个都有其策略和权衡。这与例如Python的引用计数机制或Go或C#等语言中使用的GC形成对比。
- en: Memory leaks often result from programming errors, such as failing to release
    dynamically allocated memory or inadvertently maintaining references to objects
    beyond their useful lifespan. Common scenarios include neglecting to free memory
    in languages that require manual memory management, such as C or C++, or unintentionally
    creating circular references in languages with automatic memory management, such
    as Java.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏通常源于编程错误，例如未能释放动态分配的内存或无意中维持对象在其有用生命周期之后的引用。常见场景包括在需要手动内存管理的语言（如C或C++）中忘记释放内存，或在具有自动内存管理的语言（如Java）中无意创建循环引用。
- en: The GC plays a pivotal role in mitigating the risk of memory leaks in languages
    that employ automatic memory management. Its primary function is to identify and
    reclaim memory occupied by objects no longer reachable or in use by the program.
    By automating the memory deallocation process, the GC significantly reduces the
    likelihood of memory leaks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GC在减轻采用自动内存管理语言中的内存泄漏风险方面发挥着关键作用。其主要功能是识别并回收程序不再可达或使用的对象占用的内存。通过自动化内存释放过程，GC显著降低了内存泄漏的可能性。
- en: 'In automatic memory management, the GC acts as a vigilant defender, crucially
    mitigating the risk of memory leaks. Automating the identification and reclamation
    of unused memory in languages such as Java streamlines the development process
    and enhances system stability. With a generational approach that swiftly handles
    short-lived objects and smart memory management adapting to dynamic applications,
    the GC stands as a pivotal chapter in fortifying software integrity against the
    subtle menace of memory leaks:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动内存管理中，GC充当一名警觉的防御者，关键地减轻了内存泄漏的风险。在Java等语言中自动化识别和回收未使用内存简化了开发过程并增强了系统稳定性。通过代际方法快速处理短生命周期对象和智能内存管理适应动态应用程序，GC成为加强软件完整性对抗内存泄漏微妙威胁的关键章节：
- en: '**Automated memory management**: In languages such as Java, where automatic
    memory management is integral, the GC regularly scans the heap to identify objects
    with no reachable references. Once identified, these unreferenced objects are
    marked for collection and deallocated, freeing up memory for new allocations.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动内存管理**：在Java等自动内存管理至关重要的语言中，GC定期扫描堆以识别没有可达引用的对象。一旦识别，这些无引用对象就会被标记为收集并释放，为新分配腾出内存。'
- en: '**Generational approach**: Java’s GC often employs a generational approach,
    categorizing objects into different generations based on their age. Younger objects,
    which are more likely to become unreachable quickly, are collected more frequently,
    while older objects undergo less frequent, more comprehensive garbage collection.
    It helps quickly identify and collect short-lived objects, reducing the chances
    of memory leaks.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代际方法**：Java的GC通常采用代际方法，根据对象的年龄将对象分类到不同的代。年轻对象，它们很快就会变得不可达，被收集得更频繁，而旧对象则经历较少、更全面的垃圾回收。这有助于快速识别和收集短生命周期对象，减少内存泄漏的可能性。'
- en: '**Smart memory management**: Modern GCs are designed to be intelligent and
    adaptive. They utilize algorithms and heuristics to optimize memory management
    based on the application’s behavior. This adaptability ensures efficient garbage
    collection and minimizes the risk of memory leaks, even in complex and dynamic
    applications.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能内存管理**：现代GC被设计成智能和自适应的。它们利用算法和启发式方法根据应用程序的行为优化内存管理。这种适应性确保了高效的垃圾回收，并最小化了内存泄漏的风险，即使在复杂和动态的应用程序中也是如此。'
- en: 'Within the intricate tapestry of JVM internals, the *Mark and Sweep* GC algorithm
    emerges as a cornerstone in managing memory efficiently. This fundamental process
    operates in two key phases: the mark phase, where the GC discerns the utilization
    status of memory, marking objects as either reachable or unreachable, and the
    subsequent sweep phase, where the collector liberates the heap by reclaiming memory
    occupied by objects marked as unreachable. The advantages of this approach are
    profound, offering automatic memory management, mitigating dangling pointer issues,
    and significantly contributing to memory leak management, as the following diagram
    shows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM内部的复杂结构中，*标记-清除*垃圾回收（GC）算法成为管理内存效率的基石。这个基本过程分为两个关键阶段：标记阶段，其中GC确定内存的使用状态，将对象标记为可达或不可达，以及随后的清除阶段，其中收集器通过回收被标记为不可达的对象所占用的内存来释放堆空间。这种方法的优势是深远的，提供了自动内存管理，减轻了悬垂指针问题，并且对内存泄漏管理做出了重大贡献，如下面的图所示：
- en: '![Figure 6.1: Mark and Sweep steps of the GC](img/B22030_06_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：GC的标记-清除步骤](img/B22030_06_01.jpg)'
- en: 'Figure 6.1: Mark and Sweep steps of the GC'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：GC的标记-清除步骤
- en: As we delve into the nuances of Mark and Sweep, we navigate the benefits and
    challenges inherent in this automatic memory management paradigm. While it liberates
    developers from the intricacies of manual memory handling, it introduces considerations
    such as increased CPU power consumption and relinquishing control over object
    cleanup scheduling. Join us on this exploration into the heart of JVM internals,
    where the Mark and Sweep algorithm plays a pivotal role in shaping the reliability
    and efficiency of Java applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究标记-清除的细微差别时，我们探讨了这种自动内存管理范式固有的优势和挑战。虽然它使开发者免于手动内存处理的复杂性，但它引入了诸如增加CPU功耗和放弃对象清理调度控制等考虑因素。加入我们探索JVM内部的精髓，在那里，标记-清除算法在塑造Java应用程序的可靠性和效率方面发挥着关键作用。
- en: 'In our exploration, we’ve uncovered the automatic process of Mark and Sweep:
    its ability to effortlessly handle memory allocation and deallocation, its role
    in mitigating dangling pointers, and its significant contribution to managing
    memory leaks.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的探索中，我们发现了标记-清除的自动过程：它能够轻松处理内存分配和释放，它在减轻悬垂指针方面的作用，以及它在管理内存泄漏方面的重大贡献。
- en: However, no architectural marvel comes without its trade-offs. In the case of
    Mark and Sweep, a prominent consideration emerges in the form of memory fragmentation.
    As we unravel this aspect, we delve into the intricacies of how the algorithm,
    while adept at reclaiming memory, can leave behind fragmented pockets in the memory
    space. These fragments, akin to scattered puzzle pieces, introduce challenges
    to the efficient allocation of contiguous memory blocks, impacting the overall
    efficiency of the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有哪个建筑奇迹是不需要权衡的。在标记-清除（Mark and Sweep）的情况下，一个突出的考虑因素以内存碎片化的形式出现。当我们揭开这个方面时，我们深入探讨了算法在回收内存方面的熟练程度，但同时也可能在内存空间中留下碎片化的区域。这些碎片，就像散落的拼图碎片一样，给连续内存块的高效分配带来了挑战，从而影响了应用程序的整体效率。
- en: Our narrative thus far has illuminated the delicate balancing act between the
    advantages of automatic memory management and the potential drawbacks, emphasizing
    the need for a nuanced approach. The trade-off between seamless automation and
    the specter of fragmentation prompts developers to weigh the benefits against
    the efficiency requirements of their applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的叙述已经阐明了自动内存管理的优势与潜在缺点之间的微妙平衡，强调了需要一种细致入微的方法。无缝自动化与碎片化幽灵之间的权衡促使开发者权衡其应用程序的效率要求与好处。
- en: Within the intricate realm of JVM internals, the choice of GC can profoundly
    impact the performance of Java applications. **Serial GC**, a simple and single-threaded
    collector, suits applications with modest memory requirements, offering a straightforward
    approach to garbage collection. Conversely, **Parallel GC** steps up for throughput-centric
    scenarios, leveraging multiple threads to expedite garbage collection tasks and
    enhance overall system efficiency. Java’s default collector since version 9, **Garbage-First
    (G1) GC**, strikes a balance between low latency and high throughput, making it
    a versatile choice for various applications. Introducing a new paradigm, the **Z
    GC** (**ZGC**) in Java 11 promises minimal pause times and enhanced scalability,
    catering to the demands of modern, resource-intensive applications. As we embark
    on a journey through the intricacies of each collector, a nuanced understanding
    will empower developers to make informed decisions, optimizing garbage collection
    strategies to align with the specific needs of their Java projects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 内部错综复杂的领域中，GC 的选择可以深刻影响 Java 应用程序的性能。**Serial GC**，一个简单且单线程的收集器，适合对内存要求适中的应用程序，提供了一种直接的垃圾回收方法。相反，**Parallel
    GC** 在吞吐量优先的场景中发挥作用，利用多个线程加速垃圾回收任务，提高整体系统效率。自 Java 9 版本以来，Java 的默认收集器 **Garbage-First
    (G1) GC** 在低延迟和高吞吐量之间取得平衡，成为各种应用程序的多功能选择。Java 11 中引入的新范式 **Z GC**（**ZGC**）承诺最小暂停时间并增强可伸缩性，满足现代资源密集型应用程序的需求。随着我们踏上探索每个收集器复杂性的旅程，细微的理解将赋予开发者做出明智决策的能力，优化垃圾回收策略以符合他们
    Java 项目的特定需求。
- en: Serial GC
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Serial GC
- en: Within the tapestry of JVM internals, Serial GC is a fundamental player in garbage
    collection strategies. We will dissect the essence of Serial GC, a collector distinguished
    by its simplicity and singular-threaded approach to memory management. As we delve
    into the intricacies of its operation, we explore why such a straightforward design
    is essential and the scenarios in which Serial GC shines. Unveiling its advantages
    and limitations, we navigate the landscape to understand the optimal scenarios
    where this minimalist collector becomes a strategic choice for Java developers.
    We will explore Serial GC, where the pursuit of simplicity intertwines with efficiency
    in the orchestration of memory within the JVM.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 内部的织锦中，Serial GC 是垃圾收集策略中的基本参与者。我们将剖析 Serial GC 的本质，这是一个以其简单性和单线程内存管理方法而区别的收集器。随着我们深入其操作的复杂性，我们将探讨为什么这种简单的设计是必要的，以及
    Serial GC 发光的应用场景。揭示其优势和局限性，我们将在理解这种最小化收集器成为 Java 开发者战略选择的最佳场景中导航。我们将探索 Serial
    GC，其中对简单性的追求与 JVM 内部内存编排中的效率交织在一起。
- en: Serial GC is characterized by its sequential, **stop-the-world** approach to
    garbage collection. It halts the application’s execution during the collection
    process, ensuring that no parallel threads interfere with identifying and reclaiming
    unreachable objects. This simplicity allows Serial GC to streamline memory management
    without the complexity of concurrent operations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Serial GC 以其顺序的、**停止世界的**垃圾回收方法为特征。在收集过程中，它暂停应用程序的执行，确保没有并行线程干扰识别和回收不可达对象。这种简单性使得
    Serial GC 能够简化内存管理，无需并发操作的复杂性。
- en: The elegance of Serial GC comes with trade-offs, notably in the realm of throughput
    and responsiveness. Given its single-threaded nature, there may be more efficient
    choices for applications with large heaps or those requiring low pause times.
    Stop-the-world pauses, while brief, can impact the user experience, making Serial
    GC better suited for scenarios where these pauses are acceptable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Serial GC 的优雅之处伴随着权衡，尤其是在吞吐量和响应性方面。鉴于其单线程特性，对于大堆或需要低暂停时间的应用程序，可能存在更有效的选择。虽然停止世界的暂停时间很短，但可能会影响用户体验，使得
    Serial GC 更适合这些暂停可接受的场景。
- en: 'Serial GC seamlessly integrates with the Mark and Sweep algorithm. It identifies
    reachable and unreachable objects during the mark phase, marking them accordingly.
    In the subsequent sweep phase, it clears memory occupied by unreachable objects.
    The sequential nature of Serial GC ensures a straightforward execution of these
    phases, simplifying the coordination between marking and sweeping, as the following
    diagram shows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Serial GC 与标记和清除算法无缝集成。在标记阶段，它识别可达和不可达对象，并相应地进行标记。在随后的清除阶段，它清除不可达对象占用的内存。Serial
    GC 的顺序性质确保了这些阶段的直接执行，简化了标记和清除之间的协调，如下面的图示所示：
- en: '![Figure 6.2: Serial GC working](img/B22030_06_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：Serial GC工作原理](img/B22030_06_02.jpg)'
- en: 'Figure 6.2: Serial GC working'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：Serial GC工作原理
- en: The simplicity of Serial GC shines in scenarios where the memory footprint is
    modest and the application’s performance is not overly sensitive to brief pauses.
    It is well suited for client applications or environments with limited resources,
    where the straightforward, stop-the-world approach aligns seamlessly with the
    system’s demands.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Serial GC的简单性在内存占用适中且应用程序性能对短暂暂停不敏感的场景中表现得尤为出色。它非常适合客户端应用程序或资源有限的环境，其中直接的停止世界方法与系统的需求无缝对接。
- en: 'As we immerse ourselves in the orchestration of memory within the JVM, a crucial
    aspect unfolds through the configuration options tailored for Serial GC. The following
    table presents a harmonious ensemble of commands, each holding the power to influence
    and optimize the behavior of Serial GC. From enabling or disabling the use of
    Serial GC to fine-tuning ratios, sizes, and thresholds, these commands offer a
    conductor’s wand to shape the memory management symphony. Join us in deciphering
    the significance of each command, providing developers and administrators with
    the means to sculpt an optimal performance for their Java applications by adjusting
    the parameters that govern the workings of Serial GC:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们沉浸在JVM内存配置中时，Serial GC的配置选项展现了一个关键方面。以下表格展示了一系列和谐的命令，每个命令都拥有影响和优化Serial GC行为的力量。从启用或禁用Serial
    GC的使用到微调比例、大小和阈值，这些命令提供了一根指挥棒，以塑造内存管理交响乐。加入我们，解读每个命令的意义，为开发人员和管理员提供调整Serial GC工作参数的方法，从而通过调整参数来优化Java应用程序的性能：
- en: '| **Command** | **Description** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-``XX:+UseSerialGC` | Enables the use of Serial GC. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:+UseSerialGC` | 启用Serial GC。|'
- en: '| `-``XX:-UseSerialGC` | Disables Serial GC (default for server-class machines).
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:-UseSerialGC` | 禁用Serial GC（服务器级机器的默认设置）。|'
- en: '| `-``XX:NewRatio=<value>` | Sets the ratio of the young generation to the
    old generation. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:NewRatio=<value>` | 设置年轻代与旧代的比例。|'
- en: '| `-``XX:NewSize=<size>` | Sets the initial size of the young generation. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:NewSize=<size>` | 设置年轻代的初始大小。|'
- en: '| `-``XX:MaxNewSize=<size>` | Sets the maximum size of the young generation.
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:MaxNewSize=<size>` | 设置年轻代的最大大小。|'
- en: '| `-``XX:SurvivorRatio=<value>` | Sets the ratio of Eden space to survivor
    space. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:SurvivorRatio=<value>` | 设置Eden空间与幸存空间的比例。|'
- en: '| `-``XX:MaxTenuringThreshold=<value>` | Sets the maximum tenuring threshold
    for objects in the young generation. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:MaxTenuringThreshold=<value>` | 设置年轻代对象的最大存活阈值。|'
- en: '| `-``XX:TargetSurvivorRatio=<value>` | Sets the desired survivor space size
    as a percentage of the young generation size. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:TargetSurvivorRatio=<value>` | 设置期望的幸存空间大小为年轻代大小的百分比。|'
- en: '| `-``XX:PretenureSizeThreshold=<size>` | Sets the threshold for object allocation
    in the old generation. Objects larger than this size go directly to the old generation.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:PretenureSizeThreshold=<size>` | 设置旧生代对象分配的阈值。大于此大小的对象将直接进入旧生代。|'
- en: '| `-``XX:MaxHeapSize=<size>` | Sets the maximum heap size. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:MaxHeapSize=<size>` | 设置最大堆大小。|'
- en: 'Table 6.1: Serial GC commands'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1：Serial GC命令
- en: These options allow developers and administrators to configure aspects of Serial
    GC, such as the size of the young generation, the ratio of survivor spaces, and
    overall heap size. Adjusting these parameters enables fine-tuning of memory management
    for specific application requirements and hardware characteristics.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项允许开发人员和管理员配置Serial GC的各个方面，如年轻代的大小、幸存空间的比例以及整体堆大小。调整这些参数可以针对特定应用程序的要求和硬件特性进行内存管理的微调。
- en: The harmonious coordination of memory management orchestrated by Serial GC has
    illuminated its advantages, trade-offs, and strategic scenarios in which its singular
    approach excels. As we transition to our next section, the stage is set for a
    parallel performance as we delve into Parallel GC. The evolution from singular
    to parallel threads promises an exploration of efficiency at scale and enhanced
    throughput.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Serial GC协调内存管理的和谐配合，揭示了其优势、权衡以及Serial GC独特方法在特定场景中表现卓越的战略。随着我们过渡到下一节，我们将深入探讨Parallel
    GC，并行线程的演变承诺了对规模效率和吞吐量提升的探索。
- en: Parallel GC
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行GC
- en: As we embark on the next movement in our exploration of JVM internals, the spotlight
    now shifts to Parallel GC. In this section, we dive into the world of parallelism,
    where the efficiency of memory management takes center stage. Parallel GC, with
    its multithreaded prowess, orchestrates a symphony of garbage collection, promising
    enhanced throughput and optimized performance for Java applications. Through a
    nuanced lens, we unravel the complexities of Parallel GC—its characteristics,
    advantages, and scenarios where its parallel threads harmonize seamlessly with
    the demands of large-scale, data-intensive environments. Join us in this section
    as we traverse the parallel rhythms of JVM internals, uncovering parallel threads
    that propel memory management to new heights.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始探索JVM内部的下一部分，聚光灯现在转向了并行GC。在本节中，我们深入到并行性的世界，其中内存管理的效率成为焦点。并行GC凭借其多线程能力，编排了一场垃圾回收的交响乐，为Java应用程序提供了增强的吞吐量和优化的性能。通过细微的视角，我们揭示了并行GC的复杂性——其特征、优点以及其并行线程如何与大规模、数据密集型环境的需求无缝协调的场景。加入我们，在本节中，我们将穿越JVM内部的并行节奏，揭示推动内存管理达到新高度的并行线程。
- en: Parallel GC’s hallmark lies in its multithreaded approach, making it particularly
    adept at handling more enormous heaps and achieving higher throughput compared
    to its single-threaded counterparts. It divides the heap into sections, employing
    parallel threads to perform garbage collection tasks concurrently, resulting in
    faster execution and reduced pause times.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 并行垃圾回收（Parallel GC）的标志是其多线程方法，这使得它在处理更大的堆和与单线程版本相比实现更高的吞吐量方面特别擅长。它将堆划分为部分，使用并行线程同时执行垃圾回收任务，从而实现更快的执行速度和减少的暂停时间。
- en: 'Parallel GC orchestrates a synchronized dance of efficiency within the JVM,
    seamlessly integrating with the Mark and Sweep algorithm. In the intricate garbage
    collection process, Parallel GC leverages the power of multiple threads to execute
    the crucial steps of marking and sweeping concurrently. During the mark phase,
    each thread traverses a designated heap section, identifying and marking objects
    as reachable or unreachable. This simultaneous marking across threads ensures
    a swift and parallel assessment of the memory space. As the mark phase concludes,
    the collective effort of threads harmonizes in the sweep phase, where Parallel
    GC efficiently reclaims memory by discarding unreachable objects identified during
    marking. The parallelism embedded in the Mark and Sweep process under Parallel
    GC optimizes throughput. It showcases the synchronized brilliance of multiple
    threads working in unison to choreograph a performance that elegantly balances
    responsiveness and efficiency in memory management, as the following diagram shows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 并行GC在JVM内部协调了一场高效的同步舞蹈，无缝地与标记和清除算法集成。在复杂的垃圾回收过程中，并行GC利用多线程的力量同时执行标记和清除的关键步骤。在标记阶段，每个线程遍历指定的堆部分，识别并标记对象为可达或不可达。这种跨线程的同步标记确保了对内存空间的快速并行评估。当标记阶段结束时，线程的集体努力在清除阶段和谐地统一，此时并行GC通过丢弃在标记阶段识别出的不可达对象来有效地回收内存。在并行GC下的标记和清除过程中的并行性优化了吞吐量。它展示了多个线程协同工作以编排一场在内存管理中优雅平衡响应性和效率的性能的同步智慧，如下面的图所示：
- en: '![Figure 6.3: Parallel GC working](img/B22030_06_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：并行GC工作原理](img/B22030_06_03.jpg)'
- en: 'Figure 6.3: Parallel GC working'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：并行GC工作原理
- en: While Parallel GC excels in throughput, its reliance on parallelism introduces
    trade-offs, notably in responsiveness. Stop-the-world pauses, while minimized,
    can still impact the application’s responsiveness, making it less suitable for
    scenarios where low latency is paramount. Additionally, the increased CPU usage
    due to parallelism might be a consideration for resource-constrained environments.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并行GC在吞吐量方面表现出色，但其对并行性的依赖引入了权衡，特别是在响应性方面。虽然停止世界的暂停时间已经最小化，但仍可能影响应用程序的响应性，使其在低延迟至关重要的场景中不太适用。此外，由于并行性导致的CPU使用增加，在资源受限的环境中可能需要考虑。
- en: Parallel GC shines brightest in scenarios where large heaps and data-intensive
    applications are the norm. It is well suited for batch processing, scientific
    computing, and scenarios where maximizing throughput is crucial. However, its
    trade-offs make it a strategic choice for applications that can tolerate brief
    pauses in exchange for optimized overall performance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 并行垃圾回收在大型堆和数据密集型应用是常态的场景中最为出色。它非常适合批处理、科学计算以及最大化吞吐量至关重要的场景。然而，它的权衡使其成为可以承受短暂暂停以换取优化整体性能的应用的战略选择。
- en: As we unravel the intricacies of Parallel GC, we explore how its parallel threads
    choreograph a performance that balances the demands of large-scale memory management.
    Join us in this section as we navigate the landscape of parallel garbage collection,
    understanding when its parallel prowess becomes a strategic choice for optimizing
    memory orchestration within the JVM.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们揭开并行垃圾回收的复杂性，我们探索了其并行线程如何编排平衡大规模内存管理需求的表现。加入我们在这个部分，我们将导航并行垃圾回收的景观，了解何时其并行能力成为优化
    JVM 内部内存编排的战略选择。
- en: 'In our exploration of Parallel GC within the intricacies of JVM internals,
    the ability to finely tune its behavior becomes paramount. The following table
    offers a comprehensive ensemble of commands, each a key to unlocking the potential
    of Parallel GC’s efficiency and throughput. From turning its use on or off to
    configuring the number of threads, setting pause-time goals, and employing adaptive
    sizing policies, these options empower developers and administrators to shape
    the orchestration of memory management within the JVM. As we delve into the nuances
    of each command, this ensemble becomes a conductor’s guide, enabling the crafting
    of a performance optimized to meet the unique demands of Java applications. Join
    us in deciphering the significance of these commands, providing a symphony of
    possibilities for molding Parallel GC to harmonize seamlessly with the diverse
    landscapes of JVM environments:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索 JVM 内部细节中的并行垃圾回收时，精细调整其行为变得至关重要。下表提供了一个全面的命令集合，每个命令都是解锁并行垃圾回收效率和吞吐量潜力的关键。从开启或关闭其使用，到配置线程数，设置暂停时间目标，以及采用自适应大小策略，这些选项使开发人员和管理员能够塑造
    JVM 内部的内存管理编排。随着我们深入到每个命令的细微差别，这个集合成为了一位指挥家的指南，使我们能够打造出针对 Java 应用独特需求进行优化的性能。加入我们，解读这些命令的重要性，为塑造与
    JVM 环境多样化的景观无缝融合的并行垃圾回收提供可能性：
- en: '| **Command** | **Description** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| `-``XX:+UseParallelGC` | Enables the use of Parallel GC. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:+UseParallelGC` | 启用并行垃圾回收的使用。 |'
- en: '| `-``XX:-UseParallelGC` | Disables Parallel GC. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:-UseParallelGC` | 禁用并行垃圾回收。 |'
- en: '| `-``XX:ParallelGCThreads=<value>` | Sets the number of threads for garbage
    collection. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ParallelGCThreads=<value>` | 设置垃圾回收的线程数。 |'
- en: '| `-``XX:MaxGCPauseMillis=<value>` | Sets the maximum desired pause-time goal
    for garbage collection. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:MaxGCPauseMillis=<value>` | 设置垃圾回收的最大期望暂停时间目标。 |'
- en: '| `-``XX:GCTimeRatio=<value>` | Sets the target ratio of garbage collection
    time to application time. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:GCTimeRatio=<value>` | 设置垃圾回收时间与应用时间的目标比率。 |'
- en: '| `-``XX:UseAdaptiveSizePolicy` | Enables adaptive sizing policies for heap
    and survivor spaces. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:UseAdaptiveSizePolicy` | 启用堆和幸存空间的自适应大小策略。 |'
- en: '| `-``XX:AdaptiveSizeThroughPutPolicy` | Configures the adaptive sizing policy
    for throughput-oriented garbage collection. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:AdaptiveSizeThroughPutPolicy` | 配置面向吞吐量的垃圾回收的自适应大小策略。 |'
- en: '| `-``XX:AdaptiveSizePolicyOutputInterval=<n>` | Sets the interval, in the
    number of collections, for adaptive sizing policy output. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:AdaptiveSizePolicyOutputInterval=<n>` | 设置自适应大小策略输出的间隔，以收集次数计。 |'
- en: '| `-``XX:ParallelGCVerbose` | Enables verbose output from Parallel GC. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ParallelGCVerbose` | 启用并行垃圾回收的详细输出。 |'
- en: 'Table 6.2: Parallel GC commands'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2：并行垃圾回收命令
- en: These options provide a means to configure and fine-tune the behavior of Parallel
    GC, allowing developers and administrators to optimize garbage collection for
    specific application requirements and hardware characteristics.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '这些选项提供了一种配置和微调并行垃圾回收行为的方法，使开发人员和管理员能够针对特定的应用需求和硬件特性优化垃圾回收。 '
- en: As we conclude our exploration into the Parallel GC world, we find ourselves
    enriched with insights into the parallel threads that orchestrate a harmonious
    performance within the JVM. The multithreaded efficiency of Parallel GC, showcased
    through its configuration options, provides a powerful toolkit for developers
    and administrators seeking to optimize memory management in diverse JVM environments.
    Our journey through the parallel rhythms has set the stage for the next act—G1
    GC. Join us in the upcoming section as we delve into the nuances of G1, unraveling
    its characteristics, advantages, and intricacies that position it as a pivotal
    player in the symphony of garbage collection strategies within the JVM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们对并行 GC 世界的探索告一段落，我们发现自己在并行线程如何协调 JVM 内部的和谐性能方面获得了丰富的见解。并行 GC 的多线程效率，通过其配置选项展示出来，为寻求在多种
    JVM 环境中优化内存管理的开发人员和管理员提供了一个强大的工具包。我们穿越并行节奏的旅程为下一幕——G1 GC 做好了准备。在接下来的部分，我们将深入探讨
    G1 的细微之处，揭示其特性、优势和复杂性，使其成为 JVM 内部垃圾收集策略交响乐中的关键角色。加入我们，一起探索垃圾收集策略的演变，剖析支撑 G1 的原则，并揭示它为
    JVM 内部动态景观带来的交响效率。
- en: G1
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: G1
- en: As we continue our exploration of JVM internals, our spotlight now turns to
    G1 GC. Positioned as a modern successor to its predecessors, G1 introduces a paradigm
    shift in garbage collection strategies. In this section, we delve into the intricacies
    of G1, unraveling its characteristics, operational nuances, and the innovative
    approaches it brings to the forefront of memory management. G1’s meticulous focus
    on achieving low latency, predictable pause times, and efficient heap utilization
    marks it as a key player in the symphony of garbage collection within the JVM.
    Join us in this section as we explore the evolution of garbage collection strategies,
    dissect the principles that underpin G1, and unveil the symphonic efficiency it
    brings to the dynamic landscape of JVM internals.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续探索 JVM 内部，我们的焦点现在转向 G1 GC。作为其前辈的现代继承者，G1 在垃圾收集策略上引入了一种范式转变。在本节中，我们深入探讨
    G1 的复杂性，揭示其特性、操作细微差别以及它为内存管理带来的创新方法。G1 对实现低延迟、可预测的暂停时间和高效堆利用的细致关注，使其成为 JVM 内部垃圾收集交响乐中的关键参与者。加入我们，在本节中我们将探索垃圾收集策略的演变，剖析支撑
    G1 的原则，并揭示它为 JVM 内部动态景观带来的交响效率。
- en: G1 GC is designed to address the challenges posed by traditional garbage collection
    strategies. It introduces a region-based approach, dividing the Java heap into
    smaller, uniformly sized regions. This departure from the monolithic heap structure
    allows G1 to manage memory more flexibly and precisely.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: G1 GC 设计用来解决传统垃圾收集策略带来的挑战。它引入了一种基于区域的方法，将 Java 堆划分为更小、均匀大小的区域。这种对单一堆结构的偏离使得
    G1 能够更灵活、更精确地管理内存。
- en: 'G1 divides the heap into regions and categorizes them into three main types:
    Eden, survivor, and old. The size and configuration of these regions are dynamic,
    allowing G1 to adapt to the memory needs of the application.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: G1 将堆划分为区域，并将它们分为三种主要类型：伊甸园（Eden）、幸存者（survivor）和旧（old）。这些区域的大小和配置是动态的，允许 G1
    适应应用程序的内存需求。
- en: 'The concept of the liveness space is central to G1’s efficiency. The liveness
    space comprises regions with live objects—objects still actively referenced by
    the application. G1 identifies and prioritizes regions with the least live data
    for garbage collection. This strategic approach optimizes the collection process
    by targeting areas where reclaimable memory is most concentrated, reducing both
    the frequency and duration of garbage collection pauses, as the following diagram
    shows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 活动空间的概念是 G1 效率的核心。活动空间包括包含活动对象的区域——这些对象仍然被应用程序积极引用。G1 识别并优先处理活数据最少的区域进行垃圾收集。这种战略方法通过针对可回收内存最集中的区域来优化收集过程，减少了垃圾收集暂停的频率和持续时间，如下面的图示所示：
- en: '![Figure 6.4: G1 process and liveness space working](img/B22030_06_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4：G1 过程和活动空间工作原理](img/B22030_06_04.jpg)'
- en: 'Figure 6.4: G1 process and liveness space working'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：G1 过程和活动空间工作原理
- en: G1’s primary goal is to achieve low latency and predictable pause times. By
    prioritizing regions with the least live data, G1 minimizes the impact on application
    responsiveness. It makes G1 particularly well suited for scenarios where maintaining
    consistent and low pause times is critical, such as in interactive and real-time
    applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: G1 的主要目标是实现低延迟和可预测的暂停时间。通过优先处理活数据最少的区域，G1 最小化了其对应用程序响应性的影响。这使得 G1 特别适合那些需要保持一致且低暂停时间的场景，例如交互式和实时应用程序。
- en: G1 employs adaptive collection strategies to adjust its approach based on the
    application’s dynamic behavior. It can dynamically resize regions, alter the garbage
    collection frequency, and adapt its overall strategy to align with the evolving
    demands of the application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: G1 采用自适应收集策略，根据应用程序的动态行为调整其方法。它可以动态调整区域大小，改变垃圾回收频率，并适应应用程序不断变化的需求。
- en: In essence, G1 GC’s utilization of liveness spaces, along with its region-based
    approach, positions it as a sophisticated and efficient solution for memory management
    in modern Java applications. The focus on predictability and adaptability makes
    G1 valuable in the landscape of garbage collection strategies within the JVM.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，G1 GC 对存活空间的利用，以及其基于区域的方法，使其成为现代 Java 应用程序内存管理的复杂和高效解决方案。对可预测性和适应性的关注使
    G1 在 JVM 内垃圾回收策略的领域中变得有价值。
- en: 'In our journey through the orchestration of memory within the JVM, the following
    table unfolds as a conductor’s guide to G1\. Each command within this ensemble
    provides a key to unlocking the precision and efficiency that G1 brings to garbage
    collection. From turning G1 on or off to fine-tuning parameters such as heap region
    size, pause-time goals, and adaptive strategies, these options empower developers
    and administrators to sculpt the symphony of memory management within the JVM.
    As we delve into the significance of each command, we navigate the intricacies
    that define G1’s performance, crafting a balance between predictability and adaptability.
    Join us in deciphering this symphony of configurations, where each note resonates
    with the nuanced precision that G1 introduces to the dynamic landscape of JVM
    internals:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们穿越 JVM 内存编排之旅中，以下表格展开为 G1 的指挥家指南。这个组合中的每个命令都提供了一把开启 G1 垃圾回收器精确性和效率之门的钥匙。从开启或关闭
    G1 到微调堆区域大小、暂停时间目标和自适应策略等参数，这些选项赋予了开发人员和管理员塑造 JVM 内部内存管理交响乐的能力。随着我们深入到每个命令的重要性，我们探索定义
    G1 性能的复杂性，在可预测性和适应性之间寻求平衡。加入我们，解读这个配置交响乐，其中每个音符都与 G1 引入 JVM 内部动态景观的细微精确性产生共鸣：
- en: '| **Command** | **Description** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-``XX:+UseG1GC` | Enables the use of G1 GC. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:+UseG1GC` | 启用 G1 垃圾回收器的使用。|'
- en: '| `-``XX:-UseG1GC` | Disables G1 GC. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:-UseG1GC` | 禁用 G1 垃圾回收器。|'
- en: '| `-``XX:G1HeapRegionSize=<value>` | Sets the size of G1 garbage collection
    regions. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:G1HeapRegionSize=<value>` | 设置 G1 垃圾回收区域的大小。|'
- en: '| `-``XX:MaxGCPauseMillis=<value>` | Sets the maximum desired pause-time goal
    for G1 garbage collection. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:MaxGCPauseMillis=<value>` | 设置 G1 垃圾回收的最大期望暂停时间目标。|'
- en: '| `-``XX:InitiatingHeapOccupancyPercent=<value>` | Sets the percentage of heap
    occupancy to start a G1 garbage collection cycle. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:InitiatingHeapOccupancyPercent=<value>` | 设置启动 G1 垃圾回收周期时的堆占用百分比。|'
- en: '| `-``XX:G1NewSizePercent=<value>` | Sets the percentage of heap size to use
    as the minimum for the young generation in G1. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:G1NewSizePercent=<value>` | 设置 G1 中年轻代的最小堆大小百分比。|'
- en: '| `-``XX:G1MaxNewSizePercent=<value>` | Sets the maximum percentage of heap
    size to use as the maximum for the young generation in G1. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:G1MaxNewSizePercent=<value>` | 设置 G1 中年轻代的最大堆大小百分比。|'
- en: '| `-``XX:ParallelGCThreads=<value>` | Sets the number of parallel garbage collection
    threads for G1. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ParallelGCThreads=<value>` | 设置 G1 的并行垃圾回收线程数。|'
- en: '| `-``XX:ConcGCThreads=<value>` | Sets the number of parallel garbage collection
    threads for the concurrent phase in G1. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ConcGCThreads=<value>` | 设置 G1 并行阶段的并行垃圾回收线程数。|'
- en: '| `-``XX:G1ReservePercent=<value>` | Sets the target percentage of heap to
    reserve as space for future garbage collection cycles. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:G1ReservePercent=<value>` | 设置为未来垃圾回收周期预留的堆目标百分比。|'
- en: '| `-``XX:G1TargetSurvivorOccupancy=<value>` | Sets the target occupancy of
    survivor space within each G1 region. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:G1TargetSurvivorOccupancy=<value>` | 设置每个 G1 区域中幸存空间的占用目标。|'
- en: '| `-``XX:G1HeapWastePercent=<value>` | Sets the target percentage of wasted
    space within a G1 region before a region is considered for reclamation. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:G1HeapWastePercent=<value>` | 设置在区域被视为回收之前，G1 区域内浪费空间的目标百分比。|'
- en: 'Table 6.3: G1 commands'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3：G1 命令
- en: These options provide a means to configure and fine-tune the behavior of G1
    GC, allowing developers and administrators to optimize garbage collection for
    specific application requirements and hardware characteristics.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项提供了一种配置和微调G1 GC行为的方法，允许开发人员和管理员针对特定的应用需求和硬件特性优化垃圾回收。
- en: On our exploration into the intricacies of G1 GC, we stand enriched with insights
    into the precision and adaptability that define its symphony of memory management
    within the JVM. The meticulous configuration options presented in our ensemble
    guide offer a conductor’s wand, shaping G1’s performance to align seamlessly with
    the diverse demands of Java applications. As we set our sights on the next section,
    the stage is set for a crescendo as we unravel the innovative nuances of ZGC.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索G1 GC的复杂性时，我们获得了关于其精确性和适应性的洞察，这些特性定义了其在JVM内存管理中的交响乐。我们指南中提供的细致配置选项提供了一根指挥棒，塑造G1的性能，使其与Java应用的多样化需求无缝对接。当我们着眼于下一节时，舞台已经准备好，我们将揭示ZGC的创新细微差别。
- en: ZGC
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZGC
- en: In our continued exploration of JVM internals, our focus shifts to the forefront
    of innovation by introducing ZGC. Positioned as a game-changer in garbage collection
    strategies, ZGC emerges as a beacon of efficiency and low-latency performance.
    This section serves as our gateway into the world of ZGC, unraveling its cutting-edge
    features, adaptive techniques, and commitment to minimizing pause times. With
    the pursuit of responsiveness at its core, ZGC redefines the dynamics of garbage
    collection, offering a solution tailored for modern, dynamic applications. Join
    us in this section as we delve into the revolutionary advancements that ZGC brings
    to the JVM, marking a pivotal milestone in the evolution of garbage collection
    strategies.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们持续探索JVM内部结构的过程中，我们的焦点转向了创新的前沿，通过引入ZGC。作为垃圾回收策略中的变革者，ZGC成为效率与低延迟性能的灯塔。本节作为我们进入ZGC世界的门户，揭示其尖端特性、自适应技术和最小化暂停时间的承诺。以响应性为核心，ZGC重新定义了垃圾回收的动态，为现代动态应用提供定制解决方案。请与本节一起深入探讨ZGC为JVM带来的革命性进步，标志着垃圾回收策略演变中的关键里程碑。
- en: ZGC stands at the forefront of modern garbage collection strategies, introducing
    groundbreaking features that redefine the dynamics of memory management within
    the JVM. At its core, ZGC prioritizes low latency and responsiveness, aiming to
    minimize pause times for applications with stringent performance requirements.
    One of ZGC’s key innovations is its concurrent approach to garbage collection.
    Unlike traditional collectors that halt the application during certain phases,
    ZGC performs major garbage collection tasks concurrently with the application
    threads, ensuring that pause times are kept to a minimum. This concurrent model
    is particularly advantageous for applications where responsiveness is critical,
    such as in real-time systems, interactive applications, or services where downtime
    must be minimized.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC位于现代垃圾回收策略的前沿，引入了开创性的特性，重新定义了JVM内存管理中的动态。在其核心，ZGC优先考虑低延迟和响应性，旨在最小化对性能要求严格的应用的暂停时间。ZGC的关键创新之一是其并发垃圾回收方法。与传统在特定阶段停止应用的垃圾回收器不同，ZGC与应用线程并发执行主要的垃圾回收任务，确保暂停时间保持在最低。这种并发模型对于响应性至关重要的应用特别有利，例如实时系统、交互式应用或必须最小化停机时间的服务。
- en: 'In computer memory, multi-mapping refers to a technique in which specific addresses
    in the virtual memory space point to the same ones in physical memory. It means
    that multiple virtual addresses correspond to the same physical location. Applications
    interact with data through virtual memory, and they remain oblivious to the underlying
    multi-mapping mechanism. This abstraction is crucial for the applications, allowing
    them to access data without being aware of the complexities involved in mapping
    virtual to physical memory, as the following diagram shows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机内存中，多映射是指一种技术，其中虚拟内存空间中的特定地址指向物理内存中的相同地址。这意味着多个虚拟地址对应于相同的物理位置。应用通过虚拟内存与数据交互，并且对底层的多映射机制一无所知。这种抽象对于应用至关重要，它允许它们在不了解将虚拟映射到物理内存的复杂性情况下访问数据，如下面的图所示：
- en: '![Figure 6.5: ZGC process mapping](img/B22030_06_05.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5：ZGC进程映射](img/B22030_06_05.jpg)'
- en: 'Figure 6.5: ZGC process mapping'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：ZGC进程映射
- en: Dynamic memory allocation, a common practice in programming, contributes to
    memory fragmentation over time. When objects are allocated and deallocated, free
    space gaps can emerge in the memory layout. Over time, these gaps accumulate,
    leading to **fragmentation**, wherein the memory resembles a chessboard with alternating
    areas of free and used space. To address this, there are two main strategies.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分配是编程中的常见做法，随着时间的推移会导致内存碎片。当对象被分配和释放时，内存布局中可能会出现空闲空间间隙。随着时间的推移，这些间隙会积累，导致**碎片化**，内存看起来像棋盘，交替出现空闲和使用的区域。为了解决这个问题，主要有两种策略。
- en: One approach involves scanning the memory for free space large enough to accommodate
    the desired object. This method, while feasible, is resource-intensive, especially
    if performed frequently. Additionally, it does not entirely eliminate fragmentation,
    as finding an exact match for the required space size can be challenging, leaving
    gaps between objects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在内存中扫描足够大的空闲空间以容纳所需的对象。虽然这种方法是可行的，但资源消耗较大，尤其是如果频繁执行。此外，它并不能完全消除碎片，因为找到所需空间大小的精确匹配可能具有挑战性，这会在对象之间留下间隙。
- en: The alternative strategy is to periodically relocate objects from fragmented
    memory areas to free spacein a more compact format. It involves dividing the memory
    space into blocks and relocating entire blocks of objects simultaneously. By doing
    so, the allocation of memory becomes faster, as known empty blocks are available.
    This strategy helps manage memory fragmentation more efficiently, balancing the
    need for dynamic allocation and the desire for a more contiguous and organized
    memory layout.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是定期将对象从碎片化的内存区域重新定位到更紧凑的空闲空间中。这涉及到将内存空间划分为块，并同时重新定位整个对象块。通过这样做，内存分配变得更快，因为已知的空块是可用的。这种策略有助于更有效地管理内存碎片，平衡动态分配的需求和对更连续、更有序的内存布局的渴望。
- en: Trade-offs are inherent in any garbage collection strategy, and ZGC is no exception.
    While it excels in reducing pause times, it may not achieve the same throughput
    as collectors optimized for throughput at the expense of latency. Additionally,
    ZGC might not be optimal for applications with extremely large heaps, as its concurrent
    approach may introduce some overhead. However, for scenarios where low latency
    is paramount, and the application’s responsiveness takes precedence over maximum
    throughput, ZGC emerges as a powerful solution.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 任何垃圾回收策略都存在权衡，ZGC也不例外。虽然它在减少暂停时间方面表现出色，但它可能无法达到那些以牺牲延迟为代价优化吞吐量的收集器的相同吞吐量。此外，ZGC可能不是具有极大规模堆的应用程序的最佳选择，因为其并发方法可能会引入一些开销。然而，在低延迟至关重要且应用程序的响应性比最大吞吐量更重要的场景中，ZGC成为一个强大的解决方案。
- en: Another notable feature of ZGC is its ability to resize the heap dynamically.
    ZGC adapts the heap size to the application’s demand, allowing it to manage memory
    in response to changing workloads efficiently. This adaptability is particularly
    beneficial in environments where workloads vary, providing an agile and responsive
    memory management solution.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC的另一个显著特点是它能够动态调整堆的大小。ZGC会根据应用程序的需求调整堆的大小，使其能够高效地响应不断变化的工作负载。这种适应性在负载变化的环境中尤其有益，提供了一个灵活且响应迅速的内存管理解决方案。
- en: In essence, ZGC represents a paradigm shift in garbage collection, offering
    a sophisticated solution for applications demanding low latency and responsiveness
    without compromising memory management efficiency. Its innovative features and
    concurrent design make it a compelling choice for modern Java applications operating
    in dynamic and resource-intensive scenarios.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，ZGC代表了垃圾回收领域的一次范式转变，为需要低延迟和响应性的应用程序提供了一个复杂的解决方案，而不会牺牲内存管理效率。其创新特性和并发设计使其成为在动态和资源密集型场景下运行的现代Java应用程序的一个有吸引力的选择。
- en: 'In the dynamic realm of JVM internals, ZGC takes center stage as a cutting-edge
    solution, prioritizing low-latency performance and responsiveness. This table
    serves as a compass in navigating the configuration landscape of ZGC, providing
    developers and administrators with a curated set of commands to sculpt its behavior.
    From turning ZGC on or off to fine-tuning parameters such as pause times, thread
    counts, and memory uncommit policies, these options empower users to tailor ZGC
    to the specific demands of their Java applications. As we delve into the significance
    of each command, this guide becomes an essential resource for optimizing ZGC performance,
    ensuring a harmonious balance between efficiency and adaptability. Join us in
    unlocking the potential of ZGC, where each command becomes a note in the symphony
    of precision that defines the future of garbage collection strategies within the
    JVM:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM内部动态领域，ZGC作为一项前沿解决方案，占据中心舞台，优先考虑低延迟性能和响应性。此表作为导航ZGC配置景观的指南，为开发人员和管理员提供了一系列精心挑选的命令，以塑造其行为。从开启或关闭ZGC到微调暂停时间、线程数和内存释放策略等参数，这些选项赋予用户根据其Java应用程序的具体需求定制ZGC的能力。随着我们深入探讨每个命令的重要性，本指南成为优化ZGC性能的必备资源，确保在效率与适应性之间达到和谐平衡。加入我们，一起发掘ZGC的潜力，每个命令都成为定义JVM内垃圾收集策略未来的精确交响乐中的音符：
- en: '| **Command** | **Description** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-``XX:+UseZGC` | Enables the use of ZGC. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:+UseZGC` | 启用ZGC的使用。 |'
- en: '| `-``XX:-UseZGC` | Disables ZGC. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:-UseZGC` | 禁用ZGC。 |'
- en: '| `-``XX:MaxGCPauseMillis=<value>` | Sets the maximum desired pause time goal
    for ZGC garbage collection. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:MaxGCPauseMillis=<value>` | 设置ZGC垃圾收集的最大期望暂停时间目标。 |'
- en: '| `-``XX:GCPauseIntervalMillis=<value>` | Sets the maximum interval between
    ZGC pauses. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:GCPauseIntervalMillis=<value>` | 设置ZGC暂停之间的最大间隔。 |'
- en: '| `-``XX:ConcGCThreads=<value>` | Sets the number of parallel garbage collection
    threads for ZGC. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ConcGCThreads=<value>` | 设置ZGC的并行垃圾回收线程数。 |'
- en: '| `-``XX:ParallelGCThreads=<value>` | Sets the number of parallel garbage collection
    threads for the parallel phase of ZGC. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ParallelGCThreads=<value>` | 设置ZGC并行阶段的并行垃圾回收线程数。 |'
- en: '| `-``XX:ConcGCThreads=<value>` | Sets the number of parallel garbage collection
    threads for the concurrent phase of ZGC. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ConcGCThreads=<value>` | 设置ZGC并发阶段的并行垃圾回收线程数。 |'
- en: '| `-``XX:ZUncommitDelay=<value>` | Sets the delay for uncommitting memory after
    a region is no longer needed. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ZUncommitDelay=<value>` | 设置在区域不再需要后释放内存的延迟。 |'
- en: '| `-``XX:ZUncommitDelayMax=<value>` | Sets the maximum delay for uncommitting
    memory after a region is no longer needed. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ZUncommitDelayMax=<value>` | 设置在区域不再需要后释放内存的最大延迟。 |'
- en: '| `-``XX:ZUncommitDelayPolicy=<adaptive\&#124;fixed>` | Sets the uncommit delay
    policy for ZGC. Options include **adaptive** and **fixed**. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ZUncommitDelayPolicy=<adaptive\&#124;fixed>` | 设置ZGC的释放延迟策略。选项包括**自适应**和**固定**。
    |'
- en: '| `-``XX:SoftMaxHeap=<value>` | Sets the soft maximum heap size for ZGC. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:SoftMaxHeap=<value>` | 设置ZGC的软最大堆大小。 |'
- en: '| `-``XX:ZHeapSize=<value>` | Sets the ZGC heap size. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `-``XX:ZHeapSize=<value>` | 设置ZGC堆大小。 |'
- en: 'Table 6.4: ZGC commands'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.4：ZGC命令
- en: These options provide a means to configure and fine-tune the behavior of ZGC,
    allowing developers and administrators to optimize garbage collection for specific
    application requirements and hardware characteristics.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项提供了一种配置和微调ZGC行为的方法，允许开发人员和管理员针对特定的应用程序需求和硬件特性优化垃圾收集。 |
- en: As we wrap up our exploration into the intricacies of ZGC, we find ourselves
    immersed in the world of precision performance and low-latency responsiveness.
    The table of ZGC commands presented here serves as a guide, unlocking the potential
    for users to fine-tune and optimize ZGC for their Java applications. This section
    has laid the foundation for understanding how ZGC reshapes the landscape of garbage
    collection strategies.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对ZGC复杂性的探索时，我们发现自己沉浸在精确性能和低延迟响应性的世界中。这里提供的ZGC命令表作为指南，解锁了用户微调和优化ZGC以适应其Java应用程序的潜力。本节为理解ZGC如何重塑垃圾收集策略的格局奠定了基础。
- en: Our journey doesn’t end here but gracefully transitions into the next act—ergonomics
    and tuning. In the forthcoming chapters, we will delve into the art of optimizing
    Java applications, exploring strategies to fine-tune the performance of the JVM
    to meet the nuanced demands of diverse workloads. Join us as we navigate the realm
    of JVM tuning, where each adjustment becomes a brushstroke in the canvas of crafting
    optimal Java application performance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的旅程并未在此结束，而是优雅地过渡到下一幕——人体工程学和调优。在接下来的章节中，我们将深入探讨优化Java应用程序的艺术，探讨调整JVM性能的策略，以满足不同工作负载的细微需求。随着我们探索JVM调优的领域，每一次调整都成为构建最佳Java应用程序性能画布上的笔触。
- en: JVM tuning and ergonomics
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM调优和人体工程学
- en: In the dynamic landscape of Java application development, the twin pillars of
    ergonomics and profiling emerge as crucial elements in achieving optimal performance.
    This section marks our journey into fine-tuning Java applications, exploring the
    principles of ergonomics to adapt the JVM automatically to varying workloads.
    Simultaneously, we delve into profiling, a powerful tool for gaining insights
    into the runtime behavior of applications. As we navigate the nuances of optimizing
    Java performance, ergonomics and profiling become our guiding lights, offering
    strategies to sculpt applications for responsiveness and efficiency. Join us in
    this section as we uncover the synergy between adaptive tuning and insightful
    profiling, unlocking the potential to elevate Java applications to new levels
    of performance and responsiveness.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java应用程序开发的动态环境中，人体工程学和剖析成为实现最佳性能的关键要素。本节标志着我们进入Java应用程序微调的旅程，探讨人体工程学的原则，以自动适应不同的工作负载。同时，我们深入研究剖析，这是一种强大的工具，可以深入了解应用程序的运行时行为。随着我们探索优化Java性能的细微差别，人体工程学和剖析成为我们的指南，提供策略来塑造应用程序以实现响应性和效率。在本节中，随着我们揭示自适应调优和洞察力剖析之间的协同作用，我们将解锁提升Java应用程序性能和响应能力的新潜力。
- en: Ergonomics in the context of Java refers to the adaptive tuning capabilities
    embedded within the JVM to adjust its configuration automatically based on the
    characteristics of the underlying hardware and the application’s behavior. The
    primary goal of ergonomics is to enhance the performance and responsiveness of
    Java applications without requiring manual intervention from developers. By dynamically
    adjusting parameters such as garbage collection algorithms, heap sizes, and thread
    counts, ergonomics aims to strike an optimal balance for a given runtime environment.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的背景下，人体工程学指的是JVM内嵌的自适应调优能力，可以根据底层硬件和应用行为自动调整其配置。人体工程学的主要目标是提高Java应用程序的性能和响应性，而无需开发者的手动干预。通过动态调整垃圾收集算法、堆大小和线程计数等参数，人体工程学旨在为给定的运行时环境实现最佳平衡。
- en: However, the default configuration set by ergonomics is often considered a form
    of premature optimization. It is because the default settings are determined at
    JVM startup, relying on heuristics and assumptions about the environment. While
    these defaults may work reasonably well for a broad range of applications and
    hardware, they might not be the most efficient configuration for specific use
    cases. Premature optimization occurs when the JVM makes assumptions about application
    behavior without sufficient runtime information, potentially leading to suboptimal
    performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，人体工程学设定的默认配置通常被认为是一种过早优化。这是因为默认设置是在JVM启动时确定的，依赖于启发式和环境假设。虽然这些默认设置可能对广泛的应用程序和硬件来说表现良好，但它们可能不是特定用例中最有效的配置。过早优化发生在JVM在没有足够运行时信息的情况下对应用程序行为做出假设时，可能导致性能不佳。
- en: Ergonomics can choose between Serial GC and G1 based on the system’s capabilities.
    Serial GC is typically chosen as the default, especially for single-processor
    systems or when memory is limited. On the other hand, G1 may be selected when
    there are more than two processors and a sufficient amount of memory (1792 MB
    or more) available.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 人体工程学可以根据系统的能力在串行GC和G1之间进行选择。串行GC通常是默认选择，尤其是在单处理器系统或内存有限的情况下。另一方面，当有超过两个处理器且可用内存足够（1792
    MB或更多）时，可能会选择G1。
- en: Furthermore, ergonomics adjusts the default maximum heap size based on the available
    memory. The default maximum heap size can be set to 50%, 25%, or 1/64 of the available
    memory, providing flexibility to accommodate different application requirements
    and system constraints. In essence, ergonomics acts as an intelligent conductor,
    dynamically tailoring the JVM’s configuration to orchestrate a performance symphony
    that aligns with the unique characteristics of each runtime environment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，人体工程学根据可用内存调整默认的最大堆大小。默认最大堆大小可以设置为可用内存的50%、25%或1/64，提供灵活性以适应不同的应用程序需求和系统限制。本质上，人体工程学充当一个智能指挥家，动态调整JVM配置以编排与每个运行时环境独特特性相一致的性能交响曲。
- en: The recommendation to *always set the configuration of GC and avoid the ergonomic*
    stems from the idea that manually configuring GC parameters gives developers more
    control and predictability over the JVM’s behavior. While ergonomic settings are
    designed to adjust the JVM configuration based on heuristics and runtime characteristics,
    this automated approach may not always produce the most optimized performance
    for specific use cases.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 建议始终设置GC配置并避免使用人体工程学，源于手动配置GC参数可以给开发者提供对JVM行为的更多控制和可预测性。虽然人体工程学设置旨在根据启发式方法和运行时特性调整JVM配置，但这种自动化的方法可能并不总是为特定用例产生最优化性能。
- en: When developers manually configure the GC, they can tailor the JVM settings
    according to the application’s unique requirements, workload characteristics,
    and the underlying infrastructure. This manual tuning allows more fine-grained
    control over parameters such as heap size, thread counts, and garbage collection
    algorithms.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者手动配置GC时，他们可以根据应用程序的独特需求、工作负载特性和底层基础设施来定制JVM设置。这种手动调优允许对堆大小、线程数和垃圾回收算法等参数进行更细致的控制。
- en: Avoiding ergonomic settings becomes especially relevant when applications have
    specific performance goals, stringent latency requirements, or when the default
    configurations generated by the ergonomic tuning may not align with the application’s
    optimal needs. Manual tuning allows developers to experiment with, analyze, and
    adjust JVM parameters to achieve the desired performance outcomes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用人体工程学设置在应用程序具有特定性能目标、严格的延迟要求，或者人体工程学调优生成的默认配置可能不符合应用程序最佳需求时变得尤为重要。手动调优允许开发者对JVM参数进行实验、分析和调整，以实现期望的性能结果。
- en: However, it’s crucial to note that while manual tuning provides greater control,
    it also requires a deep understanding of the application’s behavior, garbage collection
    algorithms, and JVM internals. Developers must carefully assess the impact of
    their configurations and regularly monitor the application’s performance to ensure
    that the chosen settings align with evolving application demands.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，虽然手动调优提供了更大的控制权，但它也要求对应用程序的行为、垃圾回收算法和JVM内部有深入的了解。开发者必须仔细评估其配置的影响，并定期监控应用程序的性能，以确保所选设置与不断变化的应用需求相一致。
- en: In summary, the recommendation to manually set the configuration of the GC and
    avoid relying solely on ergonomic settings reflects a desire for more precise
    control over JVM behavior, particularly in scenarios where tailored performance
    optimization is crucial for the application’s success.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，建议手动设置GC配置并避免仅依赖人体工程学设置，反映了希望对JVM行为有更精确控制的愿望，尤其是在对应用程序成功至关重要的定制性能优化场景中。
- en: 'In Bruno Borges’ insightful *Secrets of Performance Tuning Java on Kubernetes*
    presentation, he shared invaluable recommendations for optimizing Java applications
    running on Kubernetes. Borges discussed the performance implications associated
    with different garbage collection algorithms, namely Serial, Parallel, G1, and
    Z, considering key factors such as the number of cores, multithreaded environments,
    Java heap size, pause times, overhead, and tail-latency effects. Each garbage
    collection strategy was dissected in the context of its suitability for specific
    scenarios. Whether an application benefits from the simplicity of Serial, the
    parallel processing of Parallel, the adaptability of G1, or the low-latency focus
    of Z, Borges provided nuanced insights into choosing the most effective garbage
    collection approach. The recommendations presented by Borges offer a comprehensive
    guide for Java developers navigating the complexities of performance tuning in
    Kubernetes environments, shedding light on the intricate dance between application
    demands and garbage collection strategies:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在布鲁诺·博尔热斯的深刻见解性演讲《在Kubernetes上性能调优Java的秘诀》中，他分享了针对在Kubernetes上运行的Java应用程序进行优化的宝贵建议。博尔热斯讨论了与不同垃圾回收算法相关的性能影响，包括串行、并行、G1和Z，考虑到关键因素如核心数、多线程环境、Java堆大小、暂停时间、开销和尾延迟效应。每种垃圾回收策略都在其适用于特定场景的背景下进行了剖析。无论是应用程序从串行的简单性、并行的并行处理、G1的适应性还是Z的低延迟焦点中受益，博尔热斯都提供了对选择最有效的垃圾回收方法的细微洞察。博尔热斯提出的建议为在Kubernetes环境中导航性能调优复杂性的Java开发者提供了一个全面的指南，揭示了应用程序需求与垃圾回收策略之间错综复杂的舞蹈：
- en: '|  | **Serial** | **Parallel** | **G1** | **Z** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  | **串行** | **并行** | **G1** | **Z** |'
- en: '| Number of cores | 1 | +2 | +2 | +2 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 核心数 | 1 | +2 | +2 | +2 |'
- en: '| Multithreaded | No | Yes | Yes | Yes |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 多线程 | 否 | 是 | 是 | 是 |'
- en: '| Java heap size | > 4 GB | < 4 GB | > 4 GB | > 4 GB |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Java堆大小 | > 4 GB | < 4 GB | > 4 GB | > 4 GB |'
- en: '| Pause | Yes | Yes | Yes | Yes (> 1 ms) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 暂停 | 是 | 是 | 是 | 是 (> 1 ms) |'
- en: '| Overhead | Minimal | Minimal | Moderate | Moderate |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 开销 | 最小 | 最小 | 中等 | 中等 |'
- en: '| Tail-latency effect | High | High | High | Low |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 尾延迟效应 | 高 | 高 | 高 | 低 |'
- en: '| Best for | Single-core small heaps | Multi-core small heaps. Batch jobs,
    with any heap size. | Responsive in medium-to-large heaps (request-     response/DB interactions) | Responsive in medium-to-large heaps (request-     response |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 最佳适用 | 单核小型堆 | 多核小型堆。任何堆大小的批处理作业 | 中等至大型堆的响应性（请求-响应/数据库交互） | 中等至大型堆的响应性（请求-响应
    |'
- en: 'Table 6.5: Comparing all GCs’ aspects'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.5：比较所有垃圾回收器的各个方面
- en: In our exploration of JVM tuning, we’ve delved into the realms of ergonomics,
    profiling, and the delicate balance between automated adaptation and manual precision.
    Ergonomics dynamically tunes the JVM configuration for varying workloads, yet
    the recommendation emerges to configure the GC for greater control manually. A
    distilled summary awaits as we approach the conclusion, crystallizing the wisdom
    gained in navigating JVM tuning intricacies.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索JVM调优的过程中，我们深入研究了人体工程学、性能分析和自动化适应与手动精确之间的微妙平衡。人体工程学动态调整JVM配置以适应不同的工作负载，但建议手动配置GC以获得更大的控制权。随着我们接近结论，一个提炼的总结在等待着我们，它将我们在导航JVM调优复杂性中获得的智慧结晶化。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we draw the curtain on our exploration into the intricate GC world, we’ve
    navigated diverse strategies, nuances, and configurations that shape the memory
    management landscape within the JVM. From the adaptive finesse of ergonomics to
    the precision of Serial, Parallel, G1, and ZGC GCs, our journey has been a symphony
    of choices, each tuned to orchestrate optimal performance based on distinct application
    needs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束对复杂垃圾回收世界的探索时，我们已经导航了多种策略、细微差别和配置，这些策略塑造了JVM内存管理领域的格局。从人体工程学的适应性到串行、并行、G1和ZGC垃圾回收器的精确性，我们的旅程是一曲选择交响曲，每个选择都调校以根据不同的应用程序需求编排最佳性能。
- en: However, our expedition through JVM internals doesn’t pause here. The next chapter
    awaits, inviting us into the avant-garde realm of GraalVM. Beyond the confines
    of traditional Java, GraalVM emerges as a revolutionary platform, blurring the
    boundaries between languages and unleashing new possibilities for performance,
    polyglot capabilities, and efficient execution. Join us in the forthcoming chapters
    as we delve into the paradigm-shifting landscape of GraalVM, where the symphony
    of languages converges in harmony, marking a dynamic evolution in the ever-evolving
    tapestry of JVM technologies.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们对JVM内部的探险并未就此停止。下一章在等待着，邀请我们进入GraalVM的前沿领域。在传统Java的界限之外，GraalVM作为一个革命性的平台出现，模糊了语言之间的界限，释放了性能、多语言能力和高效执行的新可能性。随着我们深入探讨GraalVM的范式转变景观，加入我们，在语言交响乐和谐汇聚的地方，标志着JVM技术不断演变的动态进化。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的了解：
- en: What is the primary goal of ergonomics in JVM tuning?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JVM调优中人体工程学的首要目标是什么？
- en: Minimizing code compilation time
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小化代码编译时间
- en: Automatically adjusting JVM configuration based on runtime characteristics
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据运行时特性自动调整JVM配置
- en: Maximizing heap size for all applications
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有应用程序最大化堆大小
- en: Disabling garbage collection for enhanced performance
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用垃圾回收以增强性能
- en: Which GC is often chosen by ergonomics as the default for single-processor systems
    or when memory is limited?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种GC通常被人体工程学选为单处理器系统或内存有限时的默认选项？
- en: Serial GC
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列GC
- en: Parallel GC
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行GC
- en: G1 GC
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: G1 GC
- en: ZGC
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ZGC
- en: In the context of garbage collection, what does “multi-mapping” refer to?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在垃圾回收的背景下，“多映射”指的是什么？
- en: Multiple mapping of virtual memory addresses to physical memory
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟内存地址到物理内存的多次映射
- en: The use of multiple garbage collection algorithms simultaneously
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时使用多种垃圾回收算法
- en: Multithreading during garbage collection
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾回收期间的线程
- en: Allocating memory in multiple regions simultaneously
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时在多个区域分配内存
- en: Why might developers prefer manual GC configuration over ergonomics?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么开发者可能更喜欢手动GC配置而不是人体工程学？
- en: Manual tuning is more cost-effective
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动调整更经济高效
- en: Ergonomics is not compatible with modern JVM versions
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人体工程学与现代JVM版本不兼容
- en: Developers have better control over performance parameters
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者对性能参数有更好的控制
- en: Manual configuration reduces the need for garbage collection
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动配置减少了垃圾回收的需求
- en: Which GC is known for its focus on low latency and responsiveness, making it
    suitable for real-time systems?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种GC以其对低延迟和响应性的关注而闻名，使其适合实时系统？
- en: Serial GC
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列GC
- en: Parallel GC
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行GC
- en: G1 GC
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: G1 GC
- en: ZGC
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ZGC
- en: Answers
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章问题的答案：
- en: B. Automatically adjusting JVM configuration based on runtime characteristics
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B. 根据运行时特性自动调整JVM配置
- en: A. Serial GC
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A. 序列GC
- en: A. Multiple mapping of virtual memory addresses to physical memory
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A. 虚拟内存地址到物理内存的多次映射
- en: C. Developers have better control over performance parameters
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C. 开发者对性能参数有更好的控制
- en: D. ZGC
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D. ZGC
