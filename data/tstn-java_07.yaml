- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Java Syntax and Exceptions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java语法和异常
- en: 'In this chapter, we will begin by looking at the syntax of the Java language.
    It might seem strange that it took till this chapter to look at syntax. To understand
    why, I must let you in on a secret: you already know how to code. This is the
    audience this book is for – you can program but have little or no experience with
    Java. I have no doubt that you could understand what was happening in every code
    sample you have seen so far. We will now formalize the Java syntax.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从查看Java语言的语法开始。它可能看起来很奇怪，直到本章才查看语法。为了理解为什么，我必须告诉你一个秘密：你已经知道如何编码。这本书的受众就是这样的——你可以编程，但可能对Java的经验很少或没有。我毫不怀疑，你能够理解你迄今为止看到的每个代码示例中发生的事情。我们现在将正式化Java语法。
- en: 'Here are the topics we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要讨论的主题：
- en: Understanding coding structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解编码结构
- en: Handling exceptions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: By the end of this chapter, you will be able to organize Java code into methods
    and classes. Decision-making and iteration in Java code are presented. When things
    go wrong, there can be, in many situations, the need to leave the code that caused
    the error and either carry out additional processing to solve the problem or exit
    the program. This is the role of exceptions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够将Java代码组织成方法和类。Java代码中的决策和迭代将得到介绍。当事情出错时，在许多情况下，可能需要离开导致错误的代码，执行额外的处理以解决问题或退出程序。这就是异常的作用。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行本章示例所需的工具：
- en: Java 17 installed
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Java 17
- en: Text editor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: Maven 3.8.6 or a newer version installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Maven 3.8.6或更高版本
- en: You can find the code from this chapter in the GitHub repository at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter07](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter07).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库中找到本章的代码：[https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter07](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter07)。
- en: Understanding coding structures
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解编码结构
- en: When we write code in any language, we know that it must be organized in very
    specific ways. You are familiar with this concept from whichever language or languages
    you already know, so all we must do is examine how they are coded in Java. We
    begin with code blocks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在任何语言中编写代码时，我们知道它必须以非常具体的方式进行组织。你从你所知道的任何语言中熟悉这个概念，所以我们只需要检查它们在Java中的编码方式。我们从代码块开始。
- en: Code blocks
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码块
- en: Every language has a structure for organizing the lines of code you write, and
    this is commonly called a `begin` and `end` keywords. Java uses opening (`{`)
    and closing (`}`) braces, as do C, C++, C#, and JavaScript.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言都有一种组织你编写的代码行的结构，这通常被称为`begin`和`end`关键字。Java使用开括号（`{`）和闭括号（`}`），C、C++、C#和JavaScript也是如此。
- en: 'In Java, all classes and methods must have an opening and closing brace. Blocks
    may be nested, as we will see when we examine iteration and decisions later in
    this section. Blocks also serve another purpose when it comes to variables. This
    is called the variable’s scope. Let’s look at this in practice in an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，所有类和方法都必须有开括号和闭括号。块可以嵌套，正如我们在本节稍后讨论迭代和决策时将看到的。当涉及到变量时，块也起到另一个作用。这被称为变量的作用域。让我们通过以下示例来实际看看：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll discuss each line in detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论每一行。
- en: '*Line 1* declares a class named `Blocks`, and an opening brace appears on this
    line. C/C++ programmers typically place opening braces on their own line, and
    Java is fine with this. The Java style is to place an opening brace on the same
    line that names the block.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*第1行* 声明了一个名为`Blocks`的类，并且在这一行上出现了一个开括号。C/C++程序员通常将开括号放在自己的行上，Java对此也持开放态度。Java的风格是将开括号放在命名块的同一行上。'
- en: '*Line 3* declares an instance field. We know this because it is declared inside
    the class block and is not static. For every object, there will be a unique `classScope`
    variable. As this field is in the class block, it is visible to all non-static
    methods in the class. It is also available to any inner blocks in any method.
    It only goes out of scope when the object instantiated from this class goes out
    of scope.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*第3行* 声明了一个实例字段。我们知道这是因为它在类块内部声明，并且不是静态的。对于每个对象，将有一个唯一的`classScope`变量。因为这个字段在类块中，所以它对所有非静态方法都是可见的。它也可以在任何方法的任何内部块中使用。只有当从这个类实例化的对象超出作用域时，它才会超出作用域。'
- en: '*Line 4* declares a static or class variable. This variable will be shared
    by all instances of the class. It is visible in all blocks in the class. One thing
    it cannot be is a local method variable. Static variables can only be declared
    in the class block or scope.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4行*声明了一个静态或类变量。这个变量将由类的所有实例共享。它在类的所有块中都是可见的。它不能是一个局部方法变量。静态变量只能声明在类块或作用域中。'
- en: '*Lines 6* through *9* declare a static block. The code in this block is only
    ever executed once when the first instance of this object is created. You cannot
    declare fields in this block. You cannot interact with instance (non-static) variables,
    but you can interact with class (static) variables. You may also call upon static
    methods such as `System.out.print` or any static methods in this class. An interesting
    characteristic of static blocks is that they execute before the constructor. This
    is why they cannot access non-static variables and methods. These non-static variables
    are only valid after the constructor executes, not before.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行至第9行声明了一个静态块。这个块中的代码只会在创建这个对象的第一个实例时执行一次。你无法在这个块中声明字段。你无法与实例（非静态）变量交互，但你可以与类（静态）变量交互。你也可以调用静态方法，例如`System.out.print`或这个类中的任何静态方法。静态块的一个有趣特性是它们在构造函数之前执行。这就是为什么它们不能访问非静态变量和方法。这些非静态变量仅在构造函数执行后才是有效的，而不是在执行之前。
- en: '*Lines 11* through *13* are just a constructor. If you add a `main` method
    to this example, you will be able to see that the static block always executes
    before the constructor.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第11行至第13行只是一个构造函数。如果你向这个示例添加一个`main`方法，你将能够看到静态块总是先于构造函数执行。
- en: '*Lines 15* through *26* are a non-static method block named `perform` that
    in turn contains two additional blocks. In the `method` block, we have the `methodScope`
    local variable that is visible and accessible in the method and in any inner blocks.
    This variable will go out of scope when the execution of the method reaches the
    closing brace of the `method` block.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第15行至第26行是一个名为`perform`的非静态方法块，它包含两个额外的块。在`method`块中，我们有一个名为`methodScope`的局部变量，它在方法和任何内部块中都是可见和可访问的。当方法的执行达到`method`块的闭合大括号时，这个变量将超出作用域。
- en: '*Lines 18* through *20* consist of an `if` statement followed by a block that
    is executed should the `if` statement be `true`. In this block, we have declared
    a variable named `blockScope`. This variable comes into scope after the opening
    brace is encountered and the declaration is found. When the block ends, this variable
    goes out of scope.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第18行至第20行由一个`if`语句和一个随后执行的块组成。如果`if`语句为`true`，则执行这个块。在这个块中，我们声明了一个名为`blockScope`的变量。这个变量在遇到开括号并找到声明后进入作用域。当块结束时，这个变量将超出作用域。
- en: '*Lines 22* through *25* are another block. In here, we are declaring a variable
    of the same name and type as the class-scoped variable. When this occurs, the
    block version of a variable hides any variable declared in an outer block, which
    in this case is the class itself. To access the class block variable, as we have
    seen when we discussed methods, we use the `this` reference. If you create more
    blocks in blocks, which is not really a good idea, you can only access the class
    level variable with `this`, and any variable of the same name and the type in
    outer blocks becomes inaccessible.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第22行至第25行是另一个块。在这里，我们声明了一个与类作用域变量具有相同名称和类型的变量。当这种情况发生时，块版本的变量会隐藏任何在外部块（在这种情况下是类本身）中声明的变量。要访问类块变量，就像我们在讨论方法时看到的那样，我们使用`this`引用。如果你在块中创建更多的块，这实际上并不是一个好主意，你只能使用`this`来访问类级别的变量，并且任何与外部块中相同名称和类型的变量都变得不可访问。
- en: Moving on, let’s briefly review the meaning of the terms *statement* and *expression*
    in Java.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简要回顾一下Java中术语*语句*和*表达式*的含义。
- en: Statements
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句
- en: 'In Java, any line of code that performs a task and ends in a semicolon is a
    statement. Here are a few examples:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，任何执行任务并以分号结束的代码行都是语句。以下是一些示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are all statements. *Line 1* is a declaration statement where an integer
    variable is assigned space in memory and a value is assigned to it. *Line 2* is
    a call to a method. *Line 3* uses the square root method from the `Math` library
    to compute a result that you are assigning to a variable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是语句。*第1行*是一个声明语句，其中为整数变量分配了内存空间，并给它赋了一个值。*第2行*是对一个方法的调用。*第3行*使用了`Math`库中的平方根方法来计算一个结果，并将其赋给一个变量。
- en: Expressions
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式
- en: An expression in Java is any code that returns a result as part of a statement.
    The result may be from an assignment, some simple math, or as the return value
    from another method or Java construct, such as the `switch` expression that we
    will see shortly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的表达式是指任何作为语句一部分返回结果的代码。结果可能来自赋值、一些简单的数学运算，或者来自另一个方法或Java构造的返回值，例如我们很快将要看到的`switch`表达式。
- en: In the examples in the *Statements* section, we can see that the *line 1* statement
    includes an expression that assigns a value to a variable. *Line 2* is just a
    statement as there is no value that is changing. *Line 3* takes the value returned
    by the call to `Math.sqrt` and assigns it to a variable. When we assign a new
    value to a variable, we describe this as changing its state. Statements that change
    the state of a variable do this with an expression.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在*语句*部分的例子中，我们可以看到*第1行*的语句包含一个将值赋给变量的表达式。*第2行*只是一个语句，因为没有值在改变。*第3行*将`Math.sqrt`调用的返回值赋给一个变量。当我们给变量赋新值时，我们将其描述为改变其状态。改变变量状态的语句使用表达式来完成。
- en: Operators
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符
- en: Java’s family of operators is quite like what is found in C and most other languages
    derived from C/C++ or modeled on them. The rules of precedence are respected,
    and expressions inside parentheses are always carried out first. All the standard
    logical operators exist. As Java does not have pointers, operators that deal with
    pointers, such as the address of (`&`) and the indirection (`*`), do not exist
    in this language. There is one group of operators that I do want to highlight.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java的运算符家族与C语言以及大多数从C/C++派生或基于它们构建的语言中的运算符非常相似。优先级规则得到尊重，括号内的表达式总是首先执行。所有标准逻辑运算符都存在。由于Java没有指针，因此处理指针的运算符，如地址运算符（`&`）和间接引用运算符（`*`），在这个语言中不存在。有一组运算符我想特别强调。
- en: 'In C/C++, we express the outcome of combining multiple Boolean expressions
    in one of two ways—either logical `AND` or logical `OR`. They are expressed as
    a double ampersand (`&&`) and a double pipe (`||`). They employ short-circuit
    evaluation, which means if there’s a condition that validates or invalidates the
    statement in the first comparison, then there is no need to carry out a second
    comparison. The values on each side of the operator must be Booleans. Here’s an
    example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在C/C++中，我们以两种方式之一表达组合多个布尔表达式的结果——逻辑`AND`或逻辑`OR`。它们分别表示为双与运算符（`&&`）和双或运算符（`||`）。它们使用短路计算，这意味着如果第一个比较中的条件验证或无效化语句，则不需要执行第二个比较。运算符两边的值必须是布尔值。以下是一个例子：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is a matching set that can perform the same task but without short-circuit
    evaluation. These are the single ampersand (`&`) and the single pipe (`|`). When
    working with primitive types, they perform a bitwise operation. For the single
    ampersand (`&`), there must be a binary 1 in the same position in each value that
    becomes a binary 1 in the new value. Otherwise, a binary 0 is placed in the new
    value. For the single pipe (`|`), the matching bits must have one of the bits
    as a binary 1.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一组可以执行相同任务但不进行短路计算的匹配运算符。这些是单个与运算符（`&`）和单个或运算符（`|`）。当与原始类型一起使用时，它们执行位运算。对于单个与运算符（`&`），每个值中必须有一个二进制1在相同的位置，该位置在新值中也将变为二进制1。否则，新值中将放置一个二进制0。对于单个或运算符（`|`），匹配的位必须有一个位是二进制1。
- en: There is one more operator in this family worth mentioning and that is the caret
    (`^`). This is the `XOR` operator. As used with the primitive types, the new value
    takes a binary 1 only if one of the two values being compared has a binary 1 in
    the same position. Otherwise, the result is 0.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个家族中还有一个值得提到的运算符，那就是撇号（`^`）。这是`XOR`运算符。当与原始类型一起使用时，新值仅在比较的两个值中有一个在相同位置有二进制1时才取二进制1。否则，结果是0。
- en: 'In Java, there is a hierarchy of the numeric primitive types—as listed next—based
    on their size in memory and the range of allowable values. We saw this earlier
    in [*Chapter 4*](B19088_04.xhtml#_idTextAnchor086), *Language Fundamentals – Data
    Types* *and Variables*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，数值原始类型有一个基于它们在内存中的大小和允许值范围的层次结构——如下所示。我们之前在[*第4章*](B19088_04.xhtml#_idTextAnchor086)中看到过，*语言基础——数据类型*和*变量*：
- en: '`byte`'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`char`'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`char`'
- en: '`short`'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`short`'
- en: '`int`'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`long`'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`float`'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`double`'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`double`'
- en: 'Assignment statements have a right-hand side and a left-hand side, such as:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句有一个右侧和一个左侧，例如：
- en: '*LHS =* *RHS*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*LHS =* *RHS*'
- en: 'Based on this list, you can only have a type on the LHS that has a larger range
    of values than the type on the RHS. This means you can write something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个列表，你只能在左侧有一个比右侧类型值范围更大的类型。这意味着你可以写像这样的事情：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This works because the conversion from `int` on the RHS to `double` on the
    LHS is lossless. In the other direction, as shown next, it will be an error because
    the fractional part of `double` will be lost:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为从右侧的 `int` 到左侧的 `double` 的转换是无损的。在相反方向，如以下所示，将会出现错误，因为 `double` 的分数部分将会丢失：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This all leads to the casting operator—the parenthesis plus type. The parenthesis
    is also used in other ways but when used here, it becomes an operator. To make
    the previous example work, you can cast `double` to `int`, like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都导致类型转换运算符——括号加类型。括号也有其他用途，但在这里使用时，它变成了一个运算符。为了使前面的例子工作，你可以将 `double` 转换为
    `int`，如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a lossy conversion as the fractional component of the `double` value
    is sliced off, with no rounding. The value that ends up in `intValue` will be
    `23`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有损转换，因为 `double` 值的分数部分被截断，没有四舍五入。最终在 `intValue` 中的值将是 `23`。
- en: There is one more operator—the arrow operator (`->`), which we will encounter
    when we examine the modern switch and functional programming. Let’s now move on
    and examine iteration, commonly called looping.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个运算符——箭头运算符 (`->`)，我们将在检查现代 `switch` 和函数式编程时遇到。现在让我们继续前进，检查迭代，通常称为循环。
- en: Iteration
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代
- en: Java provides us with two approaches to iteration. The first, which we will
    look at now, is the classical looping technique. We will examine using streams
    to iterate over every member of a collection in the next chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Java 为我们提供了两种迭代方法。第一种，我们现在将探讨，是经典的循环技术。我们将在下一章中检查如何使用流来遍历集合中的每个成员。
- en: The for loop
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: 'Let’s begin with the C-style `for` loop. This is a loop where the conditions
    for iteration are in the first line of the loop inside parentheses:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 C 风格的 `for` 循环开始。这是一个迭代条件在循环括号第一行的循环：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The entire `for` loop is considered a block. This means that an `x` variable
    is created when the `for` loop is entered, and it goes out of scope when the loop
    ends. If you need access to `x` after the loop ends, then declare it before the
    loop, as shown:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 `for` 循环被视为一个块。这意味着当进入 `for` 循环时创建一个 `x` 变量，当循环结束时它将超出作用域。如果你需要在循环结束后访问 `x`，那么请在循环之前声明它，如下所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are two special statements available in classic loops:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 经典循环中有两个特殊语句可用：
- en: The `break` statement will end a loop before it finishes iterating
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break` 语句将在循环完成迭代之前结束循环'
- en: The `continue` statement ends the current iteration of the loop and moves on
    to the next iteration
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue` 语句结束当前迭代并继续到下一个迭代'
- en: The foreach loop
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`foreach` 循环'
- en: There is one more style of the `for` loop, called the `foreach` loop. It is
    predicated on the fact that every element in an array or collection will be processed.
    We will examine the `foreach` loop when we look at collections in the next chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环还有一种风格，称为 `foreach` 循环。它基于这样一个事实：数组或集合中的每个元素都将被处理。我们将在下一章查看集合时检查 `foreach`
    循环。'
- en: The while and do/while loops
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当 `while` 和 `do/while` 循环
- en: When a `for` loop is written, the maximum number of iterations is known right
    away. For our next loops, `while` and `do`/`while`, the number of iterations cannot
    be predicted as it will depend on something changing in the body of the loop.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写 `for` 循环时，最大迭代次数立即可知。对于我们的下一个循环，`while` 和 `do`/`while`，迭代次数无法预测，因为它将取决于循环体内的变化。
- en: 'In using `while` and `do`/`while`, the loop is dependent on something happening
    inside the loop block, which may change the variable that is being logically examined.
    Here is an example with an unpredictable ending:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `while` 和 `do`/`while` 时，循环依赖于循环块内部发生的事情，这可能会改变正在逻辑上检查的变量。以下是一个具有不可预测结束的例子：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line instantiates the `java.util.Random` object. Next, we instantiate
    the variable that will be the basis of the logical test and give it a random value.
    The method call to `rand.nextInt(12)` will return a value with a range of 12 possible
    integers between 0 to 11 inclusively. This points out that a `while` loop can
    iterate zero or more times, but it is not possible to predict how many iterations.
    We express the logical test in the parentheses of the `while` statement. Inside
    the loop, we must perform some action that alters the state of the `x` loop variable.
    There are no restrictions on what you can code in the `while` block.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行实例化了`java.util.Random`对象。接下来，我们实例化一个将作为逻辑测试基础的变量，并给它一个随机值。调用`rand.nextInt(12)`方法将返回一个介于0到11（包含）之间的12个可能整数的值。这表明`while`循环可以迭代零次或多次，但无法预测迭代次数。我们在`while`语句的括号中表达逻辑测试。在循环内部，我们必须执行一些改变`x`循环变量状态的行动。在`while`块中你可以编写的内容没有任何限制。
- en: 'A variation of the `while` loop is the `do`/`while` loop. This loop is guaranteed
    to iterate at least once as the logical test occurs at the end of the loop. You
    can see it in action here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环的一种变体是`do`/`while`循环。这个循环保证至少迭代一次，因为逻辑测试发生在循环的末尾。你可以在以下示例中看到它的作用：'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that, unlike the `while` loop, there is no need to initialize the loop
    variable as it will get its first value inside the loop.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与`while`循环不同，不需要初始化循环变量，因为它将在循环内部获得第一个值。
- en: Decision-making
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决策
- en: Decision-making syntax in Java supports three structures available in C/C++
    and other languages. They are the `if`/`else` statement, the `switch` statement,
    and the ternary operator.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的决策语法支持C/C++和其他语言中可用的三种结构。它们是`if`/`else`语句、`switch`语句和三元运算符。
- en: 'A simple `if` statement does not require an `else` block:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`if`语句不需要`else`块：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can create an either/or expression using `else`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`else`创建一个“要么/要么”的表达式：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can simplify this example by using the ternary operator, which uses a question
    mark and a colon:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用三元运算符来简化这个例子，它使用问号和冒号：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It begins with the logical test. While using parentheses in this situation is
    optional, I strongly recommend using them. After the question mark and on either
    side of the colon are the values that will be returned by the expression. You
    may also call a method if it returns a value of the appropriate type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它从逻辑测试开始。虽然在这种情况下使用括号是可选的，但我强烈建议使用它们。在问号和冒号两边是表达式将返回的值。你也可以调用一个返回适当类型值的函数。
- en: 'Should you need to define a test for ranges of value, you can use the `if`/`else`/`if`
    syntax:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要定义一个测试值范围的测试，你可以使用`if`/`else`/`if`语法：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next up is the C-style switch. As of Java 17, the syntax of the C-style switch
    can be considered obsolete. The fact that the new versions of the switch are recent
    additions makes it important that you understand the C-style version. A switch
    is a logical structure for comparing the `switch` variable to the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是C风格的`switch`语句。截至Java 17，C风格`switch`的语法可以被认为是过时的。由于新的`switch`版本是最近添加的，因此理解C风格版本很重要。`switch`是一种比较`switch`变量与以下内容的逻辑结构：
- en: A literal integer
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字面整数
- en: An integer constant variable
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数常量变量
- en: A literal string
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字面字符串
- en: 'Here is a switch to determine the postal rate, which depends on the zone the
    mail is being sent to:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个用于确定邮政费用的`switch`语句，这取决于邮件发送到的区域：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The lines that end in a colon are referred to as conditional labels. Should
    the `zone` variable’s value match the literal, then the code that follows the
    matching case is performed. When such a match with a case is found, all subsequent
    cases become `true`, regardless of the case value. Therefore, there is a `break`
    statement at the end of every case. You can simulate a test against a limited
    range of values by purposely not using a break everywhere, as illustrated in the
    following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以冒号结尾的行被称为条件标签。如果`zone`变量的值与字面值匹配，则执行匹配的case之后的代码。当找到与case的匹配时，所有后续的case都变为`true`，无论case的值如何。因此，每个case的末尾都有一个`break`语句。你可以通过故意不在每个地方使用`break`来模拟对值范围的测试，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As of Java 14, two new versions of the switch were introduced. These are the
    new `switch` expression and new `switch` statement. This will also be the first
    time we see the new arrow operator. Here is the expression version of the switches:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Java 14，引入了两种新的 switch 语法。这些是新的 `switch` 表达式和新的 `switch` 语句。这将是第一次我们看到新的箭头操作符。以下是
    switch 的表达式版本：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The break is gone as any match will end the switch. To match one of multiple
    items, we can use the comma operator to create a list. The arrow operator (`->`)
    points at the value that will be assigned to `continent`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句已经不存在了，因为任何匹配都将结束 `switch`。为了匹配多个项目中的一个，我们可以使用逗号操作符来创建一个列表。箭头操作符
    (`->`) 指向将被分配给 `continent` 的值：'
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Unlike a `switch` expression, a `switch` statement does not return a value,
    but the matching case performs some action such as calling a method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `switch` 表达式不同，`switch` 语句不返回值，但匹配的 `case` 执行一些操作，例如调用一个方法：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the new `switch` statement:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是新的 `switch` 语句：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is another type of switch that, as of this writing, is only available
    as a preview feature in Java 19, and that is the pattern-matching switch. As a
    preview feature, it may change when it becomes formally part of the language or
    even dropped from the language. I see this as an exciting new type of switch—you
    can see it in action here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还有一种类型的 `switch`，它只作为 Java 19 的预览功能提供，这就是模式匹配 `switch`。作为一个预览功能，它可能在其成为正式语言的一部分或甚至从语言中删除时发生变化。我认为这是一个令人兴奋的新类型的
    `switch`——你可以在下面看到它的实际应用：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Pattern matching will only work with objects and not primitives unless they
    are in one of Java’s primitive wrapper classes. When we assign the value `4` to
    the variable value of type `Object`, the compiler will auto-box the `int` primitive
    into an object of type `Integer`. Each `case` statement uses the class type in
    the case rather than a literal value. It also allows you to assign an identifier—in
    our case, `i`. Following the identifier is the new `when` keyword, after which
    you can write any valid Boolean expression. Only if the type matches and the logical
    expression after the `when` keyword is `true` is the case `true`. This should
    reduce the number of `if`/`else` `if`/ `else` `if`/ `else` `if` structures in
    your program. You will need Java 19 installed on your computer to experiment with
    this preview feature.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配仅适用于对象，而不是原始类型，除非它们是 Java 的原始包装类之一。当我们把值 `4` 赋给类型为 `Object` 的变量时，编译器会将 `int`
    原始类型自动装箱成一个 `Integer` 类型的对象。每个 `case` 语句使用 `case` 中的类类型而不是字面值。它还允许你分配一个标识符——在我们的例子中，是
    `i`。标识符之后是新 `when` 关键字，之后你可以写任何有效的布尔表达式。只有当类型匹配并且 `when` 关键字之后的逻辑表达式为 `true` 时，`case`
    才为 `true`。这应该会减少你程序中 `if`/`else` `if`/ `else` `if`/ `else` 结构的数量。你需要安装 Java 19
    来实验这个预览功能。
- en: With how Java handles decisions out of the way, we can now look at how Java
    handles exceptions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 处理决策的问题解决之后，我们现在可以看看 Java 如何处理异常。
- en: Handling exceptions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: In Java, when things go wrong, they can be classified as errors or exceptions.
    An error is a problem that cannot be recovered from. An exception is an error
    that can be detected in your code such that you can possibly recover from it.
    For example, a recursion that never ends will result in a `StackOverflowError`-type
    error. Converting the `Bob` string to an integer will result in a `NumberFormatException`
    exception.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，当事情出错时，它们可以被分类为错误或异常。错误是一个无法恢复的问题。异常是一个可以在你的代码中检测到的错误，你可能会从中恢复。例如，一个永远不会结束的递归将导致
    `StackOverflowError` 类型的错误。将 `Bob` 字符串转换为整数将导致 `NumberFormatException` 异常。
- en: 'Here is a diagram of the primary exception classes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是主要异常类的图示：
- en: '![Figure 7.1 – The exception hierarchy](img/B19088_07_01.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 异常层次结构](img/B19088_07_01.jpg)'
- en: Figure 7.1 – The exception hierarchy
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 异常层次结构
- en: 'Exceptions are objects of classes named after the type of exception that has
    occurred. In the diagram, you can see that at the root of the hierarchy is the
    `Throwable` class. From `Throwable`, we have two subclasses: `Error` and `Exception`.
    The subclasses of `Error` are named after the errors that may occur during program
    execution. These are errors that generally cannot be recovered from and should
    lead to the program ending.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是命名异常类型的类的对象。在图中，你可以看到在层次结构的根处是 `Throwable` 类。从 `Throwable`，我们有两个子类：`Error`
    和 `Exception`。`Error` 的子类是以程序执行期间可能发生的错误命名的。这些是通常无法恢复的错误，应该导致程序结束。
- en: 'As it may be possible to recover from an exception as opposed to an error,
    these types of problems belong to the `Exception` branch. This branch is divided
    into two categories: `try`/`catch`. Failing to use a `try`/`catch` block will
    generate a compiler error. You must resolve this; otherwise, you cannot compile
    your code.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能从异常中恢复，而不是从错误中恢复，这些类型的问题属于`Exception`分支。这个分支分为两个类别：`try`/`catch`。未能使用`try`/`catch`块将生成编译器错误。你必须解决这个问题；否则，你无法编译你的代码。
- en: Unchecked exceptions do not require a `try`/`catch` block. The compiler will
    happily compile code that might generate an unchecked exception without this code
    in a try/catch block. Should you decide not to handle an unchecked exception,
    your program will end.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 未检查的异常不需要`try`/`catch`块。编译器会愉快地编译可能生成未检查异常但不在`try`/`catch`块中的代码。如果你决定不处理未检查的异常，你的程序将结束。
- en: 'Let’s look at code that could have both types of exceptions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可能同时具有这两种异常的代码：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s review the important code lines.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下重要的代码行。
- en: '*Line 3* is the first method that contains code that could result in a checked
    exception being thrown.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*第3行*是第一个包含可能抛出检查异常的代码的方法。'
- en: '*Line 4* declares a `List` variable and sets it to `null`, which sets the `List`
    reference to zero. Local variables are not initialized, so they may already contain
    a value based on where in memory the reference is placed. If you do not properly
    allocate the `List` reference, usually done with `null`, there will be a compiler
    error in *line 11*. This will end the program.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*第4行*声明了一个`List`变量并将其设置为`null`，这设置了`List`引用为零。局部变量未初始化，因此它们可能已经根据引用在内存中的位置包含了一个值。如果你没有正确分配`List`引用，通常使用`null`，那么在第11行将会有编译器错误。这将结束程序。'
- en: '*Line 5* defines a path to a file. The `Paths.get()` method does not verify
    that the file exists, so no exception is thrown if the file does not exist.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*第5行*定义了一个文件路径。`Paths.get()`方法不会验证文件是否存在，因此如果文件不存在，不会抛出异常。'
- en: '*Line 6* is the beginning of our `try` block where any code that may throw
    a checked exception is written. You may have lines of code in a `try` block that
    do not throw an exception.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*第6行*是我们`try`块的开始，任何可能抛出检查异常的代码都写在这里。你可以在`try`块中有不抛出异常的代码行。'
- en: In *line 7*, using `Files.readAllLines()`, each line in the file is added to
    the `List` variable. This is where an invalid file `Path` object can result in
    a checked exception named `IOException`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第7行*，使用`Files.readAllLines()`，文件中的每一行都被添加到`List`变量中。这就是无效的文件`Path`对象可能导致名为`IOException`的检查异常的地方。
- en: '*Line 8* is the end of the `try` block and the beginning of the first `catch`
    block. A `catch` block takes as a parameter a reference to an `Exception` object
    that is created by the JVM when the exception is detected in the code inside the
    `try` block while the program executes. The `NoSuchFileException` exception is
    a subclass of `IOException`. Subclass exceptions must be handled before the superclass
    exception.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*第8行*是`try`块的末尾和第一个`catch`块的开始。`catch`块接受一个参数，即当在`try`块中的代码执行时检测到异常时，JVM创建的`Exception`对象的引用。`NoSuchFileException`异常是`IOException`的子类。子类异常必须在超类异常之前处理。'
- en: '*Line 9* is the body of a `catch` block, where you can write code to handle
    the error in such a way that the program does not need to end. All `Exception`
    objects have a method that displays the stack trace. You will not handle errors
    this way in production. When we discuss logging in the next chapter, we will see
    a best-practice approach.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*第9行*是`catch`块的主体，你可以在这里编写代码来处理错误，这样程序就不需要结束。所有`Exception`对象都有一个显示堆栈跟踪的方法。在生产环境中，你不会以这种方式处理错误。在我们下一章讨论日志记录时，我们将看到一种最佳实践方法。'
- en: In *line 10*, we have a second `catch` block. This is the `IOException` class.
    The code that reads the file can throw either a `NoSuchFileException` exception
    or an `IOException` exception. Some programmers may just catch `IOException`.
    As `NoSuchFileException` is a subclass of `IOException`, polymorphism allows you
    have both exceptions caught in one `catch` block that expects `IOException`. My
    preference is to use specific exception classes where possible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第10行*，我们有一个第二个`catch`块。这是`IOException`类。读取文件的代码可能会抛出`NoSuchFileException`异常或`IOException`异常。一些程序员可能只捕获`IOException`。由于`NoSuchFileException`是`IOException`的子类，多态性允许你在期望`IOException`的一个`catch`块中捕获这两个异常。我的偏好是在可能的情况下使用特定的异常类。
- en: Just as in *line 9*, here, in *line 11*, we are just printing the stack trace
    if this exception is caught here.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在第 *9* 行一样，这里在第 *11* 行，如果在这里捕获到这个异常，我们只是打印堆栈跟踪。
- en: It is in *line 13* that a compiler error can occur if the `fileContents` variable
    is either not assigned `null` or assigned a reference from calling the `File.readAllLines`
    method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 13* 行，如果 `fileContents` 变量既没有被分配 `null`，也没有从调用 `File.readAllLines` 方法分配引用，则可能会发生编译错误。
- en: During development, the use of the `printStackTrace` method in an `Exception`
    object can be useful. When we move to production code, we should never make this
    method call. In the next chapter, we will see how to use logging to preserve this
    information without it appearing in the console.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，在 `Exception` 对象中使用 `printStackTrace` 方法可能很有用。当我们转向生产代码时，我们永远不应该调用这个方法。在下一章中，我们将看到如何使用日志来保留这些信息，而不会出现在控制台中。
- en: '*Line 16* is a method that will perform division by zero. This will generate
    an unchecked `ArithmeticException` exception. For this reason, you are not required
    to use a `try`/`catch` block. As the code is dividing by zero, an exception will
    be thrown, a stack trace will appear if this is a console application, and the
    program will end. A GUI program has no place to show a stack trace, so it will
    appear to just end suddenly.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 16* 行是一个将执行除以零的方法。这将生成一个未检查的 `ArithmeticException` 异常。因此，你不需要使用 `try`/`catch`
    块。由于代码正在除以零，所以会抛出异常，如果这是一个控制台应用程序，则会显示堆栈跟踪，并且程序将结束。GUI 程序没有地方显示堆栈跟踪，所以它看起来会突然结束。'
- en: The stack trace
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈跟踪
- en: 'When your program ends due to an exception or after catching an exception,
    you can display a stack trace. The stack trace will appear in the console window.
    It is a list of every line of code that led to the exception before being caught
    or after the program ends. Here is the stack trace from the `doCheckedException`
    method when the filename in the `Path` object cannot be found:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序由于异常而结束或在捕获异常后，你可以显示堆栈跟踪。堆栈跟踪将出现在控制台窗口中。它是一系列代码行，这些代码行导致了异常，在捕获之前或程序结束后。以下是当
    `Path` 对象中的文件名找不到时 `doCheckedException` 方法的堆栈跟踪：
- en: '![Figure 7.2 – The stack trace explicitly displayed when an exception occurs](img/B19088_07_02.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 当发生异常时显式显示的堆栈跟踪](img/B19088_07_02.jpg)'
- en: Figure 7.2 – The stack trace explicitly displayed when an exception occurs
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 当发生异常时显式显示的堆栈跟踪
- en: 'As you can see, the exception has traveled through several methods, many of
    which occurred in a Java library and not your code. To use this information to
    locate the possibly offending source code, go through the list and locate the
    first entry that comes from your code, starting from the beginning of the trace:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，异常已经穿越了几个方法，其中许多发生在 Java 库中而不是你的代码中。为了使用这些信息来定位可能的有问题的源代码，从跟踪的开始处遍历列表，找到来自你代码的第一个条目：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This line tells us that the exception happened in the `doCheckedException` method
    on *line 17*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉我们异常发生在第 *17* 行的 `doCheckedException` 方法中。
- en: Ending the program
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束程序
- en: 'In some situations, you may wish to end a program after catching its exception.
    You can end most programs with `System.exit(n)`, where `n` is a number you assign
    to this error:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望在捕获异常后结束程序。你可以使用 `System.exit(n)` 来结束大多数程序，其中 `n` 是你分配给这个错误的数字：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The number—in this example, `12`—maps to a known error condition that must end
    the program. Here, after the stack trace is displayed, the program ends.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数字——在这个例子中是 `12`——映射到一个必须结束程序的已知错误条件。在这里，在显示堆栈跟踪后，程序结束。
- en: The throw and throws statements
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出和抛出语句
- en: 'If an exception is thrown in a method, Java looks for a `catch` block. If there
    is no `catch` block in the method that threw the exception, then Java looks into
    the method that called the offending method. This continues until it gets to the
    `main` method, and at that point, the program ends. There are situations where
    you will want to catch an exception where it happens, but then you want to re-throw
    it to whatever method that came before it that has a `catch` block. In this `catch`
    block, we are displaying the stack trace to the console and then re-throwing the
    exception:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在方法中抛出异常，Java 会查找 `catch` 块。如果在抛出异常的方法中没有 `catch` 块，那么 Java 会查看调用该方法的那个方法。这个过程会一直持续到
    `main` 方法，在那个点上，程序结束。有些情况下，你会在异常发生的地方捕获异常，但同时又想将其重新抛给之前有 `catch` 块的任何方法。在这个 `catch`
    块中，我们将堆栈跟踪显示到控制台，然后重新抛出异常：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To be able to re-throw, we must add to the method a `throws` clause:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够重新抛出异常，我们必须向该方法添加一个`throws`子句：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you use `throws`, whichever method calls `doCheckedException` must do
    this in a `try`/`catch` block, as shown:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`throws`时，调用`doCheckedException`的任何方法都必须像下面这样在`try`/`catch`块中执行：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can also use the `throws` clause to define that a method has a checked exception,
    but it will not be handled in the method. This means we can just call `checkedException()`
    without a `try`/`catch` block, as the method shows that it will be thrown to whichever
    `try`/`catch` block in another method called this method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`throws`子句来定义一个方法有一个检查异常，但该方法不会处理它。这意味着我们可以在没有`try`/`catch`块的情况下调用`checkedException()`，因为该方法表明它将被抛出到调用此方法的另一个方法的`try`/`catch`块中。
- en: The finally block
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`finally`块'
- en: 'There can be a third block for handling exceptions, called the `finally` block.
    In this block, you can write any code that you wish to execute if an exception
    is thrown or not. In this example, a message is displayed regardless of whether
    an exception is thrown or not:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有一个用于处理异常的第三个块，称为`finally`块。在这个块中，你可以编写任何你希望在抛出异常或不抛出异常时执行的代码。在这个例子中，无论是否抛出异常，都会显示一条消息：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the divisor is valid—not zero—then the code in the `finally` block is executed.
    If the divisor is invalid—is zero—the code in the `catch` block is executed followed
    by the code in the `finally` block.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除数有效——不是零——则执行`finally`块中的代码。如果除数无效——是零——则执行`catch`块中的代码，然后执行`finally`块中的代码。
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not confuse `finally` with the `finalize` method. The `finally` block is
    useful. The `finalize` method is not useful and should not be used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将`finally`与`finalize`方法混淆。`finally`块是有用的。`finalize`方法没有用，不应该使用。
- en: Creating your own exception classes
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自己的异常类
- en: 'The name of an exception class is the description of the problem that led to
    the exception being thrown. You can create your own exceptions and then throw
    your custom exception when you detect a serious problem in your code. The first
    step is to create an exception class, like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 异常类的名称是导致抛出异常的问题的描述。你可以创建自己的异常，然后在检测到代码中的严重问题时抛出自定义异常。第一步是创建一个异常类，如下所示：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a checked exception class. If you do not want it to be checked, then
    extend `RuntimeException`. You can add additional methods or override methods
    in `Exception`, but this is not necessary. You create custom exceptions to define
    exceptions unique to your program that are not sufficiently described in the existing
    family of exception classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个检查异常类。如果你不希望它被检查，那么扩展`RuntimeException`。你可以在`Exception`中添加额外的方法或覆盖方法，但这不是必要的。你创建自定义异常是为了定义你程序中独特的异常，这些异常在现有的异常类族中描述不足。
- en: 'Now, we need some code that will throw this exception:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一些会抛出这个异常的代码：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we need code that will call this method. As the method we are calling
    has a `throws` clause, we must treat it as a checked exception, and we must use
    a `try`/`catch` block:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要代码来调用这个方法。因为我们调用的方法有一个`throws`子句，我们必须将其视为检查异常，并且必须使用`try`/`catch`块：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the stack trace that occurred when this code executed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码执行时发生的堆栈跟踪：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see that the exception class we created is the exception reported in
    the stack trace.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们创建的异常类就是堆栈跟踪中报告的异常。
- en: There is one last issue to point out in regard to exceptions. Many languages
    such as C# and JavaScript do not have checked exceptions. The decision to catch
    these exceptions is solely at the discretion of the developer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异常，还有一个问题需要指出。许多语言，如C#和JavaScript，没有检查异常。是否捕获这些异常的决定完全取决于开发者。
- en: Throwing an exception is a slow process in the JVM. It is not something you
    might notice, but if it happens often enough, it will result in slower execution
    of the program. For this reason, never use exception handling as part of the program
    logic. Exceptions are serious issues that, in most cases, imply an error or bug
    that can affect the outcome of the program. If you can detect an error in your
    code, typically by testing a value with an `if` statement, you should handle it
    with the code you write and not by expecting or throwing an exception.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM中抛出异常是一个缓慢的过程。你可能不会注意到这一点，但如果它经常发生，将会导致程序执行速度变慢。因此，永远不要将异常处理作为程序逻辑的一部分。异常是严重的问题，在大多数情况下，意味着一个错误或缺陷，可能会影响程序的输出。如果你可以在代码中检测到一个错误，通常是通过使用`if`语句测试一个值，你应该使用你编写的代码来处理它，而不是期望或抛出异常。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about how Java code is organized into blocks as
    defined by an opening and closing brace. The blocks can be an entire class, each
    method in the class, and a body of iteration and decision statements. From there,
    we learned how to classify lines of code as statements or expressions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Java 代码是如何根据开闭大括号组织成块的。这些块可以是一个完整的类，类中的每个方法，以及迭代和决策语句的主体。从那里，我们学习了如何将代码行分类为语句或表达式。
- en: Operators were the next topic. We reviewed the math and logic operators and
    how they are combined. The `cast` operator for converting from one type to another
    was also shown.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符是下一个主题。我们回顾了数学和逻辑操作符以及它们的组合方式。还展示了用于将一种类型转换为另一种类型的 `cast` 操作符。
- en: 'Next up were the two most common coding structures: iterations and decisions.
    The classic `for` loop, a loop where the number of iterations is known before
    the loop begins, was presented. The second style of loops was `while` and `do`/`while`
    loops. These loops do not know how many iterations there will be. This is determined
    in the repeating block of code.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了两种最常见的编码结构：循环和决策。我们介绍了经典的 `for` 循环，这是一种在循环开始之前已知迭代次数的循环。第二种循环风格是 `while`
    和 `do`/`while` 循环。这些循环不知道会有多少次迭代，这由重复的代码块确定。
- en: Decision-making was next up. We looked at the `if` and `if`/`else` statements.
    These are effectively the same as found in any language that traces its lineage
    to the C language. The second decision structure we covered was the `switch` statement.
    As with `if`, it is virtually unchanged from its C roots. The good news is that
    this style of switch has been enhanced with three new versions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是决策。我们讨论了 `if` 和 `if`/`else` 语句。这些语句实际上与任何起源于 C 语言的编程语言中的语句相同。我们讨论的第二种决策结构是
    `switch` 语句。与 `if` 一样，它几乎与其 C 语言根源没有变化。好消息是这种风格的 `switch` 已经通过三个新版本得到了增强。
- en: The last topic we looked at was exceptions. We looked at what exception classes
    and objects are and which category, checked or unchecked, they fall into. How
    we can handle exceptions rather than just let the program end was presented as
    well. Creating our own named exceptions and how we can use them was the last topic
    we covered.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的最后一个主题是异常。我们探讨了异常类和对象是什么，以及它们属于哪一类，是检查型还是非检查型。我们还介绍了如何处理异常，而不是让程序直接结束。最后，我们还讨论了如何创建我们自己的命名异常以及如何使用它们。
- en: At this point, you should feel comfortable reading Java code. In our next chapter,
    we will look at additional features of the language and how they can be used to
    write cleaner code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经能够舒适地阅读 Java 代码了。在我们下一章中，我们将探讨语言的附加功能以及如何使用它们来编写更干净的代码。
- en: Further reading
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Exceptions in* *Java*: [https://medium.com/interviewnoodle/exception-in-java-89a0b41e0c45](https://medium.com/interviewnoodle/exception-in-java-89a0b41e0c45)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Java* 中的异常：[https://medium.com/interviewnoodle/exception-in-java-89a0b41e0c45](https://medium.com/interviewnoodle/exception-in-java-89a0b41e0c45)'
