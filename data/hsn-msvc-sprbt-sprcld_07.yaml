- en: Adding Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加持久化
- en: In this chapter, we will learn how to persist data that a microservice is using. As
    already mentioned in [Chapter 2](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Spring Boot*, we will use the Spring Data project to persist
    data to MongoDB and MySQL databases. The `project` and `recommendation` microservices
    will use Spring Data for MongoDB and the `review` microservice will use Spring
    Data for the **JPA** (short for the **Java Persistence API**) to access a MySQL
    database. We will add operations to the RESTful APIs to be able to create and
    delete data in the databases. The existing APIs for reading data will be updated
    to access the databases. We will run the databases as Docker containers, managed
    by Docker Compose, that is, in the same way as we run our microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将微服务正在使用数据进行持久化。正如在[第2章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)《Spring
    Boot简介》中提到的，我们将使用Spring Data项目将数据持久化到MongoDB和MySQL数据库中。`project`和`recommendation`微服务将使用Spring
    Data进行MongoDB操作，而`review`微服务将使用Spring Data的**JPA**（Java Persistence API的缩写）访问MySQL数据库。我们将向RESTful
    API添加操作，以能够创建和删除数据库中的数据。现有的用于读取数据的API将更新以访问数据库。我们将以Docker容器的形式运行数据库，由Docker Compose管理，也就是我们运行微服务的方式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Adding a persistence layer to the core microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向核心微服务添加持久化层
- en: Writing automated tests that focus on persistence
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写专注于持久化的自动化测试
- en: Using the persistence layer in the service layer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务层中使用持久化层
- en: Extending the composite service API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展组合服务API
- en: Adding databases to the Docker Compose landscape
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Docker Compose环境中添加数据库
- en: Manual testing of the new APIs and the persistence layer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试新API和持久化层
- en: Updating the automated tests of the microservice landscape
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新微服务环境中的自动化测试
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave
    but should be straightforward to modify to run on another platform such as Linux
    or Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在MacBook Pro上使用macOS Mojave运行的，但应该很容易修改以在另一个平台，如Linux或Windows上运行。
- en: No new tools need to be installed in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中不需要安装任何新工具。
- en: To access the databases manually, we will use the CLI tools provided in the
    Docker images used to run the databases. We will, however, expose the standard
    ports used for each database in Docker Compose—`3306` for MySQL and `27017` for
    MongoDB. This will enable you to use your local favorite database tools for accessing
    the databases in the same way as if they were running locally on your computer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够手动访问数据库，我们将使用用于运行数据库的Docker镜像中提供的CLI工具。不过，我们将在Docker Compose中暴露每个数据库所使用的标准端口——MySQL的`3306`和MongoDB的`27017`。这将允许你使用你最喜欢的数据库工具以与它们在本机运行相同的方式访问数据库。
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter06).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter06)。
- en: 'To be able to run the commands as described in the book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. Following are some sample commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够按照书中描述运行命令，请将源代码下载到一个文件夹中，并设置一个环境变量`$BOOK_HOME`，使其指向该文件夹。以下是一些示例命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Boot 2.1.0 (and Spring 5.1.2)—the latest available version of Spring
    Boot at the time of writing this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所用的Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用的是Spring Boot 2.1.0（以及Spring 5.1.2）——这是在撰写本章时Spring
    Boot可用的最新版本。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`'
- en: '`util`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`microservices/product-service`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-service`'
- en: '`microservices/review-service`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/review-service`'
- en: '`microservices/recommendation-service`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/recommendation-service`'
- en: '`microservices/product-composite-service`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-composite-service`'
- en: The code examples in this chapter all come from source code in `$BOOK_HOME/Chapter06` but
    are, in many cases, edited to remove non-relevant parts of the source code, such
    as comments and import and log statements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例都来自`$BOOK_HOME/Chapter06`的源代码，但在许多情况下，为了删除源代码中不相关部分，例如注释和导入以及日志语句，都进行了编辑。
- en: If you want to see the changes applied to the source code in [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),* Adding
    Persistence*, which sees what it took to add persistence to the microservices
    using Spring Data, you can compare it with the source code for [Chapter 5](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml),
    *Adding API Description Using OpenAPI/Swagger*. You can use your favorite diff tool
    and compare the two folders, `$BOOK_HOME/Chapter05` and `$BOOK_HOME/Chapter06`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看在[第6章](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml)，*添加持久化*中应用到源代码的变化，可以看到添加了持久化到微服务中使用Spring
    Data所需要的一切，你可以与[第5章](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml)，*使用OpenAPI/Swagger添加API描述*的源代码进行比较。你可以使用你喜欢的diff工具，比较两个文件夹，`$BOOK_HOME/Chapter05`和`$BOOK_HOME/Chapter06`。
- en: But first, let's see where we are heading
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但首先，让我们看看我们的目标在哪里
- en: 'By the end of this chapter, we will have layers inside our microservices that
    look like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们的微服务内部将会有如下的层次结构：
- en: '![](img/148fd8fc-30e4-4039-986a-554a4237bb7c.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/148fd8fc-30e4-4039-986a-554a4237bb7c.png)'
- en: The **Protocol layer** is very thin, only consisting of `RestController` annotations
    and the common `GlobalControllerExceptionHandler`. The main functionality of each
    microservice resides in the service layers. The `product-composite` service contains
    an integration layer to communicate with the three core microservices. The core microservices
    will all have a **Persistence layer** used for communicating with their databases.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议层**非常薄，仅包含`RestController`注解和公共`GlobalControllerExceptionHandler`。每个微服务的主要功能都存在于服务层中。`product-composite`服务包含一个集成层，用于与三个核心微服务进行通信。核心微服务都将有一个用于与它们数据库通信的**持久化层**。'
- en: 'We will be able to see data stored in MongoDB with a command like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用如下命令查看存储在MongoDB中的数据：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result of the command should look like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的结果应该像以下这样：
- en: '![](img/396be685-3e82-4fc9-b871-3b6e72c7f6d8.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/396be685-3e82-4fc9-b871-3b6e72c7f6d8.png)'
- en: 'Regarding data stored in MySQL, we will be able to see it with a command like
    this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于存储在MySQL中的数据，我们可以使用如下命令查看：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of the command should look as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的结果应该如下所示：
- en: '![](img/05445cec-486e-426e-8b16-b611e61649e5.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05445cec-486e-426e-8b16-b611e61649e5.png)'
- en: '**Note:** The output from the `mongo` and `mysql` commands have been shortened
    for improved readability.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** `mongo`和`mysql`命令的输出已经被缩短以提高可读性。'
- en: Let's see how to go about this.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何进行操作。
- en: Adding a persistence layer to the core microservices
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为核心微服务添加持久化层
- en: Let's start with adding a persistence layer to the core microservices. Besides
    using Spring Data, we will also use a Java bean mapping tool, MapStruct, that
    makes it easy to transform between Spring Data entity objects and the API model
    classes. For further details, see [http://mapstruct.org/](http://mapstruct.org/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为核心微服务添加一个持久化层。除了使用Spring Data，我们还将使用一个Java bean映射工具MapStruct，它使得在Spring
    Data实体对象和API模型类之间转换变得容易。有关详细信息，请参阅[http://mapstruct.org/](http://mapstruct.org/)。
- en: First, we need to add dependencies to MapStruct, Spring Data, and the JDBC drivers
    for the databases we intend to use. After that, we can define our Spring Data
    entity classes and repositories. The Spring Data entity classes and repositories
    will be placed in their own Java package, `persistence`. For example, for the
    product microservice, they will be placed in the Java package, `se.magnus.microservices.core.product.persistence`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加对MapStruct、Spring Data以及我们打算使用的数据库的JDBC驱动的依赖。之后，我们可以定义我们的Spring Data实体类和仓库。Spring
    Data实体类和仓库将被放置在它们自己的Java包中，`persistence`。例如，对于产品微服务，它们将被放置在Java包`se.magnus.microservices.core.product.persistence`中。
- en: Adding dependencies
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加依赖
- en: 'We will use MapStruct V1.3.0-Beta 2, so we start by defining a variable holding
    the version information in the build file for each core microservice, `build.gradle`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MapStruct V1.3.0-Beta 2，所以我们首先在每一个核心微服务的构建文件中定义一个变量，以保存版本信息，`build.gradle`：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we declare a dependency on MapStruct:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明对MapStruct的依赖：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since MapStruct generates the implementation of the bean mappings at compile
    time by processing MapStruct annotations, we need to add an `annotationProcessor` and
    a `testAnnotationProcessor` dependency:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MapStruct在编译时通过处理MapStruct注解来生成bean映射的实现，我们需要添加一个`annotationProcessor`和一个`testAnnotationProcessor`依赖：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make the compile-time generation work in popular IDEs such as IntelliJ IDEA,
    we also need to add the following dependency:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使在流行的IDE如IntelliJ IDEA中的编译时生成工作，我们还需要添加以下依赖：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are using IntelliJ IDEA, you also need to ensure that support for annotation
    processing is enabled. Open Preferences and navigate to Build, Execute, Deployment |
    Compiler | Annotations Processors. Verify that the checkbox named Enable annotation
    processing is selected!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是IntelliJ IDEA，你还需要确保启用了注解处理支持。打开首选项，导航到构建、执行、部署 | 编译器 | 注解处理器。验证名为“启用注解处理”的复选框是否被选中！
- en: 'For the `project` and `recommendation` microservices, we declare the following
    dependencies to Spring Data for MongoDB:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`project`和`recommendation`微服务，我们在Spring Data for MongoDB中声明了以下依赖：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The test dependency to `de.flapdoodle.embed.mongo` enables us to run MongoDB
    embedded when we run JUnit-based tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对`de.flapdoodle.embed.mongo`的测试依赖使我们能够在运行JUnit基础测试时运行MongoDB嵌入式。
- en: 'The `review` microservices will use Spring Data for JPA together with MySQL
    as its database in runtime and it will use an embedded database, H2, during tests.
    Therefore, it declares the following dependencies in its build file, `build.gradle`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`review`微服务将使用Spring Data for JPA，并搭配MySQL作为其数据库在运行时使用，在测试时会使用嵌入式数据库H2。因此，在它的构建文件`build.gradle`中声明了以下依赖：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Storing data with entity classes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实体类存储数据
- en: The entity classes are similar to the corresponding API model classes in terms
    of what fields they contain—see the Java package, `se.magnus.api.core`, in the
    `api` project. We will add two fields, `id`, and `version`, in the entity classes
    compared to the fields in the API model classes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类在包含字段方面与相应的API模型类相似——查看`api`项目中的Java包`se.magnus.api.core`。我们将在与API模型类字段相比在实体类中添加两个字段`id`和`version`。
- en: The `id` field is used to hold the database identity of each stored entity—the
    primary key when using a relational database. We will delegate the responsibility
    to generate unique values of the identity field to Spring Data. Depending on the
    database used, Spring Data can delegate this responsibility to the database engine.
    In either case, the application code does not need to consider how a unique database
    `id` value is set. The `id` field is not exposed in the API, as a best practice
    from a security perspective. The fields in the model classes that identify an
    entity will be assigned a unique index in the corresponding entity class, to ensure
    consistency in the database from a business perspective.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`字段用于持有每个存储实体的数据库身份——在使用关系数据库时是主键。我们将负责生成身份字段唯一值的职责委托给Spring Data。根据所使用的数据库，Spring
    Data可以将这个职责委托给数据库引擎。无论哪种情况，应用程序代码都不需要考虑如何设置数据库`id`的唯一值。`id`字段在API中不暴露，这是从安全角度出发的最佳实践。模型类中的字段，用于标识实体，将在相应的实体类中分配一个唯一索引，以确保从业务角度保持数据库的一致性。'
- en: The `version` field is used to implement optimistic locking, that is, allowing
    Spring Data to verify that updates of an entity in the database do not overwrite
    a concurrent update. If the value of the version field stored in the database
    is higher than the value of the version field in an update request, it indicates
    that the update is performed on stale data—the information to be updated has been
    updated by someone else since it was read from the database. Attempts to perform
    updates based on stale data will be prevented by Spring Data. In the section on
    writing persistence tests, we will see tests that verify the optimistic locking
    mechanism in Spring Data prevent updates performed on stale data. Since we only
    implement APIs for create, read, and delete operations, we will, however, not
    expose the version field in the API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`version`字段用于实现乐观锁，即允许Spring Data验证数据库中实体的更新是否覆盖了并发更新。如果存储在数据库中的版本字段值高于更新请求中的版本字段值，这表明更新是基于过时数据进行的——即自从从数据库中读取数据以来，要更新的信息已被其他人更新。Spring
    Data将防止基于过时数据执行更新。在编写持久性测试的部分，我们将看到测试验证Spring Data中的乐观锁机制防止对过时数据执行更新。由于我们只实现创建、读取和删除操作的API，因此我们不会在API中暴露版本字段。'
- en: 'The most interesting parts of the product entity class look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 产品实体类最有趣的部分看起来像这样：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are the observations from the preceding code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面代码得出的观察结果：
- en: The `@Document(collection="products")` annotation is used to mark the class
    as an entity class used for MongoDB, that is, mapped to a collection in MongoDB
    with the name, `products`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Document(collection="products")`注解用于标记用作MongoDB实体的类，即映射到名为`products`的MongoDB集合。'
- en: The `@Id` and `@Version` annotations are used to mark the `id` and `version`
    fields to be used by Spring Data, as explained previously.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Id` 和 `@Version` 注解用于标记由 Spring Data 使用的 `id` 和 `version` 字段，如前所述。'
- en: The `@Indexed(unique = true)` annotation is used to get a unique index created
    for the business key, `productId`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Indexed(unique = true)` 注解用于为业务键 `productId` 创建一个唯一的索引。'
- en: 'The most interesting parts of the `Recommendation` entity class look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recommendation` 实体类最有趣的部分看起来是这样的：'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Added to the explanations for the preceding product entity, we can see how a
    unique compound index is created using the `@CompoundIndex` annotation for the
    compound business key based on the fields, `productId` and `recommendationId`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面产品实体的解释基础上，我们可以看到如何使用 `@CompoundIndex` 注解为基于字段 `productId` 和 `recommendationId`
    的复合业务键创建唯一的复合索引。
- en: 'Finally, the most interesting parts of the `Review` entity class look like
    this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Review` 实体类最有趣的部分看起来是这样的：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following are the observations from the preceding code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的观察：
- en: The `@Entity` and `@Table` annotations are used to mark the class as an entity
    class used for JPA—mapped to a table in a SQL database with the name, `products`.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Entity` 和 `@Table` 注解用于标记一个类作为一个用于 JPA 的实体类——映射到 SQL 数据库中的一个名为 `products`
    的表。'
- en: The `@Table` annotation is also used to specify that a unique compound index
    shall be created for the compound business key based on the fields, `productId` and `reviewId`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Table` 注解也用于指定基于字段 `productId` 和 `reviewId` 的复合业务键应创建一个唯一的复合索引。'
- en: The `@Id` and `@Version` annotations are used to mark the `id` and `version`
    fields to be used by Spring Data as explained previously. To direct Spring Data
    for JPA to automatically generate unique `id` values for the `id` field, we are
    using the `@GeneratedValue` annotation.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Id` 和 `@Version` 注解用于标记 `id` 和 `version` 字段，如前所述，由 Spring Data 使用。为了指导 Spring
    Data for JPA 自动为 `id` 字段生成唯一的 `id` 值，我们使用了 `@GeneratedValue` 注解。'
- en: 'For full source code of the entity classes, see the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类的完整源代码可以在以下链接中找到：
- en: '`se.magnus.microservices.core.product.persistence.ProductEntity` in the `product`
    project'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.persistence.ProductEntity` 在 `product`
    项目中'
- en: '`se.magnus.microservices.core.recommendation.persistence.RecommendationEntity` in
    the `recommendation` project'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.persistence.RecommendationEntity`
    在 `recommendation` 项目中'
- en: '`se.magnus.microservices.core.review.persistence.ReviewEntity` in the `review`
    project'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.persistence.ReviewEntity` 在 `review` 项目中'
- en: Defining repositories in Spring Data
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Spring Data 中定义仓库
- en: Spring Data comes with a set of base classes for defining repositories. We will
    use the base classes, `CrudRepository` and `PagingAndSortingRepository`. The `CrudRepository` base
    class provides standard methods for performing basic create, read, update, and
    delete operations on the data stored in the databases. The `PagingAndSortingRepository` base
    class adds support for paging and sorting to the `CrudRepository` base class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 带有一组用于定义仓库的基础类。我们将使用基础类 `CrudRepository` 和 `PagingAndSortingRepository`。`CrudRepository`
    基础类提供了执行基本的数据库创建、读取、更新和删除操作的标准方法。`PagingAndSortingRepository` 基础类在 `CrudRepository`
    基础类中增加了分页和排序的支持。
- en: We will use the `CrudRepository` class as the base class for the `Recommendation`
    and `Review` repositories and the `PagingAndSortingRepository` class as the base
    class for the `Product` repository.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `CrudRepository` 类作为 `Recommendation` 和 `Review` 仓库的基础类，以及 `PagingAndSortingRepository`
    类作为 `Product` 仓库的基础类。
- en: We will also add a few extra query methods to our repositories for looking up
    entities using the business key, `productId`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向我们的仓库中添加几个额外的查询方法，用于使用业务键 `productId` 查找实体。
- en: Spring Data supports defining extra query methods based on naming conventions
    for the signature of the method. For example, the `findByProductId(int productId)`
    method signature can be used to direct Spring Data to automatically create a query
    that returns entities from the underlying collection or table that has the `productId` field
    set to the value specified in the `productId` parameter when calling the query
    method. For more details on how to declare extra queries, see [https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation](https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data支持基于方法签名的命名约定定义额外的查询方法。例如，`findByProductId(int productId)` 方法签名可以用来指导Spring
    Data自动创建一个查询，当调用查询方法时，返回底层集合或表中`productId`字段设置为`productId`参数中指定值的实体。有关如何声明额外查询的详细信息，请参阅[https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation](https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repositories.query-methods.query-creation)。
- en: 'The `Product` repository class looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product` 仓库类看起来是这样的：'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since the `findByProductId` method might return zero or one product entity,
    the return value is marked to be optional by wrapping it in an `Optional` object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`findByProductId`方法可能返回零个或一个产品实体，所以通过将其包裹在`Optional`对象中来标记返回值为可选的。
- en: 'The `Recommendation` repository class looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recommendation` 仓库类看起来是这样的：'
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the `findByProductId` method will return zero to many recommendation
    entities, so the return value is defined as a list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，`findByProductId`方法将返回零到多个推荐实体，所以返回值被定义为一个列表。
- en: 'Finally, the `Review` repository class looks like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Review` 仓库类的样子是这样的：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since SQL databases are transactional, we have to specify the default transaction
    type—read-only in our case—for the query method, `findByProductId()`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQL数据库是事务性的，我们必须为查询方法`findByProductId()`指定默认的事务类型——在我们的案例中是只读的。
- en: That's it—this is all it takes to establish a persistence layer for our core
    microservices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——这就是为我们的核心微服务建立持久化层所需的所有步骤。
- en: 'For full source code of the repository classes, see the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在以下位置查看仓库类的完整源代码：
- en: '`se.magnus.microservices.core.product.persistence.ProductRepository` in the `product` project'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.persistence.ProductRepository` 在 `product`
    项目中'
- en: '`se.magnus.microservices.core.recommendation.persistence.RecommendationRepository` in
    the `recommendation` project'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.persistence.RecommendationRepository`
    在 `recommendation` 项目中'
- en: '`se.magnus.microservices.core.review.persistence.ReviewRepository` in the `review` project'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.persistence.ReviewRepository` 在 `review`
    项目中'
- en: Let's start using them by writing some persistence tests to verify that they
    work as intended.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一些持久化测试来验证它们是否如预期般工作。
- en: Writing automated tests that focus on persistence
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写关注持久化的自动化测试
- en: When writing persistence tests, we want to start an embedded database when the
    tests begin and tear it down when the tests complete. However, we don't want the
    tests to wait for other resources to start up, for example, a web server such
    as Netty (which is required in runtime).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写持久化测试时，我们希望当测试开始时启动一个嵌入式数据库，当测试完成时将其销毁。然而，我们不希望测试等待其他资源启动，例如，Netty之类的Web服务器（在运行时是必需的）。
- en: 'Spring Boot comes with two class level annotations tailored for this specific
    requirement:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot带有两个针对此特定要求定制的类级注解：
- en: '`@DataMongoTest`: This starts up an embedded MongoDB database when the test
    starts.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DataMongoTest`：当测试开始时启动一个嵌入式MongoDB数据库。'
- en: '`@DataJpaTest`: This starts up an embedded SQL database when the test starts:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DataJpaTest`：当测试开始时启动一个嵌入式SQL数据库：'
- en: Since we added a test dependency in the build file for the review microservice
    to the H2 database, it will be used as the embedded SQL database.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自从我们在构建文件中向评论微服务的H2数据库添加了测试依赖后，它将被用作嵌入式SQL数据库。
- en: By default, Spring Boot configures the tests to roll back updates to the SQL
    database to minimize the risk of negative side effects on other tests. In our
    case, this behavior will cause some of the tests to fail. Therefore, automatic
    rollback is disabled with the class level annotation: `@Transactional(propagation
    = NOT_SUPPORTED)`.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Boot配置测试以回滚SQL数据库的更新，以最小化对其他测试的负面副作用风险。在我们的情况下，这种行为将导致一些测试失败。因此，通过类级注解禁用了自动回滚：`@Transactional(propagation
    = NOT_SUPPORTED)`。
- en: The persistence tests for the three core microservices are similar to each other,
    so we will only go through the persistence tests for the `Product` microservice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 三个核心微服务的持久化测试彼此相似，因此我们只需查看`Product`微服务的持久化测试。
- en: 'The test class declares a method, `setupDb()`, annotated with `@Before`, which
    is executed before each test method. The setup method removes any entities from
    previous tests in the database and inserts an entity that the test methods can
    use as a base for their tests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类声明了一个方法`setupDb()`，用`@Before`注解标记，在每种测试方法之前执行。设置方法从数据库中删除以前测试的任何实体，并插入一个测试方法可以作为其测试基础的实体：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next comes the various test methods. First out is a `create` test:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是各种测试方法。首先是`create`测试：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This test creates a new entity and verifies that it can be found using the `findByProductId()`
    method and wraps up with asserting that there are two entities stored in the database,
    the one created by the `setup` method and the one created by the test itself.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试创建了一个新实体，并验证它可以通过`findByProductId()`方法找到，并以断言数据库中存储了两个实体结束，一个是通过`setup`方法创建的，另一个是测试本身创建的。
- en: 'The `update` test looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`update`测试看起来像这样：'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test updates the entity created by the setup method, reads it again from
    the database using the standard `findById()` method, and asserts that it contains
    expected values for some of its fields. Note that, when an entity is created,
    its `version` field is set to `0` by Spring Data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试更新了由设置方法创建的实体，再次使用标准的`findById()`方法从数据库中读取它，并断言它的一些字段包含期望的值。注意，当实体被创建时，其`version`字段由Spring
    Data设置为`0`。
- en: 'The `delete` test looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`测试看起来像这样：'
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This test deletes the entity created by the `setup` method and verifies that
    it no longer exists in the database.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试删除由`setup`方法创建的实体，并验证它不再存在于数据库中。
- en: 'The `read` test looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`测试看起来像这样：'
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This test uses the `findByProductId()` method to get the entity created by the
    `setup` method, verifies that it was found, and then uses the local helper method, `assertEqualsProduct()`, to
    verify that the entity returned by `findByProductId()` looks the same as the entity
    stored by the setup method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试使用了`findByProductId()`方法来获取由`setup`方法创建的实体，验证它是否被找到，然后使用本地助手方法`assertEqualsProduct()`来验证`findByProductId()`返回的实体是否与`setup`方法存储的实体相同。
- en: 'Next, it follows two test methods that verify alternative flows—handling of
    error conditions. First, is a test that verifies that duplicates are handled correctly:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它跟随两个测试方法，验证替代流程——错误条件的处理。首先是验证重复正确处理的测试：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The test tries to store an entity with the same business key as used by the
    entity saved by the setup method. The test will fail if the save operation succeeds
    or if the save fails with an exception other than the expected, `DuplicateKeyException`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 测试尝试存储一个与`setup`方法保存的实体具有相同业务键的实体。如果保存操作成功，或者保存失败并抛出预期之外的异常，`DuplicateKeyException`，则测试将失败。
- en: 'The other negative test is, in my opinion, the most interesting test in the
    test class. It is a test that verifies a correct error handling in the case of
    updates of stale data—it verifies that the optimistic locking mechanism works.
    It looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，另一个负向测试是测试类中最有趣的测试。这是一个测试，用于验证在更新陈旧数据时的正确错误处理——它验证乐观锁定机制是否工作。它看起来像这样：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is observed from the preceding code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中观察到以下情况：
- en: First, the test reads the same entity twice and stores it in two different variables, `entity1`
    and `entity2`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，测试两次读取同一个实体，并将其存储在两个不同的变量`entity1`和`entity2`中。
- en: Next, it uses one of the variables, `entity1`, to update the entity. The update
    of the entity in the database will cause the version field of the entity to be
    increased automatically by Spring Data. The other variable, `entity2`, now contains
    stale data, manifested by its version field that holds a lower value than the
    corresponding value in the database.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它使用其中一个变量`entity1`来更新实体。在数据库中更新实体将导致Spring Data自动增加实体的版本字段。另一个变量`entity2`现在包含陈旧数据，体现在其版本字段持有的值低于数据库中对应值。
- en: When the test tries to update the entity using the variable, `entity2`, that
    contains stale data, it is expected to fail by throwing an `OptimisticLockingFailureException`
    exception.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当测试尝试使用包含陈旧数据的变量`entity2`更新实体时，预计会通过抛出`OptimisticLockingFailureException`异常来失败。
- en: The test wraps up by asserting that the entity in the database reflects the
    first update, that is, contains the name `"n1"`, and that the version field has
    the value `1`, that is, only one update has been performed on the entity in the
    database.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试通过断言数据库中的实体反映了第一次更新，即包含名称`"n1"`，并且版本字段具有值`1`，即只在数据库中更新了实体的一次。
- en: 'Finally, the `product` service contains a test that demonstrates the usage
    of built-in support for sorting and paging in Spring Data:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`product`服务包含一个测试，演示了Spring Data中内置的排序和分页支持的用法：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is observed from the preceding code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中观察到以下内容：
- en: The test starts with removing any existing data, then inserts 10 entities with
    the `productId` field ranging from `1001` to `1010`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试从删除任何现有数据开始，然后插入具有`productId`字段从`1001`到`1010`的10个实体。
- en: Next, it creates `PageRequest`, requesting a page count of `4` entities per
    page and a sort order based on `ProductId` in ascending order.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它创建了`PageRequest`，请求每页4个实体的分页计数，并根据`ProductId`升序排序。
- en: Finally, it uses a helper method, `testNextPage`, to read the expected three
    pages, verifying the expected product IDs in each page and verifying that Spring
    Data correctly reports back whether more pages exist or not.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它使用一个助手方法`testNextPage`来读取预期的三页内容，验证每页中预期的产品ID，并验证Spring Data正确报告是否存在更多页面。
- en: 'The helper method `testNextPage` looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 助手方法`testNextPage`看起来像这样：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The helper method uses the page request object, `nextPage`, to get the next
    page from the repository method, `findAll()`. Based on the result, it extracts
    the product IDs from the returned entities into a string and compares it to the
    expected list of product IDs. Finally, it returns a Boolean indicating whether
    more pages can be retrieved or not.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 助手方法使用分页请求对象`nextPage`从仓库方法的`findAll()`获取下一页。根据结果，它从返回的实体中提取产品ID，将其转换为字符串，并与期望的产品ID列表进行比较。最后，它返回一个布尔值，指示是否可以检索更多页面。
- en: 'For full source code of the three persistence test classes, see the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 三篇持久化测试类的完整源代码，请参见以下内容：
- en: '`se.magnus.microservices.core.product.PersistenceTests` in the `product` project'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.PersistenceTests`在`product`项目中'
- en: '`se.magnus.microservices.core.recommendation.PersistenceTests` in the `recommendation` project'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.PersistenceTests`在`recommendation`项目中'
- en: '`se.magnus.microservices.core.review.PersistenceTests` in the `review` project'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.PersistenceTests`在`review`项目中'
- en: 'The persistence tests in the `product` microservice can be executed using Gradle
    with a command like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`微服务中的持久化测试可以通过使用Gradle执行以下命令来执行：'
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After running the tests, it should respond with the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，它应该响应以下内容：
- en: '![](img/cf9108ce-73db-41ea-ab82-0bf1eb098921.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf9108ce-73db-41ea-ab82-0bf1eb098921.png)'
- en: With a persistence layer in place, we can update the service layer in our core
    microservices to use the persistence layer.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久化层就位后，我们可以将核心微服务中的服务层更新为使用持久化层。
- en: Using the persistence layer in the service layer
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务层使用持久化层
- en: 'In this section, we will learn how to use the persistence layer in the service
    layer to store data and retrieve data from a database. We will go through the
    following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在服务层使用持久化层来存储和从数据库中检索数据。我们将按照以下步骤进行：
- en: Log the database connection URL.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志记录数据库连接URL。
- en: Add new APIs.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的API。
- en: Use the persistence layer.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用持久化层。
- en: Declare a Java bean mapper.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个Java bean mapper。
- en: Update the service tests.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新服务测试。
- en: Log the database connection URL
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录数据库连接URL
- en: When scaling up the number of microservices where each microservice connects
    to its own database, I find myself, from time to time, in a situation where I'm
    not sure what database each microservice actually uses. Therefore, I usually add
    a log statement directly after the startup of a microservice that logs the connection
    URL that is used to connect to the database.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展微服务的数量时，每个微服务连接到自己的数据库，我发现自己有时不确定每个微服务实际上使用的是哪个数据库。因此，我通常在微服务启动后直接添加一个日志语句，记录用于连接数据库的连接URL。
- en: 'For example, the startup code for the `Product` service looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Product`服务的启动代码看起来像这样：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the log, the following type of output should be expected:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，应期望以下类型的输出：
- en: '![](img/96ba31d3-159d-4cca-a6b9-b3000522b943.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96ba31d3-159d-4cca-a6b9-b3000522b943.png)'
- en: For the full source code, see the `se.magnus.microservices.core.product.ProductServiceApplication` class
    in the `product` project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请参阅`product`项目中的`se.magnus.microservices.core.product.ProductServiceApplication`类。
- en: Adding new APIs
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新API
- en: Before we can use the persistence layer for creating and deleting information
    in the database, we need to create the corresponding API operations in our core
    service APIs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用持久化层在数据库中创建和删除信息之前，我们需要在我们的核心服务API中创建相应的API操作。
- en: 'The API operations for creating and deleting a product entity looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和删除产品实体的API操作看起来像这样：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The implementation of the delete operation will be idempotent, that is, it will
    return the same result if called several times. This is a valuable characteristic
    in fault scenarios. For example, if a client experience a network timeout during
    a call to a delete operation, it can simply call the delete operation again without
    worrying about varying responses, for example, OK (200) in response the first
    time and Not Found (404) in response to consecutive calls, or any unexpected side
    effects. This implies that the operation should return the status code OK (200)
    even though the entity no longer exists in the database.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作的实现将是幂等的，也就是说，如果多次调用，它将返回相同的结果。这在故障场景中是一个宝贵的特性。例如，如果客户端在调用删除操作时遇到网络超时，它可以简单地再次调用删除操作，而不用担心不同的响应，例如，第一次响应为OK
    (200) 和连续调用响应为Not Found (404)，或者任何意外的副作用。这暗示了即使实体在数据库中不再存在，操作也应该返回OK (200)的状态码。
- en: The API operations for the `recommendation` and `review` entities look similar;
    however, note that, when it comes to the delete operation for `recommendation`
    and `review` entities, it will delete all `recommendations` and `reviews` for
    the specified `productId`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommendation` 和 `review` 实体的API操作看起来很相似；然而，注意，当涉及到`recommendation` 和 `review`
    实体的删除操作时，它将删除指定`productId`的所有`recommendations`和`reviews`。'
- en: 'For the full source code, see the following classes in the `api` project:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请查看`api`项目中的以下类：
- en: '`se.magnus.api.core.product.ProductService`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.product.ProductService`'
- en: '`se.magnus.api.core.recommendation.RecommendationService`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.recommendation.RecommendationService`'
- en: '`se.magnus.api.core.review.ReviewService`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.review.ReviewService`'
- en: The use of the persistence layer
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用持久化层
- en: The source code in the service layer for using the persistence layer is structured
    in the same way for all core microservices. Therefore, we will only go through
    the source code for the `Product` microservice.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务层中使用持久化层的源代码对于所有核心微服务都是结构相同的。因此，我们只查看`Product`微服务的源代码。
- en: 'First, we need to inject the repository class from the persistence layer and
    a Java bean mapper class into the constructor:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从持久化层注入仓库类和一个Java bean映射器类到构造函数中：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the next section, we will see how the Java mapper class is defined.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到Java映射器类是如何定义的。
- en: 'Next, the `createProduct` method is implemented as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照以下方式实现`createProduct`方法：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `create` method used the `save` method in the repository to store a new
    entity. It should be noted how the mapper class is used to convert Java beans
    between an API model class and an entity class using the two mapper methods, `apiToEntity()`
    and `entityToApi()`. The only error we handle for the `create` method is the `DuplicateKeyException`
    exception, which we convert into an `InvalidInputException` exception.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`方法使用了仓库中的`save`方法来存储一个新的实体。应注意映射器类是如何使用两个映射器方法`apiToEntity()`和`entityToApi()`，在API模型类和实体类之间转换Java
    bean的。我们为`create`方法处理的唯一错误是`DuplicateKeyException`异常，我们将它转换为`InvalidInputException`异常。'
- en: 'The `getProduct` method looks like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`getProduct`方法看起来像这样：'
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After some basic input validation (that is, ensuring that `productId` is not
    negative), the `findByProductId()` method in the repository is used to find the
    product entity. Since the repository method returns an `Optional` product, we
    can use the `orElseThrow()` method in the `Optional` class to conveniently throw
    a `NotFoundException` exception if no product entity is found. Before the product
    information is returned, the `serviceUtil` object is used to fill in the currently
    used address of the microservice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行了基本输入验证（即确保`productId`不是负数）之后，仓库中的`findByProductId()`方法用于查找产品实体。由于仓库方法返回一个`Optional`产品，我们可以使用`Optional`类中的`orElseThrow()`方法方便地抛出如果没有找到产品实体就抛出`NotFoundException`异常。在返回产品信息之前，使用`serviceUtil`对象填充微服务当前使用的地址。
- en: 'Finally, let''s see the `deleteProduct` method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`deleteProduct`方法：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `delete` method also uses the `findByProductId()` method in the repository
    and uses the `ifPresent()` method in the `Optional` class to conveniently delete
    the entity only if it exists. Note that the implementation is idempotent, that
    is, it will not report any failure if the entity is not found.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 方法还使用了仓库中的`findByProductId()`方法，并使用了`Optional`类中的`ifPresent()`方法，方便地仅在实体存在时删除实体。注意，该实现是幂等的，即，如果找不到实体，它不会报告任何故障。'
- en: 'The source code for the three service implementation classes can be found at
    the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 三个服务实现类的源代码可以在以下位置找到：
- en: '`se.magnus.microservices.core.product.services.ProductServiceImpl` in the `product` project'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.services.ProductServiceImpl` 在 `product` 项目中'
- en: '`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl` in
    the `recommendation` project'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl` 在 `recommendation` 项目中'
- en: '`se.magnus.microservices.core.review.services.ReviewServiceImpl` in the `review` project'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.services.ReviewServiceImpl` 在 `review` 项目中'
- en: Declaring a Java bean mapper
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个Java bean映射器
- en: So, what about the magic Java bean mapper?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，魔法的Java bean映射器又如何呢？
- en: As already mentioned, we use MapStruct to declare our mapper classes. The use
    of MapStruct is similar in all three core microservices, so we will only go through
    the source code for the mapper object in the `Product` microservice.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，我们使用MapStruct来声明我们的映射器类。MapStruct在三个核心微服务中的使用是相似的，所以我们只查看`Product`微服务中的映射器对象源代码。
- en: 'The mapper class for the `product` service looks like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`product` 服务的映射器类看起来像这样：'
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following is observed from the preceding code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中观察到以下内容：
- en: The `entityToApi()` method maps entity objects to the API model object. Since
    the entity class does not have a field for `serviceAddress`, the `entityToApi()`
    method is annotated to ignore `serviceAddress`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entityToApi()`方法将实体对象映射到API模型对象。由于实体类没有`serviceAddress`字段，`entityToApi()`方法被注解忽略`serviceAddress`。'
- en: The `apiToEntity()` method maps API model objects to entity objects. In the
    same way, the `apiToEntity()` method is annotated to ignore the `id` and `version`
    fields that are missing in the API model class.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiToEntity()`方法将API模型对象映射到实体对象。同样，`apiToEntity()`方法被注解忽略在API模型类中缺失的`id`和`version`字段。'
- en: 'MapStruct does not only support mapping fields by name, but it can also be
    directed to map fields with different names. In the mapper class for the `Recommendation`
    service, the `rating` entity field is mapped to the API model field, `rate`, using
    the following annotations:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: MapStruct不仅支持按名称映射字段，还可以指定它映射具有不同名称的字段。在`Recommendation`服务的映射器类中，使用以下注解将`rating`实体字段映射到API模型字段`rate`：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After a successful Gradle build, the generated mapping implementation can be
    found in the `build/classes` folder, for example, the `Product` service: `$BOOK_HOME/Chapter06/microservices/product-service/build/classes/java/main/se/magnus/microservices/core/product/services/ProductMapperImpl.java`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 成功构建Gradle后，生成的映射实现可以在`build/classes` 文件夹中找到，例如，`Product`服务：`$BOOK_HOME/Chapter06/microservices/product-service/build/classes/java/main/se/magnus/microservices/core/product/services/ProductMapperImpl.java`。
- en: 'The source code for the three mapper classes can be found at the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 三个映射器类的源代码可以在以下位置找到：
- en: '`se.magnus.microservices.core.product.services.ProductMapper` in the `product`
    project'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.services.ProductMapper` 在 `product` 项目中'
- en: '`se.magnus.microservices.core.recommendation.services.RecommendationMapper` in
    the `recommendation` project'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.services.RecommendationMapper` 在 `recommendation` 项目中'
- en: '`se.magnus.microservices.core.review.services.ReviewMapper` in the `review`
    project'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.services.ReviewMapper` 在 `review` 项目中'
- en: Updating the service tests
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新服务测试
- en: The tests of the APIs exposed by the core microservices have been updated since
    the previous chapter with tests on the create and delete API operations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 自上一章以来，核心微服务暴露的API的测试已经更新，增加了对创建和删除API操作的测试。
- en: The added tests are similar in all three core microservices, so we will only
    go through the source code for the service tests in the `Product` microservice.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的测试在三个核心微服务中都是相似的，所以我们只查看`Product`微服务中的服务测试源代码。
- en: 'To ensure a known state for each test, a setup method, `setupDb()`, is declared
    and annotated with `@Before`, so it runs before each test runs. The setup method
    removes any previously created entities:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个测试都有一个已知的状态，声明了一个设置方法，`setupDb()`，并用 `@Before` 注解，这样它会在每个测试运行之前运行。设置方法移除了之前创建的任何实体：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The test method for the create API verifies that a product entity can be retrieved
    after it has been created and that creating another product entity with the same
    `productId` results in an expected error, `UNPROCESSABLE_ENTITY`, in the response
    to the API request:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 API 的测试方法验证了一个产品实体在创建后可以被检索到，并且使用相同的 `productId` 创建另一个产品实体会导致预期的错误，`UNPROCESSABLE_ENTITY`，在
    API 请求的响应中：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The test method for the delete API verifies that a product entity can be deleted
    and that a second delete request is idempotent—it also returns the status code
    OK, even though the entity no longer exists in the database:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 API 的测试方法验证了一个产品实体可以被删除，并且第二个删除请求是幂等的——它还返回了状态码 OK，即使实体在数据库中已不再存在：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To simplify sending the create, read, and delete requests to the API and verify
    the response status, three helper methods have been created:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化向 API 发送创建、读取和删除请求并验证响应状态，已经创建了三个辅助方法：
- en: '`postAndVerifyProduct()`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postAndVerifyProduct()`'
- en: '`getAndVerifyProduct()`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAndVerifyProduct()`'
- en: '`deleteAndVerifyProduct()`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleteAndVerifyProduct()`'
- en: 'The `postAndVerifyProduct()` method looks like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`postAndVerifyProduct()` 方法看起来是这样的：'
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Added to performing the actual HTTP request and verifying its response code,
    the helper method also returns the body of the response for further investigations
    by the caller, if required. The other two helper methods for read and delete requests
    are similar and can be found in the source code pointed out at the beginning of
    this section.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了执行实际的 HTTP 请求并验证其响应码外，辅助方法还将响应的正文返回给调用者进行进一步调查，如果需要的话。另外两个用于读取和删除请求的辅助方法类似，可以在本节开头指出的源代码中找到。
- en: 'The source code for the three service tests classes can be found at the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 三个服务测试类的源代码可以在以下位置找到：
- en: '`se.magnus.microservices.core.product.ProductServiceApplicationTests` in the `product`
    project'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.ProductServiceApplicationTests` 在 `product`
    项目中'
- en: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests` in
    the `recommendation` project'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests`
    在 `recommendation` 项目中'
- en: '`se.magnus.microservices.core.review.ReviewServiceApplicationTests` in the `review`
    project'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.review.ReviewServiceApplicationTests` 在 `review`
    项目中'
- en: Now, lets move on to seeing how we extend a composite service API.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何扩展复合服务 API。
- en: Extending the composite service API
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展复合服务 API
- en: 'In this section, we will see how we can extend the composite API with operations
    for creating and deleting composite entities. We will go through the following
    steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何扩展复合 API 以创建和删除复合实体。我们将按照以下步骤进行：
- en: Adding new operations in the composite service API
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在复合服务 API 中添加新操作
- en: Adding methods in the integration layer
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集成层中添加方法
- en: Implementing the new composite API operations
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现新的复合 API 操作
- en: Updating the composite service tests
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新复合服务测试
- en: Adding new operations in the composite service API
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在复合服务 API 中添加新操作
- en: 'The composite versions of creating and deleting entities and handling aggregated
    entities are similar to the create and delete operations in the core service APIs.
    The major difference is that they have annotations added for Swagger-based documentation. For
    an explanation of the usage of the Swagger annotations, `@ApiOperation` and `@ApiResponses`, 
    refer to [Chapter 5](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml), *Adding API
    Description Using OpenAPI/Swagger*, the section, *Adding API specific documentation
    in ProductCompositeService*. The API operation for creating a composite product
    entity is declared as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和删除实体的复合版本以及处理聚合实体的方法与核心服务 API 中的创建和删除操作相似。主要区别在于，它们添加了用于基于 Swagger 的文档的注解。有关
    Swagger 注解的使用说明，请参阅 [第 5 章](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml)，*使用 OpenAPI/Swagger
    添加 API 描述* 节，*在 ProductCompositeService 中添加 API 特定文档*。创建复合产品实体的 API 操作声明如下：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The API operation for deleting a composite product entity is declared as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 删除复合产品实体的 API 操作声明如下：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For the full source code, see the Java interface, `se.magnus.api.composite.product.ProductCompositeService`,
    in the `api` project.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码，请参阅`api`项目中的Java接口`se.magnus.api.composite.product.ProductCompositeService`。
- en: 'We also need to, as before, add the descriptive text of the API documentation
    to the property file, `application.yml`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要像以前一样，将 API 文档的描述性文本添加到属性文件`application.yml`中：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For details, see the configuration file, `src/main/resources/application.yml`,
    in the `product-composite` project.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 具体细节，请查看`product-composite`项目中的`src/main/resources/application.yml`配置文件。
- en: 'The updated Swagger documentation will look like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的 Swagger 文档将如下所示：
- en: '![](img/52f270b1-6039-4d6e-ad95-f4a9a7029063.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52f270b1-6039-4d6e-ad95-f4a9a7029063.png)'
- en: Later on in this chapter, we will user the Swagger UI to try out the new composite
    API operations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将使用 Swagger UI 来尝试新的组合 API 操作。
- en: Adding methods in the integration layer
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集成层中添加方法
- en: Before we can implement the new create and delete APIs in the composite services, we
    need to extend the integration layer so it can call the underlying create and
    delete operations in the APIs of the core microservices.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够实现组合服务中的新创建和删除 API 之前，我们需要扩展集成层，使其能够调用核心微服务 API 中的底层创建和删除操作。
- en: The methods in the integration layer for calling the create and delete operations
    in the three core microservices are straightforward and similar to each other,
    so we will only go through the source code for the methods that call the `Product` microservice.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 调用三个核心微服务中的创建和删除操作的集成层方法简单且彼此相似，所以我们只查看调用`Product`微服务的方法的源代码。
- en: 'The `createProduct()` method looks like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`createProduct()`方法看起来像这样：'
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It simply delegates the responsibility of sending the HTTP request to the `RestTemplate`
    object and delegates error handling to the helper method, `handleHttpClientException`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它简单地将发送 HTTP 请求的责任委托给`RestTemplate`对象，并将错误处理委托给助手方法`handleHttpClientException`。
- en: 'The `deleteProduct()` method looks like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`deleteProduct()`方法看起来像这样：'
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is implemented in the same way as for the create method, but performs an
    HTTP delete request instead.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它的实现方式与创建方法相同，但执行的是 HTTP 删除请求。
- en: The full source code for the integration layer can be seen in the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class in
    the `product-composite` project.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 集成层完整的源代码可以在`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类中找到。
- en: Implementing the new composite API operations
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现新的组合 API 操作
- en: Now, we can implement the composite create and delete methods!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现组合的创建和删除方法！
- en: 'The composite''s create method will split up the aggregate product object into
    discrete objects for `product`, `recommendation`, and `review` and call the corresponding
    create methods in the integration layer:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的创建方法会将聚合产品对象拆分为`product`、`recommendation`和`review`的独立对象，并在集成层中调用相应的创建方法：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The composite''s delete method simply calls the three delete methods in the
    integration layer to delete the corresponding entities in the underlying databases:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '组合的删除方法 simply calls the three delete methods in the integration layer to delete
    the corresponding entities in the underlying databases:'
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class in
    the `product-composite` project.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码，请参阅`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl`类。
- en: For happy day scenarios, this implementation will work fine, but if we consider
    various error scenarios this implementation will cause trouble!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于快乐路径场景，这个实现会很好，但如果我们考虑各种错误场景，这个实现将会带来麻烦！
- en: What if, for example, one of the underlying core microservices temporarily is
    not available, for example, due to internal, network, or database problems?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果底层的核心微服务之一暂时不可用，可能是由于内部、网络或数据库问题，那该怎么办？
- en: This might result in partly created or deleted composite products. For the delete
    operation, this can be fixed if the requestor simply calls the composite's delete
    method until it succeeds. However, if the underlying problem remains for a while,
    the requestor will probably give up, resulting in an inconsistent state of the
    composite product—not acceptable in most cases!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致部分创建或删除的组合产品。对于删除操作，如果请求者简单地调用组合的删除方法直到成功，这可以得到修复。然而，如果底层问题持续一段时间，请求者可能会放弃，导致组合产品的不一致状态——在大多数情况下这是不可接受的！
- en: In the next chapter, [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing
    Reactive Microservices*, we will see how we can address these types of shortcomings
    with synchronous APIs as a RESTful API!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章[第7章](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml)中，*开发反应式微服务*，我们将了解如何使用同步API（如RESTful
    API）来解决这些问题！
- en: For now, let's move on with this fragile design in mind.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们带着这个脆弱的设计继续前进。
- en: Updating the composite service tests
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新组合服务测试：
- en: 'Testing composite services, as already mentioned in [Chapter 3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating
    a Set of Cooperating Microservices* (refer to the *Automated tests of microservices
    in isolation *section), are limited to using simple mock components instead of
    the actual core services. This restricts us from testing more complex scenarios,
    for example, error handling when trying to create duplicates in the underlying
    databases. The tests of the composite create and delete API operations are therefore
    relatively simple:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第3章](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml)中提到的*创建一组协作微服务*（参考*隔离微服务的自动化测试*部分），测试组合服务限于使用简单的模拟组件而不是实际的核心服务。这限制了我们测试更复杂场景的能力，例如，在尝试在底层数据库中创建重复项时的错误处理。组合的创建和删除API操作的测试相对简单：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For the full source code, see the test class, `se.magnus.microservices.composite.product.ProductCompositeServiceApplicationTests`,
    in the `product-composite` project.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码，请参阅`product-composite`项目中的测试类，`se.magnus.microservices.composite.product.ProductCompositeServiceApplicationTests`。
- en: Next, we will see how to add databases to the landscape of Docker Compose.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将了解如何将数据库添加到Docker Compose的景观中。
- en: Adding databases to the Docker Compose landscape
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Docker Compose景观添加数据库：
- en: Now, we have all of the source code in place. Before we can start up the microservice
    landscape and try out the new APIs together with the new persistence layer, we
    must start up some databases.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将所有源代码放到位。在我们能够启动微服务景观并尝试新的API以及新的持久层之前，我们必须启动一些数据库。
- en: We will bring MongoDB and MySQL into the system landscape controlled by Docker
    Compose and add configuration to our microservices so that they can find their
    databases when running, either with or without running as a Docker container.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把MongoDB和MySQL带入由Docker Compose控制的系统景观，并向我们的微服务添加配置，以便它们在运行时能够找到它们的数据库，无论是否作为Docker容器运行。
- en: The Docker Compose configuration
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose配置：
- en: 'MongoDB and MySQL are declared as follows in the Docker Compose configuration
    file, `docker-compose.yml`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB和MySQL在Docker Compose配置文件`docker-compose.yml`中声明如下：
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following is observed from the preceding code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面代码中观察到的：
- en: We will use the official Docker image for MongoDB V3.6.9 and MySQL 5.7 and forward
    their default ports `27017` and `3306` to the Docker host, also made available
    on `localhost` when using Docker for Mac.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用官方的MongoDB V3.6.9和MySQL 5.7 Docker镜像，并将它们的默认端口`27017`和`3306`转发到Docker主机，在Mac上使用Docker时也可在`localhost`上访问。
- en: 'For MySQL, we also declare some environment variables, defining the following:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于MySQL，我们还声明了一些环境变量，定义如下：
- en: The root password
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: root密码：
- en: The name of the database that will be created on image startup
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将在图像启动时创建的数据库的名称：
- en: A username and password for a user that is set up for the database on image
    startup
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在图像启动时为数据库设置的用户设置用户名和密码：
- en: For MySQL, we also declare a health check that Docker will run to determine
    the status of the MySQL database.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于MySQL，我们还声明了一个健康检查，Docker将运行该检查以确定MySQL数据库的状态。
- en: 'To avoid problems with microservices that try to connect to their databases
    before the database is up and running,  the `product` and `recommendation` services
    are declared dependent on the `mongodb` database, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免微服务在数据库启动之前尝试连接到它们的数据库的问题，`product`和`recommendation`服务被声明为依赖于`mongodb`数据库，如下所示：
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This means that Docker Compose will not start up the `product` and `recommendation`
    containers until the `mongodb` container is launched.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Docker Compose将在启动`mongodb`容器后启动`product`和`recommendation`容器。
- en: 'For the same reason, the `review` service is declared dependent on the `mysql`
    database:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，`review`服务被声明为依赖于`mysql`数据库：
- en: '[PRE47]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this case, the `review` service depends on the fact that the `mysql` container
    is not only launched, but also that the `mysql` containers health check reports
    are okay. The reason for this extra step is that the initialization of the `mysql`
    container includes setting up a database and creating a superuser for the database.
    This takes a few seconds and, to hold back the `review` service to startup before
    this is done, we direct Docker Compose to hold back the `review` container from
    being launched until the `mysql` container reports that it is operational through
    its health check.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`review`服务依赖于不仅启动了`mysql`容器，而且`mysql`容器的健康检查报告也正常。之所以采取这一额外步骤，是因为`mysql`容器的初始化包括设置数据库并创建数据库超级用户。这需要几秒钟，为了在完成此操作之前阻止`review`服务启动，我们指示Docker
    Compose在`mysql`容器通过其健康检查报告正常之前，不要启动`review`容器。
- en: Database connect configuration
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库连接配置
- en: With the database in place, we now need to set up the configuration for the
    core microservices so they know how to connect to their databases. This is set
    up in each core microservice's configuration file, `src/main/resources/application.yml`,
    in the `product`, `recommendation`, and `review` projects.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有了数据库之后，我们现在需要为核心微服务设置配置，以便它们知道如何连接到其数据库。这在每个核心微服务的配置文件`src/main/resources/application.yml`中进行设置，位于`product`，`recommendation`和`review`项目中。
- en: 'The configuration for the `product` and `recommendation` services are similar,
    so we will only look into the configuration of the `product` services. The following
    part of the configuration is of interest:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`和`recommendation`服务的配置类似，所以我们只查看`product`服务的配置。以下配置部分值得关注：'
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is observed from the preceding code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面代码中观察到的：
- en: When running without Docker using the default Spring profile, the database is
    expected to be reachable on `localhost:27017`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有Docker的情况下运行，使用默认的Spring配置文件，期望数据库可以在`localhost:27017`上访问。
- en: Setting the log level for `MongoTemplate` to `DEBUG` will allow us to see which
    MongoDB statements are executed in the log.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MongoTemplate`的日志级别设置为`DEBUG`将允许我们查看在日志中执行了哪些MongoDB语句。
- en: When running inside Docker using the Spring profile, `Docker`, the database
    is expected to be reachable on `mongodb:27017`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用Spring配置文件运行Docker内部时，`Docker`，数据库期望可以在`mongodb:27017`上访问。
- en: 'The configuration for the `review` service, which affects how it connects to
    its SQL database, looks like the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 影响`review`服务如何连接其SQL数据库的配置如下所示：
- en: '[PRE49]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is observed from the preceding code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面代码中观察到的：
- en: By default, Hibernate will be used by Spring Data JPA as the JPA Entity Manager.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Data JPA将使用Hibernate作为JPA实体管理器。
- en: The `spring.jpa.hibernate.ddl-auto` property is used to tell Spring Data JPA
    to create new or update existing SQL tables during startup.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`spring.jpa.hibernate.ddl-auto`属性用于告诉Spring Data JPA在启动期间创建新的或更新现有的SQL表。'
- en: '**Note:** It is strongly recommended to set the `spring.jpa.hibernate.ddl-auto` property to
    `none` in a production environment—this prevents Spring Data JPA to manipulate
    the structure of the SQL tables.'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意：**强烈建议在生产环境中将`spring.jpa.hibernate.ddl-auto`属性设置为`none`——这防止Spring Data
    JPA操作SQL表的结构。'
- en: When running without Docker, using the default Spring profile, the database
    is expected to be reachable on `localhost` using the default port `3306`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在没有Docker的情况下运行，使用默认的Spring配置文件，期望数据库可以在`localhost`上使用默认端口`3306`访问。
- en: By default, HikariCP is used by Spring Data JPA as the JDBC connection pool. To
    minimize startup problems on computers with limited hardware resources, the `initializationFailTimeout`
    parameter is set to 60 seconds. This means that the Spring Boot application will
    wait for up to 60 seconds during startup to establish a database connection.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Data JPA使用HikariCP作为JDBC连接池。为了在硬件资源有限的计算机上最小化启动问题，将`initializationFailTimeout`参数设置为60秒。这意味着Spring
    Boot应用程序在启动期间会等待最多60秒以建立数据库连接。
- en: The log level settings for Hibernate will cause Hibernate to print the SQL statements
    used and the actual values used. Please note that, when used in a production environment,
    writing the actual values to the log should be avoided for privacy reasons.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hibernate的日志级别设置会导致Hibernate打印使用的SQL语句和实际值。请注意，在生产环境中，出于隐私原因，应避免将实际值写入日志。
- en: When running inside Docker using the Spring profile, `Docker`, the database
    is expected to be reachable on the `mysql` hostname using the default port `3306`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用Spring配置文件`Docker`在Docker内运行时，数据库预期可以通过`mysql`主机名使用默认端口`3306`可达。
- en: The MongoDB and MySQL CLI tools
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB和MySQL CLI工具
- en: To be able to run the database CLI tools, the Docker Compose `exec` command
    can be used.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行数据库CLI工具，可以使用Docker Compose `exec`命令。
- en: The commands described in this section will be used when we get to the manual
    tests in the next section. Don't try to run them now; they will fail since we
    have no databases up and running yet!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的命令将在下一节的手动测试中使用。现在不要尝试运行它们；因为我们现在还没有运行数据库，所以它们会失败！
- en: 'To start the MongoDB CLI tool, `mongo`, inside the `mongodb` container, run
    the following command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动MongoDB CLI工具`mongo`，在`mongodb`容器内运行以下命令：
- en: '[PRE50]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Enter `exit` to leave the `mongo` CLI.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`exit`以离开`mongo` CLI。
- en: 'To start the MySQL CLI tool, `mysql`, inside the `mysql` container and log
    in to `review-db` using the user created at startup, run the following command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动MySQL CLI工具`mysql`，在`mysql`容器内并使用启动时创建的用户登录到`review-db`，请运行以下命令：
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `mysql` CLI tool will prompt you for a password; you can find it in the
    `docker-compose.yml` file. Look for the value of the environment variable, `MYSQL_PASSWORD`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql` CLI工具将提示您输入密码；您可以在`docker-compose.yml`文件中找到它。查找环境变量的值`MYSQL_PASSWORD`。'
- en: Enter `exit` to leave the `mysql` CLI.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`exit`以离开`mysql` CLI。
- en: We will see the usage of these tools in the next section.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节看到这些工具的使用。
- en: If you prefer graphical database tools, you can run them locally as well, since
    both the MongoDB and the MySQL containers expose their standard ports on localhost.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢图形数据库工具，您也可以本地运行它们，因为MongoDB和MySQL容器都将在本地主机上暴露它们的标准端口。
- en: Manual tests of the new APIs and the persistence layer
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对新API和持久化层进行手动测试。
- en: Now, it is finally time to start everything up and test it manually using the
    Swagger UI.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，终于可以启动一切并使用Swagger UI进行手动测试了。
- en: 'Build and start the system landscape with the following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建并启动系统架构：
- en: '[PRE52]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Open the Swagger UI in a web browser, `http://localhost:8080/swagger-ui.html`,
    and perform the following steps on the web page:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络浏览器中打开Swagger UI，`http://localhost:8080/swagger-ui.html`，并在网页上执行以下步骤：
- en: Click on product-composite-service-impl and the POST method to expand them.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击产品组合服务实现（product-composite-service-impl）和POST方法以展开它们。
- en: Click on the Try it out button and go down to the body field.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击尝试一下（Try it out）按钮并下移到正文字段。
- en: Replace the default value, `0`,  of the `productId` field with `123456`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`productId`字段的默认值`0`替换为`123456`。
- en: Scroll down to the Execute button and click on it.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到底部的执行按钮并点击它。
- en: Verify that the returned response code is `200`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证返回的响应码是`200`。
- en: 'Following is a sample screenshot after hitting the Execute button:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 点击执行按钮后的示例屏幕截图如下：
- en: '![](img/eb728f85-f6b7-42e9-89a2-41ed11559551.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb728f85-f6b7-42e9-89a2-41ed11559551.png)'
- en: 'In the log output from the `docker-compose up` command, we should be able to
    see output like the following (abbreviated for increased readability):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从`docker-compose up`命令的日志输出中，我们应该能够看到如下输出（为了提高可读性而简化）：
- en: '![](img/1b2a26c1-fe45-49c0-95e9-9a8d4384351e.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b2a26c1-fe45-49c0-95e9-9a8d4384351e.png)'
- en: We can also use the database CLI tools to see the actual content in the different
    databases.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用数据库CLI工具来查看不同数据库中的实际内容。
- en: 'Look up content in the `product` service, that is, the `products` collection
    in MongoDB, with the following command:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`product`服务中查找内容，即MongoDB中的`products`集合，使用以下命令：
- en: '[PRE53]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Expect a response like:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到如下响应：
- en: '![](img/0b57bb76-075c-4cfd-9d65-43d2760a8200.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b57bb76-075c-4cfd-9d65-43d2760a8200.png)'
- en: 'Look up content in the `recommendation` service, that is, the `recommendations` collection
    in MongoDB, with the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recommendation`服务中查找内容，即MongoDB中的`recommendations`集合，使用以下命令：
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Expect a response like:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到如下响应：
- en: '![](img/12d6b674-b3ac-4819-9fc8-5423d00c17af.png)10'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/12d6b674-b3ac-4819-9fc8-5423d00c17af.png)10'
- en: 'Look up content in the `review` service, that is, the `reviews` table in MySQL, with
    the following command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在`review`服务中查找内容，即MySQL中的`reviews`表，使用以下命令：
- en: '[PRE55]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `mysql` CLI tool will prompt you for a password; you can find it in the `docker-compose.yml` file.
    Look for the value of the environment variable, `MYSQL_PASSWORD`. Expect a response
    like the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql` CLI工具将提示您输入密码；您可以在`docker-compose.yml`文件中找到它。查找环境变量的值`MYSQL_PASSWORD`。预期得到如下响应：'
- en: '![](img/b408949c-fb6d-4b76-8976-556538b135d2.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b408949c-fb6d-4b76-8976-556538b135d2.png)'
- en: Bring down the system landscape by interrupting the `docker-compose up` command
    with *Ctrl + C*, followed by the command, `docker-compose down`. After this, let
    us see how to update the automated tests in a microservice landscape.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按下*Ctrl + C*中断`docker-compose up`命令，然后执行`docker-compose down`命令，可以关闭系统环境。之后，我们将看看如何在微服务环境中更新自动化测试。
- en: Updating the automated tests of the microservice landscape
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新微服务环境的自动化测试
- en: The automated tests of the microservice landscape, `test-em-all.bash`, needs
    to be updated so that they ensure that the database of each microservice has a
    known state before it runs the tests.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务环境的自动化测试`test-em-all.bash`需要更新，以确保在运行测试之前，每个微服务数据库都处于已知状态。
- en: The script is extended with a setup function, `setupTestdata()`, which uses
    the composite's create and delete APIs to recreate the products that the tests
    use into a known state.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本增加了一个设置函数`setupTestdata()`，该函数使用组合实体的创建和删除API将测试使用的产品重新创建到已知状态。
- en: 'The `setupTestdata` function looks like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupTestdata`函数如下所示：'
- en: '[PRE56]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It uses a helper function, `recreateComposite()`, to perform the actual requests
    to the create and delete APIs:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一个辅助函数`recreateComposite()`来对创建和删除API执行实际的请求：
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `setupTestdata` function is called directly after the `waitForService`
    function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupTestdata`函数在`waitForService`函数之后直接调用：'
- en: '[PRE58]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The main purpose of the `waitForService` function is to verify that all microservices
    are up and running. In the previous chapter, the get API on the composite product
    service was used. In this chapter, the delete API is used instead. When using
    the get API, only the product core microservice is called if the entity is not
    found; the recommendation and `review` services will not be called to verify that
    they are up and running. The call to the delete API will also ensure that the
    *Not Found*-test on `productId 13` will succeed. Later on in this book, we will
    see how we can define specific APIs for checking the health state of a microservice
    landscape.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForService`函数的主要目的是验证所有微服务是否都已启动并运行。在前一章节中，使用了组合产品服务的get API。在本章节中，我们使用的是delete
    API。使用get API时，如果找不到实体，只会调用产品核心微服务；推荐和`review`服务不会被调用以验证它们是否启动并运行。调用delete API也将确保`productId
    13`的*未找到*测试成功。在本书的后面部分，我们将了解如何为检查微服务环境的运行状态定义特定的API。'
- en: 'Execute the updated test script with the following command:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可执行更新后的测试脚本：
- en: '[PRE59]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The execution should end by writing a log message like this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 执行应该以编写如下日志消息结束：
- en: '![](img/bcd02c04-4291-440a-96e4-0660e2792679.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcd02c04-4291-440a-96e4-0660e2792679.png)'
- en: This ends updating of the automated tests of the microservice landscape.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了微服务环境的自动化测试的更新。
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how we can use Spring Data to add a persistence
    layer to the core microservices. We used the core concepts of Spring Data, repositories
    and entities, to store data in both MongoDB and MySQL using a programming model
    that is similar, even though not fully portable. We have also seen how Spring
    Boot's annotations, `@DataMongoTest` and `@DataJpaTest`, can be used to conveniently
    set up tests targeted for persistence; this is where an embedded database is started
    automatically before the test runs, but no other infrastructure that the microservice
    will need in runtime, for example, a web server such as Netty, is started up.
    This results in persistence tests that are easy to set up and that start with
    minimum overhead.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，我们看到了如何使用Spring Data为核心微服务添加一个持久层。我们使用了Spring Data的核心概念，存储库和实体，在MongoDB和MySQL中以一种类似的编程模型存储数据，即使不是完全可移植的。我们还看到了Spring
    Boot的注解`@DataMongoTest`和`@DataJpaTest`如何用于方便地设置针对持久层的测试；在这种情况下，在测试运行之前自动启动嵌入式数据库，但不会启动微服务在运行时需要的其他基础架构，例如Netty这样的web服务器。这导致持久层测试易于设置，并且启动开销最小。
- en: We have also seen how the persistence layer can be used by the service layer
    and how we can add APIs for creating and deleting entities, both core and composite
    entities.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了持久层如何被服务层使用，以及我们如何为创建和删除实体（包括核心和组合实体）添加API。
- en: Finally, we learned how convenient it is to start up databases such as MongoDB
    and MySQL in runtime using Docker Compose and how to use the new create and delete
    APIs to set up test data before running automated tests of the microservice-based
    system landscape.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了使用Docker Compose在运行时启动MongoDB和MySQL等数据库是多么方便，以及如何使用新的创建和删除API在运行微服务基础系统景观的自动化测试之前设置测试数据。
- en: However, one major concern was identified in this chapter. Updating (creating
    or deleting) a composite entity—an entity whose parts are stored in a number of
    microservices—using synchronous APIs can lead to inconsistencies, if not all involved
    microservices are updated successfully. This is, in general, not acceptable. This
    leads us into the next chapter, where we will look into why and how to build reactive
    microservices, that is, microservices that are scalable and robust.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中识别出了一个主要问题。使用同步API更新（创建或删除）复合实体——一个其部分存储在多个微服务中的实体——如果不成功更新所有涉及的微服务，可能会导致不一致。这通常是不可接受的。这引导我们进入下一章，我们将探讨为什么以及如何构建响应式微服务，即可扩展和健壮的微服务。
- en: Questions
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Spring Data, a common programming model based on entities and repositories,
    can be used for different types of database engines. From the source code examples
    in this chapter, what are the most important differences in the persistence code
    for MySQL and MongoDB?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Data是一种基于实体和仓库的常见编程模型，可以用于不同类型的数据库引擎。从本章的源代码示例中，MySQL和MongoDB的持久化代码最重要的区别是什么？
- en: What is required to implement optimistic locking using Spring Data?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现乐观锁需要Spring Data提供什么？
- en: What is MapStruct used for?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MapStruct是用来做什么的？
- en: What does it mean that an operation is idempotent and why is that useful?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是幂等操作，为什么这很有用？
- en: How can we access the data that is stored in the MySQL and MongoDB databases without
    using the API?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在不使用API的情况下访问存储在MySQL和MongoDB数据库中的数据？
