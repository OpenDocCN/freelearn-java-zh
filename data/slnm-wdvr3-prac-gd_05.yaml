- en: Exploring Advanced Interactions of WebDriver
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 WebDriver 的高级交互
- en: 'In the previous chapter, we discussed the WebDriver interface and its features,
    including taking screenshots, working with Windows, frames, alerts, cookies, and
    synchronizing tests. In this chapter, we will go through some advanced ways of
    performing actions on WebElements. We will learn how to perform actions, using
    the actions API of Selenium WebDriver, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 WebDriver 接口及其功能，包括截图、与窗口、框架、警告、cookie 和同步测试。在本章中，我们将介绍一些在 WebElements
    上执行动作的高级方法。我们将学习如何使用 Selenium WebDriver 的 actions API 执行动作，包括以下内容：
- en: Complex mouse actions, such as moving the mouse, double-clicking, and dragging
    and dropping
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的鼠标动作，如移动鼠标、双击和拖放
- en: Keyboard shortcuts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘快捷键
- en: Understanding the build and perform actions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解构建和执行动作
- en: We know how to perform some basic actions, such as clicking on a button and
    typing text into a textbox; however, there are many scenarios where we have to
    perform multiple actions at the same time, for example, keeping the *Shift* button
    pressed and typing text for uppercase letters, and the dragging and dropping mouse
    actions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何执行一些基本动作，例如点击按钮和在文本框中输入文本；然而，有许多场景需要我们同时执行多个动作，例如，保持 *Shift* 按钮按下并输入大写字母，以及拖放鼠标动作。
- en: 'Let''s see a simple scenario here. Open the [http://guidebook.seleniumacademy.com/Selectable.html](http://guidebook.seleniumacademy.com/Selectable.html).
    A box of tiles numbered 1 to 12 will appear, as seen in this screenshot:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的场景。打开 [http://guidebook.seleniumacademy.com/Selectable.html](http://guidebook.seleniumacademy.com/Selectable.html)。将出现一个编号为
    1 到 12 的瓷砖盒子，如图所示：
- en: '![](img/83234a72-4071-496d-a528-be94774ba35b.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83234a72-4071-496d-a528-be94774ba35b.png)'
- en: 'If you inspect the elements with browser developer tools, you will see an ordered
    list tag:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用浏览器开发者工具检查元素，你会看到一个有序列表标签：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you click a number, its background color changes to orange. Try selecting
    the tiles 1, 3, and 5\. You do that by holding down *Ctrl* + tile 1 + tile 3 +
    tile 5\. This involves performing multiple actions, that is, holding *Ctrl* continuously
    and clicking on tiles 1, 3, and 5\. How do we perform these multiple actions using
    WebDriver? The following code demonstrates how:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击一个数字，其背景颜色将变为橙色。尝试选择 1、3 和 5 号瓷砖。你可以通过按下 *Ctrl* + 瓷砖 1 + 瓷砖 3 + 瓷砖 5 来完成这个操作。这涉及到执行多个动作，即持续按下
    *Ctrl* 并点击瓷砖 1、3 和 5。我们如何使用 WebDriver 执行这些多个动作？以下代码演示了如何操作：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, if you refer to the code, we are getting introduced to a new class named
    `Actions`. This `Actions` class is the one that is used to emulate all the complex
    user events. Using this, the developer of the test script could combine all the
    necessary user gestures into one composite action. We have declared all the actions
    that are to be executed to achieve the functionality of clicking on the numbers
    1, 3, and 5\. Once all the actions are grouped together, we build that into a
    composite action. `Action` is an interface that has only the `perform()` method,
    which executes the composite action. When we execute the test, tiles 1, 3, and
    5 will be selected one by one. Finally, tile 5 will be selected, as shown in this
    screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你参考代码，我们将介绍一个新的名为 `Actions` 的类。这个 `Actions` 类是用来模拟所有复杂用户事件的。使用它，测试脚本的开发者可以将所有必要的用户手势组合成一个复合动作。我们已经声明了所有要执行的动作，以实现点击数字
    1、3 和 5 的功能。一旦所有动作组合在一起，我们就将其构建成一个复合动作。"Action" 是一个只有 `perform()` 方法的接口，它执行复合动作。当我们执行测试时，1、3
    和 5 号瓷砖将被依次选中。最后，将选中 5 号瓷砖，如图所示：
- en: '![](img/3536f3af-e12e-48f4-8ec0-71bbded32f68.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3536f3af-e12e-48f4-8ec0-71bbded32f68.png)'
- en: 'So, to make WebDriver perform multiple actions at the same time, you need to
    follow a three-step process of using the user-facing API of the actions class
    to group all the actions, then build the composite action, and perform the action.
    This process can be made into a two-step process, as the `perform()` method internally
    calls the `build()` method. So the previous code will look as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要使 WebDriver 同时执行多个动作，你需要遵循使用动作类用户界面 API 的三个步骤：分组所有动作，然后构建复合动作，并执行动作。这个过程可以简化为两步，因为
    `perform()` 方法内部调用 `build()` 方法。所以之前的代码将如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we have directly invoked the `perform()` method on the
    `Actions` instance, which internally calls the `build()` method to create a composite
    action before executing it. In the subsequent sections of this chapter, we will
    take a closer look at the `Actions` class. All the actions are basically divided
    into two categories: mouse-based actions and keyboard-based actions. In the following
    sections, we will discuss all the actions that are specific to the mouse and keyboard
    available in the `Actions` class.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们直接在 `Actions` 实例上调用了 `perform()` 方法，它内部调用 `build()` 方法来创建一个复合动作并在执行之前创建它。在本章的后续部分，我们将更详细地研究
    `Actions` 类。所有动作基本上分为两类：基于鼠标的动作和基于键盘的动作。在接下来的部分中，我们将讨论 `Actions` 类中所有特定于鼠标和键盘的动作。
- en: Learning mouse based interactions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基于鼠标的交互
- en: There are around eight different mouse actions that can be performed using the
    actions class. We will see each of their syntax and a working example.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动作类可以执行大约八种不同的鼠标动作。我们将看到它们的语法和实际的工作示例。
- en: The moveByOffset action
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按偏移量移动的动作
- en: The `moveByOffset()` method is used to move the mouse from its current position
    to another point on the web page. Developers can specify the *x* distance and
    the *y* distance the mouse has to be moved. When the page is loaded, generally
    the initial position of the mouse would be (0, 0), unless there is an explicit
    focus declared by the page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveByOffset()` 方法用于将鼠标从当前位置移动到网页上的另一个点。开发者可以指定鼠标需要移动的 *x* 距离和 *y* 距离。当页面加载时，鼠标的初始位置通常是
    (0, 0)，除非页面有明确的焦点声明。'
- en: 'The API syntax for the `moveByOffset()` method is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveByOffset()` 方法的 API 语法如下：'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, `xOffSet` is the input parameter providing the WebDriver
    the amount of offset to be moved along the *x* axis. A positive value is used
    to move the cursor to the right, and a negative value is used to move the cursor
    to the left.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`xOffSet` 是一个输入参数，它为 WebDriver 提供了沿 *x* 轴移动的偏移量。正值用于将光标向右移动，负值用于将光标向左移动。
- en: '`yOffSet` is the input parameter providing the WebDriver the amount of offset
    to be moved along the *y* axis. A positive value is used to move the cursor down
    along the *y* axis, and a negative value is used to move the cursor toward the
    top.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`yOffSet` 是一个输入参数，它为 WebDriver 提供了沿 *y* 轴移动的偏移量。正值用于将光标沿 *y* 轴向下移动，负值用于将光标向上移动。'
- en: When the `xOffSet` and `yOffSet` values result in moving the cursor out of the
    document, a  `MoveTargetOutOfBounds` exception is raised.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `xOffSet` 和 `yOffSet` 的值导致光标移出文档时，会引发 `MoveTargetOutOfBounds` 异常。
- en: 'Let''s see a working example of it. The objective of the following code is
    to move the cursor on to tile 3 on the web page:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际的工作示例。以下代码的目标是将光标移动到网页上的第 3 个瓷砖上：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output will be as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/eabd86c4-a1fb-4b7a-b922-4fb254413d85.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eabd86c4-a1fb-4b7a-b922-4fb254413d85.png)'
- en: We have added `+1` to the coordinates, because if you observe the element in
    Firebug, we have a style border of 1 px. The border is a CSS-style attribute,
    which when applied to an element will add a border of the specified color around
    the element, with the specified amount of thickness. Though the previous code
    does move your mouse over tile 3, we don't realize this, because we are not performing
    any action there. We will see this shortly, when we use the `moveByOffset()` method
    in combination with the `click()` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在坐标中增加了 `+1`，因为如果你在 Firebug 中观察元素，我们有一个 1 px 的边框样式。边框是一个 CSS 样式属性，当应用于元素时，会在元素周围添加指定颜色和厚度的边框。尽管之前的代码确实将鼠标移动到了第
    3 个瓷砖上，但我们没有意识到这一点，因为我们没有在那里执行任何操作。我们将在使用 `moveByOffset()` 方法与 `click()` 方法结合时看到这一点。
- en: The click at current location action
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在当前位置点击的动作
- en: The `click()` method is used to simulate the left-click of your mouse at its
    current point of location. This method doesn't really realize where or on which
    element it is clicking. It just clicks wherever it is at that point in time. Hence,
    this method is used in combination with some other action, rather than independently,
    to create a composite action.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`click()` 方法用于模拟鼠标在其当前位置的左键点击。此方法实际上并不确定点击的位置或元素。它只是在那个时间点点击任何地方。因此，此方法通常与其他动作结合使用，而不是独立使用，以创建复合动作。'
- en: 'The API syntax for the `click()` method is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`click()` 方法的 API 语法如下：'
- en: '`public Actions click()`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`public Actions click()`.'
- en: 'The `click()` method doesn''t really have any context about where it is performing
    its action; hence, it doesn''t take any input parameter. Let''s see a code example
    of the `click()` method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`click()` 方法实际上并没有任何关于它在何处执行操作的上下文信息；因此，它不接收任何输入参数。让我们看看 `click()` 方法的代码示例：'
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the above example we have used a combination of the `moveByOffset()` and
    `click()` methods to move the cursor from point (0, 0) to the point of tile 7\.
    Because the initial position of the mouse is (0, 0), the *x*, *y* offset provided
    for the `moveByOffset()` method is nothing but the location of the tile 7 element.
    Now let''s try to move the cursor from tile 1 to tile 11, and from there to tile
    5, and see how the code looks. Before we get into the code, let''s inspect the
    `Selectable.html` page using Firebug. The following is the style of each tile:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们使用了 `moveByOffset()` 和 `click()` 方法的组合，将光标从点 (0, 0) 移动到 7 号瓷砖的位置。因为鼠标的初始位置是
    (0, 0)，所以 `moveByOffset()` 方法提供的 *x*、*y* 偏移量实际上就是 7 号瓷砖的位置。现在让我们尝试将光标从 1 号瓷砖移动到
    11 号瓷砖，然后从那里移动到 5 号瓷砖，看看代码是如何的。在我们进入代码之前，让我们使用 Firebug 检查 `Selectable.html` 页面。以下是每个瓷砖的样式：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The three elements with which we are concerned for our offset movement in the
    preceding style code are: `height`, `width`, and the `border` thickness. Here,
    the `height` value is `80px`, the `width` value is `100px`, and the `border` value
    is `1px`. Use these three factors to calculate the offset to navigate from one
    tile to the other. Note that the border thickness between any two tiles will result
    in `2 px`, that is, `1 px` from each tile. The following is the code that uses
    the `moveByOffset` and `click()` methods to navigate from tile 1 to tile 11, and
    from there to tile 5:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的样式代码中，我们关注于偏移量移动的三个元素是：`height`、`width` 和 `border` 厚度。在这里，`height` 值是 `80px`，`width`
    值是 `100px`，`border` 值是 `1px`。使用这三个因素来计算从一个瓷砖导航到另一个瓷砖的偏移量。请注意，任何两个瓷砖之间的边框厚度将产生
    `2 px`，即每个瓷砖各 `1 px`。以下是一个使用 `moveByOffset` 和 `click()` 方法从 1 号瓷砖导航到 11 号瓷砖，然后从那里导航到
    5 号瓷砖的代码示例：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The click on a WebElement action
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击 WebElement 的操作
- en: We have seen how to click a WebElement by calculating the offset to it. This
    process may not be needed every time, especially when the WebElement has its own
    identifiers, such as a name or an ID. We can use another overloaded version of
    the `click()` method to click directly on the WebElement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何通过计算偏移量来点击 WebElement。这个过程可能并不总是需要，尤其是当 WebElement 有自己的标识符时，比如名称或 ID。我们可以使用
    `click()` 方法的另一个重载版本来直接在 WebElement 上点击。
- en: 'The API syntax for clicking on a WebElement is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebElement 上点击的 API 语法如下：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The input parameter for this method is an instance of the WebElement on which
    the `click` action should be performed. This method, like all the other methods
    in the `Actions` class, will return an `Actions` instance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法输入参数是一个 WebElement 实例，该实例上的 `click` 操作将被执行。此方法，就像 `Actions` 类中的所有其他方法一样，将返回一个
    `Actions` 实例。
- en: 'Now let''s try to modify the previous code example to use the `click(WebElement)`
    method, instead of using the `moveByOffset()` method, to move to the location
    of the WebElement and click on it using the `click()` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试修改之前的代码示例，使用 `click(WebElement)` 方法而不是使用 `moveByOffset()` 方法来移动到 WebElement
    的位置，并使用 `click()` 方法点击它：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now the `moveByOffset()` method has been replaced by the `click(WebElement)`
    method, and, all of a sudden, the complex coordinate geometry has been removed
    from the code. If you're a tester, this is one more good reason to push your developers
    to provide identifiers for the WebElements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`moveByOffset()` 方法已经被 `click(WebElement)` 方法所取代，突然之间，复杂的坐标几何从代码中消失了。如果你是一名测试人员，这是推动你的开发者为
    WebElement 提供标识符的另一个好理由。
- en: 'If you observe the previous examples for the `moveByOffset` and `click` methods,
    all the operations of moving the mouse and clicking on tiles 1, 11, and 5 are
    built separately and performed separately. This is not how we use our `Actions`
    class. You can actually build all these actions together and then perform them.
    So, the preceding code will turn out to be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察了之前的 `moveByOffset` 和 `click` 方法的示例，所有移动鼠标和点击 1、11 和 5 号瓷砖的操作都是分别构建和执行的。这不是我们使用
    `Actions` 类的方式。您实际上可以将所有这些操作一起构建，然后执行。因此，前面的代码将变成如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The click and hold at current location action
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在当前位置点击并保持操作
- en: The `clickAndHold()` method is another method of the actions class that left-clicks
    on an element and holds it without releasing the left button of the mouse. This
    method will be useful when executing operations such as drag and drop. This method
    is one of the variants of the `clickAndHold()` method that the actions class provides.
    We will discuss the other variant in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`clickAndHold()`方法是`actions`类的一个方法，它会在元素上左击并按住，而不释放鼠标的左键。这个方法在执行如拖放等操作时非常有用。这是`actions`类提供的`clickAndHold()`方法的变体之一。我们将在下一节讨论另一个变体。'
- en: 'Now open the `Sortable.html` file that came with the book. You can see that
    the tiles can be moved from one position to the other. Now let''s try to move
    tile 3 to the position of tile 2. The sequence of steps that are involved to do
    this are the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开随书附带的`Sortable.html`文件。你可以看到瓷砖可以从一个位置移动到另一个位置。现在让我们尝试将瓷砖3移动到瓷砖2的位置。完成此操作涉及的步骤如下：
- en: Move the cursor to the position of tile 3.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标移动到瓷砖3的位置。
- en: Click and hold tile 3.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并按住瓷砖3。
- en: Move the cursor in this position to tile 2's location.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标移动到这个位置到瓷砖2的位置。
- en: 'Now let''s see how this can be accomplished, using the WebDriver''s `clickAndHold()`
    method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用WebDriver的`clickAndHold()`方法来完成这个操作：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s analyze the following line of code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析以下代码行：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The tile movement will be similar to the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 瓷砖移动将与以下截图类似：
- en: '![](img/944e4722-7d84-4f9e-9483-70df3f8ed449.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/944e4722-7d84-4f9e-9483-70df3f8ed449.png)'
- en: First, we move the cursor to the location of tile 3. Then, we click and hold
    tile 3. Then, we move the cursor by `120px` horizontally to the position of tile
    2\. The last line performs all the preceding actions. Now execute this in your
    eclipse and see what happens. If you observe closely, tile 3 doesn't properly
    go into the position of tile 2\. This is because we are yet to release the left
    button. We just commanded the WebDriver to click and hold, but not to release.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将光标移动到瓷砖3的位置。然后，我们点击并按住瓷砖3。然后，我们将光标水平移动`120px`到瓷砖2的位置。最后一行执行所有前面的操作。现在在你的Eclipse中执行这个操作，看看会发生什么。如果你仔细观察，瓷砖3并没有正确地移动到瓷砖2的位置。这是因为我们还没有释放左键。我们只是命令WebDriver点击并按住，但没有释放。
- en: The click and hold a WebElement action
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击并按住`WebElement`操作
- en: In the previous section, we have seen the `clickAndHold()` method, which will
    click and hold a WebElement at the current position of the cursor. It doesn't
    care about which element it is dealing with. So, if we want to deal with a particular
    WebElement on the web page, we have to first move the cursor to the appropriate
    position and then perform the `clickAndHold()` action. To avoid the hassle of
    moving the cursor geometrically, WebDriver provides the developers with another
    variant or overloaded method of the `clickAndHold()` method that takes the WebElement
    as input.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了`clickAndHold()`方法，它会在光标当前位置点击并按住一个`WebElement`。它不关心它处理的是哪个元素。所以，如果我们想处理网页上的特定`WebElement`，我们必须首先将光标移动到适当的位置，然后执行`clickAndHold()`操作。为了避免在几何上移动光标的麻烦，WebDriver为开发者提供了`clickAndHold()`方法的另一个变体或重载方法，该方法接受`WebElement`作为输入。
- en: 'The API syntax is this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: API语法如下：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The input parameter for this method is the WebElement that has to be clicked
    and held. The return type, as in all the other methods of the `Actions` class,
    is the `Actions` instance. Now let''s refactor the example in the previous section
    to use this method, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的输入参数是要点击并按住的`WebElement`。返回类型，如`Actions`类的所有其他方法一样，是`Actions`实例。现在让我们重构上一节的示例，使用此方法，如下所示：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The only change is that we have removed the action of moving the cursor to the
    `(200, 20)` position and provided the WebElement to the `clickAndHold()` method
    that will take care of identifying the WebElement.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是我们已经移除了将光标移动到`(200, 20)`位置的操作，并提供了`WebElement`给`clickAndHold()`方法，该方法将负责识别`WebElement`。
- en: The release at current location action
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在当前位置释放操作
- en: Now, in the previous example, we have seen how to click and hold an element.
    The ultimate action that has to be taken on a held WebElement is to release it
    so that the element can be dropped or released from the mouse. The `release()`
    method is the one that can release the left mouse button on a WebElement.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在之前的示例中，我们看到了如何点击并按住一个元素。对按住的`WebElement`必须采取的最终操作是释放它，以便元素可以被放下或从鼠标中释放。`release()`方法是可以在`WebElement`上释放左鼠标按钮的方法。
- en: The API syntax for the `release()` method is as follows: `public Actions release()`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`release()` 方法的 API 语法如下：`public Actions release()`。'
- en: The preceding method doesn't take any input parameter and returns the `Actions`
    class instance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法不接收任何输入参数，并返回 `Actions` 类的实例。
- en: 'Now, let''s modify the previous code to include the `release` action in it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改之前的代码，使其包含 `release` 动作：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code will make sure that the mouse is released at the specified
    location.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将确保鼠标在指定位置释放。
- en: The release on another WebElement action
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在另一个 WebElement 上释放动作
- en: This is an overloaded version of the `release()` method. Using this, you can
    actually release the currently held WebElement in the middle of another WebElement.
    In this way, we don't have to calculate the offset of the target WebElement from
    the held WebElement.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `release()` 方法的重载版本。使用它，你实际上可以在另一个 WebElement 的中间释放当前持有的 WebElement。这样，我们就不必计算目标
    WebElement 从持有 WebElement 的偏移量。
- en: 'The API syntax is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: API 语法如下：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The input parameter for the preceding method is obviously the target WebElement,
    where the held WebElement should be dropped. The return type is the instance of
    the `Actions` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的输入参数显然是鼠标应该释放到的目标 WebElement。返回类型是 `Actions` 类的实例。
- en: 'Let''s modify the preceding code example to use this method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面的代码示例以使用此方法：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Look at how simple the preceding code is. We have removed all the `moveByOffset`
    code and added the `release()` method that takes the WebElement with the name
    `two` as the input parameter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的代码有多简单。我们移除了所有的 `moveByOffset` 代码，并添加了以名为 `two` 的 WebElement 作为输入参数的 `release()`
    方法。
- en: Invoking the `release()` or `release(WebElement)` methods without calling the
    `clickAndHold()` method will result in an undefined behavior.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在不调用 `clickAndHold()` 方法的情况下调用 `release()` 或 `release(WebElement)` 方法将导致未定义的行为。
- en: The moveToElement action
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动到元素动作
- en: The `moveToElement()` method is another method of WebDriver that helps us to
    move the mouse cursor to a WebElement on the web page.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveToElement()` 方法是 WebDriver 的另一种方法，帮助我们将鼠标光标移动到网页上的 WebElement。'
- en: 'The API syntax for the `moveToElement()` method is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveToElement()` 方法的 API 语法如下：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The input parameter for the preceding method is the target WebElement, where
    the mouse should be moved. Now go back to the `clickAndHold` at *current location
    action* section of this chapter and try to modify the code to use this method.
    The following is the code we have written in *The click-and-hold-at-current-location
    action* section:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的输入参数是鼠标应该移动到的目标 WebElement。现在回到本章的 *当前位置点击并保持* 动作部分，尝试修改代码以使用此方法。以下是我们在
    *当前位置点击并保持动作* 部分编写的代码：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we will replace the `moveByOffset(x, y)` method with
    the `moveToElement(WebElement)` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将用 `moveToElement(WebElement)` 方法替换 `moveByOffset(x, y)` 方法：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we have moved to tile 3, clicked and held it, and then
    moved to the location of tile 2, by specifying its offset. If you want, you can
    add the `release()` method before the `perform()` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经移动到第 3 个方块，点击并保持，然后通过指定其偏移量移动到第 2 个方块的位置。如果你愿意，你可以在 `perform()`
    方法之前添加 `release()` 方法。
- en: There might be a number of ways to achieve the same task. It is up to the user
    to choose the appropriate ones that best suit the given circumstances.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实现同一任务可能有多种方式。用户需要根据具体情况选择最合适的方案。
- en: The dragAndDropBy action
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放动作
- en: There might be many instances where we may have to drag and drop components
    or WebElements of a web page. We can accomplish that by using many of the actions
    seen until now. But WebDriver has given us a convenient out-of-the-box method
    to use. Let's see its API syntax.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可能需要拖放网页上的组件或 WebElement。我们可以通过使用到目前为止看到的大多数动作来完成此操作。但是 WebDriver 给我们提供了一个方便的即用型方法。让我们看看它的
    API 语法。
- en: 'The API syntax for the `dragAndDropBy()` method is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`dragAndDropBy()` 方法的 API 语法如下：'
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `WebElement` input parameter is the target WebElement to be dragged, the
    `xOffset` parameter is the horizontal offset to be moved, and the `yOffset` parameter
    is the vertical offset to be moved.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebElement` 输入参数是要拖动的目标 WebElement，`xOffset` 参数是要移动的水平偏移量，`yOffset` 参数是要移动的垂直偏移量。'
- en: 'Let''s see a code example for it. Open the HTML file, `DragMe.html`, provided
    with this book. It has a square box, as shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例。打开本书提供的 HTML 文件 `DragMe.html`。它有一个正方形框，如下面的截图所示：
- en: '![](img/9dfa2b9d-f4b9-465a-a5e1-c32911386701.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9dfa2b9d-f4b9-465a-a5e1-c32911386701.png)'
- en: 'You can actually drag that rectangle to any location on the web page. Let''s
    see how we can do that, using WebDriver. The following is the code example for
    that:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您实际上可以将该矩形拖动到网页上的任何位置。让我们看看如何使用 WebDriver 来实现这一点。以下是一个代码示例：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, `dragMe` is the WebElement that is identified by its
    `id`, and that is dragged `300px` horizontally and `200px` vertically. The following
    screenshot shows how an element is dragged from this position:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`dragMe` 是通过其 `id` 识别的 WebElement，它被水平拖动 `300px` 和垂直拖动 `200px`。以下截图显示了如何从这个位置拖动元素：
- en: '![](img/8db11150-9639-44a0-8c0b-c431f32f1c7d.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8db11150-9639-44a0-8c0b-c431f32f1c7d.png)'
- en: The dragAndDrop action
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖动操作
- en: The `dragAndDrop()` method is similar to the `dragAndDropBy()` method. The only
    difference being that, instead of moving the WebElement by an offset, we move
    it on to a target element.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`dragAndDrop()` 方法与 `dragAndDropBy()` 方法类似。唯一的区别在于，我们不是通过偏移量移动 WebElement，而是将其移动到目标元素上。'
- en: 'The API syntax for the `dragAndDrop()` method is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`dragAndDrop()` 方法的 API 语法如下：'
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The input parameters for the preceding method are the WebElement source and
    the WebElement target, while the return type is the `Actions` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的输入参数是源 WebElement 和目标 WebElement，返回类型是 `Actions` 类。
- en: 'Let''s see a working code example for it. Open the `DragAndDrop.html` file,
    which is provided with the book, with two square boxes, as shown in this screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际的工作代码示例。打开与本书一起提供的 `DragAndDrop.html` 文件，其中包含两个正方形框，如图所示：
- en: '![](img/a805d005-ebdd-4cdc-80fe-12c29f8158f6.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a805d005-ebdd-4cdc-80fe-12c29f8158f6.png)'
- en: 'Here, we can actually drag the Drag me to my target rectangle to the Drop here
    rectangle. Try that. Let''s see how that can be achieved, using WebDriver:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实际上可以将“拖动我到目标矩形”拖动到“在这里放下”矩形。试试看。让我们看看如何使用 WebDriver 实现这一点：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, the source and target WebElements are identified by
    their IDs, and the `dragAndDrop()` method is used to drag one to the other. Here,
    out of the script with first square box dropped on the second box shown in the
    following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，源和目标 WebElement 是通过它们的 ID 识别的，并使用 `dragAndDrop()` 方法将一个元素拖动到另一个元素上。以下截图显示了将第一个正方形框拖放到第二个框上的脚本：
- en: '![](img/6ee19696-4b35-42f6-ac0c-9b6172088063.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ee19696-4b35-42f6-ac0c-9b6172088063.png)'
- en: The double click at current location action
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前位置的双击操作
- en: Moving on to another action that can be performed using a mouse, `doubleClick()`
    is another out- of-the-box method that WebDriver provides to emulate the double-clicking
    of the mouse. This method, like the `click()` method, comes in two flavors. One
    is double-clicking a WebElement, which we will discuss in next section; the second
    is clicking at the current location of the cursor, which will be discussed here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论另一种可以使用鼠标执行的操作，`doubleClick()` 是 WebDriver 提供的另一种非常规方法，用于模拟鼠标的双击。此方法与
    `click()` 方法类似，有两种形式。一种是双击一个 WebElement，我们将在下一节中讨论；另一种是在光标当前位置单击，这将在本节中讨论。
- en: 'The API syntax is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: API 语法如下：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Obviously, the preceding method doesn''t take any input parameters, as it just
    clicks on the current cursor location and returns an actions class instance. Let''s
    see how the previous code can be converted to use this method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前面的方法不接收任何输入参数，因为它只是单击当前光标位置并返回一个 `Actions` 类实例。让我们看看如何将前面的代码转换为使用此方法：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, we have used the `moveToElement(WebElement)` method
    to move the mouse to the location of the button element and just double-clicked
    at the current location. Here is the output after performing the double-click
    on the element on the sample page:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `moveToElement(WebElement)` 方法将鼠标移动到按钮元素的位置，并在当前位置进行了双击。以下是双击样本页面上的元素后的输出：
- en: '![](img/f703cd69-1145-43e4-9b43-c8a65cd189bc.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f703cd69-1145-43e4-9b43-c8a65cd189bc.png)'
- en: The double click on WebElement action
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebElement 的双击操作
- en: Now that we have seen a method that double-clicks at the current location, we
    will discuss another method that WebDriver provides to emulate the double-clicking
    of a WebElement.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一个在当前位置双击的方法，我们将讨论 WebDriver 提供的另一种模拟 WebElement 双击的方法。
- en: 'The API syntax for the `doubleClick()` method is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`doubleClick()` 方法的 API 语法如下：'
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The input parameter for the preceding method is the target WebElement that has
    to be double-clicked, and the return type is the `Actions` class.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的输入参数是要双击的目标WebElement，返回类型是`Actions`类。
- en: 'Let''s see a code example for this. Open the `DoubleClick.html` file and *single*-click
    on the Click Me button. You shouldn''t see anything happening. Now double-click
    on the button; you should see an alert saying Double Clicked !!. Now we will try
    to do the same thing using WebDriver. The following is the code to do that:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例。打开`DoubleClick.html`文件，*单击*点击“点击我”按钮。你不应该看到任何动作发生。现在双击按钮；你应该看到一个弹出的警告说“双击了!!”。现在我们将尝试使用WebDriver做同样的事情。以下是要执行的代码：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After executing the preceding code, you should see an alert dialog saying that
    the button has been double-clicked.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，你应该看到一个包含“按钮已被双击”的警告对话框。
- en: The context click on WebElement action
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WebElement上的上下文点击操作
- en: 'The `contextClick()` method, also known as *right-click*, is quite common on
    many web pages these days. It displays a menu similar to this screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`contextClick()`方法，也称为*右键点击*，在许多网页上相当常见。它显示一个类似于以下截图的菜单：'
- en: '![](img/3dabf2a1-2c7f-4ab4-a9ed-b66686e65be4.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3dabf2a1-2c7f-4ab4-a9ed-b66686e65be4.png)'
- en: This context menu can be accessed by a right-click of the mouse on the WebElement.
    WebDriver provides the developer with an option of emulating that action, using
    the `contextClick()` method. Like many other methods, this method has two variants
    as well. One is clicking on the current location and the other overloaded method
    is clicking on the WebElement. Let's discuss the context of clicking on WebElement
    here.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个上下文菜单可以通过在WebElement上右键点击鼠标来访问。WebDriver为开发者提供了一个使用`contextClick()`方法模拟该动作的选项。像许多其他方法一样，此方法也有两种变体。一个是点击当前位置，另一个重载方法是点击WebElement。让我们在这里讨论在WebElement上点击的上下文。
- en: 'The API syntax for the `contextClick()` method is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`contextClick()`方法的API语法如下：'
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The input parameter is obviously the WebElement that has to be right-clicked,
    and the return type is the `Actions` instance. As we do normally, its time to
    see a code example. If you open the `ContextClick.html` file, you can right-click
    on the text visible on the page, and it will display the context menu. Now clicking
    any item pops up an alert dialog stating which item has been clicked. Now let''s
    see how to implement this in WebDriver, using the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数显然是要右键点击的WebElement，返回类型是`Actions`实例。像我们通常做的那样，现在是时候看看一个代码示例了。如果你打开`ContextClick.html`文件，你可以在页面上可见的文本上右键点击，这将显示上下文菜单。现在点击任何项都会弹出一个包含已点击项的警告对话框。现在让我们看看如何使用以下代码在WebDriver中实现这一点：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, first we have right-clicked using the `contextClick()`
    method on the WebElement contextMenu, and then left-clicked on Item 4 from the
    context menu. This should pop up an alert dialog saying Item 4 Clicked.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先在contextMenu的WebElement上使用`contextClick()`方法进行了右键点击，然后从上下文菜单中点击了第4项。这将弹出一个包含“第4项已点击”的警告对话框。
- en: The context click at current location action
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在当前位置的上下文点击操作
- en: 'Now that we have seen context click on a WebElement, it''s time to explore
    the `contextClick()` method at the current mouse location. The API syntax for
    the `contextClick()` method is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了在WebElement上的上下文点击，是时候探索在当前鼠标位置上的`contextClick()`方法了。`contextClick()`方法的API语法如下：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As expected, the preceding method doesn''t expect any input parameter and returns
    the `Actions` instance. Let''s see the necessary modifications needed for the
    previous example to use this method. The following is the code refactored to achieve
    this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，前面的方法不需要任何输入参数，并返回`Actions`实例。让我们看看为了使用此方法对前面的示例所需的必要修改。以下是对此进行重构的代码：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code first moves the cursor to the `div-context` WebElement and
    then context-clicks it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码首先将光标移动到`div-context` WebElement，然后对其进行上下文点击。
- en: Learning keyboard-based interactions
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基于键盘的交互
- en: Until now, we have seen all the actions that can be taken using a mouse. Now
    it's time to look at some of the actions that are specific to the keyboard in
    the `Actions` class. Basically, there are three different actions that are available
    in the `Actions` class that are specific to the keyboard. They are the `keyUp`,
    `keyDown`, and `sendKeys` actions, each having two overloaded methods. One method
    is to execute the action directly on the WebElement, and the other is to just
    execute the method irrespective of its context.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了可以使用鼠标执行的所有操作。现在，我们需要看看 `Actions` 类中特定于键盘的一些操作。基本上，`Actions` 类中有三种特定于键盘的不同操作。它们是
    `keyUp`、`keyDown` 和 `sendKeys` 操作，每个操作都有两个重载方法。一个方法是在 WebElement 上直接执行操作，另一个方法是不考虑其上下文来执行方法。
- en: The keyDown and keyUp actions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`keyDown` 和 `keyUp` 操作'
- en: 'The `keyDown()` method is used to simulate the action of pressing and holding
    a key. The keys that we are referencing here are the *Shift*, *Ctrl*, and *Alt*
    keys. The `keyUp()` method is used to release the key that is already pressed
    using the `keyDown()` method. The API syntax for the `keyDown()` method is as
    follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyDown()` 方法用于模拟按下并保持按键的动作。这里我们引用的键是 *Shift*、*Ctrl* 和 *Alt* 键。`keyUp()` 方法用于释放使用
    `keyDown()` 方法按下的键。`keyDown()` 方法的 API 语法如下：'
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An `IllegalArgumentException` is thrown when the passed key is not one of the
    *Shift*, *Ctrl*, and *Alt* keys. The API syntax for the `keyUp()` method is as
    follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递的键不是 *Shift*、*Ctrl* 和 *Alt* 键之一时，会抛出 `IllegalArgumentException`。`keyUp()`
    方法的 API 语法如下：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `keyUp` action performed on a key, on which a `keyDown` action is not already
    being performed, will result in some unexpected results. So, we have to make sure
    we perform the `keyUp` action after a `keyDown` action is performed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个已经执行了 `keyDown` 操作的键上执行 `keyUp` 操作，如果没有正在进行的 `keyDown` 操作，将会产生一些意外的结果。因此，我们必须确保在执行
    `keyUp` 操作之前已经执行了 `keyDown` 操作。
- en: The sendKeys method
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sendKeys 方法
- en: 'This is used to type in alphanumeric and special character keys into WebElements
    such as textbox, textarea, and so on. This is different than the `WebElement.sendKeys(CharSequence
    keysToSend)` method, as this method expects the WebElements to have the focus
    before being called. The API syntax for the `sendkeys()` method is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于在 WebElements（如文本框、文本区域等）中输入字母数字和特殊字符键。这与 `WebElement.sendKeys(CharSequence
    keysToSend)` 方法不同，因为这个方法期望在调用之前 WebElements 已经获得焦点。`sendkeys()` 方法的 API 语法如下：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We expect you to implement a couple of test scripts around these keyboard events
    using the `keyUp`, `keyDown`, and `sendKeys()` methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望您使用 `keyUp`、`keyDown` 和 `sendKeys()` 方法围绕这些键盘事件实现一些测试脚本。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to use the actions class to create a set
    of actions, and build them into a composite action to execute it in one pass,
    using the `perform()` method. In this way, we can aggregate a series of complex
    user actions into a single functionality, which can be executed in one pass. In
    the next [chapter](480ab588-a7a3-4592-8b58-1b98060a0568.xhtml), we will learn
    WebDriver events and how we can listen and perform advanced actions, using WebDriver.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 actions 类创建一系列操作，并通过 `perform()` 方法将它们构建成一个组合操作以单次执行。这样，我们可以将一系列复杂用户操作聚合到一个单一功能中，并单次执行。在下一章中，我们将学习
    WebDriver 事件以及如何使用 WebDriver 监听和执行高级操作。
- en: Questions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: True or False – the drag and drop action requires the source element and the
    target element.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错 – 拖放操作需要源元素和目标元素。
- en: List the keyboard methods that we can perform using the actions API.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出我们可以使用 actions API 执行的键盘方法。
- en: Which method of the actions API will help in performing a double-click operation?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种 actions API 方法可以帮助执行双击操作？
- en: Using the actions API, how we can perform a save option (that is to say, *Ctrl*
    + *S*)?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 actions API，我们如何执行保存选项（即 *Ctrl* + *S*）？
- en: How can we open a context menu using the actions API?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用 actions API 打开上下文菜单？
- en: Further information
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'You can check the following links for more information about the topics we
    covered in this chapter:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接获取更多关于本章所涉及主题的信息：
- en: Read more about Advanced User Interaction at[ https://github.com/SeleniumHQ/selenium/wiki/Advanced-User-Interactions](https://github.com/SeleniumHQ/selenium/wiki/Advanced-User-Interactions)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/SeleniumHQ/selenium/wiki/Advanced-User-Interactions](https://github.com/SeleniumHQ/selenium/wiki/Advanced-User-Interactions)了解更多关于高级用户交互的信息
- en: See Chapter 4 : *Working with Selenium API* in* Selenium Testing Tools* Cookbook,
    second edition, by Unmesh Gundecha, and Chapter 6,* Utilizing the Advanced User
    Interactions API* in *Master Selenium WebDriver,* byMark Collin, for more examples
    of the actions API
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅第四章节：*使用Selenium API*，出自Unmesh Gundecha所著的《Selenium测试工具手册》第二版，以及第六章节：*利用高级用户交互API*，出自Mark
    Collin所著的《精通Selenium WebDriver》，以获取更多关于动作API的示例。
