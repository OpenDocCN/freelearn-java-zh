- en: Chapter 7. Adding Web Services to Your Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。将网络服务添加到您的应用程序中
- en: In the previous chapter, we discussed the Java Messaging Service API, which
    is commonly used to develop loosely coupled applications and a common integration
    pattern for Java-to-Java systems. In this chapter, you will learn about web services
    that are defined by W3C as software systems, and designed to support interoperable
    machine-to-machine interaction over a network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了Java消息服务API，它通常用于开发松散耦合的应用程序，以及Java到Java系统的通用集成模式。在本章中，你将了解由W3C定义的作为软件系统的网络服务，以及它们旨在支持通过网络进行可互操作机器到机器交互的设计。
- en: What makes web services different from other forms of distributed computing
    is that information is exchanged using only simple and nonproprietary protocols.
    This means the services can communicate with each other regardless of location,
    platform, or programming language. Essentially, web services protocols provide
    a platform-independent way to perform **Remote Procedure Calls** (**RPCs**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使网络服务与其他分布式计算形式不同的因素是，信息仅通过简单和非专有协议进行交换。这意味着服务可以无论位置、平台或编程语言如何相互通信。本质上，网络服务协议提供了一种平台无关的方式来执行**远程过程调用**（**RPCs**）。
- en: 'The focus of this chapter will be on the two chief web services standards,
    **JAX-WS** (**JSR 224**) and **JAX-RS** (**JSR 339**), and how they are implemented
    in WildFly. As you can imagine, there is a lot of ground to cover, so we will
    quickly get our hands dirty with the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将集中在两个主要的网络服务标准上，即**JAX-WS**（**JSR 224**）和**JAX-RS**（**JSR 339**），以及它们在WildFly中的实现方式。正如你所想象的那样，这里有很多内容需要覆盖，因此我们将快速进入以下主题：
- en: A short introduction to SOAP-based web services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于SOAP的网络服务的简要介绍
- en: Creating, deploying, and using the JBoss JAX-WS implementation (Apache CXF)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、部署和使用JBoss JAX-WS实现（Apache CXF）
- en: A quick overview of REST web services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对REST网络服务的快速概述
- en: How to create, deploy, and use services using the JBoss JAX-RS implementation
    (RESTEasy)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用JBoss JAX-RS实现（RESTEasy）创建、部署和使用服务
- en: Integrating JAR-RS with an external non-Java application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JAR-RS与外部非Java应用程序集成
- en: Developing SOAP-based web services
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发基于SOAP的网络服务
- en: 'As stated, web services are based on the exchange of messages using nonproprietary
    protocol messages. The messages themselves are not sufficient to define the web
    service platform. We actually need a list of standard components, including the
    following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，网络服务基于使用非专有协议消息的消息交换。这些消息本身不足以定义网络服务平台。我们实际上需要一个包括以下内容的标准化组件列表：
- en: A language used to define the interfaces provided by a web service in a manner
    that is not dependent on the platform on which it is running or the programming
    language used to implement it
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种用于以不依赖于它运行的平台或实现它的编程语言的方式定义网络服务提供的接口的语言
- en: A common standard format to exchange messages between web service **providers**
    and web service **consumers**
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种在web服务**提供者**和web服务**消费者**之间交换消息的通用标准格式
- en: A registry within which service definitions can be placed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以放置服务定义的注册表
- en: The **Web Service Description Language**, also known as **WSDL**, ([http://www.w3.org/TR/wsdl](http://www.w3.org/TR/wsdl))
    is the de facto standard to provide a description of a web service contract exposed
    to clients. In particular, a WSDL document describes a web service in terms of
    the operations that it provides, and the data types that each operation requires
    as inputs and can return in the form of results.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络服务描述语言**（**WSDL**），也称为**WSDL**，([http://www.w3.org/TR/wsdl](http://www.w3.org/TR/wsdl))是提供对客户端公开的网络服务合同描述的事实标准。特别是，一个WSDL文档描述了一个提供操作的web服务，以及每个操作所需的输入数据类型和可以以结果形式返回的数据类型。'
- en: Communication between the service provider and service consumer happens by means
    of XML messages that rely on the SOAP specification.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供者与服务消费者之间的通信是通过依赖于SOAP规范的XML消息来实现的。
- en: 'A basic SOAP message consists of an envelope that may contain any number of
    headers and a body. These parts are delimited by XML elements called `envelope`,
    `header`, and `body`, which belong to a namespace defined by the SOAP specification.
    The following figure depicts the basic structure of a SOAP message:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的SOAP消息由一个可能包含任意数量头部的信封和一个主体组成。这些部分由称为`envelope`、`header`和`body`的XML元素界定，这些元素属于由SOAP规范定义的命名空间。以下图展示了SOAP消息的基本结构：
- en: '![Developing SOAP-based web services](img/00062.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![开发基于SOAP的网络服务](img/00062.jpeg)'
- en: Strategies to build SOAP-based web services
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建基于SOAP的网络服务的策略
- en: As we have just discussed, the service description is provided by a commonly
    used document interface named WSDL that exposes the services as a collection of
    networks, endpoints, and ports, using the XML format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才讨论的，服务描述是由一个常用的文档接口WSDL提供的，它使用XML格式将服务作为一组网络、端点和端口公开。
- en: You may logically be inclined to think that it is necessary to state the corresponding
    programming interfaces at the beginning of the contract of a service and then
    produce them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会逻辑上倾向于认为，在服务合同的开始处声明相应的编程接口，然后生成它们是必要的。
- en: 'Actually, you can follow two approaches to develop your SOAP web services:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以遵循两种方法来开发你的SOAP网络服务：
- en: '**Top-down**: This development strategy involves creating a web service from
    a WSDL file. The top-down approach is likely to be used when creating web services
    from scratch. It is the preferred choice of pure web service engineers because
    it is business-driven, that is, the contract is defined by business people and
    so the software is designed to fit the web service contract.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自上而下**：这种开发策略涉及从WSDL文件创建网络服务。当从头开始创建网络服务时，可能会使用自上而下的方法。这是纯网络服务工程师的首选选择，因为它是业务驱动的，也就是说，合同是由业务人员定义的，因此软件的设计是为了适应网络服务合同。'
- en: '**Bottom-up**: This approach requires the WSDL file to be generated by the
    programming interfaces. It is likely to be used when we have existing applications
    that we want to expose as web services. As this approach does not require a deep
    knowledge of the WSDL syntax, it is the easiest choice if you want to turn your
    Java classes or EJB into web services.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自下而上**：这种方法要求由编程接口生成WSDL文件。当我们希望将现有应用程序作为网络服务公开时，可能会使用这种方法。由于这种方法不需要对WSDL语法的深入了解，如果你想把Java类或EJB转换为网络服务，它是最容易的选择。'
- en: As the audience of this book is composed mainly of Java developers with little
    or no knowledge of WSDL basics, we will focus primarily on the bottom-up approach.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的受众主要由对WSDL基础知识了解甚少或没有的Java开发者组成，我们将主要关注自下而上的方法。
- en: Designing top-down web services, on the other hand, will require you to integrate
    the basic web services notions provided with this chapter with a comprehensive
    awareness of the WSDL standard.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，设计自上而下的网络服务将需要你将本章提供的基本网络服务概念与对WSDL标准的全面了解相结合。
- en: JBoss SOAP-based web services stack
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JBoss基于SOAP的网络服务栈
- en: All JAX-WS functionalities provided on top of WildFly are currently served through
    a proper integration of the JBoss web services stack with most of the **Apache
    CXF** project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在WildFly上提供的所有JAX-WS功能都是通过将JBoss网络服务栈与Apache CXF项目的大部分功能适当集成来提供的。
- en: 'Apache CXF is an open source web service framework that provides an easy-to-use,
    standard-based programming model to develop both SOAP and REST web services. The
    integration layer (JBossWS-CXF in short hereafter) allows us to perform the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Apache CXF是一个开源的网络服务框架，它提供了一个易于使用的、基于标准的编程模型来开发SOAP和REST网络服务。集成层（以下简称JBossWS-CXF）允许我们执行以下操作：
- en: Use standard web services APIs (including JAX-WS) on a WildFly Application Server;
    this is performed internally by leveraging Apache CXF, without requiring the user
    to deal with it
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WildFly应用服务器上使用标准的网络服务API（包括JAX-WS）；这是通过利用Apache CXF内部执行的，无需用户处理。
- en: Leverage Apache CXF's advanced native features on top of a WildFly Application
    Server without the need for the user to deal with all the required integration
    steps to run the application in such a container
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WildFly应用服务器上利用Apache CXF的高级原生特性，无需用户处理运行该容器中的应用所需的所有集成步骤
- en: Therefore, the focus of the next section will be on developing JAX-WS web services
    using the built-in Apache CXF configuration. If you want to further expand your
    knowledge about Apache CXF's native features, you can refer to the official documentation
    that is available at [http://cxf.apache.org/](http://cxf.apache.org/).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下一节的重点将是使用内置的Apache CXF配置开发JAX-WS网络服务。如果你想进一步扩展你对Apache CXF原生特性的知识，你可以参考官方文档，该文档可在[http://cxf.apache.org/](http://cxf.apache.org/)找到。
- en: A brief look at the JAX WS architecture
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简要了解JAX WS架构
- en: When a SOAP message sent by the client enters the web service runtime environment,
    it is captured by a component named **server endpoint listener**, which, in turn,
    uses the **Dispatcher** module to deliver the SOAP message to that service.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端发送的SOAP消息进入网络服务运行环境时，它被一个名为**服务器端点监听器**的组件捕获，该组件随后使用**调度器**模块将SOAP消息传递到该服务。
- en: At this point, the HTTP request is converted internally into a SOAP message.
    The message content is extracted from the transport protocol and processed through
    the handler chain configured for the web service.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，HTTP请求被内部转换为SOAP消息。消息内容从传输协议中提取出来，并通过为该网络服务配置的处理程序链进行处理。
- en: SOAP message handlers are used to intercept SOAP messages as they make their
    way from the client to the endpoint service and vice versa. These handlers intercept
    SOAP messages for both the request and response of the web service.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP消息处理程序用于拦截SOAP消息，在它们从客户端到端点服务以及相反方向传输的过程中。这些处理程序拦截了网络服务的请求和响应中的SOAP消息。
- en: The next step is unmarshalling the SOAP message into Java objects. This process
    is governed by WSDL to Java Mapping and XML to Java Mapping. The former is performed
    by the JAX-WS engine, and it determines which endpoint to invoke from the SOAP
    message. The latter, performed by the JAXB libraries, deserializes the SOAP message
    so that it is ready to invoke the endpoint method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将SOAP消息反序列化为Java对象。此过程由WSDL到Java映射和XML到Java映射控制。前者由JAX-WS引擎执行，它确定从SOAP消息中调用哪个端点。后者由JAXB库执行，它将SOAP消息反序列化，以便它可以调用端点方法。
- en: Finally, the deserialized SOAP message reaches the actual web service implementation
    and the method is invoked.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，反序列化的SOAP消息到达实际的网络服务实现，并调用该方法。
- en: Once the call is completed, the process is reversed. The return value from the
    web service method is marshalled into a SOAP response message using JAX-WS WSDL
    to Java mapping and JAXB 2.0 XML to Java mapping.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用完成，过程就会逆转。网络服务方法返回的值使用JAX-WS WSDL到Java映射和JAXB 2.0 XML到Java映射打包成一个SOAP响应消息。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The JAXB provides a fast and convenient way to bind XML schemas and Java representations,
    making it easy for Java developers to incorporate XML data and process functions
    in Java applications. As part of this process, JAXB provides methods to unmarshal
    XML instance documents into Java content trees, and then marshal Java content
    trees back into XML instance documents. JAXB also provides a way to generate XML
    schema from Java objects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JAXB提供了一种快速便捷的方式将XML模式与Java表示绑定，使得Java开发者能够轻松地将XML数据和过程函数集成到Java应用程序中。作为此过程的一部分，JAXB提供了将XML实例文档反序列化为Java内容树的方法，然后将Java内容树反序列化为XML实例文档的方法。JAXB还提供了一种从Java对象生成XML模式的方法。
- en: Next, the outbound message is processed by handlers before returning it to the
    dispatcher and endpoint listener that will transmit the message as an HTTP response.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，出站消息在返回给调度器和端点监听器之前，由处理程序进行处理，这些调度器和端点监听器将消息作为HTTP响应传输。
- en: 'The following diagram describes how data flows from a web service client to
    a web service endpoint and back:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了数据如何从网络服务客户端流向网络服务端点，并返回：
- en: '![A brief look at the JAX WS architecture](img/00063.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![简要了解JAX WS架构](img/00063.jpeg)'
- en: Coding SOAP web services with WildFly
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WildFly编写SOAP网络服务代码
- en: In the first deliverable, we will show how easily you can turn a plain Java
    class into a web service. The newly created service will then be tested using
    a simple Eclipse-based testing GUI. The second part of this section will draw
    your attention to how EJBs can be exposed as web service endpoints by enhancing
    your ticket application with a web service.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个交付成果中，我们将展示如何轻松地将一个普通的Java类转换为网络服务。然后，使用基于Eclipse的简单测试GUI对该新创建的服务进行测试。本节第二部分将关注如何通过增强您的票务应用程序以网络服务的方式公开EJB作为网络服务端点。
- en: Developing a POJO web service
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发POJO网络服务
- en: We will start developing web services, using our project from [Chapter 4](part0028_split_000.html#page
    "Chapter 4. Learning Context and Dependency Injection"), *Learning Context and
    Dependency Injection* (`ticket-agency-cdi`) as a base. We will omit the current
    JSF-based web layer for now. You can safely remove all of the JSF-related classes
    and configurations. If you encounter any problems, remember that you'll find a
    fully working project in the code examples, upon completion of this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始开发Web服务，使用我们的项目从[第4章](part0028_split_000.html#page "Chapter 4. 学习上下文和依赖注入")，*学习上下文和依赖注入*
    (`ticket-agency-cdi`)作为基础。现在我们将省略基于JSF的当前Web层。您可以安全地删除所有与JSF相关的类和配置。如果您遇到任何问题，请记住，在本章完成后，您将在代码示例中找到一个完全工作的项目。
- en: 'Our first class will not be related to our ticket application, but it will
    just demonstrate how to create a web service from a `POJO` class named `CalculatePowerWebService`.
    This class has a method named `calculatePower`, which returns the power of an
    argument, as shown in the following highlighted code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一类将与我们的票务应用程序无关，但它将仅演示如何从一个名为`CalculatePowerWebService`的`POJO`类创建Web服务。这个类有一个名为`calculatePower`的方法，它返回一个参数的幂，如下面的高亮代码所示：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will turn this simple class into a web service by adding the mandatory
    `@WebService` annotation:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过添加必需的`@WebService`注解将这个简单的类转换成Web服务：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the `@WebService` annotation, you can specify additional elements, such
    as the `targetNamespace` element that declares the namespace used for the WSDL
    elements generated by the web service. If you don't specify this element, the
    web service container will use the Java package name to generate a default XML
    namespace.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@WebService`注解内部，您可以指定额外的元素，例如声明由Web服务生成的WSDL元素的命名空间的`targetNamespace`元素。如果您不指定此元素，Web服务容器将使用Java包名来生成默认的XML命名空间。
- en: You can also use the `serviceName` element to specify the service name. The
    name specified using `serviceName` is used to generate the name attribute in the
    service element in the WSDL interface. If you don't specify the `serviceName`
    element, the server will generate it using the default value, which is the bean
    class name appended with the service.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`serviceName`元素来指定服务名称。使用`serviceName`指定的名称用于生成WSDL接口中服务元素的名称属性。如果您不指定`serviceName`元素，服务器将使用默认值生成它，默认值是bean类名后追加的服务。
- en: In the next row, we state that the web service is of the type **Remote Procedure
    Call** using the `@javax.jws.SOAPBinding` annotation. The possible values are
    `DOCUMENT` and `RPC`, the first one being the default value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，我们使用`@javax.jws.SOAPBinding`注解声明Web服务是**远程过程调用**类型。可能的值是`DOCUMENT`和`RPC`，第一个是默认值。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The choice between the RPC and Document style boils down to the different ways
    we can construct services using these two styles. The body of an RPC-style SOAP
    message is constructed in a specific way, which is defined in the SOAP standard.
    This is built on the assumption that you want to call the web service just like
    you would call a normal function or method that is part of your application code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: RPC和文档风格之间的选择归结为我们可以使用这两种风格构建服务的不同方式。RPC风格SOAP消息的体是以特定方式构建的，这在SOAP标准中定义。这是基于您想要像调用应用程序代码中的普通函数或方法一样调用Web服务的假设。
- en: Therefore, the RPC is more tightly coupled because if you make any changes in
    the message structure, you'll need to change all the clients and servers processing
    this kind of message.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RPC更紧密地耦合，因为如果您在消息结构中做出任何更改，您需要更改所有处理此类消息的客户端和服务器。
- en: A document-style web service, on the other hand, contains no restrictions for
    how the SOAP body must be constructed. It allows you to include whatever XML data
    you want and also a schema for this XML. Therefore, the document style is probably
    more flexible, but the effort to implement the web service and clients may be
    slightly more.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，文档风格的Web服务对SOAP体如何构建没有限制。它允许您包含任何想要的XML数据以及该XML的模式。因此，文档风格可能更灵活，但实现Web服务和客户端的努力可能稍微多一点。
- en: In the end, the likelihood of change is a factor that one has to consider when
    choosing whether to use RPC- or Document-style web services.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，改变的可能性是选择是否使用RPC或文档风格Web服务时必须考虑的一个因素。
- en: Attaching the `@WebMethod` attribute to a public method indicates that you want
    the method exposed as part of the web service.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `@WebMethod` 属性附加到公共方法上表示您希望将方法公开作为网络服务的一部分。
- en: The `@WebParam` annotation is used to specify the parameter's name that needs
    to be exhibited in the WSDL. You should always consider using a `WebParam` annotation,
    especially when using multiple parameters, otherwise the WSDL will use the default
    argument parameter (in this case, `arg0`), which is meaningless for web service
    consumers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebParam` 注解用于指定需要在 WSDL 中展示的参数名称。您应该始终考虑使用 `WebParam` 注解，尤其是在使用多个参数时，否则
    WSDL 将使用默认的参数（在这种情况下，`arg0`），这对网络服务消费者来说是没有意义的。'
- en: The `@WebResult` annotation is quite similar to `@WebParam` in the sense that
    it can be used to specify the name of the value returned by the WSDL.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`@WebResult` 注解在意义上与 `@WebParam` 非常相似，因为它可以用来指定由 WSDL 返回的值的名称。'
- en: 'Your web service is now complete. In order to deploy your web service, run
    the following Maven goal, which will package and deploy your web service to your
    running WildFly instance:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您的网络服务现在已完成。为了部署您的网络服务，运行以下 Maven 目标，这将打包并部署您的网络服务到您的运行 WildFly 实例：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'WildFly will provide a minimal output on the console; this will inform you
    that the web service project has been deployed and the WSDL file has been generated:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: WildFly 将在控制台上提供最小输出；这将通知您网络服务项目已部署，WSDL 文件已生成：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the short log, you can pick up some useful information. For example, the
    first line states that the web service has been bound in the endpoint registry
    as `{http://www.packtpub.com/}CalculatePowerService`. Next is the information
    about the web context path, which, by default, has the same name as your project,
    that is, `ticket-agency-ws`. The last piece of information is about the web service
    address, which is `http://localhost:8080/ticket-agency-ws/CalculatePowerService`.
    By appending the `?wsdl` suffix to the end of the address, you can inspect the
    web service contract.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从简短的日志中，您可以获取一些有用的信息。例如，第一行表明网络服务已在端点注册表中绑定为 `{http://www.packtpub.com/}CalculatePowerService`。接下来是有关网络上下文路径的信息，默认情况下，它与您的项目名称相同，即
    `ticket-agency-ws`。最后一条信息是关于网络服务地址的，它是 `http://localhost:8080/ticket-agency-ws/CalculatePowerService`。通过在地址末尾附加
    `?wsdl` 后缀，您可以检查网络服务合约。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `data` directory contains a versioned list of all the generated WSDLs. So,
    you might find the entire history of your web services published by `ticket-agency-ws`
    in `JBOSS_HOME/standalone/data/wsdl/ticket-agency-ws.war`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 目录包含所有生成的 WSDL 的版本化列表。因此，您可能会在 `JBOSS_HOME/standalone/data/wsdl/ticket-agency-ws.war`
    中找到由 `ticket-agency-ws` 发布的网络服务的整个历史记录。'
- en: Inspecting the web service from the console
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从控制台检查网络服务
- en: You can inspect the web services subsystem by moving to the web admin console
    and navigating to **Runtime** | **Status** | **Subsystems** | **Web Services**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过转到网络管理控制台并导航到 **Runtime** | **Status** | **Subsystems** | **Web Services**
    来检查网络服务子系统。
- en: 'Here, you can gather some useful information about the services deployed. In
    fact, the most useful option is the list of endpoint contracts available, which
    is needed when developing our clients. The following screenshot shows a view of
    the web service endpoints from the console:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以收集有关已部署服务的有用信息。实际上，最有用的选项是可用的端点合约列表，这在开发我们的客户端时是必需的。以下截图显示了从控制台查看的网络服务端点：
- en: '![Inspecting the web service from the console](img/00064.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![从控制台检查网络服务](img/00064.jpeg)'
- en: Particularly, in the lower part of the screen, you can read the web service
    endpoint address that bears the web application context name and registered name
    for the web service. In our case, it is `http://localhost:8080/ticket-agency-ws/CalculatePowerService?wsdl`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在屏幕的下半部分，你可以阅读包含网络应用程序上下文名称和注册的网络服务名称的网络服务端点地址。在我们的例子中，它是 `http://localhost:8080/ticket-agency-ws/CalculatePowerService?wsdl`。
- en: Testing our simple web service
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试我们的简单网络服务
- en: Since our first web service is not yet connected to our ticketing system, we
    will use an external client application to test our web service. One of the best
    tools to test web services is **SoapUI**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的第一个网络服务尚未连接到我们的票务系统，我们将使用外部客户端应用程序来测试我们的网络服务。测试网络服务最好的工具之一是 **SoapUI**。
- en: SoapUI is a free, open source, cross-platform functional testing solution with
    an easy-to-use graphical interface and enterprise-class features. This tool allows
    you to create and execute automated, functional, regression, compliance, and load
    tests easily and rapidly. SoapUI is also available as an Eclipse plugin.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SoapUI是一个免费、开源、跨平台的函数测试解决方案，具有易于使用的图形界面和企业级功能。此工具允许您轻松快速地创建和执行自动化、功能、回归、合规性和负载测试。SoapUI还可用作Eclipse插件。
- en: 'Here, we will use the SoapUI standalone application. Run it and create a new
    SOAP project providing the URL to the service WSDL, as shown in the following
    screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用SoapUI独立应用程序。运行它，创建一个新的SOAP项目，提供服务的WSDL URL，如图下截图所示：
- en: '![Testing our simple web service](img/00065.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的简单网络服务](img/00065.jpeg)'
- en: 'After this, you''ll see a view containing a few windows. The most important
    ones show the request logs and the project view in the navigator window, as shown
    in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将看到一个包含几个窗口的视图。其中最重要的窗口显示请求日志和导航窗口中的项目视图，如图下截图所示：
- en: '![Testing our simple web service](img/00066.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的简单网络服务](img/00066.jpeg)'
- en: 'As you can see, your service operations have been automatically discovered.
    Double-click on the **Request 1** tree element; the SoapUI request window will
    appear where you can enter the named parameters. Enter the two arguments for the
    web service, as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您的服务操作已被自动发现。双击**请求 1**树元素；SoapUI请求窗口将出现，您可以在其中输入命名参数。输入网络服务的两个参数，如图下截图所示：
- en: '![Testing our simple web service](img/00067.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的简单网络服务](img/00067.jpeg)'
- en: 'Click on the **Submit** button on the toolbar and check the result in the SOAP
    response window:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 点击工具栏上的**提交**按钮，并在SOAP响应窗口中检查结果：
- en: '![Testing our simple web service](img/00068.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的简单网络服务](img/00068.jpeg)'
- en: EJB3 Stateless Session Bean (SLSB) web services
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EJB3无状态会话Bean（SLSB）网络服务
- en: The JAX-WS programming model supports the same set of annotations on EJB3 Stateless
    Session Bean as it does on POJO endpoints. Now that we already have some web service
    muscle, we will engineer one of the examples introduced in this book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-WS编程模型支持与EJB3无状态会话Bean在POJO端点上的相同一组注解。既然我们已经有一些网络服务经验，我们将构建本书中介绍的一个示例。
- en: 'Our main web service class will be named `DefaultTicketWebService` and will
    use some of the core classes that we described in [Chapter 3](part0023_split_000.html#page
    "Chapter 3. Introducing Java EE 7 – EJBs"), *Introducing Java EE 7 – EJBs*, such
    as `TheatreBox`, which will keep in memory the ticket bookings and the `Seat`
    class as the model. The business methods of our web service will be described
    by a **Service Endpoint Interface** (**SEI**) named `TicketWebService`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要网络服务类将被命名为`DefaultTicketWebService`，并使用我们在[第3章](part0023_split_000.html#page
    "第3章。介绍Java EE 7 – EJBs")中描述的一些核心类，例如`TheatreBox`，它将在内存中保留票务预订和`Seat`类作为模型。我们的网络服务业务方法将由一个名为**服务端点接口**（**SEI**）的`TicketWebService`来描述：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Writing the service interface is always a good practice as it gives a proper
    client-side view of our Service methods. The implementation class can then implement
    the methods defined in the interface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 编写服务接口始终是一个好习惯，因为它为我们提供了服务方法的适当客户端视图。然后实现类可以实现对接口中定义的方法。
- en: 'We will now implement the interface by providing the business logic to the
    interface methods in the `DefaultTicketWebService` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过在`DefaultTicketWebService`类中提供业务逻辑到接口方法来实现该接口：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the implementation class contains the `getSeats` method, which
    returns the list of seats that are self-generated when the `TheatreBox` object
    is initialized. The `bookSeat` method will be able to book seats for your web
    service clients as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实现类包含`getSeats`方法，该方法返回当`TheatreBox`对象初始化时自动生成的座位列表。`bookSeat`方法将为您的网络服务客户端预订座位。
- en: 'Now deploy your web service and verify on the console that it has been correctly
    registered:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在部署您的网络服务，并在控制台上验证它是否已正确注册：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Developing a web service consumer
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发网络服务消费者
- en: 'The web service consumer of the `TicketWebService` class will be coded using
    the standard Java SE classes. We want to show here how to use these standard APIs.
    For this reason, you can just add a class named `TicketWebServiceTestApplication`
    to your current or a separate project in the package `com.packtpub.wflydevelopment.chapter7.webservice`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`TicketWebService`类的Web服务消费者将使用标准的Java SE类进行编码。我们在这里想展示如何使用这些标准API。因此，你只需在你的当前项目或单独的项目中添加一个名为`TicketWebServiceTestApplication`的类到包`com.packtpub.wflydevelopment.chapter7.webservice`：'
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The service WSDL URL and name are needed for retrieval of the `Service` object.
    Finally, the `getPort` method will return a proxy to your web service that can
    be used to test two basic operations: booking a seat and checking from the `Seat`
    list if the seat has actually been reserved.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 需要服务WSDL URL和名称来检索`Service`对象。最后，`getPort`方法将返回一个代理到你的Web服务，你可以用它来测试两个基本操作：预订座位和从`Seat`列表中检查座位是否已被预留。
- en: This small standalone class has shown how it is possible to use SOAP-based services
    from the client-side perspective.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小型独立类展示了从客户端视角使用基于SOAP的服务是如何可能的。
- en: 'The most interesting part, however, is at the bottom of the Maven output, where
    the `Ticket` list is dumped after booking one seat, as depicted in the following
    command line:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最有趣的部分是在Maven输出的底部，其中在预订一个座位后，`Ticket`列表被输出，如下面的命令行所示：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Developing REST-based web services
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发基于REST的Web服务
- en: '**JAX-RS 2.0** (JSR-339 can be found at [https://jcp.org/en/jsr/detail?id=339](https://jcp.org/en/jsr/detail?id=339))
    is a JCP specification that provides a Java API for RESTful web services in the
    HTTP protocol. It is a major refresh from the old Version 1.1\. Some of the new
    features are the client API, HATEOAS support, and asynchronous calls.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**JAX-RS 2.0**（JSR-339可以在[https://jcp.org/en/jsr/detail?id=339](https://jcp.org/en/jsr/detail?id=339)找到）是一个JCP规范，它为HTTP协议中的RESTful
    Web服务提供了Java API。这是从旧版本1.1的重大更新。一些新特性包括客户端API、HATEOAS支持以及异步调用。'
- en: In their simplest form, RESTful web services are networked applications that
    manipulate the state of system resources. In this context, resource manipulation
    means resource creation, retrieval, updatation, and deletion (CRUD). However,
    RESTful web services are not limited to just these four basic data manipulation
    concepts. On the contrary, RESTful web services can execute logic at the server
    level but remember that every result must be a resource representation of the
    domain.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，RESTful Web服务是网络应用程序，它操作系统资源的状态。在这个上下文中，资源操作意味着资源的创建、检索、更新和删除（CRUD）。然而，RESTful
    Web服务并不仅限于这四个基本的数据操作概念。相反，RESTful Web服务可以在服务器级别执行逻辑，但请记住，每个结果都必须是域的资源表示。
- en: The main difference with SOAP web services is that REST asks developers to use
    HTTP methods explicitly and in a way that's consistent with the protocol definition.
    This basic REST design principle establishes a **one-to-one** mapping between
    CRUD operations and HTTP methods.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与SOAP Web服务的主要区别是，REST要求开发者显式地使用HTTP方法，并且与协议定义保持一致。这个基本的REST设计原则在CRUD操作和HTTP方法之间建立了一个**一对一**的映射。
- en: 'Therefore, with the delineated roles for resources and representations, we
    can now map our CRUD actions to the HTTP methods `POST`, `GET`, `PUT`, and `DELETE`
    as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了对资源和表示的明确角色划分，我们现在可以将我们的CRUD动作映射到HTTP方法`POST`、`GET`、`PUT`和`DELETE`，如下所示：
- en: '| Action | HTTP protocol equivalent |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 动作 | HTTP协议等效 |'
- en: '| --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| RETRIEVE | GET |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| RETRIEVE | GET |'
- en: '| CREATE | POST |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| CREATE | POST |'
- en: '| UPDATE | PUT |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| UPDATE | PUT |'
- en: '| DELETE | DELETE |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | DELETE |'
- en: Accessing REST resources
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问REST资源
- en: 'As we said, REST resources can be accessed using actions that map an equivalent
    HTTP request. In order to simplify the development of REST applications, you can
    use simple annotations to map your actions; for example, in order to retrieve
    some data from your application, you can use something similar to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，REST资源可以通过映射等效HTTP请求的动作来访问。为了简化REST应用程序的开发，你可以使用简单的注解来映射你的动作；例如，为了从你的应用程序中检索一些数据，你可以使用以下类似的方法：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first annotation, `@Path`, in our example is used to specify the URI that
    is assigned to this web service. Subsequent methods have their specific `@Path`
    annotation so that you can provide a different response according to the URI requested.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，第一个注解`@Path`用于指定分配给此Web服务的URI。后续的方法都有其特定的`@Path`注解，这样你就可以根据请求的URI提供不同的响应。
- en: Then, we have an `@GET` annotation that maps an HTTP `GET` request and an `@POST`
    annotation that handles an HTTP `POST` request. So, in this example, if we were
    to request for a web application bound to the `example` web context, an HTTP `GET`
    request to the URL `http://host/example/users` would trigger the `handleGETRequest`
    method; on the other hand, an HTTP `POST` request to the same URL would conversely
    invoke the `handlePOSTRequest` method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个 `@GET` 注解，它映射 HTTP `GET` 请求，还有一个 `@POST` 注解，它处理 HTTP `POST` 请求。所以，在这个例子中，如果我们请求绑定到
    `example` 网络上下文的 Web 应用程序，对 URL `http://host/example/users` 的 HTTP `GET` 请求将触发
    `handleGETRequest` 方法；另一方面，对同一 URL 的 HTTP `POST` 请求将相反地调用 `handlePOSTRequest`
    方法。
- en: JBoss REST web services
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JBoss REST 网络服务
- en: Having understood the basics of REST services, let's see how we can develop
    a RESTful web service using WildFly. The application server includes an out-of-the-box
    RESTEasy library that is a portable implementation of the JSR-339 specification.
    RESTEasy can run in any servlet container; however, it is perfectly integrated
    with WildFly, thus making the user experience nicer in that environment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了 REST 服务的基础知识之后，让我们看看如何使用 WildFly 开发一个 RESTful 网络服务。应用程序服务器包含一个开箱即用的 RESTEasy
    库，它是 JSR-339 规范的可移植实现。RESTEasy 可以在任何 Servlet 容器中运行；然而，它与 WildFly 完美集成，因此在那个环境中为用户提供更好的体验。
- en: Besides the server-side specification, in the past, RESTEasy has been innovative
    in bringing JAX-RS to the client through the RESTEasy **JAX-RS Client Framework**.
    However, the latest version of the JAX-RS specification comes with a client API,
    which we can use in every JAX-RS implementation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了服务器端规范之外，在以前，RESTEasy 通过 RESTEasy **JAX-RS 客户端框架**将 JAX-RS 带到客户端方面进行了创新。然而，JAX-RS
    规范的最新版本附带了一个客户端 API，我们可以在每个 JAX-RS 实现中使用它。
- en: Activating JAX-RS
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活 JAX-RS
- en: 'RESTEasy is bundled with WildFly, so you need very little effort to get started.
    You have two choices. The first one is to use the `@ApplicationPath` annotation
    in a class that extends `javax.ws.rs.core.Application`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: RESTEasy 与 WildFly 打包在一起，因此你几乎不需要做任何努力就可以开始使用。你有两个选择。第一个是在扩展 `javax.ws.rs.core.Application`
    的类中使用 `@ApplicationPath` 注解：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The second choice is less popular and used to configure the application using
    a `web.xml` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择不太受欢迎，它用于通过 `web.xml` 文件配置应用程序：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This simply means that if we were to deploy our former example, the HTTP `GET`
    method, `http://host/example/rest/users` would trigger our `getUser` business
    method, while the same URL will place a request through the `handlePOSTRequest`
    method using a `POST` request.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅意味着，如果我们部署之前的示例，HTTP `GET` 方法，`http://host/example/rest/users` 将触发我们的 `getUser`
    业务方法，而相同的 URL 将通过 `POST` 请求通过 `handlePOSTRequest` 方法发送请求。
- en: Adding REST to our ticket example
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 REST 添加到我们的票务示例中
- en: With all the configurations in place, we can now add a simple REST web service
    to our `Ticket Web Service` project, which will provide the same functionalities
    as our SOAP web service.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有配置就绪后，我们现在可以向我们的 `Ticket Web Service` 项目添加一个简单的 REST 网络服务，它将提供与我们的 SOAP 网络服务相同的功能。
- en: 'So add a new class to your project and name it `SeatsResource`. The code for
    this is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在你的项目中添加一个新类，并将其命名为 `SeatsResource`。这个类的代码如下：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you have understood our earlier section well, this code will be almost intuitive
    to you. We have included two methods here, just like the SOAP alter ego; the former
    one is named `getSeatList`, which is bound to an HTTP `GET` request and produces
    the list of `Seats`. The list is returned using a JSON representation that is
    pretty common when returning Java objects to the client.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经很好地理解了我们前面的部分，这段代码对你来说几乎会直观易懂。我们在这里包含了两个方法，就像 SOAP 的对应物一样；前者命名为 `getSeatList`，它与
    HTTP `GET` 请求绑定并生成 `Seats` 列表。列表使用 JSON 表示法返回，这在将 Java 对象返回给客户端时非常常见。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The grammar for JSON objects is simple and requires the grouping of the data
    definition and data values; it is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 对象的语法很简单，需要将数据定义和数据值分组；如下所示：
- en: Elements are enclosed within curly brackets (`{` and `}`)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素被花括号 (`{` 和 `}`) 包围
- en: Values of elements come in pairs with the structure of `name:value` and are
    comma separated
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的值以 `name:value` 的结构成对出现，并且用逗号分隔
- en: Arrays are enclosed within square brackets (`[` and `]`)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组被方括号 (`[` 和 `]`) 包围
- en: That's all there is to it (for the full JSON grammar description, visit [http://www.json.org/](http://www.json.org/)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容（对于完整的 JSON 语法描述，请访问 [http://www.json.org/](http://www.json.org/)）。
- en: 'The second method included in this class is `bookPlace`, which will be used
    to invoke the corresponding `bookSeat` class of our EJB. This method, on the other
    hand, is bound to the following HTTP `POST` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该类中包含的第二个方法是`bookPlace`，它将用于调用我们的EJB的相应`bookSeat`类。另一方面，此方法绑定到以下HTTP `POST`方法：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You might be thinking that this `Path` expression seems a bit weird, but all
    it does is map a URI parameter (included in the `Path` expression) to a method
    parameter. In short, the parameter that is included in the URL will be passed
    to the method in the `ID` variable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这个`Path`表达式看起来有点奇怪，但它所做的只是将URI参数（包含在`Path`表达式中）映射到方法参数。简而言之，包含在URL中的参数将通过`ID`变量传递给方法。
- en: The previous method also returns a JSON-formatted string that is encoded and
    decoded using Jackson (by default, it is possible to create your own message body
    providers!), a library that transforms POJOs to JSON (and vice versa).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法还返回一个使用Jackson（默认情况下，你可以创建自己的消息体提供者！）编码和解码的JSON格式的字符串，这是一个将POJO转换为JSON（反之亦然）的库。
- en: 'Before we proceed, we need to extend our sample with a new resource account,
    which will allow us to check the cash status and optionally reset it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要通过一个新的资源账户扩展我们的样本，这将使我们能够检查现金状态并可选择重置它：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The account representation is available, as shown in the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 账户表示如下所示：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last step is to update our `TheatreBooker` class to use our new account
    representation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将我们的`TheatreBooker`类更新为使用我们新的账户表示：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The newest version of JAX-RS also supports server-side asynchronous responses.
    Thanks to the `@Suspended` annotation and the `AsyncResponse` class, you can use
    a separate (possibly delayed) thread to handle a request call.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS的最新版本也支持服务器端异步响应。多亏了`@Suspended`注解和`AsyncResponse`类，你可以使用一个单独的（可能是延迟的）线程来处理请求调用。
- en: Adding filters
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加过滤器
- en: JAX-RS allows us to define filters and interceptors for both the client and
    server. They allow the developer to address cross-cutting concerns, such as security,
    auditing, or compression. Basically, you can treat filters and interceptors as
    extension points.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS允许我们为客户端和服务器定义过滤器和拦截器。它们允许开发者处理横切关注点，如安全、审计或压缩。基本上，你可以将过滤器和拦截器视为扩展点。
- en: 'Filters are used mainly on headers of requests and responses. For example,
    you can block a request based on its header fields or log only failed requests.
    On the contrary, interceptors deal with message bodies, for example, you can sign
    or compress the messages. Interceptors also come in two flavors: one for reading
    (they are executed when a message is translated into a POJO, for example JSON
    to `SeatDto`) and one for writing (they are used for POJO to message translation).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器主要用于请求和响应的头部。例如，你可以根据其头部字段阻止请求或仅记录失败的请求。相反，拦截器处理消息体，例如，你可以对消息进行签名或压缩。拦截器也有两种类型：一种是读取（当消息被转换为POJO，例如JSON到`SeatDto`时执行）和一种是写入（用于POJO到消息的转换）。
- en: 'We can add a simple server-side logging filter to our application by creating
    the following class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建以下类向我们的应用程序添加一个简单的服务器端日志过滤程序：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, we implement two pretty straightforward interfaces: `ContainerRequestFilter`
    and `ContainerResponseFilter`. We simply log some information about the HTTP request
    and response. To activate the filter, we use the `@Provider` annotation; without
    additional configuration, the filter will work for every REST resource in our
    application. Additionally, if we would like to reject a request in the filter,
    there is a `requestContext.abortWith` method.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们实现了两个相当直接的接口：`ContainerRequestFilter`和`ContainerResponseFilter`。我们只是记录一些关于HTTP请求和响应的信息。要激活过滤器，我们使用`@Provider`注解；在没有额外配置的情况下，过滤器将适用于我们应用程序中的每个REST资源。此外，如果我们想在过滤器中拒绝请求，有一个`requestContext.abortWith`方法。
- en: 'The client side has two corresponding interfaces: `ClientRequestFilter` and
    `ClientResponseFilter`. The implementations, however, must be registered manually.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端有两个相应的接口：`ClientRequestFilter`和`ClientResponseFilter`。然而，实现必须手动注册。
- en: 'Now the REST service is complete and we can start deploying it in the usual
    way:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，REST服务已经完成，我们可以按照常规方式开始部署它：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you followed all the steps so far, the `http://localhost:8080/ticket-agency-ws/rest/seat
    GET` method issued by your browser should print out the list of available seats:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经遵循了迄今为止的所有步骤，那么由你的浏览器发出的`http://localhost:8080/ticket-agency-ws/rest/seat
    GET`方法应该会打印出可用座位的列表：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Going to `http://localhost:8080/ticket-agency-ws/rest/account` will result
    in:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8080/ticket-agency-ws/rest/account`将导致：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should also see some log statements from our filter in the console, for
    instance:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该在控制台中看到一些来自我们的过滤器的日志语句，例如：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Consuming our REST service
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费我们的REST服务
- en: Connecting to a RESTful web service takes no more work than directly connecting
    to the service through an HTTP connection. For this reason, you can use plenty
    of APIs to access your REST services, such as the JDK `URLConnection` class or
    Jakarta Commons HttpClient API, since we have a standardized client available
    in JAX-RS.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到RESTful Web服务所需的工作量与直接通过HTTP连接连接到服务的工作量相当。因此，你可以使用大量的API来访问你的REST服务，例如JDK的`URLConnection`类或Jakarta
    Commons HttpClient API，因为我们有标准化的客户端可用在JAX-RS中。
- en: 'If you want to retrieve the list of `Seats` from your REST service, your code
    should look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从你的REST服务中检索`Seats`列表，你的代码应该看起来像这样：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous code will simply perform a `GET` action to the REST service that
    is deployed as part of the `ticket-agency-ws` web application. RESTEasy (using
    Jackson) will transform the JSON objects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将简单地执行对作为`ticket-agency-ws` Web应用程序一部分部署的REST服务的`GET`操作。RESTEasy（使用Jackson）将转换JSON对象。
- en: 'The following standalone sample will get the data from the account and seat
    resources and attempt to book all of the available seats:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下独立示例将从账户和座位资源获取数据，并尝试预订所有可用的座位：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the highlighted fragments, you can see the REST calls used to retrieve the
    data and booking seats. Our `post` call requires an ID to be specified; we do
    that by using the `path` method of the `request` builder. It is also possible
    to make the call asynchronously, using the `async` method and a `Future` object:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在高亮显示的片段中，你可以看到用于检索数据和预订座位的REST调用。我们的`post`调用需要指定一个ID；我们通过使用`request`构建器的`path`方法来完成。也可以使用`async`方法和`Future`对象来异步执行调用：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can use the new `CompletableFuture` class from Java 8 to be notified about
    the completion of a request:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Java 8中的新`CompletableFuture`类来通知请求的完成：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After receiving the data, we simply print it out. Another option is to simply
    create an `InvocationCallback` class and pass it as a second argument to the `get`
    method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 收到数据后，我们只需将其打印出来。另一个选项是简单地创建一个`InvocationCallback`类，并将其作为第二个参数传递给`get`方法。
- en: Compiling our ticket example
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译我们的票务示例
- en: 'Our sample can reside in a separate Maven module or you can leave it with the
    server content (although it is not a good practice). In order to compile our client
    project with the REST web service, we need to import the JAX-RS API that is included
    in the application server libraries. We will need the following dependencies in
    our standalone application:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例可以位于一个单独的Maven模块中，或者你可以将其与服务器内容一起保留（尽管这不是一个好的做法）。为了编译我们的客户端项目与REST Web服务，我们需要导入包含在应用程序服务器库中的JAX-RS
    API。在我们的独立应用程序中，我们需要以下依赖项：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you have any problems with the creation of the POM file, you can look it
    up in the samples that are distributed with this book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建POM文件时遇到任何问题，你可以查看本书附带提供的示例。
- en: 'Now simply run your application, and you should see something similar to the
    following console output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在简单地运行你的应用程序，你应该会看到以下类似的控制台输出：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Adding AngularJS
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加AngularJS
- en: Our samples for the REST integration are not very spectacular. However, because
    we expose the functionality of our application via a REST API, it is easy to create
    a non-Java GUI, which can be used to control the application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的REST集成示例并不非常引人注目。然而，因为我们通过REST API公开了我们的应用程序功能，所以很容易创建一个非Java GUI，它可以用来控制应用程序。
- en: 'To create a GUI that uses only the REST API to communicate with our Java backend,
    we will use a popular JavaScript framework: AngularJS ([http://angularjs.org/](http://angularjs.org/)).
    We won''t get into too much detail of the JavaScript code. The most interesting
    part for us is the usage of our REST API, which we currently consume only in a
    Java application.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个仅使用REST API与我们的Java后端通信的GUI，我们将使用一个流行的JavaScript框架：AngularJS ([http://angularjs.org/](http://angularjs.org/))。我们不会深入探讨JavaScript代码的细节。对我们来说，最有趣的部分是使用我们的REST
    API，我们目前只在Java应用程序中消费它。
- en: 'As seen in [Chapter 5](part0030_split_000.html#page "Chapter 5. Combining Persistence
    with CDI"), *Combining Persistence with CDI*, we will use WebJars. This time,
    apart from Bootstrap, we need the AngularJS (preferably in Version 3.x) and Angular
    UI Bootstrap package ([http://angular-ui.github.io/bootstrap/](http://angular-ui.github.io/bootstrap/)):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 5 章](part0030_split_000.html#page "第 5 章。将持久性与 CDI 结合") 所见，我们将使用 WebJars。这次，除了
    Bootstrap 之外，我们还需要 AngularJS（最好是 3.x 版本）和 Angular UI Bootstrap 包 ([http://angular-ui.github.io/bootstrap/](http://angular-ui.github.io/bootstrap/))：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that all the files that are required to run this sample are available
    with the code attached to this book.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，所有运行此示例所需的文件都包含在这本书附带的代码中。
- en: 'We will need an `index.html` file to start our work and an empty `scripts`
    directory to store our logic. Our directory structure should currently look like
    this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 `index.html` 文件来开始我们的工作，以及一个空的 `scripts` 目录来存储我们的逻辑。我们的目录结构目前应该如下所示：
- en: '![Adding AngularJS](img/00069.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![添加 AngularJS](img/00069.jpeg)'
- en: 'In the `index.html` file, we need to add all the required libraries along with
    our well-known Bootstrap structure:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index.html` 文件中，我们需要添加所有必需的库以及我们熟知的 Bootstrap 结构：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You may have also noticed two strange-looking attributes in the `html` tags:
    `ng-app` and `ng-controller`. These are AngularJS directives that point to the
    web page being an AngularJS application, and that the container div will use a
    `SeatCtrl` controller.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还注意到了 `html` 标签中的两个看起来很奇怪的属性：`ng-app` 和 `ng-controller`。这些是 AngularJS 指令，指向的网页是一个
    AngularJS 应用程序，并且容器 div 将使用 `SeatCtrl` 控制器。
- en: 'Now, we will need the following files placed in our `scripts` directory. The
    first one is the initialization file `app.js`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在 `scripts` 目录中放置以下文件。第一个是初始化文件 `app.js`：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next we will initialize the address of our seat resource in `scripts/services/seatservice.js`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `scripts/services/seatservice.js` 中初始化座位资源的地址：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, we mapped our REST URL to the JavaScript code along with two
    HTTP methods: `GET` and `POST`. They will be called by the controller to communicate
    with the server; the same goes for our account resource, as shown in the following
    code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将我们的 REST URL 与 JavaScript 代码以及两个 HTTP 方法：`GET` 和 `POST` 映射在一起。它们将由控制器调用以与服务器通信；我们的账户资源也是如此，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we create a simple controller to place our logic at `scripts/controllers/seat.js`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个简单的控制器，将我们的逻辑放在 `scripts/controllers/seat.js`：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The highlighted portions of code are calls to the services we defined previously.
    For instance, `$scope.seats = SeatService.query()` will issue a `GET` request
    to retrieve a list of seats in the JSON format. The case for `seat.$book` is similar;
    it will issue a `POST` request to book a specific seat.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码部分是我们之前定义的服务调用。例如，`$scope.seats = SeatService.query()` 将发出一个 `GET` 请求以获取座位列表的
    JSON 格式。对于 `seat.$book` 的情况类似；它将发出一个 `POST` 请求以预订特定的座位。
- en: 'Our whole JavaScript logic is now in place. One final move is to place some
    HTML code bound to it in our `index.html` file. Insert the following code in the
    `index.html` file, inside the `content` div:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的全部 JavaScript 逻辑现在都已就绪。最后的步骤是将一些与它绑定的 HTML 代码放在我们的 `index.html` 文件中。在 `index.html`
    文件中，在 `content` div 内插入以下代码：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The code is similar to the JSF tables we created in the earlier chapters. What
    is important to us is that the `{{ }}` symbols are used by AngularJS to bind the
    displayed data with a variable in a controller, which, in fact, is a representation
    of our REST endpoints.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与我们在早期章节中创建的 JSF 表类似。对我们来说重要的是，`{{ }}` 符号被 AngularJS 用于将显示的数据与控制器中的一个变量绑定，实际上这是一个我们
    REST 端点的表示。
- en: Additionally, the `ng-click` directives are bound to the appropriate methods
    in the controller. The `bookTicket` method issues a `seat.$book` call, which is
    propagated as a `POST` request to our backend.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ng-click` 指令绑定到控制器中适当的方法。`bookTicket` 方法发出一个 `seat.$book` 调用，这作为一个 `POST`
    请求传播到我们的后端。
- en: 'We can now deploy our application to the server. After going to `http://localhost:8080/ticket-agency-ws/index.html`
    in your browser, you should see your application running, as shown in the following
    screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将我们的应用程序部署到服务器上。在浏览器中访问 `http://localhost:8080/ticket-agency-ws/index.html`
    后，你应该能看到你的应用程序正在运行，如下面的截图所示：
- en: '![Adding AngularJS](img/00070.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![添加 AngularJS](img/00070.jpeg)'
- en: 'You can use the developer''s tools in Chrome (or FireBug in Mozilla Firefox)
    to inspect the `rest` calls that are done against the server; simply press *F12*
    and switch to the **Network** tab:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Chrome（或Mozilla Firefox中的FireBug）的开发者工具来检查针对服务器的`rest`调用；只需按下*F12*并切换到**网络**标签页：
- en: '![Adding AngularJS](img/00071.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![添加AngularJS](img/00071.jpeg)'
- en: Congratulations! You have just created a modern Internet application and combined
    it with a REST API that was earlier used by a standalone console application!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚创建了一个现代互联网应用，并将其与之前由独立控制台应用使用的REST API相结合！
- en: Choosing between SOAP and REST services
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择SOAP和REST服务
- en: The choice of adopting SOAP rather than REST depends on your application's requirements.
    SOAP web services are exposed using their own well-defined protocol and focus
    on exposing pieces of application logic as services. So if your requirement is
    to consume business services that are exposed using a well-defined and negotiated
    contract (between the service consumer and service provider), SOAP web services
    are a perfect match.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 采用SOAP而不是REST的选择取决于您的应用需求。SOAP网络服务使用它们自己定义良好的协议，并专注于公开应用逻辑的片段作为服务。因此，如果您的需求是消费使用定义良好且经过协商的合同（在服务消费者和服务提供者之间）公开的业务服务，SOAP网络服务是一个完美的匹配。
- en: On the other hand, if you need to access some server resources using stateless
    HTTP invocations and as little as possible of the navigation bar of your browser,
    you should probably go with RESTful web services.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您需要使用无状态的HTTP调用访问某些服务器资源，并且尽可能少地使用浏览器导航栏，那么您可能应该选择RESTful网络服务。
- en: That being said, there may still be some scenarios that could fit both the options,
    and you are free to choose whichever web service suits your requirements the best.
    Recently, REST has gained popularity, thanks to its interoperability. We use only
    the HTTP protocol and JSON, which almost every language can handle. Therefore,
    a REST API developed using Java EE can be used by a wide variety of clients along
    with mobile devices. Often, this feature is a deal breaker when it comes to designing
    a system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，仍有一些场景可能适合这两种选项，您可以根据自己的需求自由选择最适合的Web服务。最近，由于其互操作性，REST变得流行。我们只使用HTTP协议和JSON，这几乎每种语言都能处理。因此，使用Java
    EE开发的REST API可以由各种客户端以及移动设备使用。通常，当设计系统时，这个特性是一个决定性的因素。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced some of the basic web services concepts so that
    you could get acquainted with these technologies before using them to enhance
    your ticket application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了基本网络服务概念，以便您在使用它们来增强您的票务应用之前熟悉这些技术。
- en: Then, we went through SOAP-based web services that are based on a contract between
    the service and client defined by the WSDL file. SOAP web services are an excellent
    option to integrate systems when you have well-defined, abstract operations exposed
    using standard XML files.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了基于WSDL文件定义的服务和客户端之间合同的基础上的SOAP网络服务。当您使用标准XML文件公开了定义良好、抽象的操作时，SOAP网络服务是集成系统的绝佳选择。
- en: 'Then, we discussed REST services. The key to the REST methodology is to write
    web services using an interface that is already well known and widely used: the
    URI. The twist here is to identify the key system resources (this can be entities,
    collections, or anything else the designer thinks is worthy of having its own
    URI) and expose them using standard methods that are mapped to standard methods.
    In this case, the HTTP verbs are mapped to resource-specific semantics.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了REST服务。REST方法的关键是使用一个已知且广泛使用的接口编写网络服务：URI。这里的转折点是识别关键系统资源（这可以是实体、集合或设计师认为值得拥有自己的URI的任何其他东西），并使用映射到标准方法的标准方法公开它们。在这种情况下，HTTP动词被映射到资源特定的语义。
- en: 'We created two applications that use our REST API: one console-based and one
    written purely in JavaScript using AngularJS. Both of these use the same REST
    endpoints and the second one knows only about JSON; it has no idea about the Java
    classes underneath (or even about Java).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个使用我们的REST API的应用程序：一个基于控制台，另一个完全使用JavaScript编写，使用AngularJS。这两个都使用相同的REST端点，第二个只知道JSON；它对底层的Java类（甚至Java本身）一无所知。
- en: 'We discussed application server resources a lot. In the next chapter, we will
    explore another approach for client-server communication: WebSockets.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了很多应用服务器资源。在下一章中，我们将探讨客户端-服务器通信的另一种方法：WebSocket。
