- en: Migrating Your Code to Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的代码迁移到Java 9
- en: In the previous chapter, we looked at what it takes to start with a pre-Java
    9 code base and have it compile or run with minimal changes in the new Java 9
    platform. We also looked at some problems you could face with your legacy code
    and how to solve them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们探讨了从一个Java 9之前的代码库开始，使其在新的Java 9平台上编译或运行所需的最小更改。我们还探讨了您可能会遇到的一些遗留代码问题以及如何解决这些问题。
- en: If you are working on a code base that you expect to make many changes or enhancements
    to, then you'll want to do more than just run it in Java 9\. You'll want to take
    advantage of the modularity features that Java 9 provides. Of course, you shouldn't
    always blindly rewrite your application to use modules just because you can! The
    advantages of modularity--strong encapsulation and reliable configuration--are
    the most useful in applications where there is a large code base with clear boundaries
    and multiple teams working on it. In this chapter, we'll take a look at how you
    can use those new modularity features and gradually introduce them to your pre-Java
    9 codebase.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在对一个预期将进行许多更改或增强的代码库进行工作，那么您不仅想要在Java 9上运行它。您想要利用Java 9提供的模块化特性。当然，您不应该盲目地重写应用程序以使用模块，仅仅因为您能够这样做！模块化的优势——强大的封装和可靠的配置——在具有大型代码库、清晰的边界和多个团队共同工作的应用程序中最为有用。在本章中，我们将探讨如何使用这些新的模块化特性，并逐步将它们引入到您的Java
    9之前的代码库中。
- en: 'These are the topics we''ll be covering in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Migration strategy for codebases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码库迁移策略
- en: Automatic modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动模块
- en: Library migration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库迁移
- en: Multi-release JARs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多版本JAR文件
- en: We'll be working on the shopping bag example that we've looked at in the previous
    chapter. We've got it compiling and running in the Java 9 platform. We'll now
    be adding modularity features to the code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在前一章中讨论的购物袋示例上继续工作。我们已经将它编译并运行在Java 9平台上。现在，我们将向代码中添加模块化特性。
- en: Now, how do you go about doing something like that? In the case of a small application,
    like the example code we are looking at, it is trivial to make a complete change
    across the application--you can split a small codebase into modules based on the
    roles that different types in your code performs. And then wrap the individual
    modules in modules with the right module definitions. Easy!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您如何进行类似的事情呢？在小型应用程序的情况下，例如我们正在查看的示例代码，在整个应用程序中进行全面更改是微不足道的——您可以根据代码中不同类型所扮演的角色将小型代码库分割成模块。然后，用正确的模块定义将各个模块包装起来。简单！
- en: Unfortunately, most real-world applications are much larger and more complex.
    Thus, they cannot be modularized with a **big bang** approach. You'll have to
    gradually chunk away at it, moving portions of the application into modules. How
    would this work in an application where a portion of the code is modularized while
    the rest isn't? In addition, most applications, especially enterprise Java applications,
    use some kind of a framework or library to handle application infrastructure.
    What does Java 9 migration mean in those cases? Would the libraries need to be
    rewritten to use modules as well? Could you modularize your application while
    the libraries are not yet modularized? Before we answer these questions, let's
    first understand what the migration goal is. What are we trying to achieve?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，大多数现实世界的应用程序都更大、更复杂。因此，它们不能通过“大爆炸”方法进行模块化。您将不得不逐步将其分割成块，将应用程序的部分移动到模块中。在一个部分代码已经模块化而其余部分没有的应用程序中，这会是如何运作的呢？此外，大多数应用程序，尤其是企业Java应用程序，都使用某种类型的框架或库来处理应用程序基础设施。在这些情况下，Java
    9迁移意味着什么呢？库是否需要重写以使用模块？在库尚未模块化的情况下，您能否模块化您的应用程序？在我们回答这些问题之前，让我们首先了解迁移目标是什么。我们试图实现什么？
- en: Understanding the migration goal
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解迁移目标
- en: Let's assume you are done with the steps in the previous chapter and your legacy
    code now complies or runs in Java 9\. You are ready for the next step--to migrate
    your code to use Java 9 modules! What does that look like?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经完成了前一章中的步骤，并且您的遗留代码现在符合或可以在Java 9上运行。您已经准备好下一步——将您的代码迁移到使用Java 9模块！这看起来会是什么样子？
- en: 'Here''s a very high-level picture that shows the different elements of a typical
    pre-Java 9 application running on a Java 9 platform:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常高级的图示，展示了在Java 9平台上运行的典型Java 9之前应用程序的不同元素：
- en: '![](img/00094.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00094.jpeg)'
- en: You can break a typical application down into three distinct layers. At the
    very top layer are the **application classes and jars**. Typical applications
    have a combination of **application classes and jars** along with any internal
    libraries, such as shared utility components. All of these are application specific.
    Since the application is yet to be migrated to Java 9, this layer consists of
    classes and jars in the classpath.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个典型应用程序分解为三个不同的层。在最顶层是**应用程序类和JAR文件**。典型应用程序结合了**应用程序类和JAR文件**以及任何内部库，例如共享的实用组件。所有这些都是特定于应用程序的。由于应用程序尚未迁移到Java
    9，因此这一层由classpath中的类和JAR文件组成。
- en: The second layer denotes any **frameworks** that the application might be using.
    It's very rare to find Java applications these days that do not use an application
    framework of some sort. Frameworks such as Spring, Vaadin, JSF, and Hibernate
    are very commonly used. These are typically bundled into the application as `.jar`
    files, either downloaded manually or through a dependency management utility such
    as Maven or Gradle. Will the libraries be in the classpath or the module path?
    It depends on the library, and if the authors have migrated it to Java 9\. If
    the libraries are already migrated, all you need to do is simply add them to the
    module path! However, for the sake of this chapter, let's assume that the libraries
    are still not migrated, so that you know how to tackle the more complex scenario.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层表示应用程序可能使用的任何**框架**。现在很难找到不使用某种应用程序框架的Java应用程序。Spring、Vaadin、JSF和Hibernate等框架非常常用。这些通常捆绑到应用程序中作为`.jar`文件，无论是手动下载还是通过Maven或Gradle之类的依赖关系管理工具。库将在classpath中还是在模块路径中？这取决于库，以及作者是否将其迁移到Java
    9。如果库已经迁移，你只需将它们添加到模块路径即可！然而，为了本章的目的，让我们假设库尚未迁移，这样你就知道如何处理更复杂的情况。
- en: The third layer is the underlying **Java Platform** that powers it all. This,
    as we've seen in this book, is a fully modularized platform as of Java 9.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第三层是所有这一切背后的底层**Java平台**。正如我们在本书中看到的，自Java 9起，这是一个完全模块化的平台。
- en: 'Since we are assuming that none of the application code or the libraries are
    Java 9 modules, they are primarily running in the class path, and the module path
    is completely empty. This is just the way we left our code at the end of the previous
    chapter. Here''s the *before* picture:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们假设应用程序代码或库都不是Java 9模块，它们主要在classpath中运行，而模块路径完全为空。这正是我们在上一章结束时留下的代码的方式。以下是*之前*的图片：
- en: '![](img/00095.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.jpeg)'
- en: 'The goal is to create modules and move everything from the **classpath** into
    the **module path**. Once we are done, the **classpath** will be empty and everything
    that the application needs will run from the **module path**. Here''s the ideal
    *after* picture:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是创建模块，并将所有内容从**classpath**移动到**模块路径**。一旦完成，**classpath**将变为空，应用程序所需的所有内容都将从**模块路径**运行。以下是理想的*之后*图片：
- en: '![](img/00096.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpeg)'
- en: Notice that in the *after* picture, we aren't even using the **classpath** anymore.
    All the code and binaries we need are now converted to modules and made available
    in the **module path**. Thus, in an ideal world, there is no need to even pass
    the classpath argument! Also, notice that I have intentionally changed the representation
    of modules to random sizes. This is to highlight that there might not be a one-to-one
    mapping between the JARs and classes in the classpath to the converted modules.
    You might break a single JAR in your Java 8 application into multiple modules
    in Java 9 or merge multiple JARs into a single module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在*之后*的图片中，我们甚至不再使用**classpath**了。我们现在需要的所有代码和二进制文件都已转换为模块，并在**模块路径**中提供。因此，在一个理想的世界里，甚至不需要传递classpath参数！此外，请注意，我故意将模块的表示改为随机大小。这是为了强调，JAR文件和classpath中的类与转换后的模块之间可能不存在一对一的映射。你可能会在Java
    9中将Java 8应用程序中的一个JAR文件拆分为多个模块，或者将多个JAR文件合并为一个模块。
- en: Now that we have an idea about what the end goal is, let's look at the migration
    strategy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对最终目标有了概念，让我们来看看迁移策略。
- en: Beginning the migration
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始迁移
- en: Let's go through the migration process by working on the sample shopping bag
    application. It's a simple app that contains three classes--one to read user input,
    one to provide a shopping bag functionality, and one class with a main method
    to drive execution--iteratively taking in user input, adding it to the shopping
    bag, and then printing the contents of the bag. The application has a dependency
    on the commons collections JAR file for the Bag data structure. It also calls
    the Java logging API to log the start and end times to the console.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过处理示例购物袋应用程序来逐步进行迁移过程。这是一个简单的应用程序，包含三个类——一个用于读取用户输入，一个提供购物袋功能，还有一个包含main方法的类来驱动执行——迭代地接收用户输入，将其添加到购物袋中，然后打印袋中的内容。该应用程序依赖于commons
    collections JAR文件中的Bag数据结构。它还调用Java日志API将开始和结束时间记录到控制台。
- en: The shopping bag application has code that is referred to as a *monolith*. That
    is, all the code that forms the app is in one code base. This is really a simplification,
    and does not represent a real-world application that could span multiple projects
    and have different build artifacts that are bundled together. We'll keep things
    simple and run through the migration process with the simplified monolithic code
    base first and then expand it to a multi-project setup.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 购物袋应用程序中的代码被称为*单体*。也就是说，构成应用程序的所有代码都在一个代码库中。这实际上是一种简化，并不代表一个可能跨越多个项目并具有不同构建工件捆绑在一起的真实世界应用程序。我们将保持简单，首先使用简化的单体代码库运行迁移过程，然后将其扩展到多项目设置。
- en: 'We are starting with the code in the `01-legacy-app` folder. The application
    code is in the `src` folder and the commons collections JAR in the `lib` folder:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`01-legacy-app`文件夹中的代码开始。应用程序代码在`src`文件夹中，commons collections JAR在`lib`文件夹中：
- en: '![](img/00097.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00097.jpeg)'
- en: The first step to modularizing this application is to create one big module
    that wraps around the entire application. We've run this application in the classpath
    in [Chapter 10](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb), *Preparing
    Your Code for Java 9*. The platform helped us there by creating an unnamed module
    that housed all of our code, which was an automatic process. This time, we'll
    do this ourselves by creating a module for our application called `packt.shoppingbag`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将此应用程序模块化的第一步是创建一个大的模块，它围绕整个应用程序。我们在[第10章](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb)中运行了这个应用程序，*为Java
    9准备你的代码*。平台通过创建一个包含所有我们代码的无名模块来帮助我们，这是一个自动的过程。这次，我们将自己创建一个名为`packt.shoppingbag`的应用程序模块。
- en: 'First, just like before, let''s assign a module source folder where the source
    of all the modules resides. You can either create a new folder or use the existing
    `src` folder. I''ll choose the latter. In the `src` folder, create a module room
    folder, `packt.shoppingbag`, and a `module-info.java` file within it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，就像之前一样，让我们指定一个模块源文件夹，其中包含所有模块的源代码。你可以创建一个新的文件夹或使用现有的`src`文件夹。我将选择后者。在`src`文件夹中，创建一个名为`packt.shoppingbag`的模块文件夹，并在其中创建一个`module-info.java`文件：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's just an empty module descriptor for now. We'll get back to this in a bit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这只是一个空的模块描述符。我们稍后会回到这个问题。
- en: 'Now that we have a module root, you can move the entire source (with the package
    name folder hierarchy) into the module root folder. The source code in the `11-migrating-application/02-migrating-to-one-module`
    folder represents this state of the code base:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了模块根，你可以将整个源代码（包括包名文件夹层次结构）移动到模块根文件夹中。`11-migrating-application/02-migrating-to-one-module`文件夹中的源代码代表了代码库的这种状态：
- en: '![](img/00098.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00098.jpeg)'
- en: What we have now is far from a *modular* Java application. However, it does
    technically have one module. So, the way to compile and execute this application
    needs to be similar to what we've done so far in this book. That is, use the module
    source path argument for the source location containing the module root and the
    module path argument to point to the location of the compiled modules.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有的远非一个*模块化*的Java应用程序。然而，从技术上讲，它确实有一个模块。因此，编译和执行此应用程序的方式需要与我们在这本书中迄今为止所做的方式相似。也就是说，使用模块源路径参数来指定包含模块根的源位置，并使用模块路径参数指向编译模块的位置。
- en: 'Let''s try compiling this application. We''ll first create a folder called
    out to contain the compiled classes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编译这个应用程序。我们首先创建一个名为out的文件夹来包含编译后的类：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s the javac command we''ve used all along:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是到目前为止我们使用的javac命令：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run this, you''ll get the following error:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，你会得到以下错误：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The compiler is unable to find the commons collections dependency. Makes sense!
    The JAR in the `lib` folder and we never told the compiler about it. Now, can
    we add this JAR to the class path and compile again?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器无法找到commons collections依赖项。这很合理！`lib`文件夹中的JAR文件，而我们从未告诉编译器关于它。现在，我们可以将这个JAR文件添加到类路径中并再次编译吗？
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Nope, that won''t work either. Why is that? Here''s a picture of the application
    we have now:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不行，这也不会起作用。为什么？下面是我们现在拥有的应用程序的图片：
- en: '![](img/00099.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00099.jpeg)'
- en: 'We''ve moved the application code into the **module path**, but the library
    (in our case, a single JAR file) still exists in the **classpath**. And, since
    it is in the **classpath**, it is a part of the automatically created unnamed
    module. We''ve already seen how the unnamed module reads all resolved modules
    by default. Thus, any code in the unnamed module can access types in the **module
    path**. This is what we did in [Chapter 10](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb),
    *Preparing Your Code for Java 9*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将应用程序代码移动到**模块路径**中，但库（在我们的例子中是一个单独的JAR文件）仍然存在于**类路径**中。由于它位于**类路径**中，它成为了自动创建的未命名模块的一部分。我们已经看到未命名模块默认读取所有解析的模块。因此，未命名模块中的任何代码都可以访问**模块路径**中的类型。这就是我们在[第10章](part0161.html#4PHAI0-ed2405f4162b4f86b565edd6b6d679fb)，“为Java
    9准备您的代码”中做的事情：
- en: '![](img/00100.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00100.jpeg)'
- en: However, what we are trying to do here is the other way round. We want a module
    in the **module path** to access types from the **unnamed module**, and there's
    the problem. It turns out that no other module can read the **unnamed module**!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这里试图做的正好相反。我们希望**模块路径**中的模块能够访问**未命名模块**中的类型，这就是问题所在。结果是，没有任何其他模块可以读取**未命名模块**！
- en: '![](img/00101.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00101.jpeg)'
- en: This is an intentional restriction. Every module needs to meet the requirements
    of strong encapsulation and reliable configuration. If a module were to read the
    class path, we'd basically be tossing reliable configuration out of the window!
    Since the class path does not have reliable configuration, there's no way the
    platform can verify if the module has everything it needs. So, preventing explicit
    Java 9 modules from accessing the classpath is a Good Thing™.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有意为之的限制。每个模块都需要满足强封装和可靠配置的要求。如果模块要读取类路径，我们基本上就会把可靠的配置抛出窗外！由于类路径没有可靠的配置，平台无法验证模块是否拥有它所需的一切。因此，防止显式Java
    9模块访问类路径是一件好事™。
- en: It does cause a major problem with migration though. Moving code from the class
    path to the module path is taking it down a one-way street. Once the code is crossed
    over to the module path, it cannot access anything from the class path. It's not
    so much an issue for your application code. Like we've seen, you can take your
    entire code base and put it in a giant named module, like we did with the shopping
    bag app. And now, none of your code is in the classpath. Great! However, what
    about libraries? Almost every Java application has third-party libraries and frameworks
    that are mostly JARs pulled in from the internet and bundled into the classpath.
    Since we don't control or maintain the library code, we cannot put their code
    in a module and wrap them with a module descriptor. So, until the authors of your
    libraries get to migrate their code to Java 9, you are stuck with non-modular
    libraries. How can your types access them? Do you have to hold off on modularizing
    your code until the very last library you use has its code migrated to Java 9?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实会在迁移过程中引起重大问题。将代码从类路径移动到模块路径是在走一条单行道。一旦代码跨越到模块路径，它就无法访问类路径中的任何内容。这对你应用程序的代码来说并不是一个大问题。就像我们看到的，你可以将整个代码库放入一个巨大的命名模块中，就像我们在购物袋应用程序中做的那样。现在，你的所有代码都不在类路径中。太好了！然而，关于库怎么办？几乎每个Java应用程序都有第三方库和框架，这些库主要是从互联网上拉取的JAR文件，并捆绑到类路径中。由于我们无法控制或维护库代码，我们不能将它们的代码放入模块中并用模块描述符包装它们。因此，直到你的库的作者将它们的代码迁移到Java
    9，你将不得不使用非模块化的库。你的类型如何访问它们？你不得不等到你使用的最后一个库的代码迁移到Java 9之后才模块化你的代码吗？
- en: Thankfully, that's not the case. The platform helps, once again, with the ability
    to create modules from JARs automatically. These modules are called **automatic
    modules**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，情况并非如此。平台再次通过创建模块的能力来提供帮助。这些模块被称为**自动模块**。
- en: Automatic modules
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动模块
- en: In order to avoid the problems with third-party library dependencies, which
    we just discussed, the Java platform has a mechanism to automatically create modules
    from JAR files. You don't need to access the library code or even create a module
    descriptor. All you need is the JAR file. This works great because, for any third-party
    library, the one thing that you are sure to have is the JAR file!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免我们刚才讨论的第三方库依赖问题，Java 平台有一个机制可以自动从 JAR 文件创建模块。你不需要访问库代码或甚至创建模块描述符。你只需要 JAR
    文件。这很好，因为对于任何第三方库，你确定会有的就是 JAR 文件！
- en: 'Okay, what does it take to convert a JAR file into an automatic module and
    drop them into your application? The answer is--nothing! All you need to do is
    drop any JAR file into the module path. The platform automatically converts it
    into a module. Here are the things that the platform does to every JAR that it
    encounters in the module path:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，将 JAR 文件转换为自动模块并将其放入应用程序中需要什么？答案是--什么也不需要！你只需要将任何 JAR 文件放入模块路径中。平台会自动将其转换为模块。以下是平台对模块路径中遇到的每个
    JAR 文件所执行的操作：
- en: It automatically converts the JAR into a module and gives it a name
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自动将 JAR 转换为模块并给它命名
- en: It sets up the module definition--What the module reads and exports
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设置了模块定义--模块读取和导出的内容
- en: And since they are now modules with a name (albeit automatically created), your
    code can depend on and require them just like any other module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们现在是有名称的模块（尽管是自动创建的），你的代码可以像依赖和引用任何其他模块一样依赖和引用它们。
- en: Let's examine the preceding two options in detail.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查前两个选项。
- en: Automatic module naming
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动模块命名
- en: Given a JAR file, how does the platform know what to name it? For instance,
    if I were to drop the JAR file we are currently working with--`commons-collections4-4.1.jar`--into
    the module path, what would be the name of the module that gets created from it?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 JAR 文件，平台是如何知道如何命名它的？例如，如果我把我们目前正在使用的 JAR 文件--`commons-collections4-4.1.jar`--放入模块路径中，从它创建的模块将叫什么名字？
- en: Naming of an automatic module is based off of the name of the JAR file, without
    the `.jar` extension. For example, if your JAR is named `foo.jar`, the name of
    the automatic module is `foo`! But, wait! What about invalid characters? It's
    very common to have the `-` character in the JAR name, but it's not allowed in
    module names. In such cases, the `-` character is automatically replaced by the
    `.` character. So, if the JAR file's name is `my-lib.jar` , the name of the automatic
    module would be `my.lib`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 自动模块的命名基于 JAR 文件名，但不包括 `.jar` 扩展名。例如，如果你的 JAR 文件名为 `foo.jar`，则自动模块的名称是 `foo`！但是，等等！关于无效字符怎么办？在
    JAR 文件名中包含 `-` 字符是很常见的，但在模块名称中是不允许的。在这种情况下，`-` 字符会自动被 `.` 字符替换。所以，如果 JAR 文件名是
    `my-lib.jar`，则自动模块的名称将是 `my.lib`。
- en: While this naming works, it can be a hassle. It's because most JARs (especially
    ones from Maven or Gradle build systems) commonly have the version number in the
    name. This means that every time you get a new version of the JAR, the name of
    the module changes! To prevent that, and to make the library module names consistent,
    the automatic module name drops the version number from the name.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种命名方式可行，但可能会很麻烦。这是因为大多数 JAR 文件（尤其是来自 Maven 或 Gradle 构建系统的 JAR 文件）通常在名称中包含版本号。这意味着每次你获取
    JAR 文件的新版本时，模块的名称都会改变！为了避免这种情况，并使库模块名称保持一致，自动模块名称会从名称中删除版本号。
- en: 'In summary, given a JAR file name, the automatic module naming does the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，给定一个 JAR 文件名，自动模块命名执行以下操作：
- en: It drops the `.jar` file extension
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它删除了 `.jar` 文件扩展名
- en: It replaces `-` characters with `.`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 `-` 字符替换为 `.` 字符
- en: It removes the version string
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它删除了版本字符串
- en: Thus, the JAR, `commons-collections4-4.1.jar`, gets the automatic module name--
    `commons.collections4`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JAR 文件 `commons-collections4-4.1.jar` 获得了自动模块名称-- `commons.collections4`。
- en: 'Here are a few more examples:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些其他示例：
- en: '| **JAR file name** | **Automatic module name** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **JAR 文件名** | **自动模块名称** |'
- en: '| `commons-lang-1.2.10.jar` | `commons.lang` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `commons-lang-1.2.10.jar` | `commons.lang` |'
- en: '| `spring-core-4.3.10.RELEASE.jar` | `spring.core` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `spring-core-4.3.10.RELEASE.jar` | `spring.core` |'
- en: '| `guice-4.1.0.jar` | `guice` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `guice-4.1.0.jar` | `guice` |'
- en: Automatic module definition
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动模块定义
- en: What does the automatic module *require* and *export*? The answer is--everything!
    Remember that the platform creates the module descriptor automatically, so it
    has no idea what the module needs or what it will be used for. To make sure things
    work, it creates the least restrictive module definition possible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自动模块*需要*和*导出*什么？答案是——一切！记住，平台会自动创建模块描述符，所以它不知道模块需要什么或它将被用于什么。为了确保一切正常工作，它创建了最不限制的模块定义。
- en: It `requires transitive` all resolved modules
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它`requires transitive`所有已解析的模块
- en: It exports all modules
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它导出所有模块
- en: It reads the unnamed module (that is, all code in the classpath)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它读取未命名的模块（即类路径中的所有代码）
- en: I hope you agree that this is the worst module definition you can possibly create
    for a module. However, this is required to ensure that the libraries in the Java
    ecosystem work seamlessly as automatic modules. This is not the ideal end state.
    We'd like to move to an environment where all the libraries are modularized too,
    and we work with actual modular JAR files with well-defined `requires` and `exports`
    definitions in the module path. Until that happens, automatic modules help get
    us going with the migration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你们同意，这是你可以为模块创建的最糟糕的模块定义。然而，这是确保Java生态系统中的库作为自动模块无缝工作的必要条件。这不是理想的状态。我们希望迁移到一个所有库都模块化的环境中，并且我们使用具有在模块路径中定义良好的`requires`和`exports`定义的实际模块JAR文件。直到那时，自动模块帮助我们开始迁移。
- en: Note that the automatic modules `requires transitive` all resolved modules.
    You read that right! When you depend on an automatic module, you read *everything*,
    whether you want it or not! Be very cautious about what dependencies you use.
    Just because you get readability to any module doesn't mean it's okay to use it.
    Always keep the module definition in mind. Automatic modules are just a stop-gap
    arrangement. You don't want to take the readability relationship you get for granted.
    Remember that when the automatic module goes away, the transitive readability
    goes away with it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，自动模块`requires transitive`解决了所有已解析的模块。你读得对！当你依赖于一个自动模块时，你会读取*所有*内容，无论你是否需要！请非常谨慎地使用你依赖的模块。仅仅因为你可以读取任何模块，并不意味着使用它是可以的。始终牢记模块定义。自动模块只是一个权宜之计。你不应该把从自动模块得到的可读性关系视为理所当然。记住，当自动模块消失时，传递的可读性关系也会随之消失。
- en: Migrating with automatic modules
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自动模块进行迁移
- en: With this knowledge of automatic modules, let's resume the migration of the
    shopping bag application. We need to get the commons collection JAR out of the
    classpath and made into an automatic module. To do that, rather than moving the
    JAR, we'll just supply the `--module-path` argument with the path to the JAR (the
    `lib` folder), thereby making the JAR file in the module path. (Unlike the classpath,
    you don't have to specify the file name. Just the folder location will do.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 带着对自动模块的了解，让我们继续迁移购物袋应用程序。我们需要将commons collection JAR从类路径中移除，并制作成自动模块。为此，我们不会移动JAR文件，而是只需提供带有JAR文件路径（`lib`文件夹）的`--module-path`参数，从而在模块路径中创建JAR文件。（与类路径不同，你不需要指定文件名。只需文件夹位置即可。）
- en: 'Here''s the compiler command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编译器命令：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get the following different errors now:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将得到以下不同的错误：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This fix should be a bit more obvious. The compiler is complaining that the
    `packt.shoppingbag` module does not *require* the modules whose types it uses.
    It uses the logging API (in module `java.logging`) and the Commons Collections
    API (from the now-created automatic module called `commons.collections4`). Let''s
    add them both as dependencies in `module-info.java`. Note that we are using the
    automatic module name to establish read relationships just like any other Java
    9 module:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修复应该更明显一些。编译器抱怨`packt.shoppingbag`模块没有*要求*它使用的模块。它使用了日志API（在模块`java.logging`中）和Commons
    Collections API（来自现在创建的自动模块`commons.collections4`）。让我们在`module-info.java`中将它们都添加为依赖项。请注意，我们使用自动模块名称来建立读取关系，就像任何其他Java
    9模块一样：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this sample application, we are using just one JAR file. It is far from a
    realistic scenario. Most real-world applications have multiple JARs. So, this
    step would involve converting all the necessary JARs into automatic modules by
    adding them to the module path and then adding the right `requires` declaration
    in your module definition files.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例应用程序中，我们只使用了一个JAR文件。这远非一个现实场景。大多数现实世界应用程序都有多个JAR文件。因此，这一步将涉及将所有必要的JAR文件转换为自动模块，通过将它们添加到模块路径，然后在你的模块定义文件中添加正确的`requires`声明。
- en: When compiling again, things should work without any errors. To execute, we'll
    use the same `java` command with the `--module-path` flag that we've used before,
    with one minor change. We need to add the `lib` folder to the module path, because
    we, again, want the commons collections JAR to be treated as an automatic module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译时，应该没有任何错误。为了执行，我们将使用之前使用的带有 `--module-path` 标志的相同 `java` 命令，但有一个小的变化。我们需要将
    `lib` 文件夹添加到模块路径中，因为我们再次希望将 commons 集合 JAR 文件视为自动模块。
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use the delimiter (`:` for macOS/Linux and `;` for Windows) to separate the
    two module paths--`out`, which has the compiled modules, and `lib`, which has
    the JAR. Everything should work as expected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用分隔符（macOS/Linux 上的 `:` 和 Windows 上的 `;`）来分隔两个模块路径——`out`，其中包含编译模块，和 `lib`，其中包含
    JAR 文件。一切都应该按预期工作。
- en: There is one potential problem that could result from automatic modules that
    you need to watch out for. Remember the split package problem that we discussed
    in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb), *Module
    Resolution, Readability, and Accessibility*? It is not possible for a single package
    to exist in two different modules in Java 9\. However, it is possible for a package
    to exist in two different JARs. Now what happens when you take two such JARs that
    share a package and make them as automatic modules? They don't work, because they
    result in the split package problem. If you encounter this problem with any library
    of yours, there is unfortunately not much you can do. You'll either have to move
    things back to the classpath, or bug the library developers to have them fix their
    code. Or both!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 自动模块可能会引起的一个潜在问题是你需要注意的。还记得我们在[第 6 章](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb)“模块解析、可读性和可访问性”中讨论的拆分包问题吗？在
    Java 9 中，单个包不能存在于两个不同的模块中。然而，一个包可以存在于两个不同的 JAR 文件中。现在，当你将两个共享包的 JAR 文件作为自动模块使用时会发生什么？它们将无法工作，因为它们会导致拆分包问题。如果你在自己的任何库中遇到这个问题，很遗憾，你几乎无能为力。你可能不得不将东西移回类路径，或者联系库的开发者让他们修复代码。或者两者都要做！
- en: Using jdeps to outline module relationships
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `jdeps` 概述模块关系
- en: We used `jdeps` to identify the usage of internal JDK APIs. The tool can do
    much more than that! One feature that comes in handy when migrating code to Java
    9 is the `-summary` option. What this does is go through your compiled modules
    and identify the relationships between different modules. This makes sure that
    you get the right `requires` relationship specified in your modules, including
    the automatic modules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `jdeps` 来识别内部 JDK API 的使用情况。这个工具的功能远不止于此！在将代码迁移到 Java 9 时，一个非常有用的功能是 `-summary`
    选项。这个选项会遍历你的编译模块，并识别不同模块之间的关系。这确保了你在模块中指定的 `requires` 关系是正确的，包括自动模块。
- en: 'Run the following `jdeps` command in the `11-migrating-application/02-migrating-to-one-module`
    folder:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `11-migrating-application/02-migrating-to-one-module` 文件夹中运行以下 `jdeps` 命令：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-recursive` flag instructs `jdeps` to recursively navigate subfolders and
    list the dependencies of modules found in them too.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`-recursive` 标志指示 `jdeps` 递归地遍历子文件夹，并列出其中找到的模块的依赖关系。'
- en: Notice that you get a really helpful output listing what module reads what.
    This is very handy when you have a bunch of JAR dependencies that were compiled
    in Java 8 or earlier, and you are trying to add them as automatic modules; rather
    than guessing what modules need to read these automatic modules, you can just
    run this command and get a good overview.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你会得到一个非常有用的输出列表，列出哪些模块读取了哪些内容。当你有一堆在 Java 8 或更早版本编译的 JAR 依赖项，并且你试图将它们作为自动模块添加时，这非常有用；你不必猜测需要读取这些自动模块的模块，只需运行这个命令就可以得到一个很好的概述。
- en: Refactoring into smaller modules
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码重构为更小的模块
- en: 'Now that you have your codebase in the module source path, the next steps would
    be to gradually break it down into smaller modules. This effort depends on the
    size of your codebase and how much of it you want to tackle at a time. You can
    choose to leave the single module as is and only create modules for any new code
    that you write. Thus, the legacy code does not get the benefit of modularity concepts,
    but any new code does. However, it is highly recommended to do the following two
    steps at this point:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将代码库放在模块源路径中，下一步就是逐步将其分解为更小的模块。这项工作取决于你的代码库的大小以及你一次想要处理多少。你可以选择保持单个模块不变，只为任何你编写的新代码创建模块。因此，遗留代码不会从模块化概念中受益，但任何新代码都会。然而，强烈建议在此处执行以下两个步骤：
- en: Find modular versions or equivalents for your libraries and move the JARs out
    of the module path.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的库找到模块化版本或等效版本，并将 JAR 文件移出模块路径。
- en: Break down the module into smaller modules.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模块分解成更小的模块。
- en: '**Step 1** removes the broad transitive dependencies that automatic modules
    give you, so that you can get more fine-grained control over your dependencies.
    This depends on the libraries you use and if the authors have gotten to migrating
    them to Java 9\. Once a library gets updated to Java 9, the updated version can
    still be placed in the module path, but this time, since they''ll have a proper
    module descriptor, the platform will not need to convert them to automatic modules.
    You might have to check if the new name of the Java 9 modules in those libraries
    are different from the automatic module names you had previously used, and if
    they are, update your module descriptors to use the new library module name.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1** 移除自动模块提供的广泛传递依赖项，这样您就可以对依赖项有更精细的控制。这取决于您使用的库以及作者是否已经将它们迁移到 Java 9。一旦库更新到
    Java 9，更新的版本仍然可以放置在模块路径中，但这次，由于它们将有一个适当的模块描述符，平台将不需要将它们转换为自动模块。您可能需要检查那些库中 Java
    9 模块的新名称是否与您之前使用的自动模块名称不同，如果是，请更新您的模块描述符以使用新的库模块名称。'
- en: '**Step 2** makes sure that the legacy code also gets the benefits of strong
    encapsulation and reliable configuration. Since unlike step 1, we can control
    step 2, let''s do just that for the shopping bag application.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 2** 确保遗留代码也能获得强封装和可靠配置的好处。由于与步骤 1 不同，我们可以控制步骤 2，所以让我们为购物袋应用程序做这件事。'
- en: 'Let''s say we''d like to split the code into the following three modules:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望将代码分解成以下三个模块：
- en: User Input module
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入模块
- en: Bag module
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包模块
- en: App module
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序模块
- en: I know this is an overkill for this small application. However, it helps as
    an example, illustrating the next step in the migration.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这对这个小型应用程序来说有点过度，但是它作为一个例子，说明了迁移的下一步。
- en: The `11-migrating-application/03-splitting-modules` folder contains the state
    of the application after separating the code into multiple modules. Note the module
    descriptors in each module narrow down the dependencies, making it clear which
    part of the code needs those external APIs. The `java.logging` is required just
    by the `packt.app` module. The commons collection is required by `packt.bag`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`11-migrating-application/03-splitting-modules` 文件夹包含将代码分解成多个模块后的应用程序状态。注意每个模块的模块描述符缩小了依赖范围，使得代码的哪些部分需要那些外部API变得清晰。`java.logging`
    仅由 `packt.app` 模块需要。`commons collection` 由 `packt.bag` 需要。'
- en: Handling larger codebases
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理更大的代码库
- en: 'The sample application we modularized is very simple and not a representation
    of most real-world applications. Here are a couple of characteristics in which
    most applications differ:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块化的示例应用程序非常简单，并不代表大多数现实世界应用程序。以下是一些大多数应用程序不同的特性：
- en: They have a *broader* code base that spans multiple projects. These projects
    may reside in different source locations and may be hooked to a build system.
    The build of the main application then gathers the right dependencies together
    to form the final application build.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个更广泛的代码库，跨越多个项目。这些项目可能位于不同的源位置，并且可能连接到构建系统。主应用程序的构建随后将正确的依赖项收集在一起，以形成最终的应用程序构建。
- en: They have many more framework dependencies that have more complex needs. Frameworks
    such as Spring or Hibernate require access to your application code to do reflection.
    They might scan your classes for annotations and do various things such as dependency
    injection and object-relational mapping. In that sense, it is not just your application
    code that needs access to libraries as automatic modules; even such automatic
    modules would need access to your application code.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有更多的框架依赖项，这些依赖项有更复杂的需求。例如，Spring 或 Hibernate 框架需要访问您的应用程序代码以进行反射。它们可能会扫描您的类以查找注解，并执行各种操作，如依赖注入和对象关系映射。从这个意义上说，不仅您的应用程序代码需要访问库作为自动模块，甚至这样的自动模块也需要访问您的应用程序代码。
- en: 'Given such a large Java 8 code base, how do you even begin migrating? Here
    are some steps that you''d typically follow:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这样一个庞大的 Java 8 代码库，您甚至如何开始迁移？以下是一些您通常会遵循的步骤：
- en: '**Step 1**: Draw module boundaries and create a high-level module map:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 1**：绘制模块边界并创建高级模块图：'
- en: In my opinion, modularizing existing code starts with having at least a rough
    high-level idea of the modules you need and how you plan to split the code base.
    We've looked at some strategies and tips to help you draw module boundaries in
    [Chapter 9](part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb), *Module Design
    Patterns and Strategies*. Depending on the complexity of your code, you'll need
    to either look at the code in entirety or in high-level parts and come up with
    some module names and interfaces.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，模块化现有代码首先需要至少有一个大致的高级想法，即你需要哪些模块以及你计划如何拆分代码库。我们查看了一些策略和技巧，以帮助你确定[第9章](part0134.html#3VPBC0-ed2405f4162b4f86b565edd6b6d679fb)，*模块设计模式和策略*中的模块边界。根据你代码的复杂性，你可能需要查看整个代码或高级部分，并想出一些模块名称和接口。
- en: Once you have a rough idea about what your modules will be, you can create a
    module graph that represents the dependencies between these modules. Don't get
    too involved in the details. This is just a rough sketch and you may be inclined
    to make changes to either the modules or their relationships as you get into the
    weeds and start refactoring.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对你的模块有一个大致的想法，你可以创建一个表示这些模块之间依赖关系的模块图。不要过于纠结于细节。这只是一个粗略的草图，当你开始深入细节并进行重构时，你可能倾向于对模块或它们之间的关系进行修改。
- en: '**Step 2**: Modularize the *main* application:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2**：模块化*主要*应用程序：'
- en: Among all the code projects that a large application consists of, there's usually
    one that can be classified as the *main* project. It is the one that perhaps starts
    the execution or the project that is built and deployed as the application. That
    would be a good place to start. You can follow the steps you learned in this chapter
    to bring that application over to the module path first.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型应用程序所包含的所有代码项目中，通常有一个可以归类为*主要*项目。这可能是一个启动执行的项目，或者是一个构建并部署为应用程序的项目。那将是一个好的开始地方。你可以遵循本章学到的步骤，首先将那个应用程序带到模块路径上。
- en: '**Step 3**: Use the module overrides for special library needs:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤3**：使用模块覆盖来满足特殊库需求：'
- en: 'If you are using a framework like Spring or Hibernate, you are sure to run
    into problems when using them as automatic modules. That''s because those frameworks
    typically need access to your code base to reflectively scan your classes for
    annotations. We know that automatic modules read all resolved modules. So, it
    technically reads your application modules that could have Spring annotations.
    However, if your modules do not *export* the packages, it''ll still be unable
    to access them. You can get around this problem in a couple of ways:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Spring或Hibernate等框架，当你将它们用作自动模块时，你肯定会遇到问题。这是因为那些框架通常需要访问你的代码库以反射性地扫描你的类中的注解。我们知道自动模块读取所有解析的模块。所以，技术上它读取了可能包含Spring注解的应用程序模块。然而，如果你的模块没有*导出*包，它仍然无法访问它们。你可以通过几种方式解决这个问题：
- en: Add the `opens` declaration to the packages that contain such annotations in
    your module definition so that the libraries have access to reflect on the necessary
    classes
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的模块定义中将包含此类注释的包添加`opens`声明，以便库能够访问必要的类进行反射
- en: Use the `--add-opens` command-line arguments to achieve the same result
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--add-opens`命令行参数来达到相同的结果
- en: '**Step 4**: Leverage automatic modules for in-house build artifacts:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤4**：利用自动模块为内部构建工件：'
- en: There's no reason why you should not use automatic modules even for your own
    application JARs. Let's say you are migrating a large Maven application with multiple
    artifact dependencies on other projects that are built in-house (or code that
    you own). Those in-house artifacts can be added to the module path and converted
    into automatic modules too. One thing to watch out for here is the split package
    problem. Since we are dealing with in-house code, there's a good chance that there
    are package overlaps between JARs. In such cases, you'll need to refactor your
    code to make sure there are no overlapping packages in JAR files. You can do this
    refactoring while using an older version of Java too.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由你不应该为你的应用程序JAR使用自动模块。假设你正在迁移一个大型Maven应用程序，它依赖于其他内部构建的项目（或你拥有的代码）的多个工件依赖项。这些内部工件可以被添加到模块路径并转换为自动模块。这里需要注意的一点是拆分包问题。由于我们处理的是内部代码，因此JAR之间存在包重叠的可能性很大。在这种情况下，你需要重构你的代码以确保JAR文件中没有重叠的包。你可以在使用较旧版本的Java的同时进行此重构。
- en: '**Step 5a**: Break down the *main* project into smaller modules:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤5a**：将*主要*项目分解成更小的模块：'
- en: Again, following the process we used in this chapter, start chunking away pieces
    of the monolithic module into smaller pieces. Establish clearer dependencies among
    the smaller modules as you go.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，按照本章中使用的流程，开始将单体模块分解成更小的部分。在分解过程中，明确较小的模块之间的依赖关系。
- en: '**Step 5b**: Migrate modules from the leaf up:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤 5b**：从叶子向上迁移模块：'
- en: In parallel to **Step 5a**, you can also start migrating projects other than
    the main project too. Since you've built your module tree, the order of migration
    of modules becomes clear. You can make your migration significantly easier by
    ordering the modules you choose to migrate from the leaf of the module dependency
    tree and work your way toward the top. The ideal candidate for migration is a
    module that does not have any other application module dependency. Dependency
    on Java modules is okay though!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与**步骤 5a**并行，你也可以开始迁移除主项目之外的其他项目。由于你已经构建了模块树，模块迁移的顺序变得清晰。你可以通过从模块依赖树的叶子开始，逐步向上迁移，使迁移过程显著简化。理想的迁移候选者是一个没有其他应用程序模块依赖的模块。对
    Java 模块的依赖是可以接受的，尽管如此！
- en: 'For example, let''s say this is your target module graph for the code that
    you plan to achieve after migration. The graph includes just your application
    modules. Any dependency on platform modules is excluded in this graph:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设这是你计划在迁移后实现的代码的目标模块图。该图仅包括你的应用程序模块。任何对平台模块的依赖都被排除在这个图中：
- en: '![](img/00102.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00102.jpeg)'
- en: The first set of modules you should pick for migration are **D** and **E**.
    Once they are done, migrate **C**, then **A** and **B**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该首先选择迁移的模块集是**D**和**E**。一旦完成，迁移**C**，然后是**A**和**B**。
- en: Migrating libraries
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移库
- en: We've looked at steps and strategies to follow when migrating applications to
    the Java modules. How about libraries? Let's say you are the maintainer of an
    open source library that is used by many people. Or, perhaps, you maintain a library
    that's used by multiple teams in your organization. How would you migrate such
    a code base? Wouldn't that require you to follow the same steps we've covered
    to migrate applications? Well, mostly yes. However, there are certain things you
    need to do differently with libraries. This section covers those details.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了在将应用程序迁移到 Java 模块时需要遵循的步骤和策略。那么库呢？假设你是被许多人使用的开源库的维护者。或者，也许你维护的库被你组织中的多个团队使用。你将如何迁移这样的代码库？这不会要求你遵循我们为迁移应用程序所涵盖的相同步骤吗？嗯，大部分是的。然而，有一些事情你需要对库进行不同的处理。本节将涵盖这些细节。
- en: What's perhaps the biggest difference with libraries is that you no longer work
    in the *context* of an application. A library could be used by multiple applications.
    These applications could be using multiple versions of Java. How could you create
    a single library JAR that could work for all those cases? Thankfully, there are
    some features in the platform that make this easier.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与库相比，最大的不同可能在于你不再在应用程序的**上下文**中工作。一个库可以被多个应用程序使用。这些应用程序可能使用多个版本的 Java。你如何创建一个可以适用于所有这些情况的单一库
    JAR 文件呢？幸运的是，平台中有些功能可以简化这个过程。
- en: 'Before we get into those specific problems, let''s look at what it takes to
    migrate library code to use Java 9 modules. Here are some high-level steps you
    need to follow as a library author:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究这些具体问题之前，让我们看看将库代码迁移到使用 Java 9 模块需要什么。以下是一些作为库作者你需要遵循的高级步骤：
- en: '**Eliminate the JDK internal API usage**: This is no different from what we
    did for applications. We need to make sure the library is a good Java 9 citizen.
    Calls to JDK internals or deprecated APIs are a no-no. Refactor your code to avoid
    the calls or use a replacement that our friendly `jdeps` tool with the `--jdk-internals`
    option suggests.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**消除 JDK 内部 API 的使用**：这与我们为应用程序所做的工作没有不同。我们需要确保库是一个好的 Java 9 公民。对 JDK 内部或已弃用的
    API 的调用是不允许的。重构你的代码以避免调用，或者使用我们的友好工具 `jdeps` 的 `--jdk-internals` 选项建议的替代方案。'
- en: '**Eliminate any split packages**: We''ve looked at how split packages cause
    problems with automatic modules. You''ll need to make sure your JARs do not contain
    packages that could potentially exist in other JARs in your organization. If other
    teams own libraries whose packages conflict with yours, you''ll need to work with
    them to streamline the package names'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**消除任何分割的包**：我们已经探讨了分割包如何导致自动模块出现问题。你需要确保你的 JAR 文件不包含可能存在于你组织中的其他 JAR 文件中的包。如果其他团队拥有的库的包与你的冲突，你需要与他们合作，简化包名。'
- en: '**Identify a name for your core library module**: As with any module, you need
    to come up with a name for the library. This is not that big of a deal when working
    with libraries that are used only in your organization. However, it''s a much
    more important step when dealing with open source modules. Like we''ve covered
    in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb), *Creating
    Your First Java Module*, module names can follow reverse domain name convention.
    You can opt to go with a shorter name for strictly in-house libraries to ease
    readability and communication, because name conflicts are less likely in such
    cases.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为你的核心库模块命名**：与任何模块一样，你需要为库起一个名字。当与仅在你组织内部使用的库一起工作时，这并不是什么大问题。然而，当处理开源模块时，这是一个非常重要的步骤。正如我们在[第2章](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb)“创建你的第一个Java模块”中提到的，模块名称可以遵循反向域名约定。你可以选择为仅限内部使用的库使用更短的名字，以简化可读性和沟通，因为在这些情况下名称冲突的可能性较小。'
- en: '**Start refactoring and converting your code into modules**: This involves
    moving your code into module root folders, adding module descriptors, and defining
    the `requires` and `exports` definitions for your modules. Be careful about any
    types that you encapsulate. If there are consumers of your library using those
    types, they''ll not be able to use them anymore, unless they add the `--add-exports` overrides.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开始重构并将你的代码转换为模块**：这包括将你的代码移动到模块根目录，添加模块描述符，并定义模块的`requires`和`exports`定义。注意任何你封装的类型。如果有使用这些类型的库消费者，他们将无法再使用它们，除非他们添加`--add-exports`覆盖。'
- en: As with application migration, I highly recommend that you survey your library
    code and come up with a high-level module diagram that outlines the relationships
    between modules before you start digging into the code and moving files around.
    It will save you a lot of time and work!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就像应用程序迁移一样，我强烈建议你在深入代码和移动文件之前，对你的库代码进行一次调查，并制定一个高级模块图，概述模块之间的关系。这将为你节省大量的时间和工作！
- en: '**Add transitive dependencies or wrap around dependency leakage**: There''s
    a chance that your library code depends on other libraries. They may be other
    in-house libraries or open source JARs. These libraries may not be migrated to
    Java 9 yet, and we have the same problem we did for application dependencies.
    Here, again, you''ll need to use automatic modules for the JARs that your library
    depends on. If using your APIs requires access to those libraries, it''s a good
    idea to add require transitive on those libraries in your module definition. If
    possible, wrap around those types so that the code consuming your library doesn''t
    have to be aware of this dependency.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加传递依赖或处理依赖泄漏**：有可能你的库代码依赖于其他库。它们可能是其他内部库或开源JAR文件。这些库可能尚未迁移到Java 9，我们面临与应用程序依赖相同的问题。在这里，你同样需要为你的库所依赖的JAR文件使用自动模块。如果你使用你的API需要访问这些库，那么在你的模块定义中添加对这些库的require
    transitive是一个好主意。如果可能的话，将这些类型包装起来，这样使用你的库的代码就不需要知道这个依赖了。'
- en: Reserving library names
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预留库名称
- en: Let's say you are a library developer who is not ready to migrate your code
    to Java 9 yet. We know that's not a problem. Other Java 9 applications can still
    consume your library by dropping the JAR into the module path, thus making an
    automatic module out of it. They use the auto-generated module name from the JAR
    file name and use that in their module definition files. However, what if you
    have a really cool name for your module that you plan to use when you eventually
    get to migrating to Java 9? Does it mean that all the consumers will then have
    to go to all the module definitions that specify the auto-generated name and update
    them to the new module name? That can be tedious.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一个尚未准备好将代码迁移到Java 9的库开发者。我们知道那不是问题。其他Java 9应用程序仍然可以通过将JAR文件放入模块路径中来消费你的库，从而将其自动转换为模块。他们使用从JAR文件名自动生成的模块名称，并在他们的模块定义文件中使用它。然而，如果你有一个计划在最终迁移到Java
    9时使用的非常酷的模块名称，这意味着所有消费者都必须去更新所有指定自动生成名称的模块定义吗？那可能会很麻烦。
- en: The Java 9 platform gives library authors an option to *reserve* a module name
    for their libraries, even before migrating their libraries to Java 9\. So, you,
    as a library author, can specify what you want your Java 9 module name to be in
    the `META-INF/MANIFEST.MF` file in your JAR. You can do this in your Java 8 compiled
    JAR. Once you do that and bundle it into your JAR file, when it is dropped into
    the module path in a Java 9 application, the platform picks that name up as the
    automatic module name. It essentially overrides the automatic naming of modules
    from the JAR file name.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9平台为库作者提供了一个选项，在将库迁移到Java 9之前，为他们的库*预留*一个模块名称。因此，作为库作者，您可以在JAR文件中的`META-INF/MANIFEST.MF`文件中指定您希望Java
    9模块名称是什么。您可以在Java 8编译的JAR文件中这样做。一旦这样做并将它捆绑到JAR文件中，当它被放入Java 9应用程序的模块路径中时，平台就会将其名称作为自动模块名称拾取。它实际上覆盖了从JAR文件名中自动命名的模块名称。
- en: 'Here''s how you specify your preferred automatic module name in your JAR file.
    Create a file called `MANIFEST.MF` file in the `META_INF` folder in the root of
    the JAR file. Add the following line to specify the preferred automatic module
    name:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您如何在JAR文件中指定首选的自动模块名称的方法。在JAR文件的根目录下的`META_INF`文件夹中创建一个名为`MANIFEST.MF`的文件。添加以下行以指定首选的自动模块名称：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once you've done this, the JAR is given this name instead of the name from the
    JAR file name when the platform converts it into an automatic module. And all
    the consumers have to refer to your JAR in the module path by using this preferred
    module name. Thus, when you do get to migrating your module to Java 9, you can
    use the preferred name in the module descriptor and the consumers of your library
    won't need to change their module descriptors.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，JAR文件将使用此名称，而不是平台将其转换为自动模块时从JAR文件名中获取的名称。并且所有消费者都必须通过使用此首选模块名称来在模块路径中引用您的JAR文件。因此，当您开始将模块迁移到Java
    9时，您可以在模块描述符中使用首选名称，而您的库的消费者不需要更改他们的模块描述符。
- en: Using jdeps to create module descriptors
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jdeps创建模块描述符
- en: Once you start breaking down your library JARs into modules, depending on the
    size of your library, you may have a lot of work to do. It's not straightforward
    to identify which modules you'll need to `require` and which you'll need to `export`.
    The `jdeps` tool has another trick up its sleeve. It can look at your JAR files
    and automatically come up with module descriptors for you to use.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始将库JAR文件分解成模块，根据您库的大小，您可能有很多工作要做。确定您需要`require`哪些模块以及需要`export`哪些模块并不简单。`jdeps`工具还有另一个技巧。它可以查看您的JAR文件，并自动为您生成可使用的模块描述符。
- en: 'The syntax is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s try this for the commons-collections JAR file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以commons-collections JAR文件为例：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output should look like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, `jdeps` has generated a module root folder with the same automatic
    naming algorithm we''ve seen before. Inside that folder, it has created a `module-info.java`
    file that it has populated with the `requires` and `exports` declarations that
    it identified by scanning the classes in the JARs:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`jdeps`已生成一个具有与我们之前看到的相同自动命名算法的模块根文件夹。在该文件夹内，它创建了一个`module-info.java`文件，并用通过扫描JAR文件中的类所识别的`requires`和`exports`声明填充了该文件：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can run this command and point to multiple JARs, and it'll do this for every
    single JAR, which also benefits from any relationships between the JARs. The generated
    `module-info.java` files for those related modules will include the relationship
    too!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行此命令并指向多个JAR文件，它将为每个JAR文件执行此操作，这也有利于JAR文件之间的任何关系。为这些相关模块生成的`module-info.java`文件也将包括这些关系！
- en: Remember to use this feature just as a starting point to define your module
    definitions. The platform cannot obviously guess the perfect module definition
    for your library just by looking at the code. It's your job as the author of the
    library to come up with what it requires and what it encapsulates or exports.
    There is also a technical limitation here. The `jdeps` does static code analysis,
    so it will not be able to catch any runtime reflective access that libraries may
    perform. If your library is using reflection, you'll need to manually add the `exports` or `opens` declarations
    to the right modules yourself.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，将此功能仅作为定义你的模块定义的起点。显然，平台不能仅通过查看代码就猜测出你的库的完美模块定义。作为库的作者，你的任务是确定它需要什么，它封装或导出什么。这里也存在一个技术限制。`jdeps`
    进行静态代码分析，因此它将无法捕获库可能执行的任何运行时反射访问。如果你的库使用了反射，你需要手动将 `exports` 或 `opens` 声明添加到正确的模块中。
- en: Building libraries for multiple Java versions
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多个 Java 版本构建库
- en: 'When migrating applications, we had to deal with the scenario that the dependent
    libraries might not all be migrated to Java 9\. When dealing with libraries, you''ll
    need to tackle the opposite problem. The applications consuming your library may
    not all be Java 9\. You''ll have to support Java 8 (or perhaps even older versions
    of Java in some cases). How do you, as a library author, create library distributions
    for all those versions? Before Java 9, you used to have two options:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移应用程序时，我们必须处理这样一个场景：依赖库可能并非全部都迁移到 Java 9。在处理库时，你将需要解决相反的问题。使用你的库的应用程序可能并非全部都是
    Java 9。你将不得不支持 Java 8（或者在某些情况下甚至更旧的 Java 版本）。作为库的作者，你该如何为所有这些版本创建库分发？在 Java 9
    之前，你通常有两个选择：
- en: You could create separate JARs for each Java version
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为每个 Java 版本创建单独的 JAR
- en: In your library code, you could use reflection to do a *feature check*. For
    example, you could reflectively access a platform API that was introduced in Java
    8\. If it works, you are in Java 8\. If not, drop down to Java 7, and so on.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的库代码中，你可以使用反射来进行 *特性检查*。例如，你可以反射地访问在 Java 8 中引入的平台 API。如果它工作正常，你就在 Java 8
    中。如果不工作，就降级到 Java 7，依此类推。
- en: Both these options are tedious. There is a new alternative with Java 9, with
    a feature called *multi-release JARs*. The concept is simple. You create a special
    JAR file called a *multi-release JAR* that contains classes for all versions of
    Java you are targeting.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项都很繁琐。Java 9 提供了一个新的替代方案，其特性称为 *多版本 JAR*。这个概念很简单。你创建一个特殊的 JAR 文件，称为 *多版本
    JAR*，其中包含你针对的所有 Java 版本的类。
- en: 'Here''s how it works. Multi-release JARs have a special structure that holds
    the classes within it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这样工作的。多版本 JAR 有一个特殊的结构，其中包含其内部的类：
- en: '![](img/00103.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.jpeg)'
- en: 'Here''s what you''ll find in a multi-release JAR file, corresponding to the
    numbering in the diagram:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在多版本 JAR 文件中，你可以找到以下对应于图中编号的内容：
- en: 'There''s a root `META-INF` folder with a `MANIFEST.MF` file that contains the
    following line:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个根 `META-INF` 文件夹，其中包含一个 `MANIFEST.MF` 文件，该文件包含以下行：
- en: '`Multi-Release: true`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Multi-Release: true`'
- en: This tells the platform that this is a multi-release JAR and thus needs to be
    treated differently
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉平台这是一个多版本 JAR，因此需要以不同的方式处理
- en: The JAR root also contains a default version of the compiled classes, just like
    any other JAR. Remember, this JAR targets multiple Java versions and it could
    hold multiple target versions of the same class. The classes at the root folder
    are the *default* base versions that could potentially apply to multiple Java
    versions
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JAR 根目录也包含编译后的类的默认版本，就像任何其他 JAR 一样。记住，这个 JAR 针对多个 Java 版本，并且可能包含同一类的多个目标版本。根目录中的类是
    *默认* 的基础版本，可能适用于多个 Java 版本
- en: There's a folder called `versions` inside `META-INF.` To target multiple runtimes,
    the JAR packages classes into sub-folders here. There's one folder for each Java
    version you want to target. Each such folder contains classes that have been specifically
    compiled for that release version. So, if the JAR is used in that version of the
    Java platform, the classes in the version folder override the classes in the `multirelease` folder
    and are picked up instead. If the JAR is used in a platform version that does
    not have classes in the `META-INF` folder, or the class needed doesn't exist in
    the version folder, the runtime falls back to the contents of the `multirelease` folder.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `META-INF` 中有一个名为 `versions` 的文件夹。为了针对多个运行时，JAR 将类打包到这里的子文件夹中。每个要针对的 Java
    版本都有一个文件夹。这样的每个文件夹都包含专门为该发布版本编译的类。因此，如果 JAR 在该版本的 Java 平台上使用，版本文件夹中的类将覆盖 `multirelease`
    文件夹中的类，并取而代之。如果 JAR 在没有 `META-INF` 文件夹的平台版本上使用，或者所需的类不存在于版本文件夹中，则运行时会回退到 `multirelease`
    文件夹的内容。
- en: Notice that the default versions of the classes are in the root location in
    the JAR file. This is why you can use the JAR file with older versions of Java
    too. To older Java versions, a multi-release JAR file looks just like an ordinary
    JAR file--the root location is all the platform looks at, and the versions folder
    is ignored!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类的默认版本位于 JAR 文件的根位置。这就是为什么您也可以使用旧版本的 Java 来使用这个 JAR 文件。对于旧版本的 Java，多版本 JAR
    文件看起来就像一个普通的 JAR 文件——平台只查看根位置，而版本文件夹被忽略！
- en: Let's try creating a simple multi-release JAR. The `11-migrating-application/04-multirelease-jars`
    folder contains an extremely simple library. It's called `mylib` and it has a
    class with a method that prints the contents of a list passed to it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个简单的多版本 JAR。`11-migrating-application/04-multirelease-jars` 文件夹中包含一个非常简单的库。它被称为
    `mylib`，并且有一个方法可以打印传递给它的列表内容。
- en: 'We''d like to create a multi-release JAR for this library targeting two different
    versions of Java:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望为这个库创建一个针对两个不同 Java 版本的多版本 JAR：
- en: 'The base version of the library targets all pre-Java 9 versions. It contains
    code that performs a `for` loop and prints the contents of the list as follows:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库的基本版本针对所有 Java 9 之前的版本。它包含执行 `for` 循环并按如下方式打印列表内容的代码：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Java 9 specific version of this library has two changes--it declares itself
    as a Java 9 module with `module-info.java` and it uses `forEach` and a function
    reference to print the contents of the list, as follows:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个库针对 Java 9 的特定版本有两个更改——它通过 `module-info.java` 声明自己为 Java 9 模块，并使用 `forEach`
    和函数引用来打印列表内容，如下所示：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The two versions of the library are in two separate folders. Since there will
    be two separate versions of the same class, it helps to separate them this way.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 库的两个版本分别位于两个不同的文件夹中。由于将有两个相同类的不同版本，因此这样分离它们是有帮助的。
- en: 'Here''s the structure of the code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的结构：
- en: '![](img/00104.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00104.jpeg)'
- en: 'The first step to making a multi-release JAR is to add the `MANIFEST.MF` file
    that declares it. Add this file at the root of the project with a single line,
    shown next. Make sure you match the statement exactly without any extra spaces:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 制作多版本 JAR 的第一步是添加声明它的 `MANIFEST.MF` 文件。将此文件添加到项目的根目录，如下所示，确保您完全匹配该语句，不要有任何额外的空格：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we''ll create the folders that hold the compiled classes. We''ll create
    a folder called `out` and have two subfolders--`base` for the base classes and
    `9` for the Java 9 version, as shown here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建包含编译类的文件夹。我们将创建一个名为 `out` 的文件夹，并有两个子文件夹——`base` 用于基本类，`9` 用于 Java 9
    版本，如下所示：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will compile the classes into these two folders by setting the right
    release versions. The `--release` parameter to the `javac` command lets you target
    specific Java versions for your compiled classes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过设置正确的发布版本来将这些类编译到这两个文件夹中。`javac` 命令的 `--release` 参数允许您为目标编译的类指定特定的
    Java 版本：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding command compiles the `PrintList.java` class with target release
    7, and places the complied output in the `out/base` directory.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令使用目标发布版本 7 编译了 `PrintList.java` 类，并将编译输出放置在 `out/base` 目录中。
- en: Note that you don't need to have multiple versions of Java installed on your
    machine to achieve this. Java 9 has the ability to generate classes targeting
    different versions of Java by itself! This is analogous to the `-target` flag
    in Java that has been available in earlier versions of the Java platform.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您不需要在机器上安装多个版本的 Java 来实现这一点。Java 9 有能力自行生成针对不同 Java 版本的类！这类似于 Java 平台早期版本中可用的
    `-target` 标志。
- en: 'Next, we''ll compile the Java 9 version as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按照以下方式编译 Java 9 版本：
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are two Java files this time--`PrintList.java` and `module-info.java`.
    The complied classes go to the `out/9` directory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这次有两个 Java 文件--`PrintList.java` 和 `module-info.java`。编译后的类将放入 `out/9` 目录。
- en: 'Now that we have the compiled classes, it''s time to create a multi-release
    JAR. Let''s first create a JAR file with the base version classes. We also supply
    the `MANIFEST.MF` file to be included in the JAR:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了编译后的类，是时候创建一个多版本 JAR 了。让我们首先创建一个包含基础版本类的 JAR 文件。我们还提供了要包含在 JAR 中的 `MANIFEST.MF`
    文件：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `-c` option tells the `jar` tool to create a new JAR, and `f` option is
    used to specify the JAR file name (here, `mylib.jar`). The `-C` option changes
    the directory the tool is looking for to `out.base` and lets it compile classes
    there (as specified by "`.`").
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c` 选项告诉 `jar` 工具创建一个新的 JAR，`f` 选项用于指定 JAR 文件名（这里为 `mylib.jar`）。`-C` 选项更改工具正在查找的目录为
    `out.base`，并允许它在那里编译类（如 "`.`" 所指定）。'
- en: 'This creates the JAR file and adds the base classes to it. Next, let''s add
    the Java 9 classes:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建 JAR 文件并将基础类添加到其中。接下来，让我们添加 Java 9 类：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `-u` options tells the `jar` tool to update the JAR rather than create one.
    We are targeting release 9 this time, and including compiled classes in the `out/9`
    directory.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u` 选项告诉 `jar` 工具更新 JAR 而不是创建一个新的。这次我们针对的是版本 9，并将编译后的类包含在 `out/9` 目录中。'
- en: You don't have to add all the classes in your JAR file for every version. Try
    to keep version-specific classes to a minimum. If there are common classes in
    the base version that the version-specific copy can reuse, you just don't include
    it here. The platform will fall back to the base folder for classes it doesn't
    find for that specific version.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要为每个版本添加 JAR 文件中的所有类。尽量将特定版本的类保持到最小。如果基础版本中有可被特定版本复用的通用类，您就无需在此包含它。平台将回退到基础文件夹以查找该特定版本的类。
- en: 'Here are the contents of the JAR file that''s generated. This is the structure
    we have already seen:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是生成的 JAR 文件的内容。这是我们之前已经看到的结构：
- en: '![](img/00105.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00105.jpeg)'
- en: Remember that the multi-release JAR feature was introduced in Java 9\. So, you
    cannot really create version-specific alternatives in your JAR for Java 8 or earlier.
    Those versions of the platform will not know to read from the `META-INF/versions` folder.
    They'd just use the compiled classes in the JAR root folder. This is, however,
    a good feature to use if you need to create new Java-9-only classes. Since those
    classes will end up in the `META-INF/versions` folder, older platforms will ignore
    them. Once future versions of Java are released, this feature can be used for
    those versions too. So, you can have a `META-INF/versions/10` folder targeting
    the Java 10 platform, for example.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，多版本 JAR 功能是在 Java 9 中引入的。因此，您无法在 JAR 中为 Java 8 或更早的版本创建特定版本的替代品。这些平台将不知道从
    `META-INF/versions` 文件夹中读取。它们只会使用 JAR 根目录中的编译类。然而，如果您需要创建仅适用于 Java 9 的类，这是一个很好的功能。由于这些类最终会出现在
    `META-INF/versions` 文件夹中，较旧的平台将忽略它们。一旦发布了 Java 的未来版本，这个功能也可以用于那些版本。例如，您可以有一个针对
    Java 10 平台的 `META-INF/versions/10` 文件夹。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to migrate a pre-Java 9 application to use
    the Java 9 modularity features. You learned how to plan the overall migration
    strategy, and what the ideal end goal of such a migration is. You also learned
    about a new feature in the platform that lets you handle dependencies and libraries
    that are not modular--automatic modules. We looked at how automatic modules are
    named, how they behave, and how we can use them in our migration process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将 Java 9 之前的应用程序迁移到使用 Java 9 的模块化功能。您学习了如何规划整体迁移策略，以及这种迁移的理想最终目标是什么。您还了解了一个新功能，该功能允许您处理非模块化的依赖项和库--自动模块。我们探讨了自动模块的命名方式、它们的行为方式以及我们如何在迁移过程中使用它们。
- en: You then learned how to approach migrating libraries. We looked at some factors
    to consider when migrating the library code, as well as the multi-release JAR
    feature that lets us create single JARs that target multiple Java platform versions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了如何处理库迁移。我们讨论了在迁移库代码时需要考虑的一些因素，以及多版本JAR功能，它允许我们创建针对多个Java平台版本的单一JAR文件。
- en: In the next and final chapter, we'll wrap things up by looking at two important
    aspects that Java developers commonly deal with--build tooling and unit testing.
    We will understand how they work in the context of a modular Java application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将通过探讨Java开发者经常处理的两个重要方面来总结全文——构建工具和单元测试。我们将了解它们在模块化Java应用程序中的工作原理。
