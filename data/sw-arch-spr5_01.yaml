- en: Software Architecture Today
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 今天的软件架构
- en: In this chapter, we will review what software architecture is and why it's still
    relevant today. We will also discuss the new business demands that have been guiding
    the world of software development in the last few years, and how they have affected
    the software industry as a whole.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾软件架构是什么，以及为什么它今天仍然很重要。我们还将讨论近年来引导软件开发世界的新业务需求，以及它们如何影响整个软件行业。
- en: Software and technology are evolving daily, introducing new demands that businesses
    must meet in order to remain relevant in a competitive market. Regardless of their
    core business, every competitive company has had to turn to technology. Online
    transactions and clients around the world are just some of the challenges that
    have to be mastered in order to stay ahead.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件和技术每天都在发展，引入了新的需求，企业必须满足这些需求，以保持在竞争激烈的市场中的竞争力。无论其核心业务如何，每个有竞争力的公司都必须转向技术。在线交易和全球客户只是必须掌握的一些挑战，以保持领先地位。
- en: 'In order to support these new demands, we have been discovering new ways to
    do our work. Drastic changes have been made and adopted, directly affecting our **software
    development life cycle** (**SDLC**). Some examples of these changes are reflected
    in how we work on the following phases:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这些新需求，我们一直在发现新的工作方式。已经进行了重大的变革，并被采纳，直接影响了我们的软件开发生命周期。这些变化的一些例子反映在我们如何在以下阶段工作上：
- en: Gathering requirements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集需求
- en: Organizing teams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织团队
- en: Designing software architectures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计软件架构
- en: Writing code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码
- en: Deploying applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: In this chapter, we will start by revisiting the underlying concepts of software
    architecture, which have been present for a long time and are still relevant today.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重新审视软件架构的基本概念，这些概念已经存在很长时间，而且今天仍然很重要。
- en: 'This chapter will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Defining software architecture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义软件架构
- en: Common mistakes that are made when creating architectures
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建架构时常见的错误
- en: Architecture and architects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构和架构师
- en: Software architecture principles
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件架构原则
- en: Applying high cohesion and low coupling in order to create components
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用高内聚和低耦合来创建组件
- en: SOLID principles
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID原则
- en: Conway's law
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 康威定律
- en: Choosing the right technology for you
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自己选择合适的技术
- en: New technology tendencies
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新技术趋势
- en: Defining software architecture
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义软件架构
- en: No matter whether or not someone holds the software architect role in a team,
    every application has an architecture that somebody needs to take care of. This
    is an important step as it helps us to avoid writing entangled code, which makes
    a software system impossible to evolve in the future.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无论某人是否在团队中担任软件架构师的角色，每个应用程序都有一个需要有人负责的架构。这是一个重要的步骤，因为它帮助我们避免编写纠缠不清的代码，这使得软件系统在未来无法发展。
- en: 'First things first: In order to know why you need to remember software architecture,
    we first need to understand what it is and why it is important.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要明确的是：为了知道为什么需要记住软件架构，我们首先需要了解它是什么，以及为什么它很重要。
- en: In software, the term *architecture* is hard to define. Authors often borrow
    the definition from the construction industry, which is wrong. Software architecture
    is not all about diagrams, such as plans for buildings or houses—it's more than
    that. It's about the shared knowledge that technical and even nontechnical people
    have about the application that the whole team is creating, how the modules are
    connected to shape it, and all the complicated and vital elements surrounding
    it. Good software architectures are heavily focused on business requirements rather
    than on frameworks, programming languages, diagrams, and programming paradigms.
    Of course, we need these because we create applications using them. However, they
    don't have to define the underlying principles that dictate how we conceive the
    software. Instead, this role should be played according to business requirements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，“架构”这个词很难定义。作者们经常从建筑行业借用定义，这是错误的。软件架构不仅仅是关于图表，比如建筑或房屋的计划 - 它不仅仅是这些。它关乎技术甚至非技术人员对整个团队正在创建的应用程序的共享知识，模块如何连接以塑造它，以及围绕它的所有复杂和重要元素。良好的软件架构主要关注业务需求，而不是框架、编程语言、图表和编程范式。当然，我们需要这些，因为我们使用它们来创建应用程序。但是，它们不必定义我们构思软件的基本原则。相反，这个角色应该根据业务需求来发挥作用。
- en: 'The long-term success of an application is mainly based on its architecture,
    which must be created to support a well-defined set of business requirements,
    as mentioned earlier. Since an application needs to resolve these specific requirements,
    they must guide the architecture of the application. However, there are two main
    scenarios in which we guide software architecture decisions based on technology
    instead of business requirements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的长期成功主要取决于其架构，这必须是为了支持一组明确定义的业务需求而创建的，正如前面提到的。由于应用程序需要解决这些特定需求，它们必须引导应用程序的架构。然而，有两种主要情况下，我们基于技术而不是业务需求来指导软件架构决策：
- en: I know my land
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我知道我的领域
- en: I want to stay ahead
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我想保持领先
- en: I know my land
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我知道我的领域
- en: This scenario occurs when we create software architectures using frameworks
    and programming languages that we already know about, without paying close attention
    to business needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用已知的框架和编程语言创建软件架构时，而不是密切关注业务需求时，就会出现这种情况。
- en: Let's say that the ABC company needs an application for manipulating text from
    large log files. If someone were to ask to work on this requirement, then they
    will choose a programming language that they are comfortable with during the development
    process, instead of looking for the best approach elsewhere.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设ABC公司需要一个用于处理大型日志文件中文本的应用程序。如果有人要求处理这个需求，那么他们在开发过程中会选择一种他们熟悉的编程语言，而不是在其他地方寻找最佳方法。
- en: Imagine that the person in charge of creating this application has already mastered
    JavaScript. In this case, do you think it's a good idea to write code using Node
    JS or another JavaScript framework running on the server in order to write an
    application to manipulate log files? I'm not saying that this is impossible—you
    can do it. However, do you think an application created using this approach will
    be able to perform and scale better than a system written in Perl, Python, or
    C, for example? This is not to say that JavaScript is terrible—it is simply important
    to know that this approach is not a good fit for JavaScript.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下负责创建此应用程序的人已经精通JavaScript。在这种情况下，您认为使用Node JS或另一个在服务器上运行的JavaScript框架编写代码来编写操作日志文件的应用程序是个好主意吗？我并不是说这是不可能的
    - 您可以做到。但是，您认为使用这种方法创建的应用程序能够比使用Perl、Python或C等语言编写的系统表现和扩展得更好吗？这并不是说JavaScript很糟糕
    - 只是重要的是要知道这种方法不适合JavaScript。
- en: I want to stay ahead
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我想保持领先
- en: We all want to stay ahead with technology, using the latest trends in the programming
    world to have a better technological background and consequently land cool jobs.
    Some people tend to write applications, keeping this idea in mind. Let's explain
    this scenario using the application example for manipulating log files that we
    mentioned in the previous section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都希望保持技术领先，利用编程世界中的最新趋势来拥有更好的技术背景，从而获得很酷的工作。有些人倾向于在编写应用程序时牢记这一点。让我们使用前一节中提到的操作日志文件的应用程序示例来解释这种情况。
- en: Suppose you're asked to solve the problem that we mentioned in the *I know my
    land* section. In this scenario, your only concern is technology. For instance,
    let's say you want to try the newest features in the latest PHP release. In this
    case, you will build this application using PHP. While this programming language
    has been improving over the last few years since Facebook started to add new features
    to it, the idea behind writing an application to manipulate large log files using
    PHP is crazy. As you may know, this programming language is intended to create
    other kinds of applications—mainly those that have to be accessed using a web
    browser and without high transactional requirements.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您被要求解决我们在“我了解我的土地”部分提到的问题。在这种情况下，您唯一关心的是技术。例如，假设您想尝试最新的PHP版本中的最新功能。在这种情况下，您将使用PHP构建此应用程序。尽管自从Facebook开始向其添加新功能以来，这种编程语言在过去几年中一直在改进，但使用PHP编写应用程序来操作大型日志文件的想法是疯狂的。正如您可能知道的那样，这种编程语言旨在创建其他类型的应用程序，主要是那些必须使用Web浏览器访问且没有高事务要求的应用程序。
- en: Again, you can write an application using PHP to manipulate large log files,
    but what will happen when more features are needed? Do you think a software architecture
    created with this approach in mind will be able to respond quickly to new requirements
    and the inherent characteristics of the application used in this example?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您可以使用PHP编写应用程序来操作大型日志文件，但是当需要更多功能时会发生什么？您认为以这种方式创建的软件架构能够快速响应新需求和本示例中使用的应用程序的固有特性吗？
- en: Predicting the future
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预测未来
- en: While we can't predict each detail of an application when we are creating it,
    we can keep some apparent assumptions in mind to avoid glaring mistakes, like
    the ones exposed in the preceding sections. Even if you have created an application
    using the wrong approach, one part of the software architecture process is to
    evaluate the code base from time to time and take corrective actions based on
    this. This is important because the existing software architecture needs to evolve
    in order to avoid becoming useless. During the development process—and because we
    do not want to miss the established project deadlines—we often use the `FIXME`
    and `TODO` tags. However, we should pay close attention to these and take action
    as soon as we can, as they represent a technical debt that gets worse as time
    passes. Imagine how easy it is to get rid of a recently introduced debt in the
    next iteration. Now, imagine how hard it would be if the developer who added that
    debt is no longer working on the project or even within the same company.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在创建应用程序时无法预测每个细节，但我们可以牢记一些明显的假设，以避免明显的错误，就像在前面的部分中暴露的那些错误一样。即使您使用了错误的方法创建了一个应用程序，软件架构过程的一部分是定期评估代码库并根据此采取纠正措施。这很重要，因为现有的软件架构需要不断发展以避免变得无用。在开发过程中，因为我们不想错过已建立的项目截止日期，我们经常使用`FIXME`和`TODO`标签。但是，我们应该密切关注这些并尽快采取行动，因为它们代表随着时间推移而恶化的技术债务。想象一下在下一个迭代中摆脱最近引入的债务有多容易。现在，想象一下，如果添加了该债务的开发人员不再在项目上工作，甚至不在同一家公司内，那将会有多困难。
- en: Remember that these tags represent a debt, and debts are paid with interest
    that increases with time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些标签代表一种债务，债务会随着时间的推移而增加利息。
- en: The process of improving the existing software architecture sometimes tends
    to be even more interesting than creating a new one from scratch. This is because
    you now have more information about the business requirements and how the application
    was performing at the time that it was in production.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 改进现有软件架构的过程有时倾向于比从头开始创建一个新的更有趣。这是因为您现在对业务需求以及应用程序在生产中的表现有更多信息。
- en: When you are adding new features to an existing application, you will figure
    out how good the initial idea was. If the process of adding new features is simple
    and requires only a few changes in its structure, then we can conclude that the
    software architecture is doing its job well. Otherwise, if we need to make substantial
    changes to the underlying parts of the original design, we can say that the initial
    idea and assumptions were all wrong. However, at this point, the team in charge
    of the product should be responsible enough to make it evolve instead of writing
    additional patches to support new features.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向现有应用程序添加新功能时，您将会发现最初的想法有多好。如果添加新功能的过程简单，并且只需要对其结构进行少量更改，那么我们可以得出结论，软件架构正在很好地发挥作用。否则，如果我们需要对原始设计的基本部分进行重大更改，我们可以说最初的想法和假设都是错误的。然而，在这一点上，负责产品的团队应该有足够的责任心，使其不断发展，而不是编写额外的补丁来支持新功能。
- en: Even though patching something sounds similar to making it evolve, it isn't.
    This idea is explained clearly in the book *Building Evolutionary Architectures*,
    written by Neal Ford, Rebecca Parsons, and Patrick Kua.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管修补某些东西听起来与使其发展类似，但实际上并不是。这个想法在《构建进化架构》一书中得到了清楚的解释，该书由Neal Ford、Rebecca Parsons和Patrick
    Kua撰写。
- en: 'Proactive teams continually apply changes that make it possible to better support
    preexisting and new features rather than simply sitting and waiting for chaos
    when things get out of control. There''s nothing wrong with changing an initial
    design, and it''s always worth doing this. The following diagram illustrates this
    process, as applied to a geometric shape:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 积极的团队不断应用变化，使其能够更好地支持现有和新功能，而不是坐等混乱失控。更改最初的设计没有错，总是值得的。以下图表说明了这个过程，应用于几何形状：
- en: '![](img/cfa0a822-303f-4f7a-8e69-8e04df15f77f.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfa0a822-303f-4f7a-8e69-8e04df15f77f.jpg)'
- en: Evolving original designs
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 演变的原始设计
- en: Now that we know that business needs must guide the application architecture,
    we can conclude that if it is unable to support new features, then new business
    opportunities will be missed, making the application and its architecture useless.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道业务需求必须引导应用程序架构，我们可以得出结论，如果它无法支持新功能，那么新的商机将被错过，使应用程序及其架构变得无用。
- en: Architecture and architects
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构和架构师
- en: Before the agile and DevOps approaches appeared, architects used to focus on
    creating standards and rules to write code. In the past, it was common to find architects
    who wrote code, but this approach is currently outdated with regards to programming.
    Over the last few years, the idea of architects has been disappearing, all thanks
    to the new emerging models for creating teams. Agile movements have been in the
    software industry for a while, helping us to rethink how we are building software
    and organizing teams.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷和DevOps方法出现之前，架构师通常专注于创建编写代码的标准和规则。过去，常常会发现编写代码的架构师，但这种方法在编程方面目前已经过时。在过去的几年里，架构师的概念已经消失，这要归功于创建团队的新兴模式。敏捷运动在软件行业已经存在一段时间，帮助我们重新思考我们如何构建软件和组织团队。
- en: 'Nowadays, it''s almost impossible to find software teams that have an architect
    working with them. Moreover, the idea of having different groups of people as
    part of an organization that collaborates using a silo style (where one task has
    to be finished before starting a new one) is disappearing. A few years ago, we
    had well-defined roles and even specialized departments for the following roles:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，几乎不可能找到有架构师与之合作的软件团队。此外，使用独立样式（一个任务必须在开始新任务之前完成）的组织中，将不同的人员组成不同的团队的想法正在消失。几年前，我们有明确定义的角色，甚至为以下角色设立了专门的部门：
- en: Business analysts
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务分析师
- en: Developers
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员
- en: QA engineers
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QA工程师
- en: Architects
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构师
- en: DBAs
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库管理员
- en: People working on infrastructure
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基础设施上工作的人员
- en: Operations
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运营
- en: Security
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: 'The following graphic shows how teams work using a silos style:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了团队使用独立样式的工作方式：
- en: '![](img/10fe3563-d7b9-42f1-ae55-8ceca9c02fb0.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10fe3563-d7b9-42f1-ae55-8ceca9c02fb0.jpg)'
- en: Teams working as silos
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为独立团队工作的团队
- en: The preceding list also grows in specific cases. Teams working using a silo
    style used to work on producing defined artifacts, such as documentation, UML
    diagrams, and other things that are usually incomplete.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表在特定情况下也在增长。使用独立样式工作的团队过去通常致力于制作定义的工件，如文档、UML图和通常不完整的其他东西。
- en: This approach is changing, and having small and multidisciplinary teams in charge
    of taking care of every single detail of an application is now more common. This
    approach has helped to create proactive teams with strong skills that allow us
    to ensure that software architecture is still happening all the time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法正在改变，现在更常见的是由小型和多学科团队负责照顾应用程序的每一个细节。这种方法有助于创建具有强大技能的积极团队，使我们能够确保软件架构一直在发生。
- en: It's evident that not every team member has the full set of skills required
    to work on every stage, from gathering requirements to deploying the application
    in production, but the communication among all of them allows us to reduce the
    technical gaps and have a better understanding of the bigger picture of the application.
    This is one of the most important aspects of software architecture.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并非每个团队成员都具备从收集需求到将应用程序部署到生产环境的所有阶段所需的技能，但他们之间的沟通使我们能够减少技术差距，并更好地理解应用程序的整体情况。这是软件架构中最重要的方面之一。
- en: This shared knowledge helps the team to continue improving the existing software
    architecture, overcoming the most complex problems. All of the teams in charge
    of writing software can understand the details of the system under development instead
    of delegating this responsibility to only one person or even to a department.
    This approach can lead us to rely on people or teams that would be slightly out
    of the business context of why the application was being created. This is because
    people that worked on the project in the past but no longer participate actively
    due to working on more than one project can't fully understand all of the details
    of every system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种共享的知识帮助团队不断改进现有的软件架构，克服最复杂的问题。负责编写软件的所有团队都可以理解正在开发的系统的细节，而不是将这一责任委托给一个人或一个部门。这种方法可能导致我们依赖于可能与应用程序创建的业务背景略有不同的人或团队。这是因为曾经参与项目但现在由于同时参与多个项目而不再积极参与的人无法完全理解每个系统的所有细节。
- en: Software architecture principles
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构原则
- en: 'Software architecture should improve by following two simple principles that
    are often difficult to achieve:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循两个简单的原则可以改进软件架构，但通常很难实现：
- en: Low coupling
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低耦合
- en: High cohesion
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高内聚
- en: No matter what programming language, paradigm, or tools you are using to architect
    your applications, these two principles should guide you when building your software
    architecture components.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用什么编程语言、范例或工具来设计应用程序，这两个原则都应该在构建软件架构组件时指导你。
- en: In order to build the components that will shape your architecture, it's always
    worth following the guidelines. These are still relevant, even after many years
    of existence, and they should always be considered when components are being created.
    In this section, I'm talking about SOLID principles and Conway's law, which we
    will discuss in more detail later in this chapter. It is now time to look at what
    components are in more detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建塑造你的架构的组件，始终遵循指导方针是值得的。即使在存在多年后，这些指导方针仍然相关，并且在创建组件时应始终考虑它们。在这一部分，我谈论的是SOLID原则和康威定律，我们将在本章后面更详细地讨论它们。现在是时候更详细地了解组件是什么了。
- en: Components
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: A component is a set of functions, data structures, and algorithms that solve
    one problem. This means that all the code and artifacts that are used to build
    the component have a high cohesion with each other; the rule here is that the
    classes or files that create a component should change at the same time and for
    the same reason.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是解决一个问题的一组函数、数据结构和算法。这意味着用于构建组件的所有代码和工件都与彼此具有高内聚性；规则是创建组件的类或文件应该同时且出于同样的原因而进行更改。
- en: Software architecture is built using many components, and you should not be
    worried about having an excessive quantity of these. The more components you write,
    the more freedom there is to assign them to different developers or even to different
    teams. Large software architectures can be created using many smaller components
    that can be developed and deployed independently of each other.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '软件架构是由许多组件构建的，你不应该担心拥有过多的组件。你写的组件越多，就越自由地将它们分配给不同的开发人员甚至不同的团队。可以使用许多较小的组件创建大型软件架构，这些组件可以独立开发和部署。 '
- en: Once we connect these components to each other, they allow us to create the
    desired software architecture.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将这些组件连接在一起，它们就允许我们创建所需的软件架构。
- en: 'As shown in the following diagram, we can see the components as pieces of a
    puzzle that come together to form an application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，我们可以将组件看作是拼图的一部分，它们汇聚在一起形成一个应用程序：
- en: '![](img/eb910a1c-585c-4810-964c-691cb9fe9d8a.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb910a1c-585c-4810-964c-691cb9fe9d8a.jpg)'
- en: Components forming a larger application
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 组件构成了一个更大的应用程序
- en: The connected components define application architectures, and their designs
    describe how each component has been created internally. It's here that pattern
    designs and SOLID principles must be used to create good designs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的组件定义了应用程序的架构，它们的设计描述了每个组件内部是如何创建的。在这里，必须使用模式设计和SOLID原则来创建良好的设计。
- en: Low coupling
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低耦合
- en: 'Low coupling refers to the degree to which components depend on each other
    by their lower structures instead of their interfaces, creating a tight coupling
    among them. Let''s make this easier to understand by using a simple example. Imagine
    that you need to work on the next user''s story:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 低耦合指的是组件之间依赖于它们的低层结构而不是它们的接口的程度，从而在它们之间创建了紧密的耦合。让我们通过一个简单的例子来更容易理解。想象一下，你需要处理下一个用户故事：
- en: '*As a bank customer, I want to receive my bank statement by email or fax in
    order to avoid having to open the bank application.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为银行客户，我希望通过电子邮件或传真收到我的银行对账单，以避免必须打开银行应用程序。*'
- en: 'As you may discover, the developer should work on two things to solve this
    problem:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能会发现的，开发人员应该解决这个问题的两个方面：
- en: Adding the ability to save the user's preferences in the system
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加在系统中保存用户偏好的能力
- en: Making it possible to send the bank statement to the customer by using the requested
    notification channels
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用请求的通知渠道向客户发送银行对账单的可能性
- en: 'The first requirement seems quite straightforward. To test this implementation,
    we would use something fairly simple, such as the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要求似乎非常直接。为了测试这个实现，我们可以使用一些相当简单的东西，比如以下代码：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the second requirement, we will need to read these preferred notification
    channels and send the bank statement using them. The test that will guide this
    implementation will look like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个要求，我们需要读取这些首选通知渠道，并使用它们发送银行对账单。将指导这个实现的测试看起来像下面这样：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is now time to show a tightly coupled code in order to understand this problem.
    Let''s take a look at the following implementation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候展示一个紧密耦合的代码，以便理解这个问题。让我们看一下以下的实现：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note how this code is tightly coupled with the implementation of the `NotificationService`
    class; it even knows the name of the methods that this service has. Now, imagine
    that we need to add a new notification channel. To make this code work, we will
    need to add another `if` statement and invoke the correspondent method from this
    class. Even when the example is referring to tightly coupled classes, this design
    problem often occurs between modules.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码与`NotificationService`类的实现紧密耦合；它甚至知道此服务具有的方法的名称。现在，想象一下，我们需要添加一个新的通知渠道。为了使此代码工作，我们需要添加另一个`if`语句，并从此类调用相应的方法。即使示例是指紧密耦合的类，这种设计问题经常发生在模块之间。
- en: 'We will now refactor this code and show its low-coupled version:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将重构此代码并展示其低耦合版本：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time, the responsibility to get a notification channel is passed to the
    `Factory` class, no matter what kind of channel is needed. The unique detail that
    we need to know from the `channel` class is that it has a `send` method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，获取通知渠道的责任被传递给了`Factory`类，无论需要哪种类型的渠道。我们需要从`channel`类知道的唯一细节是它有一个`send`方法。
- en: 'The following diagram shows how the class that sends notifications was refactored
    to send notifications using different channels and support an interface in front
    of the implementations per notification channel:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了发送通知的类是如何重构的，以使用不同的渠道发送通知，并在通知渠道的实现前支持一个接口：
- en: '![](img/7c2b5fd5-10da-46a2-890e-7e5356d4824d.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c2b5fd5-10da-46a2-890e-7e5356d4824d.jpg)'
- en: Classes after refactoring
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的类
- en: This small but significant change has to lead us to encapsulate the details
    of the mechanism used to send notifications. This exposes only one well-defined
    interface that should be used by the other classes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小但重要的改变导致我们封装了用于发送通知的机制的细节。这只暴露了一个明确定义的接口，应该被其他类使用。
- en: Although we have shown this example using classes, the same principle is applicable
    to components, and the same strategies should be used to implement them and avoid
    coupling among them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经展示了使用类的示例，但同样的原则也适用于组件，并且应该使用相同的策略来实现它们并避免它们之间的耦合。
- en: High cohesion
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高内聚
- en: 'The principle of high cohesion also has a pretty simple definition: one component
    should perform one and only one well-defined job. Although the description is
    pretty simple, we often tend to get confused and violate this principle.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 高内聚原则也有一个非常简单的定义：一个组件应该执行一个且仅执行一个明确定义的工作。尽管描述非常简单，但我们经常会感到困惑并违反这个原则。
- en: In the previous example, we had `NotificationService`, which was in charge of
    sending notifications by email and fax. The word  `and` can be helpful for us
    when it comes to identifying the violation of this principle. Now that we have
    two different classes (one per notification channel), it's fair to say that our
    classes only have one responsibility.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有`NotificationService`，负责通过电子邮件和传真发送通知。当我们识别到这个原则的违反时，`and`这个词对我们可能会有所帮助。现在我们有两个不同的类（每个通知渠道一个），可以说我们的类只有一个责任。
- en: Again, the same is true for components, and another reason to keep the same
    idea with them is that you will likely have each component accomplishing only
    one specific requirement. For example, what would happen if all our customers
    just wanted to receive their bank statements by email; do you think it's okay
    to depend on a class that has the ability to send faxes too?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于组件也是如此，另一个保持相同想法的原因是，您可能会有每个组件只完成一个特定的要求。例如，如果我们所有的客户都只想通过电子邮件收到他们的银行对账单，您认为依赖于具有发送传真能力的类是否可以接受？
- en: Although the previous question may seem unimportant, imagine that you solved
    an existing issue related to sending notifications using faxes as a notification
    mechanism, and a new issue was then introduced into the mechanism in order to
    send email notifications by mistake.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的问题可能看起来不重要，但想象一下，您解决了使用传真作为通知机制发送通知的现有问题，并且随后错误地引入了一个新问题，以便通过电子邮件发送通知。
- en: Remember that components shape your software architecture, and architects should
    design them in a way that maximizes team productivity. Aligning your components
    to the high-cohesion principle is an excellent way to separate them and allows
    teams to work independently on different parts of your application. This ability
    to create various components with clear responsibilities will make it easier when
    solving other issues and adding new features, and will also make you less prone
    to introducing bugs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，组件塑造了您的软件架构，架构师应该以最大化团队生产力的方式设计它们。将您的组件与高内聚原则对齐是一个很好的方法，可以将它们分开，并允许团队独立地在应用程序的不同部分上工作。创建具有明确责任的各种组件的能力将使在解决其他问题和添加新功能时更容易，并且也会使您更不容易引入错误。
- en: With regards to the previous example, you are probably wondering why the `NotificationChannel` class
    is apparently sending notifications with a `BankStatement` parameter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的例子，您可能想知道为什么`NotificationChannel`类显然要使用`BankStatement`参数发送通知。
- en: 'Common sense leads us to believe that we need to replace this class with any
    other generic type. It can be helpful to allow the application to send different
    kinds of notifications, and not only bank statements: this may include drawbacks,
    or when a new deposit is received in the account. Even though the idea of supporting
    incoming requirements looks like something you might want to include in the program
    at this stage, the application doesn''t currently need this ability. This is why
    it is not necessary for us to add this feature right now. Instead, this design
    should evolve when this becomes necessary; in this way, we are sticking to the
    KISS principle ([https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle](https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle))
    and following the directions of only building the most basic features to make
    the application work.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 常识告诉我们，我们需要用任何其他通用类型替换这个类。允许应用程序发送不同类型的通知可能会有所帮助，而不仅仅是银行对账单：这可能包括缺点，或者当账户收到新存款时。即使支持新需求的想法看起来像是你可能想在这个阶段包含在程序中的东西，但应用程序目前并不需要这种能力。这就是为什么我们现在不需要添加这个功能。相反，当这变得必要时，这个设计应该发展；这样，我们遵循了KISS原则（https://www.techopedia.com/definition/20262/keep-it-simple-stupid-principle-kiss-principle）并且只构建最基本的功能来使应用程序工作。
- en: SOLID principles
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: SOLID is an acronym that represents the five underlying principles that guide
    a good software design. The design is related to the creation of components that
    shape your software architecture.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是一个缩略词，代表着指导良好软件设计的五个基本原则。这个设计与塑造软件架构的组件的创建有关。
- en: In 2004, Michael Feathers suggested this acronym to Robert C. Martin, the author
    of these principles. The process for creating them took him around 20 years, and
    during this period, many of them were added, removed, and merged to achieve a
    robust set of principles named SOLID. Let's review each one of the principles
    and provide a brief and clear explanation that will be helpful for getting a precise
    idea of how we can use them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 2004年，Michael Feathers向这些原则的作者Robert C. Martin建议了这个缩略词。创建它们的过程花了他大约20年的时间，在这期间，许多原则被添加、删除和合并，以实现一个强大的名为SOLID的原则集。让我们审查每一个原则，并提供一个简明清晰的解释，这将有助于准确理解我们如何使用它们。
- en: We will use the term *module* in tandem with the idea of modules shaping components,
    and we will make reference to the **object-oriented programming** (**OOP**) world
    using terms such as *classes* and *interfaces* in order to provide a more precise
    explanation of modules.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用术语“模块”来配合模块塑造组件的想法，并且我们将引用面向对象编程（OOP）世界的术语，比如类和接口，以便更精确地解释模块。
- en: The single responsibility principle (SRP)
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: The SRP is very closely related to the high cohesion that we reviewed earlier.
    The idea behind this principle is that a module should be changed for one reason only.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: SRP与我们之前审查的高内聚性密切相关。这个原则背后的想法是，一个模块应该只因一个原因而被改变。
- en: 'This definition leads us to conclude that a module should have only one responsibility.
    One way to verify whether this principle is achieved in your design is to answer
    the following questions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义让我们得出结论，一个模块应该只有一个职责。验证你的设计是否实现了这个原则的一种方法是回答以下问题：
- en: Does the module's name represent its exposed functionality?
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的名称是否代表其公开的功能？
- en: The answer should be yes. For example, if the module's name refers to the domain,
    then the module should contain domain classes and some functionality around the
    domain objects related to the module's name itself. You won't want to have code
    to support audit elements or any other aspect out of the scope of the module you
    are working with, for example. If the module is supporting additional features,
    the code supporting those additional features should probably need to be moved
    to an existing audit module, or a new audit module should be created.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 答案应该是肯定的。例如，如果模块的名称指的是领域，那么模块应该包含领域类和围绕模块名称本身的领域对象的一些功能。例如，你不会希望有支持审计元素或任何其他超出你正在处理的模块范围的代码。如果模块支持额外的功能，支持这些额外功能的代码可能需要移动到现有的审计模块，或者需要创建一个新的审计模块。
- en: When a new change is required, how many parts of the module are affected?
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要进行新的更改时，模块的多少部分会受到影响？
- en: The answer to this question should be many of them; all classes in the module
    are highly connected, and a new change will change them for this reason. The desired
    behavior is prevented from being changed through the exposed interface, but the
    background implementation is often volatile.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的答案应该是很多；模块中的所有类都高度相关，一个新的更改会因此改变它们。期望的行为通过公开接口阻止被更改，但后台实现通常是不稳定的。
- en: The Open–Closed Principle (OCP)
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则（OCP）
- en: 'The OCP is simple to write, but difficult to explain. For this reason, I''ll
    write the following definition first and describe it later:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: OCP很容易写，但很难解释。因此，我将首先写下以下定义，然后再描述它：
- en: '*New features can be added to an existing module by extension and not by modification.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以通过扩展而不是修改向现有模块添加新功能。*'
- en: 'It sounds simple, doesn''t it? In order to understand this concept from a practical
    viewpoint, it is necessary to revisit our last example. Let''s check that we are
    accomplishing this principle by answering the following questions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单，不是吗？为了从实际角度理解这个概念，有必要重新审视我们上一个例子。让我们通过回答以下问题来检查我们是否遵循了这个原则：
- en: What do we need in order to support a new notification channel?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持新的通知渠道，我们需要什么？
- en: We need to write a new class (module), and this should implement an existing
    interface. Note how the open-closed principle makes sense with the provided answer.
    To support a new notification channel in our application, we need to create a
    new class, but we don't need to modify the existing code. According to the previous
    refactoring that we made, if we needed to support this requirement, we had to
    adjust the existing service to send notifications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个新的类（模块），这个类应该实现一个现有的接口。注意到开闭原则与提供的答案是如何合理的。为了在我们的应用程序中支持新的通知渠道，我们需要创建一个新的类，但不需要修改现有的代码。根据我们之前进行的重构，如果我们需要支持这个需求，我们必须调整现有的服务来发送通知。
- en: 'A few questions to validate how well this principle is achieved are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 验证这一原则实现程度的一些问题如下：
- en: Do I add a new `IF` statement to my code?
  id: totrans-124
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要在我的代码中添加一个新的`IF`语句吗？
- en: No. If you're looking to add a new feature, you will write a new class instead
    of modifying an existing one. This is because you are adding and not changing
    features.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不。如果你想要添加一个新功能，你会编写一个新的类而不是修改现有的类。这是因为你是在添加而不是改变功能。
- en: How much code do I modify in order to support a new feature?
  id: totrans-126
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持一个新功能，我需要修改多少代码？
- en: Hopefully, just a little bit. In a perfect world, you won't need to modify anything,
    but sometimes a few sections should be changed to support new features in the
    real world. The rule here is that if you are adding a new feature, your original
    design should be able to support this requirement with minimal changes. If this
    is not true, refactoring or changing your initial design is recommended.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 希望只是一点点。在理想的世界里，你不需要修改任何东西，但有时为了支持现实世界中的新功能，可能需要改变一些部分。规则是，如果你要添加一个新功能，你的原始设计应该能够以最小的改动来支持这个需求。如果不是这样，建议重构或更改初始设计。
- en: How big should my source code files be?
  id: totrans-128
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的源代码文件应该有多大？
- en: Big source code files are a bad idea, and there is no reason for them to be
    large. If your source code file has hundreds and hundreds of lines, revisit your
    functions and think about moving code to a new file in order to make the source
    code files smaller and easy to understand.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大型源代码文件是一个坏主意，也没有理由让它们变得庞大。如果你的源代码文件有成百上千行，重新审视你的函数，并考虑将代码移动到一个新文件中，以使源代码文件变得更小且易于理解。
- en: Should I use abstractions within my code?
  id: totrans-130
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该在我的代码中使用抽象吗？
- en: This is a tricky one. If you only have one concrete implementation for something,
    you won't need to have an abstract class or interface. Writing code and inventing
    new possible scenarios is not desirable at all, but if you have at least two concrete
    implementations that are related to each other, you have to think about writing
    an abstraction for them. For example, if we only need to send email notifications,
    there would be no reason to write an interface for this. However, since we are
    sending notifications via two different channels, we certainly need an abstraction
    to deal with them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个棘手的问题。如果对于某个东西你只有一个具体的实现，那么就不需要有一个抽象类或接口。编写代码和想象新的可能场景都是不可取的，但如果你至少有两个相互关联的具体实现，你必须考虑为它们编写一个抽象。例如，如果我们只需要发送电子邮件通知，那就没有理由为此编写一个接口。然而，由于我们通过两种不同的渠道发送通知，我们肯定需要一个抽象来处理它们。
- en: The Liskov substitution principle
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里氏替换原则
- en: 'The **Liskov substitution principle** (**LSP**) has a fancy definition:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**里氏替换原则**（LSP）有一个花哨的定义：'
- en: '*Module A can be replaced by module B as long as B is a subtype of A.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 模块A可以被模块B替换，只要B是A的子类型。
- en: 'Well-defined contracts heavily support this definition and help us reduce the
    coupling between modules. The following questions can help you figure out how
    well this principle is achieved:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 明确定义的契约大大支持这一定义，并帮助我们减少模块之间的耦合。以下问题可以帮助你确定这一原则的实现程度：
- en: Are the modules interacting using abstractions or concrete implementations?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块之间是使用抽象还是具体实现进行互动的？
- en: Here, the answer should be that the modules should not be interacting with either
    option. There is no reason to establish interactions among modules by using their
    concrete implementations instead of their interfaces.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，答案应该是模块不应该与任何选项互动。没有理由使用它们的具体实现而不是它们的接口来建立模块之间的互动。
- en: Should I be casting objects in order to use them?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该强制转换对象以便使用它们吗？
- en: I hope not. If so, it's because the interface is not well-designed, and a new
    one should be created to avoid this behavior. The use of the `instanceOf` function is
    also not desirable at all.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 希望不需要。如果需要，那是因为接口设计不好，应该创建一个新的接口来避免这种行为。也不希望使用`instanceOf`函数。
- en: Is the interaction between modules guided by `IF `statements?
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块之间的互动是否由`IF`语句引导？
- en: There is no reason for this to be the case. Your modules should be connected
    in a way that can be taken care of by the use of an interface and the correct
    dependency injection to solve their concrete implementations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由这样做。你的模块应该以一种可以通过接口和正确的依赖注入来解决它们的具体实现的方式相互连接。
- en: The interface segregation principle (ISP)
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则（ISP）
- en: 'The principal motivation of the interface segregation principle is aligned
    with the lean movement where creating values with fewer resources is essential.
    Here''s a short definition for it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则的主要动机与精益运动一致，即用更少的资源创建价值至关重要。以下是它的简短定义：
- en: '*Avoid things that you don''t use.*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免不使用的东西。*'
- en: 'You may have already seen classes (modules) implementing interfaces with some
    method implementations, such as the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到类（模块）实现了一些方法实现的接口，例如以下内容：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, another option called *comment as* *implementation* tends to
    be used, as shown in the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是*comment as* *implementation*，如下所示：
- en: '[PRE5]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding examples successfully describe the problem that this principle
    was created to address. The best way to deal with this issue is by creating more
    consistent interfaces that conform to the other explained principles. The main
    problem with this issue is not related to having empty method implementations,
    but having additional functionality that is not used at all.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子成功地描述了创建这一原则的问题。解决这个问题的最佳方法是创建更一致的接口，符合其他解释的原则。这个问题的主要问题与有空方法实现无关，而是具有根本没有被使用的额外功能。
- en: Suppose that an application depends on an *XYZ* library and the system is only
    using 10% of the available functionality. If a new change is applied to solve
    an issue that was present in the other 90%, that modified code represents a risk
    to the part that the application is using, even when it's not directly related
    to it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个应用程序依赖于*XYZ*库，系统只使用了可用功能的10%。如果应用了新的更改来解决其他90%存在的问题，那么修改后的代码对应用程序正在使用的部分构成风险，即使它与之没有直接关联。
- en: 'The following questions will help you identify how well you are doing:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您确定您的表现如何：
- en: Do I have empty or silly implementations like the ones mentioned earlier?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否有空的或愚蠢的实现，就像前面提到的那样？
- en: Please don't answer YES.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要回答YES。
- en: Does my interface have a lot of methods?
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的接口有很多方法吗？
- en: Hopefully not, as this will make it more difficult to implement all the abstract
    methods in concrete implementations. If you have many methods, please refer to
    the next question.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 希望不是，因为这将使在具体实现中实现所有抽象方法变得更加困难。如果你有很多方法，请参考下一个问题。
- en: Are all the method names consistent with the interface name?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有方法名称是否与接口名称一致？
- en: The method names should be consistent with the interface name. If one or more
    methods don't make sense at all, then a new interface should be created to place
    them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称应该与接口名称一致。如果一个或多个方法根本没有意义，那么应该创建一个新的接口来放置它们。
- en: Can I split this interface into two instead of only one?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以将这个接口分成两个而不是一个吗？
- en: If yes, go ahead and do it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是的话，继续做。
- en: How many functions am I using from the whole set of exposed functions?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我从所有公开函数中使用了多少个功能？
- en: If the modules interacting with an interface are only using a few of the exposed
    functions, then the other ones should probably be moved to another interface,
    or even to new modules.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与接口交互的模块只使用了少量公开函数，那么其他函数可能应该移动到另一个接口，甚至移动到新模块。
- en: The dependency inversion (DI) principle
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖反转（DI）原则
- en: 'It is now time to define the dependency inversion principle:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候定义依赖反转原则了：
- en: '*Modules should depend on abstractions rather than on concrete implementations.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块应该依赖于抽象而不是具体实现。*'
- en: 'Abstractions represent the high-level details of a module, and the interaction
    among modules should be done at this level. Low-level details are volatile and
    ever-evolving. We previously stated that there are no problems with evolved modules,
    but of course, we don''t want to break module interactions because of low-level
    details, and an excellent way to do this is to use abstractions rather than concrete
    implementations. The following questions will help you identify how well you are
    doing:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象代表模块的高级细节，模块之间的交互应该在这个级别进行。低级细节是不稳定的，不断发展的。我们之前说过，进化的模块没有问题，但当然，我们不希望因为低级细节而破坏模块之间的交互，一个很好的方法是使用抽象而不是具体实现。以下问题将帮助您确定您的表现如何：
- en: Do I have abstractions as part of my modules?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的模块中有抽象吗？
- en: As discussed earlier in this chapter, many concrete implementations should have
    an abstraction in front of them. However, when it comes to one specific implementation, this
    is probably not the case.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面讨论的那样，许多具体实现应该在其前面有一个抽象。然而，当涉及到一个特定的实现时，情况可能并非如此。
- en: Am I creating new instances by myself every time?
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是自己每次都创建新实例吗？
- en: The answer here should be no. Your framework or mechanism that is in charge
    of the dependency injection inside your application is responsible for doing this.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的答案应该是否定的。负责应用程序内部依赖注入的框架或机制负责执行此操作。
- en: Conway's law
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 康威定律
- en: 'Mel Conway published a paper in 1968 that is still relevant today, stating
    the direction that companies should move in. For a long time, we focused on defining
    rules for everything, such as the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Mel Conway在1968年发表了一篇至今仍然相关的论文，阐述了公司应该朝着的方向。长期以来，我们一直致力于为一切定义规则，例如以下内容：
- en: What time you should arrive at the office
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该在什么时间到达办公室
- en: The minimum hours that people should work
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们应该工作的最少小时数
- en: How many days per week are used for working
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周工作几天
- en: What type of clothing is appropriate to wear during working hours
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作时间穿什么类型的服装是合适的
- en: 'These rules apply to any type of company, and, in many cases, they are still
    relevant today. Within the IT world (and particularly the software industry),
    we created another set of rules to guide our teams (feel free to avoid reading
    these rules if you don''t want to get bored):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则适用于任何类型的公司，在许多情况下，它们仍然具有相关性。在IT世界（尤其是软件行业）中，我们创建了另一套规则来指导我们的团队（如果你不想感到无聊，可以随意避免阅读这些规则）：
- en: Business analysts should create use cases with a well-defined structure, allowing
    the developer to ignore the business details and focus on the technical part of
    the process.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务分析师应该创建具有明确定义结构的用例，使开发人员可以忽略业务细节，专注于流程的技术部分。
- en: Developers should follow the standard document created by the software architect
    of the product that was written many years ago.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员应该遵循产品软件架构师多年前编写的标准文档。
- en: The lines of code written per day should indicate how productive a developer
    is.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每天写的代码行数应该表明开发人员的生产力。
- en: When you create a new database object, you have to update the existing trustable
    database dictionary.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你创建一个新的数据库对象时，你必须更新现有的可信数据库字典。
- en: As soon as your code is ready to be pushed, use an email template to ask for
    revision by the QA team. After their approval, repeat this process with the design
    team and later again with the architecture team.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你的代码准备好推送，使用电子邮件模板请求QA团队进行审查。经过他们的批准后，再次与设计团队重复此过程，然后再次与架构团队重复此过程。
- en: Any change to the pushed code will force you to repeat the process that was
    explained in the preceding rule.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对推送的代码进行任何更改都将迫使你重复前面规则中解释的过程。
- en: 'Don''t forget UML diagrams when you finish coding your assigned use case. Not
    all of them are required—only the most important ones, such as those listed here:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完成编码分配的用例后，不要忘记UML图。并非所有图都是必需的，只有最重要的图，比如这里列出的图：
- en: Class diagram
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类图
- en: Object diagram
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象图
- en: Package diagram
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包图
- en: Component diagram
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件图
- en: Sequence diagram
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列图
- en: Deployment diagram
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署图
- en: 'The preceding list of diagrams will be larger in some cases. Fortunately, things
    have changed nowadays, and crazy processes that force us to write huge documents
    and create different diagrams that pay no attention are no longer used. With these
    premises in mind, Mel Conway wrote the following as part of his paper:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，前面列出的图表将更大。幸运的是，现在情况已经改变，不再使用迫使我们编写大量文件并创建不注意的不同图表的疯狂流程。在这些前提下，Mel Conway在他的论文中写道：
- en: '"Any organization that designs a system will inevitably produce a design whose
    structure is a copy of the organization''s communication structure."'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: “任何设计系统的组织最终都会产生一个结构与组织沟通结构相同的设计。”
- en: Conway's thesis is still relevant and has been affecting the way we structure
    our teams to create successful projects and avoid wasting resources ever since.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Conway的论点仍然相关，并且自那时以来一直影响着我们构建团队以创建成功项目并避免浪费资源的方式。
- en: People comprise teams, and the question of how these people should be arranged
    in order to create successful teams has been answered in many ways in the last
    few years. All of these answers have suggested building small and multidisciplinary
    teams that should be small enough to be fed using one pizza and multidisciplinary
    enough to avoid creating silos during the SDLC.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 人们组成团队，如何安排这些人以创建成功的团队的问题在过去几年中已有多种回答。所有这些答案都建议建立小型和多学科团队，这些团队应该足够小，可以用一块披萨来供应，并且多学科足够，以避免在SDLC期间创建孤立。
- en: In this way, companies are promoting a culture of sharing and continuous learning
    within teams. Teams are continually learning from their successes and failures.
    They are interacting with each other directly instead of using intermediaries
    or other protocols of communication.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，公司正在促进团队内的共享文化和持续学习。团队不断从成功和失败中学习。他们直接相互交流，而不是使用中介或其他通信协议。
- en: Business boundaries are defined by teams that allow them to communicate using
    well-defined interfaces, and since the communication is directly managed by themselves,
    rapid feedback will enable them to fix issues and take corrective actions when
    necessary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 团队定义了业务边界，使他们能够使用明确定义的接口进行通信，由于通信是由他们自己直接管理的，快速反馈将使他们能够在必要时解决问题并采取纠正措施。
- en: Choosing the right technology for you
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为自己选择合适的技术
- en: Earlier in this chapter, we defined what software architecture is and what the
    relevant elements surrounding it are. We also mentioned that frameworks, programming
    languages, paradigms, and so on are not the underlying elements that should guide
    your software architecture. Many people defend the idea of deferring as much of
    your technical decisions as possible in order to have your design open to new
    options, and that's worth doing. However, you can't postpone these choices forever.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们定义了软件架构是什么，以及围绕它的相关元素是什么。我们还提到，框架、编程语言、范例等并不是应该指导你的软件架构的基本元素。许多人支持尽可能推迟尽可能多的技术决策的想法，以便使你的设计对新选项开放，这是值得做的。然而，你不能永远推迟这些选择。
- en: 'There are a lot of frameworks available on the market. Many of them are new,
    but old frameworks are also still available. Even at the beginning of the process,
    when all this stuff is just a detail, you need to carefully choose the framework
    that you will use to build your software architecture, since this detail will
    make your life easier (or more difficult) depending on the features that you implement
    in order to solve the business requirements. I''ll show you some considerations
    that you need to bear in mind when you''re deciding which framework to use:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有很多框架可用。其中许多是新的，但旧的框架仍然可用。即使在过程的开始阶段，当所有这些都只是细节时，你也需要仔细选择你将用来构建软件架构的框架，因为这个细节将根据你实现的功能来解决业务需求，使你的生活更轻松（或更困难）。我将向你展示在决定使用哪个框架时需要考虑的一些因素：
- en: How much documentation is available?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少文档可用？
- en: This is an important factor to consider. Here, you must think about how much
    documentation has been written for the vendor, and how many courses are available
    online (not only by the vendor but by other developers, as well). If you can find
    books, articles, and showcases, it's always worth exploring these as they will
    allow you to learn about the tool that you have decided to use.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的考虑因素。在这里，你必须考虑为供应商编写了多少文档，以及在线有多少课程（不仅供应商提供的，还有其他开发人员提供的）。如果你能找到书籍、文章和展示，总是值得探索，因为它们将使你了解你决定使用的工具。
- en: How big is the community around your choice?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你选择的技术周围的社区有多大？
- en: Having a lot of people working on improving a product is something that you
    should appreciate. Your choice should be supported not only by the vendor but
    also by other developers and companies using the product to solve their needs.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多人致力于改进产品是你应该欣赏的。你的选择不仅应得到供应商的支持，还应得到其他开发人员和公司的支持，他们使用产品来解决他们的需求。
- en: Is it difficult to write tests using a defined technology that you have in mind?
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你心目中的定义的技术编写测试是否困难？
- en: No matter what your programming style is, you will always benefit from including
    tests as part of your SDLC. You will also benefit from including tests for another
    aspect of your software (or at least unit tests, integration tests, functional
    tests, and load tests). If your framework makes this task difficult, it is better
    to choose another one. If you are using a framework, ABC, for dependency injection,
    this should be tested, but if these tests are difficult to write, you won't want
    to waste your time with them. With this idea in mind, Spring has excellent support
    for testing, and we'll cover this in subsequent chapters by using a hands-on approach.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的编程风格是什么，将测试包括在你的SDLC中总是有益的。你还将受益于为软件的另一个方面（或至少单元测试、集成测试、功能测试和负载测试）包括测试。如果你的框架使这项任务变得困难，最好选择另一个。如果你正在使用依赖注入框架ABC，这应该被测试，但如果这些测试很难编写，你就不会想浪费时间在这上面。考虑到这一点，Spring对测试有很好的支持，我们将在后续章节中使用实际操作来介绍这一点。
- en: Can I plug components to add more features?
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以插入组件以添加更多功能吗？
- en: You are probably thinking "if I want to add a new component, I can simply include
    a JAR". In some cases, this is true, and in other cases, you'll need to discover
    a whole set of dependencies for making it work. This is a painful procedure because
    sometimes you need specific versions of specific libraries, which is more challenging
    to figure out by ourselves, and this is not something you should spend too much
    time on. Spring includes Spring Boot, which has an excellent method for adding
    dependencies to your project in a straightforward way. You should only indicate
    to Spring that you want to work with JPA (for example) during the application
    creation process, and Spring itself will be able to figure out all the required
    dependencies to make it work by itself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想“如果我想添加一个新组件，我可以简单地包含一个JAR文件”。在某些情况下，这是正确的，而在其他情况下，你需要发现一整套依赖项来使其工作。这是一个痛苦的过程，因为有时你需要特定版本的特定库，这更难以自己解决，这不是你应该花太多时间的事情。Spring包括Spring
    Boot，它有一种很好的方法来以简单的方式向你的项目添加依赖。你只需要在应用程序创建过程中指示Spring你想要使用JPA（例如），Spring本身就能够找出使其工作所需的所有依赖项。
- en: It is common to struggle with Maven a bit when you're looking for the right
    artifact to bootstrap your application for the first time. The good news with
    Spring is that you have Spring Initializer, which is a friendly website for bootstrapping
    your application in a few clicks. You can refer to [https://start.spring.io](https://start.spring.io) for
    more details.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次寻找合适的构件来启动你的应用程序时，可能会在Maven上遇到一些困难。Spring的好消息是，你可以使用Spring Initializer，在几次点击中启动你的应用程序。你可以参考[https://start.spring.io](https://start.spring.io)获取更多详情。
- en: What are companies using the product for?
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司使用这个产品做什么？
- en: Even when the market is crowded with new tools that look promising, you will
    not want to gamble when it comes to choosing technologies and frameworks. Before
    choosing a framework or technology, I encourage you to watch some videos of conferences on
    YouTube. It would be even better if you can go and attend one of them if you have
    the chance. You'll also benefit from reading papers, showcases, and case studies
    about a specific technology, as well as which companies are working with these.
    You can even start creating analogies based on this information in order to figure
    out how well a particular technology will fit for you.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 即使市场上充斥着看起来很有前途的新工具，当选择技术和框架时，你也不会想要赌博。在选择框架或技术之前，我鼓励你观看一些YouTube上的会议视频。如果有机会，最好能去参加其中之一。你还将受益于阅读关于特定技术的论文、展示和案例研究，以及哪些公司正在使用这些技术。你甚至可以根据这些信息开始建立类比，以便弄清楚特定技术对你的适应程度。
- en: However, for many years, I have seen how people have been working with Spring
    to accomplish their business requirements in different industries.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，多年来，我看到人们如何使用Spring来满足不同行业的业务需求。
- en: This framework is mature and is constantly evolving to embrace new programming
    styles and emerging techniques in the software industry. For example, the latest
    release of Spring includes support for the most recent features introduced within
    the Java world and the industry in general, such as reactive programming, the
    latest Java version, and even support for other programming languages that are
    becoming popular, such as Kotlin and Groovy.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架是成熟的，并不断发展，以拥抱软件行业中的新编程风格和新技术。例如，最新版本的Spring包括对Java世界和整个行业引入的最新功能的支持，如响应式编程、最新的Java版本，甚至对其他变得流行的编程语言的支持，如Kotlin和Groovy。
- en: New trends
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新趋势
- en: In the last few years, a lot of programming languages have been emerging to
    solve new business requirements, and many of these run on the JVM, which gives
    a significant advantage to Java developers, making embracing new programming languages less
    difficult.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，许多编程语言已经出现，以解决新的业务需求，其中许多在JVM上运行，这给Java开发人员带来了重大优势，使得接受新的编程语言变得不那么困难。
- en: It's not a coincidence that new emerging software architectures have been created.
    Business has expanded around the world, which makes it more challenging to scale
    old applications. This approach has forced us to rethink how to split business
    boundaries in order to deliver scalable services to solve business needs. Since
    we needed to offer services to clients around the world, the cloud appeared, and
    nowadays we can even select regions to reduce the latency of our applications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 新兴的软件架构的出现并非偶然。业务已经扩展到全球，这使得扩展旧应用程序变得更具挑战性。这种方法迫使我们重新思考如何划分业务边界，以便提供可扩展的服务来解决业务需求。由于我们需要向全球客户提供服务，云出现了，如今我们甚至可以选择区域来减少应用程序的延迟。
- en: With the cloud ready to be used, the X appeared as a service paradigm. We now
    have services that are created to deal with specific requirements, such as online
    payments, authentication, data storage, and so on. This leads us to the creation
    of serverless architectures; with these, companies are focusing more on their
    businesses requirements rather than on details that were solved by other companies
    and are offered as ready-to-consume services.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算准备就绪，X作为服务范式出现了。我们现在有针对特定要求创建的服务，比如在线支付、身份验证、数据存储等。这导致了无服务器架构的创建；通过这些，公司更多地关注他们的业务需求，而不是那些被其他公司解决并作为现成服务提供的细节。
- en: Having clients around the world means that there is more data to store, and
    improved data storage is replacing old relational models. NoSQL was forced to
    be conceived, and recommended techniques such as normalization have been replaced
    with these models, making practices and recommendations that were previously good
    entirely useless now. This movement even forced the creation of new careers around
    it. We are currently studying this data and making it worthwhile. Data scientists
    are becoming popular today, and their role is to identify what other business
    opportunities are hidden behind the data, as well as what actions IT people need
    to take based on this.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有世界各地的客户意味着有更多的数据需要存储，改进的数据存储正在取代旧的关系模型。NoSQL被迫被构想出来，而像规范化这样的推荐技术已被这些模型取代，使以前良好的做法和建议现在完全无用。这一运动甚至迫使围绕它产生了新的职业。我们目前正在研究这些数据并使其有价值。数据科学家如今变得很受欢迎，他们的角色是识别数据背后隐藏的其他业务机会，以及基于此需要采取什么行动的IT人员。
- en: Allowing customers to consume services quickly is the functionality that companies
    are looking for, and conversational interfaces are guiding us to the right path.
    Devices that contain software to allow people to establish conversations using
    their voice (such as Alexa, Cortana, and Siri, among others) are offering new
    possibilities to consume services easier and faster. SDK tools are currently available
    for developers in many programming languages, since polyglot developers are the most
    common nowadays.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让客户快速消费服务是公司正在寻找的功能，而会话界面正在引导我们走向正确的道路。包含软件的设备允许人们使用他们的语音建立对话（如Alexa、Cortana和Siri等），为消费服务提供了更简单、更快速的新可能性。SDK工具目前适用于许多编程语言的开发人员，因为多语言开发人员如今是最常见的。
- en: Not all businesses need to embrace these new trends. However, these new options
    are introducing companies to a world of opportunities that will provide them with
    an advantage over those that are not embracing them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有企业都需要拥抱这些新趋势。然而，这些新选择正在向公司介绍一个充满机遇的世界，这将使它们比不拥抱这些趋势的公司具有优势。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the underlying concepts inherent to software architecture.
    Even when the exposed principles have been in the industry for a while, they are
    still relevant, and it's worth considering them when working on architectural
    aspects. Something to remember is that high cohesion and low coupling refers to
    how you connect your components to shape your software architecture, and the SOLID
    principles apply to the design of each one of them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与软件架构相关的基本概念。即使这些原则在行业中已经存在一段时间，它们仍然是相关的，而且在处理架构方面时值得考虑。需要记住的是，高内聚和低耦合是指如何连接组件来塑造软件架构，而SOLID原则适用于每个组件的设计。
- en: To wrap this up, in this chapter, we have talked about how the software industry
    is evolving to embrace the new business challenges that companies are currently
    facing. In the next chapter, we will review what software architecture dimensions
    are in depth, and we will also learn how to use the C4 model to document software
    architectures.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在本章中，我们讨论了软件行业如何发展以应对公司目前面临的新业务挑战。在下一章中，我们将深入了解软件架构的维度，并学习如何使用C4模型来记录软件架构。
