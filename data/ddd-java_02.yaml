- en: '*Chapter 1*: The Rationale for Domain-Driven Design'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：领域驱动设计的理由'
- en: The being cannot be termed rational or virtuous, who obeys any authority, but
    that of reason.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何服从任何权威而不是理性的人都不能被称为理性或道德的。
- en: — Mary Wollstonecraft
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ——玛丽·沃斯通克拉夫特
- en: According to the **Project Management Institute’s** (**PMI’s**) *Pulse of the
    Profession* report published in February 2020, only 77% of all projects meet their
    intended goals—and even this is true only in the most mature organizations. For
    less mature organizations, this number falls to just 56%; that is, approximately
    one in every two projects does not meet its intended goals. Furthermore, approximately
    one in every five projects is declared an outright failure. At the same time,
    we also seem to be embarking on our most ambitious and complex projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据2020年2月发布的**项目管理协会（PMI**）的《职业脉搏》报告，只有77%的所有项目达到预期目标——即使在最成熟的组织中也是如此。对于不太成熟的组织，这个数字下降到仅为56%；也就是说，大约每两个项目中就有一个没有达到预期目标。此外，大约每五个项目中就有一个被宣布为彻底失败。与此同时，我们似乎也在着手进行我们最雄心勃勃和最复杂的项目。
- en: In this chapter, we will examine the main causes of project failure and look
    at how applying **domain-driven design** (**DDD**) provides a set of guidelines
    and techniques to improve the odds of success in our favor. While Eric Evans wrote
    his classic book on the subject way back in 2003, we look at why that work is
    still extremely relevant in today’s times.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨项目失败的主要原因，并查看应用**领域驱动设计（DDD**）如何提供一套指南和技术，以提高我们成功的几率。虽然埃里克·埃文斯在2003年就写下了关于这个主题的经典书籍，但我们来看为什么这项工作在今天仍然极其相关。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding why software projects fail
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解软件项目失败的原因
- en: Characteristics of modern systems and dealing with complexity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代系统的特征和应对复杂性
- en: Introduction to DDD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计简介
- en: Reviewing why DDD is relevant today
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾为什么DDD今天仍然相关
- en: By the end of this chapter, you will have gained a basic understanding of DDD
    and why you should strongly consider applying the tenets of DDD when architecting/implementing
    modern software applications, especially the more complex ones.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将获得对DDD的基本理解，以及为什么在架构/实现现代软件应用时，你应该强烈考虑应用DDD的原则，特别是对于更复杂的应用。
- en: Why do software projects fail?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么软件项目会失败？
- en: Failure is simply the opportunity to begin again, this time more intelligently.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 失败仅仅是开始再次尝试的机会，这次更加明智。
- en: — Henry Ford
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ——亨利·福特
- en: 'According to the project success report published in the *Project Management
    Journal* of the PMI, the following six factors need to be true for a project to
    be deemed successful:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据PMI的《项目管理杂志》发布的项目成功报告，以下六个因素必须真实存在，一个项目才能被认为是成功的：
- en: '![](img/B16716_01_Table_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16716_01_Table_01.jpg)'
- en: Table 1.1 – Project success factors
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1 – 项目成功因素
- en: With all of these criteria being applied to assess project success, a large
    percentage of projects fail for one reason or another. Let’s examine some of the
    top reasons in more detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用所有这些标准来评估项目成功的情况下，大量项目由于各种原因而失败。让我们更详细地考察一些主要原因。
- en: Inaccurate requirements
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不准确的需求
- en: PMI’s *Pulse of the Profession* report from 2017 highlights a very stark fact—a
    vast majority of projects fail due to inaccurate or misinterpreted requirements.
    It follows that it is impossible to build something that clients can use, they
    are happy with, and that makes them more effective at their jobs if the wrong
    thing gets built—even much less for the project to be built on time and within
    budget.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PMI的《职业脉搏》报告（2017年）强调了一个非常明显的事实——绝大多数项目失败是由于不准确或误解的需求。因此，如果建成了错误的东西，那么就不可能建成客户可以使用、满意并且使他们工作更有效率的东西——更不用说项目能否按时并在预算内完成。
- en: IT teams, especially in large organizations, are staffed with mono-skilled roles,
    such as UX designer, developer, tester, architect, business analyst, project manager,
    product owner, and business sponsor. In a lot of cases, these people are parts
    of distinct organization units/departments—each with its own set of priorities
    and motivations. To make matters even worse, the geographical separation between
    these people only keeps increasing. The need to keep costs down and the recent
    COVID-19 ecosystem does not help matters either.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: IT团队，尤其是在大型组织中，由单一技能角色组成，如UX设计师、开发者、测试员、架构师、业务分析师、项目经理、产品所有者和业务赞助人。在许多情况下，这些人属于不同的组织单位/部门——每个单位/部门都有自己的优先级和动机。更糟糕的是，这些人之间的地理分隔还在不断加大。为了降低成本和最近的COVID-19生态系统也不利于解决这个问题。
- en: '![Figure 1.1 – Silo mentality and the loss of information fidelity'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.1 – 隔离思维和信息保真度损失]'
- en: '](img/B16716_Figure_1.1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16716_Figure_1.1.jpg](img/B16716_Figure_1.1.jpg)'
- en: Figure 1.1 – Silo mentality and the loss of information fidelity
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 隔离思维和信息保真度损失
- en: All this results in a loss in fidelity of information at every stage in the
    assembly line, which then results in misconceptions, inaccuracies, delays, and
    eventually failure!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都导致在装配线每个阶段的信息保真度下降，进而导致误解、不准确、延误，最终失败！
- en: Too much architecture
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过多的架构
- en: Writing complex software is quite a task. You cannot just hope to sit down and
    start typing code—although that approach might work in some trivial cases. Before
    translating business ideas into working software, a thorough understanding of
    the problem at hand is necessary. For example, it is not possible (or is at least
    extremely hard) to build credit card software without understanding how credit
    cards work in the first place. To communicate your understanding of a problem,
    it is not uncommon to create software models of the problem before writing code.
    This model or collection of models represents the understanding of the problem
    and the architecture of the solution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编写复杂的软件是一项相当艰巨的任务。你不能只是坐下来开始敲代码——尽管这种方法在某些简单情况下可能有效。在将业务理念转化为可工作的软件之前，对当前问题的彻底理解是必要的。例如，如果不了解信用卡是如何工作的，就不可能（或者至少非常困难）构建信用卡软件。为了传达你对问题的理解，在编写代码之前创建软件模型来表示问题及其解决方案的架构是很常见的。
- en: Efforts to create a perfect model of the problem—one that is accurate in a very
    broad context—are not dissimilar to the proverbial holy grail quest. Those accountable
    for producing the architecture can get stuck in analysis paralysis and/or big
    design upfront, producing artifacts that are one or more of too high level, wishful,
    gold-plated, buzzword-driven, or disconnected from the real world—while not solving
    any real business problems. This kind of lock-in can be especially detrimental
    during the early phases of the project when the knowledge levels of team members
    are still up and coming. Needless to say, projects adopting such approaches find
    it hard to reach success consistently.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 努力创建一个完美的问题模型——在非常广泛的背景下都是准确的——并不亚于传说中的圣杯之旅。负责产生架构的人可能会陷入分析瘫痪和/或前期大设计，产生出过于高级、充满幻想、镀金、口号驱动或脱离现实世界的工件——而未能解决任何真正的业务问题。这种锁定在项目早期阶段，当团队成员的知识水平还在上升时，可能会特别有害。不用说，采用这种方法的项目的成功往往难以持续。
- en: Tip
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For a more comprehensive list of modeling anti-patterns, refer to Scott W.
    Ambler’s website ([http://agilemodeling.com/essays/enterpriseModelingAntiPatterns.htm](http://agilemodeling.com/essays/enterpriseModelingAntiPatterns.htm))
    and book, *Agile Modeling: Effective Practices for eXtreme Programming and the
    Unified Process*, dedicated to the subject.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取建模反模式的更全面列表，请参考Scott W. Ambler的网站([http://agilemodeling.com/essays/enterpriseModelingAntiPatterns.htm](http://agilemodeling.com/essays/enterpriseModelingAntiPatterns.htm))和书籍，《敏捷建模：极限编程和统一过程的实用方法》，该书专门论述了这一主题。
- en: Too little architecture
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构过少
- en: Agile software delivery methods manifested themselves in the late 90s and early
    2000s in response to heavyweight processes collectively known as *waterfall*.
    These processes seemed to favor big design upfront and abstract ivory tower thinking
    based on wishful, ideal-world scenarios. This was based on the premise that thinking
    things out well in advance ends up saving serious development headaches later
    on as the project progresses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷软件开发方法在20世纪90年代末和21世纪初显现出来，是对被称为“瀑布”的重量级流程的反应。这些流程似乎更倾向于前期的大规模设计和基于愿望、理想世界场景的抽象象牙塔思维。这是基于这样一个前提：提前深思熟虑可以避免在项目进展过程中出现严重的开发问题。
- en: In contrast, agile methods seem to favor a much more nimble and iterative approach
    to software development with a high focus on working software over other artifacts,
    such as documentation. Most teams these days claim to practice some form of iterative
    software development. However, with this obsession to claim conformance to a specific
    family of agile methodologies as opposed to the underlying principles, a lot of
    teams misconstrue having just enough architecture with having no perceptible architecture.
    This results in a situation where adding new features or enhancing existing ones
    takes a lot longer than what it previously used to—which then accelerates the
    devolution of the solution to become the dreaded big ball of mud ([http://www.laputan.org/mud/mud.html#BigBallOfMud](http://www.laputan.org/mud/mud.html#BigBallOfMud)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，敏捷方法似乎更倾向于一种更加灵活和迭代的软件开发方法，高度关注可工作的软件而不是其他工件，如文档。如今，大多数团队都声称在实践某种形式的迭代软件开发。然而，这种对声称符合特定敏捷方法论家族而不是基本原理的执着，导致许多团队误解了“足够的架构”与“没有明显架构”之间的区别。这导致了一种情况，即添加新功能或增强现有功能所需的时间比以前更长——这进而加速了解决方案的退化，变成了令人恐惧的“大泥球”（[http://www.laputan.org/mud/mud.html#BigBallOfMud](http://www.laputan.org/mud/mud.html#BigBallOfMud)）。
- en: Excessive incidental complexity
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过度的偶然复杂性
- en: 'Mike Cohn popularized the notion of the test pyramid, where he talks about
    how a large number of unit tests should form the foundation of a sound testing
    strategy—with numbers decreasing significantly as you move up the pyramid. The
    rationale here is that as you move up the pyramid, the cost of upkeep goes up
    copiously while the speed of execution slows down manifold. In reality, though,
    a lot of teams seem to adopt a strategy that is the exact opposite of this—known
    as the testing ice cream cone, as depicted here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克·科恩（Mike Cohn）普及了测试金字塔的概念，他在其中谈到，大量的单元测试应该构成一个健全测试策略的基础——随着你向上移动金字塔，数字会显著减少。这里的逻辑是，随着你向上移动金字塔，维护成本急剧上升，而执行速度却大幅下降。然而，在现实中，许多团队似乎采用了与此完全相反的策略——被称为测试冰淇淋锥形，如图所示：
- en: '![Figure 1.2 – Testing strategy: expectation versus reality'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – 测试策略：期望与现实'
- en: '](img/B16716_Figure_1.2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_1.2.jpg)'
- en: 'Figure 1.2 – Testing strategy: expectation versus reality'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 测试策略：期望与现实
- en: The testing ice cream cone is a classic case of what Fred Brooks calls incidental
    complexity in his seminal paper titled *No Silver Bullet—Essence and Accident
    in Software Engineering* ([http://worrydream.com/refs/Brooks-NoSilverBullet.pdf](http://worrydream.com/refs/Brooks-NoSilverBullet.pdf)).
    All software has some amount of essential complexity that is inherent to the problem
    being solved. This is especially true when creating solutions for non-trivial
    problems. However, incidental or accidental complexity is not directly attributable
    to the problem itself—but is caused by the limitations of the people involved,
    their skill levels, the tools, and/or abstractions being used. Not keeping tabs
    on incidental complexity causes teams to veer away from focusing on the real problems,
    solving which provide the most value. It naturally follows that such teams minimize
    their odds of success appreciably.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试冰淇淋锥形是弗雷德·布鲁克斯在其经典论文《没有银弹——软件工程中的本质与偶然》中提到的偶然复杂性的一个典型案例（[http://worrydream.com/refs/Brooks-NoSilverBullet.pdf](http://worrydream.com/refs/Brooks-NoSilverBullet.pdf)）。所有软件都有一定程度的本质复杂性，这是解决问题的固有属性。这在为非平凡问题创建解决方案时尤其如此。然而，偶然或意外的复杂性并不是直接归因于问题本身——而是由涉及人员的局限性、他们的技能水平、工具和/或使用的抽象造成的。不关注偶然复杂性会导致团队偏离关注真正的问题，解决这些问题可以提供最大的价值。因此，这样的团队成功的机会显著降低。
- en: Uncontrolled technical debt
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无法控制的债务
- en: Financial debt is the act of borrowing money from an outside party to quickly
    finance the operations of a business—with the promise to repay the principal plus
    the agreed-upon rate of interest in a timely manner. Under the right circumstances,
    this can accelerate the growth of a business considerably while allowing the owner
    to retain ownership, reduced taxes, and lower interest rates. On the other hand,
    the inability to pay back this debt on time can adversely affect credit rating,
    result in higher interest rates, cash flow difficulties, and other restrictions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 财务债务是指从外部借款以快速资助企业的运营——承诺及时偿还本金加上约定的利率。在适当的条件下，这可以显著加速企业的增长，同时允许所有者保留所有权、降低税收和较低的利率。另一方面，如果不能按时偿还这笔债务，可能会对信用评级产生不利影响，导致利率上升、现金流困难和其他限制。
- en: 'Technical debt is what results when development teams take arguably suboptimal
    actions to expedite the delivery of a set of features or projects. For a period
    of time, just like borrowed money allows you to do things sooner than you could
    otherwise, technical debt can result in short-term speed. In the long term, however,
    software teams will have to dedicate a lot more time and effort toward simply
    managing complexity as opposed to thinking about producing architecturally sound
    solutions. This can result in a vicious negative cycle, as illustrated in the
    following diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务是当开发团队采取可能不是最佳的行动来加速一组功能或项目的交付时产生的。在一段时间内，就像借款允许你比其他方式更快地做事一样，技术债务可以带来短期速度。然而，从长远来看，软件团队将不得不投入更多的时间和精力来简单地管理复杂性，而不是思考产生架构上合理的解决方案。这可能导致以下图中所示的恶性负面循环：
- en: '![Figure 1.3 – Technical debt: implications'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 技术债务：影响'
- en: '](img/B16716_Figure_1.3.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_1.3.jpg)'
- en: 'Figure 1.3 – Technical debt: implications'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 技术债务：影响
- en: In a recent McKinsey survey ([https://www.mckinsey.com/business-functions/mckinsey-digital/our-insights/tech-debt-reclaiming-tech-equity](https://www.mckinsey.com/business-functions/mckinsey-digital/our-insights/tech-debt-reclaiming-tech-equity))
    sent out to CIOs, around 60% reported that the amount of technical debt increased
    over the past 3 years. At the same time, over 90% of CIOs allocated less than
    a fifth of their tech budget toward paying it off. Martin Fowler explores ([https://martinfowler.com/articles/is-quality-worth-cost.html#WeAreUsedToATrade-offBetweenQualityAndCost](https://martinfowler.com/articles/is-quality-worth-cost.html#WeAreUsedToATrade-offBetweenQualityAndCost))
    the deep correlation between high software quality (or the lack thereof) and the
    ability to enhance software predictably. While carrying a certain amount of technical
    debt is inevitable and part of doing business, not having a plan to systematically
    pay off this debt can have significantly detrimental effects on team productivity
    and the ability to deliver value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近麦肯锡公司对CIOs进行的一项调查（[https://www.mckinsey.com/business-functions/mckinsey-digital/our-insights/tech-debt-reclaiming-tech-equity](https://www.mckinsey.com/business-functions/mckinsey-digital/our-insights/tech-debt-reclaiming-tech-equity)）中，大约60%的受访者表示，过去3年中技术债务的数量有所增加。与此同时，超过90%的CIOs将不到五分之一的科技预算用于偿还债务。马丁·福勒探讨了([https://martinfowler.com/articles/is-quality-worth-cost.html#WeAreUsedToATrade-offBetweenQualityAndCost](https://martinfowler.com/articles/is-quality-worth-cost.html#WeAreUsedToATrade-offBetweenQualityAndCost))高软件质量（或缺乏质量）与增强软件的可预测性之间的深层相关性。虽然携带一定量的技术债务是不可避免的，也是商业活动的一部分，但没有计划系统地偿还这些债务可能会对团队生产力和交付价值的能力产生严重影响。
- en: Ignoring non-functional requirements
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略非功能性需求
- en: Stakeholders often want software teams to spend the majority (if not all) of
    their time working on features that provide enhanced functionality. This is understandable
    given that such features provide the highest ROI. These features are called functional
    requirements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 利益相关者通常希望软件开发团队将大部分（如果不是全部）时间用于开发提供增强功能的功能。考虑到这些功能提供了最高的投资回报率，这是可以理解的。这些功能被称为功能需求。
- en: 'Non-functional requirements (also sometimes known as cross-functional requirements),
    on the other hand, are those aspects of the system that do not affect functionality
    directly but have a profound effect on the efficacy of those using and maintaining
    these systems. There are many kinds of NFRs. A partial list of common NFRs is
    depicted in the following figure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能性需求（有时也称为跨功能性需求），另一方面，是指那些不直接影响功能但会对使用和维护这些系统的人的效率产生深远影响的系统方面。有许多种类的NFR。以下图中展示了常见NFR的部分列表：
- en: '![Figure 1.4 – NFRs'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 非功能性需求（NFRs）](img/B16716_Figure_1.4.jpg)'
- en: '](img/B16716_Figure_1.4.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – NFRs](img/B16716_Figure_1.4.jpg)'
- en: Figure 1.4 – NFRs
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 非功能性需求（NFRs）
- en: Very rarely do users explicitly request NFRs, but they almost always expect
    these features to be part of any system they use. Oftentimes, systems may continue
    to function without NFRs being met, but not without having an adverse impact on
    the *quality* of the user experience. For example, the home page of a website
    that loads in under 1 second under low load and takes upward of 30 seconds under
    higher loads may not be usable during those times of stress. Needless to say,
    not treating NFRs with the same amount of rigor as explicit, value-adding functional
    features can lead to unusable systems—and subsequently failure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用户很少会明确要求非功能性需求（NFRs），但他们几乎总是期望这些功能成为他们使用的任何系统的一部分。很多时候，系统可能在没有满足非功能性需求的情况下继续运行，但这会对用户体验的“质量”产生不利影响。例如，在低负载下加载时间不到
    1 秒，而在高负载下加载时间超过 30 秒的网站主页，在压力时期可能无法使用。不用说，如果不以与显式、增值的功能特性相同的标准来对待非功能性需求，可能会导致无法使用的系统——进而导致失败。
- en: In this section, we examined some common reasons why software projects to fail.
    Is it possible to improve our odds? Before we do that, let’s look at the nature
    of modern software systems and how we can deal with the ensuing complexity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了导致软件项目失败的一些常见原因。我们能否提高我们的胜算？在我们这样做之前，让我们看看现代软件系统的本质以及我们如何应对随之而来的复杂性。
- en: Modern systems and dealing with complexity
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代系统和处理复杂性
- en: We cannot solve our problems with the same level of thinking that created them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能用创造问题的同一层次的思维来解决我们的问题。
- en: — Albert Einstein
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: —— 阿尔伯特·爱因斯坦
- en: As we saw in the previous section, there are several reasons why software endeavors
    fail. In this section, we will try to understand how software gets built, what
    the currently prevailing realities are, and what adjustments we need to make in
    order to cope.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，软件项目失败有几个原因。在本节中，我们将尝试理解软件是如何被构建的，目前存在的现实情况是什么，以及我们需要做出哪些调整来应对。
- en: How software gets built
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件是如何被构建的
- en: 'Building successful software is an iterative process of constantly refining
    knowledge and expressing it in the form of models. We have attempted to capture
    the essence of the process at a high level here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功的软件是一个不断精炼知识和以模型形式表达的过程。我们试图在这里从高层次上捕捉这一过程的精髓：
- en: '![Figure 1.5 – Building software is a continuous refinement of knowledge and
    models'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – 开发软件是一个持续的知识和模型精炼过程](img/B16716_Figure_1.5.jpg)'
- en: '](img/B16716_Figure_1.5.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – 开发软件是一个持续的知识和模型精炼过程](img/B16716_Figure_1.5.jpg)'
- en: Figure 1.5 – Building software is a continuous refinement of knowledge and models
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 开发软件是一个持续的知识和模型精炼过程
- en: Before we express a solution in working code, it is necessary to understand
    *what* the problem entails, *why* the problem is important to solve, and finally,
    *how* it can be solved. Irrespective of the methodology used (waterfall, agile,
    and/or anything in between), the process of building software is one where we
    need to constantly use our knowledge to refine mental/conceptual models to be
    able to create valuable solutions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将解决方案以工作代码的形式表达出来之前，有必要理解问题所包含的“什么”，为什么这个问题需要解决，以及最后“如何”解决它。无论使用的方法论（瀑布、敏捷，以及两者之间的任何方法），构建软件的过程都是一个需要我们不断运用知识来精炼心理/概念模型，以便能够创造有价值的解决方案的过程。
- en: Complexity is inevitable
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂性是不可避免的
- en: 'We find ourselves in the midst of the fourth industrial revolution, where the
    world is becoming more and more digital—with technology being a significant driver
    of value for businesses. There have been exponential advances in computing technology,
    as illustrated by Moore’s law:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现自己正处于第四次工业革命之中，世界正变得越来越数字化——技术成为企业价值的重要驱动力。正如摩尔定律所展示的，计算技术已经取得了指数级的进步：
- en: '![Figure 1.6 – Moore’s law'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – 摩尔定律](img/B16716_Figure_1.6.jpg)'
- en: '](img/B16716_Figure_1.6.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – 摩尔定律](img/B16716_Figure_1.6.jpg)'
- en: Figure 1.6 – Moore’s law
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 摩尔定律
- en: This has also coincided with the rise of the internet.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这也与互联网的兴起相吻合。
- en: '![Figure 1.7 – Global internet traffic'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – 全球互联网流量'
- en: '](img/B16716_Figure_1.7.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – 全球互联网流量](img/B16716_Figure_1.7.jpg)'
- en: Figure 1.7 – Global internet traffic
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 全球互联网流量
- en: This has meant that companies are being required to modernize their software
    systems much more rapidly than they ever have. Along with all this, the onset
    of commodity computing services, such as the public cloud, has led to a move away
    from expensive centralized computing systems to more distributed computing ecosystems.
    As we attempt to build our most complex solutions, monoliths are being replaced
    by an environment of distributed, collaborating microservices. Modern philosophies
    and practices, such as automated testing, architecture fitness functions, continuous
    integration, continuous delivery, DevOps, security automation, and infrastructure
    as code, to name a few, are disrupting the way we deliver software solutions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着公司需要比以往任何时候都要更快地现代化他们的软件系统。伴随着所有这些，商品计算服务的出现，如公共云，导致了从昂贵的集中式计算系统转向更分散的计算生态系统。当我们试图构建最复杂的解决方案时，单体正在被分布式、协作的微服务环境所取代。现代哲学和实践，如自动化测试、架构适应性函数、持续集成、持续交付、DevOps、安全自动化和基础设施即代码等，正在颠覆我们交付软件解决方案的方式。
- en: All these advances introduce their own share of complexity. Instead of attempting
    to control the amount of complexity, there is a need to embrace and cope with
    it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些进步都引入了自己的复杂性。而不是试图控制复杂性的数量，我们需要接受并应对它。
- en: Optimizing the feedback loop
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化反馈循环
- en: As we enter an age of encountering our most complex business problems, we need
    to embrace new ways of thinking, development philosophy, and an arsenal of techniques
    to iteratively evolve mature software solutions that will stand the test of time.
    We need better ways of communicating, analyzing problems, arriving at a collective
    understanding, creating and modeling abstractions, and then implementing and enhancing
    the solution.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入遇到最复杂商业问题的时代，我们需要拥抱新的思维方式、发展哲学和一系列技术，以迭代地进化成熟的软件解决方案，这些解决方案将经受住时间的考验。我们需要更好的沟通方式、分析问题、达成共识、创建和建模抽象，然后实施和增强解决方案。
- en: 'To state the obvious—we’re all building software with seemingly brilliant business
    ideas on one side and our ever-demanding customers on the other, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 明白地说——我们都在用看似绝妙的商业理念一边构建软件，另一边则是我们不断要求苛刻的客户，正如这里所示：
- en: '![Figure 1.8 – The software delivery continuum'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8 – 软件交付连续体'
- en: '](img/B16716_Figure_1.8.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片/B16716_Figure_1.8.jpg]'
- en: Figure 1.8 – The software delivery continuum
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 软件交付连续体
- en: In between, we have two chasms to cross—the *delivery pipeline* and the *feedback
    pipeline*. The delivery pipeline enables us to put software in the hands of our
    customers, whereas the feedback pipeline allows us to adjust and adapt. As we
    can see, this is a continuum. If we are to build better, more valuable software,
    this continuum, this potentially infinite loop, has to be optimized!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们需要跨越两个鸿沟——*交付管道*和*反馈管道*。交付管道使我们能够将软件交到客户手中，而反馈管道则允许我们调整和适应。正如我们所见，这是一个连续体。如果我们想要构建更好、更有价值的软件，这个连续体，这个可能无限循环的过程，必须得到优化！
- en: 'To optimize this loop, we need three characteristics to be present: we need
    to be fast, we need to be reliable, and we need to do this over and over again.
    In other words, we need to be rapid, reliable, and repeatable—all at the same
    time! Take any one of these away and it just won’t sustain.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化这个循环，我们需要三个特征同时存在：我们需要快速、我们需要可靠，并且我们需要不断地重复这样做。换句话说，我们需要快速、可靠和可重复——同时！去掉任何一个，它都无法持续。
- en: DDD promises to provide answers on how to do this in a systematic manner. In
    the upcoming section, and indeed the rest of this book, we will examine what DDD
    is and why it is indispensable when working to provide solutions for non-trivial
    problems in today’s world of massively distributed teams and applications.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD）承诺以系统化的方式提供答案。在接下来的章节中，以及本书的其余部分，我们将探讨领域驱动设计（DDD）是什么，以及为什么在为当今大规模分布式团队和应用程序中的非平凡问题提供解决方案时，它是不可或缺的。
- en: What is DDD?
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是领域驱动设计（DDD）？
- en: Life is really simple, but we insist on making it complicated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 生活其实很简单，但我们却坚持让它变得复杂。
- en: — Confucius
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: —— 孔子
- en: In the previous section, we saw how a myriad of reasons, coupled with system
    complexity, gets in the way of software project success. The idea of DDD, originally
    conceived by Eric Evans in his 2003 book, is an approach to software development
    that focuses on expressing software solutions in the form of a model that closely
    embodies the core of the problem being solved. It provides a set of principles
    and systematic techniques to analyze, architect, and implement software solutions
    in a manner that enhances the chances of success.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了众多原因以及系统复杂性是如何阻碍软件项目成功的。DDD（领域驱动设计）的概念，最初由埃里克·埃文斯在其2003年的著作中提出，是一种专注于以模型的形式表达软件解决方案的软件开发方法，该模型紧密体现了所解决问题的核心。它提供了一套原则和系统化的技术，以分析、设计和实现软件解决方案，从而提高成功的可能性。
- en: While Evans’ work is indeed seminal, ground-breaking, and way ahead of its time,
    it is not prescriptive at all. This is a strength in that it has enabled the evolution
    of DDD beyond what Evans had originally conceived at the time. On the other hand,
    it also makes it extremely hard to define what DDD actually encompasses, making
    practical application a challenge. In this section, we will look at some foundational
    terms and concepts behind DDD. Elaboration and practical application of these
    concepts will happen in upcoming chapters of this book.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然埃文斯的工作确实是开创性的、突破性的，并且远远领先于其时代，但它并不具有规范性。这实际上是一种优势，因为它使得DDD的演变超越了埃文斯当时所构想的。另一方面，这也使得定义DDD实际上包含的内容变得极其困难，使得实际应用成为一个挑战。在本节中，我们将探讨DDD背后的某些基础术语和概念。这些概念的详细阐述和实际应用将在本书的后续章节中展开。
- en: 'When encountering a complex business problem, DDD suggests doing the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到复杂的企业问题时，DDD建议采取以下措施：
- en: '**Understand the problem**: To have a deep, shared understanding of the problem,
    it is necessary for business and technology experts to collaborate closely. Here,
    we collectively understand what the problem is and why it is valuable to solve.
    This is termed the **domain** of the problem.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解问题**：为了对问题有一个深入、共享的理解，商业和技术专家需要紧密合作。在这里，我们共同理解问题的本质以及为什么解决问题是有价值的。这被称为问题的**领域**。'
- en: '**Break down the problem into more manageable parts**: To keep complexity at
    manageable levels, break down complex problems into smaller, independently solvable
    parts. These parts are termed **subdomains**. It may be necessary to further break
    down subdomains where the subdomain is still too complex. Assign explicit boundaries
    to limit the functionality of each subdomain. This boundary is termed the **bounded
    context** for that subdomain. It may also be convenient to think of the subdomain
    as a concept that makes more sense to the domain experts (in the problem space),
    whereas the bounded context is a concept that makes more sense to the technology
    experts (in the solution space).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将问题分解为更易管理的部分**：为了保持复杂性在可管理的水平，将复杂问题分解为更小、可独立解决的组成部分。这些部分被称为**子领域**。如果子领域仍然过于复杂，可能还需要进一步分解子领域。为每个子领域分配明确的边界以限制其功能。这个边界被称为该子领域的**边界上下文**。也可能方便地将子领域视为对领域专家（在问题空间中）更有意义的概念，而边界上下文是对技术专家（在解决方案空间中）更有意义的概念。'
- en: 'For each of these bounded contexts, do the following:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这些边界上下文中的每一个，都要做以下事情：
- en: '**Agree on a shared language**: Formalize the understanding by establishing
    a shared language that is applicable unambiguously within the bounds of the subdomain.
    This shared language is termed the ubiquitous language of the domain.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**达成共识的共享语言**：通过建立一个适用于子领域范围内的明确共享语言来正式化理解。这种共享语言被称为领域的通用语言。'
- en: '**Express understanding in shared models**: In order to produce working software,
    express the ubiquitous language in the form of shared models. This model is termed
    the **domain model**. There may exist multiple variations of this model, each
    meant to clarify a specific aspect of the solution, for example, a process model,
    a sequence diagram, working code, and a deployment topology.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在共享模型中表达理解**：为了生成可工作的软件，将通用语言以共享模型的形式表达出来。这个模型被称为**领域模型**。可能存在多个这种模型的变体，每个变体旨在阐明解决方案的特定方面，例如，流程模型、序列图、工作代码和部署拓扑。'
- en: '**Embrace the incidental complexity of the problem**: It is important to note
    that it is not possible to shy away from the essential complexity of a given problem.
    By breaking down the problem into subdomains and bounded contexts, we are attempting
    to distribute it (more or less) evenly across more manageable parts.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥抱问题的偶然复杂性**：需要注意的是，无法回避给定问题的本质复杂性。通过将问题分解为子域和边界上下文，我们试图将其（或多或少）均匀地分布在更易于管理的部分。'
- en: '**Continuously evolve for greater insight**: It is important to understand
    that the previous steps are not a one-time activity. Businesses, technologies,
    processes, and our understanding of these evolve, so it is important for our shared
    understanding to remain in sync with these models through continuous refactoring.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续进化以获得更深入的洞察**：重要的是要理解，之前的步骤并不是一次性的活动。企业、技术、流程以及我们对这些的理解都在不断进化，因此，我们的共同理解需要通过持续的重构与这些模型保持同步。'
- en: 'A pictorial representation of the essence of DDD is expressed here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了 DDD 本质的图示表示：
- en: '![Figure 1.9 – Essence of DDD'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – DDD 的本质'
- en: '](img/B16716_Figure_1.9.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_1.9.jpg)'
- en: Figure 1.9 – Essence of DDD
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – DDD 的本质
- en: We appreciate that this is quite a whirlwind introduction to the subject of
    DDD.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认识到，这只是一个关于领域驱动设计（DDD）主题的快速介绍。
- en: Understanding the problem using strategic design
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用战略设计理解问题
- en: In this section, let’s demystify some commonly used concepts and terms when
    working with DDD. First and foremost, we need to understand what we mean by the
    first *D* — **domain**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们揭开在使用 DDD 时一些常用概念和术语的神秘面纱。首先，我们需要理解我们所说的第一个 *D* —— **领域**。
- en: What is a domain?
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是领域？
- en: The foundational concept when working with DDD is the notion of a domain. But
    what exactly is a domain? The word domain, which has its *origins* in the 1600s
    from the old French word *domaine* (power) and the Latin word *dominium* (property,
    right of ownership) is a rather confusing word. Depending on who, when, where,
    and how it is used, it can mean different things.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用领域驱动设计（DDD）时，基础概念是领域这一概念。但领域究竟是什么？这个词“领域”起源于 17 世纪，源自古老的法语单词 *domaine*（权力）和拉丁语单词
    *dominium*（财产、所有权），是一个相当令人困惑的词。根据谁、何时、何地以及如何使用，它可以有不同的含义。
- en: '![Figure 1.10 – The meaning of domain changes with context'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – 领域的含义随上下文而变化'
- en: '](img/B16716_Figure_1.10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_1.10.jpg)'
- en: Figure 1.10 – The meaning of domain changes with context
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 领域的含义随上下文而变化
- en: In the context of a business, however, the word domain covers the overall scope
    of its primary activity—the service it provides to its customers. This is also
    referred to as the **problem domain**. For example, Tesla operates in the domain
    of electric vehicles, Netflix provides online movies and shows, and McDonald’s
    provides fast food. Some companies such as Amazon provide services in more than
    one domain—online retail and cloud computing, among others. The domain of a business
    (at least the successful ones) almost always encompasses fairly complex and abstract
    concepts. To cope with this complexity, it is usual to decompose these domains
    into more manageable pieces called subdomains. Let’s understand subdomains in
    more detail next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在商业的背景下，这个词“领域”涵盖了其主要活动的整体范围——它向客户提供的服务。这也被称为**问题域**。例如，特斯拉在电动汽车领域运营，Netflix
    提供在线电影和电视节目，麦当劳提供快餐。一些公司，如亚马逊，在多个领域提供服务——在线零售和云计算等。一个企业的领域（至少是成功的那些）几乎总是包含相当复杂和抽象的概念。为了应对这种复杂性，通常将这些领域分解成更易于管理的部分，称为子域。接下来，让我们更详细地了解子域。
- en: What is a subdomain?
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是子域？
- en: 'In its essence, DDD provides means to tackle complexity. Engineers do this
    by breaking down complex problems into more manageable ones called **subdomains**.
    This facilitates better understanding and makes it easier to arrive at a solution.
    For example, the online retail domain may be divided into subdomains such as product,
    inventory, rewards, shopping cart, order management, payments, and shipping, as
    shown in the following figure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，DDD 提供了解决复杂性的方法。工程师通过将复杂问题分解为更易于管理的子域来实现这一点。这有助于更好地理解，并使找到解决方案变得更加容易。例如，在线零售领域可以划分为如产品、库存、奖励、购物车、订单管理、支付和运输等子域，如下面的图所示：
- en: '![Figure 1.11 – Subdomains in the retail'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11 – 零售中的子域'
- en: '](img/B16716_Figure_1.11.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_1.11.jpg)'
- en: Figure 1.11 – Subdomains in the retail
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 零售中的子域
- en: 'In certain businesses, subdomains themselves may turn out to become very complex
    on their own and may require further decomposition. For instance, in the retail
    example, it may be required to break the products subdomain into further constituent
    subdomains, such as catalog, search, recommendations, and reviews, as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些商业活动中，子域本身可能变得非常复杂，可能需要进一步的分解。例如，在零售的例子中，可能需要将产品子域进一步分解成更基本的子域，如目录、搜索、推荐和评论，如图所示：
- en: '![Figure 1.12 – Subdomains in the products subdomain'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12 – 产品子域中的子域'
- en: '](img/B16716_Figure_1.12.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16716_Figure_1.12.jpg]'
- en: Figure 1.12 – Subdomains in the products subdomain
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 产品子域中的子域
- en: Further breakdown of subdomains may be needed until we reach a level of manageable
    complexity. Domain decomposition is an important aspect of DDD. Let’s look at
    the types of subdomains to understand this better.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要进一步分解子域，直到达到可管理的复杂度水平。领域分解是领域驱动设计（DDD）的一个重要方面。让我们看看子域的类型，以便更好地理解这一点。
- en: Important Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The terms domain and subdomain tend to get used interchangeably quite often.
    This can be confusing to the casual onlooker. Given that subdomains tend to be
    quite complex and hierarchical, a subdomain can be a domain in its own right.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: “域”和“子域”这两个术语往往被交替使用，这可能会让旁观者感到困惑。鉴于子域往往非常复杂且具有层次结构，一个子域本身就可以成为一个域。
- en: Types of subdomains
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 子域类型
- en: 'Breaking down a complex domain into more manageable subdomains is a great thing
    to do. However, not all subdomains are created equal. With any business, the following
    three types of subdomains are going to be encountered:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个复杂的领域分解成更易于管理的子域是一件好事。然而，并非所有子域都是平等的。在任何一个商业活动中，你可能会遇到以下三种类型的子域：
- en: '**Core**: The main focus area for the business. This is what provides the biggest
    differentiation and value. It is, therefore, natural to want to place the most
    focus on the core subdomain. In the retail example, shopping carts and orders
    might be the biggest differentiation—and hence may form the core subdomains for
    that business venture. It is prudent to implement core subdomains in-house, given
    that it is something that businesses will desire to have the most control over.
    In the online retail example, the business may want to focus on providing an enriched
    experience for placing online orders. This will make the *online orders* and *shopping
    cart* part of the core subdomain.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心**：商业的主要关注领域。这是提供最大差异化和价值的地方。因此，自然地，人们会希望将最多的关注放在核心子域上。在零售的例子中，购物车和订单可能是最大的差异化因素——因此可能形成该商业冒险的核心子域。鉴于这是企业希望拥有最大控制权的地方，内部实施核心子域是明智的。在在线零售的例子中，企业可能希望专注于提供在线订单的丰富体验。这将使**在线订单**和**购物车**成为核心子域的一部分。'
- en: '**Supporting**: Like with every great movie, where it is not possible to create
    a masterpiece without a solid supporting cast, so it is with supporting or auxiliary
    subdomains. Supporting subdomains are usually very important and very much required
    but may not be the primary focus of running the business. These supporting subdomains,
    while necessary to run the business, do not usually offer a significant competitive
    advantage. Hence, it might even be fine to completely outsource this work or use
    an off-the-shelf solution as is or with minor tweaks. For the retail example,
    assuming that online ordering is the primary focus of this business, catalog management
    may be a supporting subdomain.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持性**：就像每部伟大的电影都需要一个坚实的配角阵容才能成为杰作一样，支持性或辅助性子域也是如此。支持性子域通常非常重要且非常必要，但可能不是运营业务的主要焦点。尽管这些支持性子域对于运营业务是必要的，但通常不会提供显著的竞争优势。因此，甚至可以完全外包这项工作或使用现成的解决方案，或者进行一些小的调整。以零售为例，假设在线订购是这个业务的主要焦点，目录管理可能就是一个支持性子域。'
- en: '**Generic**: When working with business applications, you are required to provide
    a set of capabilities *not* directly related to the problem being solved. Consequently,
    it might suffice to just make use of an off-the-shelf solution. For the retail
    example, the identity, auditing, and activity tracking subdomains might fall in
    that category.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用**：在与商业应用打交道时，你需要提供一组与正在解决的问题**不直接相关**的能力。因此，仅仅使用现成的解决方案可能就足够了。以零售为例，身份验证、审计和活动跟踪子域可能就属于这一类别。'
- en: Important Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is important to note that the notion of core versus supporting versus generic
    subdomains is very context-specific. What is core for one business may be supporting
    or generic for another. Identifying and distilling the core domain requires a
    deep understanding and experience of what problem is being attempted to be solved.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '重要的是要注意，核心、支持性或通用子领域这一概念非常具体。对一家企业来说是核心的，对另一家企业来说可能是支持性或通用性。识别和提炼核心领域需要深入了解和经验，了解正在尝试解决的问题。 '
- en: 'Given that the core subdomain establishes most of the business differentiation,
    it will be prudent to devote the most amount of energy toward maintaining that
    differentiation. This is illustrated in the core domain chart here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于核心子领域建立了大部分业务差异化，因此明智的做法是将最多的精力投入到维护这种差异化上。这如图中的核心领域图所示：
- en: '![Figure 1.13 – Importance of subdomains'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.13 – 子领域的重要性'
- en: '](img/B16716_Figure_1.13.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16716_Figure_1.13.jpg]'
- en: Figure 1.13 – Importance of subdomains
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – 子领域的重要性
- en: 'Over time, it is only natural that competitors will attempt to emulate your
    successes. Newer, more efficient methods will arise, reducing the complexity involved
    and disrupting your core. This may cause the notion of what is currently core
    to shift and become a supporting or generic capability, as depicted here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，竞争对手尝试模仿您的成功是自然而然的事情。新的、更高效的方法将会出现，降低涉及的复杂性并扰乱您的核心。这可能会导致目前核心的概念发生转变，成为支持性或通用能力，如图所示：
- en: '![Figure 1.14 – Core domain erosion'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.14 – 核心领域侵蚀'
- en: '](img/B16716_Figure_1.14.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16716_Figure_1.14.jpg]'
- en: Figure 1.14 – Core domain erosion
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – 核心领域侵蚀
- en: To continue running a successful operation, it is required to constantly innovate
    at the core. For example, when AWS started the cloud computing business, it only
    provided simple infrastructure (IaaS) solutions. However, as competitors such
    as Microsoft and Google started to catch up, AWS has had to provide several additional
    value-added services (for example, PaaS and SaaS).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续运营一个成功的业务，需要在核心上不断进行创新。例如，当AWS开始云计算业务时，它只提供简单的基础设施（IaaS）解决方案。然而，随着微软和谷歌等竞争对手开始迎头赶上，AWS不得不提供几个额外的增值服务（例如，PaaS和SaaS）。
- en: As is evident, this is not just an engineering problem. It requires a deep understanding
    of the underlying business. That’s where domain experts can play a significant
    role.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，这不仅仅是一个工程问题。它需要深入了解潜在的业务。这就是领域专家可以发挥重要作用的地方。
- en: Domain and technical experts
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领域和技术专家
- en: 'Any modern software team requires expertise in at least two areas—the functionality
    of the domain and the art of translating it into high-quality software. In most
    organizations, these exist as at least two distinct groups of people:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 任何现代软件团队都需要至少在两个领域拥有专业知识——领域的功能以及将其转化为高质量软件的艺术。在大多数组织中，这些至少存在为两个不同的群体：
- en: '**Domain experts**: Those who have a deep and intimate understanding of the
    domain. Domain experts are **subject-matter experts** (**SMEs**) who have a very
    strong grasp of the business. Domain experts may have varying degrees of expertise.
    Some SMEs may choose to specialize in specific subdomains, while others may have
    a broader understanding of how the overall business works.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域专家**：那些对领域有深入和亲密理解的人。领域专家是**领域专家**（SMEs），他们对业务有非常强的掌握。领域专家可能具有不同程度的专长。一些SMEs可能选择在特定子领域专业化，而其他人可能对整个业务如何运作有更广泛的理解。'
- en: '**Technical experts**: On the other hand, enjoy solving specific, quantifiable
    computer science problems. Often, technical experts do not feel it is worth their
    while to understand the context of the business they work in. Rather, they seem
    overly eager to only enhance their technical skills that are a continuation of
    their learnings in academia.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术专家**：另一方面，喜欢解决具体、可量化的计算机科学问题。通常，技术专家并不觉得了解他们所在业务的环境值得他们投入精力。相反，他们似乎过于渴望只提升他们在学术界学习延续的技术技能。'
- en: While the domain experts specify the *why* and the *what*, technical experts
    (software engineers) largely help realize the *how*. Strong collaboration and
    synergy between both groups are essential to ensure sustained high performance
    and success.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当领域专家指定“为什么”和“是什么”时，技术专家（软件工程师）主要帮助实现“如何”。两组之间的强大合作和协同作用对于确保持续的高性能和成功至关重要。
- en: A divide originating in language
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自语言的分歧
- en: 'While strong collaboration between these groups is necessary, it is important
    to appreciate that these groups of people seem to have distinct motivations and
    differences in thinking. Seemingly, this may appear to be restricted to simple
    things such as differences in their day-to-day language. However, deeper analysis
    usually reveals a much larger divide in aspects such as goals and motivations.
    This is illustrated in the figure here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些团队之间的紧密合作是必要的，但重要的是要认识到，这些人似乎有截然不同的动机和思维方式。表面上，这似乎仅限于他们日常语言中的差异。然而，更深入的分析通常揭示出在目标、动机等方面存在更大的分歧。这一点在本图中有体现：
- en: '![Figure 1.15 – Divide originating in language'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.15 – 语言起源的划分'
- en: '](img/B16716_Figure_1.15.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_1.15.jpg)'
- en: Figure 1.15 – Divide originating in language
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 语言起源的划分
- en: But this is a book primarily focused on technical experts. Our point is that
    it is not possible to be successful by just working on technically challenging
    problems without gaining a sound understanding of the underlying business context.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但这本书主要关注技术专家。我们的观点是，仅仅通过解决技术难题而不对基础商业环境有深入理解，是不可能取得成功的。
- en: Every decision we take regarding the organization, be it requirements, architecture,
    or code, has business and user consequences. In order to conceive, architect,
    design, build and evolve software effectively, our decisions need to aid in creating
    the optimal business impact. As mentioned, this can only be achieved if we have
    a clear understanding of the problem we intend to solve. This leads us to the
    realization that there exist two distinct *domains* when arriving at the solution
    for a problem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对组织的每一个决策，无论是需求、架构还是代码，都会产生商业和用户后果。为了有效地构思、设计、构建和演进软件，我们的决策需要帮助创造最佳的商业影响。正如之前提到的，这只能在我们对要解决的问题有清晰理解的情况下实现。这使我们认识到，在解决问题的解决方案中存在两个截然不同的*域*。
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The use of the word domain in this context is done so in an abstract sense—not
    to be confused with the concept of the business domain introduced earlier.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，使用“域”一词是抽象意义上的，不要与之前介绍的商业域概念混淆。
- en: Problem domain
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题域
- en: This is a term that is used to capture information that simply defines the problem
    while consciously avoiding any details of the solution. It includes details such
    as *why* we are trying to solve the problem, *what* we are trying to achieve,
    and *how* it needs to be solved. It is important to note that the *why*, *what*,
    and *how* are from the perspective of the customers/stakeholders, not from the
    perspective of the engineers providing software solutions to the problem.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个术语，用于捕捉仅定义问题而有意避免任何解决方案细节的信息。它包括诸如*为什么*我们试图解决问题、*我们试图实现什么*以及*如何解决*等细节。重要的是要注意，*为什么*、*是什么*和*如何*是从客户/利益相关者的角度出发，而不是从提供软件解决方案的工程师的角度出发。
- en: 'Consider the example of a retail bank that already provides a checking account
    capability for their customers. They want access to more liquid funds. They need
    to encourage customers to maintain higher account balances to achieve that. They
    are looking to introduce a new product called the *premium checking account* with
    additional features such as higher interest rates, overdraft protection, and no-charge
    ATM access. The problem domain expressed in the form of why, what, and how is
    shown here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个零售银行的例子，该银行已经为其客户提供支票账户功能。他们希望获得更多流动资金。他们需要鼓励客户保持更高的账户余额来实现这一点。他们正在寻求推出一个名为*高级支票账户*的新产品，该产品具有更高的利率、透支保护和免费ATM访问等附加功能。以下是以*为什么*、*是什么*和*如何*的形式表达的问题域：
- en: '![Table 1.2 – Problem domain: why, what, and how'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 1.2 – 问题域：为什么、是什么以及如何'
- en: '](img/B16716_01_Table_02.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_01_Table_02.jpg)'
- en: 'Table 1.2 – Problem domain: why, what, and how'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.2 – 问题域：为什么、是什么以及如何
- en: Now that we have defined the problem and the motivations surrounding it, let’s
    examine how it can inform the solution.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了问题和与之相关的动机，让我们来看看它如何能指导解决方案。
- en: Solution domain
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案域
- en: A term used to describe the environment in which the solution is developed.
    In other words, the process of translating requirements into working software
    (this includes design, development, testing, and deployment). Here, the emphasis
    is on the *how* of the problem being solved from a software implementation perspective.
    However, it is very difficult to arrive at a solution without having an appreciation
    of the why and the what.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 术语，用于描述解决方案开发的环境。换句话说，将需求转化为工作软件的过程（这包括设计、开发、测试和部署）。在这里，重点是如何从软件实现的角度解决被解决的问题。然而，如果没有对“为什么”和“是什么”的理解，很难找到解决方案。
- en: 'Building on the previous premium checking account example, the code-level solution
    for this problem may look something like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在之前的优质支票账户示例之上，这个问题的代码级解决方案可能看起来像这样：
- en: '![](img/ch1-1.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ch1-1.jpg)'
- en: This likely appears like a significant leap from a problem domain description,
    and indeed it is. Before a solution like this can be arrived at, there may need
    to exist multiple levels of refinement of the problem. This process of refinement
    is usually messy and may lead to inaccuracies in the understanding of the problem,
    resulting in a solution that may be good (for example, one that is sound from
    an engineering, software architecture standpoint) but not one that solves the
    problem at hand. Let’s look at how we can continuously refine our understanding
    by closing the problem and solution domain gap.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是从问题域描述到问题的一个重大飞跃，确实如此。在达到这样的解决方案之前，可能需要存在多个级别的问题细化。这个过程通常是混乱的，可能会导致对问题的理解不准确，从而导致一个可能很好（例如，从工程、软件架构的角度来看是合理的）但不是解决当前问题的解决方案。让我们看看我们如何通过缩小问题和解决方案域之间的差距来不断细化我们的理解。
- en: Promoting a shared understanding using a ubiquitous language
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用通用语言促进共同理解
- en: Previously, we saw how organizational silos could result in valuable information
    getting diluted. At a credit card company I used to work with, the words plastic,
    payment instrument, account, **PAN** (**Primary Account Number**), **BIN** (**Bank
    Identification Number**), and card were all used by different team members to
    mean the exact same thing—the *credit card*—when working in the same area of the
    application. On the other hand, a term such as *user* would be used to sometimes
    mean a customer, a relationship manager, or a technical customer support employee.
    To make matters worse, a lot of these muddled use of terms got implemented in
    code as well. While this might feel like a trivial thing, it had far-reaching
    consequences. Product experts, architects, and developers all came and went, each
    regressively contributing to more confusion, muddled designs, implementation,
    and technical debt with every new enhancement—accelerating the journey toward
    the dreaded, unmaintainable big ball of mud ([http://www.laputan.org/mud/](http://www.laputan.org/mud/)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们看到了组织壁垒如何导致有价值的信息被稀释。在我曾经工作的一家信用卡公司，塑料、支付工具、账户、**PAN**（**主要账户号码**）、**BIN**（**银行识别号码**）和卡片这些词都被不同的团队成员用来指代同一个东西——**信用卡**——当他们在应用的同区域内工作时。另一方面，像*用户*这样的术语有时会被用来指代客户、关系经理或技术客户支持员工。更糟糕的是，很多这些混乱的术语也被应用到代码中。虽然这可能看起来是一件微不足道的事情，但它有着深远的影响。产品专家、架构师和开发者来了又去，每个人都逐渐增加了更多的混乱、混乱的设计、实施和技术债务，加速了走向令人恐惧的、难以维护的大泥球（[http://www.laputan.org/mud/](http://www.laputan.org/mud/)）的过程。
- en: 'DDD advocates breaking down these artificial barriers and putting the domain
    experts and the developers on the same level footing by working collaboratively
    toward creating what DDD calls a *ubiquitous language*—a shared vocabulary of
    terms, words, and phrases to continuously enhance the collective understanding
    of the entire team. This phraseology is then used actively in every aspect of
    the solution: the everyday vocabulary, the designs, the code—in short, by *everyone*
    and *everywhere*. Consistent use of the common, ubiquitous language helps reinforce
    a shared understanding and produce solutions that better reflect the mental model
    of the domain experts.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: DDD倡导打破这些人为的障碍，通过共同努力创建DDD所说的*通用语言*——一个共享的术语、单词和短语词汇，以不断增进整个团队的理解。这种说法随后被积极用于解决方案的各个方面：日常词汇、设计、代码——简而言之，由*每个人*和*每个地方*使用。一致地使用这种常见的通用语言有助于加强共同的理解，并产生更好地反映领域专家心智模型的解决方案。
- en: Evolving a domain model and a solution
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领域模型和解决方案的演变
- en: 'The ubiquitous language helps establish a consistent, albeit informal, lingo
    among team members. To enhance understanding, this can be further refined into
    a formal set of abstractions—a *domain model* to represent the solution in software.
    When a problem is presented to us, we subconsciously attempt to form mental representations
    of potential solutions. Furthermore, the type and nature of these representations
    (models) may differ wildly based on factors such as our understanding of the problem,
    our backgrounds, and experiences. This implies that it is natural for these models
    to be different. For example, the same problem can be thought of differently by
    various team members, as shown here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通用语言有助于在团队成员之间建立一致、尽管是非正式的术语。为了提高理解，这可以进一步细化为一套正式的抽象——一个*领域模型*，用于在软件中表示解决方案。当我们面临问题时，我们无意识地试图形成潜在解决方案的心理表征。此外，这些表征（模型）的类型和性质可能因我们的问题理解、背景和经验等因素而大相径庭。这意味着这些模型的不同是自然的。例如，同一问题可能由不同的团队成员以不同的方式思考，如下所示：
- en: '![Figure 1.16 – Multiple models to represent the solution'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.16 – 多个模型表示解决方案'
- en: '](img/B16716_Figure_1.16.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_1.16.jpg)'
- en: Figure 1.16 – Multiple models to represent the solution
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16 – 多个模型表示解决方案
- en: As illustrated here, the business expert may think of a process model, whereas
    the test engineer may think of exceptions and boundary conditions to arrive at
    a test strategy and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，业务专家可能会考虑流程模型，而测试工程师可能会考虑异常和边界条件，以制定测试策略等。
- en: Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: '*Figure 1.16* depicts the existence of multiple models. There may be several
    other perspectives, for example, a customer experience model and an information
    security model, which are not depicted.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.16* 描述了多个模型的存在。可能还有其他视角，例如客户体验模型和信息安全模型，这些并未在图中展示。'
- en: Care should be taken to retain focus on solving the business problem at hand
    at all times. Teams will be better served if they expend the same amount of effort
    modeling business logic as the technical aspects of the solution. To keep accidental
    complexity in check, it will be best to isolate the infrastructure aspects of
    the solution from this model. These models can take several forms, including conversations,
    whiteboard sessions, documentation, diagrams, tests, and other forms of architecture
    fitness functions. It is also important to note that this is *not* a one-time
    activity. As the business evolves, the domain model and the solution will need
    to keep up. This can only be achieved through close collaboration between the
    domain experts and the developers at all times.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 应当始终注意专注于解决当前的业务问题。如果团队在建模业务逻辑和技术解决方案方面投入相同数量的努力，那么他们将得到更好的服务。为了控制偶然的复杂性，最好将解决方案的基础设施方面与该模型隔离开来。这些模型可以采取多种形式，包括对话、白板会议、文档、图表、测试以及其他形式的架构健康函数。还应注意，这**不是**一次性的活动。随着业务的演变，领域模型和解决方案需要保持同步。这只能通过领域专家和开发者之间的紧密合作来实现。
- en: Scope of domain models and the bounded context
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领域模型和边界上下文的范围
- en: When creating domain models, one of the dilemmas is in deciding how to restrict
    the scope of these models. You can attempt to create a single domain model that
    acts as a solution for the entire problem. On the other hand, we may go the route
    of creating extremely fine-grained models that cannot exist meaningfully without
    having a strong dependency on others. There are pros and cons in going each way.
    Whatever be the case, each solution has a scope—bounds to which it is confined.
    This boundary is termed a **bounded context**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建领域模型时，一个常见的困境在于决定如何限制这些模型的范围。你可以尝试创建一个单一的领域模型，作为整个问题的解决方案。另一方面，我们可能选择创建极其细粒度的模型，这些模型在没有对其他模型有强烈依赖的情况下无法有意义地存在。每种方法都有其优缺点。无论情况如何，每个解决方案都有一个范围——它被限制在一定的边界内。这个边界被称为**边界上下文**。
- en: 'There seems to exist a lot of confusion between the terms subdomains and bounded
    contexts. What is the difference? It turns out that subdomains are problem space
    concepts, whereas bounded contexts are solution space concepts. This is best explained
    through the use of an example. Let’s consider the example of a fictitious Acme
    bank that provides two products: credit cards and retail bank. This may decompose
    to the following subdomains depicted here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在子域和有界上下文这两个术语之间似乎存在很多混淆。它们之间的区别是什么？结果是，子域是问题空间的概念，而有界上下文是解决方案空间的概念。这最好通过一个例子来解释。让我们考虑一个虚构的Acme银行，它提供两种产品：信用卡和零售银行。这可能分解为以下子域，如图所示：
- en: '![Figure 1.17 – Banking subdomains at Acme bank'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.17 – Acme银行的银行子域](img/B16716_Figure_1.17.jpg)'
- en: '](img/B16716_Figure_1.17.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_1.17.jpg)'
- en: Figure 1.17 – Banking subdomains at Acme bank
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17 – Acme银行的银行子域
- en: 'When creating a solution for the problem, many possible solution options exist.
    We have depicted a few options here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在为问题创建解决方案时，存在许多可能的解决方案选项。我们在这里展示了一些选项：
- en: '![Figure 1.18 – Bounded context options at Acme bank'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.18 – Acme银行的有界上下文选项](img/B16716_Figure_1.18.jpg)'
- en: '](img/B16716_Figure_1.18.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_1.18.jpg)'
- en: Figure 1.18 – Bounded context options at Acme bank
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18 – Acme银行的有界上下文选项
- en: 'These are just a few examples of decomposition patterns to create bounded contexts.
    The exact set of patterns you may choose to use may vary depending on currently
    prevailing realities, such as the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是创建有界上下文的分解模式的几个示例。你可能会选择的特定模式集合可能因当前的现实情况而异，例如以下情况：
- en: Current organizational structures
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前组织结构
- en: Domain experts’ responsibilities
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域专家的职责
- en: Key activities and pivotal events
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键活动和关键事件
- en: Existing applications
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有应用程序
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: '**Conway’s law** asserts that organizations are constrained to produce application
    designs that are copies of their communication structures. Your current organizational
    structures may not be optimally aligned to your desired solution approach. The
    inverse Conway maneuver may be applied to achieve isomorphism with the business
    architecture. Whatever the method used to decompose a problem into a set of bounded
    contexts, care should be taken to make sure that the coupling between them is
    kept as low as possible.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**康威定律**断言，组织被限制在产生与其沟通结构相复制的应用设计。你当前的组织结构可能并不最优地与你的期望解决方案方法对齐。逆向康威机动可能被应用以达到与业务架构的同构。无论使用何种方法将问题分解为一系列有界上下文，都应小心确保它们之间的耦合尽可能低。'
- en: 'While bounded contexts ideally need to be as independent as possible, they
    may still need to communicate with each other. When using DDD, the system as a
    whole can be represented as a set of bounded contexts that have relationships
    with each other. These relationships define how these bounded contexts can integrate
    with each other and are called **context maps**. A sample context map is shown
    here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有界上下文理想上需要尽可能独立，但它们仍然可能需要相互通信。当使用DDD时，整个系统可以表示为一组相互关联的有界上下文。这些关系定义了这些有界上下文如何相互集成，并被称为**上下文图**。这里展示了一个示例上下文图：
- en: '![Figure 1.19 – Sample context map for Acme bank'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.19 – Acme银行的示例上下文图](img/B16716_Figure_1.19.jpg)'
- en: '](img/B16716_Figure_1.19.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16716_Figure_1.19.jpg)'
- en: Figure 1.19 – Sample context map for Acme bank
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.19 – Acme银行的示例上下文图
- en: The context map shows the bounded contexts and the relationship between them.
    These relationships can be a lot more nuanced than what is depicted here. We will
    discuss context maps and communication patterns in *Chapter 9*, *Integrating with
    External Systems*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文图显示了有界上下文及其之间的关系。这些关系可能比这里展示的更为复杂。我们将在第9章“与外部系统集成”中讨论上下文图和通信模式。
- en: We have now covered a catalog of concepts that are core to the strategic design
    tenets of DDD. Let’s look at some tools that can help expedite this process.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了一系列对领域驱动设计（DDD）战略设计原则至关重要的概念。让我们看看一些可以帮助加速这一过程的工具。
- en: In subsequent chapters, we will reinforce all the concepts introduced here in
    a lot more detail.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的章节中，我们将更详细地巩固这里介绍的所有概念。
- en: In the next section, we will look at why the ideas of DDD, introduced all those
    years ago, are still very relevant. We will see why, if anything, they are becoming
    even more relevant now than ever.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨为什么那些多年前引入的领域驱动设计（DDD）理念至今仍然非常相关。我们将看到，如果有什么不同的话，它们现在甚至比以往任何时候都更加相关。
- en: Implementing the solution using tactical design
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用战术设计实施解决方案
- en: In the previous section, we saw how we can arrive at a shared understanding
    of the problem using strategic design tools. We need to use this understanding
    to create a solution. DDD’s tactical design aspects, tools, and techniques help
    translate this understanding into working software. Let’s look at these aspects
    in detail. In *Part 2* of the book, we will apply these to solve a real-world
    problem.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用战略设计工具达成对问题的共同理解。我们需要利用这种理解来创建解决方案。DDD 的战术设计方面、工具和技术帮助将这种理解转化为可工作的软件。让我们详细看看这些方面。在本书的*第
    2 部分*中，我们将将其应用于解决一个现实世界的问题。
- en: 'It is convenient to think of the tactical design aspects, as depicted in this
    figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将战术设计方面考虑进去，如图所示：
- en: '![Figure 1.20 – The elements of DDD’s tactical design'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.20 – DDD 战术设计的元素'
- en: '](img/B16716_Figure_1.20.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16716_Figure_1.20.jpg]'
- en: Figure 1.20 – The elements of DDD’s tactical design
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – DDD 战术设计的元素
- en: Let’s look at the definitions of these elements.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些元素的定义。
- en: Value objects
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值对象
- en: 'Value objects are immutable objects that encapsulate the data and behavior
    of one or more related attributes. It may be convenient to think of value objects
    as named primitives. For example, consider a `MonetaryAmount` value object. A
    simple implementation can contain two attributes—an amount and a currency code.
    This allows encapsulation of behavior, such as adding two `MonetaryAmount` objects
    safely, as shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象是不可变对象，封装了一个或多个相关属性的*数据和行为*。可以方便地将值对象视为命名的原始数据类型。例如，考虑一个`MonetaryAmount`值对象。一个简单的实现可以包含两个属性——金额和货币代码。这允许封装行为，例如安全地添加两个`MonetaryAmount`对象，如下所示：
- en: '![Figure 1.21 – A simple MonetaryAmount value object'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.21 – 简单的 MonetaryAmount 值对象'
- en: '](img/B16716_Figure_1.21.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16716_Figure_1.21.jpg]'
- en: Figure 1.21 – A simple MonetaryAmount value object
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21 – 简单的 MonetaryAmount 值对象
- en: The effective use of value objects helps protect from the primitive obsession
    with anti-patterns while increasing clarity. It also allows composing higher-level
    abstractions using one or more valuable objects. It is important to note that
    value objects do not have the notion of identity. That is, two values with the
    same value are treated equally. So, two `MonetaryAmount` objects with the same
    amount and currency code will be considered equal. Also, it is important to make
    value objects immutable. A need to change any of the attributes should result
    in the creation of a new attribute.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地使用值对象有助于防止对反模式的原始执着，同时增加清晰度。它还允许使用一个或多个值对象来组合更高层次的抽象。需要注意的是，值对象没有身份的概念。也就是说，具有相同值的两个值被视为相等。因此，两个具有相同金额和货币代码的`MonetaryAmount`对象将被视为相等。此外，重要的是要使值对象不可变。如果需要更改任何属性，应导致创建一个新的属性。
- en: It is easy to dismiss value objects as a mere engineering technique, but the
    consequences of (not) using them can be far-reaching. In the `MonetaryAmount`
    example, it is possible for the *amount* and *currency code* to exist as independent
    attributes. However, the use of `MonetaryAmount` enforces the notion of the *ubiquitous
    language*. Hence, we recommend the use of value objects as a default instead of
    using primitives.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 容易将值对象视为一种简单的工程技术，但（不）使用它们的后果可能非常深远。在`MonetaryAmount`示例中，金额和货币代码可以独立作为属性存在。然而，使用`MonetaryAmount`强制了*通用语言*的概念。因此，我们建议将值对象作为默认选项，而不是使用原始数据类型。
- en: Critics may be quick to point out problems such as class explosion and performance
    issues. But in our experience, the benefits usually outweigh the costs. But it
    may be necessary to re-examine this approach if problems occur.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 批评者可能会迅速指出诸如类爆炸和性能问题等问题。但根据我们的经验，好处通常大于成本。但如果出现问题，可能需要重新审视这种方法。
- en: Entities
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体
- en: 'An entity is an object with a *unique identity* and *encapsulates* the data
    and behavior of its attributes. It may be convenient to view entities as a collection
    of other entities and value objects that need to be grouped together. A very simple
    example of an entity is shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实体是一个具有*唯一标识*的对象，并封装了其属性的*数据和行为*。可能将实体视为需要组合在一起的其它实体和值对象的集合。这里展示了一个非常简单的实体示例：
- en: '![Figure 1.22 – A simple depiction of a Transaction entity'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.22 – 交易实体的简单表示'
- en: '](img/B16716_Figure_1.22.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16716_Figure_1.22.jpg]'
- en: Figure 1.22 – A simple depiction of a Transaction entity
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22 – 交易实体的简单表示
- en: In contrast to a value object, entities have the notion of a unique identifier.
    This means that two `Transaction` entities with the same underlying values but
    a different **identifier** (**id**) value will be considered different. On the
    other hand, two entity instances with the same value for the identifier are considered
    equal. Furthermore, unlike value objects, entities are mutable. That is, their
    attributes can and will change over time.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与值对象不同，实体具有唯一标识符的概念。这意味着两个具有相同基础值但不同**标识符**（**id**）值的`Transaction`实体将被视为不同。另一方面，具有相同标识符值的两个实体实例被视为相等。此外，与值对象不同，实体是可变的。也就是说，它们的属性可以并且会随时间变化。
- en: The concept of value objects and entities depends on the context within which
    they are used. In an order management system, the *address* may be implemented
    as a value object in the *e-commerce* bounded context, whereas it may be needed
    to be implemented as an entity in the *order fulfillment* bounded context.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象和实体的概念取决于它们被使用的上下文。在一个订单管理系统内，*地址*可能在*电子商务*边界上下文中实现为一个值对象，而在*订单履行*边界上下文中可能需要实现为一个实体。
- en: Important Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is common to collectively refer to entities and value objects as *domain
    objects*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将实体和值对象统称为*领域对象*。
- en: Aggregates
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合
- en: 'As seen previously, entities are hierarchical in that they can be composed
    of one more child. Fundamentally, an aggregate has the following qualities:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，实体是分层的，因为它们可以由一个或多个子实体组成。本质上，聚合具有以下特性：
- en: Is an entity usually composed of other child entities and value objects
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体通常由其他子实体和值对象组成
- en: Encapsulates access to child entities by exposing behavior (usually referred
    to as *commands**)*
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过暴露行为（通常称为*命令*）来封装对子实体的访问
- en: Is a boundary that is used to enforce business invariants (rules) consistently
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是一个用于一致性地强制执行业务不变性（规则）的边界
- en: Is an entry point to get things done within a bounded context
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是在边界上下文中完成工作的入口点
- en: 'Consider the example of a `CheckingAccount` aggregate:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`CheckingAccount`聚合的例子：
- en: '![Figure 1.23 – A simple depiction of a CheckingAccount aggregate'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.23 – CheckingAccount聚合的简单表示](img/B16716_Figure_1.23.jpg)'
- en: '](img/B16716_Figure_1.23.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.23 – CheckingAccount聚合的简单表示](img/B16716_Figure_1.23.jpg)'
- en: Figure 1.23 – A simple depiction of a CheckingAccount aggregate
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.23 – CheckingAccount聚合的简单表示
- en: 'Note how `CheckingAccount` is composed of the `AccountHolder` and `Transaction`
    entities, among other things. In this example, let’s assume that the overdraft
    feature (ability to hold a negative account balance) is only available for `currentBalance`
    needs to occur in the form of a unique `Transaction` for audit purposes—irrespective
    of its outcome. For this reason, the `CheckingAccount` aggregate makes use of
    the `Transaction` entity. Although `Transaction` has `approve` and `reject` methods
    as part of its interface, only the aggregate has access to these methods. In this
    way, the aggregate enforces the business invariant while maintaining high levels
    of encapsulation. A potential implementation of the `tryWithdraw` method is shown
    here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`CheckingAccount`是如何由`AccountHolder`和`Transaction`实体以及其他事物组成的。在这个例子中，让我们假设透支功能（保持负账户余额的能力）仅适用于`currentBalance`需要以唯一的`Transaction`形式出现——无论其结果如何。因此，`CheckingAccount`聚合使用`Transaction`实体。尽管`Transaction`具有作为其接口一部分的`approve`和`reject`方法，但只有聚合可以访问这些方法。通过这种方式，聚合强制执行业务不变性，同时保持高度的封装。`tryWithdraw`方法的一个潜在实现如下所示：
- en: '![](img/ch1-2.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2](img/ch1-2.jpg)'
- en: The `CheckingAccount` aggregate is composed of child entities and value objects.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CheckingAccount`聚合由子实体和值对象组成。'
- en: The `tryWithdraw` method acts as a consistency boundary for the operation. Irrespective
    of the outcome (approved or rejected), the system will remain in a consistent
    state. In other words, the `currentBalance` can change only within the confines
    of the `CheckingAccount` aggregate.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tryWithdraw`方法充当操作的连续性边界。无论结果如何（批准或拒绝），系统都将保持一致状态。换句话说，`currentBalance`只能在`CheckingAccount`聚合的范围内变化。'
- en: The aggregate enforces the appropriate business invariant (rule) to allow overdrafts
    only for HNIs.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合强制执行适当的业务不变性（规则），仅允许HNIs透支。
- en: Important Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Aggregates are also referred to as aggregate roots, that is, the object that
    is at the root of the entity hierarchy. We use these terms synonymously in this
    book.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合也被称为聚合根，即实体层次结构中的根对象。在这本书中，我们使用这些术语同义。
- en: Domain events
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领域事件
- en: As mentioned previously, aggregates dictate how and when state changes occur.
    Other parts of the system may be interested in knowing about the occurrence of
    changes that are significant to the business, for example, an order is placed
    or payment is received. *Domain events* are the means to convey that something
    significant to the business has occurred. It is important to differentiate between
    system events and domain events. For example, in the context of a retail bank,
    a *row was saved* in the database or a *server ran out of disk space* may classify
    as system events, whereas a *deposit was made* to a checking account and *fraudulent
    activity was detected* on a transaction could be classified as domain events.
    In other words, domain events are things that *domain experts care about*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，聚合体决定了状态变化何时以及如何发生。系统的其他部分可能对了解对业务有重要意义的变更感兴趣，例如，下订单或收到付款。*领域事件*是传达对业务有重要意义的变更的手段。区分系统事件和领域事件很重要。例如，在零售银行的情况下，数据库中*行被保存*或*服务器磁盘空间不足*可能被归类为系统事件，而*存款到支票账户*和*交易中检测到欺诈活动*可能被归类为领域事件。换句话说，领域事件是*领域专家关心的事情*。
- en: It may be prudent to make use of domain events to reduce the amount of coupling
    between bounded contexts, making it a critical building block of DDD.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 可能明智的做法是利用领域事件来减少边界上下文之间的耦合，使其成为领域驱动设计（DDD）的一个关键构建块。
- en: Repositories
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仓储
- en: Most businesses require the durability of data. For this reason, the aggregate
    state needs to be persisted and retrieved when needed. Repositories are objects
    that enable persisting and loading *aggregate* instances. This is well documented
    in Martin Fowler’s *Patterns of Enterprise Application Architecture* book as part
    of the *repository* ([https://martinfowler.com/eaaCatalog/repository.html](https://martinfowler.com/eaaCatalog/repository.html))
    pattern. It is pertinent to note that we are referring to aggregate repositories
    here, not just any entity repository. The singular purpose of this repository
    is to load a *single instance* of an aggregate using its identifier. It is important
    to note that this repository does not support finding aggregate instances using
    any other means. This is because business operations happen as part of manipulating
    a single instance of the aggregate within its bounded context.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数业务都需要数据的持久性。因此，聚合体的状态需要在需要时持久化和检索。仓储是使聚合体实例能够持久化和加载的对象。这在马丁·福勒的《企业应用架构模式》一书中作为*仓储*（[https://martinfowler.com/eaaCatalog/repository.html](https://martinfowler.com/eaaCatalog/repository.html)）模式的一部分有很好的记录。值得注意的是，我们在这里指的是聚合仓储，而不仅仅是任何实体仓储。这个仓储的单一目的是使用其标识符加载聚合体的*单个实例*。需要注意的是，这个仓储不支持使用任何其他方式查找聚合体实例。这是因为业务操作是作为在边界上下文中操作聚合体的单个实例的一部分发生的。
- en: Factories
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂
- en: In order to work with aggregates and value objects, instances of these need
    to be constructed. In simple cases, it might suffice to use a constructor to do
    so. However, aggregate and value object instances can become quite complex depending
    on the amount of state they encapsulate. In such cases, it may be prudent to consider
    delegating object construction responsibilities to a *factory* external to the
    aggregate/value object. We make use of the static factory method, builder, and
    dependency injection quite commonly in our day-to-day work. Joshua Bloch discusses
    several variations of this pattern in [*Chapter 2*](B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037),
    *Where and How Does DDD Fit?*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与聚合体和值对象一起工作，需要构建这些实例。在简单的情况下，可能只需要使用构造函数来做到这一点。然而，根据封装的状态量，聚合体和值对象实例可能会变得相当复杂。在这种情况下，考虑将对象构建责任委托给聚合体/值对象外部的*工厂*可能是明智的。我们在日常工作中非常常用静态工厂方法、构建器和依赖注入。约书亚·布洛奇在[*第二章*](B16716_02_Final_NM_ePub.xhtml#_idTextAnchor037)，“DDD适合在哪里以及如何？”中讨论了这种模式的几种变体。
- en: Services
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: 'When working within the confines of a single bounded context, the public interface
    (commands) of the aggregate provides a natural API. However, more complex business
    operations may require interacting with multiple bounded contexts and aggregates.
    In other words, we may find ourselves in situations where certain business operations
    do not fit naturally with any single aggregate. Even if interactions are limited
    to a single bounded context, there may be a need to expose that functionality
    in an implementation-neutral manner. In such cases, you may consider the use of
    objects called *services*. Services come in at least three flavors:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一个单一的有界上下文中工作时，聚合的公共接口（命令）提供了一个自然的API。然而，更复杂的业务操作可能需要与多个有界上下文和聚合进行交互。换句话说，我们可能会发现自己处于某些业务操作与任何单个聚合都不自然匹配的情况。即使交互仅限于单一的有界上下文，也可能需要以实现无关的方式公开该功能。在这种情况下，您可以考虑使用称为*服务*的对象。服务至少有三种类型：
- en: '**Domain services**: To enable coordinating operations among more than one
    aggregate – for example, transferring money between two checking accounts at a
    retail bank.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域服务**：为了协调多个聚合之间的操作——例如，在零售银行之间转账两个支票账户。'
- en: '**Infrastructure services**: To enable interactions with a utility that is
    not core to the business – for example, logging and sending emails at the retail
    bank.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施服务**：为了与业务非核心的实用程序进行交互——例如，在零售银行进行日志记录和发送电子邮件。'
- en: '**Application services**: To enable coordination between domain services, infrastructure
    services, and other application services – for example, sending email notifications
    after a successful inter-account money transfer.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用服务**：为了协调领域服务、基础设施服务和其它应用服务之间的操作——例如，在成功完成账户间转账后发送电子邮件通知。'
- en: Services can also be stateful or stateless. It is best to allow aggregates to
    manage state, making use of repositories, while allowing services to coordinate
    and/or orchestrate business flows. In complex cases, there may be a need to manage
    the state of the flow itself. We will look at more concrete examples in *Part
    2* of this book.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 服务也可以是有状态的或无状态的。最好让聚合管理状态，利用存储库，同时允许服务协调和/或编排业务流程。在复杂情况下，可能需要管理流程本身的状态。我们将在本书的*第2部分*中查看更多具体的例子。
- en: It may become tempting to implement business logic almost exclusively using
    services—inadvertently leading to the anemic domain model anti-pattern ([https://martinfowler.com/bliki/AnemicDomainModel.html](https://martinfowler.com/bliki/AnemicDomainModel.html)).
    It is worthwhile striving to encapsulate business logic within the confines of
    aggregates as a default.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会诱使人们几乎完全使用服务来实现业务逻辑——无意中导致贫血领域模型反模式（[https://martinfowler.com/bliki/AnemicDomainModel.html](https://martinfowler.com/bliki/AnemicDomainModel.html)）。努力将业务逻辑封装在聚合的范围内作为默认做法是值得的。
- en: Why is DDD relevant? Why now?
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么DDD是相关的？为什么现在？
- en: He who has a why to live for can bear almost any how.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个为什么而活的人可以忍受几乎任何如何。
- en: — Friedrich Nietzsche
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ——弗里德里希·尼采
- en: In a lot of ways, DDD was way ahead of its time when Eric Evans introduced the
    concepts and principles back in 2003\. DDD seems to have gone from strength to
    strength. In this section, we will examine why DDD is even more relevant today
    than it was when Eric Evans wrote his book on the subject way back in 2003.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多方面，当埃里克·埃文斯在2003年引入这些概念和原则时，领域驱动设计（DDD）就已经远远领先于其时代。DDD似乎一直都在不断壮大。在本节中，我们将探讨为什么DDD在埃里克·埃文斯在2003年撰写关于该主题的书籍时就已经非常相关，而现在更是如此。
- en: Rise of open source
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源软件的兴起
- en: 'Eric Evans, during his keynote address at the Explore DDD conference in 2017,
    lamented how difficult it was to implement even the simplest concepts, such as
    immutability in value objects, when his book had released. In contrast, though,
    nowadays, it’s simply a matter of importing mature, well-documented, tested libraries,
    such as Project Lombok ([https://projectlombok.org/](https://projectlombok.org/))
    or Immutables ([https://immutables.github.io/](https://immutables.github.io/)),
    to be productive, literally in a matter of minutes. To say that open source software
    has revolutionized the software industry would be an understatement! At the time
    of writing, the public Maven repository ([https://mvnrepository.com](https://mvnrepository.com))
    indexes no less than a staggering **18.3 million artifacts** in a large assortment
    of popular categories ranging from databases and language runtimes to test frameworks,
    and many, many more, as shown in the following chart:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Eric Evans在2017年探索DDD会议的开幕式上，哀叹他的书发布后，即使是实现最简单的概念，如值对象的不变性，也是多么困难。然而，如今，这仅仅是一个导入成熟、文档齐全、经过测试的库的问题，例如Project
    Lombok（[https://projectlombok.org](https://projectlombok.org)）或Immutables（[https://immutables.github.io](https://immutables.github.io)），以在几分钟内变得高效。说开源软件彻底改变了软件行业，这还是低估了它！在撰写本文时，公共Maven仓库（[https://mvnrepository.com](https://mvnrepository.com)）索引了令人震惊的**1830万个工件**，涵盖了从数据库和语言运行时到测试框架等众多流行类别，如图所示：
- en: '![Figure 1.24 – Open source Java over the years (source: https://mvnrepository.com/)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.24 – 多年来开源Java的发展情况（来源：https://mvnrepository.com/)]'
- en: '](img/B16716_Figure_1.24.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.24 – 多年来开源Java的发展情况（来源：[https://mvnrepository.com/](https://mvnrepository.com/))]'
- en: 'Figure 1.24 – Open source Java over the years (source: [https://mvnrepository.com/](https://mvnrepository.com/))'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.24 – 多年来开源Java的发展情况（来源：[https://mvnrepository.com](https://mvnrepository.com/))
- en: Java stalwarts such as the Spring Framework and more recent innovations such
    as Spring Boot and Quarkus make it a no-brainer to create production-grade applications
    literally in a matter of minutes. Furthermore, frameworks such as Axon and Lagom,
    among others, make it relatively simple to implement advanced architecture patterns
    such are CQRS and event sourcing, which is very complementary to implementing
    DDD-based solutions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Java的常青树，如Spring框架，以及更近期的创新，如Spring Boot和Quarkus，使得在几分钟内就能创建出生产级别的应用程序变得易如反掌。此外，Axon和Lagom等框架使得实现高级架构模式，如CQRS和事件溯源，变得相对简单，这对于实现基于DDD的解决方案非常有益。
- en: Advances in technology
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术进步
- en: DDD by no means is just about technology; it could not be completely agnostic
    to the choices available at the time. 2003 was the heyday of heavyweight and ceremony-heavy
    frameworks, such as **Java 2 Enterprise Edition** (**J2EE**), **Enterprise JavaBeans**
    (**EJB**), SQL databases, and **object relational mappers** (**ORMs**)—with not
    much choice beyond that when it came to enterprise tools and patterns to build
    complex software, at least out in the public domain. The software world has evolved
    and come a very long way from there. In fact, modern game-changers such as Ruby
    on Rails and the public cloud were just getting released. In contrast, though,
    we now have no shortage of application frameworks, NoSQL databases, and programmatic
    APIs to create infrastructure components with a lot more releasing with monotonous
    regularity.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: DDD绝非仅仅是关于技术的；它不可能对当时可用的选择完全无动于衷。2003年是重量级和仪式感重的框架的鼎盛时期，例如**Java 2 Enterprise
    Edition**（**J2EE**）、**Enterprise JavaBeans**（**EJB**）、SQL数据库和**对象关系映射**（**ORMs**）——在公共领域，当涉及到构建复杂软件的企业工具和模式时，选择并不多。软件世界已经发展，并从那时起取得了很大的进步。事实上，现代的颠覆性技术，如Ruby
    on Rails和公共云，才刚刚发布。然而，相比之下，我们现在不缺少应用程序框架、NoSQL数据库和用于创建基础设施组件的程序化API，这些组件以单调的规律不断发布。
- en: All these innovations allow for rapid experimentation, continuous learning,
    and iteration at pace. These game-changing advances in technology have also coincided
    with the exponential rise of the internet and e-commerce as viable means to carry
    out successful businesses. In fact, the impact of the internet is so pervasive
    that it is almost inconceivable to launch businesses without a digital component
    being an integral component. Finally, the consumerization and wide-scale penetration
    of smartphones, IoT devices, and social media have meant that data is being produced
    at rates inconceivable as recent as a decade ago. This means that we are building
    for and solving the most complicated problems by several orders of magnitude.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些创新都允许快速实验、持续学习和快速迭代。这些改变游戏规则的技术进步也与互联网和电子商务作为成功开展业务的可行手段的指数级增长相吻合。事实上，互联网的影响如此广泛，以至于几乎无法想象没有数字组件作为核心组成部分来启动业务。最后，智能手机、物联网设备和社交媒体的消费者化和广泛渗透意味着数据的生产速度已经达到了十年前难以想象的程度。这意味着我们正在通过几个数量级来构建和解决最复杂的问题。
- en: Rise of distributed computing
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式计算的兴起
- en: There was a time when building large monoliths was very much the default. But
    an exponential rise in computing technology, the public cloud (IaaS, PaaS, SaaS,
    and FaaS), big data storage, and processing volumes, which has coincided with
    an arguable slowdown in the ability to continue creating faster CPUs, has meant
    a turn toward more decentralized methods of solving problems.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，构建大型单一实体是默认的做法。但计算技术的指数级增长、公共云（IaaS、PaaS、SaaS和FaaS）、大数据存储和处理量的增长，与继续创建更快CPU的能力的相对放缓相吻合，这意味着转向更多去中心化的解决问题方法。
- en: '![Figure 1.25 – Global information storage capacity'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.25 – 全球信息存储容量'
- en: '](img/B16716_Figure_1.25.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16716_Figure_1.25.jpg)'
- en: Figure 1.25 – Global information storage capacity
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.25 – 全球信息存储容量
- en: DDD, with its emphasis on dealing with complexity by breaking unwieldy monoliths
    into more manageable units in the form of subdomains and bounded contexts, fits
    naturally into this style of programming. Hence, it is no surprise to see a renewed
    interest in adopting DDD principles and techniques when crafting modern solutions.
    To quote Eric Evans, it is no surprise that DDD is even more relevant now than
    when it was originally conceived!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: DDD（领域驱动设计），通过将难以驾驭的单一实体分解为更易于管理的子域和边界上下文的形式来处理复杂性，自然地融入了这种编程风格。因此，当我们在构建现代解决方案时，对采用DDD原则和技术的兴趣重新焕发并不令人惊讶。正如埃里克·埃文斯所说，DDD现在比最初构想时更加相关！
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined some common reasons why software projects fail.
    We saw how inaccurate or misinterpreted requirements, architecture (or the lack
    thereof), and excessive technical debt can get in the way of meeting business
    goals and success.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了软件项目失败的一些常见原因。我们看到了不准确或误解的需求、架构（或缺乏架构）以及过度的技术债务是如何阻碍实现商业目标和成功的。
- en: We looked at the basic building blocks of DDD, such as domains, subdomains,
    ubiquitous language, domain models, bounded contexts, and context maps. We also
    examined why the principles and techniques of DDD are still very much relevant
    in the modern age of microservices and serverless. You should now be able to appreciate
    the basic terms of DDD and understand why it is important in today’s context.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了DDD的基本构建块，如领域、子域、通用语言、领域模型、边界上下文和上下文图。我们还考察了为什么DDD的原则和技术在现代微服务和无服务器时代仍然非常相关。你现在应该能够欣赏DDD的基本术语，并理解为什么它在当今的背景下很重要。
- en: In the next chapter, we will take a closer look at the real-world mechanics
    of DDD. We will delve deeper into the strategic and tactical design elements of
    DDD and look at how using these can help form the basis for better communication
    and create more robust designs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨DDD的实际运作机制。我们将深入研究DDD的战略和战术设计元素，并探讨如何使用这些元素来帮助形成更好的沟通和更稳健的设计基础。
- en: Further reading
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '![](img/B16716_01_Table_03a.jpg)![](img/B16716_01_Table_03b.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B16716_01_Table_03a.jpg)![图片](img/B16716_01_Table_03b.jpg)'
