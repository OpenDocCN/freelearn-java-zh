- en: Adding Service Discovery Using Netflix Eureka and Ribbon
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Netflix Eureka和Ribbon添加服务发现
- en: In this chapter, we will learn how to use Netflix Eureka as a discovery server
    for microservices based on Spring Boot. To allow our microservices to communicate
    with Netflix Eureka, we will use the Spring Cloud module for Netflix Eureka clients.
    Before we delve into the details, we will elaborate on why a discovery server
    is needed and why a DNS server isn't sufficient.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Netflix Eureka作为基于Spring Boot的微服务的发现服务器。为了使我们的微服务能够与Netflix Eureka通信，我们将使用Netflix
    Eureka客户端的Spring Cloud模块。在深入细节之前，我们将详细介绍为什么需要发现服务器以及为什么DNS服务器是不够的。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to service discovery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现简介
- en: The problem with DNS-based service discovery
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS基于的服务发现的问题
- en: Challenges with service discovery
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现面临的挑战
- en: Service discovery with Netflix Eureka in Spring Cloud
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Netflix Eureka在Spring Cloud中的服务发现
- en: Setting up a Netflix Eureka server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Netflix Eureka服务器
- en: Connecting microservices to a Netflix Eureka server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将微服务连接到Netflix Eureka服务器
- en: Setting up configuration for use in the development process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为开发过程设置配置
- en: Trying out the discovery service
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试服务发现服务
- en: Introducing service discovery
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍服务发现
- en: 'The concept of service discovery was described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*; please refer to the *Service discovery* section for
    more information. Netflix Eureka was introduced as a discovery service in [Chapter
    8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml), *Introduction to Spring Cloud*;
    please refer to the *Netflix Eureka as a discovery service* section for more information.
    Before we jump into the implementation details, we will look at the following
    topics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章*微服务简介*中描述了服务发现的概念；请参阅*服务发现*部分以获取更多信息。在第8章*Spring Cloud简介*中介绍了Netflix Eureka作为发现服务；请参阅*Netflix
    Eureka作为发现服务*部分以获取更多信息。在深入了解实现细节之前，我们将讨论以下主题：
- en: The problem with DNS-based service discovery
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS基于的服务发现的问题
- en: Challenges with service discovery
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现面临的挑战
- en: Service discovery with Netflix Eureka in Spring Cloud
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Netflix Eureka在Spring Cloud中的服务发现
- en: The problem with DNS-based service discovery
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS基于的服务发现的问题
- en: So, what's the problem?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题是什么？
- en: Why can't we simply start new instances of a microservice and rely on round-robin
    DNS? In essence, given that the microservice instances have the same DNS name,
    the DNS server will resolve it to a list of IP addresses for the available instances.
    Due to this, the client can call the service instances in a round-robin fashion.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不能简单地启动微服务的新实例，并依赖轮询DNS呢？本质上，由于微服务实例具有相同的DNS名称，DNS服务器将解析为可用实例的IP地址列表。因此，客户端可以以轮询方式调用服务实例。
- en: 'Let''s try it out and see what happens, shall we? Follow these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看会发生什么，好吗？请按照以下步骤操作：
- en: 'Assuming that you have followed the instructions from [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml),
    *Developing Reactive Microservices*, start the system landscape and insert some
    test data with the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你已经按照第7章*开发反应式微服务*的说明操作，使用以下命令启动系统架构并向其中插入一些测试数据：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Scale up the `review` microservice to two instances:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`review`微服务扩展到两个实例：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Ask the composite product service for the IP addresses it finds for the `review`
    microservice:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问复合产品服务为`review`微服务找到的IP地址：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Expect an answer like the following:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期待如下回答：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Great, the composite product service sees two IP addresses—in my case, `172.19.0.8`
    and `172.19.0.9`—one for each instance of the `review` microservice instances!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，复合产品服务看到了两个IP地址——在我的情况下，`172.19.0.8`和`172.19.0.9`——分别为`review`微服务的每个实例！
- en: 'If you want to, you can verify that these are the correct IP addresses by using
    the following commands:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想验证这些确实是正确的IP地址，可以使用以下命令：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last line in the output from each command should contain one of the IP addresses,
    as shown in the preceding code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令的输出最后一行应包含一个IP地址，如前所示。
- en: 'Now, let''s try out a couple of calls to the composite product service and
    see whether it uses both instances of the `review` microservice:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试对复合产品服务进行几次调用，看看它是否使用了`review`微服务的两个实例：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Unfortunately, we will only get responses from one of the microservice instances,
    as in this example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们只能从其中一个微服务实例获得响应，如这个例子所示：
- en: '![](img/70f0682d-4f5b-4fae-a1a0-d96ea3c3c254.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70f0682d-4f5b-4fae-a1a0-d96ea3c3c254.png)'
- en: That was disappointing!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那真是令人失望！
- en: Okay, so what is going on here?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里发生了什么事？
- en: A DNS client typically caches the resolved IP addresses and hangs on to the
    first working IP address it tries out when it receives a list of IP addresses
    that have been resolved for a DNS name. Neither the DNS servers nor the DNS protocol
    is well-suited for handling volatile microservices instances that come and go
    all of the time. Because of this, DNS-based service discovery isn't very appealing
    from a practical standpoint.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个DNS客户端通常缓存已解析的IP地址，并在收到已为DNS名称解析的IP地址列表时，保留它尝试的第一个有效IP地址。DNS服务器或DNS协议都不适合处理时而出现时而消失的微服务实例。因此，基于DNS的服务发现从实际角度来看并不很有吸引力。
- en: Using Spring Cloud Config for centralized configuration
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Config进行集中配置
- en: To manage the configuration of a system landscape of microservices, Spring Cloud
    contains Spring Cloud Config, which provides the centralized management of configuration
    files according to the requirements described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*, in the *Central configuration* section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理微服务系统架构的配置，Spring Cloud包含Spring Cloud Config，它根据第1章中描述的要求，提供集中管理配置文件的功能，该章节为*微服务介绍*中的*集中配置*部分。
- en: 'Spring Cloud Config supports storing configuration files in a number of different
    backends, such as the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config支持将配置文件存储在多种不同的后端中，例如以下后端：
- en: A Git repository, for example, on GitHub or Bitbucket
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Git仓库，例如，在GitHub或Bitbucket上
- en: Local filesystem
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地文件系统
- en: HashiCorp Vault
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Vault
- en: A JDBC database
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个JDBC数据库
- en: Spring Cloud Config allows us to handle configuration in a hierarchical structure;
    for example, we can place common parts of the configuration in a common file and
    microservice-specific settings in separate configuration files.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config允许我们以分层结构处理配置；例如，我们可以将配置的通用部分放在一个公共文件中，将微服务特定的设置放在单独的配置文件中。
- en: Spring Cloud Config also supports detecting changes in the configuration and
    pushing notifications to the affected microservices. It uses **Spring Cloud Bus**
    to transport the notifications. Spring Cloud Bus is an abstraction on top of Spring
    Cloud Stream that we already are familiar with; that is, it supports the use of
    either RabbitMQ or Kafka as the messaging system for transporting notifications
    out of the box.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config还支持检测配置变化并将通知推送给受影响的微服务。它使用**Spring Cloud Bus**来传输通知。Spring
    Cloud Bus是我们已经熟悉的Spring Cloud Stream的抽象；也就是说，它支持使用RabbitMQ或Kafka作为消息系统来传输通知。
- en: 'The following diagram illustrates the cooperation between Spring Cloud Config,
    its clients, a Git repository, and Spring Cloud Bus:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了Spring Cloud Config、其客户端、Git仓库和Spring Cloud Bus之间的协作：
- en: '![](img/a6dc8c02-132d-482d-bf64-2b2994b29eca.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6dc8c02-132d-482d-bf64-2b2994b29eca.png)'
- en: 'The diagram shows the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了以下内容：
- en: When the microservices starts up, they ask the configuration server for its
    configuration.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当微服务启动时，它们会向配置服务器请求其配置。
- en: The configuration server gets the configuration from, in this case, a Git repository.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置服务器从这个例子中的Git仓库获取配置。
- en: Optionally, the Git repository can be configured to send notifications to the configuration
    server when Git commits are pushed to the Git repository.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，Git仓库可以配置为在Git提交推送到Git仓库时向配置服务器发送通知。
- en: The configuration server will publish change events using Spring Cloud Bus.
    The microservices that are affected by the change will react and retrieve its
    updated configuration from the configuration server.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置服务器将使用Spring Cloud Bus发布变更事件。受到变更影响的微服务将做出反应，并从配置服务器获取其更新的配置。
- en: Finally, Spring Cloud Config also supports the encryption of sensitive information
    in the configuration, such as credentials.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Spring Cloud Config还支持对配置中的敏感信息进行加密，例如凭据。
- en: We will learn about Spring Cloud Config in [Chapter 12](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml),
    *Centralized Configuration*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第12章中学习Spring Cloud Config，*集中配置*。
- en: With Spring Cloud Config introduced, let's get introduced to how to use Resilience4j
    for improved resilience.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Spring Cloud Config 的引入，让我们了解一下如何使用 Resilience4j 提高韧性。
- en: Using Resilience4j for improved resilience
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Resilience4j 提高韧性
- en: As we already mentioned in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, in the*Circuit breaker* section, things go wrong occasionally.
    In a fairly large-scaled system landscape of cooperating microservices, we must
    assume that there is something going wrong all of the time. Failures must be seen
    as a normal state, and the system landscape must be designed to handle it!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)**微服务介绍**中已经提到的，*在电路断路器*部分，事情偶尔会出错。在一个相当大规模的微服务合作系统中，我们必须假设任何时候都在出现问题。失败必须被视为一种正常状态，系统景观必须设计成能够处理它！
- en: Initially, Spring Cloud came with Netflix Hystrix, a well-proven circuit breaker.
    But since the Spring Cloud Greenwich release, it is recommended to replace Netflix
    Hystrix with Resilience4j. The reason for this is that Netflix recently put Hystrix
    into maintenance mode. For more details, see [https://github.com/Netflix/Hystrix#hystrix-status](https://github.com/Netflix/Hystrix#hystrix-status).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Spring Cloud 随 Netflix Hystrix 一起提供，这是一个经过验证的电路断路器。但是自从 Spring Cloud Greenwich
    版本发布以来，建议将 Netflix Hystrix 替换为 Resilience4j。原因是 Netflix 最近将 Hystrix 置于维护模式。有关详细信息，请参阅[https://github.com/Netflix/Hystrix#hystrix-status](https://github.com/Netflix/Hystrix#hystrix-status)。
- en: '**Resilience4j** is an open source-based fault tolerance library. You can discover
    more about it at [https://github.com/resilience4j/resilience4j](http://resilience4j.github.io/resilience4j/).
    It comes with the following fault tolerance mechanisms built-in:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**Resilience4j**是一个基于开源的容错库。您可以在[https://github.com/resilience4j/resilience4j](http://resilience4j.github.io/resilience4j/)了解更多信息。它内置了以下容错机制：'
- en: '**Circuit breaker** is used to prevent a chain of failure reactions if a remote
    service stops to respond.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电路断路器**用于防止远程服务停止响应时的故障连锁反应。'
- en: '**Rate limiter** is used to limit the number of requests to service during
    a specified time period.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率限制器**用于在指定时间段内限制对服务的请求数量。'
- en: '**Bulkhead** is used to limit the number of concurrent requests to a service.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**舱壁**用于限制对服务的并发请求数量。'
- en: '**Retries** is used to handle random errors that might happen from time to
    time.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重试**用于处理可能时不时发生的随机错误。'
- en: '**Timeout** is used to avoid waiting too long for a response from slow or not
    responding service.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时**用于避免等待慢速或无响应服务的响应时间过长。'
- en: 'In [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml), *Improving Resilience
    Using Resilience4j*, we will focus on the circuit breaker in Resilience4j.It follows
    the classic design of a circuit breaker, as illustrated in the following state
    diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](23795d34-4068-4961-842d-989cde26b642.xhtml)**使用Resilience4j提高韧性**中，我们将重点关注Resilience4j中的电路断路器。它遵循以下状态图所示的经典电路断路器设计：
- en: '![](img/39bdb1ab-dd3a-4238-8fe8-9b112d5f2125.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39bdb1ab-dd3a-4238-8fe8-9b112d5f2125.png)'
- en: 'Let''s take a look at the state diagram in more detail:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看状态图：
- en: A circuit breaker starts as **Closed**, that is, allowing requests to be processed.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**电路断路器**开始时是**关闭**的，也就是说，允许请求被处理。
- en: As long as the requests are processed successfully, it stays in the **Closed**
    state.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要请求成功处理，它就保持在**关闭**状态。
- en: If failures start to happen, a counter starts to count up.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果开始出现故障，一个计数器开始递增。
- en: If a configured threshold of failures is reached, the circuit breaker will **trip**,
    that is, go to the **Open** state, not allowing further requests to be processed.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果达到配置的失败阈值，电路断路器将**跳闸**，也就是说，进入**打开**状态，不允许进一步处理请求。
- en: Instead, a request will **fast fail**, that is, return immediately with an exception.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，请求将**快速失败**，也就是说，立即返回异常。
- en: After a configurable time, the circuit breaker will enter a **Half Open** state
    and allow one request to go through, such as a probe, to see whether the failure
    has been resolved.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可配置的时间后，电路断路器将进入**半开**状态，并允许一个请求通过，如一个探针，以查看故障是否已解决。
- en: If the probe request fails, the circuit breaker goes back to the **Open** state.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果探针请求失败，电路断路器回到**打开**状态。
- en: If the probe request succeeds, the circuit breaker goes to the initial **Closed**
    state, that is, allowing new requests to be processed.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果探针请求成功，电路断路器回到初始**关闭**状态，也就是说，允许处理新请求。
- en: Sample usage of the circuit breaker in Resilience4j
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Resilience4j 中电路断路器的示例用法
- en: Let's assume we have a REST service that is protected by a circuit breaker via Resilience4j
    called `myService`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个通过Resilience4j实现的带有熔断器的REST服务，称为`myService`。
- en: If the service starts to produce internal errors, for example, because it can't
    reach a service it depends on, we might get a response from the service such as `500
    Internal Server Error`. After a number of configurable attempts, the circuit will
    open and we will get a fast failure that returns an error message such as `CircuitBreaker
    'myService' is open`. When the error is resolved and we make a new attempt (after
    the configurable wait time), the circuit breaker will allow a new attempt as a
    probe. If the call succeeds, the circuit breaker will be closed again; that is,
    it is operating normally.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务开始产生内部错误，例如，因为它无法访问它依赖的服务，我们可能会从服务中得到如`500 Internal Server Error`的响应。在经过一系列可配置的尝试后，电路将会打开，我们将得到一个快速失败，返回一个如`CircuitBreaker
    'myService' is open`的错误消息。当错误解决后（在可配置的等待时间后）我们进行新的尝试，熔断器将允许作为探测器的新的尝试。如果调用成功，熔断器将再次关闭；也就是说，它正在正常运行。
- en: 'When using Resilience4j together with Spring Boot, we will be able to monitor
    the state of the circuit breakers in a microservice using its Spring Boot Actuator
    `health` endpoint. We can, for example, use `curl` to see the state of the circuit
    breaker, that is, `myService`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当与Spring Boot一起使用Resilience4j时，我们能够通过Spring Boot Actuator的`health`端点监控微服务中的熔断器状态。例如，我们可以使用`curl`查看熔断器的状态，即`myService`：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If it operates normally, that is, the circuit is `closed`, it will respond
    with something such as the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它正常运行，即电路`关闭`，它会响应一些如下类似的内容：
- en: '![](img/3fb19393-c8f6-46e4-a14b-f0850f75131e.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fb19393-c8f6-46e4-a14b-f0850f75131e.png)'
- en: 'If something is wrong and the circuit is **open**, it will respond with something
    such as the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出了问题且电路**打开**，它会响应一些如下类似的内容：
- en: '![](img/0256fdb6-55bb-4ad8-9e24-532f801c9916.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0256fdb6-55bb-4ad8-9e24-532f801c9916.png)'
- en: With Resilience4j and specifically its circuit breaker introduced, we have seen
    an example of how the circuit breaker can be used to handle errors for a REST
    client. Let's get introduced to how to use Spring Cloud Sleuth and Zipkin for
    distributed tracing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Resilience4j以及特别介绍的它的熔断器，我们看到了一个例子，说明熔断器可以如何用于处理REST客户端的错误。让我们了解一下如何使用Spring
    Cloud Sleuth和Zipkin进行分布式追踪。
- en: Using Spring Cloud Sleuth and Zipkin for distributed tracing
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Sleuth和Zipkin进行分布式追踪。
- en: To understand what is going on in a distributed system such as a system landscape
    of cooperating microservices, it is crucial to be able to track and visualize
    how requests and messages flow between microservices when processing an external
    call to the system landscape.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解分布式系统（如合作微服务的系统景观）中发生了什么，能够追踪和可视化处理系统景观的外部调用时请求和消息在微服务之间的流动至关重要。
- en: Refer to [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),* Introduction
    to Microservices*, the *Distributed tracing*section, for more information on this
    subject.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 参阅[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)，*微服务简介*，*分布式追踪*部分，了解有关这个主题的更多信息。
- en: Spring Cloud comes with **Spring Cloud Sleuth**, which can mark requests and
    messages/events that are part of the same processing flow with a common *correlation
    ID*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud自带**Spring Cloud Sleuth**，它可以标记属于同一处理流程的请求和消息/事件，使用共同的相关ID。
- en: Spring Cloud Sleuth can also decorate log messages with correlation IDs to make
    it easier to track log messages from different microservices that come from the
    same processing flow. **Zipkin** is a distributed tracing system ([http://zipkin.io](http://zipkin.io/))
    that Spring Cloud Sleuth can send tracing data to for storage and visualization.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Sleuth还可以用相关ID装饰日志消息，以便更容易追踪来自相同处理流程的不同微服务日志消息.**Zipkin**是一个分布式追踪系统（[http://zipkin.io](http://zipkin.io/)），Spring
    Cloud Sleuth可以将追踪数据发送到该系统进行存储和可视化。
- en: The infrastructure for handling distributed tracing information in Spring Cloud
    Sleuth and Zipkinis based on Google Dapper ([https://ai.google/research/pubs/pub36356](https://ai.google/research/pubs/pub36356)).
    In Dapper, the tracing information from a complete workflow is called a **trace tree**,
    and subparts of the tree, such as the basic units of work, are called **spans**.
    Spans can, in turn, consist of sub-spans, which form the trace tree. A correlation
    ID is called `TraceId`, and a span is identified by its own unique `SpanId`, along
    with `TraceId` of the trace tree it belongs to.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Sleuth和Zipkin处理分布式追踪信息的基础架构基于Google Dapper([https://ai.google/research/pubs/pub36356](https://ai.google/research/pubs/pub36356)).
    在Dapper中，来自完整工作流的追踪信息称为**追踪树**，树的部分，如工作基本单元，称为**跨度**。 跨度可以进一步由子跨度组成，形成追踪树。 一个关联ID称为`TraceId`，跨度由其唯一的`SpanId`以及它所属的追踪树的`TraceId`来标识。
- en: 'Spring Cloud Sleuth can send requests to Zipkin either synchronously over HTTP
    or asynchronously using either RabbitMQ or Kafka. To avoid creating runtime dependencies
    to the Zipkin server from our microservices, we prefer sending trace information
    to Zipkin asynchronously using either RabbitMQ or Kafka. This is illustrated by
    the following diagram:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Sleuth可以通过HTTP同步或使用RabbitMQ或Kafka异步发送请求到Zipkin。 为了避免从我们的微服务中创建对Zipkin服务器的运行时依赖，我们更倾向于异步使用RabbitMQ或Kafka将追踪信息发送到Zipkin。
    这如下面的图表所示：
- en: '![](img/0b718675-03d1-4367-8114-0def71168052.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b718675-03d1-4367-8114-0def71168052.png)'
- en: 'In [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml), *Understanding
    Distributed Tracing*, we will see how we can use Spring Cloud Sleuth and Zipkin
    to trace the processing that goes on in our microservice landscape. The following
    is a screenshot from the Zipkin UI, which visualizes the trace tree that was created
    as a result of processing the creation of an aggregated product:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](42f456c5-d911-494a-a1ba-4631863068b6.xhtml)中，*理解分布式追踪*，我们将了解如何使用Spring
    Cloud Sleuth和Zipkin来追踪我们微服务架构中进行的处理。以下是来自Zipkin UI的屏幕截图，它可视化了创建聚合产品处理结果所生成的追踪树：
- en: '![](img/6b7b0b09-bac1-4528-ad88-ab30d6410fde.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b7b0b09-bac1-4528-ad88-ab30d6410fde.png)'
- en: An HTTP `POST` request is sent to the product-composite service and responds
    by publishing create events to the topics for products, recommendations, and reviews.
    These events are consumed by the three core microservices in parallel and the
    data in the create events are stored in each microservice's database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个HTTP `POST`请求发送到产品组合服务，并通过发布创建事件到产品、推荐和评论的主题来响应。 这些事件被三个核心微服务并行消费，并且创建事件中的数据存储在每个微服务的数据库中。
- en: With Spring Cloud Sleuth and Zipkin for distributed tracing being introduced,
    we have seen an example of distributed tracing of the processing of an external
    synchronous HTTP request that includes asynchronous passing of events between
    the involved microservices.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Spring Cloud Sleuth和Zipkin分布式追踪的引入，我们看到了一个例子，该例子追踪了一个外部同步HTTP请求的处理，包括涉及微服务之间异步传递事件的分布式追踪。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how Spring Cloud has evolved from being rather
    Netflix OSS-centric to having a much larger scope as of today. We also introduced
    how components from the latest release of Spring Cloud Greenwich can be used to
    implement some of the design patterns we described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*, in the *Design patterns for microservices* section.
    These design patterns are required to make a landscape of cooperating microservices
    production-ready.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Spring Cloud如何从较为Netflix OSS中心演变成今天的范围更广。 我们还介绍了如何使用Spring Cloud Greenwich的最新版本来实现我们*微服务介绍*章节中描述的设计模式，在*微服务设计模式*部分。
    这些设计模式是使一组合作的微服务准备好生产环境的必要条件。
- en: Head over to the next chapter to see how we can implement service discovery
    using Netflix Eureka and Spring Cloud load balancer!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 翻到下一章，了解我们如何使用Netflix Eureka和Spring Cloud负载均衡器实现服务发现！
- en: Questions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of Netflix Eureka?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Netflix Eureka的目的是什么？
- en: What are the main features of Spring Cloud Gateway?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway的主要特性是什么？
- en: What backends are supported by Spring Cloud Config?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Config支持哪些后端？
- en: What are the capabilities that Resilience4j provides?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Resilience4j提供了哪些功能？
- en: What are the concepts of trace tree and span used for in distributed tracing,
    and what is the paper called that defined them?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式跟踪中 trace tree 和 span 的概念是什么，定义它们的论文叫什么？
- en: Technical requirements
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the commands that are described in this book have been run on a MacBook
    Pro using macOS Mojave, but it should be straightforward to modify it so that
    it can run on another platform, such as Linux or Windows.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在MacBook Pro上使用macOS Mojave运行的，但是修改起来应该很容易，使其可以在其他平台上运行，例如Linux或Windows。
- en: No new tools need to be installed in this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中不需要安装任何新工具。
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter09).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter09)。
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中描述的命令，将源代码下载到文件夹中，并设置一个环境变量`$BOOK_HOME`，使其指向该文件夹。一些示例命令如下：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Java source code is written for Java 8 and has been tested on Java 12\.
    This chapter uses Spring Cloud 2.1.0 (also known as the **Greenwich** release),
    Spring Boot 2.1.3, and Spring 5.1.5—that is, the latest available version of the
    Spring components at the time of writing this chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用Spring Cloud 2.1.0（也称为**Greenwich**版本），Spring
    Boot 2.1.3和Spring 5.1.5，即在本章撰写时可用的Spring组件的最新版本。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含了以下Gradle项目：
- en: '`api`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`'
- en: '`util`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`microservices/product-service`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-service`'
- en: '`microservices/review-service`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/review-service`'
- en: '`microservices/recommendation-service`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/recommendation-service`'
- en: '`microservices/product-composite-service`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-composite-service`'
- en: '`spring-cloud/eureka-server`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/eureka-server`'
- en: The code examples in this chapter all come from the source code in the `$BOOK_HOME/Chapter09` directory
    but have been edited in several places in order to remove irrelevant parts of
    the source code, such as comments and import and log statements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter09`目录中的源代码，但在多个地方进行了编辑，以删除源代码中不相关的内容，例如注释和导入日志语句。
- en: If you want to look at the changes that were applied to the source code in [Chapter
    9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding Service Discovery Using
    Netflix Eureka and Ribbon*, to see what it took to add Netflix Eureka as a discovery
    service to the microservices landscape, you can compare it with the source code
    for [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing Reactive
    Microservices*. You can use your favorite `diff` tool and compare the two folders,
    `$BOOK_HOME/Chapter07` and `$BOOK_HOME/Chapter09`, respectively.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看在[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)中应用于源代码的更改，*使用Netflix
    Eureka和Ribbon添加服务发现*，以了解向微服务架构添加Netflix Eureka作为发现服务所需的内容，你可以将其与[第7章](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml)的源代码进行比较，*开发反应式微服务*。你可以使用你喜欢的`diff`工具，分别比较两个文件夹，`$BOOK_HOME/Chapter07`和`$BOOK_HOME/Chapter09`。
- en: Challenges with service discovery
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现的问题
- en: So, we need something a bit more powerful than a plain DNS to keep track of
    available microservice instances!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要比普通的DNS更强大的东西来跟踪可用的微服务实例！
- en: 'We must take the following into consideration when we''re keeping track of
    many small moving parts, that is, microservice instances:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们跟踪许多小的移动部件，即微服务实例时，我们必须考虑以下几点：
- en: New instances can start up at any point in time.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的实例可以在任何时间点启动。
- en: Existing instances can stop responding and eventually crash at any point in
    time.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的实例在任何时间点都可能停止响应并最终崩溃。
- en: Some of the failing instances might be okay after a while and should start to
    receive traffic again, while others will not and should be removed from the service
    registry.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些失败的实例可能过一会儿就没事了，应该重新开始接收流量，而其他的则不应该，应该从服务注册表中删除。
- en: Some microservice instances might take some time to start up; that is, just
    because they can receive HTTP requests doesn't mean that traffic should be routed
    to them.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些微服务实例可能需要一些时间来启动；也就是说，仅仅因为它们能够接收HTTP请求，并不意味着应该将流量路由到它们那里。
- en: Unintended network partitioning and other network-related errors can occur at
    any time.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无意中的网络分区和其他网络相关错误可能会随时发生。
- en: Building a robust and resilient discovery server is not an easy task, to say
    the least. Let's see how we can use Netflix Eureka to handle these challenges!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个健壮和有弹性的发现服务器绝非易事。让我们看看我们如何可以使用Netflix Eureka来应对这些挑战！
- en: Service discovery with Netflix Eureka in Spring Cloud
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud中的Netflix Eureka进行服务发现
- en: 'Netflix Eureka implements client-side service discovery, meaning that the clients
    run software that talks to the discovery service, Netflix Eureka, to get information
    about the available microservice instances. This is illustrated in the following
    diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka实现了客户端服务发现，这意味着客户端运行与发现服务（Netflix Eureka）通信的软件，以获取有关可用微服务实例的信息。以下图表说明了这一点：
- en: '![](img/3e46d604-73a8-4747-8af4-23865c058d65.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e46d604-73a8-4747-8af4-23865c058d65.png)'
- en: 'The process is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 流程如下：
- en: Whenever a microservice instance starts up—for example, the **Review** service—it
    registers itself to one of the Eureka servers.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当一个微服务实例启动时—例如，**Review**服务—它会将自己注册到其中一个Eureka服务器上。
- en: On a regular basis, each microservice instance sends a heartbeat message to
    the Eureka server, telling it that the microservice instance is okay and is ready
    to receive requests.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个微服务实例定期向Eureka服务器发送心跳消息，告诉它该微服务实例是正常的，并准备好接收请求。
- en: Clients—for example, the **Product Composite** service—use a client library
    that regularly asks the Eureka service for information about available services.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端—例如，**Product Composite**服务—使用一个客户端库，该库定期向Eureka服务询问有关可用服务的信息。
- en: When the client needs to send a request to another microservice, it already
    has a list of available instances in its client library and can pick one of them
    without asking the discovery server. Typically available instances are chosen
    in a round-robin fashion; that is, they are called one after another before the
    first one is called once more.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端需要向另一个微服务发送请求时，它已经在客户端库中有一个可用实例的列表，可以选择其中的一个，而不需要询问发现服务器。通常，可用实例是按照轮询方式选择的；也就是说，它们是依次调用，然后再重新调用第一个。
- en: In [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Implementing Kubernetes
    Features as an Alternative*, we will look at an alternative approach to how to
    provide a discovery service using a server-side *service* concept in Kubernetes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml)中，*作为替代的Kubernetes特性实现*，我们将探讨一种替代方法，使用Kubernetes中的服务器端*服务*概念来提供发现服务。
- en: Spring Cloud comes with an abstraction of how to communicate with a discovery
    service such as Netflix Eureka and provides an interface called `DiscoveryClient`.
    This can be used to interact with a discovery service to get information regarding
    available services and instances. Implementations of the `DiscoveryClient` interface
    are also capable of automatically registering a Spring Boot application with the
    discovery server.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud 包含如何与发现服务（如Netflix Eureka）通信的抽象，并提供了一个名为`DiscoveryClient`的接口。这可以用来与发现服务进行交互，获取有关可用服务和实例的信息。`DiscoveryClient`接口的实现也能够在启动时自动将Spring
    Boot应用程序注册到发现服务器上。
- en: Spring Boot can find implementations of the `DiscoveryClient` interface automatically
    during startup, so we only need to bring in a dependency on the corresponding
    implementation to connect to a discovery server. In the case of Netflix Eureka,
    the dependency that's used by our microservices is `spring-cloud-starter-netflix-eureka-client`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 可以在启动过程中自动找到`DiscoveryClient`接口的实现，因此我们只需要引入对应实现的依赖项即可连接到发现服务器。在Netflix
    Eureka的情况下，我们微服务所使用的依赖是`spring-cloud-starter-netflix-eureka-client`。
- en: Spring Cloud also has `DiscoveryClient` implementations that support the use
    of either Apache Zookeeper or HashiCorp Consul as a discovery server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud 还有支持使用Apache Zookeeper或HashiCorp Consul作为发现服务器的`DiscoveryClient`实现。
- en: Spring Cloud also comes with an abstraction—the `LoadBalancerClient` interface—for
    clients that want to make requests through a load balancer to registered instances
    in the discovery service. The standard reactive HTTP client, `WebClient`, can
    be configured to use the `LoadBalancerClient` implementation. By adding the `@LoadBalanced`
    annotation to an `@Bean` declaration that returns a `WebClient.Builder` object,
    a `LoadBalancerClient` implementation will be injected into the `Builder` instance
    as `ExchangeFilterFunction`. With the `spring-cloud-starter-netflix-eureka-client` dependency
    on the classpath, `RibbonLoadBalancerClient` will be automatically injected, that
    is, a load balancer based on Netflix Ribbon. So, even though a Netflix Ribbon
    is placed in maintenance mode, as described in [Chapter 8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml),
    *Introduction to Spring Cloud*, it is still used under the hood. Later in this
    chapter in the *Connecting microservices to a Netflix Eureka server *section,
    we will look at some source code examples of how this can be used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud还提供了一个抽象——`LoadBalancerClient`接口——对于希望通过负载均衡器向发现服务中的注册实例发起请求的客户端。标准反应式HTTP客户端`WebClient`可以配置为使用`LoadBalancerClient`实现。通过在返回`WebClient.Builder`对象的`@Bean`声明上添加`@LoadBalanced`注解，`LoadBalancerClient`实现将被注入到`Builder`实例中作为`ExchangeFilterFunction`。由于在类路径上有`spring-cloud-starter-netflix-eureka-client`依赖项，`RibbonLoadBalancerClient`将自动注入，即基于Netflix
    Ribbon的负载均衡器。所以，即使Netflix Ribbon已进入维护模式，如在第8章*Spring Cloud介绍*中描述，它仍然在幕后使用。在本章后面的*将微服务连接到Netflix
    Eureka服务器*部分，我们将查看一些源代码示例，了解如何使用它。
- en: In summary, Spring Cloud makes it very easy to use Netflix Eureka as a discovery
    service. With this introduction to service discovery and its challenges and how
    Netflix Eureka can be used together with Spring Cloud, we are ready to learn how
    to set up a Netflix Eureka server.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Spring Cloud让使用Netflix Eureka作为发现服务变得非常简单。通过介绍服务发现及其挑战以及Netflix Eureka如何与Spring
    Cloud一起使用，我们准备好学习如何设置一个Netflix Eureka服务器。
- en: Trying out the discovery service
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用发现服务
- en: 'With all of the details in place, we are ready to try out the service:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有细节就绪后，我们就可以尝试服务了：
- en: 'First, build the Docker images with the following commands:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令构建Docker镜像：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, start the system landscape and run the usual tests with the following
    command:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令启动系统架构并执行常规测试：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Expect output similar to what we have seen in previous chapters:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出与我们在前面的章节中看到的内容类似：
- en: '![](img/841fe8fc-968b-40e7-85fa-60fa73153679.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/841fe8fc-968b-40e7-85fa-60fa73153679.png)'
- en: With the system landscape up and running, we can start with testing how to scale
    up the number of instances for one of the microservices.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 系统架构运行起来后，我们可以开始测试如何扩展其中一个微服务实例的数量。
- en: Setting up a Netflix Eureka server
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Netflix Eureka服务器
- en: 'In this section, we will learn how to set up a Netflix Eureka server for service
    discovery. Setting up a Netflix Eureka server using Spring Cloud is really easy—just
    follow these steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为服务发现设置一个Netflix Eureka服务器。使用Spring Cloud设置Netflix Eureka服务器真的很容易——只需按照以下步骤操作：
- en: Create a Spring Boot project using Spring Initializr, as described in [Chapter
    3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating a Set of Cooperating
    Microservices*, in the*Using Spring Initializr to generate skeleton code* section.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Spring Initializr创建一个Spring Boot项目，具体操作见[第3章](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml)*创建一组协作的微服务*中的*使用Spring
    Initializr生成骨架代码*部分。
- en: Add a dependency to `spring-cloud-starter-netflix-eureka-server`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`spring-cloud-starter-netflix-eureka-server`依赖项。
- en: Add the `@EnableEurekaServer` annotation to the application class.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类上添加`@EnableEurekaServer`注解。
- en: Add a Dockerfile, similar to the Dockerfiles that are used for our microservices,
    with the exception that we export the Eureka default port, `8761`, instead of
    the default port for our microservices, `8080`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个Dockerfile，与用于我们的微服务的Dockerfile类似，不同之处在于我们导出Eureka默认端口`8761`，而不是我们微服务默认端口`8080`。
- en: 'Add the Eureka server to our three Docker Compose files, that is, `docker-compose.yml`,
    `docker-compose-partitions.yml`, and `docker-compose-kafka.yml`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把我们三个Docker Compose文件中添加Eureka服务器，即`docker-compose.yml`、`docker-compose-partitions.yml`和`docker-compose-kafka.yml`：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, add some configuration. Please go to the *Setting up configuration
    for use in the development process* section in this chapter, where we will go
    through the configuration for both the Eureka server and our microservices.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，请转到本章的*设置开发过程中使用的配置*部分，我们将介绍Eureka服务器和我们的微服务的配置。
- en: That's all it takes!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了！
- en: You can find the source code for the Eureka server in the `$BOOK_HOME/Chapter09/spring-cloud/eureka-server`
    folder.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`$BOOK_HOME/Chapter09/spring-cloud/eureka-server`文件夹中找到Eureka服务器的源代码。
- en: Knowing how to set up a Netflix Eureka server for service discovery, we are
    ready to learn how to connect microservices to a Netflix Eureka server.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何为服务发现设置一个Netflix Eureka服务器后，我们准备学习如何将微服务连接到Netflix Eureka服务器。
- en: Connecting microservices to a Netflix Eureka server
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微服务连接到Netflix Eureka服务器
- en: In this section, we will learn how to connect microservice instances to a Netflix
    Eureka server. We will learn both how microservices instances register themselves
    to the Eureka server during their startup and how clients can use the Eureka server to
    find microservice instances it wants to call.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将微服务实例连接到Netflix Eureka服务器。我们将了解微服务实例在启动时如何向Eureka服务器注册自己，以及客户端如何使用Eureka服务器找到它想要调用的微服务实例。
- en: 'To be able to register a microservice instance in the Eureka server, we need
    to do the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在Eureka服务器中注册一个微服务实例，我们需要执行以下操作：
- en: 'Add a dependency to `spring-cloud-starter-netflix-eureka-client` in the build
    file, `build.gradle`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建文件`build.gradle`中添加`spring-cloud-starter-netflix-eureka-client`依赖项：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When running tests on a single microservice, we don''t want to depend on having
    the Eureka server up and running. Therefore, we will disable the use of Netflix
    Eureka in all Spring Boot tests, that is, JUnit tests annotated with `@SpringBootTest`. This
    can be done by adding the `eureka.client.enabled` property and setting it to `false`
    in the annotation, like so:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在单个微服务上运行测试时，我们不希望依赖于Eureka服务器的运行。因此，我们将禁用所有Spring Boot测试中使用Netflix Eureka，即使用`@SpringBootTest`注解的JUnit测试。这可以通过在注解中添加`eureka.client.enabled`属性并将其设置为`false`来实现，如下所示：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finally, add some configuration. Please go to the *Set**ting up configuration
    for use in the development process* section, where we will go through the configuration
    for both the Eureka server and our microservices.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，请转到*设置开发过程中使用的配置*部分，我们将介绍Eureka服务器和我们的微服务的配置。
- en: There is, however, one property in the configuration that is extra important: `spring.application.name`.
    It is used to give each microservice a virtual hostname, that is, a name used
    by the Eureka service to identify each microservice. Eureka clients will use this virtual
    hostname in the URLs that are used to make HTTP calls to the microservice, as
    we will see as we proceed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在配置中有一个非常重要的属性：`spring.application.name`。它用于给每个微服务一个虚拟主机名，即Eureka服务用来识别每个微服务的名称。Eureka客户端将在用于向微服务发起HTTP调用的URL中使用这个虚拟主机名，正如我们接下来所看到的。
- en: 'To be able to look up available microservices instances through the Eureka
    server in the `product-composite` microservice, we also need to do the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在`product-composite`微服务中通过Eureka服务器查找可用的微服务实例，我们还需要执行以下操作：
- en: 'Add a load balancer-aware `WebClient` builder, as described previously, in
    an application class, that is, `se.magnus.microservices.composite.product.ProductCompositeServiceApplication`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类中，即`se.magnus.microservices.composite.product.ProductCompositeServiceApplication`，添加一个负载均衡意识`WebClient`构建器，如前所述：
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update how the `WebClient` object is created in the integration class, `se.magnus.microservices.composite.product.services.ProductCompositeIntegration`.
    The `@LoadBalanced` annotation will, as described previously, result in that Spring
    will inject a load balancer-aware filter into the `WebClient.Builder` bean. Unfortunately,
    this isn''t done until after the constructor runs in the integration class. This
    means that we have to move the construction of `webClient` away from the constructor,
    as we did in [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing
    Reactive Microservices*, to a separate getter method that creates the `webClient`
    lazily, that is, once it''s used for the first time. This is shown in the following
    code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新在集成类`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`中`WebClient`对象的创建方式。如前所述，`@LoadBalanced`注解会导致Spring向`WebClient.Builder`bean中注入一个负载均衡器感知过滤器。不幸的是，在集成类的构造函数运行之后才执行这个操作。这意味着我们必须将`webClient`的构造从构造函数中移开，就像在[第7章](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml)，*开发响应式微服务*中做的那样，移到一个单独的getter方法，该方法延迟创建`webClient`，即在第一次使用时创建。以下代码显示了这一点：
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Whenever `WebClient` is used to create an outgoing HTTP request, it is accessed
    via the `getWebClient()` getter method (instead of using the `webClient` field
    directly). See the following example:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当使用`WebClient`创建一个出站HTTP请求时，它是通过`getWebClient()`getter方法访问的（而不是直接使用`webClient`字段）。以下示例说明了这一点：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now get rid of our hardcoded configuration of available microservices
    in `application.yml`. For example, consider the following code:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以摆脱在`application.yml`中硬编码的可用微服务配置。例如，考虑以下代码：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The corresponding code in the integration class that handled the hardcoded
    configuration is replaced by a declaration of the base URLs to the APIs of the
    core microservices. This is shown in the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 处理硬编码配置的集成类中相应的代码被替换为声明核心微服务API的基本URL。以下代码显示了这一点：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The hostnames in the preceding URLs are not actual DNS names. Instead, they
    are the virtual hostnames that are used by the microservices when they register
    themselves to the Eureka server, that is, the values of the `spring.application.name` property.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前述URL中的主机名不是实际的DNS名称。相反，它们是微服务在向Eureka服务器注册时使用的虚拟主机名，即`spring.application.name`属性的值。
- en: Knowing how to connect microservice instances to a Netflix Eureka server, we
    can move on and learn how to configure both a Eureka server and microservice instances
    that need to connect to a Eureka server.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何将微服务实例连接到Netflix Eureka服务器后，我们可以继续学习如何配置Eureka服务器以及需要连接到Eureka服务器的微服务实例。
- en: Setting up configuration for use in the development process
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为开发过程设置配置
- en: 'Now, it''s time for the trickiest part of setting up Netflix Eureka as a discovery
    service, that is, setting up a working configuration for both the Eureka server
    and its clients: our microservice instances.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是设置Netflix Eureka作为发现服务最棘手的部分的时候了，也就是说，为Eureka服务器及其客户端（即我们的微服务实例）设置一个工作配置。
- en: Netflix Eureka is a highly configurable discovery server that can be set up
    for a number of different use cases, and it provides robust, resilient, and fault-tolerant
    runtime characteristics. One downside of this flexibility and robustness is that
    it has an almost overwhelming number of configuration options. Fortunately, Netflix
    Eureka comes with good default values for most of the configurable parameters—at
    least when it comes to using them in a production environment.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka是一个高度可配置的发现服务器，可以设置为多种不同的使用场景，并提供健壮、弹性、容错性强的运行时特性。这种灵活性和健壮性的一个缺点是，它有令人望而生畏的大量配置选项。幸运的是，Netflix
    Eureka为大多数可配置参数提供了良好的默认值——至少在使用它们的生产环境来说是这样。
- en: When it comes to using Netflix Eureka during development, the default values
    cause long startup times. For example, it can take a long time for a client to
    make an initial successful call to a microservices instance that is registered
    in the Eureka server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当在开发过程中使用Netflix Eureka时，默认值会导致长时间启动。例如，客户端首次成功调用注册在Eureka服务器中的微服务实例可能需要很长时间。
- en: Up to two minutes of wait time can be experienced when using the default configuration
    values. This wait time is added to the time it takes for the Eureka service and
    the microservices to start up. The reason for this wait time is that the involved
    processes need to synchronize registration information with each other.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认配置值时，可能会经历长达两分钟的等待时间。这种等待时间是在Eureka服务及其微服务启动所需的时间之上加上的。这段等待时间的原因是涉及到的进程需要彼此同步注册信息。
- en: The microservices instances need to register with the Eureka server, and the
    client needs to gather information from the Eureka server. This communication
    is mainly based on heartbeats, which happen every 30 seconds by default. A couple
    of caches are also involved, which slows down the propagation of updates.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务实例需要向Eureka服务器注册，客户端需要从Eureka服务器获取信息。这种通信主要基于心跳，默认每30秒发生一次。还有几个缓存也涉及其中，这减缓了更新的传播。
- en: We will use a configuration that minimizes this wait time, which is useful during
    development. For use in production environments, the default values should be
    used as a starting point!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种减少等待时间的配置，这在开发时很有用。对于生产环境，应该以默认值作为起点！
- en: We will only use one Netflix Eureka server instance, which is okay in a development
    environment. In a production environment, you should always use two or more instances to
    ensure high availability for the Netflix Eureka server.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用一个Netflix Eureka服务器实例，这在开发环境中是可以的。在生产环境中，为了确保Netflix Eureka服务器的高可用性，你应该始终使用两个或更多的实例。
- en: Let's start to learn what types of configuration parameters we need to know
    about.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始了解我们需要知道哪些类型的配置参数。
- en: Eureka configuration parameters
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eureka配置参数
- en: 'The configuration parameters for Eureka are divided into three groups:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Eureka的配置参数分为三组：
- en: There are parameters for the Eureka server, prefixed with `eureka.server`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用于Eureka服务器的参数，前缀为`eureka.server`。
- en: There are parameters for Eureka clients, prefixed with `eureka.client`. This
    is for clients who want to communicate with a Eureka server.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用于Eureka客户端的参数，前缀为`eureka.client`。这是用于与Eureka服务器通信的客户端。
- en: There are parameters for Eureka instances, prefixed with `eureka.instance`.
    This is for the microservices instances that want to register themselves in the
    Eureka server.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用于Eureka实例的参数，前缀为`eureka.instance`。这是用于希望在Eureka服务器上注册自己的微服务实例。
- en: 'Some of the available parameters are described in the Spring Cloud documentation:
    *Service Discovery: Eureka Server*: [https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server)
    *Service Discovery: Eureka Clients*: [https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#_service_discovery_eureka_clients](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#_service_discovery_eureka_clients)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可用的参数在Spring Cloud文档中有描述：*服务发现：Eureka服务器*：[https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server)
    *服务发现：Eureka客户端*：[https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#_service_discovery_eureka_clients](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#_service_discovery_eureka_clients)
- en: 'For an extensive list of available parameters, I recommend reading the source
    code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可用参数的详细列表，我建议阅读源代码：
- en: For Eureka server parameters, look at the `org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean` class
    for default values and the `com.netflix.eureka.EurekaServerConfig` interface for
    the relevant documentation.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Eureka服务器参数，你可以查看`org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean`类以获取默认值和`com.netflix.eureka.EurekaServerConfig`接口的相关文档。
- en: For Eureka client parameters, look at the `org.springframework.cloud.netflix.eureka.EurekaClientConfigBean`
    class for the default values anddocumentation.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Eureka客户端参数，你可以查看`org.springframework.cloud.netflix.eureka.EurekaClientConfigBean`类以获取默认值和文档。
- en: For Eureka instance parameters, look at the `org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean`
    class for default values and documentation.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Eureka实例参数，你可以查看`org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean`类以获取默认值和文档。
- en: Let's start to learn about configuration parameters for the Eureka server.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始了解Eureka服务器的配置参数。
- en: Configuring the Eureka server
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Eureka服务器
- en: 'To configure the Eureka server for use in a development environment, the following
    configuration can be used:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在开发环境中配置Eureka服务器，可以使用以下配置：
- en: '[PRE18]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first part of the configuration, for a Eureka `instance` and `client` is
    a standard configuration of a standalone Eureka server. For details, see the Spring
    Cloud documentation that we referred to previously. The last two parameters used
    for the Eureka `server`, `waitTimeInMsWhenSyncEmpty` and `response-cache-update-interval-ms`,
    are used to minimize the startup time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka服务器的配置第一部分，对于一个`instance`（实例）和`client`（客户端）是一个独立Eureka服务器的标准配置。详细信息，请参阅我们之前引用的Spring
    Cloud文档。用于Eureka`server`（服务器）的最后两个参数`waitTimeInMsWhenSyncEmpty`和`response-cache-update-interval-ms`用于最小化启动时间。
- en: With the Eureka server configured, we are ready to see how clients to the Eureka
    server, that is, the microservice instances, can be configured.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了Eureka服务器之后，我们准备看看如何配置Eureka服务器的客户端，即微服务实例。
- en: Configuring clients to the Eureka server
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Eureka服务器的客户端
- en: 'To be able to connect to the Eureka server, the microservices have the following
    configuration:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够连接到Eureka服务器，微服务具有以下配置：
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `eureka.client.serviceUrl.defaultZone` parameter is used to find the Eureka
    server, whereas the other parameters are used to minimize the startup time and
    the time it takes to deregister a microservice instance that is stopped.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`eureka.client.serviceUrl.defaultZone`参数用于查找Eureka服务器，而其他参数用于最小化启动时间和停止微服务实例的时间。'
- en: 'The `product-composite` microservice, which uses the Eureka server to look
    up the other microservices, also has two Netflix Ribbon-specific parameters:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Eureka服务器查找其他微服务的`product-composite`微服务也有两个Netflix Ribbon特定参数：
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These two parameters are also used to minimize startup time.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数也用于最小化启动时间。
- en: Now, we have everything in place required to actually try out discovery service
    using the Netflix Eureka server together with our microservices.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了在Netflix Eureka服务器和我们的微服务中实际尝试发现服务所需的一切。
- en: Scaling up
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'Now, we can try out the discovery service by launching two extra `review` microservice
    instances:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过启动两个额外的`review`微服务实例来尝试发现服务：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the preceding command, we ask Docker Compose to run three instances of
    the `review` service. Since one instance is already running, two new instances
    will be started up.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们要求Docker Compose运行`review`服务的三个实例。由于一个实例已经在运行，将启动两个新实例。
- en: 'Once the new instances are up and running, browse to `http://localhost:8761/`
    and expect something like the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新实例启动并运行，浏览到`http://localhost:8761/`，预期如下所示：
- en: '![](img/b53f6c5c-f964-4731-8907-8482ddd11cca.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b53f6c5c-f964-4731-8907-8482ddd11cca.png)'
- en: After running this localhost, verify that you can see three `review` instances
    in the Netflix Eureka web UI, as shown in the preceding screenshot.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此localhost之后，验证您是否可以在Netflix Eureka web UI中看到三个`review`实例，如前截图所示。
- en: 'One way of knowing when the new instances are up and running is to run the
    `docker-compose logs -f review` command and look for output that looks as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 知道新实例何时启动并运行的一种方法是运行`docker-compose logs -f review`命令，并查找如下所示的输出：
- en: '![](img/249647b6-1f89-4d9a-800c-d84d740893f6.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/249647b6-1f89-4d9a-800c-d84d740893f6.png)'
- en: 'We can also use a REST API that the Eureka service exposes. To get a list of
    instance IDs, we can issue a `curl` command, like so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用Eureka服务暴露的REST API。为了获取实例ID列表，我们可以发出如下`curl`命令：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Expect a response that looks similar to the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 期待类似于以下内容的响应：
- en: '![](img/66ef4c5e-20f9-4056-8bdb-e4398a194d4e.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66ef4c5e-20f9-4056-8bdb-e4398a194d4e.png)'
- en: 'Now that we have all of the instances up and running, let''s try out the client-side
    load balancer by making some requests and focusing on the address of the `review`
    service in the responses, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让所有实例运行起来，尝试通过发送一些请求并关注`review`服务在响应中的地址，如下所示：
- en: '[PRE23]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Expect responses similar to the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 期待类似于以下的响应：
- en: '![](img/ccd79bc6-a3e1-43aa-891f-553c6f727741.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccd79bc6-a3e1-43aa-891f-553c6f727741.png)'
- en: Note that the address of the `review` service changes in each response; that
    is, the load balancer uses a round-robin to call the available `review` instances,
    one at a time!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`review`服务的地址在每次响应中都会改变；也就是说，负载均衡器使用轮询依次调用可用的`review`实例，一个接一个！
- en: 'We can also take a look into the `review` instances log with the following
    command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令查看`review`实例的日志：
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After this, you will see output that looks similar to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将看到类似于以下内容的输出：
- en: '![](img/cadd482e-aa89-4949-972e-d8fb4f3f1145.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cadd482e-aa89-4949-972e-d8fb4f3f1145.png)'
- en: In the preceding output, we can see how the three review microservice instances, `review_1`, `review_2`,
    and `review_3`, in turn, have responded to the requests.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到三个`review`微服务实例`review_1`、`review_2`和`review_3`如何依次响应请求。
- en: After trying out scaling up microservice instances we will try out what happens
    when we scale down the instances.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试扩展现有的微服务实例之后，我们将尝试缩减这些实例。
- en: Scaling down
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放向下
- en: 'Let''s also see what happens if we lose one instance of the `review` microservice.
    We can simulate that one instance stops unexpectedly by running the following
    command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看如果我们失去了一个`review`微服务的实例会发生什么。我们可以通过运行以下命令来模拟这个实例意外停止：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After the shutdown of the `review` instance, there is a short time slot when
    calls to the API might fail. This is caused by the time it takes for information
    regarding the lost instance to propagate to the client, that is, the `product-composite`
    service. During this time frame, the client-side load balancer might choose the
    instance that no longer exists. To prevent this from occurring, resilience mechanisms
    such as timeouts and retries can be used. In [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml), *Improving
    Resilience Using Resilience4j*, we will see how this can be applied. For now,
    let''s specify a timeout on our `curl` command, using the `-m 2` switch to specify
    that we will wait no longer than two seconds for a response:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`review`实例关闭后，有一个短暂的时间段，API调用可能会失败。这是由于信息传播到客户端（即`product-composite`服务）所需的时间，也就是失去实例的时间。在这段时间内，客户端负载均衡器可能会选择不再存在的实例。为了防止这种情况发生，可以使用诸如超时和重试等弹性机制。在[第13章](23795d34-4068-4961-842d-989cde26b642.xhtml)，*使用Resilience4j改进弹性*，我们将看到如何应用这些机制。现在，让我们在我们的`curl`命令上指定一个超时，使用`-m
    2`开关来指定我们不会等待超过两秒钟的响应：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If a timeout occurs, that is, the client-side load balancer tries to call an
    instance that no longer exists, the following response is expected from `curl`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生超时，即客户端负载均衡器尝试调用一个不再存在的实例，`curl`应返回以下响应：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Besides that, we should expect normal responses from the two remaining instances;
    that is, the `serviceAddresses.rev` field should contain the addresses of the
    two instances, as in the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预期两个剩余实例的正常响应；也就是说，`serviceAddresses.rev`字段应包含两个实例的地址，如下所示：
- en: '![](img/25abdb94-b95c-4cb9-baea-c5917f2ce8af.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25abdb94-b95c-4cb9-baea-c5917f2ce8af.png)'
- en: In the preceding sample output, we can see that two different container names
    and IP addresses are reported. This means that the requests have been served by
    different microservice instances.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例输出中，我们可以看到报告了两个不同的容器名称和IP地址。这意味着请求已经被不同的微服务实例处理。
- en: 'After trying out the scaling down of microservice instances, we can try out
    something that is a bit more disruptive: stopping the Eureka server and seeing
    what happens when the discovery service is temporarily unavailable.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试微服务实例的缩放向下之后，我们可以尝试更具破坏性的事情：停止Eureka服务器，看看当发现服务暂时不可用时会发生什么。
- en: Disruptive tests with the Eureka server
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带Eureka服务器的破坏性测试
- en: Let's bring some disorder to our Eureka server and see how the system landscape
    manages it!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的Eureka服务器带来一些混乱，看看系统景观如何处理它！
- en: To start with, what happens if we crash the Eureka server?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们使Eureka服务器崩溃会怎样？
- en: As long as clients have read the information regarding available microservice
    instances from the Eureka server before it is stopped, the clients will be fine
    since they cache the information locally. However, new instances will not be made
    available to clients, and they will not be notified if any running instances are
    terminated. So, calls to instances that are no longer running will cause failures.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 只要客户端在Eureka服务器停止之前从服务器读取了有关可用微服务实例的信息，客户端就会没问题，因为它们会在本地缓存这些信息。但是，新的实例不会提供给客户端，并且如果任何正在运行的实例被终止，它们也不会收到通知。因此，调用不再运行的实例将导致失败。
- en: Let's try this out!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看！
- en: Stopping the Eureka server
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止Eureka服务器
- en: 'To simulate that the Eureka server crashes, follow these steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟Eureka服务器的崩溃，请按照以下步骤操作：
- en: 'First, stop the Eureka server and keep the two `review` instances up and running:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，停止Eureka服务器，同时保持两个`review`实例运行：
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Try a couple of calls to the API and extract the service address of the `review`
    service:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试对API进行几次调用并提取`review`服务的服务地址：
- en: '[PRE29]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The response will—just like before we stopped the Eureka server—contain the
    addresses of the two `review` instances, like so:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应将—就像我们停止Eureka服务器之前一样—包含两个`review`实例的地址，如下所示：
- en: '![](img/91291ded-566c-4cea-b151-aeea0e4c6390.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91291ded-566c-4cea-b151-aeea0e4c6390.png)'
- en: This shows that the client can make calls to existing instances, even though
    the Eureka server is no longer running!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明客户端甚至可以在Eureka服务器不再运行时对现有实例进行调用！
- en: Stopping a review instance
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止一个`review`实例
- en: 'To further investigate what the effects are of a crashed Eureka server, let''s
    simulate that one of the remaining `review` microservice instances also crashes.
    Terminate one of the two `review` instances with the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步调查停止运行的Eureka服务器的影响，让我们模拟剩下的一个`review`微服务实例也崩溃。使用以下命令终止两个`review`实例中的一个：
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The client, that is, the `product-composite` service, will not be notified that
    one of the `review` instances has disappeared since no Eureka server is running.
    Due to this, it still thinks that there are two instances up and running. Every
    second call to the client will cause it to call a `review` instance that no longer
    exists, resulting in the response from the client not containing any information
    from the `review` service. The service address of the `review` service will be
    empty.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端，即`product-composite`服务，由于没有运行Eureka服务器，不会通知其中一个`review`实例已经消失。因此，它仍然认为有两个实例正在运行。每两次对客户端的调用会导致它调用一个不再存在的`review`实例，导致客户端的响应不包含任何来自`review`服务的信息。`review`服务的服务地址将变为空。
- en: Try out the preceding `curl` command to verify that the service address of the
    `review` service will be empty every second time. This can be prevented, as described
    previously, by using resilience mechanisms such as timeouts and retries.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用前面的`curl`命令验证`review`服务的服务地址将会在第二次变为空。这可以通过使用之前描述的时间outs和retries等弹性机制来防止。
- en: Starting up an extra instance of the product service
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动产品服务的额外实例
- en: 'As a final test of the effects of a crashed Eureka server, let''s see what
    happens if we start up a new instance of the `product` microservice. Perform the
    following steps:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对停止运行的Eureka服务器效果的最终测试，如果我们启动`product`微服务的新实例，会发生什么情况呢？执行以下步骤：
- en: 'Let''s try starting a new instance of the `product` service:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试启动`product`服务的新的实例：
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Call the API a couple of times and extract the address of the `product` service
    with the following command:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对API进行几次调用并使用以下命令提取`product`服务的地址：
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since no Eureka server is running, the client will not be notified of the new
    `product` instance, and so all calls will go to the first instance, as in the
    following example:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有运行Eureka服务器，客户端不会通知新的`product`实例，所以所有的调用都会发送到第一个实例，如下例所示：
- en: '![](img/a783eca8-e0b7-48be-947d-c972032e4c9b.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a783eca8-e0b7-48be-947d-c972032e4c9b.png)'
- en: Now we have seen some of the most important aspects of not having a Netflix
    Eureka server up and running. Let's conclude the section on disruptive tests by
    starting up the Netflix Eureka server again and seeing how the system landscape
    handles self-heals, that is, resilience.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了在没有运行Netflix Eureka服务器时的一些最重要的方面。让我们通过再次启动Netflix Eureka服务器来结束本节的干扰性测试，看看系统景观如何处理自我修复，即弹性。
- en: Starting up the Eureka server again
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新启动Eureka服务器
- en: 'In this section, we will wrap up the disruptive tests by starting up the Eureka
    server again. We shall also verify that the system landscape self-heals, that
    is, verify that the new instance of the `product` microservice gets registered
    with the Netflix Eureka server and that the client gets updated by the Eureka
    server. Perform the following steps:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过重新启动Eureka服务器来结束干扰性测试。我们还应验证系统景观是否自我修复，即验证新的`product`微服务实例是否被Netflix
    Eureka服务器注册，并且客户端是否被Eureka服务器更新。执行以下步骤：
- en: 'Start the Eureka server with the following command:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动Eureka服务器：
- en: '[PRE33]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Make some new calls to the API and verify that the following happens:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 进行一些新的API调用，并验证以下情况是否发生：
- en: All calls go to the remaining `review` instance, that is, the client has detected
    that the second `review` instance has gone.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有调用都发送到剩余的`review`实例，即客户端检测到第二个`review`实例已经消失。
- en: Calls to the `product` service are load-balanced over the two `product` instances,
    that is, the client has detected that there are two `product` instances available.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `product` 服务的调用在两个 `product` 实例之间进行负载均衡，也就是说，客户端检测到有这两个 `product` 实例可用。
- en: 'Make the following call a couple of times to extract the addresses of the product
    and the `review` service:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次调用以下调用以提取 `product` 和 `review` 服务的地址：
- en: '[PRE34]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Verify that the responses from the API calls contain addresses to the involved
    `product` and `review` instances, like so:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认 API 调用响应包含涉及 `product` 和 `review` 实例的地址，如下所示：
- en: '![](img/4c8c141a-2404-4b8c-bf33-b7a0b59c5476.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c8c141a-2404-4b8c-bf33-b7a0b59c5476.png)'
- en: 'This is the second response:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个响应：
- en: '![](img/03c25c97-63a7-49d6-82b1-72ea5a69ac79.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03c25c97-63a7-49d6-82b1-72ea5a69ac79.png)'
- en: The `192.168.128.3` and `192.168.128.7` IP addresses belong to the two `product`
    instances. `192.168.128.9` is the IP address of the `review` instance.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`192.168.128.3` 和 `192.168.128.7` IP 地址属于两个 `product` 实例。`192.168.128.9` 是
    `review` 实例的 IP 地址。'
- en: To summarize, the Eureka server provides a very robust and resilient implementation
    of a discovery service. If even higher availability is desired, multiple Eureka
    servers can be launched and configured to communicate with each other. Details
    on how to set up multiple Eureka servers can be found in the Spring Cloud documentation: [https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server-peer-awareness](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server-peer-awareness).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Eureka 服务器提供了一个非常健壮和灵活的发现服务实现。如果需要更高的可用性，可以启动并配置多个 Eureka 服务器以相互通信。在 Spring
    Cloud 文档中可以找到有关如何设置多个 Eureka 服务器的详细信息：[https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server-peer-awareness](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server-peer-awareness)。
- en: 'Finally, shut down the system landscape with the command:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令关闭系统景观：
- en: '[PRE35]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This completes the tests of the discovery server, Netflix Eureka, where we have
    learned both how to scale up and scale down microservice instances and learned
    what happens if a Netflix Eureka server crashes and later on comes back online.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对发现服务器 Netflix Eureka 的测试，我们既学习了如何扩展和缩小微服务实例，也学习了 Netflix Eureka 服务器崩溃后重新上线会发生什么。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use Netflix Eureka for service discovery.
    First, we looked into the shortcomings of a simple DNS-based service discovery
    solution and the challenges that a robust and resilient service discovery solution
    must be able to handle.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Netflix Eureka 进行服务发现。首先，我们探讨了简单基于 DNS 的服务发现解决方案的不足之处，以及健壮和灵活的服务发现解决方案必须能够处理的问题。
- en: Netflix Eureka is a very capable service discovery solution that provides robust,
    resilient, and fault-tolerant runtime characteristics. However, it can be challenging
    to configure correctly, especially for smooth developer experience. With Spring
    Cloud, it becomes easy to set up a Netflix Eureka server and adapt Spring Boot-based
    microservices, both so that they can register themselves to Eureka during startup
    and, when acting as a client to other microservices, to keep track of available
    microservices instances.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Eureka 是一个功能强大的服务发现解决方案，提供了健壮、灵活和容错性运行时特性。然而，正确配置可能会具有一定挑战性，尤其是为了提供平滑的开发体验。使用
    Spring Cloud，设置 Netflix Eureka 服务器和适配基于 Spring Boot 的微服务变得容易，这样它们可以在启动时注册到 Eureka，并且在作为其他微服务客户端时，可以跟踪可用的微服务实例。
- en: With a discovery service in place, it's time to see how we can handle external
    traffic using Spring Cloud Gateway as an edge server. Head over to the next chapter
    to find out how!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有了发现服务之后，是时候看看我们如何使用 Spring Cloud Gateway 作为边缘服务器来处理外部流量了。翻到下一章，找出答案吧！
- en: Questions
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is required to turn a Spring Boot application created with Spring Initializr
    into a fully-fledged Netflix Eureka Server?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将使用 Spring Initializr 创建的 Spring Boot 应用程序转换为完全功能的 Netflix Eureka 服务器需要什么？
- en: What is required to make a Spring Boot-based microservice register itself automatically
    as a startup with Netflix Eureka?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要让基于 Spring Boot 的微服务自动作为启动项注册到 Netflix Eureka 需要什么？
- en: What is required to make it possible for a Spring Boot-based microservice to
    call another microservice that is registered in a Netflix Eureka server?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要让一个基于 Spring Boot 的微服务调用注册在 Netflix Eureka 服务器上的另一个微服务需要什么？
- en: 'Let''s assume that you have a Netflix Eureka server up and running, along with
    one instance of microservice *A* and two instances of microservice *B*. All microservice
    instances register themselves with the Netflix Eureka server. Microservice *A*
    makes HTTP requests to microservice *B* based on the information it gets from
    the Eureka server. What will happen if, in turn, the following happens:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你有一个正在运行的网飞Eureka服务器，以及一个微服务*A*的实例和两个微服务*B*的实例。所有微服务实例都会向网飞Eureka服务器注册。微服务*A*根据从Eureka服务器获取的信息对微服务*B*发起HTTP请求。那么，如果依次发生以下情况：
- en: The Netflix Eureka server crashes
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网飞Eureka服务器崩溃了
- en: One of the instances of microservice *B* crashes
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务*B*的一个实例崩溃了
- en: A new instance of microservice *A* starts up
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务*A*的一个新实例启动了
- en: A new instance of microservice *B* starts up
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务*B*的一个新实例启动了
- en: The Netflix Eureka server starts up again
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网飞Eureka服务器再次启动了
