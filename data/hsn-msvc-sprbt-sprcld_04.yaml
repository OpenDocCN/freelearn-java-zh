- en: Creating a Set of Cooperating Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一套协作的微服务
- en: In this chapter, we will build our first couple of microservices. We will learn
    how to create cooperating microservices with minimalistic functionality. In upcoming
    chapters, we will add more and more functionality to these microservices. By the
    end of this chapter, we will have a RESTful API exposed by a composite microservice.
    The composite microservice will call three other microservices using their RESTful
    API's to create an aggregated response.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的第一个微服务。我们将学习如何创建具有最小功能的协作微服务。在接下来的章节中，我们将向这些微服务添加越来越多的功能。到本章末尾，我们将通过一个复合微服务暴露一个
    RESTful API。复合微服务将使用它们的 RESTful API 调用其他三个微服务，以创建一个聚合响应。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the microservice landscape
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍微服务架构
- en: Generating skeleton microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成微服务骨架
- en: Adding RESTful APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 RESTful API
- en: Adding a composite microservice
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个复合微服务
- en: Adding error handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加错误处理
- en: Testing the APIs manually
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试 API
- en: Adding automated tests of microservices in isolation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向微服务添加隔离的自动化测试
- en: Adding semi-automated tests to a microservice landscape
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向微服务架构添加半自动化测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the commands that are described in this book are run on a MacBook Pro
    using macOS Mojave but should be straightforward to modify so that they can be
    run on another platform such as Linux or Windows.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在 MacBook Pro 上使用 macOS Mojave 运行的，但它们应该很容易修改，以便在如 Linux 或 Windows
    等其他平台上运行。
- en: Tool installation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具安装
- en: 'To be able to execute the commands that are used in this chapter, you need
    to have the following tools installed on your computer:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够执行本章中使用的命令，你需要在你计算机上安装以下工具：
- en: '**Git: **Can be downloaded and installed from [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Git:](https://git-scm.com/downloads) 可以从 [https://git-scm.com/downloads](https://git-scm.com/downloads)
    下载并安装。'
- en: '**Java: **Can be downloaded and installed from [https://www.oracle.com/technetwork/java/javase/downloads/index.html](https://www.oracle.com/technetwork/java/javase/downloads/index.html).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java：**可以从 [https://www.oracle.com/technetwork/java/javase/downloads/index.html](https://www.oracle.com/technetwork/java/javase/downloads/index.html)
    下载并安装。'
- en: '`curl`: This command-line tool for testing HTTP-based APIs can be downloaded
    and installed from [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl`：这个用于测试基于 HTTP 的 API 的命令行工具可以从 [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html)
    下载并安装。'
- en: '`jq`: This command-line JSON processor can be downloaded and installed from [https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jq`：这个命令行JSON处理器可以从 [https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/)
    下载并安装。'
- en: '**Spring Boot CLI**: This command-line tool for Spring Boot applications can
    be downloaded and installed from [https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-installing-the-cli](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-installing-the-cli).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Boot CLI**：这个 Spring Boot 应用程序的命令行工具可以从 [https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-installing-the-cli](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-installing-the-cli)
    下载并安装。'
- en: Installing Homebrew
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Homebrew
- en: 'To install these tools on macOS, I recommend that you use Homebrew, [https://brew.sh/](https://brew.sh/).
    If you don''t have it installed, you can install it with the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 macOS 上安装这些工具，我建议你使用 Homebrew，[https://brew.sh/](https://brew.sh/)。如果你没有安装，可以使用以下命令安装：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing the command-line tools for Xcode installs Homebrew, so it might take
    a while if you don't have it installed already.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Xcode 的命令行工具会安装 Homebrew，如果你还没有安装，可能需要一些时间。
- en: 'Verify the installation of Homebrew with the following commands:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令验证 Homebrew 的安装：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Expect a response such as the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到如下响应：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using Homebrew to install Java, curl, jq, and the Spring Boot CLI
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Homebrew 安装 Java、curl、jq 和 Spring Boot CLI
- en: 'On a macOS, `curl` is already preinstalled and `git` was installed as part
    of the installation of Homebrew. The remaining tools can be installed on a macOS
    using Homebrew with the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，`curl` 已经预装，`git` 是 Homebrew 安装的一部分。剩下的工具可以使用以下命令在 macOS 上使用 Homebrew
    安装：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The installation of these tools can be verified by the following commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具的安装可以通过以下命令来验证：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These commands will return something like the following (some extra irrelevant
    output was removed):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将返回如下内容（删除了一些不相关的输出）：
- en: '![](img/cf7decb8-42ed-41c9-a9fe-6143e7d1c0e5.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf7decb8-42ed-41c9-a9fe-6143e7d1c0e5.png)'
- en: Using an IDE
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IDE
- en: I recommend that you work with your Java code using an IDE that supports the
    development of Spring Boot applications such as Spring Tool Suite or IntelliJ
    IDEA Ultimate Edition. See the *Testing APIs manually* section to learn how to
    use the Spring Boot Dashboard. However, you don't need an IDE to be able to follow
    the instructions in this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你使用支持Spring Boot应用程序开发的IDE，如Spring Tool Suite或IntelliJ IDEA Ultimate Edition来编写Java代码。查看*手动测试API*部分，了解如何使用Spring
    Boot控制台。然而，你不需要IDE就能按照本书中的说明操作。
- en: Accessing the source code
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问源代码
- en: 'The source code for this chapter can be found in this book''s GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter03).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter03)。
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中描述的命令，将源代码下载到文件夹中，并设置一个环境变量`$BOOK_HOME`，该变量指向该文件夹。一些示例命令如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Java source code is written for Java 8 and tested to run on Java 12\. To
    avoid some problems with Spring Boot 2.0 (and Spring 5.0), this chapter uses Spring
    Boot 2.1.0 RC1 (and Spring 5.1.1), the latest available version of Spring Boot
    at the time of writing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试运行。为了避免与Spring Boot 2.0（和Spring 5.0）的一些问题，本章使用了Spring
    Boot 2.1.0 RC1（和Spring 5.1.1），这是在撰写本书时可用的最新Spring Boot版本。
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter03`
    but are in many cases edited to remove irrelevant parts of the source code, such
    as comments, imports, and log statements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter03`的源代码，但在许多情况下，为了删除源代码中不相关部分，例如注释、导入和日志声明，对这些代码进行了编辑。
- en: With this, we have the required tools installed and the source code for the
    chapter downloaded. In the next section, we will learn about the system landscape
    of cooperating microservices that we will create in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们安装了所需的工具，并下载了本章的源代码。在下一节中，我们将学习本书中我们将要创建的协作微服务系统架构。
- en: Introducing the microservice landscape
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍微服务架构
- en: 'In [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction to
    Microservices*, we were briefly introduced to the microservice-based system landscape
    that we will use throughout this book:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)中，*微服务简介*，我们简要介绍了将在本书中使用的基于微服务的系统架构：
- en: '![](img/cf74f5f6-c0f7-471c-8eae-a2566ecee996.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf74f5f6-c0f7-471c-8eae-a2566ecee996.png)'
- en: It consists of three core microservices, the **Product**, **Review**, and **Recommendation**
    services, all of which deal with one type of resource, and a composite microservice
    called the **Product Composite** service, which aggregates information from the
    three core services.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它由三个核心微服务组成，分别是**产品**、**评论**和**推荐**服务，这三个服务都处理一种资源类型，还有一个名为**产品组合**的复合微服务，它聚合了这三个核心服务的信息。
- en: Temporarily replacing a discovery service
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂时替换发现服务
- en: 'Since, at this stage, we don''t have any service discovery mechanism in place,
    we will use hardcoded port numbers for each microservice. We will use the following
    ports:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个阶段，我们没有任何服务发现机制，我们将为每个微服务使用硬编码端口号。我们将使用以下端口：
- en: 'Product composite service: `7000`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品组合服务：`7000`
- en: 'Product service: `7001`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品服务：`7001`
- en: 'Review service: `7002`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查服务：`7002`
- en: Recommendation service: `7003`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐服务：`7003`
- en: We will get rid of the hardcoded ports later when we start using Docker and
    Kubernetes!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后开始使用Docker和Kubernetes时，将不再使用这些硬编码端口！
- en: In this section, we have been introduced to the microservices we are going to
    create and the information that they will handle. In the next section, we will
    use Spring Initializr to create skeleton code for the microservices.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经介绍了将要创建的微服务以及它们将处理的信息。在下一节中，我们将使用Spring Initializr创建微服务的骨架代码。
- en: Information handled by microservices
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务处理的信息
- en: To keep the source code examples in this book easy to understand, they have
    a minimal amount of business logic. The information model for the business objects
    they process is kept minimal for the same reason. In this section, we will go
    through the information that's handled by each microservice, plus infrastructure-related
    information that microservices handle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本书中的源代码示例容易理解，它们包含的业务逻辑量最小。它们处理的业务对象的信息模型同样因为此原因保持最小。在本节中，我们将了解每个微服务处理的信息，以及微服务处理的基础设施相关信息。
- en: Product service
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品服务
- en: 'The `product` service manages product information and describes each product
    with the following attributes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`服务管理产品信息，并使用以下属性描述每个产品：'
- en: Product ID
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品ID
- en: Name
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: Weight
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重量
- en: Review service
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务回顾
- en: 'The `review` service manages product reviews and stores the following information
    about each review:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`review`服务管理产品评论，并存储关于每个评论以下信息：'
- en: Product ID
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品ID
- en: Review ID
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾ID
- en: Author
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者
- en: Subject
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题
- en: Content
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容
- en: Recommendation service
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推荐服务
- en: 'The `recommendation` service manages product recommendations and stores the
    following information about each recommendation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommendation`服务管理产品推荐，并存储关于每个推荐以下信息：'
- en: Product ID
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品ID
- en: Recommendation ID
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐ID
- en: Author
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者
- en: Rate
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分
- en: Content
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容
- en: Product composite service
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品复合服务
- en: 'The product composite service aggregates information from the three core services
    and presents information about a product as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`复合服务汇总三个核心服务的信息，如下所示呈现关于产品的信息：'
- en: Product information, as described in the `product` service
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品信息，如`product`服务中所描述
- en: A list of product reviews for the specified product, as described in the `review`
    service
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定产品的产品评论列表，如`review`服务中所描述
- en: A list of product recommendations for the specified product, as described in
    the `recommendation` service
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定产品的产品推荐列表，如`recommendation`服务中所描述
- en: Infrastructure-related information
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与基础设施相关的信息
- en: Once we start to run our microservices as containers that are managed by the
    infrastructure (first Docker and later on Kubernetes), it will be of interest
    to track which container actually responded to our requests. To simplify this
    tracking, we have also added a `serviceAddress` attribute to all our responses, formatted
    as `hostname/ip-address:port`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始将我们的微服务作为由基础架构管理（首先是Docker，后来是Kubernetes）的容器运行，跟踪实际响应我们请求的容器将会很有趣。为了简化这种跟踪，我们还向所有我们的响应中添加了一个`serviceAddress`属性，格式为`hostname/ip-address:port`。
- en: Generating skeleton microservices
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成骨架微服务
- en: Now it's time to see how we can create projects for our microservices. The final
    result for this topic can be found in the `$BOOK_HOME/Chapter03/1-spring-init`folder.
    To simplify setting up the projects, we will use Spring Initializr to generate
    a skeleton project for each microservice. A skeleton project contains the necessary
    files for building the project, along with an empty `main` class and test class
    for the microservice. After that, we will see how we can build all our microservices
    with one command using multi-project builds in the build tool that we will use,
    Gradle.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看我们如何为我们的微服务创建项目了。这个主题的最终结果可以在`$BOOK_HOME/Chapter03/1-spring-init`文件夹中找到。为了简化项目的设置，我们将使用Spring
    Initializr为每个微服务生成一个骨架项目。骨架项目包含构建项目所需的文件，以及为微服务空白的`main`类和测试类。之后，我们将了解如何使用我们将要使用的构建工具Gradle中的多项目构建，用一个命令构建所有的微服务。
- en: Using Spring Initializr to generate skeleton code
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Initializr生成骨架代码
- en: To get started with developing our microservices, we will use a tool called
    **Spring Initializr** to generate skeleton code for us. It can either be invoked
    from a web browser using the [https://start.spring.io/](https://start.spring.io/) URL
    or by a command-line tool, `spring init`. To make it easier to reproduce the creation
    of the microservices, we will use the command-line tool.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始开发我们的微服务，我们将使用一个名为**Spring Initializr**的工具来为我们生成骨架代码。它可以通过使用[https://start.spring.io/](https://start.spring.io/)
    URL从网络浏览器调用，或者通过命令行工具`spring init`调用。为了更容易地复现微服务的创建，我们将使用命令行工具。
- en: 'For each microservice, we will create a Spring Boot project which does the
    following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 针对每个微服务，我们将创建一个Spring Boot项目，执行以下操作：
- en: Uses Gradle as a build tool
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gradle作为构建工具
- en: Generates code for Java 8
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Java 8生成代码
- en: Packages the project as a fat JAR file
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目打包为胖JAR文件
- en: Brings in dependencies for the `Actuator` and `WebFlux` Spring modules
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入了`Actuator`和`WebFlux` Spring模块的依赖项
- en: Is based on Spring Boot v2.1.0 RC1 (which depends on Spring Framework v5.1.1)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Spring Boot v2.1.0 RC1（依赖于Spring Framework v5.1.1）
- en: Spring Boot Actuator enables a number of valuable endpoints for management and
    monitoring. We will see them in action later on. Spring WebFlux will be used here
    to create our RESTful APIs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Actuator为管理和监控启用了许多有价值的端点。我们稍后可以看到它们的具体应用。在这里，我们将使用Spring WebFlux创建我们的RESTful
    API。
- en: 'To create skeleton code for our microservices, we need to run the following
    command for `product-service`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的微服务创建骨架代码，我们需要针对`product-service`运行以下命令：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you want to learn more about the `spring init` CLI, you can run the `spring
    help init` command. To see what dependencies you can add, run the `spring init
    --list` command.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`spring init` CLI的信息，可以运行`spring help init`命令。要查看您可以添加的依赖项，请运行`spring
    init --list`命令。
- en: 'If you want to create the four projects on your own instead of using the source
    code in this book''s GitHub repository, try out `$BOOK_HOME/Chapter03/1-spring-init/create-projects.bash`,
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想自己创建这四个项目，而不是使用本书GitHub仓库中的源代码，可以尝试使用`$BOOK_HOME/Chapter03/1-spring-init/create-projects.bash`，如下所示：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After creating our four projects using `create-projects.bash`, we will have
    the following file structure:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`create-projects.bash`创建我们的四个项目后，我们将拥有以下文件结构：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For each project, we can list the created files. Let''s do this for the `product-service`
    project:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个项目，我们可以列出创建的文件。让我们为`product-service`项目这样做：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will receive the following output:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '![](img/21a0ab5c-8c4c-4898-9cab-598833bd976f.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21a0ab5c-8c4c-4898-9cab-598833bd976f.png)'
- en: 'Spring Initializr created a number of files for Gradle, including a `.gitignore`
    file and three Spring Boot files:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Initializr为Gradle创建了许多文件，包括一个`.gitignore`文件和三个Spring Boot文件：
- en: '`ProductServiceApplication.java`, our main application class'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductServiceApplication.java`，我们的主应用类'
- en: '`application.properties`, an empty property file'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application.properties`，一个空属性文件'
- en: '`ProductServiceApplicationTests.java`, a test class that''s been configured
    to run tests on our Spring Boot application using JUnit'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductServiceApplicationTests.java`，一个已配置为使用JUnit在我们的Spring Boot应用程序上运行测试的测试类'
- en: 'The `main` application class, `ProductServiceApplication.java`, looks as we''d
    expect based on the previous chapter:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`应用类`ProductServiceApplication.java`看起来与上一章预期的一致：'
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The test class looks as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类如下所示：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `@RunWith(SpringRunner.class)` and `@SpringBootTest` annotations will initialize
    our application in the same way as `@SpringBootApplication` does when running
    the application; that is, the Spring application context will be set up before
    the tests are executed using component scanning and auto-configuration, as described
    in the previous chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RunWith(SpringRunner.class)`和`@SpringBootTest`注解将以前述方式初始化我们的应用：当运行应用时，`@SpringBootApplication`会设置Spring应用上下文；也就是说，在执行测试之前，使用组件扫描和自动配置设置上下文，如上一章所述。'
- en: 'Let''s also look at the most important Gradle file, `build.gradle`. The content
    of this file describes how to build the project, for example, compile, test, and
    package the source code. The Gradle file starts by setting up the conditions for
    the rest of the build file by declaring the `buildscript` element and listing
    what plugins to apply:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看看最重要的Gradle文件，即`build.gradle`。这个文件的内容描述了如何构建项目，例如编译、测试和打包源代码。Gradle文件从设置`buildscript`元素并列出要应用的插件来开始，为其余的构建文件设置条件：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: The Spring Boot version is set to what we specified when we ran the `spring
    init` command, `2.1.0.RC1`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot版本设置为我们运行`spring init`命令时指定的版本，即`2.1.0.RC1`。
- en: A number of Gradle plugins are declared. The most important ones are the `org.springframework.boot` and `io.spring.dependency-management` plugins,
    which together ensure that Gradle will build a fat JAR file and that we don't
    need to specify any explicit version numbers on our Spring Boot starter dependencies.
    Instead, they are implied by the `springBootVersion` property.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明了许多Gradle插件。最重要的插件是`org.springframework.boot`和`io.spring.dependency-management`插件，这两个插件一起确保Gradle会构建一个胖JAR文件，并且我们不需要在Spring
    Boot启动器依赖项上指定任何显式的版本号。相反，它们由`springBootVersion`属性隐含。
- en: Plugins are fetched from the central Maven repository and from Spring's snapshot
    and milestone repositories since we have specified a release candidate of Spring
    Boot, v2.1.0 RC1, and not a version that's been released and is available in the
    central Maven repository.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件是从中央Maven仓库以及Spring的快照和里程碑仓库中获取的，因为我们指定的是Spring Boot的发行候选版本，即v2.1.0 RC1，而不是一个已经发布并可在中央Maven仓库中找到的版本。
- en: 'In the rest of the build file, we basically declare a group name and version
    for our project, Java version, and its dependencies:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建文件的其余部分，我们基本上为我们的项目声明了一个组名和版本，Java版本及其依赖项：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s explain the preceding source code in more detail as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释上述源代码如下：
- en: Dependencies are, as with the preceding plugins, fetched from the central Maven
    repository and from Spring's snapshot and milestone repositories.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项，像之前的插件一样，从中央Maven仓库和Spring的快照和里程碑仓库中获取。
- en: Dependencies are set up as specified in the `Actuator` and `WebFlux` modules,
    along with a couple of useful test dependencies.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项是按照`Actuator`和`WebFlux`模块中指定的设置的，还有一些有用的测试依赖项。
- en: 'We can build each microservice separately with the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令单独构建每个微服务：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note how we use the `gradlew` executables that are created by Spring Initializr;
    that is, we don't need to have Gradle installed!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用由Spring Initializr创建的`gradlew`可执行文件；也就是说，我们不需要安装Gradle！
- en: The first time we run a command with `gradlew`, it will download Gradle automatically.
    The Gradle version that's used is determined by the `distributionUrl` property
    in the `gradle/wrapper/gradle-wrapper.properties` file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行`gradlew`命令时，它会自动下载Gradle。使用的Gradle版本由`gradle/wrapper/gradle-wrapper.properties`文件中的`distributionUrl`属性确定。
- en: Setting up multi-project builds in Gradle
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Gradle中设置多项目构建
- en: 'To make it a bit simpler to build all the microservices with one command, we
    can set up a multi-project build in Gradle. The steps are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用一个命令构建所有微服务稍微简单一些，我们可以在Gradle中设置一个多项目构建。步骤如下：
- en: 'First, we create the `settings.gradle` file, which describes what projects
    that Gradle should build:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`settings.gradle`文件，描述Gradle应该构建哪些项目：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we copy the Gradle executable files that were generated from one of the
    projects so that we can reuse them for the multi-project builds:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将复制从一个项目中生成的Gradle可执行文件，以便我们可以在多项目构建中重复使用它们：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We no longer need the generated Gradle executable files in each project, so
    we can remove them with the following commands:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要每个项目中生成的Gradle可执行文件，所以我们可以使用以下命令删除它们：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The result should be similar to the code you can find in the folder `$BOOK_HOME/Chapter03/1-spring-init`**.**
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该与您在`$BOOK_HOME/Chapter03/1-spring-init`文件夹中找到的代码类似。
- en: 'Now, we can build all the microservices with one command:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以用一个命令构建所有微服务：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you haven''t run the preceding commands, you can simply go to the book''s
    source code and build it from there:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有运行前面的命令，您可以简单地直接去书源代码那里并从中构建：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should result in the following output:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会导致以下输出：
- en: '![](img/efd0c892-cbca-4962-8248-b17da6fe8cd0.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efd0c892-cbca-4962-8248-b17da6fe8cd0.png)'
- en: With skeleton projects for the microservices created using Spring Initializr
    and successfully built using Gradle, we are ready to add some code to the microservices
    in the next section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Initializr创建的微服务骨架项目和成功使用Gradle构建后，我们在下一节准备向微服务中添加一些代码。
- en: From a DevOps perspective, a multi-project setup might not be preferred. Instead,
    setting up a separate build pipeline for each microservice project would probably
    be preferred. However, for the purposes of this book, we will use the multi-project
    setup to make it easier to build and deploy the whole system landscape with a
    single command.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从DevOps的角度来看，多项目设置可能不是首选。相反，为每个微服务项目设置一个单独的构建管道可能更受欢迎。然而，为了本书的目的，我们将使用多项目设置，以便更容易用一个命令构建和部署整个系统架构。
- en: Adding RESTful APIs
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 RESTful API
- en: Now that we have projects set up for our microservices, let's add some RESTful
    APIs to our three core microservices!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的微服务设置了项目，接下来让我们向我们的三个核心微服务中添加一些 RESTful API 吧！
- en: The final result of this and the remaining topics in this chapter can be found
    in the `$BOOK_HOME/Chapter03/2-basic-rest-services`folder.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余主题的最终结果可以在 `$BOOK_HOME/Chapter03/2-basic-rest-services` 文件夹中找到。
- en: First, we will add two projects (`api` and `util`) that will contain code that
    is shared by the microservice projects, and then we will implement the RESTful
    APIs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加两个项目（`api` 和 `util`），它们将包含由微服务项目共享的代码，然后我们将实现 RESTful API。
- en: Adding an API and a util project
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 API 和 util 项目
- en: 'To add an API, we need to do the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加 API，我们需要执行以下操作：
- en: First, we will set up a separate Gradle project where we can place our API definitions.
    We will use Java interfaces in order to describe our RESTful APIs and model classes
    to describe the data that the API uses in its requests and responses. Describing
    a RESTful API in a Java interface instead of directly in the Java class is, to
    me, a good way of separating the API definition from its implementation. We will
    further extend this pattern later in this book when we add more API information
    in the Java interfaces to be exposed in the Swagger/OpenAPI definition. See [Chapter 5](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml),
    *Adding an API Description Using OpenAPI/Swagger*, for more information.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将建立一个单独的 Gradle 项目，用于放置我们的 API 定义。我们将使用 Java 接口来描述我们的 RESTful API，并使用模型类来描述
    API 在其请求和响应中使用的数据。在我看来，使用 Java 接口而不是直接在 Java 类中描述 RESTful API 是一种很好的将 API 定义与其实现分离的方法。在本书的后续内容中，我们将进一步扩展这一模式，当我们向
    Java 接口中添加更多 API 信息以在 Swagger/OpenAPI 定义中公开时。更多信息请参阅 [第 5 章](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml)，*使用
    OpenAPI/Swagger 添加 API 描述*。
- en: Describing RESTful APIs in Java interfaces wasn't fully supported until Spring
    Framework v5.1.0\. See [https://jira.spring.io/browse/SPR-11055](https://jira.spring.io/browse/SPR-11055)
    for details.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 描述 RESTful API 的 Java 接口直到 Spring Framework v5.1.0 才得到完全支持。具体请参阅 [https://jira.spring.io/browse/SPR-11055](https://jira.spring.io/browse/SPR-11055)。
- en: It is debatable whether it is good practice to store API definitions for a group
    of microservices in a common API module. To me, it is a good choice for microservices
    that are part of the same delivery organization, that is, whose releases are governed
    by one and the same organization (compare to a *Bounded Context* in *Domain-Driven
    Design*, where our microservices are placed in one and the same bounded context).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 是否应该将一组微服务的 API 定义存储在公共 API 模块中，这一点是有争议的。在我看来，这对于属于同一交付组织的微服务来说是一个不错的选择，也就是说，这些微服务的发布由同一个组织管理（与
    *Domain-Driven Design* 中的 *Bounded Context* 相比，我们的微服务位于同一个 bounded context 中）。
- en: Next, we will create a `util` project that can hold some helper classes that
    are shared by our microservices, for example, for handling errors in a uniform
    way.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个 `util` 项目，用于存放一些由我们的微服务共享的帮助类，例如，以统一的方式处理错误。
- en: Again, from a DevOps perspective, it would be preferable to build all the projects
    in their own build pipeline and have version-controlled dependencies for the `api`
    and `util` projects in the microservice projects; that is, so that each microservice
    can choose what versions of the `api` and `util` projects to use. But to keep
    the build and deployment steps simple in the context of this book, we will make
    the `api` and `util` projects part of the multi-project build.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从 DevOps 的角度来看，最好为所有项目建立它们自己的构建管道，并在微服务项目中使用版本控制的 `api` 和 `util` 项目依赖；也就是说，每个微服务可以选择使用
    `api` 和 `util` 项目的哪些版本。但为了在本书的上下文中保持构建和部署步骤简单，我们将使 `api` 和 `util` 项目成为多项目构建的一部分。
- en: The api project
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: api 项目
- en: The `api` project will be packaged as a library; that is, it won't have its
    own `main` application class. Unfortunately, Spring Initializr doesn't support
    the creation of library projects. Instead, a library project has to be created
    manually from scratch. The source code for the API project is available at `$BOOK_HOME/Chapter03/2-basic-rest-services/api`**.**
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`api` 项目将被打包为库；也就是说，它将没有自己的 `main` 应用程序类。不幸的是，Spring Initializr 不支持创建库项目。相反，库项目需要从头开始手动创建。API
    项目的源代码可在 `$BOOK_HOME/Chapter03/2-basic-rest-services/api` 找到。'
- en: 'The structure of a library project is the same as for an application project,
    except that we no longer have the `main` application class, as well as some minor
    differences in the `build.gradle` file. The Gradle `org.springframework.boot`
    and `io.spring.dependency-management` plugins are replaced with a `dependencyManagement`
    section:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 库项目的结构与应用程序项目相同，不同之处在于我们不再有`main`应用程序类，以及在`build.gradle`文件中的一些小差异。Gradle `org.springframework.boot`和`io.spring.dependency-management`插件被替换为一个`dependencyManagement`部分：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This allows us to retain Spring Boot dependency management while we are replacing
    the construction of a fat JAR in the build step with the creation of normal JAR
    files; that is, they only contain the library project's own class and property
    files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在替换构建步骤中构建胖JAR的方法为创建正常JAR文件的同时保留Spring Boot依赖管理；也就是说，它们只包含库项目自己的类和属性文件。
- en: 'The Java files in the `api` project for our three core microservices are as
    follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`api`项目中我们三个核心微服务的Java文件如下：'
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The structure of the Java classes looks very similar for the three core microservices,
    so we will only go through the source code for the `product` service.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 三个核心微服务的Java类结构非常相似，所以我们只查看`product`服务的源代码。
- en: 'First, we will look at the `ProductService.java` Java interface, as shown in
    the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看`ProductService.java`Java接口，如下代码所示：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释一下前面的源代码：
- en: The `product` service only exposes one API method, `getProduct()` (we will extend
    the API later in this book).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`服务只暴露了一个API方法，`getProduct()`（我们将在本书后面扩展API）。'
- en: To map the method to an HTTP `GET` request, we use the `@GetMapping` Spring
    annotation, where we specify what URL path the method will be mapped to (`/product/{productId}`)
    and what format the response will be, in this case, JSON.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了将方法映射到HTTP `GET`请求，我们使用`@GetMapping` Spring注解，其中我们指定方法将被映射到的URL路径（`/product/{productId}`）以及响应的格式，这次是JSON。
- en: The `{productId}` part of the path maps to a `path` variable named `productId`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径中的`{productId}`部分映射到一个名为`productId`的`path`变量。
- en: The `productId` method parameter is annotated with `@PathVariable`, which will
    map the value that's passed in the HTTP request to the parameter. For example,
    an HTTP `GET` request to `/product/123` will result in the `getProduct()` method
    being called with the `productId` parameter set to `123`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`productId`方法参数用`@PathVariable`注解标记，这将把通过HTTP请求传递的值映射到参数。例如，对`/product/123`的HTTP`GET`请求将导致`getProduct()`方法以`productId`参数设置为`123`被调用。'
- en: 'The method returns a `Product` object, a plain POJO-based model class with
    the member variables corresponding to attributes for `Product`, as described at
    the start of this chapter. `Product.java` looks as follows (with constructors
    and getter methods excluded):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个`Product`对象，这是一个基于plain POJO的模型类，其成员变量对应于`Product`的属性。`Product.java`如下所示（省略了构造函数和getter方法）：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This type of POJO class is also known as a **Data Transfer Object** (**DTO**)
    as it is used to transfer data between the API implementation and the caller of
    the API. When we get to [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),
    *Adding Persistence*, we will look at another type of POJO that can be used to
    describe how data is stored in the databases, also known as entity objects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种POJO类也被称为数据传输对象（Data Transfer Object，DTO），因为它用于在API实现和API调用者之间传输数据。当我们在第[6章](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml)中讨论添加持久化时，我们会看到另一种可以用来描述数据在数据库中存储方式的POJO，也称为实体对象。
- en: The util project
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具项目
- en: 'The `util` project will be packaged as a library in the same way as the `api`
    project. The source code for the `util` project is available at `$BOOK_HOME/Chapter03/2-basic-rest-services/util`.
    The project contains the following Java files:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`util`项目将以与`api`项目相同的方式打包为库。`util`项目的源代码可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/util`中找到。该项目包含以下Java文件：'
- en: The `InvalidInputException` and `NotFoundException` exception classes
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvalidInputException`和`NotFoundException`异常类'
- en: The `GlobalControllerExceptionHandler`, `HttpErrorInfo`, and `ServiceUtil` utility
    classes
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GlobalControllerExceptionHandler`、`HttpErrorInfo`和`ServiceUtil`工具类'
- en: Except for the code in `ServiceUtil.java`, these classes are reusable utility
    classes that we can use to map Java exceptions to proper HTTP status codes, as
    described in the *Adding error handling* section. The main purpose of `ServiceUtil.java`
    is to find out the hostname, IP address, and port used by the microservice. The
    class exposes a method, `getServiceAddress()`, that can be used by the microservices
    to find their hostname, IP address, and port.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ServiceUtil.java`中的代码，这些类是可重用的实用工具类，我们可以使用它们将Java异常映射到适当的HTTP状态码，如*添加错误处理*部分所述。`ServiceUtil.java`的主要目的是找出微服务使用的主机名、IP地址和端口。该类暴露了一个方法`getServiceAddress()`，微服务可以使用它来找到它们的主机名、IP地址和端口。
- en: Implementing our API
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的API
- en: Now we can start to implement our APIs in the core microservices!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始在核心微服务中实现我们的API了！
- en: 'The implementation looks very similar for the three core microservices, so
    we will only go through the source code for the `product` service. You can find
    the other files in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices`.
    Let''s see how we go about this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 三个核心微服务的实现看起来非常相似，所以我们只查看`product`服务的源代码。你可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices`中找到其他文件。让我们看看我们是如何进行这项工作的：
- en: 'We need to add the `api` and `util` projects as dependencies in our `build.gradle`
    file, that is, `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/build.gradle`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们需要在我们的`build.gradle`文件中添加`api`和`util`项目作为依赖，即`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/build.gradle`:'
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To enable Spring Boot''s autoconfiguration feature to detect Spring beans in
    the `api` and `util` projects, we also need to add a `@ComponentScan` annotation
    to the `main` application class, which includes the packages of the `api` and
    `util` projects:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使Spring Boot的自动配置功能能够检测到`api`和`util`项目中的Spring beans，我们还需要在主应用类中添加一个`@ComponentScan`注解，包括`api`和`util`项目的包：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we create our service implementation file, `ProductServiceImpl.java`,
    in order to implement the Java interface, `ProductService`, from the `api` project
    and annotate the class with `@RestController` so that Spring will call the methods
    in this class according to the mappings specified in the `Interface` class:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的服务实现文件`ProductServiceImpl.java`，以便实现`api`项目中的Java接口`ProductService`，并使用`@RestController`注解类，以便Spring根据`Interface`类中指定的映射调用这个类的方法：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To be able to use the `ServiceUtil` class from the `util` project, we will
    inject it into the constructor, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够使用来自`util`项目的`ServiceUtil`类，我们将通过构造函数注入它，如下所示：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we can implement the API by overriding the `getProduct()` method from
    the interface in the `api` project:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过覆盖`api`项目中的接口的`getProduct()`方法来实现API：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since we aren't currently using a database, we simply return a hardcoded response
    based on the input of `productId`, along with the service address supplied by
    the `ServiceUtil` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前不使用数据库，我们只需根据`productId`的输入返回一个硬编码的响应，加上由`ServiceUtil`类提供的服务地址。
- en: For the final result, including logging and error handling, see `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/src/main/java/se/magnus/microservices/core/product/services/ProductServiceImpl.java`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终结果，包括日志和错误处理，请参阅`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/src/main/java/se/magnus/microservices/core/product/services/ProductServiceImpl.java`。
- en: 'Finally, we also need to set up some runtime properties – what port to use
    and the desired level of logging. This is added to the `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/src/main/resources/application.yml`
    property file:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要设置一些运行时属性——使用哪个端口以及所需的日志级别。这添加到了`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/src/main/resources/application.yml`属性文件中：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can try out the `product` service on its own. Build and start the microservice
    with the following commands:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以尝试单独测试`product`服务。使用以下命令构建并启动微服务：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Wait until the following is printed in the Terminal:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待终端打印以下内容：
- en: '![](img/41540310-c226-4100-ae87-35de5d722d65.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41540310-c226-4100-ae87-35de5d722d65.png)'
- en: 'Make a test call to the `product` service:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`product`服务进行测试调用：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It should respond with something similar to the following:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该响应以下类似的内容：
- en: '![](img/99d66466-5aec-4506-b7ea-c12540ad6ce5.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99d66466-5aec-4506-b7ea-c12540ad6ce5.png)'
- en: 'Finally, stop the `product` service:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，停止`product`服务：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have now built, run, and tested our first single microservice. In the next
    section, we will implement the composite microservice that will use the three
    core microservices that we've created so far.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建、运行并测试了我们的第一个单一微服务。在下一节中，我们将实现一个复合微服务，该服务将使用我们迄今为止创建的三个核心微服务。
- en: Adding a composite microservice
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加复合微服务
- en: Now, it's time to tie things together by adding the composite service that will
    call the three core services!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候通过添加将调用三个核心服务的复合服务来整合一切了！
- en: 'The implementation of the composite services is divided into two parts: an integration
    component that handles the outgoing HTTP requests to the core services and the
    composite service implementation itself. The main reason for this division of
    responsibility is that it simplifies automated unit and integration testing; that
    is, we can test the service implementation in isolation by replacing the integration
    component with a mock.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 复合服务的实现分为两部分：一个处理对核心服务发出的HTTP请求的集成组件和复合服务实现本身。这种责任划分的主要原因是它简化了自动化单元和集成测试；也就是说，我们可以通过用模拟替换集成组件来孤立地测试服务实现。
- en: As we will see later on in this book, this division of responsibility will also
    make it easier to introduce a Circuit Breaker!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这本书后面所看到的，这种责任划分也使得引入断路器变得更容易！
- en: Before we look into the source code of the two components, we need to take a
    look at the API classes that the composite microservices will use and also learn
    about how runtime properties are used to hold address information for the core
    microservices.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入源代码之前，我们需要先了解复合微服务将使用的API类，以及学习运行时属性如何用于持有核心微服务的地址信息。
- en: The full implementation of both the integration component and the implementation
    of the composite service can be found in the `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services` folder.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 两个组件的完整实现，包括集成组件和复合服务的实现，可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services`文件夹中找到。
- en: API classes
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: api 类
- en: 'In this section, we will take a look at the classes that describes the API
    of the composite component. They can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/api`.
    The following are the API classes:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看描述复合组件API的类。它们可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/api`中找到。以下是要查看的API类：
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The Java interface class, `ProductCompositeService.java`, follows the same
    pattern that''s used by the core services and looks as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductCompositeService.java`这个Java接口类遵循与核心服务相同的模式，如下所示：'
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The model class, `ProductAggregate.java`, is a bit more complex than the core
    models since it contains fields for lists of recommendations and reviews:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 模型类`ProductAggregate.java`比核心模型稍微复杂一些，因为它包含推荐和评论的列表字段：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Properties
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'To avoid hardcoding the address information for the core services into the
    source code of the composite microservice, the latter uses a property file where
    information on how to find the core services is stored. The property file can
    be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/resources/application.yml`
    and looks as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在复合微服务的源代码中硬编码核心服务的地址信息，后者使用一个属性文件，其中存储了如何找到核心服务的信息。这个属性文件可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/resources/application.yml`中找到，如下所示：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This configuration will, as already noted, be replaced by a service discovery
    mechanism later on in this book.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置将在本书后面被服务发现机制所取代。
- en: Integration component
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成组件
- en: 'Let''s look at the integration component, `ProductCompositeIntegration.java`.
    It is declared as a Spring Bean using the `@Component` annotation and implements
    the three core services'' API interfaces:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看集成组件`ProductCompositeIntegration.java`。它使用`@Component`注解作为一个Spring Bean声明，并实现了三个核心服务的API接口：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The integration component uses a helper class in Spring Framework, `RestTemplate.java`,
    to perform the actual HTTP requests to the core microservices. Before we can inject
    it into the integration component, we need to configure it. We do that in the
    `main` application class, `ProductCompositeServiceApplication.java`, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 整合组件使用Spring Framework中的一个助手类`RestTemplate.java`来对核心微服务执行实际的HTTP请求。在我们能够将其注入整合组件之前，我们需要对其进行配置。我们是在`main`应用程序类`ProductCompositeServiceApplication.java`中如下完成的：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`RestTemplate` is highly configurable, but we leave it with its default values
    for now.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestTemplate`高度可配置，但我们现在将其保留为其默认值。'
- en: 'We can now inject `RestTemplate`, along with a JSON mapper that''s used for
    error handling and the configuration values that we set up in the property file
    in the constructor of the integration component. Let''s see how this is done:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在整合组件的构造函数中注入`RestTemplate`，以及用于错误处理的JSON映射器和我们 在属性文件中设置的配置值。让我们看看这是如何完成的：
- en: 'The configuration values we use to set up the URLs for the three core services
    are injected into the constructor as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于设置三个核心服务URL的配置值如下所示注入到构造函数中：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The body of the constructor builds the URLs based on the injected values, as
    follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的正文根据注入的值构建URL，如下所示：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, the integration component implements the API methods for the three
    core services by using `RestTemplate` to make the actual outgoing calls:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，整合组件通过使用`RestTemplate`来实际发起调用，实现了三个核心服务的API方法：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: For the `getProduct()` implementation, the `getForObject()` method can be used
    in `RestTemplate`. The expected response is a `Product` object, and it can be
    expressed in the call to `getForObject()` by specifying the `Product.class` class that
    `RestTemplate` will map the JSON response to.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`getProduct()`实现，`RestTemplate`中的`getForObject()`方法可以使用。预期的响应是一个`Product`对象，
    它可以通过在`getForObject()`调用中指定`Product.class`类来表示，`RestTemplate`会将JSON响应映射到这个类。
- en: For the calls to `getRecommendations()` and `getReviews()`, a more advanced
    method, `exchange()`, has to be used. The reason for this is the automatic mapping
    from a JSON response to a model class that `RestTemplate` performs.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`getRecommendations()`和`getReviews()`的调用，必须使用一个更高级的方法，`exchange()`。这是因为`RestTemplate`执行了从JSON响应到模型类的自动映射。
- en: The `getRecommendations()` and `getReviews()` methods expect a generic list
    in the responses, that is, `List<Recommendation>` and `List<Review>`. Since generics
    don't hold any type of information at runtime, we can't specify that the methods
    expect a generic list in their responses. Instead, we can use a helper class from
    the Spring Framework, `ParameterizedTypeReference`, that is designed to resolve
    this problem by holding the type information at runtime. This means that `RestTemplate`
    can figure out what class to map the JSON responses to. To utilize this helper
    class, we have to use the more involved `exchange()` method instead of the simpler `getForObject()` method
    on `RestTemplate`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRecommendations()`和`getReviews()`方法期望在响应中有一个泛型列表，即`List<Recommendation>`和`List<Review>`。由于泛型在运行时
    不持有任何类型信息，我们不能指定方法期望在响应中有泛型列表。相反，我们可以使用Spring Framework中的一个助手类，`ParameterizedTypeReference`，这个类设计用来在运行时持有类型信息，解决
    这个问题。这意味着`RestTemplate`可以弄清楚要将JSON响应映射到哪个类。为了使用这个助手类，我们必须使用更为复杂的 `exchange()`方法而不是`RestTemplate`上的更简单的`getForObject()`方法。'
- en: Composite API implementation
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合API实现
- en: 'Finally, we will look at the last piece of the implementation of the composite
    microservice: the `ProductCompositeServiceImpl.java`. implementation class. Let''s
    go through it step-by-step:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看组合微服务实现的最后一部分：`ProductCompositeServiceImpl.java`实现类。让我们一步步地来看：
- en: 'In the same way that we did for the core services, the composite service implements
    its API interface, `ProductCompositeService`, and is annotated with `@RestController` to
    mark it as a REST service:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与核心服务一样，组合服务实现了其API接口，`ProductCompositeService`，并用`@RestController`注解标记为REST服务：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The implementation class requires the `ServiceUtil` bean and its own integration
    component, so they are injected in its constructor:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类需要`ServiceUtil`bean及其自己的整合组件，所以它们是在其构造函数中注入的：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, the API method is implemented as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，API方法如下实现：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The integration component is used to call the three core services, and a helper
    method, `createProductAggregate()`, is used to create a response object of the `ProductAggregate` type
    based on the responses from the calls to the integration component.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件用于调用三个核心服务，并且使用一个助手方法`createProductAggregate()`，根据对集成组件的调用的响应创建`ProductAggregate`类型的响应对象。
- en: The implementation of the helper method, `createProductAggregate()`, is quite
    lengthy and not very important and so has been omitted from this chapter; however,
    it can be found in this book's source code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 助手方法`createProductAggregate()`的实现相当长，并不是很重要，因此在本章中省略；然而，它可以在本书的源代码中找到。
- en: The full implementation of both the integration component and the composite
    service can be found in the `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services` folder.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件和复合服务的完整实现可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services`文件夹中找到。
- en: That completes the implementation of the composite microservice from a functional
    point of view. In the next section, we will see how we can add source code so
    that we can handle errors.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能角度来看，复合微服务的实现已经完成。在下一节中，我们将了解如何添加源代码以处理错误。
- en: Adding error handling
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加错误处理
- en: Handling errors in a structured and well thought-out way is essential in a microservice
    landscape where a large number of microservices communicate with each other using
    synchronous APIs, for example, using HTTP and JSON. It is also important to separate
    protocol-specific handling of errors, such as HTTP status codes, from the business
    logic.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，大量的微服务通过同步API进行通信，例如使用HTTP和JSON，以结构化和深思熟虑的方式处理错误至关重要。将协议特定的错误处理，如HTTP状态码，与业务逻辑分离也很重要。
- en: It could be argued that a separate layer for the business logic should be added
    when implementing of the microservices. This should ensure that business logic
    is separated from the protocol-specific code, making it easier both to test and
    reuse. To avoid unnecessary complexity in the examples provided in this book,
    we have left out a separate layer for business logic, that is, the microservices
    implement their business logic directly in the `@RestController` components.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现微服务时，可以认为应当添加一个单独的层来处理业务逻辑。这应该确保业务逻辑与协议特定的代码相分离，从而使得测试和重用更加容易。为了避免本书中提供的示例不必要的复杂性，我们省略了业务逻辑的单独层，即微服务直接在`@RestController`组件中实现其业务逻辑。
- en: I have created a set of Java exceptions in the `util` project that are used
    by both the API implementations and the API clients, initially `InvalidInputException`
    and `NotFoundException`. See `$BOOK_HOME/Chapter03/2-basic-rest-services/util/src/main/java/se/magnus/util/exceptions`
    for details.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`util`项目中创建了一套Java异常，这些异常既被API实现使用，也被API客户端使用，最初有`InvalidInputException`和`NotFoundException`。有关详细信息，请参见`$BOOK_HOME/Chapter03/2-basic-rest-services/util/src/main/java/se/magnus/util/exceptions`。
- en: The global REST controller exception handler
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局REST控制器异常处理
- en: To separate protocol-specific error handling from the business logic in the
    REST controllers, that is, the API implementations, I have created a utility class,
    `GlobalControllerExceptionHandler.java`, in the `util` project that's annotated
    as `@RestControllerAdvice`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将协议特定的错误处理从REST控制器中分离，即API实现，我在`util`项目中创建了一个工具类`GlobalControllerExceptionHandler.java`，它被注解为`@RestControllerAdvice`。
- en: For each Java exception that the API implementations throws, the utility class
    has an exception handler method that maps the Java exception to a proper HTTP
    response, that is, with a proper HTTP status and HTTP response body.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API实现抛出的每个Java异常，工具类都有一个异常处理方法，它将Java异常映射到一个适当的HTTP响应，即具有适当的HTTP状态和HTTP响应体。
- en: 'For example, if an API implementation class throws `InvalidInputException`,
    the utility class will map it to an HTTP response with the status code set to
    `422` (`UNPROCESSABLE_ENTITY`). The following code shows this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个API实现类抛出`InvalidInputException`，工具类将其映射为状态码设置为`422`（`UNPROCESSABLE_ENTITY`）的HTTP响应。以下代码展示了这一点：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the same way, `NotFoundException` is mapped to a `404` (`NOT_FOUND`) HTTP
    status code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`NotFoundException`被映射到`404`（`NOT_FOUND`）HTTP状态码。
- en: Whenever a REST controller throws any of these exceptions, Spring will use the
    utility class to create an HTTP response.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时REST控制器抛出这些异常中的任何一个，Spring都会使用实用类来创建一个HTTP响应。
- en: Note that Spring itself returns the HTTP status code `400` ( `BAD_REQUEST`)
    when it detects an invalid request, for example, if the request contains a non-numeric
    product ID (`productId` is specified as an integer in the API declaration).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当Spring检测到无效请求（例如，请求中包含非数字的产品ID）时，它会返回HTTP状态码`400`（`BAD_REQUEST`）。在API声明中，`productId`指定为整数。
- en: For the full source code of the utility class, see `$BOOK_HOME/Chapter03/2-basic-rest-services/util/src/main/java/se/magnus/util/http/GlobalControllerExceptionHandler.java`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实用类的完整源代码，请参阅`$BOOK_HOME/Chapter03/2-basic-rest-services/util/src/main/java/se/magnus/util/http/GlobalControllerExceptionHandler.java`。
- en: Error-handling in API implementations
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API实现中的错误处理
- en: 'API implementations use the exceptions in the `util` project to signal errors.
    They will be reported back to the REST client as HTTPS status codes indicating
    what went wrong. For example, the `Product` microservice implementation class, `ProductServiceImpl.java`,
    uses the `InvalidInputException` exception to return an error that indicates invalid
    input, as well as the `NotFoundException` exception to tell us that the product
    that was asked for does not exist. The code looks as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: API实现使用`util`项目中的异常来表示错误。它们将被报告回REST客户端，作为表明出了什么问题的HTTP状态码。例如，`Product`微服务实现类`ProductServiceImpl.java`使用`InvalidInputException`异常来返回一个指示无效输入的错误，以及使用`NotFoundException`异常告诉我们所请求的产品不存在。代码如下：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Since we currently aren't using a database, we have to simulate when to throw `NotFoundException`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前没有使用数据库，我们必须模拟何时抛出`NotFoundException`。
- en: Error-handling in the API client
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API客户端中的错误处理
- en: 'The API client, that is, the integration component of the `Composite` microservice,
    does the reverse; that is, it maps the `422` (`UNPROCESSABLE_ENTITY`) HTTP status
    code to `InvalidInputException` and the `404` (`NOT_FOUND`) HTTP status code to `NotFoundException`.
    See the `getProduct()` method in `ProductCompositeIntegration.java` for the implementation
    of this error handling logic. The source code looks as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: API客户端，即`Composite`微服务的集成组件，执行的是相反的操作；也就是说，它将`422`（`UNPROCESSABLE_ENTITY`）HTTP状态码映射到`InvalidInputException`，并将`404`（`NOT_FOUND`）HTTP状态码映射到`NotFoundException`。有关此错误处理逻辑的实现，请参阅`ProductCompositeIntegration.java`中的`getProduct()`方法。源代码如下：
- en: '[PRE47]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The error handling for `getRecommendations()` and `getReviews()` in the integration
    component is a bit more relaxed – classed as best-effort, meaning that, if it
    succeeds in getting product information but fails to get either recommendations
    or reviews, it is still considered to be okay. However, a warning is written to
    the log.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 集成组件中`getRecommendations()`和`getReviews()`的错误处理要宽松一些——归类为尽力而为，意思是如果成功获取了产品信息但未能获取推荐信息或评论，仍然认为是可以的。但是，会在日志中写入警告。
- en: For more details, see `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services/ProductCompositeIntegration.java`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息，请参阅`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services/ProductCompositeIntegration.java`。
- en: That completes the implementation of both the code and composite microservices.
    In the next section, we will test the microservices and the API that they expose.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了代码和组合微服务的实现。在下一节中，我们将测试微服务和它们暴露的API。
- en: Testing APIs manually
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试API手动
- en: 'That concludes the implementation of our microservices. Let''s try them out
    by performing the following steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们微服务的实现结束。让我们通过执行以下步骤来尝试它们：
- en: Build and start them up as background processes.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并作为后台进程启动它们。
- en: Use `curl` to call the composite API.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`调用组合API。
- en: Stop them.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止它们。
- en: 'First, build and start-up each microservice as a background process, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，以后台进程的形式构建和启动每个微服务，如下所示：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once the build completes, we can launch our microservices as background processes
    to the Terminal process with the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以使用以下代码将我们的微服务作为后台进程启动到终端进程中：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A lot of log messages will be written to the Terminal, but after a few seconds,
    things will calm down and we will find the following messages written to the log:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 会有很多日志消息被写入终端，但在几秒钟后，事情会平静下来，我们会在日志中找到以下消息：
- en: '![](img/7437d6fb-99f1-4fa9-957b-be6257567694.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7437d6fb-99f1-4fa9-957b-be6257567694.png)'
- en: 'This means that they all are ready to receive requests. Try this out with the
    following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它们都准备好接收请求。用以下代码尝试一下：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After some log output, we will get a JSON response that looks something like
    the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些日志输出，我们将得到一个类似于以下的JSON响应：
- en: '![](img/4cf8525d-ea4f-4c59-99f9-a076421e41dd.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cf8525d-ea4f-4c59-99f9-a076421e41dd.png)'
- en: 'To get the JSON response pretty-printed, you can use the `jq` tool:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得美观的JSON响应，您可以使用`jq`工具：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This results in the following output (some details have been replaced by `...` for
    increased readability):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致以下输出（为了提高可读性，一些细节被`...`替换）：
- en: '![](img/771fc141-de97-432e-af16-a3f1d0f03b70.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/771fc141-de97-432e-af16-a3f1d0f03b70.png)'
- en: 'If you want to, you can also try out the following commands to verify that
    the error handling works as expected:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，还可以尝试以下命令来验证错误处理是否如预期工作：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, you can shut down the microservices with the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用以下命令关闭微服务：
- en: '[PRE53]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you are using either Spring Tool Suite or IntelliJ IDEA Ultimate Edition
    as your IDE, you can use their Spring Boot Dashboard to start and stop your microservices
    with one click.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Spring Tool Suite或IntelliJ IDEA Ultimate Edition作为您的IDE，您可以使用它们的Spring
    Boot仪表板一键启动和停止您的微服务。
- en: 'The following screenshot shows the use of Spring Tool Suite:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了Spring Tool Suite的使用：
- en: '![](img/5017f9b2-a124-4c5a-95fa-cc52247a15e6.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5017f9b2-a124-4c5a-95fa-cc52247a15e6.png)'
- en: 'The following screenshot shows the use of IntelliJ IDEA Ultimate Edition:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了IntelliJ IDEA Ultimate Edition的使用：
- en: '![](img/871261b3-dbde-4c1d-afde-61ca65c7bdca.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/871261b3-dbde-4c1d-afde-61ca65c7bdca.png)'
- en: In this section, we have learned how to manually start, test, and stop the system
    landscape of cooperating microservices. These types of test are time-consuming,
    so they clearly need to be automated. In the next two sections, we will take our
    first steps toward learning how to automate testing, testing both a single microservice
    in isolation and a whole system landscape of cooperating microservices. Throughout
    this book, we will improve how we test our microservices.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何手动启动、测试和停止合作微服务的系统景观。这类测试耗时较长，因此显然需要自动化。在接下来的两节中，我们将迈出学习如何自动化测试的第一步，测试单个微服务以及整个合作微服务的系统景观。在整个本书中，我们将改进我们如何测试微服务。
- en: Preventing slow lookup of the localhost hostname
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止本地主机名查找缓慢
- en: With effect from macOS Sierra, looking up the hostname that's used by the localhost
    in a Java program on a macOS can take a very long time, that is, 5 seconds, making
    tests very slow. The problem seems to be fixed when using macOS Mojave, but if
    you are using an older version of macOS, this can easily be fixed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从macOS Sierra开始，在macOS上的Java程序中查找本地主机使用的hostname可能会花费很长时间，即5秒钟，使得测试变得非常缓慢。在使用macOS
    Mojave时，这个问题似乎得到了修复，但如果您使用的是较老版本的macOS，这个问题很容易解决。
- en: 'First, you need to verify whether the problem affects you by downloading a
    small tool from GitHub and running it:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要通过从GitHub下载一个小型工具并运行它来验证问题是否影响您：
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s say the program responds with something like the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 假设程序响应了类似以下内容：
- en: '![](img/c41f046a-ac2c-4f77-a856-2131fef48987.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c41f046a-ac2c-4f77-a856-2131fef48987.png)'
- en: If you have a response time of 5 seconds, then you have a problem!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有5秒的响应时间，那么您遇到问题了！
- en: 'The solution is to edit the `/etc/hosts` file and add your local hostname,
    which is `Magnuss-Mac.local` in the preceding example, after `localhost`; for
    example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是编辑`/etc/hosts`文件，在`localhost`之后添加您的本地主机名，在前面的示例中是`Magnuss-Mac.local`，例如：
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Rerun the test. It should respond with a response time of a few milliseconds, for
    example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试。它应该以几毫秒的响应时间响应，例如：
- en: '![](img/d1ba5f11-22f1-4ce4-a3fd-03e8486b5e13.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1ba5f11-22f1-4ce4-a3fd-03e8486b5e13.png)'
- en: Now lets see how to add automated tests in isolation for microservices.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何为微服务添加隔离的自动化测试。
- en: Adding automated microservice tests in isolation
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微服务添加隔离的自动化测试
- en: Before we wrap up the implementation, we also need to write some automated tests.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成实现之前，还需要编写一些自动化测试。
- en: We don't have much business logic to test at this time, so we don't need to
    write any unit tests. Instead, we will focus on testing the APIs that our microservices
    expose; that is, we will start them up in integration tests with their embedded
    web server and then use a test client to perform HTTP requests and validate the
    responses. With Spring WebFlux came a new test client, `WebTestClient`, that provides
    a fluent API for making a request and then applying assertions on its result.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们没有太多业务逻辑需要测试，所以不需要编写任何单元测试。相反，我们将重点测试我们微服务暴露的API；也就是说，我们将以集成测试的方式启动它们，带有内嵌的web服务器，然后使用测试客户端执行HTTP请求并验证响应。随着Spring
    WebFlux的推出，出现了一个新的测试客户端`WebTestClient`，它提供了一个流畅的API来发送请求，然后在它的结果上应用断言。
- en: 'The following is an example where we test the composite product API by doing
    the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，我们通过执行以下操作来测试组合产品API：
- en: Sending in `productId` for an existing product and asserting that we get back
    200 as an HTTP response code and a JSON response that contains the requested `productId`
    along with one recommendation and one review
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送一个现有的产品的`productId`，并断言我们得到一个200的HTTP响应码和一个包含所需`productId`以及一个推荐和一个评论的JSON响应。
- en: Sending in a missing `productId` and asserting that we get back 404 as an HTTP
    response code and a JSON response that contains relevant error information
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送一个缺失的`productId`，并断言我们得到一个404的HTTP响应码和一个包含相关错误信息的JSON响应。
- en: 'The implementation for these two tests is shown in the following code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试的实现如下面的代码所示：
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释一下前面的源代码：
- en: The test uses the fluent `WebTestClient` API to set up the URL to call `"/product-composite/"
    + PRODUCT_ID_OK` and specify the accepted response format, JSON.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该测试使用流畅的`WebTestClient` API来设置要调用的URL `"/product-composite/" + PRODUCT_ID_OK`，并指定接受的响应格式，即JSON。
- en: After executing the request using the `exchange()` method, the test verifies
    that the response status is OK (200) and that the response format actually is
    JSON (as requested).
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用`exchange()`方法执行请求后，测试验证响应状态是OK（200）并且实际的响应格式确实是JSON（如所请求的）。
- en: Finally, the test inspects the response body and verifies that it contains the
    expected information in terms of `productId` and the number of recommendations
    and reviews.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，该测试检查响应体，并验证它包含了关于`productId`以及推荐次数和评论数预期的信息。
- en: 'The second test looks as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试如下所示：
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释一下前面的源代码：
- en: This negative test is very similar to the preceding test in terms of its structure;
    the main difference is that it verifies that it got an error status code back,
    Not Found (404), and that the response body contains the expected error message.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个负测试在结构上与前面的测试非常相似；主要区别是它验证了返回了一个错误状态码，未找到（404），并且响应体包含了预期的错误消息。
- en: 'To test the composite product API in isolation, we need to mock its dependencies,
    that is, the requests to the other three microservices that were performed by
    the integration component, `ProductCompositeIntegration`. We use Mockito to do
    this, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了单独测试组合产品API，我们需要模拟其依赖项，即由集成组件`ProductCompositeIntegration`执行的对其他三个微服务的请求。我们使用Mockito来实现，如下所示：
- en: '[PRE58]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释一下前面的源代码：
- en: First, we declare three constants that are used in the test class: `PRODUCT_ID_OK`,
    `PRODUCT_ID_NOT_FOUND`, and `PRODUCT_ID_INVALID`.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们在测试类中声明了三个常量，分别用于`PRODUCT_ID_OK`、`PRODUCT_ID_NOT_FOUND`和`PRODUCT_ID_INVALID`。
- en: If the `getProduct()`, `getRecommendations()`, and `getReviews()` methods are
    called on the integration component, and `productId` is set to `PRODUCT_ID_OK`,
    the mock will return a normal response.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对集成组件调用`getProduct()`、`getRecommendations()`和`getReviews()`方法，并且`productId`设置为`PRODUCT_ID_OK`，则模拟将返回一个正常响应。
- en: If the `getProduct()` method is called with `productId` set to `PRODUCT_ID_NOT_FOUND`,
    the mock will throw `NotFoundException`.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`getProduct()`方法以`PRODUCT_ID_NOT_FOUND`设置`productId`，则模拟将抛出`NotFoundException`。
- en: If the `getProduct()` method is called with `productId` set to `PRODUCT_ID_INVALID`,
    the mock will throw `InvalidInputException`.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果以`PRODUCT_ID_INVALID`设置`productId`调用`getProduct()`方法，则模拟将抛出`InvalidInputException`。
- en: The full source code for the automated integration tests on the composite product
    API can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/test/java/se/magnus/microservices/composite/product/ProductCompositeServiceApplicationTests.java`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/test/java/se/magnus/microservices/composite/product/ProductCompositeServiceApplicationTests.java`找到对复合产品
    API 的自动化集成测试的完整源代码。
- en: The automated integration tests on the API exposed by the three core microservices
    are similar, but simpler since they don't need to mock anything! The source code
    for the tests can be found in each microservice's `test` folder.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 三个核心微服务暴露的 API 上的自动化集成测试类似，但更简单，因为它们不需要模拟任何内容！测试的源代码可以在每个微服务的`test`文件夹中找到。
- en: 'The tests are run automatically by Gradle when performing a build:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行构建时，Gradle 会自动运行测试：
- en: '[PRE59]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can, however, specify that you only want to run the tests (and not the
    rest of the build):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以指定只想运行测试（而不执行构建的其余部分）：
- en: '[PRE60]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This was an introduction to how to write automated tests for microservices in
    isolation. In the next section, we will learn how to write tests that automatically
    test a microservice landscape. In this chapter, these tests will only be semi-automated.
    In upcoming chapters, the tests will be fully automated, a significant improvement.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这是介绍如何为微服务编写隔离测试的介绍。在下一节中，我们将学习如何编写自动测试整个微服务景观的测试。在本章中，这些测试将是半自动化的。在后续章节中，测试将完全自动化，这是一个显著的改进。
- en: Adding semi-automated tests of a microservice landscape
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对微服务景观的半自动化测试
- en: Being able to automatically test each microservice in isolation is, of course,
    very useful, but insufficient!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，能够自动测试每个微服务是很有用的，但不够！
- en: We need a way to automatically test all of our microservices to ensure that
    they deliver what we expect!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种自动测试所有微服务的方法，以确保它们提供我们所期望的内容！
- en: For this reason, I have written a simple bash script that can perform calls
    to a RESTful API using `curl` and verify its return code and parts of its JSON
    response using `jq`. The script contains two helper functions, `assertCurl()`
    and `assertEqual()`, to make the test code compact and easier to read.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我编写了一个简单的 bash 脚本，可以使用 `curl` 对 RESTful API 进行调用并验证其返回代码及其 JSON 响应的一部分，使用
    `jq`。脚本包含两个辅助函数，`assertCurl()` 和 `assertEqual()`，以使测试代码更加紧凑，易于阅读。
- en: 'For example, making a normal request and expecting 200 as the status code,
    as well as asserting that we get back a JSON response that returns the requested
    `productId` along with three recommendations and three reviews, looks like the
    following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，发送一个正常请求，期望状态码为200，以及断言我们返回的 JSON 响应返回请求的`productId`，还附带三个推荐和三个评论，如下所示：
- en: '[PRE61]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Verifying that we get `404 (Not Found)` back as an HTTP response code (when
    we try to look up a product that doesn''t exist) looks as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 验证我们返回`404 (Not Found)`作为 HTTP 响应代码（当我们尝试查找不存在的产品）如下所示：
- en: '[PRE62]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The test script implements the manual tests that were described in the *Testing
    APIs manually* section and can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/test-em-all.bash`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本实现了在*手动测试 API*部分描述的手动测试，可以在`$BOOK_HOME/Chapter03/2-basic-rest-services/test-em-all.bash`找到。
- en: Trying out the test script
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试测试脚本
- en: 'To try out the test script, perform the following steps:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试测试脚本，执行以下步骤：
- en: 'First, start the microservices, as we did previously:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，像以前一样启动微服务：
- en: '[PRE63]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once they''ve all started up, run the test script:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦它们都启动完毕，运行测试脚本：
- en: '[PRE64]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Expect the output to look similar to the following:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望输出如下所示：
- en: '![](img/34c2f31c-8138-4f03-9414-cfb4c0779f29.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34c2f31c-8138-4f03-9414-cfb4c0779f29.png)'
- en: 'Wrap this up by shutting down the microservices with the following command:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下命令关闭微服务：
- en: '[PRE65]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this section, we have taken the first steps toward automating testing a system
    landscape of cooperating microservices, all of which will be improved in upcoming
    chapters.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们迈出了自动化测试合作微服务系统景观的第一步，所有这些都将在本章后续部分进行改进。
- en: Summary
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have now built our first few microservices using Spring Boot. After being
    introduced to the microservice landscape, which we will use throughout this book,
    we learned how to use Spring Initializr to create skeleton projects for each microservice.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用 Spring Boot 构建了我们的几个微服务。在介绍了我们将在此书中使用的微服务景观之后，我们学习了如何使用 Spring Initializr
    创建每个微服务的骨架项目。
- en: Next, we learned how to add APIs using Spring WebFlux for the three core services
    and implemented a composite service that uses the three core services APIs to
    create an aggregated view of the information in them. The composite service uses
    the `RestTemplate` class in Spring Framework to perform HTTP requests to APIs
    that are exposed by the core services. After adding logic for error handling in
    the services, we ran some manual tests on the microservice landscape.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何使用Spring WebFlux为三个核心服务添加API，并实现了一个组合服务，该服务使用三个核心服务的API来创建它们中信息的聚合视图。组合服务使用Spring
    Framework中的`RestTemplate`类来对核心服务公开的API执行HTTP请求。在为服务添加错误处理逻辑后，我们在微服务架构上进行了一些手动测试。
- en: We wrapped this chapter up by learning how to add tests for microservices in
    isolation and when they work together as a system landscape. To provide controlled
    isolation for the composite service, we mocked its dependencies to the core services
    using Mockito. Testing the whole system landscape is performed by a bash script
    that uses `curl` to perform calls to the API of the composite service.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习如何在隔离环境中为微服务添加测试以及它们作为一个系统架构一起工作时的测试来结束这一章。为了为组合服务提供受控的隔离，我们使用Mockito模拟其对核心服务的依赖。整个系统架构的测试是通过一个bash脚本完成的，该脚本使用`curl`对组合服务的API执行调用。
- en: With these skills in place, we are ready to take the next step, entering the
    world of Docker and containers, in the next chapter! Among other things, we will
    learn how to use Docker to fully automate testing of a system landscape of cooperating
    microservices.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些技能，我们准备好了下一步，进入下一章的Docker和容器世界！在接下来的内容中，我们将学习如何使用Docker完全自动化测试一个合作微服务的系统架构。
- en: Questions
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the command that lists available dependencies when you create a new
    Spring Boot project using the `spring init` Spring Initializr CLI tool?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**spring init** Spring Initializr CLI工具创建新的Spring Boot项目时，列出可用依赖项的命令是什么？
- en: How can you set up Gradle to build multiple related projects with one command?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何设置**Gradle**，用一个命令就能构建多个相关联的项目？
- en: What are the `@PathVariable` and `@RequestParam` annotations used for?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@PathVariable`和`@RequestParam`注解是用来做什么的？'
- en: How can you separate protocol-specific error handling from the business logic
    in an API implementation class?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在API实现类中，你如何将协议特定的错误处理与业务逻辑分开？
- en: What is Mockito used for?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Mockito**是用来做什么的？'
