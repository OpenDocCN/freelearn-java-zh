- en: Chapter 5. Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 人工智能
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Creating a reusable AI control class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用的AI控制类
- en: Sensing – vision
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感知 - 视觉
- en: Sensing – hearing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感知 - 听觉
- en: Decision making – Finite State Machine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策 - 有限状态机
- en: Creating the AI using cover
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用遮蔽创建AI
- en: Generating NavMesh in SDK
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SDK中生成NavMesh
- en: Pathfinding – using NavMesh
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻路 - 使用NavMesh
- en: Controlling groups of AI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制AI群体
- en: Pathfinding – our own A* pathfinder
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻路 - 我们自己的A*寻路器
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Artificial Intelligence** (**AI**) is an extremely vast field. Even for games
    it can be very diverse, depending on the type of game and requirements.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**（**AI**）是一个极其广泛的领域。即使是对于游戏来说，它也可以非常多样化，这取决于游戏类型和需求。'
- en: Many developers enjoy working with AI. It gives you a sense of creating something
    alive, something intelligent, and rational. A good question to ask before designing
    AI for a game is what the expected behavior should be, from a player's perspective.
    In an FPS, it might be the case that the AI can separate the friend from the foe,
    find cover when attacked, flee when injured, and not get stuck on things as they
    move around. AI in an RTS might need to not only evaluate the current situation,
    but also plan ahead and divide resources between aggressive and defensive behavior.
    A group of soldiers and a tactical shooter might have advanced and dynamic group
    behavior. Another option is to have individual behaviors that still make them
    appear to work together, to the player.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者喜欢与AI一起工作。它让你有一种创造生命、智能和理性的感觉。在设计游戏AI之前，一个很好的问题是，从玩家的角度来看，预期的行为应该是什么。在一个FPS游戏中，AI可能需要区分朋友和敌人，在攻击时寻找掩护，受伤时逃跑，并且在移动时不会卡在东西上。在RTS中的AI可能不仅需要评估当前情况，还需要提前规划并在进攻和防御行为之间分配资源。一组士兵和战术射击手可能具有高级和动态的群体行为。另一种选择是拥有个体行为，但仍然让玩家觉得它们似乎在协同工作。
- en: The recipes in this chapter will, in most cases, work with isolated functionality,
    but revolve around a central AI control class. As such, the results might not
    always be impressive on their own, but at the same time, it should be quite easy
    to combine several of them into a more powerful AI.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的配方在大多数情况下将与独立功能一起工作，但围绕一个中央AI控制类展开。因此，结果可能并不总是那么令人印象深刻，但同时，将几个它们组合成一个更强大的AI应该相当容易。
- en: Creating a reusable AI control class
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用的AI控制类
- en: In this recipe, we will create a control that is going to steer an AI character.
    Using `Control` to do this is beneficial since it can add the AI functionality
    and be used together with other `Controls` in the game. We can use `GameCharacterControl`
    from [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras and
    Game Controls* for both the player and AI characters by adding `AIControl` to
    its spatial. To get a quick and visual result, we'll apply it to the bullet-based
    `BetterCharacterControl` class in this recipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个控制，用于控制AI角色。使用`Control`来做这件事是有益的，因为它可以添加AI功能，并且可以与游戏中的其他`Controls`一起使用。我们可以通过向其空间添加`AIControl`来使用[第2章](ch02.html
    "第2章. 相机与游戏控制")中的`GameCharacterControl`，*相机与游戏控制*，为玩家和AI角色提供支持。为了获得快速和直观的结果，我们将在这个配方中将它应用于基于子弹的`BetterCharacterControl`类。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We need to perform the following steps to get a basic, but functional attacking
    (or following) AI:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一个基本但功能性的攻击（或跟随）AI，我们需要执行以下步骤：
- en: 'We begin by creating a new class called `AIControl`, extending `AbstractControl`.
    The core of the recipe will be based around an enum (enumeration) called `state`.
    For now it only needs two values: `Idle` and `Follow`.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的类，称为`AIControl`，它扩展了`AbstractControl`。这个配方的核心将围绕一个名为`state`的枚举（枚举）展开。目前它只需要两个值：`Idle`和`Follow`。
- en: Add fields for `BetterCharacterControl`, called `physicsCharacter`, Booleans
    `forward` and `backwards`, a `Vector3f` field for `walkDirection`, and another
    for `viewDirection`. If it's going to follow something, it also needs a `target`
    field, which can be `Spatial`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`BetterCharacterControl`添加字段，称为`physicsCharacter`，布尔值`forward`和`backwards`，一个用于`walkDirection`的`Vector3f`字段，以及另一个用于`viewDirection`的字段。如果它要去跟随某个东西，它还需要一个`target`字段，它可以是一个`Spatial`。
- en: 'The bulk of the logic is carried out in a `switch` statement in the `controlUpdate`
    method, as shown in the following code. The first case is `Idle`. In this case,
    the AI shouldn''t do anything:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑的大部分都在`controlUpdate`方法中的`switch`语句中执行，如下面的代码所示。第一个情况是`Idle`。在这种情况下，AI不应该做任何事情：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `Follow` case, we should first check whether `target` is set. If there
    is a target, we find the direction to the target and make the AI face it by setting
    `viewDirection`, as shown in the following code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Follow`情况下，我们首先检查`target`是否已设置。如果有目标，我们找到到目标的方向，并通过设置`viewDirection`使AI面向它，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We check the distance to the target. If it''s more than `5` the AI will try
    to get closer. If the distance instead is less than `3`, it will try to back up
    a bit. The AI can also lose track of the target if it is more than 20 units away.
    In this case, it also changes state to `Idle`, as shown in the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查到目标的位置。如果距离超过`5`，AI将尝试靠近。如果距离小于`3`，它将尝试后退一点。如果AI距离目标超过20个单位，它也可能失去目标。在这种情况下，它也会将状态更改为`Idle`，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When it comes to movement, we can get the forward facing direction with the
    following line of code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到移动时，我们可以使用以下代码行获取面向前方的方向：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Depending on whether forward or backward is true, we can multiply this value
    with a suitable movement speed, and the call `setWalkDirection` on the `BetterCharacterControl`
    class with the result shown in the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据向前或向后是否为真，我们可以将此值乘以合适的移动速度，并在`BetterCharacterControl`类上调用`setWalkDirection`，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we should also call `setViewDirection`, as shown in the following
    code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还应该调用`setViewDirection`，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using `BetterCharacterControl`, we get a lot of functionality for free. We only
    need a couple of Booleans to keep track of movement, and two `Vector3f` instances
    for directions. Target is what the AI will focus on (or follow, for now).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BetterCharacterControl`，我们可以免费获得很多功能。我们只需要几个布尔值来跟踪移动，以及两个`Vector3f`实例来表示方向。目标是指AI将关注的对象（或目前跟随的对象）。
- en: If we're familiar with `TestBetterCharacter` from jMonkeyEngine's test examples,
    we can recognize the movement handling from that class. For now, we only use the
    `forward`/`backward` functionality. It is a good idea to keep the rotation code
    as well, just in case we would like it to turn more smoothly in the future. The
    `walkDirection` vector is `0` by default. It can either be sent as it is sent
    to `physicsCharacter`, in which case the character will stop, or be modified to
    move in either direction. The `viewDirection` vector is simply set to look at
    the target for now, and passed on to `physicsCharacter`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们熟悉jMonkeyEngine测试示例中的`TestBetterCharacter`，我们可以从该类中识别出运动处理。目前，我们只使用`forward`/`backward`功能。保留旋转代码也是一个好主意，以防我们将来希望它转动得更平滑。`walkDirection`向量默认为`0`。它可以像发送给`physicsCharacter`一样发送，在这种情况下，角色将停止，或者修改为向任一方向移动。`viewDirection`向量目前简单地设置为指向目标，并传递给`physicsCharacter`。
- en: The logic in the `Follow` case mentioned previously is mostly there to have
    something to test with. Even so, it's AI behavior that seems to be sufficient
    for many MMOs. Once a target has been acquired, it will try to keep itself at
    a certain distance. It can also lose track of the target if it gets too far away.
    In this case, it falls back to the `Idle` state.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的`Follow`情况中的逻辑主要是为了测试。即便如此，它似乎对于许多MMO游戏中的AI行为是足够的。一旦获取了目标，它将尝试保持一定的距离。如果它离得太远，它也可能失去目标。在这种情况下，它将回退到`Idle`状态。
- en: There's more…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: By linking this recipe together with [Chapter 4](ch04.html "Chapter 4. Mastering
    Character Animations"), *Mastering Character Animations*, we can easily make Jaime
    play some animations while he's moving.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这个食谱与[第4章](ch04.html "第4章. 掌握角色动画")《掌握角色动画》联系起来，我们可以轻松地让杰伊姆在移动时播放一些动画。
- en: 'Start by adding the `AnimationManagerControl` class to the AI character using
    the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下代码将`AnimationManagerControl`类添加到AI角色中：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We need to tell it to play animations. In `AIControl`, find the forward and
    backwards brackets inside the `controlUpdate` method and add the following lines:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要告诉它播放动画。在`AIControl`中，找到`controlUpdate`方法中的前后括号，并添加以下行：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's more…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s create a test case world we can use for both this and many of the following
    recipes. First we need a world with physics:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个我们可以用于这个和许多后续食谱的测试案例世界。首先，我们需要一个具有物理特性的世界：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will need some kind of object to stand on. The `PhysicsTestHelper` class
    has a few example worlds we can use.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个可以站立的物体。`PhysicsTestHelper`类有几个我们可以使用的示例世界。
- en: 'We load up good old Jaime. Again, we use the `BetterCharacterControl` class
    since it offloads a lot of code for us. Since the Bullet physics world is different
    from the ordinary scenegraph, Jaime is added to `physicsSpace` as well as to the
    `rootNode`, as shown in the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次加载Jaime。我们再次使用`BetterCharacterControl`类，因为它为我们卸载了大量代码。由于Bullet物理世界与普通场景图不同，Jaime被添加到`physicsSpace`以及`rootNode`中，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also need to add our newly created AI control using the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用以下代码添加我们新创建的AI控制：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There''s one more thing we need to do for this to work. The AI needs to track
    something. The easiest way we can get a moving target is to add a `CameraNode`
    class and supply `cam` from the application, as shown in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做一件事才能让它工作。AI需要跟踪某些东西。我们获取移动目标的最简单方法是为`CameraNode`类添加一个类，并从应用程序中提供`cam`，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We set `camNode` to be the target, as shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`camNode`设置为目标，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we're familiar with cameras in OpenGL, we know they don't really have a physical
    existence. A `CameraNode` class in jMonkeyEngine gives us that. It tracks the
    camera's position and rotation, giving us something easy to measure. This will
    make it easier for us when we want the AI to follow it, since we can use the convenience
    of it being spatial.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们熟悉OpenGL中的相机，我们知道它们实际上并没有物理存在。jMonkeyEngine中的`CameraNode`类给了我们这样的功能。它跟踪相机的位置和旋转，给我们提供了一个容易测量的东西。这将使我们在想让AI跟随它时更容易，因为我们可以使用其空间上的便利性。
- en: For this reason, we can set `CameraNode` to be its target.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将`CameraNode`设置为它的目标。
- en: Sensing – vision
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感应 – 视觉
- en: 'No matter how clever our AI is, it needs some senses to become aware of its
    surroundings. In this recipe, we''ll accomplish an AI that can look in a configurable
    arc in front of it, as shown in the following screenshot. It will build upon the
    AI control from the previous recipe, but the implementation should work well for
    many other patterns as well. The following screenshot shows Jaime with a visible
    representation of his line of sight:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的AI多么聪明，它都需要一些感官来感知其周围环境。在这个菜谱中，我们将实现一个AI，它可以在其前方配置的弧形内查看，如下面的屏幕截图所示。它将基于前一个菜谱中的AI控制，但实现应该适用于许多其他模式。以下屏幕截图显示了Jaime及其视线的一个可见表示：
- en: '![Sensing – vision](img/6478OS_05_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![感应 – 视觉](img/6478OS_05_01.jpg)'
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To get our AI to sense something, we need to modify the `AIControl` class from
    the previous recipe by performing the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的AI感知到某些东西，我们需要通过以下步骤修改前一个菜谱中的`AIControl`类：
- en: We need to define some values, a float called `sightRange`, for how far the
    AI can see, and an angle representing the field of view (to one side) in radians.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定义一些值，一个名为`sightRange`的浮点数，表示AI可以看到多远，以及一个表示视野（到一侧）的弧度角度。
- en: With this done, we create a `sense()` method. Inside we define a Quaternion
    called `aimDirection` that will be the ray direction relative to the AI's `viewDirection`
    field.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，我们创建一个`sense()`方法。在内部，我们定义一个名为`aimDirection`的四元数，它将是相对于AI的`viewDirection`字段的射线方向。
- en: 'We convert the angle to a Quaternion and multiply it with `viewDirection` to
    get the direction of the ray, as shown in the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将角度转换为四元数，并将其与`viewDirection`相乘以获得射线的方向，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We check whether the ray collides with any of the objects in our `targetableObjects`
    list using the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下代码检查射线是否与我们的`targetableObjects`列表中的任何对象发生碰撞：
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If this happens, we set the target to be this object and exit the sensing loop,
    as shown in the following code. Otherwise, it should continue searching for it:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生这种情况，我们将目标设置为该对象并退出感应循环，如下面的代码所示。否则，它应该继续寻找它：
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the sense method returns true, the AI now has a target, and should switch
    to the `Follow` state. We add a check for this in the `controlUpdate` method and
    the `Idle` case, as shown in the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果感应方法返回true，AI现在有一个目标，应该切换到`Follow`状态。我们在`controlUpdate`方法和`Idle`情况中添加了这个检查，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The AI begins in an idle state. As long as it has some items in the `targetableObjects`
    list, it will run the `sense` method on each update. If it sees anything, it will
    switch to the `Follow` state and stay there until it loses track of the target.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: AI开始于空闲状态。只要它在`targetableObjects`列表中有一些项目，它就会在每次更新时运行`sense`方法。如果它看到任何东西，它将切换到`Follow`状态并保持在那里，直到它失去对目标的跟踪。
- en: The `sense` method consists of a `for` loop that sends rays in an arc representing
    a field of view. Each ray is limited by `sightRange` and the loop will exit if
    a ray has collided with anything from the `targetableObjects` list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`sense`方法由一个`for`循环组成，该循环发送代表视野的弧形射线。每条射线都受限于`sightRange`，如果射线与`targetableObjects`列表中的任何物体发生碰撞，循环将退出。'
- en: There's more…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Currently, it''s very difficult to visualize the results. Exactly what does
    the AI see? One way of finding out is to create `Lines` for each ray we cast.
    These should be removed before each new cast. By following this example, we will
    be able to see the extent of the vision. The following steps will give us a way
    of seeing the extent of an AI''s vision:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，可视化结果非常困难。AI到底看到了什么？一种找出答案的方法是为我们发射的每条射线创建`Lines`。这些应该在每次新的发射之前被移除。通过遵循这个例子，我们将能够看到视野的范围。以下步骤将给我们提供一种看到AI视野范围的方法：
- en: 'First of all, we need to define an array for the lines; it should have the
    same capacity as the number of rays we''re going to cast. Inside the `for` loop,
    add the following code at the start and end:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义一个用于线条的数组；它应该有我们将要发射的射线的数量相同的容量。在`for`循环中，在开始和结束时添加以下代码：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `makeDebugLine` method that we mentioned previously will look like the
    following code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前提到的`makeDebugLine`方法将如下所示：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This simply takes each ray and makes something that can be seen by human eyes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地取每条射线并使其成为人眼可见的东西。
- en: Sensing – hearing
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感知 - 听觉
- en: The hearing we'll implement is one of the more basic models you can have. It's
    not as direct as vision, and requires a different approach. We'll assume that
    hearing is defined by `hearingRange`, and that the hearing ability has a linear
    fall off to that radius. We'll also assume that the sound emits something (in
    this case, footsteps), the volume of which is relative to the object's velocity.
    This would make sense in a stealth game, where sneaking should emit less sound
    than running. Sound is not blocked by obstacles or modified in any other way,
    apart from the distance between the target and the listener.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的听觉是你可以拥有的更基本模型之一。它不像视觉那样直接，需要不同的方法。我们将假设听觉由`hearingRange`定义，并且听觉能力以线性衰减到该半径。我们还将假设声音发出某种东西（在这种情况下，脚步声），其音量与对象的速率成正比。这在潜行游戏中是有意义的，因为潜行应该比跑步发出更少的声音。声音不会被障碍物阻挡或以任何其他方式修改，除了目标和听者之间的距离。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will start by defining a class that all objects emitting sounds will use.
    This will require the following steps to be performed:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个所有发出声音的对象都将使用的类。这需要执行以下步骤：
- en: We create a class called `SoundEmitterControl`, extending `AbstractControl`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`SoundEmitterControl`的类，它扩展了`AbstractControl`。
- en: It needs three fields, a `Vector3f` called `lastPosition`, a float for `noiseEmitted`,
    and another float called `maxSpeed`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要三个字段，一个名为`lastPosition`的`Vector3f`，一个用于`noiseEmitted`的浮点数，以及另一个名为`maxSpeed`的浮点数。
- en: 'In the `controlUpdate` method, we sample the velocity the spatial has. This
    is the distance between the current `worldTranslation` and `lastPosition`. Divided
    by `tpf` (time-per-frame) we get the distance per second, as shown in the following
    code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法中，我们采样空间的速度。这是当前`worldTranslation`和`lastPosition`之间的距离。除以`tpf`（每帧时间）我们得到每秒的距离，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If it''s actually moving, we see how much it moves compared to `maxSpeed`.
    Normalized between 0 and 1, this value becomes `noiseEmitted`, as shown in the
    following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它实际上在移动，我们将看到它与`maxSpeed`相比移动了多少。在0和1之间归一化，这个值成为`noiseEmitted`，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we set `lastPosition` to current `worldTranslation`. Now we will implement
    the changes to detect sound in `AIControl`. This will have five steps. We start
    by defining a float called `hearingRange`. In the `sense()` method, we parse the
    list of `targetableObjects` and see if they have `SoundEmitterControl`. If any
    does, we check the distance between it and the AI using the following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`lastPosition`设置为当前的`worldTranslation`。现在我们将实现检测`AIControl`中的声音的更改。这将有五个步骤。我们首先定义一个名为`hearingRange`的浮点数。在`sense()`方法中，我们解析`targetableObjects`列表，看看它们是否有`SoundEmitterControl`。如果有，我们使用以下代码检查它与AI之间的距离：
- en: '[PRE21]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We get the `noiseEmitted` value from `SoundEmitterControl` and see how much
    is picked up by the AI, as shown in the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`SoundEmitterControl`获取`noiseEmitted`值，并查看AI接收了多少，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the threshold of 0.25f is exceeded, the AI has heard the sound and will react.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果阈值0.25f被超过，AI已经听到了声音，并将做出反应。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `SoundEmitterControl` class is meant to define how much sound a moving character
    makes. It does this by measuring the distance traveled each frame, and translates
    it to speed per second by dividing by the time-per-frame. It's been adapted slightly
    to work for the free-flying camera used in the test case. That's why `maxSpeed`
    is set to `25`. It uses `maxSpeed` to define how much noise the spatial is causing,
    on a scale of `0` to `1`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundEmitterControl` 类旨在定义移动角色产生的声音量。它是通过测量每一帧行进的距离，并通过除以每帧时间来将其转换为每秒速度来实现的。它已经稍作调整以适应测试用例中使用的自由飞行相机。这就是为什么
    `maxSpeed` 被设置为 `25`。它使用 `maxSpeed` 来定义空间产生的噪声量，其范围在 `0` 到 `1` 之间。'
- en: In the AI control class, we use the `sense()` method to test whether the AI
    has heard anything. It has a `hearingRange` field, with the range falling in a
    linear fashion from the location of the AI. Outside this range, no sound would
    be detected by the AI.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能控制类中，我们使用 `sense()` 方法来测试人工智能是否听到了什么。它有一个 `hearingRange` 字段，其范围从人工智能的位置线性下降。在此范围之外，人工智能不会检测到任何声音。
- en: The method measures the distance from the sound emitting spatial, and factors
    this with the noise value it emits. For this example, a threshold of 0.25 is used
    to define whether the sound is loud enough for the AI to react.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法测量从声音发出空间到距离，并将其与发出的噪声值相乘。对于这个例子，使用 0.25 的阈值来定义声音是否足够响亮以使人工智能做出反应。
- en: Decision making – Finite State Machine
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决策制作 – 有限状态机
- en: Decision making for AI can be handled in many different ways, and one common
    way is to use a **Finite State Machine** (**FSM**). An FSM contains a number of
    predefined states. Each state has a set of functionality and behavior tied to
    it. Each state also has a number of conditions for when it can change to another
    state.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能的决策可以以许多不同的方式处理，其中一种常见的方式是使用 **有限状态机**（**FSM**）。FSM 包含多个预定义的状态。每个状态都有一组与之相关的功能和行为。每个状态也有多个条件，用于确定它何时可以转换为另一个状态。
- en: In this recipe, we'll define a state machine that will emulate a common AI behavior
    in games. In fact, it will be more advanced than many games, which usually have
    AI that can only either move around on a path, or attack. Our AI will have three
    states, **Patrol**, **Attack**, and **Retreat**, as shown in the following diagram:.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将定义一个状态机，它将模拟游戏中常见的常见人工智能行为。实际上，它将比许多游戏更先进，因为许多游戏的人工智能只能沿着路径移动或攻击。我们的人工智能将具有三个状态，**巡逻**、**攻击**和**撤退**，如下面的图所示：
- en: '![Decision making – Finite State Machine](img/6478OS_05_02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![决策制作 – 有限状态机](img/6478OS_05_02.jpg)'
- en: State diagram
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 状态图
- en: The `PatrolState` will be the default and fallback state. It will perform random
    movement and will switch to `AttackState` if it spots an enemy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`PatrolState` 将是默认和回退状态。它将执行随机移动，并在发现敌人时切换到 `AttackState`。'
- en: The `AttackState` will handle firing and ammunition and will attack a target
    as long as it's visible and it has ammunition left. Then it will either return
    to `PatrolState` or flee using `RetreatState`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttackState` 将处理射击和弹药，只要目标可见并且有剩余弹药，它就会攻击目标。然后它将返回到 `PatrolState` 或使用 `RetreatState`
    逃跑。'
- en: The `RetreatState` will try to get away from a target for a set amount of time.
    After this, it will return to `PatrolState`, forgetting any fears it might previously
    have had.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`RetreatState` 将尝试在设定的时间内逃离目标。之后，它将返回到 `PatrolState`，忘记它可能之前拥有的任何恐惧。'
- en: All of our states will extend an abstract class called `AIState`, which we will
    also create in this recipe. This class in turn extends `AbstractControl`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有状态都将扩展一个名为 `AIState` 的抽象类，我们也将在这个菜谱中创建它。这个类反过来又扩展了 `AbstractControl`。
- en: Worth noting is that all AI decision making and actions are handled from within
    the states. The states only relies on the AI control class to supply it with sensing
    updates (although this could also be handled by the states themselves).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，所有人工智能决策和动作都是在状态内部处理的。状态只依赖于人工智能控制类来提供它感知更新（尽管这也可以由状态本身处理）。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will start by creating the `AIState` class. This will have two steps, as
    follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建 `AIState` 类。这将有两个步骤，如下所示：
- en: We add a field to store `AIControl` and give it two abstract methods called
    `stateEnter` and `stateExit`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个字段来存储 `AIControl`，并给它提供了两个名为 `stateEnter` 和 `stateExit` 的抽象方法。
- en: 'These should be triggered when enabling and disabling the class, respectively.
    We override `setEnabled` to achieve this, as shown in the following code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些应该在启用和禁用类时触发。我们通过重写 `setEnabled` 来实现这一点，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With `AIState` done, we can look at the first behavior, `PatrolState`. We can
    implement this by performing the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当`AIState`完成时，我们可以查看第一个行为，`PatrolState`。我们可以通过以下步骤来实现它：
- en: First of all we add a `Vector3f` field called `moveTarget`. This is the position
    it will try to reach, relative to the current position.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加一个名为`moveTarget`的`Vector3f`字段。这是它将尝试到达的位置，相对于当前位置。
- en: 'We add an `if` statement with three outcomes in the `controlUpdate` method,
    which is the main bulk of the logic in the class. The first clause should disable
    it and enable the `AttackState` if `AIControl` has found a suitable target using
    the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`controlUpdate`方法中添加一个有三个结果的`if`语句，这是类中逻辑的主要部分。第一个子句应该禁用它并启用`AttackState`，如果`AIControl`已经使用以下代码找到了一个合适的目标：
- en: '[PRE24]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If its location is close enough to the `moveTarget` vector, it should pick
    a new one nearby, as shown in the following code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它的位置足够接近`moveTarget`向量，它应该选择附近的一个新位置，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Otherwise, it should keep moving towards the target, as shown in the following
    code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，它应该继续向目标移动，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, in the `stateExit` method, we should make it stop moving using the
    following code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`stateExit`方法中，我们应该让它停止移动，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'That''s one state out of three; let''s look at the `AttackState`. We can implement
    this by performing the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经完成了三个状态中的一个；让我们看看`AttackState`。我们可以通过以下步骤来实现它：
- en: The `AttackState` keeps track of values related to firing. It needs to have
    a float for `fireDistance`, which is how far the AI can fire; an integer called
    `clip`, which is how many rounds it has in the current clip; another integer called
    `ammo`, which defines how many rounds it has in total; and finally, a float called
    `fireCooldown`, which defines the time between each shot the AI fires.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AttackState`跟踪与开火相关的值。它需要一个名为`fireDistance`的浮点数，这是AI可以开火的范围；一个名为`clip`的整数，表示当前弹夹中的弹药量；另一个名为`ammo`的整数，定义了总共的弹药量；最后，一个名为`fireCooldown`的浮点数，定义了AI每次开火之间的时间。'
- en: 'In the `stateEnter` method, we give the AI some ammunition. This is mostly
    for testing purposes, as shown in the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stateEnter`方法中，我们给AI一些弹药。这主要是为了测试目的，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the state''s `controlUpdate` method, we do a number of checks. First we
    check whether `clip` is `0`. If this is true, we check whether `ammo` is also
    `0`. If this is also true, the AI must flee! We disable this state and enable
    `RetreatState` instead using the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在状态的控制更新方法中，我们进行了一些检查。首先，我们检查`clip`是否为`0`。如果是这样，我们检查`ammo`是否也为`0`。如果是这样，AI必须逃跑！我们禁用此状态并使用以下代码启用`RetreatState`：
- en: '[PRE29]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the state still has ammo, it should refill the clip. We also set a longer
    time until it can fire again, as shown in the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果状态仍然有弹药，它应该重新装填弹夹。我们还设置了一个更长的时间，直到它可以再次开火，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the main `if` statement, if the state has lost the target, it should disable
    the state and switch to `PatrolState`, as shown in the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`if`语句中，如果状态已经失去了目标，它应该禁用状态并切换到`PatrolState`，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If it still has a target and is in a position to fire, it should fire, as shown
    in the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它仍然有目标并且处于开火的位置，它应该开火，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, if it is still waiting for the weapon to cool down since the last
    shot, it should keep waiting, as shown in the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果它仍然在等待武器冷却，它应该继续等待，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The third and final state for our AI is `RetreatState`. We can implement this
    by performing the following steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们AI的第三个也是最后一个状态是`RetreatState`。我们可以通过以下步骤来实现它：
- en: Like the `PatrolState`, it should have a `moveTarget` field that it tries to
    reach.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`PatrolState`一样，它应该有一个`moveTarget`字段，它试图到达。
- en: We also add a float called `fleeTimer` that defines for how long it will try
    to get away.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了一个名为`fleeTimer`的浮点数，它定义了它将尝试逃跑多长时间。
- en: 'In its `controlUpdate` method, if `fleeTimer` has not reached `0` yet, and
    it still feels a threat, it will pick a location opposite from the target and
    move towards it, as shown in the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`controlUpdate`方法中，如果`fleeTimer`尚未达到`0`，并且它仍然感觉到威胁，它将选择与目标相对的位置并朝它移动，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Otherwise, it's all clear, and it will switch to `PatrolState`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，一切正常，它将切换到`PatrolState`。
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing we did was define an abstract class called `AIState`. It's convenient
    to use the control pattern since it means we have access to the spatial and familiar
    ways to attach/detach states and turn them on and off.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个名为 `AIState` 的抽象类。使用控制模式很方便，因为它意味着我们可以访问空间和熟悉的方式来附加/分离状态以及开启和关闭它们。
- en: The `stateEnter` and `stateExit` methods are called when the state is enabled
    and disabled, and happens on transition from and to other states. The class also
    expects there to be some kind of AI control class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当状态被启用和禁用时，会调用 `stateEnter` 和 `stateExit` 方法，并且发生在从其他状态转换到和从其他状态转换时。该类还期望存在某种AI控制类。
- en: The first state extending `AIState` was the `PatrolState`. Its update method
    has three outcomes. If the AI has spotted something it can attack, it will change
    to the `AttackState`. Otherwise, if it's close to the place it has selected to
    move to, it will select a new target. Or, if it still has some way to go, it will
    just continue moving towards it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `AIState` 的第一个状态是 `PatrolState`。它的更新方法有三个结果。如果AI发现了它可以攻击的东西，它将切换到 `AttackState`。否则，如果它接近它选择移动的地方，它将选择一个新的目标。或者，如果它还有一段距离要走，它将只是继续朝它移动。
- en: The `AttackState` has a bit more functionality, as it also handles firing and
    ammunition management. Remember, if it has come here, the AI has already decided
    it should attack something. Hence, if it has no ammunition, it will switch to
    the `RetreatState` (although we generously give it some ammo every time it enters
    the state). Otherwise, it will attack or try attacking.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttackState` 有更多的功能，因为它还处理射击和弹药管理。记住，如果它已经到达这里，AI 已经决定它应该攻击某个目标。因此，如果没有弹药，它将切换到
    `RetreatState`（尽管我们每次进入状态时都慷慨地给它一些弹药）。否则，它将攻击或尝试攻击。'
- en: 'The `RetreatState` only has one goal: to try to get as far away from the threat
    as possible. Once it has lost sight of the target, or has fled for the specified
    amount of time, it will switch to `PatrolState`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`RetreatState` 只有一个目标：尽可能远离威胁。一旦它失去了目标，或者已经逃离了指定的时间，它将切换到 `PatrolState`。'
- en: As we can see, the logic is all contained within the associated state, which
    can be very convenient. The flow of the states will also always make sure the
    AI ends up in the `PatrolState` in the end.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，逻辑都包含在相关的状态中，这可以非常方便。状态的流动也将始终确保AI最终结束在 `PatrolState`。
- en: Creating the AI using cover
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建使用遮蔽的AI
- en: Having AI using cover is a huge step towards making characters seem more believable
    and it usually makes them more challenging as they don't die as quickly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用遮蔽的AI是使角色看起来更可信的巨大一步，通常这也使它们更具挑战性，因为它们不会那么快死去。
- en: There are many ways to implement this functionality. In the simplest form, the
    AI is not aware of any cover. It's simply scripted (by a designer) to move to
    a predefined favorable position when they spot an enemy. A player playing the
    sequence for the first time can't possibly notice the difference between an AI
    taking the decision by itself. Hence, the task of creating a believable AI (for
    that situation) is accomplished.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种功能有许多方法。在 simplest 形式下，AI 对任何遮蔽都一无所知。它只是简单地被脚本化（由设计师完成）在发现敌人时移动到预定义的有利位置。第一次玩这个序列的玩家不可能注意到AI自己做出决策的差异。因此，创建一个可信的AI（针对这种情况）的任务就完成了。
- en: A much more advanced way would be to use the same principles for cover, which
    was established in [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"),
    *Cameras and Game Controls*. However, evaluating options also becomes far more
    complex and unpredictable. Unpredictable AI might be good from the player's perspective,
    but it's a nightmare from a designer's perspective.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更高级的方法是使用与遮蔽相同的原理，这在[第二章](ch02.html "第二章。相机和游戏控制")中已经建立，即*相机和游戏控制*。然而，评估选项也变得更加复杂和不可预测。从玩家的角度来看，不可预测的AI可能很好，但从设计师的角度来看，它却是一场噩梦。
- en: In this recipe, we'll go for a middle ground. First of all, we will base the
    AI on the FSM created in the previous recipe, and add a new state that handles
    finding cover. We will then add cover points to a scene, from which the AI can
    pick a suitable one and move there before attacking.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将寻找一个中间点。首先，我们将基于之前菜谱中创建的FSM，并添加一个新的状态来处理寻找遮蔽。然后，我们将向场景中添加遮蔽点，AI可以从中选择一个合适的点并移动到那里，然后再攻击。
- en: '![Creating the AI using cover](img/6478OS_05_03.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![创建使用遮蔽的AI](img/6478OS_05_03.jpg)'
- en: State diagram
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 状态图
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s begin by defining a class called `CoverPoint`, extending `AbstractControl`
    by performing the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个名为`CoverPoint`的类，通过执行以下步骤来扩展`AbstractControl`：
- en: For now we can add a `Vector3f` called `coverDirection`. With getters and setters,
    that's all that's needed.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就目前而言，我们可以添加一个名为`coverDirection`的`Vector3f`。有了getter和setter，这就足够了。
- en: We create a class called `SeekCoverState`, extending our `AIState` class from
    the previous recipe.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`SeekCoverState`的类，它扩展了之前菜谱中的`AIState`类。
- en: It needs a list of `CoverPoints` called `availableCovers`, and a `CoverPoint`
    called `targetCover`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要一个名为`availableCovers`的`CoverPoints`列表和一个名为`targetCover`的`CoverPoint`。
- en: 'In the `stateEnter` method, it should look for a suitable cover point. We can
    do this with the following piece of code. It parses the list and takes the first
    `CoverPoint` where the dot product of the direction and `coverDirection` is positive:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stateEnter`方法中，它应该寻找一个合适的遮蔽点。我们可以用以下代码片段来完成这个任务。它解析列表，并取第一个方向和`coverDirection`的点积为正的`CoverPoint`：
- en: '[PRE35]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the `controlUpdate` method, the AI should move towards `targetCover` if it
    has one.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法中，如果AI有一个`targetCover`，它应该向`targetCover`移动。
- en: Once it gets close enough, `targetCover` should be set to null, indicating it
    should switch to `AttackState`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦它足够接近，`targetCover`应该被设置为null，表示它应该切换到`AttackState`。
- en: When this happens, `stateExit` should tell the AI to stop moving.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这种情况发生时，`stateExit`应该告诉AI停止移动。
- en: After adding the new state to the AI control class, to let it know it has the
    ability to seek cover, we also need to modify other states to enable it.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将新状态添加到AI控制类之后，为了让它知道它具有寻找遮蔽的能力，我们还需要修改其他状态来启用它。
- en: Most suitable is `PatrolState`, where it can switch to `SeekCoverState` instead
    of `AttackState` when it spots a target.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最合适的是`PatrolState`，当它发现目标时，它可以切换到`SeekCoverState`而不是`AttackState`。
- en: If we have a test case for the Finite State Machine, all we would now need to
    do is to add some `CoverPoints` to a scene and see what happens.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们为有限状态机有一个测试用例，我们现在需要做的只是向场景中添加一些`CoverPoints`，看看会发生什么。
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `CoverPoint` class we created adds the behavior to any `Spatial` instances
    to act as a cover. In a game, you would most likely not see the `CoverPoint` spatial,
    but it's good for debug and editing purposes. The concept can be expanded to cover
    other types of interest points for AI, as well as modified to handle volumes,
    rather than points using the spatial's geometry.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`CoverPoint`类为任何`Spatial`实例添加了作为遮蔽物的行为。在游戏中，你很可能看不到`CoverPoint`空间实例，但它对调试和编辑很有用。这个概念可以扩展到覆盖AI的其他类型的兴趣点，以及修改为使用空间几何形状来处理体积，而不是点。
- en: Once the `SeekCoverState` is enabled, it will try to find a suitable cover point
    that's relative to the target's position (at that time). It does this using the
    dot product between `coverDirection` and the direction to the target. If this
    is positive, it means the target is in front of the cover, and it picks this as
    `targetCover`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用了`SeekCoverState`，它将尝试找到一个相对于目标位置（当时）的合适遮蔽点。它是通过`coverDirection`和目标方向之间的点积来做到这一点的。如果这是正的，这意味着目标在遮蔽物前面，它选择这个作为`targetCover`。
- en: 'When the AI reaches this, it sets `targetCover` to `null`. This means that
    when `controlUpdate` is called the next time, it will exit the state and enable
    `AttackState` instead. In a real game, the AI would most likely use some kind
    of navigation or pathfinding to get there. You can get an introduction to navigation
    in the next recipe. There is also the *Pathfinding: Our own A* pathfinder* recipe
    that covers implementing pathfinding later in the chapter.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当AI到达这里时，它将`targetCover`设置为`null`。这意味着当下一次调用`controlUpdate`时，它将退出状态并启用`AttackState`。在真正的游戏中，AI很可能会使用某种类型的导航或路径查找来到达那里。你可以在下一个菜谱中了解导航的介绍。还有一个名为*路径查找：我们自己的A*路径查找器*的菜谱，它涵盖了在章节后面实现路径查找。
- en: With the current implementation of the AI, the result might be a bit erratic,
    since it doesn't remember the target's position. It might very well be that it
    doesn't see the target once it reaches the cover and instantly switches to `PatrolState`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当前AI的实现没有记住目标的位置，结果可能有点不稳定。它可能根本看不到目标，一旦它到达遮蔽物，就会立即切换到`PatrolState`。
- en: Generating NavMesh in SDK
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在SDK中生成NavMesh
- en: Automatic NavMesh generation is a feature of the SDK available in the SceneExplorer.
    The NavMesh, as its name implies, is a mesh in which pathfinding can be applied
    to have AIs navigate through the game world. The generator takes a set of input
    values and, based on these, will create a mesh that stretches around obstacles.
    It can be seen as painted lines that the AI can use to know where it's safe to
    walk.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 自动NavMesh生成是SceneExplorer中SDK提供的一项功能。正如其名称所暗示的，NavMesh是一个可以应用于寻路，使AI在游戏世界中导航的网格。生成器接受一组输入值，并根据这些值创建一个围绕障碍物延伸的网格。它可以看作是AI可以用来知道它在哪里可以安全行走的画线。
- en: '![Generating NavMesh in SDK](img/6478OS_05_04.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![在SDK中生成NavMesh](img/6478OS_05_04.jpg)'
- en: NavMesh on top of the terrain
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 地形上的NavMesh
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The feature is available through a plugin, which we have to download first.
    Refer to the *Downloading the plugins* section in [Appendix](apa.html "Appendix A. Information
    Fragments"), *Information Fragments*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能通过插件提供，我们首先需要下载。请参考[附录](apa.html "附录 A. 信息片段")中的*下载插件*部分，*信息片段*。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Once the plugin has been downloaded, we can open any scene in the **SceneComposer**
    window, as shown in the following screenshot:![How to do it...](img/6478OS_05_05.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载插件后，我们可以在**场景合成器**窗口中打开任何场景，如下面的截图所示：![如何操作...](img/6478OS_05_05.jpg)
- en: In the **SceneExplorer** window, right-click on the top node, and navigate to
    **Add Spatial.. | NavMesh..** to bring up the **options** window.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景资源管理器**窗口中，右键单击顶层节点，导航到**添加空间.. | NavMesh..**以打开**选项**窗口。
- en: The simplest procedure from here is to click on **Finish** and see what happens.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里最简单的步骤是点击**完成**，看看会发生什么。
- en: A geometry called `NavMesh` will shortly appear in the list, and selecting it
    will display its reach. Blue lines indicate navigable paths.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍后将在列表中看到一个名为`NavMesh`的几何形状，选择它将显示其可达范围。蓝色线条表示可导航路径。
- en: If we're happy with it (which might be difficult to say if it's the first time
    we see one), we save the scene.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们对此满意（如果这是第一次看到，可能很难说），我们就保存场景。
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The method by which the generator works is controllable by the large number
    of settings available. It can be difficult to know how they all affect the result,
    and what kind of result we're after, anyway. The best way is simply to test different
    parameters until a desired result is achieved. Each line is a path the pathfinder
    can follow, and there should be no isolated islands. The less lines there are
    in the mesh, the more restricted the AI will be. Remember, that different settings
    are optimal for different scenes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的工作方式可以通过大量可用的设置进行控制。了解它们如何影响结果可能很困难，而且我们到底想要什么样的结果。最好的方法是简单地测试不同的参数，直到达到期望的结果。每一行都是路径搜索器可以遵循的路径，而且不应该有孤岛。网格中的线条越少，AI的活动范围就越受限。记住，不同的设置对不同场景是最佳的。
- en: Pathfinding – using NavMesh
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻路 - 使用NavMesh
- en: Pathfinding can be done in many different ways, and in this recipe we'll look
    at how to use the NavMesh generated in the previous recipe for pathfinding. We'll
    use jMonkeyEngine's AI plugin, which has a pathfinder designed to navigate NavMeshes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 寻路可以以许多不同的方式进行，在这个菜谱中，我们将探讨如何使用前一个菜谱中生成的NavMesh进行寻路。我们将使用jMonkeyEngine的AI插件，该插件有一个用于在NavMesh中导航的路径搜索器。
- en: We achieve this using the Control pattern, and will also implement a way to
    generate paths in a thread-safe way separate from the main update thread, to not
    impact the performance of the application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用控制模式来实现这一点，并且还将实现一种在主更新线程之外以线程安全的方式生成路径的方法，以不影响应用程序的性能。
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need a scene with a NavMesh geometry in it. We also need to download the
    AI library plugin. Instructions on how to download a plugin in the SDK can be
    found in the *Downloading the plugins* section in [Appendix](apa.html "Appendix A. Information
    Fragments"), *Information Fragments*. The plugin is called `jME3 AI Library`.
    Once we have downloaded the plugin, we need to add it to the project. Right-click
    on the project and select **Properties**, then select **Libraries**, and then
    select **Add Library...**. Select **jME3 AI Library** and click on **Add Library**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个包含NavMesh几何形状的场景。我们还需要下载AI库插件。在SDK中如何下载插件，请参阅[附录](apa.html "附录 A. 信息片段")中的*下载插件*部分，*信息片段*。该插件名为`jME3
    AI Library`。一旦我们下载了插件，我们需要将其添加到项目中。右键单击项目并选择**属性**，然后选择**库**，然后选择**添加库...**。选择**jME3
    AI Library**并点击**添加库**。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We start by defining the class that will generate the paths for us. This part
    will be implemented by performing the following steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个将为我们生成路径的类。这部分将通过执行以下步骤来实现：
- en: We create a new class called `PathfinderThread`, which extends the `Thread`
    class.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`PathfinderThread`的新类，它扩展了`Thread`类。
- en: It needs a couple of fields, a `Vector3f` called `target`, a `NavMeshPathfinder`
    called `pathfinder`, and two Booleans, `pathfinding` and `running`, where `running`
    should be set to `true` by default.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要几个字段，一个名为`target`的`Vector3f`，一个名为`pathfinder`的`NavMeshPathfinder`，以及两个布尔值，`pathfinding`和`running`，其中`running`默认应设置为`true`。
- en: 'The constructor should take a `NavMesh` object as input, and we instantiate
    the `pathfinder` with the same, as shown in the following code:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数应接受一个`NavMesh`对象作为输入，我们使用相同的对象实例化`pathfinder`，如下所示：
- en: '[PRE36]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We override the `run` method to handle `pathfinding`. While running is `true`,
    the following logic should apply:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重写了`run`方法来处理`pathfinding`。当运行为`true`时，以下逻辑应适用：
- en: '[PRE37]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If `target` is not `null`, we set `pathfinding` to `true`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`target`不为`null`，我们将`pathfinding`设置为`true`。
- en: 'Then we set the start position of the pathfinder to the AI''s current position,
    as shown in the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将路径查找器的起始位置设置为AI的当前位置，如下所示：
- en: '[PRE38]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the pathfinder can find a path, we set `target` to `null`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果路径查找器可以找到路径，我们将`target`设置为`null`。
- en: In either case, pathfinding is done, and `pathfinding` is set to `false`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何情况下，路径查找都已完成，并将`pathfinding`设置为`false`。
- en: 'Finally, we tell the thread to sleep for one second until trying again, as
    shown in the following code:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们告诉线程休眠一秒钟，然后再尝试，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That''s the first step of the pathfinding handling. Next, we''ll define a class
    that will use this. This will be implemented by performing the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是路径查找处理的第一步。接下来，我们将定义一个将使用此方法的类。这将通过执行以下步骤来实现：
- en: We create a new class that extends `AbstractControl` called `NavMeshNavigationControl`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`NavMeshNavigationControl`的新类，它扩展了`AbstractControl`。
- en: It needs two fields, a `PathfinderThread` called `pathfinderThread` and a `Vector3f`
    called `waypointPosition`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要两个字段，一个名为`pathfinderThread`的`PathfinderThread`和一个名为`waypointPosition`的`Vector3f`。
- en: 'Its constructor should take a node as input, and we use this to extract a `NavMesh`
    from, and pass it on to `pathfinderThread`, which is instantiated in the constructor
    as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的构造函数应接受一个节点作为输入，我们使用它来提取`NavMesh`并将其传递给`pathfinderThread`，如下所示：
- en: '[PRE40]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we create a method to pass a position it should pathfind to using the
    following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建了一个方法，使用以下代码来传递它应路径查找的位置：
- en: '[PRE41]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `controlUpdate` method is what does the bulk of the work.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`controlUpdate`方法是执行大部分工作的方法。'
- en: We start by checking whether `waypointPosition` is `null`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检查`waypointPosition`是否为`null`。
- en: 'If it is not null, we project `waypointPosition` and the spatials `worldTranslation`
    onto a 2D plane (by removing the `y` value), to see how far apart they are as
    follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它不为`null`，我们将`waypointPosition`和空间`worldTranslation`投影到一个2D平面上（通过移除`y`值），如下所示，以查看它们之间的距离：
- en: '[PRE42]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the distance is more than `1f`, we tell the spatial to move in the direction
    of the waypoint. This recipe uses the `GameCharacterControl` class from [Chapter
    2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras and Game Controls*:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果距离大于`1f`，我们告诉空间向航点方向移动。这个配方使用了来自[第2章](ch02.html "第2章。相机和游戏控制")的`GameCharacterControl`类，*相机和游戏控制*：
- en: '[PRE43]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the distance is less than `1f`, we set `waypointPosition` to `null`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果距离小于`1f`，我们将`waypointPosition`设置为`null`。
- en: 'If `waypointPosition` is null, and there is another waypoint to get from the
    pathfinder, we tell the pathfinder to step to the next waypoint and apply its
    value to our `waypointPosition` field as shown in the following code snippet:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`waypointPosition`为`null`，并且路径查找器中还有另一个航点要到达，我们告诉路径查找器跳到下一个航点并将它的值应用到我们的`waypointPosition`字段，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `PathfinderThread` handles pathfinding. To do this in a thread-safe way,
    we use the pathfinding Boolean to let other threads know it's currently busy,
    so that they don't try to read from the pathfinder.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`PathfinderThread`处理路径查找。为了以线程安全的方式执行此操作，我们使用路径查找布尔值让其他线程知道它目前正在忙碌，这样它们就不会尝试从路径查找器中读取。'
- en: Target is the position the pathfinder should try to reach. This is set externally
    and will be used to indicate whether the thread should attempt to pathfind or
    not. This is why we set it to null once pathfinding is successful.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是路径查找器应尝试到达的位置。这是外部设置的，将用于指示线程是否应尝试路径查找。这就是为什么一旦路径查找成功，我们就将其设置为`null`。
- en: We keep the thread running all the time, to avoid having to initialize it every
    time. The thread will wake up once a second to see whether there is any pathfinding
    to perform. If the delay was not there, it would use up resources, unnecessarily.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直保持线程运行，以避免每次都需要初始化它。线程每秒醒来一次，看看是否有任何路径查找要执行。如果没有延迟，它将无谓地消耗资源。
- en: This class uses the `waypointPosition` field to store the current waypoint we're
    trying to reach. This is so that we don't need to look it up in the pathfinder
    every time, and thus risk interrupting an ongoing pathfinding. It also allows
    the AI to keep moving even if it's currently contemplating a new path.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用`waypointPosition`字段来存储我们试图到达的当前航点。这样做是为了我们不必每次都在路径查找器中查找它，从而避免中断正在进行的路径查找。它还允许AI即使在考虑新的路径时也能继续移动。
- en: The `controlUpdate` method first checks whether the `waypointPosition` is `null`.
    Null indicates it has no current goal, and should go to the pathfinder to see
    whether there is a new waypoint for it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`controlUpdate`方法首先检查`waypointPosition`是否为`null`。`null`表示它没有当前目标，应该去路径查找器看看是否有新的航点。'
- en: It can only get a new waypoint if `pathfinderThread` currently is not actively
    `pathfinding` and if there is a next waypoint to get.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在`pathfinderThread`当前没有积极进行路径查找，并且有一个下一个航点可以获取时，它才能获得一个新的航点。
- en: If it already has a `waypointPosition` field, it will convert both the spatials
    position and the `waypointPosition` to 2D and see how far apart they are. This
    is necessary as we can't guarantee that `NavMesh` is exactly on the same plane
    as the spatial.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它已经有一个`waypointPosition`字段，它将把空间位置和`waypointPosition`都转换为2D，看看它们有多远。这是必要的，因为我们不能保证`NavMesh`与空间完全在同一平面上。
- en: If it finds out that the distance is further than `1f`, it will find out the
    direction to the `waypointPosition` field and tell the spatial to move in that
    direction. Otherwise (if it's close enough), it will set the `waypointPosition`
    field to `null`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它发现距离超过`1f`，它将找到`waypointPosition`字段的方位，并告诉空间移动到那个方向。否则（如果足够近），它将`waypointPosition`字段设置为`null`。
- en: Once it has reached the final waypoint, it will tell the spatial to stop.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它到达了最终航点，它将告诉空间停止。
- en: Controlling groups of AI
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制AI群体
- en: In this recipe, we'll kill two birds with one stone and implement both an interface
    for group AI management and look at weighted decision making.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，我们将一石二鸟，实现一个用于群体AI管理的接口，并探讨加权决策。
- en: In many ways, the architecture will be similar to the *Decision making – Finite
    State Machine* recipe. It's recommended to have a look at it before making this
    recipe. The big difference from the normal state machine is that instead of the
    states having definite outcomes, an AI Manager will look at the current needs,
    and assign units to different tasks.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，架构将与*决策制作 – 有限状态机*方案相似。建议在制作此方案之前查看它。与正常状态机的主要区别在于，状态不是有确定结果的，AI管理者将查看当前需求，并将单位分配到不同的任务。
- en: This recipe will also make use of an `AIControl` class. This is also an extension
    of the `AIControl` that can be found in the *Creating a reusable AI control class*
    recipe.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此方案还将使用`AIControl`类。这也是`Creating a reusable AI control class`方案中可以找到的`AIControl`的扩展。
- en: As an example, we'll use resource gathering units in an RTS. In this simplified
    game, there are two resources, wood and food. Food is consumed continuously by
    the workers and is the driving force behind the decision. The AI Manager will
    try to keep the levels of the food storage at a set minimum level, taking into
    account the current consumption rate. The scarcer the food becomes, the more units
    will be assigned to gather it. Any unit not occupied by food gathering will be
    assigned to wood gathering instead.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将使用RTS中的资源收集单位。在这个简化游戏中，有两种资源：木材和食物。食物被工人持续消耗，是决策背后的驱动力。AI管理者将试图保持食物储存量的设定最低水平，考虑到当前的消耗率。食物越稀缺，分配去收集它的单位就越多。任何未被食物收集任务占用的单位将改为收集木材。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll start by defining a `GatherResourceState` class. It extends the same
    `AIState` we defined in the *Decision making – Finite State Machine* recipe. This
    will be implemented by performing the following steps:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个`GatherResourceState`类。它扩展了我们在*决策制作 – 有限状态机*方案中定义的相同的`AIState`。这将通过执行以下步骤来实现：
- en: First of all it needs access to the AIControl called `aiControl`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先它需要访问名为`aiControl`的AIControl。
- en: It needs two additional fields, a `Spatial` defining something to pick up called
    `resource`, and an integer called `amountCarried`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要两个额外的字段，一个名为`Spatial`的字段，用于定义要拾取的称为`resource`的东西，以及一个名为`amountCarried`的整数。
- en: 'In `controlUpdate` method, we define two branches. The first is for if the
    unit isn''t carrying anything, `amountCarried == 0`. In this case, the unit should
    move towards `resource`. Once it gets close enough, it should pick up some, and
    `amountCarried` should be increased, as shown in the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`controlUpdate`方法中，我们定义了两个分支。第一个是如果单位没有携带任何东西，`amountCarried == 0`。在这种情况下，单位应该向`resource`移动。一旦足够接近，它应该捡起一些东西，并将`amountCarried`增加，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the other case, `amountCarried` is more than `0`. Now, the unit should move
    towards the HQ instead. Once it's close enough, `finishTask()` is called.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一种情况下，`amountCarried`大于`0`。现在，单位应该向总部移动。一旦足够接近，就调用`finishTask()`。
- en: 'The `finishTask` method calls the AI Manager via `aiControl` to increase the
    resource amount that the state handles with the supplied amount as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`finishTask`方法通过`aiControl`调用AI管理器，以增加该状态处理的资源数量，如下所示：'
- en: '[PRE46]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, we create two new classes that extend this class, namely `GatherFoodState`
    and `GatherWoodState`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建两个新的类，它们扩展了这个类，即`GatherFoodState`和`GatherWoodState`。
- en: 'With the new state handled, we can focus on the `AIControl` class. It will
    follow the pattern established elsewhere in the chapter, but it needs some new
    functionality. This will be implemented by performing the following three steps:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理了新的状态后，我们可以专注于`AIControl`类。它将遵循本章其他地方建立的模式，但它需要一些新的功能。这将通过执行以下三个步骤来实现：
- en: It needs two new fields. The first is an `AIAppState` called `aiManager`. It
    also needs to keep track of its state in an `AIAppState` called `currentState`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要两个新的字段。第一个是一个名为`aiManager`的`AIAppState`。它还需要跟踪其状态，在名为`currentState`的`AIAppState`中。
- en: 'In the `setSpatial` method, we add the two gathering states to our control,
    and make sure they''re disabled, as shown in the following code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setSpatial`方法中，我们将两个收集状态添加到我们的控制中，并确保它们被禁用，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We also add a method to set the state, `setCurrentState`. Sidestepping conventions,
    it should not set an instance of a state, but enable an existing state the AI
    control class has, while disabling the previous state (if any), as shown in the
    following code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了一个设置状态的方法，`setCurrentState`。绕过惯例，它不应该设置一个状态实例，而应该启用AI控制类中现有的状态，同时禁用先前的状态（如果有的话），如下面的代码所示：
- en: '[PRE48]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we have to write a class that manages the units. It will be based on the
    `AppState` pattern, and consists of the following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须编写一个管理单位的类。它将基于`AppState`模式，并包括以下步骤：
- en: We begin by creating a new class called `AIAppState` that extends `AbstractAppState`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的类，名为`AIAppState`，它扩展了`AbstractAppState`。
- en: It needs a `List<AIControl>` of the units it controls, called `aiList`. We also
    add `Map<Class<? extends AIStateRTS>`, `Spatial>` called `resources` that contains
    the resources in the world that can be gathered.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要一个名为`aiList`的`List<AIControl>`，其中包含它控制的单位。我们还添加了一个名为`resources`的`Map<Class<?
    extends AIStateRTS>, Spatial>`，其中包含世界中可以收集的资源。
- en: It then needs to keep track of its stock of `wood` and `food`. There are also
    fields for the current `foodConsumption` value per second, `minimumFoodStorage`
    it would like to keep, and a `timer` for how long before it wants to reevaluate
    its decisions.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它需要跟踪其`wood`和`food`的库存。还有当前每秒的`foodConsumption`值、它希望保持的`minimumFoodStorage`以及一个在它想要重新评估其决策之前的时间`timer`。
- en: 'The `update` method is pretty simple. It starts by subtracting `foodConsumption`
    from the storage. Then, if `timer` has reached `0`, it will call the `evaluate`
    method, as shown in the following code:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update`方法相当简单。它首先从存储中减去`foodConsumption`。然后，如果`timer`达到`0`，它将调用`evaluate`方法，如下面的代码所示：'
- en: '[PRE49]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the `evaluate` method, we begin by establishing the food requirement, as
    shown in the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`evaluate`方法中，我们首先建立食物需求，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then we decide how urgent food gathering is, on a factor of 0.0 - 1.0, as shown
    in the following code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们决定食物收集的紧急程度，在0.0 - 1.0的系数上，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we decide how many workers should be assigned to food gathering by taking
    that factor and multiplying it by the total amount of workers, as shown in the
    following code:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过将这个系数乘以工人总数来决定应该分配多少工人进行食物收集，如下面的代码所示：
- en: '[PRE52]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We create a helper method, called `workersByState`, that returns the number
    of workers assigned to a given state, as shown in the following code:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个辅助方法，称为`workersByState`，它返回分配给给定状态的工人数量，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Comparing the current gathers with the required amount, we know whether to
    increase or decrease the number of food gatherers. We then set the state to change
    according to whether more or less food gatherers are required, as shown in the
    following code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前采集量与所需量进行比较，我们知道是否需要增加或减少食物采集者的数量。然后，根据是否需要更多或更少的食物采集者，我们设置状态进行相应的改变，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can create another method, called `setWorkerState`, that loops through `aiList`
    and calls `setCurrentState` of the first available worker. It reruns `true` if
    it has successfully set the state of a unit, as shown in the following code:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建另一个方法，称为`setWorkerState`，它会遍历`aiList`并调用第一个可用工人的`setCurrentState`。如果它成功设置了一个单位的州，它将重新运行`true`，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The example implementation also requires that we set the resource for that
    state in the form of a spatial. This is so that the units know where they can
    pick up some of the resource. It can be set somewhere in the application, as shown
    in the following code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例实现还要求我们将该状态的资源以空间形式设置。这样，单位就知道他们可以从哪里获取一些资源。它可以在应用程序的某个地方设置，如下面的代码所示：
- en: '[PRE56]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At the beginning of the game, we add one green food resource, and one brown
    wood resource, some distance away from the HQ (at 0,0,0). The `AIAppState` starts
    by looking at the current food storage, seeing it's low, it will assign an AI
    to go to the food resource and bring back food.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，我们在距离总部（0,0,0）一定距离处添加一个绿色食物资源和一个棕色木材资源。`AIAppState`首先查看当前的食物储存量，发现很低，于是它会分配一个AI前往食物资源并带回食物。
- en: The `AIAppState` evaluate method starts by establishing the need for food gathering.
    It does this by dividing the food stores by the current requirement. By setting
    the food in the algorithm to not be able to exceed the requirement, we make sure
    we get a figure between 0.0 and 1.0.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`AIAppState`的评估方法首先确定食物采集的需求。它是通过将食物储存量除以当前需求来做到这一点的。通过将算法中的食物设置成不能超过需求，我们确保得到一个介于0.0和1.0之间的数值。'
- en: It then takes the amount of units available, and decides how many of those should
    be gathering food, based on the `factorFood` figure, rounding it off to the nearest
    integer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它根据可用的单位数量，并根据`factorFood`数值决定应该有多少单位采集食物，并将其四舍五入到最接近的整数。
- en: The result is compared to how many are currently on a food gathering mission,
    and adjusts the number to suit the current need, assigning them to either food
    or wood gathering.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与当前执行食物采集任务的单位数量进行比较，并调整数量以适应当前需求，将他们分配到食物或木材采集。
- en: The worker AI is completely controlled by the state they're set to by the manager,
    and in this recipe, all they can do is move to one resource or the other. They
    have no idle state, and are expected to always have some task.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 工作AI完全由管理者设置的状态控制，在这个配方中，他们能做的只是移动到某个资源。他们没有空闲状态，并且预期总是有一些任务。
- en: The two states we use in the recipe are actually the same class. Both resources
    are gathered in the same way, and `GatherFoodState` and `GatherWoodState` are
    only used as identifiers. In a real game, they might well behave differently from
    each other. If not, it might be a good idea to use a parameterized version of
    `GatherResourceState` instead.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配方中使用的两种状态实际上是同一个类。两种资源都以相同的方式进行采集，`GatherFoodState`和`GatherWoodState`仅用作标识符。在真正的游戏中，它们可能表现得完全不同。如果不是这样，使用`GatherResourceState`的参数化版本可能是个好主意。
- en: There's more
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'This recipe only has two different states, where one is the deciding one. What
    do we do if we have, let''s say five equally important resources or tasks to consider?
    The principles are very much the same:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方只有两种不同的状态，其中一种是决定性的。如果我们有，比如说，五个同等重要的资源或任务需要考虑，我们会怎么做？原则是非常相似的：
- en: Begin by normalizing the need for each task between 0.0 and 1.0\. This makes
    it easier to balance things.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先将每个任务的需求在0.0到1.0之间进行归一化。这使得平衡事情变得更容易。
- en: Next, add all the values together, and divide each value by the sum. Now, each
    value is balanced with each other, and the total of all values is 1.0.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将所有值相加，然后将每个值除以总和。现在，每个值都与其他值平衡，所有值的总和为1.0。
- en: In this recipe, the evaluation is done continuously, but it might just as well
    be applied when an AI has finished a task, to see what it should do next. In that
    case, the task could be picked at random among the distributed values to make
    it more dynamic.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，评估是持续进行的，但也可以在人工智能完成一个任务后应用，看看它接下来应该做什么。在这种情况下，可以从分布的值中随机选择任务，使其更具动态性。
- en: Pathfinding – our own A* pathfinder
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻路 – 我们自己的 A* 寻路器
- en: Using the built-in functions of the `NavMesh` package might be enough for some,
    but in many cases we need customized pathfinding for our projects. Knowing how
    to implement, or even better, understanding A* (a-star) pathfinding, can take
    us a long way in our AI endeavors. It's easy to implement and very versatile.
    Correctly set up, it will always find the shortest path (and pretty fast too!).
    One of the drawbacks is that it can be memory-intensive in large areas if not
    kept in check.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NavMesh` 包的内置函数可能对一些人来说已经足够，但在许多情况下，我们需要为我们的项目定制寻路。了解如何实现，甚至更好的是，理解 A*（A-星）寻路，可以在我们的
    AI 努力中走得很远。它很容易实现，并且非常灵活。正确设置后，它总是会找到最短路径（而且速度也很快！）缺点之一是，如果不加以控制，在大面积区域可能会很消耗内存。
- en: A* is an algorithm that finds the shortest path in a graph. It's good at finding
    this quickly using **heuristics**, or an estimation of the cost to get from a
    position in the graph to the goal position.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: A* 是一种在图中找到最短路径的算法。它擅长快速使用**启发式**，或从图中某个位置到目标位置的成本的估计，来找到这个路径。
- en: Finding a good value for the heuristic (H) is very important in order to make
    it effective. In technical terms, H needs to be **admissible**. This means that
    the estimated cost should never exceed the actual cost.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个合适的启发式（H）值非常重要，这样才能使其有效。从技术角度讲，H 需要是**可接受的**。这意味着估计的成本永远不应超过实际成本。
- en: Each position, called a node, will keep track of how the cost from the starting
    node to itself, using the current path. It will then choose the next node to go
    to base on this, cost plus the cost to the next node plus the estimated cost to
    the goal node.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 每个位置，称为节点，将跟踪从起始节点到自身的成本，使用当前路径。然后，它将根据这个成本（加上到达下一个节点的成本和到达目标节点的估计成本）选择下一个要去的节点。
- en: A* could be said to work something like this; imagine that we're trying to find
    our way to a castle, through a maze. We're at an intersection, and can choose
    either the left path or the right path. We can see the castle in the distance
    to our left. We don't know anything about either path beyond the point where we're
    standing, but at least, taking the left path brings us closer to the castle, so
    it's natural to test that path.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: A* 可以说工作原理类似这样；想象一下我们正在尝试通过迷宫找到城堡的路。我们在一个十字路口，可以选择左边的路或右边的路。我们可以看到左边的远处有城堡。我们对两条路在站立点之外的情况一无所知，但至少，走左边这条路让我们更接近城堡，所以测试这条路是自然的。
- en: Now, it could very well be that the left path is wrong, and much longer. That's
    the reason it also keeps track of how far it's travelled along the path. This
    is called G. The longer it travels along a path, the higher G will become. If
    the path also starts to deviate from the way to the castle, H will rise again.
    At some point G plus H might be higher than it would be at the entrance to the
    right path at the intersection. Then it will hop back to that point and see where
    the other path leads, until the point where G plus H along that path is higher.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，左边的路可能是错误的，而且更长。这就是它也跟踪沿着路径行进距离的原因。这被称为 G。它沿着路径行进得越远，G 就会变得越高。如果路径也开始偏离通往城堡的路，H
    也会再次上升。在某个时刻，G 加上 H 可能会比在十字路口右边路的入口处更高。然后它将跳回到那个点，看看另一条路通向何方，直到沿着那条路的 G 加上 H 更高。
- en: This way, the AI using A* knows it's always traveled the shortest path once
    it exits the maze.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，使用 A* 的 AI 就知道一旦它离开迷宫，它总是走过了最短路径。
- en: In this recipe, we'll use an estimated cost to the goal, H, that is the distance
    as-the-bird-flies between two nodes. This will guarantee that H is admissible
    and always equal to or less than the actual distance to travel.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案中，我们将使用到目标节点的估计成本 H，即两个节点之间鸟瞰距离。这将保证 H 是可接受的，并且总是等于或小于实际行走的距离。
- en: We'll use the distance between nodes to calculate the cost to travel between
    them. This will be a lot to take in, but once done, we have a pathfinder we can
    use for many different applications.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用节点之间的距离来计算它们之间的旅行成本。这需要很多理解，但一旦完成，我们就有了可以用于许多不同应用的寻路器。
- en: How to do it...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll start by defining the node object, in a bean pattern. This will be implemented
    by performing the following steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义节点对象，采用bean模式。这将通过执行以下步骤来实现：
- en: We create a new class called `WaypointNode` that extends `AbstractControl`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`WaypointNode`的新类，它扩展了`AbstractControl`。
- en: It needs three integers, `f`, `h`, and `g`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要三个整数，`f`、`h`和`g`。
- en: We also have to add two Booleans, `open` and `closed`, to aid the pathfinder,
    a list of other nodes, called `connections`, it's current position stored in `Vector3f`
    and another node as `parent`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须添加两个布尔值，`open`和`closed`，以帮助路径查找器，一个其他节点的列表，称为`connections`，它当前的位置存储在`Vector3f`中，以及另一个节点作为`parent`。
- en: Now we can create the pathfinder itself. This will be implemented by performing
    the following steps. We create a new class called AStarPathfinder.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建路径查找器本身。这将通过执行以下步骤来实现。我们创建了一个名为AStarPathfinder的新类。
- en: The pathfinder class needs a list of nodes, called `openList`, which are the
    nodes currently considered.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路径查找器类需要一个节点列表，称为`openList`，这些是当前考虑的节点。
- en: It has to know of the `startNode` and `goalNode`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它必须知道`startNode`和`goalNode`。
- en: 'The `pathfind` method is the heart of the class. We can take a look at it in
    full, before explaining it, as shown in the following code:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pathfind`方法是类的心脏。在解释它之前，我们可以完整地查看它，如下面的代码所示：'
- en: '[PRE57]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It should begin by adding the `startNode` to `openList`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该首先将`startNode`添加到`openList`中。
- en: Next, we define a while loop that always picks the first node in `openList`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个while循环，该循环始终选择`openList`中的第一个节点。
- en: Inside this loop, we create another `for` loop that iterates through all the
    currently selected connected nodes, called neighbors.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个循环内部，我们创建另一个`for`循环，该循环遍历所有当前选定的连接节点，称为邻居。
- en: 'If the neighboring node is not in `openList`, it should be added there. It
    should also set the current node to `parentNode` of the `neighbor` node, as shown
    in the following code:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果相邻节点不在`openList`中，应将其添加到其中。它还应将当前节点设置为`neighbor`节点的`parentNode`，如下面的代码所示：
- en: '[PRE58]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'While doing this, `g` of the neighbor should be set to current node''s `G`
    plus the distance between the two nodes, as shown in the following code:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行此操作时，邻居的`g`值应设置为当前节点的`G`值加上两个节点之间的距离，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Also, if `H` has not already been calculated for `neighbor`, it should, by
    measuring the distance between `neighbor` and `goalNode`. `F` should be updated
    by adding `G` and `H` together, as shown in the following code:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果`H`尚未为`neighbor`计算，则应通过测量`neighbor`和`goalNode`之间的距离来计算。`F`应通过将`G`和`H`相加来更新，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It might also be that a shorter path has been discovered since `neighbor` was
    calculated. In this case, the neighbor should be updated again with the `current`
    node as `parent`. Do that and repeat the previous two steps.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也可能自计算`neighbor`以来已经发现了一条更短的路径。在这种情况下，应使用`current`节点作为`parent`再次更新邻居。完成此操作并重复前面的两个步骤。
- en: If `neighbor` is closed, it shouldn't do anything with it.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`neighbor`是关闭的，它不应该对它做任何事情。
- en: Once the neighbors have been parsed, the current node should be removed from
    `openList`. `openList` should then be reordered according to the total cost, `F`,
    of the nodes.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦解析了邻居，当前节点应从`openList`中移除。然后`openList`应根据节点的总成本`F`进行重新排序。
- en: The looping of `openList` should exit, either when it's empty, or when the `goalNode`
    has been reached, which is indicated by when it's closed.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`openList`的循环应该退出，要么是它为空，要么是`goalNode`已被达到，这表示它已关闭。'
- en: 'When the pathfinding is done, the shortest path can be extracted by going through
    the parent nodes starting with the `goalNode`, as shown in the following code.
    Reversing the resulting list will yield the best path, from `startNode` to `goalNode`.
    This can be implemented as follows:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当路径查找完成时，可以通过从`goalNode`开始遍历父节点来提取最短路径，如下面的代码所示。反转得到的列表将产生从`startNode`到`goalNode`的最佳路径。这可以按以下方式实现：
- en: '[PRE61]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The node bean that we created stores information about the state of the node,
    which is set by the pathfinder as it passes, or considers passing a node. The
    `g` value is the total cost to this node, along the current path, from the starting
    node. `h` is the estimated value left to the `goalNode`. In this recipe, it's
    the shortest distance possible. To be the most effective, it should be as close
    to the actual distance as possible, without exceeding it. This is to guarantee
    that it finds the shortest path. `F` is simply `g` and `h` added together, becoming
    the total estimated cost of the path using this node, and is the value used by
    the algorithm to consider.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的节点豆存储了节点状态的信息，这些信息由路径查找器在通过或考虑通过节点时设置。`g` 值是从起始节点沿当前路径到达此节点的总成本。`h` 是到达
    `goalNode` 的估计值。在这个菜谱中，它是可能的最短距离。为了最有效，它应该尽可能接近实际距离，但不能超过它。这是为了保证它能找到最短路径。`F`
    简单地是 `g` 和 `h` 相加，成为使用此节点的路径的总估计成本，并且是算法用来考虑的值。
- en: These values are stored as integers, rather than floats. This is better both
    for memory and processing purposes. We get around lower-than-one distances by
    multiplying them with 100.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值以整数形式存储，而不是浮点数。这对内存和处理都有好处。我们通过将它们乘以 100 来处理低于一的距离。
- en: It also keeps track of whether it's currently open or closed. It's quicker to
    query the node itself, than seeing if the list contains it. The node actually
    has three states, either open, closed, or the standard, neither which is when
    it has not yet been considered for the path. The parent of a node defines from
    which other node the path came to this node.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 它还跟踪节点当前是开放的还是关闭的。查询节点本身比查看列表中是否包含它更快。节点实际上有三种状态，即开放、关闭或标准状态，后者是节点尚未被考虑为路径的情况。节点的父节点定义了路径是从哪个其他节点到达此节点的。
- en: '`openList` contains all the nodes the pathfinder is currently considering.
    It starts with only the `startNode`, adding all its neighbors, since none are
    either open or closed at this stage. It also sets the parent of the node, calculates
    the cost to get to this node, and estimates the cost left to the goal (if it has
    not been calculated before). It only needs to do this once per node, as long as
    the goal is not moving.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`openList` 包含路径查找器目前正在考虑的所有节点。它从只包含 `startNode` 开始，添加所有邻居，因为在这个阶段它们既不是开放的也不是关闭的。它还设置节点的父节点，计算到达此节点的成本，并估计到达目标（如果之前尚未计算）的成本。只要目标没有移动，它只需要对每个节点做一次这件事。'
- en: Now, `openList` has a few new nodes to work with, and the current node is removed
    from the list. At the end of the `while` loop, we sort `openList` according to
    `f-cost` of the nodes, so that it always starts looking at the node with the lowest
    total cost. This is to make sure it doesn't spend any unnecessary time looking
    at paths which are not optimal.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`openList` 有一些新的节点可以工作，当前节点已从列表中移除。在 `while` 循环结束时，我们根据节点的 `f-cost` 对 `openList`
    进行排序，这样它总是从具有最低总成本的节点开始查找。这是为了确保它不会在不必要的路径上浪费时间。
- en: The algorithm can be considered to be successful once the `goalNode` has been
    put in `openList` and is set to closed. We can't end searching just because the
    `goalNode` enters `openList`. Since we also reconsider nodes if we find a shorter
    path to the node, we want to check all the `goalNodes` neighbors as well before
    ending the search.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `goalNode` 被放入 `openList` 并设置为关闭，算法就可以被认为是成功的。我们不能仅仅因为 `goalNode` 进入 `openList`
    就结束搜索。由于如果我们找到到达节点的更短路径，我们也会重新考虑节点，所以我们希望在结束搜索之前也检查所有 `goalNodes` 的邻居。
- en: If there is no path available to the `goalNode`, `openList` will become empty
    before the `goalNode` is closed, and the search will fail.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有路径可以到达 `goalNode`，在关闭 `goalNode` 之前，`openList` 将变为空，搜索将失败。
