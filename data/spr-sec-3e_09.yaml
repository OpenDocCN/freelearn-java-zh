- en: Client Certificate Authentication with TLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TLS的客户端证书认证
- en: Although username and password authentication is extremely common, as we discussed
    in [Chapter 1](01.html), *Anatomy of an Unsafe Application*, and in [Chapter 2](02.html),
    *Getting Started with Spring Security*, forms of authentication exist that allow
    users to present different types of credentials. Spring Security caters to these
    requirements as well. In this chapter, we'll move beyond form-based authentication
    to explore authentication using trusted client-side certificates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管用户名和密码认证极其普遍，正如我们在[第1章](01.html)《不安全应用程序的剖析》和[第2章](02.html)《Spring Security入门》中讨论的，存在允许用户呈现不同类型凭证的认证形式。Spring
    Security也迎合了这些要求。在本章中，我们将超越基于表单的认证，探索使用可信客户端证书的认证。
- en: 'During the course of this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的进程中，我们将涵盖以下主题：
- en: Learning how client certificate authentication is negotiated between the user's
    browser and a compliant server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习客户端证书认证是如何在用户的浏览器和符合要求的服器之间进行协商的。
- en: Configuring Spring Security to authenticate users with client certificates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring Security以使用客户端证书认证用户
- en: Understanding the architecture of client certificate authentication in Spring
    Security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Spring Security中客户端证书认证的架构
- en: Exploring advanced configuration options related to client certificate authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索与客户端证书认证相关的高级配置选项
- en: Reviewing pros, cons, and common troubleshooting steps when dealing with client
    certificate authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾客户端证书认证的优点、缺点和常见故障排除步骤
- en: How does client certificate authentication work?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端证书认证是如何工作的？
- en: Client certificate authentication requires a request for information from the
    server and a response from the browser to negotiate a trusted authentication relationship
    between the client (that is, a user's browser) and the server application. This
    trusted relationship is built through the use of the exchange of trusted and verifiable
    credentials, known as **certificates**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书认证需要服务器请求信息以及浏览器响应，以协商客户端（即用户的浏览器）与服务器应用程序之间的可信认证关系。这种信任关系是通过使用可信和可验证凭据的交换建立起来的，这些凭据被称为**证书**。
- en: Unlike much of what we have seen up to this point, with client certificate authentication,
    the servlet container or application server itself is typically responsible for
    negotiating the trust relationship between the browser and server by requesting
    a certificate, evaluating it, and accepting it as valid.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止所看到的大部分内容不同，在客户端证书认证中，Servlet容器或应用服务器本身通常负责通过请求证书、评估它并接受它作为有效认证来协商浏览器与服务器之间的信任关系。
- en: Client certificate authentication is also known as **mutual authentication**
    and is part of the **Secure Sockets Layer** (**SSL**) protocol and its successor,
    **Transport Layer Security** (**TLS**). As mutual authentication is part of the
    SSL and TLS protocols, it follows that an HTTPS connection (secured with SSL or
    TLS) is required in order to make use of client certificate authentication. For
    more details on SSL/TLS support in Spring Security, please refer to our discussion
    and the implementation of SSL/TLS in the Appendix, *Additional Reference Material*.
    Setting up SSL/TLS in Tomcat (or the application server you have been using to
    follow along with the examples) is required to implement client certificate authentication.
    As in the Appendix, *Additional Reference Material* we will refer to SSL/TLS as
    SSL for the remainder of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书认证也被称为**相互认证**，是**安全套接层**（**SSL**）协议及其继承者**传输层安全**（**TLS**）协议的一部分。由于相互认证是SSL和TLS协议的一部分，因此需要一个HTTPS连接（使用SSL或TLS加密）才能使用客户端证书认证。有关Spring
    Security中SSL/TLS支持的详细信息，请参阅我们在附录*附加参考资料*中的讨论和SSL/TLS的实现。在Tomcat（或您一直用来跟随示例的应用服务器）中设置SSL/TLS是实现客户端证书认证的必要条件。与附录*附加参考资料*中的内容一样，在本章剩余部分我们将SSL/TLS简称为SSL。
- en: 'The following sequence diagram illustrates the interaction between the client
    browser and the web server when negotiating an SSL connection and validating the
    trust of a client certificate used for mutual authentication:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的序列图说明了客户端浏览器与Web服务器协商SSL连接并验证用于相互认证的客户端证书的信任时的交互：
- en: '![](img/0ddcd0e7-34ef-4a68-b891-1191cd9d6418.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ddcd0e7-34ef-4a68-b891-1191cd9d6418.png)'
- en: 'We can see that the exchange of two certificates, the server and client certificates,
    provides the authentication that both parties are known and can be trusted to
    continue their conversation securely. In the interest of clarity, we omit some
    details of the SSL handshake and trust the checking of the certificates themselves;
    however, you are encouraged to do further reading in the area of the SSL and TLS
    protocols, and certificates in general, as many good reference guides on these
    subjects exist. *RFC 5246*, *The Transport Layer Security (TLS) Protocol Version
    1.2* ([http://tools.ietf.org/html/rfc5246](http://tools.ietf.org/html/rfc5246)),
    is a good place to begin reading about client certificate presentation, and if
    you''d like to get into more detail, *SL and TLS: Designing and Building Secure
    Systems, Eric Rescorla, Addison-Wesley* ([https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983](https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983))
    has an incredibly detailed review of the protocol and its implementation.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，两个证书（服务器和客户端证书）的交换为双方提供了认证，证明双方是已知的并且可以被信任继续安全地对话。为了清晰起见，我们省略了SSL握手的一些细节和证书本身的检查；然而，我们鼓励你进一步阅读有关SSL和TLS协议以及证书的一般内容，因为这些主题有很多很好的参考指南。关于客户端证书展示，可以阅读*RFC
    5246*，*传输层安全（TLS）协议版本1.2*（[http://tools.ietf.org/html/rfc5246](http://tools.ietf.org/html/rfc5246)），如果你想要了解更多细节，*SL和TLS：设计和管理安全系统，Eric
    Rescorla，Addison-Wesley*（[https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983](https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983)）对协议及其实现有非常详细的回顾。
- en: An alternative name for client certificate-based authentication is X.509 authentication.
    The term X.509 is derived from the X.509 standard, originally published by the
    ITU-T organization for use in directories based on the X.500 standard (the origins
    of LDAP, as you may recall from [Chapter 6](07.html), *LDAP Directory Services*).
    Later, this standard was adapted for use in securing internet communications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书认证的另一个名称是X.509认证。术语X.509来源于ITU-T组织最初发布的X.509标准，用于基于X.500标准的目录（你可能还记得第6章，*LDAP目录服务*中提到的LDAP的起源）。后来，这个标准被修改用于保护互联网通信。
- en: We mention this here because many of the classes in Spring Security related
    to this subject refer to X.509\. Remember that X.509 doesn't define the mutual
    authentication protocol itself, but defines the format and structure of the certificates
    and the encompassing trusted certificate authorities instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提到这一点是因为Spring Security中与这个问题相关的许多类都提到了X.509。记住X.509本身并没有定义相互认证协议，而是定义了证书的格式和结构以及包括受信任的证书颁发机构在内的内容。
- en: Setting up the client certificate authentication infrastructure
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置客户端证书认证基础架构
- en: Unfortunately for you as an individual developer, being able to experiment with
    client certificate authentication requires some non-trivial configuration and
    setup prior to the relatively easy integration with Spring Security. As these
    setup steps tend to cause a lot of problems for first-time developers, we felt
    it was important to walk you through them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，对于你这样的个人开发者来说，能够实验性地使用客户端证书认证需要一些复杂的配置和设置，这在前期的集成中相对容易与Spring Security结合。由于这些设置步骤经常给第一次开发者带来很多问题，所以我们觉得带你走过这些步骤是很重要的。
- en: We assume that you are using a local, self-signed server certificate, self-signed
    client certificates, and Apache Tomcat. This is typical of most development environments;
    however, it's possible that you may have access to a valid server certificate,
    a **certificate authority** (**CA**), or another application server. If this is
    the case, you may use these setup instructions as guidelines and configure your
    environment in an analogous manner. Please refer to the SSL setup instructions
    in the Appendix, *Additional Reference Material* for assistance on configuring
    Tomcat and Spring Security to work with SSL in a standalone environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你正在使用一个本地的、自签名的服务器证书、自签名的客户端证书和Apache Tomcat。这符合大多数开发环境；然而，你可能有访问有效的服务器证书、证书颁发机构（CA）或其他应用服务器的权限。如果是这种情况，你可以将这些设置说明作为指导，并类似地配置你的环境。请参考附录中的SSL设置说明，*附加参考材料*，以获得在独立环境中配置Tomcat和Spring
    Security以使用SSL的帮助。
- en: Understanding the purpose of a public key infrastructure
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解公钥基础设施的目的
- en: This chapter focuses on setting up a self-contained development environment
    for the purposes of learning and education. However, in most cases where you are
    integrating Spring Security into an existing client certificate-secured environment,
    there will be a significant amount of infrastructure (usually a combination of
    hardware and software) in place to provide functionality, such as certificate
    granting and management, user self-service, and revocation. Environments of this
    type define a public key infrastructure-a combination of hardware, software, and
    security policies that result in a highly secure authentication-driven network
    ecosystem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注于设置一个自包含的开发环境，用于学习和教育目的。然而，在大多数情况下，当你将Spring Security集成到现有的基于客户端证书的安全环境中时，将会有大量的基础设施（通常是硬件和软件的组合）已经到位，以提供诸如证书发放和管理、用户自我服务以及吊销等功能。这种类型的环境定义了一个公钥基础设施——硬件、软件和安全策略的组合，结果是一个高度安全的以认证为驱动的网络生态系统。
- en: In addition to being used for web application authentication, certificates or
    hardware devices in these environments can be used for secure, non-repudiated
    email (using S/MIME), network authentication, and even physical building access
    (using PKCS 11-based hardware devices).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于Web应用程序认证之外，这些环境中的证书或硬件设备还可以用于安全的、不可撤回的电子邮件（使用S/MIME）、网络认证，甚至物理建筑访问（使用基于PKCS
    11的硬件设备）。
- en: While the management overhead of such an environment can be high (and requires
    both IT and process excellence to implement well), it is arguably one of the most
    secure operating environments possible for technology professionals.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种环境的运维开销可能很高（并且需要IT和流程卓越才能实施良好），但可以说这是技术专业人员可能使用的最安全的运行环境之一。
- en: Creating a client certificate key pair
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端证书密钥对
- en: The self-signed client certificate is created in the same way as the self-signed
    server certificate is created-by generating a key pair using the `keytool` command.
    A client certificate key pair differs in that it requires the key store to be
    available to the web browser and requires the client's public key to be loaded
    into the server's trust store (we'll explain what this is in a moment).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 自签名客户端证书的创建方式与自签名服务器证书的创建方式相同——通过使用`keytool`命令生成密钥对。客户端证书密钥对的区别在于，它需要密钥库对浏览器可用，并需要将客户端的公钥加载到服务器的信任库中（我们稍后会解释这是什么）。
- en: 'If you do not wish to generate your own key right now, you may skip to the
    next section and use the sample certificates in the `./src/main/resources/keys`
    folder in the sample chapter. Otherwise, create the client key pair, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在不想生成自己的密钥，你可以跳到下一节，并使用示例章节中的`./src/main/resources/keys`文件夹中的示例证书。否则，按照如下方式创建客户端密钥对：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can find additional information about `keytool`, along with all of the configuration
    options, at Oracle's site, here [http://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html/keytool.html](http://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html/keytool.html).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Oracle的网站上找到关于`keytool`的额外信息，以及所有的配置选项，链接在这里 [http://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html/keytool.html](http://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html/keytool.html)。
- en: 'Most of the arguments to `keytool` are fairly arbitrary for this use case.
    However, when prompted to set up the first and last name (the common name, or
    CN, the portion of the owner''s DN) for the client certificate, ensure that the
    answer to the first prompt matches a user that we have set up in our Spring Security
    JDBC store. For example, `admin1@example.com` is an appropriate value since we
    have the `admin1@example.com` user setup in Spring Security. An example of the
    command-line interaction is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`keytool`的大部分参数对于这个用例来说是相当任意的。然而，当提示设置客户端证书的第一个和最后一个名字（所有者的DN的部分，即common name）时，请确保第一个提示的答案与我们在Spring
    Security JDBC存储中设置的用户相匹配。例如，`admin1@example.com`是一个合适的值，因为我们已经在Spring Security中设置了`admin1@example.com`用户。命令行交互的示例如下：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We'll see why this is important when we configure Spring Security to access
    the information from the certificate-authenticated user. We have one final step
    before we can set up certificate authentication within Tomcat, which is explained
    in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到为什么这是重要的，当我们配置Spring Security以从证书认证的用户那里获取信息。在我们可以在Tomcat中设置证书认证之前，还有最后一个步骤，将在下一节中解释。
- en: Configuring the Tomcat trust store
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Tomcat信任库
- en: Recall that the definition of a key pair includes both a private and public
    key. Similar to SSL certificates verifying and securing server communication,
    the validity of the client certificate needs to be verified by the certifying
    authority that created it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，密钥对定义包括一个私钥和一个公钥。就像SSL证书验证并确保服务器通信的有效性一样，客户端证书的有效性需要由创建它的认证机构来验证。
- en: As we have created our own self-signed client certificate using the `keytool`
    command, the Java VM will not implicitly trust it as having been assigned by a
    trusted certificate authority.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经使用`keytool`命令创建了自己的自签名客户端证书，Java虚拟机不会默认信任它，因为它并非由可信的证书机构分配。
- en: 'Let''s take a look at the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下步骤：
- en: We will need to force Tomcat to recognize the certificate as a trusted certificate.
    We do this by exporting the public key from the key pair and adding it to the
    Tomcat trust store.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要迫使Tomcat识别证书为可信证书。我们通过导出密钥对的公钥并将其添加到Tomcat信任库来实现。
- en: Again, if you do not wish to perform this step now, you can use the existing
    trust store in `.src/main/resources/keys` and skip to where we configure `server.xml`
    later in this section.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在不想执行这一步，你可以使用`.src/main/resources/keys`中的现有信任库，并跳到本节后面的`server.xml`配置部分。
- en: 'We''ll export the public key to a standard certificate file named `jbcp_clientauth.cer`,
    as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将公钥导出到一个名为`jbcp_clientauth.cer`的标准证书文件中，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we''ll import the certificate into the trust store (this will create
    the trust store, but in a typical deployment scenario you''d probably already
    have some other certificates in the trust store):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把证书导入信任库（这将创建信任库，但在典型的部署场景中，你可能已经在信任库中有一些其他证书）：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding command will create the trust store called `tomcat.truststore`
    and prompt you for a password (we chose the password `changeit`). You''ll also
    see some information about the certificate and will finally be asked to confirm
    that you do trust the certificate, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将创建一个名为`tomcat.truststore`的信任库，并提示你输入密码（我们选择了密码`changeit`）。你还将看到一些关于证书的信息，并最终被要求确认你是否信任该证书，如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Remember the location of the new `tomcat.truststore` file, as we will need to
    reference it in our Tomcat configuration.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 记住新`tomcat.truststore`文件的位置，因为我们将需要在Tomcat配置中引用它。
- en: What's the difference between a key store and a trust store?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥库和信任库之间有什么区别？
- en: The **Java Secure Socket Extension** (**JSSE**) documentation defines a key
    store as a storage mechanism for private keys and their corresponding public keys.
    The key store (containing key pairs) is used to encrypt or decrypt secure messages,
    and so on. The trust store is intended to store only public keys for trusted communication
    partners when verifying an identity (similar to how the trust store is used in
    certificate authentication). In many common administration scenarios, however,
    the key store and trust store are combined into a single file (in Tomcat, this
    would be done through the use of the `keystoreFile` and `truststoreFile` attributes
    of the connector). The format of the files themselves can be exactly the same.
    Really, each file can be any JSSE-supported keystore format, including **Java
    KeyStore** (**JKS**), PKCS 12, and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java安全套接字扩展**（**JSSE**）文档将密钥库定义为私钥及其对应公钥的存储机制。密钥库（包含密钥对）用于加密或解密安全消息等。信任库旨在存储验证身份时信任的通信伙伴的公钥（与证书认证中使用的信任库类似）。然而，在许多常见的管理场景中，密钥库和信任库被合并为单个文件（在Tomcat中，这可以通过使用连接器的`keystoreFile`和`truststoreFile`属性来实现）。这些文件本身的格式可以完全相同。实际上，每个文件可以是任何JSSE支持的密钥库格式，包括**Java密钥库**（**JKS**）、PKCS
    12等。'
- en: As previously mentioned, we assume you have already configured the SSL Connector,
    as outlined in the Appendix, *Additional Reference Material*. If you do not see
    the `keystoreFile` or `keystorePass` attributes in `server.xml`, it means you
    should visit the Appendix, *Additional Reference Material* to get SSL set up.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们假设您已经配置了SSL连接器，如附录*附加参考材料*中所概述。如果您在`server.xml`中看不到`keystoreFile`或`keystorePass`属性，这意味着您应该访问附录*附加参考材料*来设置SSL。
- en: 'Finally, we''ll need to point Tomcat at the trust store and enable client certificate
    authentication. This is done by adding three additional attributes to the SSL
    connector in the Tomcat `server.xml` file, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将Tomcat指向信任库并启用客户端证书认证。这通过在Tomcat `server.xml`文件中的SSL连接器添加三个附加属性来完成，如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `server.xml` file can be found at `TOMCAT_HOME/conf/server.xml`. If you
    are interacting with Tomcat using Eclipse or Spring Tool Suite, you will find
    a project named `Servers` that contains `server.xml`. For example, if you are
    using Tomcat 8, the path in your Eclipse workspace might look something similar
    to `/Servers/Tomcat v7.0 Server` at `localhost-config/server.xml`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.xml`文件可以在`TOMCAT_HOME/conf/server.xml`找到。如果你使用Eclipse或Spring Tool Suite与Tomcat交互，你会找到一个名为`Servers`的项目，包含`server.xml`。例如，如果你使用的是Tomcat
    8，你Eclipse工作区中的路径可能类似于`/Servers/Tomcat v7.0 Server`在`localhost-config/server.xml`。'
- en: 'This should be the remaining configuration required to trigger Tomcat to request
    a client certificate when an SSL connection is made. Of course, you will want
    to ensure you replace both `<CERT_PATH>` and `<KEYSTORE_PATH>` with the full paths.
    For example, on a Unix-based operating system, the path might look like this:
    `/home/mickknutson/packt/chapter8/keys/tomcat.keystore`.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该是触发Tomcat在建立SSL连接时请求客户端证书的剩余配置。当然，你希望确保你用完整的路径替换了`<CERT_PATH>`和`<KEYSTORE_PATH>`。例如，在基于Unix的操作系统上，路径可能看起来像这样：`/home/mickknutson/packt/chapter8/keys/tomcat.keystore`。
- en: Go ahead and try to start up Tomcat to ensure that the server starts up without
    any errors in the logs.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大胆尝试启动Tomcat，确保服务器在日志中没有错误地启动。
- en: There's also a way to configure Tomcat to optionally use client certificate
    authentication-we'll enable this later in the chapter. For now, we require the
    use of client certificates to even connect to the Tomcat server in the first place.
    This makes it easier to diagnose whether or not you have set this up correctly!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还有方法可以配置Tomcat，使其可选地使用客户端证书认证——我们将在本章后面启用这个功能。现在，我们要求使用客户端证书才能甚至连接到Tomcat服务器。这使得诊断你是否正确设置了这一点变得更容易！
- en: Configuring Tomcat in Spring Boot
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Boot中配置Tomcat
- en: We can also configure the embedded Tomcat instance within Spring Boot, which
    is how we will be working with Tomcat for the rest of this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以配置Spring Boot中的内嵌Tomcat实例，这是我们本章剩余时间将如何与Tomcat工作的方式。
- en: 'Configuring Spring Boot to use our newly created certificates is as straightforward
    as properties of the YAML entry, as shown in the following code snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Spring Boot使用我们新创建的证书，就像YAML条目的属性一样简单，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The final step is to import the certificate into the client browser.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将证书导入客户端浏览器。
- en: Importing the certificate key pair into a browser
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将证书密钥对导入浏览器
- en: Depending on what browser you are using, the process of importing a certificate
    may differ. We will provide instructions for installations of Firefox, Chrome,
    and Internet Explorer here, but if you are using another browser, please consult
    its help section or your favorite search engine for assistance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的浏览器，导入证书的过程可能会有所不同。我们将为Firefox、Chrome和Internet Explorer的安装提供说明，但如果您使用的是其他浏览器，请查阅其帮助部分或您最喜欢的搜索引擎以获得帮助。
- en: Using Firefox
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Firefox
- en: 'Perform the following steps to import the key store containing the client certificate
    key pair in Firefox:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，在Firefox中导入包含客户端证书密钥对的密钥库：
- en: Click on Edit | Preferences.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击编辑|首选项。
- en: Click on the Advanced button.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击高级按钮。
- en: Click on the Encryption tab.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击加密标签。
- en: Click on the View Certificates button. The Certificate Manager window should
    open up.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击查看证书按钮。证书管理器窗口应该打开。
- en: Click on the Your Certificates tab.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击您的证书标签。
- en: Click on the Import... button.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击导入...按钮。
- en: Browse to the location where you saved the `jbcp_clientauth.p12` file and select
    it. You will need to enter the password (that is, `changeit`) that you used when
    you created the file.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到你保存`jbcp_clientauth.p12`文件的位置并选择它。你将需要输入你创建文件时使用的密码（即`changeit`）。
- en: The client certificate should be imported, and you should see it on the list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书应该被导入，你会在列表上看到它。
- en: Using Chrome
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Chrome
- en: 'Perform the following steps to import the key store containing the client certificate
    key pair in Chrome:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，在Chrome中导入包含客户端证书密钥对的密钥库：
- en: Click on the wrench icon on the browser toolbar.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击浏览器工具栏上的扳手图标。
- en: Select Settings.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择设置。
- en: Click on Show advanced settings....
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击显示高级设置...。
- en: In the HTTPS/SSL section, click on the Manage certificates... button.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTTPS/SSL部分，点击管理证书...按钮。
- en: In the Your Certificates tab, click on the Import... button.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的证书标签中，点击导入...按钮。
- en: Browse to the location where you saved the `jbcp_clientauth.p12` file and select
    it.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到您保存`jbcp_clientauth.p12`文件的位置并选择它。
- en: You will need to enter the password (that is, `changeit`) that you used when
    you created the file.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要输入创建文件时使用的密码（即`changeit`）。
- en: Click on OK.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确定。
- en: Using Internet Explorer
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Internet Explorer
- en: 'As Internet Explorer is tightly integrated into the Windows OS, it''s a bit
    easier to import the key store. Let''s take a look at the following steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Internet Explorer与Windows操作系统紧密集成，因此导入密钥库稍微容易一些。让我们来看看以下步骤：
- en: Double-click on the `jbcp_clientauth.p12` file in Windows Explorer. The Certificate
    Import Wizard window should open.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows资源管理器中双击`jbcp_clientauth.p12`文件。证书导入向导窗口应该会打开。
- en: Click on Next and accept the default values until you are prompted for the certificate
    password.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步，接受默认值，直到您需要输入证书密码为止。
- en: Enter the certificate password (that is, `changeit`) and click Next.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入证书密码（即`changeit`）并点击下一步。
- en: Accept the default Automatically select the certificate store option and click
    Next.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受默认的自动选择证书存储选项并点击下一步。
- en: Click on Finish.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成。
- en: 'To verify that the certificate was installed correctly, you will need to perform
    another series of steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证证书是否正确安装，您需要执行另一系列步骤：
- en: Open the Tools menu (*Alt* + *X*) in Internet Explorer.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Internet Explorer中打开工具菜单 (*Alt* + *X*)。
- en: Click on the Internet Options menu item.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击互联网选项菜单项。
- en: Click on the Content tab.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击内容标签。
- en: Click on the Certificates button.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击证书按钮。
- en: Click on the Personal tab, if it is not already selected. You should see the
    certificate listed here.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有选择，点击个人标签。您应该在这里看到证书列表。
- en: Wrapping up testing
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成测试
- en: 'You should now be able to connect to the JBCP calendar site using the client
    certificate. Navigate to `https://localhost:8443/`, taking care to use HTTPS and
    `8443`. If all is set up correctly, you should be prompted for a certificate when
    you attempt to access the site-in Firefox, the certificate is displayed as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够使用客户端证书连接到JBCP日历网站。导航到`https://localhost:8443/`，注意使用HTTPS和`8443`。如果一切设置正确，当您尝试访问网站时，应该会提示您输入证书——在Firefox中，证书显示如下：
- en: '![](img/258c434d-cf14-459d-9507-fabe1c485e7c.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/258c434d-cf14-459d-9507-fabe1c485e7c.png)'
- en: You'll notice, however, that if you attempt to access a protected section of
    the site, such as the My Events section, you'll be redirected to the login page.
    This is because we haven't yet configured Spring Security to recognize the information
    in the certificate-at this point, the negotiation between the client and server
    has stopped at the Tomcat server itself.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您会发现，如果您尝试访问网站的保护区域，例如我的活动部分，您会被重定向到登录页面。这是因为我们还没有配置Spring Security来识别证书中的信息——在这个阶段，客户端和服务器之间的协商已经在Tomcat服务器本身停止了。
- en: You should start with the code from `chapter08.00-calendar`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从`chapter08.00-calendar`开始编写代码。
- en: Troubleshooting client certificate authentication
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决客户端证书认证问题
- en: Unfortunately, if we said that getting client certificate authentication configured
    correctly for the first time-without anything going wrong-was easy, we'd be lying
    to you. The fact is, although this is a great and very powerful security apparatus,
    it is poorly documented by both the browser and web server manufacturers, and
    the error messages, when present, can be confusing at best and misleading at worst.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们说第一次正确配置客户端证书认证很容易，没有出错，那就是在骗您。事实是，尽管这是一个非常强大且优秀的的安全装置，但浏览器和web服务器制造商的文档都很差，而且当出现错误信息时，充其量是令人困惑，最差的情况是具有误导性。
- en: Remember that, at this point, we have not involved Spring Security in the equation
    at all, so a debugger will most likely not help you (unless you have the Tomcat
    source code handy). There are some common errors and things to check.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，到目前为止，我们根本没有让Spring Security参与进来，所以调试器很可能帮不了您（除非您手头有Tomcat源代码）。有一些常见的错误和需要检查的事情。
- en: 'You aren''t prompted for a certificate when you access the site. There are
    many possible causes for this, and this can be the most puzzling problem to try
    to solve. Here are some things to check:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问网站时，没有提示您输入证书。这可能有多种可能的原因，这也是最难解决的问题之一。以下是一些需要检查的内容：
- en: Ensure that the certificate has been installed in the browser client you are
    using. Sometimes, you need to restart the whole browser (close all windows) if
    you attempted to access the site previously and were rejected.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保证书已安装在您正在使用的浏览器客户端中。有时，如果您之前尝试访问该网站并被拒绝，您可能需要重启整个浏览器（关闭所有窗口）。
- en: Ensure you are accessing the SSL port for the server (typically `8443` in a
    development setup), and have selected the HTTPS protocol in your URL. The client
    certificates are not presented in insecure browser connections. Make sure the
    browser also trusts the server SSL certificate, even if you have to force it to
    trust a self-signed certificate.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你正在访问服务器的SSL端口（在开发环境中通常是`8443`），并且在你的URL中选择了HTTPS协议。在不安全的浏览器连接中不会呈现客户端证书。确保浏览器也信任服务器的SSL证书，即使你不得不强制它信任自签名的证书。
- en: Ensure you have added the `clientAuth` directive to your Tomcat configuration
    (or the equivalent for whatever application server you are using).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已在您的Tomcat配置中添加了`clientAuth`指令（或您正在使用的任何应用程序服务器的等效配置）。
- en: If all else fails, use a network analyzer or packet sniffer, such as Wireshark
    ([http://www.wireshark.org/](http://www.wireshark.org/)) or Fiddler2 ([http://www.fiddler2.com/](http://www.fiddler2.com/)),
    to review the traffic and SSL key exchange over the wire (check with your IT department
    first-many companies do not allow tools of this kind on their networks).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果其他方法都失败了，请使用网络分析器或包嗅探器，如Wireshark ([http://www.wireshark.org/](http://www.wireshark.org/))
    或 Fiddler2 ([http://www.fiddler2.com/](http://www.fiddler2.com/))，以查看通过网络的流量和SSL密钥交换（首先与您的IT部门确认-许多公司不允许在他们的网络上使用这类工具）。
- en: If you are using a self-signed client certificate, make sure the public key
    has been imported into the server's trust store. If you are using a CA-assigned
    certificate, make sure the CA is trusted by the JVM or that the CA certificate
    is imported into the server's trust store.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的是自签名的客户端证书，请确保公钥已导入服务器的信任存储中。如果您使用的是CA分配的证书，请确保CA被JVM信任，或者CA证书已导入服务器的信任存储中。
- en: Internet Explorer, in particular, does not report details of client certificate
    failures at all (it simply reports a generic `Page Cannot be Displayed` error).
    Use Firefox for diagnosing if an issue you are seeing is related to client certificates
    or not.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特别是，Internet Explorer根本不报告客户端证书失败的详细信息（它只报告一个通用的“页面无法显示”错误）。如果您看到的问题可能与客户端证书有关，请使用Firefox进行诊断。
- en: Configuring client certificate authentication in Spring Security
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Security中配置客户端证书认证
- en: Unlike the authentication mechanisms that we have utilized thus far, the use
    of client certificate authentication results in the user's request being preauthenticated
    by the server. As the server (Tomcat) has already established that the user has
    provided a valid and trustworthy certificate, Spring Security can simply trust
    this assertion of validity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与迄今为止我们使用的认证机制不同，使用客户端证书认证会导致服务端预先对用户的请求进行认证。由于服务器（Tomcat）已经确认用户提供了有效且可信赖的证书，Spring
    Security可以简单地信任这一有效性的断言。
- en: An important component of the secure login process is still missing, that is,
    the authorization of the authenticated user. This is where our configuration of
    Spring Security comes in-we must add a component to Spring Security that will
    recognize the certificate authentication information from the user's HTTP session
    (populated by Tomcat), and then validate the presented credentials against the
    Spring Security `UserDetailsService` invocation. The invocation of `UserDetailsService`
    will result in the determination of whether the user declared in the certificate
    is known to Spring Security at all, and then it will assign `GrantedAuthority`
    as per the usual login rules.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 安全登录过程中的一个重要组件仍然缺失，那就是认证用户的授权。这就是我们的Spring Security配置发挥作用的地方-我们必须向Spring Security添加一个组件，该组件将识别用户HTTP会话（由Tomcat填充）中的证书认证信息，然后将呈现的凭据与Spring
    Security `UserDetailsService`的调用进行验证。`UserDetailsService`的调用将导致确定证书中声明的用户是否对Spring
    Security已知，然后根据通常的登录规则分配`GrantedAuthority`。
- en: Configuring client certificate authentication using the security namespace
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用安全命名空间配置客户端证书认证
- en: 'With all of the complexity of LDAP configuration, configuring client certificate
    authentication is a welcome reprieve. If we are using the security namespace style
    of configuration, the addition of client certificate authentication is a simple
    one-line configuration change, added within the `HttpSecurity` declaration. Go
    ahead and make the following changes to the provided `SecurityConfig.java` configuration:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管LDAP配置的复杂性令人望而却步，但配置客户端证书认证却是一种受欢迎的解脱。如果我们使用安全命名空间配置方式，在`HttpSecurity`声明中添加客户端证书认证只需简单的一行配置更改。接着，你可以对提供的`SecurityConfig.java`配置文件进行以下修改：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Observe that the `.x509()` method references our existing `userDetailsService()`
    configuration. For simplicity, we use the `UserDetailsServiceImpl` implementation
    covered in [Chapter 5](05.html), *Authentication with Spring Data*. However, we
    could easily swap this out with any other implementation (that is, the LDAP or
    JDBC-based implementation covered in [Chapter 4](04.html), *JDBC-Based Authentication*).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`.x509()`方法引用了我们现有的`userDetailsService()`配置。为了简单起见，我们使用了在[第5章](05.html)中介绍的`UserDetailsServiceImpl`实现，关于*使用Spring
    Data进行认证*。然而，我们很容易用其他任何实现来替换它（即在第4章中介绍的基于LDAP或JDBC的实现，关于*基于JDBC的认证*）。
- en: After restarting the application, you'll again be prompted for a client certificate,
    but this time, you should be able to access areas of the site requiring authorization.
    You can see from the logs (if you have them enabled) that you have been logged
    in as the `admin1@example.com` user.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重启应用程序后，系统会再次提示您提供客户端证书，但这次，您应该能够访问需要授权的网站区域。如果您启用了日志（如果有），从日志中可以看到您已以`admin1@example.com`用户身份登录。
- en: Your code should look like `chapter08.01-calendar`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像`chapter08.01-calendar`。
- en: How does Spring Security use certificate information?
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**Spring Security**是如何使用证书信息的？'
- en: 'As previously discussed, Spring Security''s involvement in certificate exchange
    is to pick up information from the presented certificate and map the user''s credentials
    to a user service. What we did not see in the use of the `.x509()` method was
    the magic that makes this happen. Recall that when we set the client certificate
    up, a DN similar to an LDAP DN was associated with the certificate:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring Security在证书交换中的作用是提取 presented certificate中的信息，并将用户的凭据映射到用户服务。我们在使用`.x509()`方法时没有看到使其成为可能的精灵。回想一下，当我们设置客户端证书时，与证书关联的类似LDAP
    DN的DN如下所示：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Spring Security uses the information in this DN to determine the actual username
    of the principal and it will look for this information in `UserDetailsService`.
    In particular, it allows for the specification of a regular expression, which
    is used to match a portion of the DN established with the certificate, and the
    utilization of this portion of the DN as the principal name. The implicit, default
    configuration for the `.x509()` method would be as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security使用DN中的信息来确定主体的实际用户名，并将在`UserDetailsService`中查找此信息。特别是，它允许指定一个正则表达式，用于匹配与证书建立的DN的一部分，并使用这部分DN作为主体名称。`.x509()`方法的隐式默认配置如下：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that this regular expression would match the `admin1@example.com`
    value as the principal's name. This regular expression must contain a single matching
    group, but it can be configured to support the username and DN issuance requirements
    of your application. For example, if the DNs for your organization's certificates
    include the `email` or `userid` fields, the regular expression can be modified
    to use these values as the authenticated principal's name.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个正则表达式会将`admin1@example.com`值作为主体名称匹配。这个正则表达式必须包含一个匹配组，但可以配置以支持您应用程序的用户名和DN发行需求。例如，如果您组织证书的DN包括`email`或`userid`字段，正则表达式可以修改为使用这些值作为认证主体的名称。
- en: How Spring Security certificate authentication works
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**Spring Security**客户端证书认证是如何工作的'
- en: 'Let''s review the various actors involved in the review and evaluation of the
    client certificates and translation into a Spring Security-authenticated session,
    with the help of the following diagram:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下图表回顾一下涉及客户端证书评审和评估的各种参与者，以及将之转化为Spring Security认证会话的过程：
- en: '![](img/3aab8775-aafc-4781-891a-8e2680fc0d53.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3aab8775-aafc-4781-891a-8e2680fc0d53.png)'
- en: We can see that `o.s.s.web.authentication.preauth.x509.X509AuthenticationFilter`
    is responsible for examining the request of an unauthenticated user for the presentation
    of client certificates. If it sees that the request includes a valid client certificate,
    it will extract the principal using `o.s.s.web.authentication.preauth.x509.SubjectDnX509PrincipalExtractor`,
    using a regular expression matching the certificate owner's DN, as previously
    described.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`o.s.s.web.authentication.preauth.x509.X509AuthenticationFilter`负责检查未经认证用户的请求以查看是否提交了客户端证书。如果它看到请求包括有效的客户端证书，它将使用`o.s.s.web.authentication.preauth.x509.SubjectDnX509PrincipalExtractor`提取主题，使用与证书所有者DN匹配的正则表达式，如前所述。
- en: Be aware that although the preceding diagram indicates that examination of the
    certificate occurs for unauthenticated users, a check can also be performed when
    the presented certificate identifies a different user than the one that was previously
    authenticated. This would result in a new authentication request using the newly
    provided credentials. The reason for this should be clear-any time a user presents
    a new set of credentials, the application must be aware of this and react in a
    responsible fashion by ensuring that the user is still able to access it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管前面的图表显示未经认证的用户会检查证书，但在呈现的证书标识的用户与先前认证的用户不同时，也会执行检查。这将导致使用新提供的凭据发起新的认证请求。这个原因应该很清楚-任何时候用户呈现一组新的凭据，应用程序都必须意识到这一点，并负责任地做出反应，确保用户仍然能够访问它。
- en: 'Once the certificate has been accepted (or rejected/ignored), as with other
    authentication mechanisms, an `Authentication` token is built and passed along
    to `AuthenticationManager` for authentication. We can now review the very brief
    illustration of the `o.s.s.web.authentication.preauth.PreAuthenticatedAuthenticationProvider`
    handling of the authentication token:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦证书被接受（或被拒绝/忽略），与其他认证机制一样，将构建一个`Authentication`令牌并传递给`AuthenticationManager`进行认证。现在我们可以回顾一下`o.s.s.web.authentication.preauth.PreAuthenticatedAuthenticationProvider`处理认证令牌的非常简短的说明：
- en: '![](img/0703ce2b-53ab-47d8-870d-00788fe453ea.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0703ce2b-53ab-47d8-870d-00788fe453ea.png)'
- en: Though we will not go over them in detail, there are a number of other preauthenticated
    mechanisms supported by Spring Security. Some examples include Java EE role mapping
    (`J2eePreAuthenticatedProcessingFilter`), WebSphere integration (`WebSpherePreAuthenticatedProcessingFilter`),
    and Site Minder-style authentication (`RequestHeaderAuthenticationFilter`). If
    you understand the process flow of client certificate authentication, understanding
    these other authentication types is significantly easier.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会详细介绍它们，但Spring Security支持许多其他预认证机制。一些例子包括Java EE角色映射（`J2eePreAuthenticatedProcessingFilter`），WebSphere集成（`WebSpherePreAuthenticatedProcessingFilter`）和Site
    Minder风格认证（`RequestHeaderAuthenticationFilter`）。如果你理解了客户端证书认证的流程，理解这些其他认证类型要容易得多。
- en: Handling unauthenticated requests with AuthenticationEntryPoint
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理未经认证请求的`AuthenticationEntryPoint`
- en: Since `X509AuthenticationFilter` will continue processing the request if authentication
    fails, we'll need to handle situations where the user does not authenticate successfully
    and has requested a protected resource. The way that Spring Security allows developers
    to customize this is by plugging in a custom `o.s.s.web.AuthenticationEntryPoint`
    implementation. In a default form login scenario, `LoginUrlAuthenticationEntryPoint`
    is used to redirect the user to a login page if they have been denied access to
    a protected resource and are not authenticated.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`X509AuthenticationFilter`如果在认证失败将继续处理请求，我们需要处理用户未能成功认证并请求受保护资源的情况。Spring
    Security允许开发人员通过插入自定义`o.s.s.web.AuthenticationEntryPoint`实现来定制这种情况。在默认的表单登录场景中，`LoginUrlAuthenticationEntryPoint`用于将用户重定向到登录页面，如果他们被拒绝访问受保护的资源且未经认证。
- en: 'In contrast, in typical client certificate authentication environments, alternative
    methods of authentication are simply not supported (remember that Tomcat expects
    the certificate well before the Spring Security form login takes place anyway).
    As such, it doesn''t make sense to retain the default behavior of redirection
    to a form login page. Instead, we''ll modify the entry point to simply return
    an `HTTP 403 Forbidden` message, using the `o.s.s.web.authentication.Http403ForbiddenEntryPoint`.
    Go ahead and make the following updates in your `SecurityConfig.java` file, as
    follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在典型的客户端证书认证环境中，其他认证方法根本不被支持（记住Tomcat在任何Spring Security表单登录发生之前都会期望证书）。因此，保留重定向到表单登录页面的默认行为是没有意义的。相反，我们将修改入口点，简单地返回一个`HTTP
    403 Forbidden`消息，使用`o.s.s.web.authentication.Http403ForbiddenEntryPoint`。在你的`SecurityConfig.java`文件中，进行以下更新：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, if a user tries to access a protected resource and is unable to provide
    a valid certificate, they will be presented with the following page, instead of
    being redirected to the login page:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一个用户尝试访问一个受保护的资源并且无法提供有效的证书，他们将看到以下页面，而不是被重定向到登录页面：
- en: '![](img/27b77e5f-5478-4833-aa29-439e54efd47c.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27b77e5f-5478-4833-aa29-439e54efd47c.png)'
- en: Your code should now look like `chapter08.02-calendar`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像`chapter08.02-calendar`。
- en: 'Other configuration or application flow adjustments that are commonly performed
    with client certificate authentication are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见于客户端证书认证的配置或应用程序流程调整如下：
- en: Removal of the form-based login page altogether
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彻底移除基于表单的登录页面。
- en: Removal of the logout link (as there's no reason to log out because the browser
    will always present the user's certificate)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除登出链接（因为浏览器总是会提交用户的证书，所以没有登出的理由）。
- en: Removal of the functionality to rename the user account and change the password
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除重命名用户账户和更改密码的功能。
- en: Removal of the user registration functionality (unless you are able to tie it
    into the issuance of a new certificate)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除用户注册功能（除非你能够将其与发放新证书相关联）。
- en: Supporting dual-mode authentication
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持双模式认证。
- en: It is also possible that some environments may support both certificate-based
    and form-based authentication. If this is the case in your environment, it is
    also possible (and trivial) to support it with Spring Security. We can simply
    leave the default `AuthenticationEntryPoint` interface (redirecting to the form-based
    login page) intact and allow the user to log in using the standard login form
    if they do not supply a client certificate.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能一些环境同时支持基于证书和基于表单的认证。如果你们环境是这样的，用Spring Security支持它是可能的（并且很简单）。我们只需保留默认的`AuthenticationEntryPoint`接口（重定向到基于表单的登录页面）不变，如果用户没有提供客户端证书，就允许用户使用标准的登录表单登录。
- en: 'If you choose to configure your application this way, you''ll need to adjust
    the Tomcat SSL settings (change as appropriate for your application server). Simply
    change the `clientAuth` directive to `want`, instead of `true`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择以这种方式配置你的应用程序，你将需要调整Tomcat的SSL设置（根据你的应用程序服务器适当更改）。将`clientAuth`指令更改为`want`，而不是`true`：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We'll also need to remove the `authenticationEntryPoint()` method that we configured
    in the previous exercise, so that the standard form-based authentication workflow
    takes over if the user isn't able to supply a valid certificate upon the browser
    first being queried.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要移除上一次练习中我们配置的`authenticationEntryPoint()`方法，这样如果用户在浏览器首次查询时无法提供有效的证书，标准的基于表单的认证工作流程就会接管。
- en: 'Although this is convenient, there are a few things to keep in mind about dual-mode
    (form-based and certificate-based) authentication, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做很方便，但是关于双模式（基于表单和基于证书）认证还有几件事情需要记住，如下：
- en: Most browsers will not reprompt the user for a certificate if they have failed
    certificate authentication once, so make sure that your users are aware that they
    may need to reenter the browser to present their certificate again.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数浏览器如果一次证书认证失败，将不会重新提示用户输入证书，所以要确保你的用户知道他们可能需要重新进入浏览器以再次提交他们的证书。
- en: Recall that a password is not required to authenticate users with certificates;
    however, if you are still using `UserDetailsService` to support your form-based
    authenticated users, this may be the same `UserDetailsService` object that you
    use to give the `PreAuthenticatedAuthenticationProvider` information about your
    users. This presents a potential security risk, as users who you intend to sign
    in only with certificates could potentially authenticate using form login credentials.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，使用证书认证用户时不需要密码；然而，如果您仍在使用`UserDetailsService`来支持您的表单认证用户，这可能就是您用来向`PreAuthenticatedAuthenticationProvider`提供关于您用户信息的同一个`UserDetailsService`对象。这可能带来潜在的安全风险，因为您打算仅使用证书登录的用户可能会潜在地使用表单登录凭据进行认证。
- en: 'There are several ways to solve this problem, and they are described in the
    following list:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题有几种方法，它们如下列所示：
- en: Ensure that the users authenticating with certificates have an appropriately
    strong password in your user store.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用证书进行身份验证的用户在您的用户存储中有适当强度的密码。
- en: Consider customizing your user store to clearly identify users who are enabled
    for form-based login. This can be tracked with an additional field in the table
    holding user account information, and with minor adjustments to the SQL queries
    used by the `JpaDaoImpl` object.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑自定义您的用户存储，以清楚地标识出可以使用表单登录的用户。这可以通过在持有用户账户信息的表中添加一个额外字段来跟踪，并对`JpaDaoImpl`对象使用的SQL查询进行少量调整。
- en: Configure a separate user details store altogether for users who are logging
    in as certificate-authenticated users, to completely segregate them from users
    that are allowed to use form-based login.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为使用证书认证的用户配置一个单独的用户详细信息存储，以完全将他们与可以使用表单登录的用户隔离开来。
- en: Dual-mode authentication can be a powerful addition to your site and can be
    deployed effectively and securely, provided that you keep in mind the situations
    under which users will be granted access to it.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重认证模式可以成为您网站的强大补充，并且可以有效地和安全地部署，前提是您要牢记在哪些情况下用户将被授予访问权限。
- en: Configuring client certificate authentication using Spring beans
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Bean配置客户端证书认证
- en: 'Earlier in this chapter, we reviewed the flow of the classes involved in client
    certificate authentication. As such, it should be straightforward for us to configure
    the JBCP calendar using explicit beans. By using the explicit configuration, we
    will have additional configuration options at our disposal. Let''s take a look
    and see how to use explicit configuration:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们回顾了参与客户端证书认证的类的流程。因此，使用显式Bean配置JBCP日历对我们来说应该是直接的。通过使用显式配置，我们将有更多的配置选项可供使用。让我们看看如何使用显式配置：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ll also need to remove the `x509()` method and add `x509Filter` to our
    filter chain, and add our `AuthenticationProvider` implementation to `AuthenticationManger`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要删除`x509()`方法，将`x509Filter`添加到我们的过滤器链中，并将我们的`AuthenticationProvider`实现添加到`AuthenticationManger`中：
- en: '[PRE13]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, give the application a try. Nothing much has changed from a user perspective,
    but as developers, we have opened the door to a number of additional configuration
    options.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试一下应用程序。从用户的角度来看，并没有发生太多变化，但作为开发者，我们已经为许多额外的配置选项打开了大门。
- en: Your code should now look like `chapter08.03-calendar`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像`chapter08.03-calendar`。
- en: Additional capabilities of bean-based configuration
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Bean配置的其他功能
- en: The use of Spring bean-based configuration provides us with additional capabilities
    through the exposure of bean properties that aren't exposed via the security namespace
    style of configuration.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于Spring Bean的配置提供了通过暴露未通过安全命名空间样式配置的bean属性而获得的其他功能。
- en: 'Additional properties available on `X509AuthenticationFilter` are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`X509AuthenticationFilter`上可用的额外属性如下：'
- en: '| **Property** | **Description** | **Default** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** | **默认值** |'
- en: '| `continueFilterChainOn UnsuccessfulAuthentication` | If false, a failed authentication
    will throw an exception rather than allow the request to continue. This would
    typically be set in cases where a valid certificate is expected and required to
    access the secured site. If true, the filter chain will proceed, even if there
    is a failed authentication. | `true` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `continueFilterChainOnUnsuccessfulAuthentication` | 如果为false，失败的认证将抛出异常，而不是允许请求继续。这通常会在预期并且需要有效证书才能访问受保护的站点时设置。如果为true，即使认证失败，过滤器链也将继续。
    | `true` |'
- en: '| `checkForPrincipalChanges` | If true, the filter will check to see if the
    currently authenticated username differs from the username presented in the client
    certificate. If so, authentication against the new certificate will be performed
    and the HTTP session will be invalidated (optionally, see the next attribute).
    If false, once the user is authenticated, they will remain authenticated even
    if they present different credentials. | `false` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `checkForPrincipalChanges` | 如果为真，过滤器将检查当前认证的用户名是否与客户端证书中呈现的用户名不同。如果是这样，将执行新的证书的认证，并使HTTP会话无效（可选，参见下一个属性）。如果为假，一旦用户认证成功，他们即使提供不同的凭据也将保持认证状态。|
    `false` |'
- en: '| `invalidateSessionOn PrincipalChange` | If true, and the principal in the
    request changes, the user''s HTTP session will be invalidated prior to being reauthenticated.
    If false, the session will remain-note that this may introduce security risks.
    | `true` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `invalidateSessionOn PrincipalChange` | 如果为真，且请求中的主体发生变化，将在重新认证之前使用户的HTTP会话无效。如果为假，会话将保持不变——请注意这可能引入安全风险。|
    `true` |'
- en: 'The `PreAuthenticatedAuthenticationProvider` implementation has a couple of
    interesting properties available to us, which are listed in the following table:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreAuthenticatedAuthenticationProvider`实现有几个有趣的属性可供我们使用，如下表所示：'
- en: '| **Property** | **Description** | **Default** |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** | **默认值** |'
- en: '| `preAuthenticatedUser` `DetailsService` | This property is used to build
    a full `UserDetails` object from the username extracted from the certificate.
    | None |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `preAuthenticatedUser` `DetailsService` | 此属性用于从证书中提取的用户名构建完整的`UserDetails`对象。|
    无 |'
- en: '| `throwExceptionWhen` `TokenRejected` | If true, a `BadCredentialsException`
    exception will be thrown when the token is not constructed properly (does not
    contain a username or certificate). It is typically set to `true` in environments
    where certificates are used exclusively. | None |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `throwExceptionWhen` `TokenRejected` | 如果为真，当令牌构建不正确（不包含用户名或证书）时，将抛出`BadCredentialsException`异常。在仅使用证书的环境中通常设置为`true`。|
    无 |'
- en: In addition to these properties, there are a number of other opportunities for
    implementing interfaces or extending classes involved in certificate authentication
    to further customize your implementation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些属性，还有许多其他机会可以实现接口或扩展与证书认证相关的类，以进一步自定义您的实现。
- en: Considerations when implementing client certificate authentication
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现客户端证书认证时的考虑
- en: Client certificate authentication, while highly secure, isn't for everyone and
    isn't appropriate for every situation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书认证虽然非常安全，但并不适合所有人，也不适用于每种情况。
- en: 'The pros of client certificate authentication are listed, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是客户端证书认证的优点：
- en: Certificates establish a framework of mutual trust and verifiability that both
    parties (client and server) are who they say they are
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书建立了一个双方（客户端和服务器）互相信任和可验证的框架，以确保双方都是他们所说的自己。
- en: Certificate-based authentication, if implemented properly, is much more difficult
    to spoof or tamper with than other forms of authentication
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果正确实现，基于证书的认证比其他形式的认证更难伪造或篡改。
- en: If a well-supported browser is used and configured correctly, client certificate
    authentication can effectively act as a single sign-on solution, enabling transparent
    login to all certificate-secured applications
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用得到良好支持的浏览器并正确配置，客户端证书认证可以有效地作为单点登录解决方案，实现对所有基于证书的安全应用的透明登录。
- en: 'The cons of client certificate authentication are listed, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是客户端证书认证的缺点：
- en: The use of certificates typically requires the entire user population to have
    them. This can lead to both a user training burden and an administrative burden.
    Most organizations deploying certificate-based authentication on a large scale
    must have sufficient self-service and helpdesk support for certificate maintenance,
    expiration tracking, and user assistance.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的使用通常要求整个用户群体都拥有证书。这可能导致用户培训负担和行政负担。大多数在大规模部署基于证书的认证的组织必须为证书维护、过期跟踪和用户支持提供足够的自助和帮助台支持。
- en: The use of certificates is generally an all-or-nothing affair, meaning that
    mixed-mode authentication and offering support for non-certificated users is not
    provided due to the complexity of web server configuration, or poor application
    support.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用证书通常是一个要么全部要么全无的事务，这意味着由于web服务器配置的复杂性或应用程序支持不足，不提供混合模式认证和支持非证书用户。
- en: The use of certificates may not be well supported by all users in your user
    population, including the ones who use mobile devices.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的使用可能不会得到您用户群体中所有用户的支持，包括使用移动设备的用户。
- en: The correct configuration of the infrastructure required to support certificate-based
    authentication may require advanced IT knowledge.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确配置支持基于证书认证的基础设施可能需要高级的IT知识。
- en: As you can see, there are both benefits and drawbacks to client certificate
    authentication. When implemented correctly, it can be a very convenient mode of
    access for your users and has extremely attractive security and non-repudiation
    properties. You will need to determine your particular situation to see whether
    or not this type of authentication is appropriate.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，客户端证书认证既有优点也有缺点。当正确实现时，它可以为用户提供非常方便的访问方式，并具有极具吸引力的安全性和不可否认性属性。你需要确定你的具体情况以判断这种认证方式是否合适。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined the architecture, flow, and Spring Security support
    for client certificate-based authentication. We have covered the concepts and
    overall flow of client certificate (mutual) authentication. We explored the important
    steps required to configure Apache Tomcat for a self-signed SSL and client certificate
    scenario.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了客户端基于证书认证的架构、流程以及Spring Security的支持。我们涵盖了客户端证书（相互）认证的概念和总体流程。我们探讨了配置Apache
    Tomcat以支持自签名的SSL和客户端证书场景的重要步骤。
- en: We also learned about configuring Spring Security to understand certificate-based
    credentials presented by clients. We covered the architecture of Spring Security
    classes related to certificate authentication. We also know how to configure a
    Spring bean-style client certificate environment. We also covered the pros and
    cons of this type of authentication.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何配置Spring Security以理解客户端呈现的基于证书的凭据。我们涵盖了与证书认证相关的Spring Security类的架构。我们还知道如何配置Spring
    bean风格的客户端证书环境。我们还讨论了这种认证方式的优缺点。
- en: It's quite common for developers unfamiliar with client certificates to be confused
    by many of the complexities of this type of environment. We hope that this chapter
    has made this complicated subject a bit easier to understand and implement! In
    the next chapter, we will discuss how you can accomplish single sign-on with OpenID.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉客户端证书的开发人员来说，他们可能会对这种环境中的许多复杂性感到困惑。我们希望这一章节使得这个复杂主题变得更容易理解和实现！在下一章节中，我们将讨论如何使用OpenID实现单点登录。
