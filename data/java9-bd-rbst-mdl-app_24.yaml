- en: Sunago - An Android Port
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sunago - Android版本
- en: In the last chapter, we built Sunago, a social media aggregation application.
    In that chapter, we learned that Sunago is a JavaFX-based application that can
    pull posts, tweets, photos, and so on from a variety of social media networks
    and display them in one place. The application certainly provided a number of
    interesting architectural and technical examples, but the application itself could
    be more practical--we tend to interact with social networks from mobile devices
    such as phones and tablets, so a mobile version would be much more useful. In
    this chapter, then, we'll write an Android port, reusing as much of the code as
    possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了Sunago，一个社交媒体聚合应用程序。在那一章中，我们了解到Sunago是一个基于JavaFX的应用程序，可以从各种社交媒体网络中抓取帖子、推文、照片等，并在一个地方显示它们。该应用程序确实提供了一些有趣的架构和技术示例，但应用程序本身可能更加实用——我们倾向于从手机和平板电脑等移动设备与社交网络互动，因此一个移动版本会更有用。因此，在这一章中，我们将编写一个Android版本，尽可能重用代码。
- en: 'Android applications, while built in Java, look quite a bit different than,
    say, a desktop application. While we can''t cover every aspect of Android development,
    we''ll cover enough in this chapter to get you started, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Android应用程序是用Java编写的，但它们看起来与桌面应用程序大不相同。虽然我们无法涵盖Android开发的各个方面，但我们将在本章中涵盖足够的内容，以帮助您入门，包括以下内容：
- en: Setting up an Android development environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Android开发环境
- en: Gradle builds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle构建
- en: Android views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android视图
- en: Android state management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android状态管理
- en: Android services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android服务
- en: Application packaging and deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序打包和部署
- en: Like the other chapters, there will be too many small items to call out each
    of them, but we'll do our best to highlight the new ones as they're introduced.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他章节一样，会有太多的小项目无法一一列举，但我们将尽力在介绍时突出新的内容。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: The first step is to get the Android development environment set up. As with
    *regular* Java development, an IDE isn't strictly necessary, but it sure helps,
    so we'll install Android Studio, which is an IDE based on IntelliJ IDEA. If you
    already have IDEA installed, you can just install the Android plugin and have
    everything you need. For our purposes here, though, we'll assume you don't have
    either installed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是设置Android开发环境。与*常规*Java开发一样，IDE不是必需的，但它确实很有帮助，所以我们将安装Android Studio，它是一个基于IntelliJ
    IDEA的IDE。如果您已经安装了IDEA，您只需安装Android插件，就可以拥有所需的一切。但在这里，我们将假设您还没有安装。
- en: 'To download Android Studio, go to [https://developer.android.com/studio/index.html](https://developer.android.com/studio/index.html),
    and download the package appropriate for your operating system. When you start
    Android Studio for the first time, you should see following screen:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要下载Android Studio，请访问[https://developer.android.com/studio/index.html](https://developer.android.com/studio/index.html)，并下载适合您操作系统的包。当您第一次启动Android
    Studio时，您应该看到以下屏幕：
- en: '![](img/bb251238-ca83-4873-92c6-9692d0bbf9d3.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb251238-ca83-4873-92c6-9692d0bbf9d3.png)'
- en: 'Before we start a new project, let''s configure the Android SDKs that are available.
    Click on the Configure menu in the bottom-right corner, then click on SDK Manager
    to get this screen:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始新项目之前，让我们配置可用的Android SDK。点击右下角的“配置”菜单，然后点击“SDK管理器”以获取以下屏幕：
- en: '![](img/18c33ace-5bd0-4b12-8f68-2f5ac6998249.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18c33ace-5bd0-4b12-8f68-2f5ac6998249.png)'
- en: Which SDKs you select will vary depending on your needs. You may need to support
    older devices as far back as, say, Android 5.0, or maybe you just want to support
    the very latest with Android 7.0 or 7.1.1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的SDK将根据您的需求而有所不同。您可能需要支持追溯到Android 5.0的旧设备，或者您可能只想支持最新的Android 7.0或7.1.1。
- en: Once you know what need, select the appropriate SDKs (or do as I've done in
    the preceding screenshot and select everything from 5.0 and forward), then click
    on OK. You will need to read and accept the license before continuing.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您知道需要什么，请选择适当的SDK（或者像我之前截图中所做的那样，从5.0开始选择所有内容），然后点击“确定”。在继续之前，您需要阅读并接受许可协议。
- en: Once you've done that, Android Studio will begin downloading the selected SDKs
    and any dependencies. This process can take a while, so be patient.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些操作后，Android Studio将开始下载所选的SDK及其依赖项。这个过程可能需要一些时间，所以请耐心等待。
- en: 'When the SDK installation completes, click on the Finish button, which will
    take you take to the Welcome screen. Click on Start a new Android Studio project
    to get the following screen:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当SDK安装完成时，点击“完成”按钮，这将带您进入欢迎屏幕。点击“开始新的Android Studio项目”以获取以下屏幕：
- en: '![](img/cd5761d5-190d-4fe2-bd36-011efcda44cf.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd5761d5-190d-4fe2-bd36-011efcda44cf.png)'
- en: 'Nothing exciting here--we need to specify the Application name, Company domain,
    and Project location of our app:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里没有什么令人兴奋的——我们需要指定我们应用的名称、公司域名和项目位置：
- en: '![](img/229a595d-c0bb-4f38-a568-dd1f24cfc34a.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/229a595d-c0bb-4f38-a568-dd1f24cfc34a.png)'
- en: Next, though, we need to specify the form factor for our app. Our options are
    Phone and Tablet, Wear, TV, Android Auto, and Glass. As seen in this preceding
    screenshot, all we're interested in for this application is Phone and Tablet.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定我们应用的表单因子。我们的选项有手机、平板、可穿戴设备、电视、Android Auto和Glass。如前一个截图所示，我们对于这个应用所感兴趣的是手机和平板。
- en: On the next window, we need to select a type for the main `Activity` for the
    application. In an Android application, what we might refer to as a *screen* (or
    maybe *page*, if you're coming from a web application background) is known as
    an `Activity`. Not every `Activity` is a screen, though.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个窗口中，我们需要为主`Activity`选择一个类型。在Android应用中，我们可能称之为*屏幕*（或者如果你来自Web应用背景，可能是*页面*）的是`Activity`。但并非每个`Activity`都是屏幕。
- en: 'From the Android developer documentation ([https://developer.android.com/reference/android/app/Activity.html](https://developer.android.com/reference/android/app/Activity.html)),
    we learn the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android开发者文档([https://developer.android.com/reference/android/app/Activity.html](https://developer.android.com/reference/android/app/Activity.html))中，我们了解到以下内容：
- en: '[a]n activity is a single, focused thing that the user can do. Almost all activities
    interact with the user, so the Activity class takes care of creating a window
    for you...'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[a] 活动是用户可以执行的单个、专注的事情。几乎所有活动都与用户交互，因此Activity类会为你创建一个窗口...'
- en: 'For our purposes, it''s probably acceptable to equate the two, but do so loosely,
    and always with this caveat in mind. The wizard gives us many options, as seen
    in this screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，可能可以将这两个概念等同起来，但这样做要宽松一些，并且始终要记住这个注意事项。巫师为我们提供了许多选项，如本截图所示：
- en: '![](img/2b059d9a-c5c1-4858-bb20-f2dd347de3e8.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b059d9a-c5c1-4858-bb20-f2dd347de3e8.png)'
- en: 'As you can see, there are several options: Basic, Empty, Fullscreen, Google
    AdMobs Ads, Google Maps, Login, and so on. Which to choose depends, again, on
    what your requirements are for the application. Our bare minimum requirements,
    in terms of user interface, are that it tells the user the name of the app, shows
    the list of social media items, and provides a menu for changing the application
    settings. From the preceding list, then, the Basic Activity is the closest match,
    so we select that, and click on Next:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，有几个选项：基本、空、全屏、Google AdMobs广告、Google地图、登录等等。选择哪个取决于你的应用需求。从用户界面的角度来看，我们最基本的需求是告诉用户应用名称，显示社交媒体项目列表，并提供更改应用设置的菜单。因此，从上述列表中，基本活动是最接近的匹配项，所以我们选择它，并点击下一步：
- en: '![](img/358b4235-4f1f-4aa9-b4f1-d7aa2177ca1d.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/358b4235-4f1f-4aa9-b4f1-d7aa2177ca1d.png)'
- en: The defaults in the preceding screen are mostly acceptable (notice that Activity
    Name was changed), but before we click on Finish, there are a few final words.
    When building an Android application of any size, you are going to have a lot
    of layouts, menus, activities, and so on. I have found it helpful to name these
    artifacts as you see here--the layout for an `Activity` is named `activity_` plus
    the `Activity` name; menus are `menu_` plus the activity name, or, for shared
    menus, a meaningful summary of its contents. Each artifact type is prefixed by
    its type. This general pattern will help you quickly navigate to the source file
    as the number of files grows, as the arrangement of these files is very flat and
    shallow.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一个屏幕中的默认设置大多是可以接受的（注意Activity名称已更改），但在我们点击完成之前，还有一些最后的话要说。在构建任何大小的Android应用时，你将会有很多布局、菜单、活动等等。我发现按照这里所示命名这些工件是有帮助的——`Activity`的布局命名为`activity_`加上`Activity`名称；菜单是`menu_`加上活动名称，或者对于共享菜单，是一个对其内容的合理总结。每种工件类型都以前缀表示其类型。这种通用模式将帮助你在文件数量增加时快速导航到源文件，因为这些文件的排列非常平坦和浅层。
- en: Finally, notice the Use a Fragment checkbox. *A Fragment is a piece of an application's
    user interface or behavior that can be placed in an Activity*. It is, effectively,
    a way for you, as the developer, to decompose the user interface definition into
    multiple pieces (or Fragments, thus, the name) that can be composed into a whole
    in an Activity in different ways depending on the current context of the application.
    For example, a Fragment-based user interface might have two screens for certain
    operations on a phone, but might combine those into one Activity for the larger
    screen on a tablet. It's a bit more complicated than that, of course, but I include
    that brief and incomplete description simply to give some explanation of the checkbox.
    We will not be using Fragments in our application, so we leave that unchecked,
    and click on Finish.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，请注意“使用片段”复选框。*片段是应用程序用户界面或行为的一部分，可以放置在 Activity 中*。实际上，它是开发者将用户界面定义分解成多个部分（或片段，因此得名）的一种方式，这些部分可以根据应用程序的当前上下文以不同的方式组合成一个整体。例如，基于片段的用户界面可能为手机上的某些操作提供两个屏幕，但在平板电脑的大屏幕上可能将它们合并为一个
    Activity。当然，这比那要复杂得多，但我只是简要地、不完整地描述一下，以便对复选框进行解释。在我们的应用程序中，我们不会使用片段，所以我们保留该选项未勾选，并点击“完成”。
- en: 'After processing for some time, Android Studio now creates a basic application
    for us. Before we start coding the application, let''s run it to see what that
    process looks like. We can run the app in a few ways--we can click on Run | Run
    ''app''; click on the green play button in the middle of the toolbar, or press
    *Shift* + *F10*. All three will bring up the same Select Deployment Target window,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间处理之后，Android Studio 现在为我们创建了一个基本的应用程序。在我们开始编写应用程序代码之前，让我们运行它看看这个过程是什么样的。我们可以以几种方式运行应用程序——我们可以点击“运行”|“运行
    'app'”；点击工具栏中间的绿色播放按钮，或者按 *Shift* + *F10*。所有三种方式都会弹出相同的“选择部署目标”窗口，如下所示：
- en: '![](img/65afc6c3-7424-45da-893a-149e8432bd43.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65afc6c3-7424-45da-893a-149e8432bd43.png)'
- en: 'Since we just installed Android Studio, we don''t have any emulators created,
    so we need to do that now. To create the emulators, follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚安装了 Android Studio，我们没有创建任何模拟器，所以我们需要现在创建。要创建模拟器，请按照以下步骤操作：
- en: 'Clicking on the Create New Virtual Device button gets us this screen:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建新虚拟设备”按钮，我们会看到这个屏幕：
- en: '![](img/991eef13-641b-4b37-9aa2-a42d7e07d228.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/991eef13-641b-4b37-9aa2-a42d7e07d228.png)'
- en: 'Let''s start with a reasonably modern Android phone--select the Nexus 6 profile,
    and click on Next:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一台相对现代的 Android 手机开始——选择 Nexus 6 配置文件，然后点击“下一步”：
- en: '![](img/ec1aaa2f-95e5-4292-a5a4-58dcdc39098e.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec1aaa2f-95e5-4292-a5a4-58dcdc39098e.png)'
- en: In the preceding screen, your options will vary based on which SDKs you've installed.
    Which SDK you choose, again, depends on your target audience, application needs,
    and so on. As enjoyable as it always is to use the latest and greatest, we don't
    strictly need any APIs from, say, Nougat. Choosing Android 7.x would restrict
    the availability of Sunago to those on very new phones, and do so for no good
    reason. We will, then, target Lollipop (Android 5.0), which strikes a good balance
    between supporting as many users as possible and providing access to newer Android
    features.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕上，你的选项将取决于你已安装的哪些 SDK。你选择哪个 SDK，再次，取决于你的目标受众、应用需求等等。尽管使用最新和最好的总是令人愉快，但我们并不严格需要来自，比如说，牛轧糖（Nougat）的任何
    API。选择 Android 7.x 将限制 Sunago 的可用性，仅限于非常新的手机，而且这样做没有充分的理由。因此，我们将以 Lollipop（Android
    5.0）为目标，它在支持尽可能多的用户和提供访问最新 Android 功能之间取得了良好的平衡。
- en: Click the Download link if necessary for the x86_64 ABI, select that release,
    click on Next, and then click on Finish on the Verify Configuration screen.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，点击下载链接以获取 x86_64 ABI，选择该版本，点击“下一步”，然后在“验证配置”屏幕上点击“完成”。
- en: With an emulator created, we can now select it in the Select Deployment Target
    screen, and run the application by clicking on OK. If you want to skip the selection
    screen the next time you run the application, you can check the Use same selection
    for future launches checkbox before clicking on OK.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建模拟器后，我们可以在“选择部署目标”屏幕中选择它，并通过点击“确定”来运行应用程序。如果你想在下次运行应用程序时跳过选择屏幕，可以在点击“确定”之前勾选“为未来的启动使用相同的选项”复选框。
- en: 'The first time the application is run, it will take a bit longer, as the application
    is built and packaged and the emulator started. After a few moments, you should
    see the following screen:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行应用程序时，可能会花费更长的时间，因为应用程序需要构建、打包，并且模拟器需要启动。几分钟后，你应该会看到以下屏幕：
- en: '![](img/05f25cda-b28e-407e-9332-7e2d74f8d644.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05f25cda-b28e-407e-9332-7e2d74f8d644.png)'
- en: It's nothing special, but it shows that everything is working as expected. Now,
    we're ready to start the real work in porting Sunago.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有什么特别之处，但它表明一切都在按预期工作。现在，我们已经准备好开始真正的移植 Sunago 的工作。
- en: Building the user interface
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: 'Put simply, Android user interfaces are based on Activities, which use layout
    files to describe the structure of the user interface. There''s more to it, of
    course, but this simple definition should be sufficient for our work on Sunago.
    Let''s start, then, by looking at our `Activity`, `MainActivity`, which is as
    follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，Android 用户界面基于 `Activity`，它们使用布局文件来描述用户界面的结构。当然，还有更多内容，但这个简单的定义应该足以满足我们在
    Sunago 上的工作。那么，让我们首先看看我们的 `Activity`，`MainActivity`，如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This last bit of code is the class exactly as it was generated by Android Studio.
    It''s very basic, but it has most of what you need to create an `Activity`. Note
    that the class extends `AppCompatActivity`. While Google has been very active
    in pushing the Android platform, they have also worked tirelessly to make sure
    that older devices aren''t left behind any sooner than they have to be. To achieve
    that, Google has backported many new features in "compat" (or compatibility) packages,
    which means many of the newer APIs will actually run on older versions of Android.
    The changes, though, since they are in separate packages, won''t break any existing
    functionality--they must be explicitly opted for, which is what we''re doing here.
    While we''re not planning on supporting older versions of Android, such as KitKat,
    it is still suggested that your `Activity` classes extend the compatibility classes,
    like this one, as there is a significant number of features built in to these
    classes that we would otherwise have to implement ourselves. Let''s walk through
    this class to get a sense of what all is going on in the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段最后的代码是 Android Studio 生成的类的确切代码。它非常基础，但它包含了创建 `Activity` 所需的大部分内容。请注意，这个类扩展了
    `AppCompatActivity`。虽然 Google 一直在积极推动 Android 平台，但他们也一直在不懈努力，确保旧设备不会比必要的时间更早被遗弃。为了实现这一点，Google
    已经在 "compat"（或兼容性）包中回滚了许多新特性，这意味着许多新的 API 实际上可以在旧版本的 Android 上运行。然而，由于它们在单独的包中，这些更改不会破坏任何现有功能——它们必须被明确选择，这正是我们在做的事情。虽然我们并不打算支持旧版本的
    Android，如 KitKat，但仍然建议你的 `Activity` 类扩展兼容性类，就像这个例子一样，因为这些类中内置了许多我们否则必须自己实现的功能。让我们按以下步骤逐步分析这个类，以了解其中发生了什么：
- en: The first method is `onCreate()`, which is an `Activity` life cycle method (we'll
    talk more about Activity life cycle in a moment). When the system creates the
    `Activity` class, this method is called. It is here that we initialize the user
    interface, setting values, connection controls to data sources, and so on. Note
    that the method takes a **Bundle**. This is how Android passes in the Activity
    state so that it may be restored.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一种方法是 `onCreate()`，这是一个 `Activity` 生命周期方法（我们稍后会详细讨论 `Activity` 生命周期）。当系统创建
    `Activity` 类时，这个方法会被调用。正是在这里，我们初始化用户界面，设置值，连接到数据源等等。请注意，这个方法接受一个 **Bundle**。这就是
    Android 传递 Activity 状态以便恢复的方式。
- en: In the `setContentView(R.layout.activity_main)` method, we tell the system what
    layout we want to use for this `Activity`. Once we've set the content `View` for
    `Activity`, we can then start acquiring references to various elements. Notice
    that we first look for the `Toolbar` defined in the view, `findViewById(R.id.toolbar)`,
    then we tell Android to use that as our action bar via `setSupportActionBar()`.
    This is an example of a functionality that is implemented for us via the `compat`
    class. If we extended, say, `Activity` directly, we would be required to do much
    more work to make the action bar work. As it is, we call one setter and we're
    done.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setContentView(R.layout.activity_main)` 方法中，我们告诉系统我们想要为这个 `Activity` 使用哪个布局。一旦我们为
    `Activity` 设置了内容 `View`，我们就可以开始获取各种元素的引用。注意，我们首先在视图中寻找定义的 `Toolbar`，使用 `findViewById(R.id.toolbar)`，然后通过
    `setSupportActionBar()` 告诉 Android 使用它作为我们的操作栏。这是一个通过 `compat` 类为我们实现的功能的例子。如果我们直接扩展了
    `Activity`，那么我们需要做更多的工作来使操作栏工作。实际上，我们只需调用一个设置器，就完成了。
- en: Next, we look up another user interface element, the `FloatingActionButton`.
    In the preceding screenshot, this is the button in the lower-right corner with
    the email icon. We will actually be removing this, but, since Android Studio generated
    it, we can learn what we can from it before it is removed. Once we have a reference
    to it, we can attach listeners. In this case, we're adding an `on Click` listener
    by creating an anonymous inner class of type `View.OnClickListener`. This works,
    but we've just spent the last five chapters getting rid of those.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们查找另一个用户界面元素，即`FloatingActionButton`。在上面的截图中，这个按钮位于右下角，带有电子邮件图标。我们实际上会移除这个按钮，但由于Android
    Studio已经生成了它，我们可以在移除之前从中学习到一些东西。一旦我们有了它的引用，我们就可以附加监听器。在这种情况下，我们通过创建一个类型为`View.OnClickListener`的匿名内部类来添加一个`onClick`监听器。这可以工作，但我们刚刚花了五章的时间来消除这些。
- en: 'The Android build system now natively supports using Java 8, so we can modify
    the `onClick` listener registration to look like this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android构建系统现在原生支持使用Java 8，因此我们可以修改`onClick`监听器注册，使其看起来像这样：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the user taps the button, the Snackbar appears. According to the Google
    documentation, *Snackbars provide brief feedback about an operation through a
    message at the bottom of the screen*. And that's exactly what we get--a message
    telling us to replace the `onClick` result with our own action. As stated earlier,
    though, we don't need the floating button, so we'll remove this method and, later,
    the view definition from the layout.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，会出现Snackbar。根据谷歌文档，*Snackbar通过屏幕底部的消息提供关于操作的简短反馈*。这正是我们得到的--一条消息告诉我们用我们自己的操作替换`onClick`结果。然而，如前所述，我们不需要浮动按钮，所以我们将移除此方法，稍后从布局中移除视图定义。
- en: The next method in the class is `onCreateOptionsMenu()`. This method is called
    when the options menu is first opened to populate the list of items. We use `MenuInflater`
    to inflate the menu definition file, and add what it defined there to `Menu` that
    the system passes in. This method is called only once, though, so if you need
    a menu that changes, you should override `onPrepareOptionsMenu(Menu)`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类中的下一个方法是`onCreateOptionsMenu()`。当选项菜单首次打开以填充项目列表时调用此方法。我们使用`MenuInflater`来填充菜单定义文件，并将其中定义的内容添加到系统传入的`Menu`中。然而，此方法只调用一次，因此如果您需要一个会变化的菜单，您应该重写`onPrepareOptionsMenu(Menu)`。
- en: The final method, `onOptionsItemSelected()`, is called when the user taps an
    options menu item. The specific `MenuItem` selected is passed in. We get its ID,
    and call the method appropriate for the menu item.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一种方法是`onOptionsItemSelected()`，当用户点击选项菜单项时会被调用。所选择的特定`MenuItem`会被传入。我们获取其ID，并调用适用于菜单项的方法。
- en: 'That''s a basic `Activity`, but what does a layout look like? Here are the
    contents of `activity_main.xml`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个基本的`Activity`，但布局看起来是什么样子呢？以下是`activity_main.xml`的内容：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That''s a fair bit of XML, so let''s walk through the major items of interest
    quickly, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有相当多的XML，所以让我们快速浏览一下感兴趣的主要项目，如下所示：
- en: The root element is `CoordinatorLayout`. Its Java document describes it as a
    super-powered `FrameLayout`. One of its intended purposes is as *a top-level application
    decor or chrome layout*, which is exactly what we're using it for here. Layouts
    such as `CoordinatorLayout` are roughly analogous to JavaFX's containers. Different
    layouts (or `ViewGroup`) provide a variety of capabilities such as laying out
    elements with exact X/Y coordinates (`AbsoluteLayout`), in a grid (`GridLayout`),
    relative to each other (`RelativeLayout`), and so on.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根元素是`CoordinatorLayout`。它的Java文档将其描述为一个超级强大的`FrameLayout`。其预期用途之一是作为*顶级应用程序装饰或chrome布局*，这正是我们在这里使用的。类似于`CoordinatorLayout`的布局大致相当于JavaFX的容器。不同的布局（或`ViewGroup`）提供了各种功能，例如使用精确的X/Y坐标布局元素（`AbsoluteLayout`）、在网格中布局（`GridLayout`）、相对于彼此布局（`RelativeLayout`）等等。
- en: In addition to providing our top-level container, the element defines a number
    of required XML namespaces. It also sets the height and width for the control.
    There are three possible values for this field--`match_parent` (in earlier versions
    of the SDK, this was called `fill_parent` should you ever come across that), which
    means that the control should match the value of its parent, `wrap_content`, which
    means the control should be just big enough for its contents; or an exact number.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了提供我们的顶级容器外，该元素还定义了多个必需的XML命名空间。它还设置了控件的高度和宽度。此字段有三个可能的值--`match_parent`（在SDK的早期版本中，这被称为`fill_parent`，如果您遇到这种情况），这意味着控件应与其父控件匹配，`wrap_content`，这意味着控件应刚好足够容纳其内容；或者一个确切的数字。
- en: The next element is `AppBarLayout`, which is a `ViewGroup` that implements a
    number of the material designs app bar concepts. **Material design** is the latest
    **visual language** being developed and supported by Google. It provides a modern,
    consistent look and feel across Android apps. Its usage is encouraged by Google,
    and fortunately, the new `Activity` wizard has set us up to use it out of the
    box. The layout's width is set to `match_parent` so that it fills the screen,
    and the width is set to `wrap_content` so that's it's just big enough to show
    its content, which is a single `Toolbar`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个元素是`AppBarLayout`，这是一个实现了许多材料设计应用栏概念的`ViewGroup`。**材料设计**是Google正在开发和支持的最新**视觉语言**。它为Android应用提供了现代、一致的外观和感觉。Google鼓励使用它，幸运的是，新的`Activity`向导已经为我们设置了使用它，无需额外配置。布局的宽度设置为`match_parent`，以便填满屏幕，宽度设置为`wrap_content`，以便它刚好足够显示其内容，即一个单独的`Toolbar`。
- en: Skipping the `include` element for a moment, the last element in the view is
    `FloatingActionButton`. Our only interest here is noting that the widget exists,
    should the need for one arise in other projects. As we did in the `Activity` class
    though, we need to remove this widget.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂时跳过`include`元素，视图中的最后一个元素是`FloatingActionButton`。我们在这里的唯一兴趣是指出该小部件存在，如果其他项目中需要的话。尽管如此，我们像在`Activity`类中做的那样，需要移除这个小部件。
- en: Finally, there's the `include` element. This does what you would think it should--the
    specified file is included in the layout definition as if its contents were hard
    coded into the file. This allows us to keep our layout files small, reuse user
    interface element definitions (which is especially helpful for complex scenarios),
    and so on.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是`include`元素。这个元素的作用正如你所想的那样——指定的文件被包含在布局定义中，就像其内容被硬编码到文件中一样。这允许我们保持我们的布局文件小巧，重用用户界面元素定义（这在复杂场景中尤其有帮助），等等。
- en: 'The included file, `content_main.xml`, looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的文件`content_main.xml`看起来是这样的：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This preceding view uses `RelativeLayout` to wrap its only child, a `TextView`.
    Note that we can set the padding of a control. This controls how much space is
    *inside* the control around its children. Think of it like packing a box--inside
    the box, you may have a fragile ceramic antique, so you pad the box to protect
    it. You can also set the margin of a control, which is the space *outside* the
    control, akin to the personal space around us we are so often fond of.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述视图使用`RelativeLayout`来包裹其唯一的子元素，一个`TextView`。请注意，我们可以设置控件的内边距。这控制了控件周围其子元素内部的多少空间。想象一下装箱——在箱子里，你可能有一个易碎的陶瓷古董，所以你需要填充箱子以保护它。你还可以设置控件的外边距，这是控件外部的空间，类似于我们经常喜欢的个人空间。
- en: 'The `TextView`, though, isn''t helpful, so we''ll remove that, and add what
    we really need, which is a `ListView`, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`TextView`没有帮助，所以我们将其移除，并添加我们真正需要的，那就是`ListView`，如下所示：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`ListView` is a control that shows items in a vertically scrolling list. In
    terms of user experience, this works pretty much like the `ListView` we looked
    at in JavaFX. How it works, though, is quite different. To see how, we need to
    make some adjustments to activity''s `onCreate()` method as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`是一个显示垂直滚动列表中项的控件。在用户体验方面，这几乎与我们在JavaFX中看到的`ListView`一样。然而，它的工作方式却大不相同。要了解它是如何工作的，我们需要对活动的`onCreate()`方法做一些调整，如下所示：'
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are several things going on here, which sets us up nicely for discussing
    data access in Android. Before we get to that in detail, though, a quick overview
    is in order:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在进行几件事情，这为我们讨论Android中的数据访问做好了很好的准备。在我们详细讨论之前，一个快速的概述是必要的：
- en: We check to make sure that the device has a working network connection via `isNetworkAvailable()`,
    which we'll look at later in this chapter.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过`isNetworkAvailable()`检查设备是否有可用的网络连接，我们将在本章稍后讨论它。
- en: If the connection is available, we configure the user interface, starting with
    setting the toolbar.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果连接可用，我们配置用户界面，从设置工具栏开始。
- en: Next, we create an instance of `SunagoCursorAdapter`, which we'll discuss in
    detail later. For now, though, just note that an `Adapter` is how the `ListView`
    is connected to the data source, and they can be backed by things as varied as
    an SQL datasource or an `Array`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个`SunagoCursorAdapter`的实例，我们将在稍后详细讨论。现在，尽管如此，请注意，`Adapter`是`ListView`连接到数据源的方式，它们可以由各种不同的东西支持，如SQL数据源或`Array`。
- en: We pass the adapter to `ListView`, thus completing this connection via `ListView.setAdapter()`.
    Much like JavaFX's `Observable` model property, we'll be able to use this to update
    the user interface without direct interaction any time the data changes.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将适配器传递给`ListView`，通过`ListView.setAdapter()`完成这个连接。就像JavaFX的`Observable`模型属性一样，我们将在数据变化时能够使用它来更新用户界面，而不需要直接交互。
- en: Next, we set up an `onClick` listener for the items in the list. We'll use this
    to display the item the user taps (or clicks) on in an external browser. In a
    nutshell, given the `position` parameter, we get the item at that position, a
    `Cursor`, extract the URL of the item, then display the page at that URL using
    the device's default browser via an `Intent` (which we'll discuss in detail later).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为列表中的项目设置一个`onClick`监听器。我们将使用它来在外部浏览器中显示用户点击（或点击）的项目。简而言之，给定`position`参数，我们获取该位置的项目，一个`Cursor`，提取项目的URL，然后使用设备的默认浏览器通过一个`Intent`（我们将在后面详细讨论）显示该URL对应的页面。
- en: Finally, completing our data binding, we initialize the `LoaderManager` that
    will handle loading and updating the `Adapter` in an asynchronous manner.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，完成我们的数据绑定，我们初始化`LoaderManager`，它将以异步方式处理加载和更新`Adapter`。
- en: 'One last bit of code to look at before diving into data access--`isNetworkAvailable()`--
    is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入数据访问之前，我们来看看最后一段代码——`isNetworkAvailable()`——如下所示：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we start by getting a reference to the system service,
    `ConnectivityManager`, then we loop through each `Network` known to the system.
    For each `Network`, we get a reference to its `NetworkInfo` and call `isConnected()`.
    If we find one connected network, we return true, otherwise, we return false.
    In the calling code, if our return value is `false`, we show an error dialog,
    the method for which is shown here as well. This is a standard Android dialog.
    We have, however, added an `onClick` listener to the OK button, which closes the
    application. Using this, we tell the user that a network connection is needed,
    then close the app when the user taps on OK. It is debatable, of course, if this
    behavior is desirable, but the process for determining a device's network state
    is interesting enough, so I've included it here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先获取系统服务`ConnectivityManager`的引用，然后遍历系统所知的每个`Network`。对于每个`Network`，我们获取其`NetworkInfo`的引用并调用`isConnected()`。如果我们找到一个已连接的网络，我们返回`true`，否则返回`false`。在调用代码中，如果我们的返回值是`false`，我们显示一个错误对话框，该方法的实现也在此处展示。这是一个标准的Android对话框。然而，我们为OK按钮添加了一个`onClick`监听器，它将关闭应用程序。使用这个，我们告诉用户需要一个网络连接，然后在用户点击OK时关闭应用程序。当然，这种行为是否可取是有争议的，但确定设备网络状态的过程本身足够有趣，所以我将其包括在这里。
- en: Let's turn our attention now to how data access is often done in Android apps--`CursorAdapters`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向Android应用中数据访问通常是如何进行的——`CursorAdapters`。
- en: Android data access
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android数据访问
- en: With any platform, there are multiple ways to access data, from built-in facilities
    to homegrown APIs. Android is no different, so while you can write your own way
    to load data from some arbitrary data source, unless you have very particular
    requirements, there is often no need, as Android has a system built in--the `ContentProvider`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何平台上，都有多种方式来访问数据，从内置功能到自建API。Android也不例外，因此虽然你可以编写自己的方式从某些任意数据源加载数据，除非你有非常特定的要求，否则通常没有必要，因为Android内置了一个系统——`ContentProvider`。
- en: The Android documentation will tell you that a *content provider manages access
    to a central repository of data*, and that it offers a consistent, *standard interface
    to data that also handles inter-process communication and secure data access*.
    If you intend to expose your application's data to external sources (either for
    read or write), `ContentProvider` is a great way to go. However, if you don't
    intend to expose your data, you are more than welcome to write the needed CRUD
    methods yourself, manually issuing various SQL statements. In our case, we'll
    use a `ContentProvider`, as we have an interest in allowing third-party developers
    access to the data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Android文档会告诉你，*内容提供者管理对数据中央存储库的访问*，并且它提供了一个一致、*标准的接口来访问数据，同时也处理进程间通信和安全的访问数据*。如果你打算将你的应用程序数据暴露给外部来源（无论是读取还是写入），`ContentProvider`是一个很好的选择。然而，如果你不打算暴露你的数据，你完全可以自己编写所需的CRUD方法，手动发出各种SQL语句。在我们的案例中，我们将使用`ContentProvider`，因为我们有兴趣允许第三方开发者访问数据。
- en: 'To create a `ContentProvider`, we need to create a new class that extends `ContentProvider`
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`ContentProvider`，我们需要创建一个新的类，该类扩展了`ContentProvider`，如下所示：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need to register the provider in `AndroidManfest.xml`, which we''ll
    do like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`AndroidManifest.xml`中注册提供者，我们将这样做：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Interaction with `ContentProvider` is never done directly. The client code will
    specify the URL of the data to be manipulated, and the Android system will direct
    the request to the appropriate provider. To make sure our `ContentProvider` functions
    as expected, then, we need to register the provider's authority, which we've already
    seen in the previous XML. In our provider, we'll create some static fields to
    help us manage the parts of our authority and the related URLs in a DRY manner.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ContentProvider`的交互永远不会直接进行。客户端代码将指定要操作的数据的URL，Android系统将请求定向到适当的提供者。为了确保我们的`ContentProvider`按预期工作，因此，我们需要注册提供者的权限，这我们在之前的XML中已经看到。在我们的提供者中，我们将创建一些静态字段来帮助我们以DRY（Don't
    Repeat Yourself）的方式管理权限的各个部分和相关的URL。
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first two fields in the preceding bit of code are private, as they're not
    needed outside the class. We define them as separate fields here, though, for
    clarity's sake. The third field, `CONTENT_URI`, is public, as we'll be referencing
    that field elsewhere in our app. Third-party consumers won't have access to the
    field, obviously, but will need to know its value, `content://com.steeplesoft.sunago.SunagoProvider/items`,
    which we would document somewhere for add-on developers. The first part of the
    URL, the protocol field, tells Android that we're looking for a `ContentProvider`.
    The next section is the authority, which uniquely identifies a particular `ContentProvider`,
    and the final field specifies the type of data, or model, that we're interested
    in. For Sunago, we have a single data type, `items`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的前两个字段是私有的，因为它们在类外部不需要。不过，我们在这里将它们定义为单独的字段，以便于理解。第三个字段`CONTENT_URI`是公开的，因为我们将在我们的应用程序的其他地方引用该字段。第三方消费者显然无法访问该字段，但他们需要知道其值，即`content://com.steeplesoft.sunago.SunagoProvider/items`，我们将在某处为附加开发者记录此值。URL的第一部分，协议字段，告诉Android我们正在寻找一个`ContentProvider`。下一部分是权限，它唯一地标识了一个特定的`ContentProvider`，最后一部分指定了我们感兴趣的数据类型或模型。对于Sunago，我们有一个单一的数据类型，即`items`。
- en: 'Next, we need to specify the URIs we want to support. We only have two--one
    for the items collection, and one for a particular item. Please, refer to following
    code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要指定我们想要支持的URI。我们只有两个——一个用于项目集合，一个用于特定项目。请参考以下代码片段：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the last code, we start by creating a `UriMatcher`. Note that we pass `UriMatcher.NO_MATCH`
    to the constructor. It's not immediately clear what this value is for, but this
    is the value that will be returned if the user passes in a URI that doesn't match
    any of those registered. Finally, we register each URI with a unique `int` identifier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行代码中，我们首先创建了一个`UriMatcher`。请注意，我们将`UriMatcher.NO_MATCH`传递给构造函数。这个值的具体用途可能并不立即明了，但这是当用户传入一个与已注册的任何URI都不匹配的URI时将返回的值。最后，我们使用唯一的`int`标识符注册每个URI。
- en: 'Next, like many Android classes, we need specify an `onCreate` lifecycle hook
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，像许多Android类一样，我们需要指定一个`onCreate`生命周期钩子，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`SunagoOpenHelper` is a child of `SQLiteOpenHelper`, which manages the creation
    and/or update of the underlying SQLite database. The class itself is pretty simple,
    and is given as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`SunagoOpenHelper`是`SQLiteOpenHelper`的子类，它管理底层SQLite数据库的创建和/或更新。这个类本身相当简单，如下所示：'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I've not shown the table creation DDL, as it's a pretty simple table creation,
    but this class is all you need to create and maintain your database. If you have
    multiple tables, you would issue multiple creates in `onCreate`. When the application
    updates, `onUpgrade()` is called to allow you to modify the schema if needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有展示表创建DDL，因为这是一个相当简单的表创建，但这个类就是你需要创建和维护你的数据库的全部。如果你有多个表，你将在`onCreate`中发出多个创建命令。当应用程序更新时，`onUpgrade()`被调用，以便你可以根据需要修改模式。
- en: 'Back in our `ContentProvider`, we need to implement two methods, one to read
    data, and one to insert (given the nature of the app, we''re not interested in
    deletes or updates right now). For reading data, we override `query()` as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`ContentProvider`中，我们需要实现两个方法，一个用于读取数据，另一个用于插入（鉴于应用的本质，我们现在对删除或更新不感兴趣）。对于读取数据，我们如下重写`query()`方法：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This last code is where our URIs and their `int` identifiers come in. Using
    `UriMatcher`, we check the `Uri` passed in by the caller. Given that our provider
    is simple, the only one we need to do anything special for is `#2`, which is the
    query for a specific item. In that case, we extract the ID passed in as the last
    path segment, and add it to the selection criteria specified by the caller.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段最后的代码是我们URI及其`int`标识符所在的位置。使用`UriMatcher`，我们检查调用者传入的`Uri`。鉴于我们的提供者很简单，我们只需要对`#2`进行特殊处理，即查询特定项。在这种情况下，我们提取传入的ID作为最后一个路径段，并将其添加到调用者指定的选择条件中。
- en: Once we have the query configured as requested, we get a readable `SQLiteDatabase`
    from our `openHelper`, and query it using the values passed by the caller. This
    is one of the areas where the `ContentProvider` contract comes in handy--we don't
    need to write any `SELECT` statements manually.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们按照要求配置了查询，我们就从`openHelper`获取一个可读的`SQLiteDatabase`实例，并使用调用者传递的值进行查询。这是`ContentProvider`契约派上用场的一个领域之一——我们不需要手动编写任何`SELECT`语句。
- en: 'Before returning the cursor, we need to do something to it, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回游标之前，我们需要对其进行一些操作，如下所示：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this preceding call, we tell the system that we want the cursor notified
    when the data is updated. Since we're using a `Loader`, this will allow us to
    update the user interface automatically when data is inserted.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个前置调用，我们告诉系统当数据更新时希望通知游标。由于我们正在使用`Loader`，这将允许我们在数据插入时自动更新用户界面。
- en: 'For inserting data, we override `insert()` as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于插入数据，我们如下重写`insert()`：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using `openHelper`, this time, we get a writable instance of the database, on
    which we call `insert()`. The insert method returns the ID of the row just inserted.
    If we get a non-zero ID, we generate a URI for the row, which we'll eventually
    return. Before we do so, however, we notify the content resolver of the change
    in the data, which triggers our auto-reload in the user interface.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`openHelper`，这次我们获取数据库的可写实例，并调用`insert()`。插入方法返回刚刚插入的行的ID。如果我们得到一个非零ID，我们为该行生成一个URI，我们最终将返回它。然而，在我们这样做之前，我们需要通知内容解析器数据的变化，这将在用户界面中触发自动重新加载。
- en: 'We have one more step to finish our data loading code, though. If you look
    back on `MainActivity.onCreate()`, you''ll see this line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一步来完成我们的数据加载代码。如果你回顾一下`MainActivity.onCreate()`，你会看到这一行：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This last line tells the system that we want to initialize a `Loader` and that
    the `Loader` is `this` or `MainActivity`. In our definition of `MainActivity`,
    we''ve specified that it implements the `LoaderManager.LoaderCallbacks<Cursor>`
    interface. This requires us to implement a few methods as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一行告诉系统我们想要初始化一个`Loader`，并且这个`Loader`是`this`或`MainActivity`。在我们的`MainActivity`定义中，我们已经指定它实现了`LoaderManager.LoaderCallbacks<Cursor>`接口。这要求我们实现一些方法，如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `onCreateLoader()`, we specify both what to load and where to load it. We
    pass in the URI of the `ContentProvider` we just created, we specify the fields
    we're interested in via the `ITEM_PROJECTION` variable (which is a `String[]`,
    and not shown here), and, finally, the sort order (which we've specified as the
    timestamp of the items in descending order so that we get the newest items on
    top). The method `onLoadFinished()` is where the auto-reload happens. Once a new
    `Cursor` is created for the updated data, we swap it in for the `Cursor` that
    `Adapter` is currently using. While you can write your own persistence code, this
    highlights why using the platform facilities, whenever possible, can be a wise
    choice.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreateLoader()`中，我们指定要加载的内容以及加载的位置。我们传入我们刚刚创建的`ContentProvider`的URI，通过`ITEM_PROJECTION`变量（它是一个`String[]`，此处未显示）指定我们感兴趣的字段，最后指定排序顺序（我们指定为按时间戳降序排列，以便将最新项放在顶部）。`onLoadFinished()`方法是在自动重新加载发生的地方。一旦为更新后的数据创建了一个新的`Cursor`，我们就将其交换为`Adapter`当前使用的`Cursor`。虽然你可以编写自己的持久化代码，但这突出了为什么在可能的情况下使用平台功能是一个明智的选择。
- en: 'There is one large item left to look at with regard to data handling-- `SunagoCursorAdapter`.
    Looking again at the Android Javadocs, we learn that *an* `Adapter` *object acts
    as a bridge between an* `AdapterView` *and the underlying data for that view*,
    and that `CursorAdapter` *exposes data from a* `Cursor` *to a* `ListView` *widget*.
    Often--if not in the majority of cases--a particular `ListView` will require a
    custom `CursorAdapter` to allow the underlying data to be rendered correctly.
    Sunago is no exception. To create our `Adapter`, then, we create a new class as
    follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据处理方面，还有一个大项目需要查看——`SunagoCursorAdapter`。再次查看Android Javadocs，我们了解到*一个* `Adapter`
    *对象充当* `AdapterView` *和该视图的底层数据之间的桥梁*，并且`CursorAdapter` *将* `Cursor` *中的数据暴露给*
    `ListView` *小部件*。通常——如果不是大多数情况下——特定的`ListView`将需要一个自定义的`CursorAdapter`，以便正确渲染底层数据。Sunago也不例外。因此，为了创建我们的`Adapter`，我们创建一个新的类，如下所示：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is pretty standard fare. The truly interesting parts come in the view
    creation, which is one of the reasons for being for a `CursorAdapter`. When the
    `Adapter` needs to create a new view to hold the data pointed to by the cursor,
    it calls the following method. This is where we specify what the view should look
    like with the call to `LayoutInflater.inflate()`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当标准。真正有趣的部分在于视图创建，这也是`CursorAdapter`的一个原因。当`Adapter`需要创建一个新的视图来持有由游标指向的数据时，它调用以下方法。这就是我们通过调用`LayoutInflater.inflate()`指定视图外观的地方：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We''ll look at our layout definition in a moment, but first, let''s take a
    look at `ViewHolder`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会查看我们的布局定义，但首先，让我们看看`ViewHolder`：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finding views by ID can be an expensive operation, so a very common pattern
    is this `ViewHolder` approach. After the view is inflated, we immediately look
    up the fields we're interested in, and store those references in a `ViewHolder`
    instance, which is then stored as the tag on the `View`. Since views are recycled
    by the `ListView` class (meaning, they're reused as needed as you scroll through
    the data), this expensive `findViewById()` is called once and cached per `View`
    rather than once per item in the underlying data. For large datasets (and complex
    views), this can be a substantial performance boost.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过ID查找视图可能是一个昂贵的操作，因此一个非常常见的模式是这种`ViewHolder`方法。在视图被展开之后，我们立即查找我们感兴趣的字段，并将这些引用存储在`ViewHolder`实例中，然后将其作为`View`的标签存储。由于视图是由`ListView`类回收的（这意味着，当你滚动数据时，它们按需被重复使用），因此这个昂贵的`findViewById()`方法只对每个`View`调用一次并缓存，而不是对底层数据中的每个项目调用一次。对于大型数据集（和复杂视图），这可以显著提高性能。
- en: In this method, we also set the size of the `ImageView` class. Android doesn't
    support setting the width of a view to a percentage via the XML markup (given
    next), so we do that manually here as we create the `View`. We get the `WindowManager`
    system service from which we get the default display's size. We multiply the display's
    width by 0.33, which will restrict the image, if any, to 1/3 of the display's
    width, and set the `ImageView`'s width to that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们还设置了`ImageView`类的尺寸。Android不支持通过XML标记设置视图的宽度为百分比（如下所示），因此我们在创建`View`时手动设置。我们从`WindowManager`系统服务中获取默认显示的大小。我们将显示的宽度乘以0.33，这将限制（如果有）图像为显示宽度的1/3，并将`ImageView`的宽度设置为该值。
- en: So, what does the view look like for each row?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，每一行的视图看起来是什么样子？
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As the `ViewHolder` hinted, our view consists of an `ImageView` and a `TextView`,
    presented horizontally, thanks to the enclosing `LinearLayout`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`ViewHolder`所暗示的，我们的视图由一个`ImageView`和一个`TextView`组成，由于包含的`LinearLayout`而水平排列。
- en: 'While `CursorAdapter` calls `newView()` to create a `View`, it calls `bindView()`
    to--if you can imagine--bind the `View` to a specific row in the `Cursor`. This
    is where `View` recycling comes into play. The `Adapter` has a number of `View`
    instances cached, and passes one to this method as needed. Our method looks like
    this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CursorAdapter`调用`newView()`来创建`View`时，它调用`bindView()`来——如果你能想象的话——将`View`绑定到`Cursor`中的特定行。这就是`View`回收发挥作用的地方。`Adapter`缓存了多个`View`实例，并按需将一个传递给此方法。我们的方法如下所示：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start by getting the `ViewHolder` instance. As discussed previously, we'll
    use the widget references stored here to update the user interface. Next, we pull
    the image URL from the cursor. It's up to each `SocialMediaItem` to decide how
    this field is populated, but it might be a tweeted image or a photo in an Instagram
    post. If the item has one, we need to download it so that it can be displayed.
    Since this requires a network operation, and we're running on the user interface
    thread, we hand that work off to `DownloadImageTask`. If there is no image for
    this item, we need to set the bitmap for the image to `null` (otherwise, the image
    that was there the last time this view instance was used would be displayed again).
    That frees up some memory, which is always good, but we also set the `ImageView`
    class' visibility to `GONE`, which hides it from the user interface. You might
    be tempted to use `INVISIBLE`, but that only makes it invisible **while preserving
    its space in the user interface**. The end result of that would be a big blank
    square, which is not what we want. Finally, we set the text of the `TextView`
    body to the text specified for the item.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取`ViewHolder`实例。如前所述，我们将使用这里存储的小部件引用来更新用户界面。接下来，我们从游标中拉取图像URL。每个`SocialMediaItem`都必须决定如何填充这个字段，但它可能是一个推文中的图像或Instagram帖子中的照片。如果项目有一个，我们需要下载它以便显示。由于这需要网络操作，而我们正在用户界面线程上运行，所以我们把这个工作交给`DownloadImageTask`。如果没有这个项目的图像，我们需要将图像的位图设置为`null`（否则，上次使用这个视图实例时存在的图像将再次显示）。这样可以释放一些内存，这总是好的，但我们还设置了`ImageView`类的可见性为`GONE`，这样它就从用户界面中隐藏了。你可能想使用`INVISIBLE`，但这只会使其在**保留其在用户界面中的空间**的同时不可见。这样做的结果将是一个大空白方块，这不是我们想要的。最后，我们将`TextView`正文的文本设置为项目指定的文本。
- en: 'The image downloading is handled off-thread by an `AsyncTask`, which is as
    follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图片下载由一个`AsyncTask`在后台线程处理，如下所示：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Android will create a background `Thread` on which to run this task. The main
    entry point for our logic is `doInBackground()`. Please refer the following snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓将为这个任务创建一个后台`Thread`。我们逻辑的主要入口点是`doInBackground()`。请参考以下代码片段：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is not the most robust download code imaginable (for example, redirect
    status codes are happily ignored), but it's certainly usable. Using Java 7's `try-with-resources`,
    we create a `URL` instance on which we call `openStream()`. Assuming no `Exception`
    is thrown in either of those operations, we call `BitmapFactory.decodeStream()`
    to convert the incoming bytes into a `Bitmap`, which is what the method is expected
    to return.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是最健壮的可想象下载代码（例如，重定向状态码被愉快地忽略），但它确实可用。使用Java 7的`try-with-resources`，我们在一个`URL`实例上调用`openStream()`。假设在这两个操作中都没有抛出`Exception`，我们调用`BitmapFactory.decodeStream()`将传入的字节转换为`Bitmap`，这正是该方法预期返回的内容。
- en: 'So, what happens to the `Bitmap` once we return it? We process that in `onPostExecute()`
    like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一旦我们返回`Bitmap`，会发生什么？我们像这样在`onPostExecute()`中处理它：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this last method, we update `ImageView` with our now downloaded `Bitmap`,
    makes it `VISIBLE`, then request that the view update itself on the screen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的方法中，我们使用现在下载的`Bitmap`更新`ImageView`，使其`VISIBLE`，然后请求视图在屏幕上更新自己。
- en: So far, we've built an app that's capable of displaying `SocialMediaItem` instances,
    but we have nothing for it to show. We'll fix that now with a look at Android
    Services.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个能够显示`SocialMediaItem`实例的应用程序，但我们没有东西可以显示。现在我们将通过查看安卓服务来解决这个问题。
- en: Android services
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓服务
- en: 'For the desktop version of Sunago, we defined an API that would allow third-party
    developers (or ourselves) to add support for an arbitrary social network to Sunago.
    That was a great goal for the desktop, and it''s a great goal for mobile. Fortunately,
    Android provides us with a mechanism that can be used to do just that: Services.
    *A Service is an application component representing either an application''s desire
    to perform a longer-running operation while not interacting with the user or to
    supply functionality for other applications to use*. While services were designed
    for more than extensibility, we can leverage this facility to that end.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Sunago的桌面版本，我们定义了一个API，允许第三方开发者（或我们自己）为Sunago添加对任意社交网络的支持。这是一个桌面上的伟大目标，也是移动端的伟大目标。幸运的是，Android为我们提供了一个机制，可以用来实现这一点：服务。*服务是一个应用程序组件，代表应用程序希望在不对用户进行交互的情况下执行长时间运行的操作，或者为其他应用程序提供功能使用*。虽然服务是为更多扩展性而设计的，但我们可以利用这个设施来实现这一目标。
- en: 'While there are a number of ways to implement and interact with services, we
    are going to bind the services to our `Activity` so that their life cycle is tied
    to that of our `Activity`, and we''ll send messages to them asynchronously. We''ll
    start by defining our class as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有几种方式来实现和与服务交互，但我们将把服务绑定到我们的`Activity`上，以便它们的生命周期与我们的`Activity`绑定，并且我们将异步地向它们发送消息。我们将首先按照以下方式定义我们的类：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Technically, these are the only methods required to create a service. Clearly,
    it doesn''t do much, but we''ll fix that in just a moment. Before we do that,
    we need to declare our new `Service` to Android which is done in `AndroidManifest.xml`,
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这些是创建服务所需的所有方法。显然，它并没有做什么，但我们将很快修复这个问题。在我们这样做之前，我们需要向Android声明我们的新`Service`，这通过`AndroidManifest.xml`完成，如下所示：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notice that, in addition to the service declaration, we also specify an `IntentFilter`
    via the `intent-filter` element. We''ll use that in `MainActivity` later to find
    and bind our services. While we''re looking at our service, though, let''s look
    at this side of the binding process. We''ll need to implement these two lifecycle
    methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了服务声明之外，我们还通过`intent-filter`元素指定了一个`IntentFilter`。我们将在`MainActivity`中稍后使用它来查找和绑定我们的服务。尽管我们在查看我们的服务，但让我们看看绑定过程的这一方面。我们需要实现这两个生命周期方法：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These preceding methods are called when the service is bound and unbound, which
    give us an opportunity to register our receiver, which may lead to the question:
    What''s that? Android provides an **Interprocess Communication** (**IPC**), but
    it is somewhat limited in that the payload size can not exceed 1 MB. Though our
    payload is only text, we can (and certainly will, based on my testing) exceed
    that. Our approach, then, will be to use asynchronous communication, via a receiver,
    and have the service persist the data via our `ContentProvider`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在服务绑定和解除绑定时被调用，这为我们提供了注册我们的接收器的机会，这可能会引发以下问题：那是什么？Android提供了**进程间通信**（**IPC**），但它有一定的局限性，即有效负载大小不能超过1
    MB。尽管我们的有效负载只是文本，但我们（根据我的测试，肯定会的）会超过那个限制。因此，我们的方法将是使用通过接收器进行的异步通信，并通过我们的`ContentProvider`让服务持久化数据。
- en: 'To create a receiver, we extend `android.content.BroadcastReceiver` as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个接收器，我们按照以下方式扩展`android.content.BroadcastReceiver`：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our message scheme is very simple--Sunago sends the message `REFRESH`, and the
    service performs its work, which we have wrapped up in `TwitterUpdatesAsyncTask`.
    In `onBind()`, we register the receiver with a specific `IntentFilter` that specifies
    the `Intent` broadcasts that we're interested in. In `onUnbind()`, we unregister
    our receiver as the service is released.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消息方案非常简单——Sunago发送`REFRESH`消息，服务执行其工作，我们将这些工作封装在`TwitterUpdatesAsyncTask`中。在`onBind()`中，我们使用特定的`IntentFilter`注册接收器，该`IntentFilter`指定了我们感兴趣的`Intent`广播。在`onUnbind()`中，当服务释放时，我们注销我们的接收器。
- en: 'The rest of our service is in our `AsyncTask`, which is given as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务的其余部分在我们的`AsyncTask`中，如下所示：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We need to make sure that the network operation isn't performed on the user
    interface thread, so we perform the work in `AsyncTask`. We don't need any parameters
    passed into the task, so we set the `Params` and `Progress` types to `Void`. We
    are, though, interested in the `Result` type, which is `List<ContentValue>`, which
    we see reflected in both the type declaration and the return type of `execute()`.
    In `onPostExecute()`, we then issue a bulk insert on `ContentProvider` to save
    the data. In this way, we can make the newly-retrieved data available to the application
    without running afoul the 1 MB limit with `IBinder`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保网络操作不在用户界面线程上执行，因此我们在`AsyncTask`中执行工作。我们不需要将任何参数传递到任务中，因此我们将`Params`和`Progress`类型设置为`Void`。然而，我们对`Result`类型感兴趣，它是`List<ContentValue>`类型，这在类型声明和`execute()`的返回类型中都有体现。然后在`onPostExecute()`中，我们对`ContentProvider`执行批量插入以保存数据。这样，我们可以在不违反1
    MB限制的情况下，通过`IBinder`使新检索到的数据对应用程序可用。
- en: 'With our service defined, we need now to look at how to find and bind the services.
    Looking back at `MainActivity`, we''ll finally look at a method we''ve already
    seen mentioned, `findPlugins()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的服务之后，我们现在需要看看如何查找和绑定服务。回顾`MainActivity`，我们最终将查看一个已经提到过的方法，即`findPlugins()`：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To find the plugins we're interested in, we create an `Intent` with a specific
    action. In this case, that action is `com.steeplesoft.sunago.intent.plugin`, which
    we've already seen in the service definition in `AndroidManifest.xml`. Using this
    `Intent`, we query `PackageManager` for all `IntentServices` matching Intent.
    Next, we iterate over the list of `ResolveInfo` instances, getting the `ServiceInfo`
    instances, and create and store a `ComponentName` representing the plugin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到我们感兴趣的插件，我们创建一个具有特定操作的`Intent`。在这种情况下，该操作是`com.steeplesoft.sunago.intent.plugin`，我们已经在`AndroidManifest.xml`中的服务定义中看到过。使用此`Intent`，我们查询`PackageManager`以获取所有匹配Intent的`IntentServices`。接下来，我们遍历`ResolveInfo`实例的列表，获取`ServiceInfo`实例，并创建并存储一个代表插件的`ComponentName`。
- en: 'The actual binding of the services is done in the following `bindPlugins()`
    method, which we call from the `onStart()` method to make sure the binding occurs
    at the appropriate time in activity''s lifecycle:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的服务绑定是在下面的`bindPlugins()`方法中完成的，我们从`onStart()`方法中调用它，以确保在活动生命周期中适当的时间进行绑定：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For each plugin found, we create an `Intent` using the `ComponentName` we created
    earlier. Each service binding will need a `ServiceConnection` object. For that,
    we created `PluginServiceConnection`, which implements the interface. Its methods
    are empty, so we'll not look at that class here. With our `ServiceConnection`
    instance, we can now bind the service with a call to `bindService()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于找到的每个插件，我们使用之前创建的`ComponentName`创建一个`Intent`。每个服务绑定都需要一个`ServiceConnection`对象。为此，我们创建了`PluginServiceConnection`，它实现了该接口。其方法都是空的，所以我们在这里不会查看该类。有了我们的`ServiceConnection`实例，我们现在可以通过调用`bindService()`来绑定服务。
- en: 'Finally, to clean up as the application is closing, we need to unbind our services.
    From `onStop()`, we call this method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当应用程序关闭时，我们需要解绑我们的服务。从`onStop()`方法中，我们调用此方法：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we simply loop through our `ServiceConnection` plugins, passing each to
    `unbindService()`, which will allow Android to garbage collect any services we
    may have started.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是简单地遍历我们的`ServiceConnection`插件，将每个传递给`unbindService()`，这将允许Android垃圾回收我们可能已启动的任何服务。
- en: 'So far, we''ve defined a service, looked it up, and bound it. But how do we
    interact with it? We''ll go the simple route, and add an option menu item. To
    do that, we modify `res/menu/main_menu.xml` as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了一个服务，查找并绑定它。但我们如何与之交互呢？我们将走一条简单的路线，并添加一个选项菜单项。为此，我们按照以下方式修改`res/menu/main_menu.xml`：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To respond to the menu item being selected, we need to revisit `onOptionsItemSelected()`
    here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应当前菜单项的选择，我们需要重新审视这里的`onOptionsItemSelected()`方法：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `switch` block of the preceding code, we add a `case` label for `R.id.action_refresh`,
    which matches the ID of our newly added menu item in which we call the method
    `sendRefreshMessage()`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的`switch`块中，我们为`R.id.action_refresh`添加了一个`case`标签，它与我们的新添加的菜单项的ID相匹配，在其中我们调用`sendRefreshMessage()`方法：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first method is pretty straightforward. In fact, it might not even be necessary,
    given its simplicity, but it does add semantic clarity to the consuming code,
    so I think it's a good method to add.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法相当直接。实际上，鉴于其简单性，它可能甚至不是必需的，但它确实为消费代码增加了语义清晰度，所以我认为这是一个很好的方法来添加。
- en: The interesting part, however, is the method `sendMessage()`. We start by creating
    an `Intent` that specifies our action, `sunago.service`. This is an arbitrary
    string that we define, and then document for any third-party consumers. This will
    help our services filter out messages that are of no interest, which is exactly
    what we did in `TwitterService.onBind()` with the call to `registerReceiver(receiver,
    new IntentFilter("sunago.service"))`. We then add the message that our app wants
    to send (`REFRESH`, in this case) as an extra on `Intent`, which we then broadcast
    via `sendBroadcast()`. From here, Android will handle delivering the message to
    our service, which is already running (since we've bound it to our `Activity`)
    and listening (as we registered a `BroadcastReceiver`).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有趣的部分是`sendMessage()`方法。我们首先创建一个指定我们的操作`sunago.service`的`Intent`。这是一个我们定义的任意字符串，并且为任何第三方消费者进行文档说明。这将帮助我们的服务过滤掉无兴趣的消息，这正是我们在`TwitterService.onBind()`中通过调用`registerReceiver(receiver,
    new IntentFilter("sunago.service"))`所做的事情。然后，我们将我们的应用程序想要发送的消息（在这种情况下为`REFRESH`）作为`Intent`上的额外内容添加，然后通过`sendBroadcast()`广播。从这里开始，Android将处理将消息传递到我们的服务，该服务已经运行（因为我们将其绑定到我们的`Activity`）并且正在监听（因为我们注册了一个`BroadcastReceiver`）。
- en: Android tabs and fragments
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android标签和片段
- en: We've looked at quite a bit, but there is still a fair bit we haven't seen,
    such as the implementation for `TwitterClient`, as well as any details on the
    integration of networks, such as Instagram, which we saw in the last chapter.
    For the most part, `TwitterClient` is identical to what we saw in [Chapter 21](d1cb41cc-d5b4-4f0d-a4ac-c41889568a76.xhtml),
    *Sunago - A Social Media Aggregator*. The only major difference is in the use
    of the stream APIs. Some APIs are only available in certain Android versions,
    specifically, version 24, also known as Nougat. Since we're targeting Lollipop
    (SDK version 21), we are unable to use them. That aside, the internal logic and
    API usage are identical. You can see the details in the source repository. Before
    we finish, though, we need to take a look at the Twitter preferences screen, as
    there are some interesting items there.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了很多，但还有很多我们没有看到，比如`TwitterClient`的实现，以及关于Instagram等网络集成的任何细节，这些我们在上一章中已经看到。就大部分而言，`TwitterClient`与我们看到的[第21章](d1cb41cc-d5b4-4f0d-a4ac-c41889568a76.xhtml)中的内容相同，即*Sunago
    - 社交媒体聚合器*。唯一的重大区别在于流API的使用。某些API仅在特定的Android版本中可用，具体来说，是版本24，也称为Nougat。由于我们针对的是Lollipop（SDK版本21），我们无法使用它们。除此之外，内部逻辑和API使用是相同的。您可以在源代码库中查看详细信息。在我们完成之前，我们还需要查看Twitter首选项屏幕，因为那里有一些有趣的项目。
- en: 'We''ll start with a tab layout activity, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从标签布局活动开始，如下所示：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For making a tabbed interface, we need two things--`FragmentPagerAdapter` and
    `ViewPager`. The `ViewPager` is a user-interface element that actually shows the
    tabs. Think of it as `ListView` for tabs. The `FragmentPagerAdapter`, then, is
    like `CursorAdapter` for the tabs. Instead of an SQL-backed data source, though,
    `FragmentPagerAdapter` is an adapter that represents pages as Fragments. In this
    method, we create an instance of our `SectionsPagerAdapter`, and set it as the
    adapter on our `ViewPager`. We also associate the `ViewPager` element with the
    `TabLayout`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建标签界面，我们需要两个东西——`FragmentPagerAdapter`和`ViewPager`。`ViewPager`是一个用户界面元素，实际上显示了标签。将其视为标签的`ListView`。那么，`FragmentPagerAdapter`就像标签的`CursorAdapter`。然而，与基于SQL的数据源不同，`FragmentPagerAdapter`是一个将页面表示为片段的适配器。在这个方法中，我们创建了一个`SectionsPagerAdapter`的实例，并将其设置为`ViewPager`上的适配器。我们还关联了`ViewPager`元素与`TabLayout`。
- en: '`SectionsPagerAdapter` is a simple class, and is written as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`SectionsPagerAdapter`是一个简单的类，编写方式如下：'
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The method `getCount()` tells the system how many tabs we support, the title
    for each tab that is returned by `getPageTitle()`, and the `Fragment` representing
    the selected tab is returned from `getItem()`. In this example, we create a `Fragment`
    instance as needed. Note, we hint at Instagram support here, but its implementation
    looks strikingly similar to the Twitter implementation, so we won't go into detail
    on that here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCount()`方法告诉系统我们支持多少个标签，每个标签的标题由`getPageTitle()`返回，而表示所选标签的`Fragment`则由`getItem()`返回。在这个例子中，我们根据需要创建一个`Fragment`实例。注意，我们在这里暗示了对Instagram的支持，但其实现与Twitter的实现非常相似，所以在这里我们不会详细介绍。'
- en: '`TwitterPreferencesFragment` looks as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwitterPreferencesFragment`看起来如下：'
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Fragments have a slightly different lifecycle than an `Activity`. Here, we inflate
    the view in `onCreateView()`, then we update the user interface with the current
    state from `onStart()`. What does the view look like? That's determined by `R.layout.fragment_twitter_preferences`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Activity`相比，片段（Fragments）具有稍微不同的生命周期。在这里，我们在`onCreateView()`中填充视图，然后从`onStart()`中更新用户界面以显示当前状态。视图看起来是什么样子？这由`R.layout.fragment_twitter_preferences`决定。
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In a nutshell, as you can see in the preceding code, we have a button for logging
    in and out, and a `ListView` for allowing the user to select which Twitter lists
    from which to load data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如您在前面代码中所见，我们有一个用于登录和注销的按钮，以及一个`ListView`，允许用户选择从哪些Twitter列表加载数据。
- en: 'Given the frequent use of the network for interacting with Twitter plus Android''s
    aversion to network access on the user interface thread, the code here gets a
    little complicated. We can see the start of that in `updateUI()`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于频繁使用网络与Twitter交互，以及Android对在用户界面线程上访问网络的厌恶，这里的代码变得有些复杂。我们可以在`updateUI()`中看到这一点，如下所示：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first thing that should stand out in the last code is that first line. Since
    we're updating the user interface, we have to make sure this code runs on the
    user interface thread. To make that happen, we wrap our logic in a `Runnable`,
    and pass that to the method `runOnUiThread()`. In `Runnable`, we check to see
    if the user is logged in or not. If not, we set the `prefsLayout` section's visibility
    to `GONE`, set the `Button`'s text to Login, and set its `onClick` listener to
    a `View.OnClickListener` method that executes `TwitterAuthenticateTask`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一段代码中，最引人注目的是第一行。由于我们正在更新用户界面，我们必须确保此代码在用户界面线程上运行。为了实现这一点，我们将我们的逻辑包装在一个 `Runnable`
    中，并将其传递给 `runOnUiThread()` 方法。在 `Runnable` 中，我们检查用户是否已登录。如果没有，我们将 `prefsLayout`
    部分的可见性设置为 `GONE`，将 `Button` 的文本设置为登录，并将其 `onClick` 监听器设置为执行 `TwitterAuthenticateTask`
    的 `View.OnClickListener` 方法。
- en: If the user is not logged in, we do the opposite--make `prefsLayout` visible,
    set the `Button` text to Logout, set the `onClick` to an anonymous `View.OnClickListener`
    class that removes the authentication-related preferences, and recursively call
    `updateUI()` to make sure the interface is updated to reflect the logout.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户未登录，我们执行相反的操作--使 `prefsLayout` 可见，将 `Button` 文本设置为注销，将 `onClick` 设置为一个匿名
    `View.OnClickListener` 类，该类删除与身份验证相关的首选项，并递归调用 `updateUI()` 确保界面更新以反映注销操作。
- en: '`TwitterAuthenticateTask` is another `AsyncTask` that handles authenticating
    with Twitter. To authenticate, we have to get a Twitter request token, which requires
    network access, so this must be done off of the user interface thread, thus, `AsyncTask`.
    Please refer to the following code snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwitterAuthenticateTask` 是另一个处理与 Twitter 进行身份验证的 `AsyncTask`。为了进行身份验证，我们必须获取一个
    Twitter 请求令牌，这需要网络访问，因此必须在用户界面线程之外完成，这就是为什么使用 `AsyncTask`。请参考以下代码片段：'
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once we have the `RequestToken`, we show the `WebLoginActivity` from which the
    user will enter the credentials for the service. We'll look at that in the next
    code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `RequestToken`，我们就显示 `WebLoginActivity`，用户将在此处输入服务的凭据。我们将在下一个代码中查看这一点。
- en: When that activity returns, we need to check the results and respond appropriately.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当该活动返回时，我们需要检查结果并相应地做出反应。
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When we started `WebLoginActivity`, we specified that we wanted to get a result,
    and we specified an identifier, `LOGIN_REQUEST`, which is set to 1, to uniquely
    identify which `Activity` was returning the result. If `requestCode` is `LOGIN_REQUEST`,
    and the result code is `Activity.RESULT_OK` (see `WebLoginActivity` given next),
    then we have a successful response, and we need to finish the login process, for
    which we'll use another `AsyncTask`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动 `WebLoginActivity` 时，我们指定我们想要获取一个结果，并指定了一个标识符，`LOGIN_REQUEST`，将其设置为 1，以唯一标识哪个
    `Activity` 正在返回结果。如果 `requestCode` 是 `LOGIN_REQUEST`，并且结果代码是 `Activity.RESULT_OK`（见下面的
    `WebLoginActivity`），那么我们有一个成功的响应，我们需要完成登录过程，我们将使用另一个 `AsyncTask`。
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In `doInBackground()`, we perform the network operation. When we have a result,
    the `AccessToken`, we use that to authenticate our `TwitterClient` instance, then
    we return the token. In `onPostExecute()`, we save the `AccessToken` details to
    `SharedPreferences`. Technically, all of this could have been done in `doInBackground()`,
    but I find it helpful, especially when learning something new, not to cut corners.
    Once you're comfortable with how all of this works, you are, of course, free to
    cut corners when and where you feel comfortable doing so.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `doInBackground()` 中，我们执行网络操作。当我们有一个结果，即 `AccessToken` 时，我们使用它来验证我们的 `TwitterClient`
    实例，然后返回令牌。在 `onPostExecute()` 中，我们将 `AccessToken` 的详细信息保存到 `SharedPreferences`。技术上，所有这些都可以在
    `doInBackground()` 中完成，但我发现，特别是在学习新事物时，不偷工减料是有帮助的。一旦你对所有这些如何工作感到舒适，当然，你当然可以在你觉得舒服的时候和地方偷工减料。
- en: We have one last piece to look over, `WebLoginActivity`. Functionally, it is
    identical to `LoginActivity`--it presents a web view which displays the login
    page for the given network. When the login succeeds, the needed information is
    returned to the calling code. This being Android rather than JavaFX, the mechanics
    are, of course, a little different.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有最后一部分要检查，`WebLoginActivity`。从功能上讲，它与 `LoginActivity` 相同--它显示一个网页视图，显示给定网络的登录页面。当登录成功时，所需的信息将返回给调用代码。由于这是
    Android 而不是 JavaFX，因此机制当然略有不同。
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Most of this preceding code looks very much like the other `Activity` classes
    we've written. We do some basic user interface set up, then, getting a reference
    to the `Intent`, we extract the two parameters of interest--the URL of the login
    page, and the query parameter that indicates a successful login.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的大部分代码看起来非常像我们编写的其他 `Activity` 类。我们进行了一些基本的用户界面设置，然后获取 `Intent` 的引用，提取两个感兴趣的参数——登录页面的
    URL 和表示成功登录的查询参数。
- en: 'To participate in the page loading life cycle, we extend `WebViewClient` (which
    we then attach to `WebView` in `Activity`, as seen previously). This is done as
    follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要参与页面加载生命周期，我们扩展 `WebViewClient`（然后将其附加到 `Activity` 中的 `WebView`，如之前所见）。这是通过以下方式完成的：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: While `WebViewClient` offers a myriad of life cycle events, we're only concerned
    with one right now, `onPageStarted()`, which is fired, as expected, when the page
    starts to load. By hooking in here, we can look at the URL before the related
    network activity begins. We can examine the desired URL to see if the query parameter
    of interest is present. If it is, we create a new `Intent` to pass data back to
    the caller, copy all of the query parameters to it, set the `Activity` result
    to `RESULT_OK`, and finish the `Activity`. If you look back at `onActivityResult()`,
    you should see now from where `resultCode` comes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `WebViewClient` 提供了众多生命周期事件，但我们目前只关注其中一个，即 `onPageStarted()`，它会在页面开始加载时触发。正如预期的那样，在这里挂钩，我们可以在相关的网络活动开始之前查看
    URL。我们可以检查所需的 URL 是否包含感兴趣的查询参数。如果存在，我们创建一个新的 `Intent` 来将数据传回调用者，将所有查询参数复制到其中，将
    `Activity` 的结果设置为 `RESULT_OK`，并结束 `Activity`。如果你回顾一下 `onActivityResult()`，你现在应该可以看到
    `resultCode` 的来源。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, our application is complete. It's not a perfect application, but
    it is a complete Android application, which demonstrates a number of features
    you might need in your own app including `Activities`, services, database creation,
    content providers, messaging, and asynchronous processing. Clearly, there are
    parts of the application where the error handling could be more robust, or the
    design generalized a bit more to be more readily reusable. Doing so in this context,
    however, would obscure the basics of the application too much. Making these changes,
    then, will make a great exercise for the reader.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的应用程序就完成了。它不是一个完美的应用程序，但它是一个完整的 Android 应用程序，展示了你可能在自己的应用程序中需要的许多功能，包括
    `Activities`、服务、数据库创建、内容提供者、消息传递和异步处理。显然，应用程序中的一些错误处理可以更健壮，或者设计可以更通用一些，以便更容易重用。然而，在这个上下文中这样做会过多地掩盖应用程序的基本原理。因此，对这些更改进行修改将是一个很好的练习，供读者参考。
- en: In the next chapter, we'll take a look at a completely different type of application.
    We'll build a small utility to handle what can be a serious problem--too much
    email. This application will allow us to describe a set of rules that will delete
    or move emails. It's a simple concept, but it will allow us to work with JSON
    APIs and the `JavaMail` package. You'll learn a bit and end up with a useful little
    utility as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将查看一种完全不同类型的应用程序。我们将构建一个小型实用程序来处理可能是一个严重问题——邮件过多。这个应用程序将允许我们描述一系列规则来删除或移动邮件。这是一个简单的概念，但它将允许我们与
    JSON API 和 `JavaMail` 包一起工作。你将学到一些东西，并最终得到一个有用的实用程序。
