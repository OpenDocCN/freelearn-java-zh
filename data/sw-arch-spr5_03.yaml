- en: Spring Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring项目
- en: In this chapter, we will review some Spring projects, looking at a brief explanation
    of each of them as we explore some scenarios in which they may be used.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一些Spring项目，简要解释每个项目，并探讨它们可能被使用的一些场景。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Why Spring appeared
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么出现了Spring
- en: 'Spring projects:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring项目：
- en: Spring Initializr
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Initializr
- en: Spring Boot in a Nutshell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot简介
- en: Avoiding redeployment with developer tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开发者工具避免重新部署
- en: Spring Data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data
- en: Supporting EIPs with Spring Integration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Integration支持EIP
- en: Spring Batch
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Batch
- en: Securing applications with Spring Security
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Security保护应用程序
- en: Embracing (Spring) HATEOAS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥抱（Spring）HATEOAS
- en: Spring Cloud and the microservices world
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud和微服务世界
- en: Reactive and Spring
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式和Spring
- en: Reactive Spring Data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式Spring Data
- en: Reactive REST services
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式REST服务
- en: Why Spring appeared
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么出现了Spring
- en: As you probably know, Spring was created with the intention of simplifying all
    of the complexity of the J2EE world. It was created as a dependency injection
    framework and as an alternative to the EJB stack with distributed objects, which
    was unnecessary in most applications. The traditional approach to J2EE introduced
    a lot of complexity when it was used to bootstrap an application, and this involved
    even more complexity when used to accomplish the business requirements it had
    to solve. Consequently, we were left with applications that were difficult to
    test and were too costly to develop and maintain.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能知道的，Spring是为了简化J2EE世界的所有复杂性而创建的。它被创建为一个依赖注入框架，作为EJB堆栈的替代品，分布式对象在大多数应用程序中是不必要的。传统的J2EE方法在用于引导应用程序时引入了很多复杂性，当用于解决业务需求时，这甚至更加复杂。因此，我们留下了难以测试且开发和维护成本过高的应用程序。
- en: Spring and J2EE were created when Java didn't have annotations, so big XML files
    were necessary for wire classes. Fortunately, annotations became available in
    version 1.5 of the **Java Development Kit** (**JDK**), and that helped to reduce
    the need for such descriptor files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Spring和J2EE是在Java还没有注解时创建的，因此需要大量的XML文件来连接类。幸运的是，在Java开发工具（JDK）的1.5版本中引入了注解，这有助于减少这些描述文件的需求。
- en: Spring evolves faster than JEE, since it doesn't have to satisfy the formality
    of talking with a large committee, as required for JEE. When a new feature has
    to be incorporated as part of the JEE specification, a JSR document has to be
    created and approved by the JCP. The main motivation for this is that it guarantees
    backward and forward compatibility among the different versions of the specification.
    On the other hand, Spring is a project that is always evolving, considering the
    constantly changing nature of the software industry.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的发展速度比JEE快，因为它不必满足与JEE所需的大型委员会交流的正式性。当需要将新功能纳入JEE规范时，必须创建JSR文档，并经JCP批准。这样做的主要动机是确保规范的不同版本之间的向后和向前兼容性。另一方面，Spring是一个不断发展的项目，考虑到软件行业不断变化的性质。
- en: When a new feature is required, it is either embraced as a part of an existing
    project, or a new project is created and supported by the Spring project umbrella.
    There is no reason to be worried about compatibility, since Spring is designed
    to run on any servlet container, such as Apache Tomcat, Jetty, and so on. This
    is contrary to JEE applications, which only run on servers that implement the
    Java EE specifications and provide the standard Java EE services.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要新功能时，它要么作为现有项目的一部分，要么创建一个由Spring项目支持的新项目。不必担心兼容性问题，因为Spring被设计为可以在任何servlet容器上运行，如Apache
    Tomcat、Jetty等。这与JEE应用程序相反，后者只能在实现Java EE规范并提供标准Java EE服务的服务器上运行。
- en: Spring projects
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring项目
- en: Spring projects make use of an ecosystem of tools that can be used to create
    different kinds of applications in order to accomplish different goals. All of
    these projects are built around Spring, which is a legitimate modular framework
    that makes it possible to plug separate Spring projects to allow applications
    to deal with more technical requirements. If you're interested in the complete
    list of Spring projects, you can visit their home page at [https://Spring.io/projects](https://spring.io/projects).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Spring项目利用了一个生态系统的工具，可以用来创建不同类型的应用程序，以实现不同的目标。所有这些项目都围绕Spring构建，这是一个合法的模块化框架，可以将单独的Spring项目插入，以使应用程序处理更多的技术需求。如果您对Spring项目的完整列表感兴趣，可以访问它们的主页[https://Spring.io/projects](https://spring.io/projects)。
- en: We will review the most commonly used Spring projects to build enterprise applications,
    but first, we will introduce Spring Initializr, one of the preferred websites
    for Spring developers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾最常用的Spring项目来构建企业应用程序，但首先，我们将介绍Spring Initializr，这是Spring开发人员首选的网站之一。
- en: Spring Initializr
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Initializr
- en: 'When we plan to create a new project from scratch, we tend to think about which
    build tool we will use, which framework we will use, and so on. One of the most
    difficult tasks is finding the right dependencies to make the projects work. That
    is what Spring Initializr was created for. This excellent Spring initiative makes
    it possible to bootstrap applications in minutes, or even seconds, no matter what
    version you prefer. Spring Initializr can be used on the web or in your favorite
    IDE (Eclipse or IntelliJ), and it even has a cool CLI tool. My preferred approach
    is the web, and the following screenshot illustrates why:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们计划从头开始创建一个新项目时，我们倾向于考虑使用哪种构建工具，使用哪种框架等。最困难的任务之一是找到使项目工作的正确依赖关系。这就是Spring
    Initializr的创建目的。这个出色的Spring倡议使得可以在几分钟甚至几秒钟内启动应用程序，无论你喜欢哪个版本。Spring Initializr可以在Web上使用，也可以在您喜欢的IDE（Eclipse或IntelliJ）上使用，甚至有一个很酷的CLI工具。我喜欢的方法是Web，下面的截图说明了原因：
- en: '![](img/a6ceedc9-69a8-4470-bb19-fdef34e6f985.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6ceedc9-69a8-4470-bb19-fdef34e6f985.png)'
- en: Spring Initializr home page
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Initializr主页
- en: At the top of the page, you have the option to specify your favorite build tool.
    The available options for this are Maven and Gradle. The next option allows you
    to choose the programming language of your choice (at the moment, Java, Groovy,
    and Kotlin are supported). The last option at the top of the web page asks which
    Spring Boot version you want to use. In this section, even snapshot and milestone
    versions are included. In the Project Metadata section, you specify the group
    and artifact name of your project. The Dependencies section has the Search for
    dependencies text field, which is helpful for defining what Spring projects you
    want to include as a part of your application. If you want to see more, go ahead
    and click on the Switch to the full version link; this will show you a big list
    of all of the available dependencies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面顶部，您可以选择您喜欢的构建工具。可用的选项有Maven和Gradle。接下来的选项允许您选择您喜欢的编程语言（目前支持Java、Groovy和Kotlin）。网页顶部的最后一个选项询问您想要使用哪个Spring
    Boot版本。在此部分，甚至包括快照和里程碑版本。在项目元数据部分，您可以指定项目的组和构件名称。依赖项部分有一个搜索依赖项的文本字段，有助于定义您想要包含在应用程序中的Spring项目。如果您想了解更多，请点击切换到完整版本的链接；这将显示所有可用依赖项的大列表。
- en: All of these projects are created using the Spring Boot framework, which makes
    it easy to create standalone applications that are ready for production. Now,
    let's quickly go over Spring Boot.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些项目都是使用Spring Boot框架创建的，这使得创建独立应用程序并准备投入生产变得容易。现在，让我们快速了解一下Spring Boot。
- en: Spring Boot in a Nutshell
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot简介
- en: 'The Spring Boot framework intends to make the following tasks easier:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot框架旨在使以下任务更加容易：
- en: Servlet container integration
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Servlet容器集成
- en: Autoconfiguration
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动配置
- en: Dependency management
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖管理
- en: Servlet container integration
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Servlet容器集成
- en: Previously, we created `.war` files and then dropped them into the corresponding
    servlet container's deployment directory. However, Spring Boot includes an embedded
    servlet container, which ensures that this is no longer necessary. The idea is
    to generate a JAR file with all involved dependencies, and then execute the JAR
    file as a regular Java application. It's possible, but not recommended, to keep
    using the old approach of generating WAR files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们创建了`.war`文件，然后将它们放入相应的servlet容器部署目录中。然而，Spring Boot包含了一个嵌入式servlet容器，这样就不再需要这样做了。其思想是生成一个包含所有相关依赖项的JAR文件，然后将其作为常规Java应用程序执行。虽然仍然可以使用生成WAR文件的旧方法，但不建议这样做。
- en: Autoconfiguration
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动配置
- en: Spring Boot always attempts to automatically configure your application, based
    on the dependencies that you have added. For example, if H2 is a part of your
    dependencies, a data source to use an in-memory database will be configured automatically.
    You can always override these default configurations by using annotations, environment
    variables, configuration files, and even arguments when you're running the `.jar`
    file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot始终尝试根据您添加的依赖项自动配置应用程序。例如，如果H2是您依赖项的一部分，将自动配置使用内存数据库的数据源。您始终可以通过使用注释、环境变量、配置文件甚至在运行`.jar`文件时使用参数来覆盖这些默认配置。
- en: Dependency management
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: Each Spring Boot version includes a curated list of dependencies. Because of
    this, you don't even have to know what artifacts and versions are required as
    a part of your application. You will always have the option to override these
    dependencies if you have to, but that is often unnecessary. This approach allows
    us to easily upgrade our Spring Boot applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Spring Boot版本都包含一个经过精心筛选的依赖项列表。因此，您甚至不需要知道哪些构件和版本是应用程序的一部分。您始终可以选择覆盖这些依赖项，但通常是不必要的。这种方法使我们能够轻松升级Spring
    Boot应用程序。
- en: 'Let''s create a simple Spring Boot application by running the following `curl`
    command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下`curl`命令来创建一个简单的Spring Boot应用程序：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command will download a `.zip` file containing the following
    file structure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将下载一个包含以下文件结构的`.zip`文件：
- en: '![](img/58e57436-d3b0-4f60-9b5f-8ddb7a8ee74d.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58e57436-d3b0-4f60-9b5f-8ddb7a8ee74d.png)'
- en: Spring Boot project structure
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot项目结构
- en: Let's quickly review these files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看这些文件。
- en: mvnw and mvnw.cmd
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mvnw和mvnw.cmd
- en: These first two files are a part of the Maven wrapper ([https://github.com/takari/maven-wrapper](https://github.com/takari/maven-wrapper)).
    Here, the idea is to avoid forcing the developers to install Maven from scratch,
    instead of providing a built-in script that is able to download the right version
    and make it ready to work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件是Maven包装器的一部分（[https://github.com/takari/maven-wrapper](https://github.com/takari/maven-wrapper)）。这里的想法是避免强制开发人员从头开始安装Maven，而是提供一个内置脚本，能够下载正确的版本并使其准备好工作。
- en: pom.xml
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pom.xml
- en: 'This file contains the necessary dependencies to run a Spring Boot application.
    Let''s review the file''s content, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含运行Spring Boot应用程序所需的必要依赖项。让我们按照以下方式查看文件的内容：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `parent` pom section provides the necessary dependency and plugin management
    for the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent` pom部分为应用程序提供了必要的依赖项和插件管理。'
- en: The `Spring-boot-starter` dependency contains all of the dependencies that you
    need to get the project up and running, using a curated set of managed transitive
    dependencies. There are also other starters that you may want to use, depending
    on what you need for your project (for example, JPA, queues, security, and so
    on).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring-boot-starter`依赖项包含了您需要启动项目并使用一组受控的传递依赖项的所有依赖项。还有其他启动器，您可能想要使用，这取决于您的项目需要（例如，JPA、队列、安全等）。'
- en: The `Spring-boot-starter-test` dependency includes the whole set of dependencies
    for testing. It will allow you to write not only unit tests, but integration tests
    as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Spring-boot-starter-test`依赖项包含了整套测试所需的依赖项。它将允许您编写单元测试和集成测试。'
- en: DemoApplication.java
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DemoApplication.java
- en: 'This is a simple class with a `main` method, which is in charge of running
    the application. This `main` class can be executed in this way because of the
    `@SpringBootApplication` annotation, which enables all of the required autoconfiguration,
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有`main`方法的简单类，负责运行应用程序。由于`@SpringBootApplication`注解，可以以这种方式执行这个`main`类，它启用了所有必需的自动配置，如下所示：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The application.properties file
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: application.properties文件
- en: Within this file, you have to define all of the configuration properties for
    your application. For example, if you are interacting with an SQL database, this
    file will have properties such as the JDBC URL, database username, password, and
    more. If you want to, you can change its extension from `.properties` to `.yml`,
    in order to make it more expressive by using a YAML format ([http://www.yaml.org/start.html](http://www.yaml.org/start.html)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，您必须定义应用程序的所有配置属性。例如，如果您正在与SQL数据库交互，该文件将具有诸如JDBC URL、数据库用户名、密码等属性。如果您愿意，可以将其扩展名从`.properties`更改为`.yml`，以便通过使用YAML格式（[http://www.yaml.org/start.html](http://www.yaml.org/start.html)）使其更具表现力。
- en: DemoApplicationTests.java
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DemoApplicationTests.java
- en: 'As a bonus, the following is an example of a simple integration test that you
    can use as a guide, to keep writing tests for your new code. Thanks to annotations,
    writing this kind of test is relatively simple:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为奖励，以下是一个简单的集成测试示例，您可以将其用作指南，为新代码编写测试。由于注释，编写这种测试相对简单：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding explanations should be enough to provide you with a brief overview
    so that you can understand what Spring Boot is and what its benefits are. Now,
    it's time to review other Spring projects that you'll love.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述解释应该足以为您提供简要概述，以便您了解Spring Boot是什么以及其好处是什么。现在，是时候审查其他您会喜欢的Spring项目了。
- en: Avoiding redeployment with developer tools
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开发人员工具避免重新部署
- en: 'This module is awesome because it''s meant to help you avoid redeployment when
    you''re working on a Spring Boot application. It is similar to JRebel, but this
    product is absolutely free, and you can include it as a part of your application
    by simply adding the following dependency:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块很棒，因为它旨在帮助您在开发Spring Boot应用程序时避免重新部署。它类似于JRebel，但这个产品是完全免费的，您可以通过简单添加以下依赖项将其作为应用程序的一部分包含进来：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once the dependency has been added, you just have to recompile the classes to
    trigger an application restart. Depending on your IDE configuration, this process
    will be done either automatically or manually.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了依赖项，您只需重新编译类即可触发应用程序重新启动。根据您的IDE配置，此过程将自动完成或手动完成。
- en: Spring Data
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data
- en: This project offers you an additional abstraction layer for accessing data storage;
    it has a bunch of interfaces that you need to extend, in order to take advantage
    of the built-in functionalities offered by Spring Data. When you extend these
    interfaces, all of the standard operations surrounding data storage will be ready
    to use.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目为您提供了一个额外的访问数据存储的抽象层；它有一堆接口，您需要扩展这些接口，以利用Spring Data提供的内置功能。当您扩展这些接口时，所有围绕数据存储的标准操作都将准备就绪。
- en: Spring Data supports technologies such as relational and non-relational databases,
    map-reduce frameworks, and cloud-based data services. These technologies are supported
    by modules; if you are interested in the whole list of existing modules, you can
    visit [http://projects.Spring.io/Spring-data/](http://projects.spring.io/spring-data/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data支持关系型和非关系型数据库、MapReduce框架和基于云的数据服务等技术。这些技术由模块支持；如果您对现有模块的完整列表感兴趣，可以访问[http://projects.Spring.io/Spring-data/](http://projects.spring.io/spring-data/)。
- en: 'Let''s play with Spring Data by using an SQL database, such as H2\. Suppose
    that you want to build a **Create, Read, Update, Delete** (**CRUD**) operation
    for a country database table. With this framework, you only need to create the
    entity class and an empty interface extending the `CrudRepository` interface provided
    by Spring Data, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用SQL数据库（如H2）来玩Spring Data。假设您想为国家数据库表构建**创建、读取、更新、删除**（CRUD）操作。使用这个框架，您只需要创建实体类和一个空接口，该接口扩展了Spring
    Data提供的`CrudRepository`接口，如下所示：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since the `CrudRepository` interface has all of the CRUD operations in it,
    you won''t have to implement anything; you will only have to use its functionality.
    Let''s see this in action, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CrudRepository`接口中包含了所有的CRUD操作，您不需要实现任何内容；您只需要使用它的功能。让我们看看它的运行方式，如下所示：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have two **Beans** that use the repository interface created previously.
    The first method will run, and it will insert two rows into the table. The second
    method will query all of the rows in the table and then print them in the console.
    After running this application, you will see the following output in the console
    when the application starts:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个使用先前创建的存储库接口的**Bean**。第一个方法将运行，并将向表中插入两行。第二个方法将查询表中的所有行，然后在控制台中打印它们。运行此应用程序后，当应用程序启动时，您将在控制台中看到以下输出：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Spring Data has more features; it also gives you the chance to create queries
    in a fascinating way. Let''s suppose that you want to filter the countries by
    name. In that case, you will need to add the method to your interface repository,
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data还具有更多功能；它还让您有机会以一种迷人的方式创建查询。假设您想按名称过滤国家。在这种情况下，您需要将该方法添加到您的接口存储库中，如下所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we can use the preceding method in the following way:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以以以下方式使用先前的方法：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There's no implementation at all for this method, which is a great advantage.
    Spring Data uses the method's name to generate the required implementation, allowing
    us to forget trivial implementations for these kinds of queries. There are many
    interfaces that provide more functionalities, such as pagination, sorting, and
    reactive extensions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法根本没有实现，这是一个很大的优势。Spring Data使用方法的名称来生成所需的实现，让我们忘记这些类型的查询的琐碎实现。有许多接口提供更多的功能，如分页、排序和响应式扩展。
- en: Supporting EIPs with Spring Integration
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Integration支持EIPs
- en: Integration is important because applications are intended to interact with
    each other. Forcing them to work in isolation makes them useless.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 集成很重要，因为应用程序旨在相互交互。强迫它们独立工作会使它们变得无用。
- en: It's common to find companies that have their own software, developed in-house,
    to solve their specific business requirements; but, since certain scenarios tend
    to be common for more than one company, there are third-party services that can
    fulfill these needs. Since the functionality offered by these systems is ready
    to use, we have to find a way to make these applications work as a single system,
    and that's where **Enterprise Integration Patterns** (**EIP**) come into play.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会发现一些公司有他们自己的内部开发的软件，以解决他们特定的业务需求；但是，由于某些情景往往对于不止一个公司是共同的，因此有第三方服务可以满足这些需求。由于这些系统提供的功能是可用的，我们必须找到一种方法使这些应用程序作为一个单一系统工作，这就是**企业集成模式**（EIP）发挥作用的地方。
- en: EIPs provide proven solutions to recurring problems that can be applied in different
    contexts with slight modifications, depending on particular business needs. There
    is a vast catalog of these patterns available on the internet, and a must-read
    within this field is the book *Enterprise Integration Patterns, *by Gregor Hohpe
    and Bobby Woolf. This book explains a large list of patterns, along with example
    scenarios, by using a technology agnostic approach.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: EIP提供了针对不同上下文中可以应用的经常出现的问题的成熟解决方案，具体取决于特定的业务需求进行轻微修改。互联网上有大量这些模式的目录，而在这个领域必读的是Gregor
    Hohpe和Bobby Woolf的书《企业集成模式》。该书采用技术无关的方法，解释了大量模式以及示例场景。
- en: Once you understand the theory around EIPs, you will find Spring Integration
    pretty handy for implementing them; it will have all of the benefits inherent
    to the Spring Framework, as discussed previously.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦理解了EIP的理论，您会发现Spring Integration非常方便用于实现它们；它将具有之前讨论过的Spring Framework固有的所有优势。
- en: 'When we discuss integration, we can consider the concept using a three-step
    approach. Let''s start reviewing the following diagram which shows these three
    steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论集成时，可以考虑使用三步方法。让我们开始审查以下显示这三个步骤的图表：
- en: '![](img/9d79debc-84d7-4f68-8a8f-7ebd87f7d5ad.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d79debc-84d7-4f68-8a8f-7ebd87f7d5ad.png)'
- en: EIPs
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: EIP
- en: 'The following is a list of steps that are executed as a part of the preceding
    process:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是作为前述过程一部分执行的步骤列表：
- en: There is a data source where the information is extracted; a poll is sometimes
    needed, in order to ask for data.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个数据源，从中提取信息；有时需要进行轮询，以请求数据。
- en: The ingested data is filtered, transformed, composed, decomposed, routed, and
    so on, depending on what's required. It's here that the EIPs are used.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摄入的数据根据需要进行过滤、转换、组合、分解、路由等。EIP就是在这里使用的。
- en: The processed data is ready to be delivered or stored, depending on what is
    needed.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理后的数据已准备好交付或存储，具体取决于需要什么。
- en: Spring Integration provides built-in support for retrieving or sending information
    from or to queues, databases, system files, FTP servers, and many other options.
    Moreover, if needed, you can write your own implementation and plug it in, in
    order to make it work as a part of your process. The DSL provided by Spring makes
    it easy to read and implement the EIPs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration提供了内置支持，用于从队列、数据库、系统文件、FTP服务器和许多其他选项中检索或发送信息。此外，如果需要，您可以编写自己的实现并将其插入，以使其作为流程的一部分工作。Spring提供的DSL使阅读和实现EIP变得容易。
- en: Spring Batch
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Batch
- en: No matter what type of architecture we are using, sometimes we will need to
    work with a great amount of data and apply some transformations to make it useful.
    This kind of processing usually happens when we need to consolidate (or simply
    process) data from one or many data sources, making it available for certain business
    purposes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用什么类型的架构，有时我们都需要处理大量数据并应用一些转换使其有用。这种处理通常发生在我们需要从一个或多个数据源中整合（或简单处理）数据，使其可用于特定的业务目的。
- en: 'These batch processes require a well-defined set of steps for accomplishing
    the required goal. Using Spring Batch, you can implement them by using jobs that
    are composed of steps to read, process, and write the processed data. One job
    can have as many steps as required, as shown in the following diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些批处理过程需要一组明确定义的步骤来实现所需的目标。使用Spring Batch，您可以通过使用由读取、处理和写入处理数据的步骤组成的作业来实现它们。一个作业可以有多个所需的步骤，如下图所示：
- en: '![](img/0f3e4098-f790-4fe1-951f-5820d1229695.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f3e4098-f790-4fe1-951f-5820d1229695.png)'
- en: Spring Batch – Job structure
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch - 作业结构
- en: The read step
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取步骤
- en: In this case, the information is read from an external data source using a built-in
    `ItemReader` object that is part of Spring Batch. The `ItemReader` object will
    serve a `<T>` object, which will be consumed later.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，信息是使用Spring Batch的内置`ItemReader`对象从外部数据源读取的。`ItemReader`对象将提供一个`<T>`对象，稍后将被使用。
- en: The process step
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理步骤
- en: Here, the data processing is done by an `ItemProcessor` object that can transform
    and manipulate the `<T>` data that has been read from the `ItemReader` object.
    An `ItemProcessor` can return the same `<T>` object that was read, or another
    `<O>` object that is completely different if that's the desired behavior.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数据处理是由一个`ItemProcessor`对象完成的，它可以转换和操作从`ItemReader`对象读取的`<T>`数据。`ItemProcessor`可以返回与读取的相同的`<T>`对象，或者如果需要的话，可以返回完全不同的`<O>`对象。
- en: The write step
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入步骤
- en: Once the processing step has finished, an `ItemWriter` object is available to
    use, writing the `<O>` transformed object obtained in the processing stage.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理步骤完成，就可以使用`ItemWriter`对象，将处理阶段获得的`<O>`转换对象写入。
- en: 'Spring provides the ability to interact with traditional data sources, such
    as the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了与传统数据源交互的能力，例如以下内容：
- en: Files
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: JMS providers
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMS提供者
- en: Databases
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: With Spring Batch, one cool feature is that it offers the chance to rerun and
    skip jobs, since it has its own database where the state to executed jobs is stored.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring Batch，一个很酷的功能是它提供了重新运行和跳过作业的机会，因为它有自己的数据库，其中存储了执行作业的状态。
- en: Since Spring Batch is designed to deal with huge amounts of data, in order to
    accelerate the processing, the framework offers the chance to process the information
    as chunks of data. This also makes it possible to reduce the server resources
    required for processing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring Batch旨在处理大量数据，为了加速处理，该框架提供了将信息作为数据块处理的机会。这也使得可以减少处理所需的服务器资源。
- en: Securing applications with Spring Security
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Security保护应用程序
- en: Spring Security is an extensible framework that can be used to secure Java applications.
    It can also be used to handle authentication and authorization, and it uses a
    declarative style that is not at all intrusive of the existing code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security是一个可扩展的框架，可用于保护Java应用程序。它还可以用于处理身份验证和授权，并且它使用一种声明式风格，完全不会侵入现有代码。
- en: 'The framework supports different approaches to authentication, such as the
    following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架支持不同的身份验证方法，例如以下方法：
- en: LDAP
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDAP
- en: JDBC
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC
- en: In-memory
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中
- en: 'You can also add your own custom authentication mechanism by implementing the `AuthenticationProvider` interface,
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过实现`AuthenticationProvider`接口添加自定义的身份验证机制，如下所示：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, the `user` and `password` hardcoded strings  are expected
    as credentials in order to have a successful authentication process, and you should
    replace that verification with the necessary logic.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`user`和`password`硬编码字符串预期作为凭据，以便成功的身份验证过程，并且您应该用必要的逻辑替换该验证。
- en: The aforementioned authentication mechanisms follow the **Basic Authentication**
    model, which is the preferred model for web applications. However, when you're
    writing APIs, you will need other approaches to deal with security. A good option
    is to use a model based on tokens, such as JWT or OAuth, which we will review
    and implement in subsequent chapters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述身份验证机制遵循**基本身份验证**模型，这是Web应用程序的首选模型。但是，当您编写API时，您将需要其他方法来处理安全性。一个很好的选择是使用基于令牌的模型，例如JWT或OAuth，我们将在后续章节中进行审查和实施。
- en: Embracing (Spring) HATEOAS
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥抱（Spring）HATEOAS
- en: 'When talking about the REST subject, it''s always worth discussing the Maturity
    Model, created by Leonard Richardson, which establishes three steps that a REST
    API should accomplish in order to be considered mature:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论REST主题时，讨论Leonard Richardson创建的成熟度模型总是值得的，该模型规定了REST API应该完成的三个步骤才能被认为是成熟的：
- en: Resources
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源
- en: HTTP verbs
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP动词
- en: 'Hypermedia controls: HATEOAS'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超媒体控制：HATEOAS
- en: In this section, we will focus on the last element. **HATEOAS** is intended
    to provide information about what we can do next, using additional **Uniform Resource
    Identifiers **(**URIs**) that are included as part of the resource.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将重点放在最后一个元素上。**HATEOAS**旨在提供关于我们可以使用什么的信息，使用作为资源的一部分包含的附加**统一资源标识符（URIs）**。
- en: Let's revisit our banking example, in order to explain HATEOAS from a practical
    view. Suppose that you have the following URI to query the customer's bank statements: `http://your-api/customer/{customer_id}/bankStatements`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新访问我们的银行示例，以便从实际角度解释HATEOAS。假设您有以下URI来查询客户的银行对账单：`http://your-api/customer/{customer_id}/bankStatements`。
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, let''s suppose that the API has the ability to resend the bank statements
    or mark them as failed. With the information provided by the previously mentioned
    payload, there is no way to know about these operations. It''s here that HATEOAS
    can be used, to let our API users know about the existence of these additional
    features. After applying HATEOAS, the payload will look as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，假设API具有重新发送银行对账单或将其标记为失败的能力。根据先前提到的有效负载提供的信息，无法了解这些操作。这就是HATEOAS可以使用的地方，让我们的API用户了解这些附加功能的存在。应用HATEOAS后，有效负载将如下所示：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note how easy it is to learn about the existence of these operations, which
    were hidden before applying HATEOAS as part of the API.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在应用HATEOAS作为API的一部分之前，了解这些操作的存在是多么容易。
- en: Spring Cloud and the microservices world
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud和微服务世界
- en: This project provides a set of tools to deal with distributed applications.
    Spring Cloud is mainly used within the microservices world, which we will review
    in depth in [Chapter 8](7c38500a-5a66-422b-a41b-21f4fd18de51.xhtml), *Microservices*.
    This project is composed of modules that offer different functionalities, which
    can be embraced all at once or one by one, depending on your needs. Let's briefly review
    some of the most common modules available in Spring Cloud, and look at how they
    work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目提供了一套工具来处理分布式应用程序。Spring Cloud主要用于微服务世界，我们将在[第8章](7c38500a-5a66-422b-a41b-21f4fd18de51.xhtml)中深入研究微服务。该项目由提供不同功能的模块组成，可以根据您的需求一次性全部采用，也可以逐个采用。让我们简要地回顾一些Spring
    Cloud中最常见的模块，并看看它们是如何工作的。
- en: Configuration server
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器
- en: This module provides a centralized tool for storing all of the configurations
    that your applications need in order to work. Within the Java world, it's quite
    common to have `.properties` and `.yml` files that store all of the required configurations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块提供了一个集中的工具，用于存储应用程序工作所需的所有配置。在Java世界中，拥有存储所有必需配置的`.properties`和`.yml`文件是非常常见的。
- en: Spring offers the ability to create different profiles, in order to deal with
    different environments, using files with the previously mentioned extensions.
    However, it also has the option to keep all of the configuration centralized in
    a server, where you can store values and even encrypted information. When clients
    need to access this secret information, the configuration server has the ability
    to decrypt the information and make it available to the client. Furthermore, you
    can change the configuration values on the fly. The files storing this configuration
    reside inside of a Git repository, which gives us the additional benefit of accounting
    for the changes applied in the configurations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了创建不同配置文件的能力，以处理不同的环境，使用之前提到的扩展名的文件。但是，它还可以选择将所有配置集中在服务器中，您可以在其中存储值甚至加密信息。当客户端需要访问此秘密信息时，配置服务器具有解密信息并使其可用于客户端的能力。此外，您可以动态更改配置值。存储此配置的文件位于
    Git 存储库中，这使我们能够考虑应用于配置的更改的额外好处。
- en: Service registry
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表
- en: A service registry works like a phone book for the Cloud, which makes it possible
    to find out where the services are and how many instances of them are available
    for handling incoming requests.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册表就像云的电话簿，可以找出服务的位置以及有多少个实例可用于处理传入请求。
- en: 'Spring offers support for most of the common service registries, including
    the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 支持大多数常见的服务注册表，包括以下内容：
- en: Zookeeper
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zookeeper
- en: Consul
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Consul
- en: Netflix Eureka
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix Eureka
- en: 'Using a service registry offers the following benefits:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务注册表提供以下好处：
- en: Sophisticated load balancing, such as availability zone awareness
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sophisticated load balancing, such as availability zone awareness
- en: Client-side load balancing
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端负载均衡
- en: Request routing
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求路由
- en: Edge services
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘服务
- en: An edge service acts as a proxy. It is designed to take all incoming requests
    and do something useful with them, before sending them to the services that are
    behind the load balancers, firewalls, and so on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务充当代理。它旨在接收所有传入请求并在将其发送到负载均衡器、防火墙等后面的服务之前对其进行有用处理。
- en: 'There are two main types of edge services:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要类型的边缘服务：
- en: Microproxy
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微代理
- en: API gateway
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 网关
- en: One of the benefits of using an edge service is that you can manage all of the
    specific client details in a centralized place instead of writing code to deal
    with these details in each service individually. For example, if you need to make
    a particular consideration for mobile clients, this is the perfect place to do
    it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用边缘服务的好处之一是，您可以在集中的位置管理所有特定客户端的详细信息，而不是在每个服务中编写代码来处理这些详细信息。例如，如果您需要针对移动客户端进行特定考虑，这是执行此操作的理想位置。
- en: Microproxy
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微代理
- en: A microproxy is a kind of edge service that retrieves an incoming request only, and
    then redirects the request to the corresponding service.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 微代理是一种边缘服务，仅检索传入请求，然后将请求重定向到相应服务。
- en: A classic example of this type of edge service involves dealing with **Cross-Origin
    Resource Sharing (CORS)**, as defined at[https://en.wikipedia.org/wiki/Cross-origin_resource_sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing).
    As you probably know, CORS restricts access to specific resources when they are
    requested from a domain different from where they reside. You can allow access
    to the resources on each service, or you can take advantage of an edge server,
    in order to allow services to be requested from other domains.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的边缘服务的经典示例涉及处理**跨域资源共享（CORS）**，如[https://en.wikipedia.org/wiki/Cross-origin_resource_sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)中定义的。您可能知道，CORS
    限制了从与资源所在不同的域请求资源时的访问。您可以允许每个服务上的资源访问，或者您可以利用边缘服务器，以便允许从其他域请求服务。
- en: API gateway
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 网关
- en: The use of an API gateway transforms incoming requests before redirecting them
    to the corresponding services. Not only can the requests be modified, but the
    responses are also provided.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关的使用可以在重定向到相应服务之前转换传入请求。不仅可以修改请求，还可以提供响应。
- en: A gateway can also work as a facade, which should orchestrate some services
    before sending the responses to the clients. When we are working with this particular
    use case, we can implement the circuit breaker pattern in order to be more defensive.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 网关还可以作为门面工作，应在将响应发送给客户端之前协调一些服务。当我们处理这种特定用例时，我们可以实现断路器模式以更具防御性。
- en: Circuit breaker
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器
- en: A circuit breaker is a pattern used to deal with failed calls. If an error occurs,
    you can usually throw an exception and let the user know that something went wrong,
    but you can also use an alternative path to serve an alternative response. For
    example, let's suppose that service A has failed. Now, instead of returning a
    failed response, you can invoke an alternative service, B, which acts similarly
    to service A, in order to provide a valid response to the client, hence improving
    the user experience.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器是一种用于处理失败调用的模式。如果发生错误，通常可以抛出异常并让用户知道出了问题，但也可以使用替代路径提供替代响应。例如，假设服务 A 失败了。现在，您可以调用类似于服务
    A 的替代服务 B，以向客户端提供有效响应，从而改善用户体验，而不是返回失败响应。
- en: Reactive and Spring
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reactive 和 Spring
- en: Reactive programming is a paradigm built around a simple concept that proposes
    propagating changes using events. This programming style has been used for a while
    in programming languages such as JavaScript, and one of its main benefits is its
    asynchronous and non-blocking behavior.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive 编程是围绕一个简单概念构建的范式，即使用事件传播变化。这种编程风格在 JavaScript 等编程语言中已经使用了一段时间，其主要好处之一是其异步和非阻塞行为。
- en: In order to embrace this programming paradigm within the Java world, the Reactive
    Stream specification was created, following the goals declared in the Reactive
    Manifesto ([https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)),
    which was written a few years ago.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Java世界中采用这种编程范式，创建了Reactive Stream规范，遵循了Reactive Manifesto（[https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)）中声明的目标，该宣言是几年前编写的。
- en: 'This specification is mainly composed of four interfaces, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范主要由四个接口组成，如下所示：
- en: Publisher
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者
- en: Subscriber
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅者
- en: Subscription
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅
- en: Processor
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器
- en: Let's briefly review these interfaces.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下这些接口。
- en: Publisher
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布者
- en: 'This interface has a simple method, which makes it possible to register subscribers
    that will eventually receive the data when it is available to consume. The following
    is the code for the `Publisher` interface:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口具有一个简单的方法，可以注册订阅者，当数据可供消费时，订阅者最终会接收到数据。以下是`Publisher`接口的代码：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Subscriber
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅者
- en: 'This interface is where the action happens. The following methods have names
    that are self-describing:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口是发生操作的地方。以下方法的名称是自描述的：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With each of the previously mentioned methods, you can register a callback
    that will be invoked under the appropriate circumstances, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面提到的每个方法，您可以注册一个回调，在适当的情况下调用它，如下所示：
- en: '`onSubscribe`: This method is executed when the subscription process happens'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSubscribe`：当订阅过程发生时执行此方法'
- en: '`onNext`: This method is executed when a new event is received'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`：当接收到新事件时执行此方法'
- en: '`onError`: This method is executed when an error occurs'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：当发生错误时执行此方法'
- en: '`onComplete`: This method is executed when the producer has finished and there
    are no more results to receive'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：当生产者完成并且没有更多结果可接收时执行此方法'
- en: Subscription
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅
- en: 'This interface is intended to be used when you want to request a subscription
    to the `Publisher` interface, specifying the number of elements to request to
    the upstream; the `cancel` method should be called when the subscriber is no longer
    interested in receiving data:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要请求对`Publisher`接口的订阅时，应使用此接口，指定要向上游请求的元素数量；当订阅者不再对接收数据感兴趣时，应调用`cancel`方法：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Processor
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: The `processor` interface implements two additional interfaces: `Publisher`
    and `Subscriber`. This interface is used to subscribe to and publish events.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`processor`接口实现了两个额外的接口：`Publisher`和`Subscriber`。此接口用于订阅和发布事件。'
- en: Project reactor
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目反应器
- en: This project is an implementation of the Reactive Streams specification, which
    is preferred by Spring Framework. There are also adapters that make it possible
    to use other implementations if required, but that is often unnecessary.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目是Reactive Streams规范的实现，Spring Framework首选。还有适配器，如果需要，可以使用其他实现，但通常是不必要的。
- en: Project reactor can also be used to implement Reactive applications without
    using Spring.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 项目反应器也可以用于实现反应式应用程序，而不使用Spring。
- en: When we're registering functions to handle events, we tend to nest callbacks
    that make it difficult to understand the written code. In order to simplify these
    kinds of requirements, Reactor has its own set of operators (visit [https://goo.gl/y7kcgS](https://goo.gl/y7kcgS)
    to see the whole list of available operators). These operators allow us to interact
    with the API in a cleaner way, without having to chain callback functions together.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们注册处理事件的函数时，我们倾向于嵌套回调，这使得难以理解书面代码。为了简化这类要求，Reactor有自己的一套操作符（访问[https://goo.gl/y7kcgS](https://goo.gl/y7kcgS)查看所有可用操作符的完整列表）。这些操作符允许我们以更清晰的方式与API交互，而无需将回调函数链接在一起。
- en: 'There are two main producer classes that deal with results where the operators
    can be applied:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要的生产者类处理结果，可以应用操作符：
- en: Mono
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mono
- en: Flux
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux
- en: Mono
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mono
- en: Mono represents the asynchronous result of a single or empty value (0...1).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Mono表示单个或空值（0...1）的异步结果。
- en: 'The following diagram was taken from the Project Reactor documentation, and
    it indicates how an item is emitted by a `Mono` object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表摘自项目反应器文档，指示了`Mono`对象如何发出项目：
- en: '![](img/23f3a241-caf4-48f7-be45-cb51f6e87c29.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23f3a241-caf4-48f7-be45-cb51f6e87c29.png)'
- en: Item emitted by a Mono object
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由Mono对象发出的项目
- en: 'The preceding diagram illustrates the following flow:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表说明了以下流程：
- en: A new value is produced
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生了一个新值
- en: An operator is applied to the produced value
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对产生的值应用了一个操作符
- en: The result is delivered
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果被传递
- en: 'The following example shows how to work using an empty value:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用空值：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Flux
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux
- en: Flux represents an asynchronous sequence of 0 to *n* items.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Flux表示0到*n*个项目的异步序列。
- en: 'We will again borrow a diagram from the Project Reactor documentation, which
    explains how a `Flux` object emits items:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次借用项目反应器文档中的图表，解释了`Flux`对象如何发出项目：
- en: '![](img/0429f36a-f799-4bc7-a1c8-45dbbb92e30a.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0429f36a-f799-4bc7-a1c8-45dbbb92e30a.png)'
- en: Item emitted by a Flux object
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由Flux对象发出的项目
- en: 'The preceding diagram illustrates the following process:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表说明了以下过程：
- en: At least six values have been produced
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少已产生了六个值
- en: An operator is applied to the produced values
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对产生的值应用了一个操作符
- en: The result is delivered
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果被传递
- en: 'In the following example, we will first convert each produced value to uppercase,
    in order to deliver the values:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将首先将每个产生的值转换为大写，以便传递这些值：
- en: '[PRE17]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Back pressure
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反压
- en: Back pressure is a mechanism that allows us to specify the required number of
    elements to be read at once. It is used when you're interested in chunks of data
    with a defined quantity of *n* elements. The data is delivered in chunks until
    the whole dataset is reached.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 反压是一种机制，允许我们指定一次要读取的所需元素数量。当您对具有定义数量的*n*元素的数据块感兴趣时，就会使用它。数据以块的形式传递，直到整个数据集被达到。
- en: 'Suppose that you want chunks of data with three elements, from a `Flux` object with
    ten elements. In this case, you will retrieve the data four times, as shown in
    the following example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要从一个包含十个元素的`Flux`对象中获取三个元素的数据块。在这种情况下，您将检索数据四次，如下例所示：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the generated output from the log:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是日志生成的输出：
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As mentioned previously, Spring 5 supports reactive programming by using the
    Reactor project. We have the ability to use it as a part of Spring MVC and Spring
    Data, as well.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring 5通过使用Reactor项目支持反应式编程。我们有能力将其作为Spring MVC和Spring Data的一部分来使用。
- en: Reactive Spring Data
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式Spring Data
- en: 'Since Reactor can be used with Spring Data, we can take full advantage of the
    reactive programming model at this stage. This means that you can persist data
    represented as `Flux` or `Mono` objects. Let''s review the following example,
    implemented with MongoDB:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Reactor可以与Spring Data一起使用，因此我们可以充分利用这种反应式编程模型。这意味着您可以持久化表示为`Flux`或`Mono`对象的数据。让我们来看下面的例子，使用MongoDB实现：
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the provided information is represented as `Flux` and `Mono` objects,
    and the queried data is obtained as a `Flux` object, which is manipulated using
    the map operator to recover only the IDs as `List<String>` to verify the number
    of entities created.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，提供的信息表示为`Flux`和`Mono`对象，查询的数据以`Flux`对象的形式获取，并使用map运算符进行操作，以仅恢复ID作为`List<String>`来验证创建的实体数量。
- en: Reactive REST services
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式REST服务
- en: Reactive REST services have been added by using `WebFlux` as a part of the Spring
    web stack. This allows us to implement endpoints that are capable of delivering
    information as streams.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`WebFlux`作为Spring Web堆栈的一部分，我们添加了反应式REST服务。这使我们能够实现能够以流的形式传递信息的端点。
- en: 'Let''s review how this works from a practical viewpoint. Suppose that you want
    to retrieve notifications that are often pushed by users. Without using the reactive
    approach, you can retrieve all of the notifications created until the request
    is made; but, with the reactive approach, you can keep receiving new notifications,
    which means that if a new notification is created, you will receive it at that
    exact moment. Let''s analyze the following code snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实际角度来看看这是如何工作的。假设您想要检索用户经常推送的通知。如果不使用反应式方法，您可以在发出请求之前检索到所有创建的通知；但是，使用反应式方法，您可以不断接收新的通知，这意味着如果创建了新的通知，您将立刻收到它。让我们分析下面的代码片段：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First of all, pay attention to the produced content. This is a stream value,
    rather than JSON, XML, or any other content type. Next, we are simulating that
    a new comment is created every second (check the code in bold). At the end of
    the process, that information is delivered by the endpoint. You can give this
    a try with the following `curl` command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意生成的内容。这是一个流值，而不是JSON、XML或任何其他内容类型。接下来，我们模拟每秒创建一个新评论（查看粗体代码）。在过程结束时，该信息通过端点传递。您可以使用以下`curl`命令尝试一下：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, you can see how a new comment is being retrieved each second. This feature
    opens up a new world of opportunities and functionalities that can be implemented
    in our applications.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到每秒都在检索一个新评论。这个功能为我们的应用程序开辟了新的机会和功能。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed some of the most common projects available in Spring,
    along with a brief explanation and use case for each of them. We also looked at
    the Spring Reactor project and the features associated with it, which can be implemented
    using Spring Data. We then looked at writing RESTful web services.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们审查了Spring中一些常见的项目，以及每个项目的简要说明和用例。我们还研究了Spring Reactor项目及其相关特性，这些特性可以使用Spring
    Data来实现。然后，我们看了如何编写RESTful Web服务。
- en: With all of the knowledge that you have acquired, it's time to dive into the
    subsequent chapters to review some architectural styles and learn how to implement
    them using the Spring Framework.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有了您所掌握的所有知识，现在是时候深入下一章，审查一些架构风格并学习如何使用Spring框架来实现它们了。
