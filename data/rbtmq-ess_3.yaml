- en: Sending Messages to Multiple Taxi Drivers
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 向多个出租车司机发送消息
- en: '[Chapter 2](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating a Taxi Application*,
    included information on how to connect to and consume messages from RabbitMQ.
    This chapter demonstrates setting the prefetch value, which specifies the number
    of messages being sent to the consumer at the same time. It also covers how consumers
    can either manually acknowledge messages or receive the messages without acknowledgment,
    the former allowing a zero-message loss design.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](377ec533-342d-4a08-9011-7176de197886.xhtml)，*创建出租车应用程序*，包含了如何连接到并从RabbitMQ接收消息的信息。本章演示了设置预取值，该值指定同时发送给消费者的消息数量。它还涵盖了消费者可以手动确认消息或接收无需确认的消息，前者允许零消息损失的设计。'
- en: A new feature is requested of the** Complete Car** (**CC**) team, as the back
    office wants to be able to send information messages to all taxis at once. This
    is a prime opportunity to introduce the fanout exchange, which routes messages
    to all queues bound to them irrespective of the routing keys.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整汽车**（**CC**）团队请求一个新功能，因为后台希望能够一次性向所有出租车发送信息消息。这是一个介绍扇出交换的绝佳机会，该交换将消息路由到所有绑定到它们的队列，而不考虑路由键。'
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Working with channels and queues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与通道和队列一起工作
- en: Specifying a consumer prefetch count
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定消费者预取计数
- en: Acknowledging messages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认消息
- en: Publishing to all queues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向所有队列发布
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter03).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，网址为[https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter03)。
- en: Working with channels and queues
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与通道和队列一起工作
- en: CC's drivers and customers are enjoying the **request taxi** feature that was
    rolled out in [*Chapter 2*](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating
    a Taxi Application*. First, publishing messages to the direct exchange for customers
    ordering a single taxi was explained, and then instructions were given on implementing
    the topic exchange, which customers use when ordering a taxi with specific requirements.
    In both cases, the consumer is bound to the channel that was used to consume a
    particular queue. If this channel was closed, the consumer would stop receiving
    messages. Because a channel cannot be reopened and has to be recreated from scratch,
    both the channel and its consumption must be re-established if there are any problems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: CC的驱动程序和客户正在享受在[*第2章*](377ec533-342d-4a08-9011-7176de197886.xhtml)，*创建出租车应用程序*中推出的**请求出租车**功能。首先，解释了向直接交换发布客户订购单辆出租车的消息，然后提供了实现主题交换的说明，客户在订购具有特定要求的出租车时使用该交换。在这两种情况下，消费者绑定到用于消费特定队列的通道。如果该通道关闭，消费者将停止接收消息。因为通道不能重新打开，必须从头开始创建，所以如果出现任何问题，必须重新建立通道及其消费。
- en: 'Let''s walk through some important points about consumers and queues in RabbitMQ:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下关于RabbitMQ中消费者和队列的一些重要点：
- en: A queue can have multiple consumers (unless the exclusive tag is used).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列可以有多个消费者（除非使用了独占标签）。
- en: Each channel can have multiple consumers.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个通道可以有多个消费者。
- en: Each consumer uses server resources, so it is best to make sure not to use too
    many consumers.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个消费者都会使用服务器资源，因此最好确保不要使用过多的消费者。
- en: Channels are full-duplex, meaning that one channel can be used to both publish
    and consume messages.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道是全双工的，这意味着一个通道可以用于发布和消费消息。
- en: There is no logical limit to the number of channels or consumers a RabbitMQ
    broker can handle. There are, however, limiting factors, such as available memory,
    broker CPU power, and network bandwidth.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ代理可以处理的通道或消费者数量没有逻辑限制。然而，有一些限制因素，例如可用内存、代理CPU功率和网络带宽。
- en: As each channel mobilizes memory and consumes CPU power, limiting the number
    of channels or consumers may be a consideration in some environments. The administrator
    can configure a maximum number of channels per connection by using the `channel_max`
    parameter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个通道都会动员内存并消耗CPU功率，因此在某些环境中可能需要考虑限制通道或消费者的数量。管理员可以通过使用`channel_max`参数来配置每个连接的最大通道数。
- en: It's now time to look into how to get as much out of the consumers as possible
    by setting a prefetch count.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探讨如何通过设置预取计数来最大限度地利用消费者了。
- en: Specifying a consumer prefetch count
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定消费者预取计数
- en: The number of messages sent to the consumer at the same time can be specified
    through the **prefetch** count value. The prefetch count value is used to get
    as much out of the consumers as possible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过**预取**计数值来指定同时发送给消费者的消息数量。预取计数值用于尽可能多地从消费者那里获取信息。
- en: If the prefetch count is too small, it could negatively affect the performance
    of RabbitMQ, since the platform is usually waiting for permission to send more
    messages. The following diagram shows an example of a long idle time. The example
    has the prefetch set to one, meaning that RabbitMQ will not send the next message
    until after the delivery, processing, and acknowledgment of the message is complete.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预取计数太小，可能会对RabbitMQ的性能产生负面影响，因为平台通常在等待发送更多消息的权限。以下图表显示了一个长时间空闲的示例。示例中预取设置为1，这意味着RabbitMQ将在消息交付、处理和确认完成后才会发送下一条消息。
- en: 'In the example, the processing time is only 5 ms, with a round-trip time of
    125 ms (60 ms + 60 ms + 5 ms):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，处理时间仅为5毫秒，往返时间为125毫秒（60毫秒 + 60毫秒 + 5毫秒）：
- en: '![](img/7252f49c-fb63-406f-a7aa-fec309ad89fe.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7252f49c-fb63-406f-a7aa-fec309ad89fe.png)'
- en: 'Fig 3.1: Round-trip time is 125 ms with a processing time of only 5 ms'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：往返时间为125毫秒，处理时间仅为5毫秒
- en: 'A large prefetch count makes RabbitMQ send many messages from one queue to
    one consumer. If all messages are sent to a single consumer, it may be overwhelmed
    and leave the other consumers idle. The following diagram shows the consumer as
    they receive lots of messages while the other consumer is idle:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的预取计数会使RabbitMQ从单个队列向单个消费者发送许多消息。如果所有消息都发送给单个消费者，它可能会超负荷工作，并使其他消费者处于空闲状态。以下图表显示了消费者在接收大量消息的同时，其他消费者处于空闲状态：
- en: '![](img/5d7e7aa7-b7d4-4df2-a065-32ee302fd53d.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d7e7aa7-b7d4-4df2-a065-32ee302fd53d.png)'
- en: 'Fig 3.2: Consumer in an idling state'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：消费者处于空闲状态
- en: 'In [*Chapter 2*](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating a Taxi
    Application*, a connection, channel, and consumer were created in Ruby. The following
    code block shows how to configure a prefetch value in Ruby:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](377ec533-342d-4a08-9011-7176de197886.xhtml)，*创建出租车应用程序*中，使用Ruby创建了一个连接、通道和消费者。以下代码块展示了如何在Ruby中配置预取值：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the example shows the prefetch value at one `(1)`. This means that
    just one message will be delivered to the consumer until the consumer has **ack:ed/nack:ed**
    it. The default RabbitMQ prefetch setting provides an unlimited buffer for sending
    as many messages as possible to consumers that are ready to accept them. In the
    consumer, the client library caches the messages until processed. Prefetch settings
    limit the number of messages the client is able to receive before acknowledging
    them, rendering them invisible to other consumers, and removing them from the
    queue.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，示例显示了单个 `(1)` 位置的预取值。这意味着只有一条消息会被发送给消费者，直到消费者对其进行**确认/拒绝确认**。默认的RabbitMQ预取设置提供了无限缓冲区，以便尽可能多地发送给准备接受消息的消费者。在消费者端，客户端库会缓存消息直到处理完毕。预取设置限制了客户端在确认之前能够接收的消息数量，使它们对其他消费者不可见，并从队列中移除。
- en: RabbitMQ supports channel-level, message-based prefetch counts, not connection
    or byte size-based prefetching.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ支持基于通道级别、基于消息的预取计数，而不是基于连接或字节大小的预取。
- en: Next, we'll look at how to set the correct prefetch value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何设置正确的预取值。
- en: Setting the correct prefetch value
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置正确的预取值
- en: In a scenario of one or a few consumers who are quickly processing messages,
    it is recommended to prefetch many messages at once to keep the client as busy
    as possible. It is possible to divide the total round-trip time by the processing
    time for each message to get an estimated prefetch value – if the processing time
    stays the same and the network behavior is stable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个或几个快速处理消息的消费者场景中，建议一次性预取许多消息，以使客户端尽可能忙碌。可以通过将总往返时间除以每条消息的处理时间来得到估计的预取值——如果处理时间保持不变且网络行为稳定。
- en: A low prefetch value is recommended in situations where there are many consumers
    and a short processing time. If the prefetch value is set too low, the consumers
    will be idle much of the time, waiting for messages to arrive. On the other hand,
    if the prefetch value is too high, one consumer may be very busy while the others
    are idle.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在有多个消费者且处理时间较短的情况下，建议使用较低的预取值。如果预取值设置得太低，消费者大部分时间都会处于空闲状态，等待消息的到来。另一方面，如果预取值过高，一个消费者可能会非常忙碌，而其他消费者则处于空闲状态。
- en: One typical mistake is to allow unlimited prefetch where one client receives
    all the messages, leading to high memory consumption and crashes, which cause
    all messages to be re-delivered.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的错误是允许无限制的预取，其中一个客户端接收所有消息，导致高内存消耗和崩溃，这会导致所有消息重新投递。
- en: In scenarios where there are many consumers and/or a longer time to process
    messages, it is recommended that the prefetch value is set to one (1) to evenly
    distribute messages among all consumers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在有多个消费者和/或较长的消息处理时间的情况下，建议将预取值设置为1（1），以均匀地将消息分配给所有消费者。
- en: If the client is set to auto-ack messages, prefetch settings will have no effect.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端设置为自动确认消息，预取设置将没有效果。
- en: As mentioned in [*Chapter 2*](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating
    a Taxi Application*, a consumer can acknowledge message delivery back to the broker.
    It's now time to look into how that can be done.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第2章*](377ec533-342d-4a08-9011-7176de197886.xhtml)中所述，*创建出租车应用程序*，消费者可以向代理确认消息的投递。现在是时候探讨如何实现这一点了。
- en: Acknowledging messages
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确认消息
- en: A message that is in transit between the broker and the consumer might get lost
    in the event of a connection failure, and important messages probably need to
    be retransmitted. Acknowledgments let the server and clients know when to retransmit
    messages.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理和消费者之间传输的消息可能会在连接失败的情况下丢失，并且重要消息可能需要重新传输。确认让服务器和客户端知道何时重新传输消息。
- en: There are two possible ways to acknowledge message delivery – once a consumer
    receives the message (an automatic acknowledgment, auto-ack), and when a consumer
    sends back an acknowledgment (explicit/manual acknowledge). With auto-ack, the
    message is acknowledged as soon as it leaves the queue (and is thereby removed
    from the queue). It is best to auto-ack when high message speeds are required,
    if the connections are reliable, and if lost messages aren't a concern.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 确认消息投递有两种可能的方式——一旦消费者收到消息（自动确认，auto-ack），以及当消费者发送回确认（显式/手动确认）。在需要高消息速度、连接可靠且丢失消息不是问题的情况下，最好使用自动确认。
- en: Using manual acknowledgments on messages can have a performance impact on the
    system, compared to an automatic acknowledgment. If aiming for fast throughput,
    manual acknowledgments should be disabled, and auto acknowledgments should be
    used instead.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与自动确认相比，在消息上使用手动确认可能会对系统性能产生影响。如果目标是快速吞吐量，应禁用手动确认，并改用自动确认。
- en: 'In CC''s case, the risk of losing a message is not acceptable, so the preceding
    code has been changed to set the acknowledgment to `manual`, making it possible
    to determine when to acknowledge the message:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在CC的情况下，消息丢失的风险是不可接受的，因此前面的代码已被修改为将确认设置为`手动`，从而可以确定何时确认消息：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The message also has to be acknowledged once it has been fully processed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 消息在完全处理完毕后也必须进行确认：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As demonstrated, the method to manually acknowledge takes two arguments – the
    first is `delivery tag`, and the second is needed in case more than one message
    must be acknowledged at once. A delivery tag is a channel-specific number that
    the server uses to identify deliveries. It is of crucial importance that the consumer
    acknowledges the messages on the same channel as they were received because not
    doing so will raise an error.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，手动确认的方法需要两个参数——第一个是`投递标签`，第二个在需要同时确认多个消息时是必需的。投递标签是服务器用于标识投递的通道特定数字。消费者必须在接收消息的同一通道上确认消息至关重要，因为如果不这样做，将会引发错误。
- en: After changing the code and running the application, the ack column rate is
    shown as non-zero. This is because manual acknowledgment is now used and the RabbitMQ
    client now sends ack messages over the wire to the broker. This has a cost in
    terms of bandwidth usage and general performance; however, if the priority is
    the guarantee of successful message processing over speed, it is perfectly acceptable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 修改代码并运行应用程序后，ack列的比率显示为非零。这是因为现在使用了手动确认，并且RabbitMQ客户端现在通过有线向代理发送ack消息。这会在带宽使用和总体性能方面产生成本；然而，如果优先考虑的是确保消息处理成功而不是速度，这是完全可以接受的。
- en: Use manual acknowledgment if there is a risk that the processing of a message
    may fail and the broker needs to eventually redeliver it. Redelivery of unacknowledged
    messages doesn't happen immediately unless the message is rejected or the channel
    is closed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在消息处理可能失败且代理最终需要重新投递的风险，请使用手动确认。除非消息被拒绝或通道关闭，否则未确认消息的重传不会立即发生。
- en: CC's journey with RabbitMQ is getting more exciting, causing the team to request
    a new feature to send important information to all taxi drivers directly. Let's
    see how to implement this new feature!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CC与RabbitMQ的旅程变得越来越激动人心，这使得团队请求一个新功能，可以直接向所有出租车司机发送重要信息。让我们看看如何实现这个新功能！
- en: Publishing to all queues
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布到所有队列
- en: 'With the new feature request in hand, the CC programming team came up with
    the new overall messaging architecture shown in the following diagram. The back-office
    application will be connected to RabbitMQ in order to publish information messages
    to all taxi drivers:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到新的功能请求后，CC编程团队提出了以下图中所示的新整体消息架构。后台应用将连接到RabbitMQ，以便向所有出租车司机发布信息消息：
- en: '![](img/966ed4da-f77c-4c89-acee-32a1e47dd8a6.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/966ed4da-f77c-4c89-acee-32a1e47dd8a6.png)'
- en: 'Fig 3.3: Back-office application in the architecture'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：架构中的后台应用
- en: To roll this out, one way could be to use the topic messaging that's already
    in place and create a special topic to which all drivers would be subscribed.
    However, there is an even cleaner and simpler approach offered by the AMQP protocol
    – fanout exchange.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推广这个功能，一种方法可能是使用已经存在的主题消息并创建一个所有司机都会订阅的特殊主题。然而，AMQP协议提供了一个更干净、更简单的方法——fanout交换。
- en: Fanout exchange
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fanout交换
- en: Fanout exchange takes all messages that are coming in and delivers them to all
    queues that are bound to it. An easy-to-understand example of where to use a fanout
    is when messages need to be spread between many participants, like in a chat (however,
    there are probably better choices for pure chat applications).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Fanout交换接收所有传入的消息并将它们发送到所有绑定到它的队列。一个易于理解的例子是当消息需要在许多参与者之间传播时，例如在聊天中（然而，对于纯聊天应用可能还有更好的选择）。
- en: 'Other examples include the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 其他例子包括以下内容：
- en: Score board or leaderboard updates from sports news to mobile clients, or other
    global events
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从体育新闻到移动客户端的得分板或排行榜更新，或其他全球事件
- en: Broadcasting various state and configuration updates in distributed systems
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分布式系统中广播各种状态和配置更新
- en: 'As shown in the following diagram, the fanout exchange routes a copy of each
    message it receives to all the queues bound to it. This model fits perfectly with
    the public address behavior that CC aims for in the new feature, the option to
    send a single message to all drivers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，fanout交换将接收到的每个消息的副本路由到所有绑定到它的队列。这种模式与CC在新功能中追求的公共广播行为完美匹配，即向所有司机发送单个消息的选项：
- en: '![](img/0b369565-ce6e-4fa0-b3bc-228e1c0738a1.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b369565-ce6e-4fa0-b3bc-228e1c0738a1.png)'
- en: 'Fig 3.4: The fanout exchange routes to all bound queues'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：fanout交换路由到所有绑定队列
- en: It's time to add the fanout exchange into CC's application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将fanout交换添加到CC的应用中了。
- en: Binding to the fanout
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定到fanout
- en: The back office should be able to publish a single message to all taxi drivers.
    This message could include current traffic information or information about a
    party that will happen during the evening. Because this new broadcast system will
    be infrequently used, the CC team was not as concerned about efficient connection
    management as they were with the main application. In fact, it's fine to connect
    and disconnect for each interaction with the fanout exchange because, in the case
    of temporary issues with the RabbitMQ broker, retries from the back office application
    will eventually succeed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 后台应该能够向所有出租车司机发布单个消息。这条消息可以包括当前的交通信息或晚上将发生的派对信息。因为这种新的广播系统将很少使用，CC团队对高效连接管理的关注不如对主应用那么大。事实上，对于fanout交换的每次交互，连接和断开连接都是可以的，因为如果RabbitMQ代理出现暂时性问题，后台应用的重试最终会成功。
- en: 'To start using the new fanout exchange in the back office, two steps must be
    performed: first, declare the fanout exchange when the application starts, and
    then bind the queue to it when a user logs in.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在后台使用新的fanout交换，必须执行两个步骤：首先，在应用启动时声明fanout交换，然后当用户登录时将队列绑定到它。
- en: 'Number five in the following example shows the code added to the back office
    service in order to publish messages on this new exchange:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例中的第五个数字显示了添加到后台服务以在此新交换机上发布消息的代码：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The logic in this code should feel familiar. An empty string is used as the
    routing key when binding the queue. The value doesn't really matter because the
    fanout exchange doesn't care about routing keys.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的逻辑应该感觉熟悉。在绑定队列时，使用空字符串作为路由键。这个值并不真正重要，因为扇出交换机不关心路由键。
- en: Notice that `exchange` is declared right before using it. This avoids relying
    on the implicit pre-existence of the exchange. Not doing that would mean that
    the main application would have to run once to create the exchange before the
    back office service can use it. Since the exchange declaration is idempotent,
    it can and should be declared at all times.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`exchange` 在使用之前被声明。这避免了依赖于交换机的隐式存在。如果不这样做，就意味着主应用程序必须运行一次来创建交换机，然后后台服务才能使用它。由于交换机声明是幂等的，它可以在任何时候声明。
- en: Be particularly careful with AMQP client libraries that may use different default
    values for exchange and queue parameters; it's better to be explicit and to specify
    all values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意可能使用不同默认值的 AMQP 客户端库；最好是明确指定所有值。
- en: The same queues as in the direct and topic exchange example are not used since
    the taxi inbox queue only includes information messages. Two new queues (`taxi-inbox.1`
    and `taxi-inbox.2`) are instead declared and bounded to the exchange.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于出租车收件箱队列仅包括信息消息，因此不使用与直接和主题交换示例中相同的队列。相反，声明了两个新的队列（`taxi-inbox.1` 和 `taxi-inbox.2`），并将它们绑定到交换机上。
- en: Unless there is a strong guarantee that an exchange or a queue will pre-exist,
    assume it doesn't exist and declare it. It is better to be safe than sorry, especially
    when AMQP encourages it and provides the necessary means to do so.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有强有力的保证交换机或队列将预先存在，否则假设它不存在并声明它。安全总是比后悔好，尤其是在 AMQP 鼓励这样做并提供必要的手段时。
- en: With this code in place, the back office application can now send public information
    messages to all drivers. This is a great success, one that again reinforces CC
    in its decision to deploy RabbitMQ and build on it. Now, let's run the application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，后台应用程序现在可以向所有司机发送公共信息消息。这是一个巨大的成功，再次强化了 CC 部署 RabbitMQ 并在此基础上构建的决定。现在，让我们运行应用程序。
- en: Running the application
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: There's nothing spectacular to note when running the application; messages from
    the back office successfully flow to the drivers' inbox queues and the only visible
    change is the newly created driver fanout exchange.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序时没有值得注意的特别之处；来自后台的消息成功流向司机的收件箱队列，唯一可见的变化是新建的司机扇出交换机。
- en: 'This is visible in the management console shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下屏幕截图所示的管理控制台中是可见的：
- en: '![](img/66699092-b5ce-4f3b-a402-dcb3986c68f9.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66699092-b5ce-4f3b-a402-dcb3986c68f9.png)'
- en: 'Fig 3.5: The fanout exchange for user queues is visible in the management console'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：用户队列的扇出交换机在管理控制台中可见
- en: At this point, it is interesting to take a look at the bindings of any particular
    queue. To do this, click on the Queues tab and then scroll down and click on Bindings
    to display the hidden window.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，查看任何特定队列的绑定是有趣的。为此，点击“队列”选项卡，然后向下滚动并点击“绑定”以显示隐藏的窗口。
- en: 'This will show what is reproduced, as in the following screenshot where each
    queue has multiple bindings – one for the user-to-taxi messaging feature, one
    for the topics messages, and a final one for the public address fanout feature:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下截图中的内容，其中每个队列都有多个绑定——一个用于用户到出租车消息功能，一个用于主题消息，最后一个用于公共广播功能：
- en: '![](img/17132d85-a996-4e16-86ea-236db35e0f71.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17132d85-a996-4e16-86ea-236db35e0f71.png)'
- en: 'Fig 3.6: Each taxi queue has multiple bindings'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：每个出租车队列有多个绑定
- en: Before concluding, let's pause for a second and relish the fact that there is
    now a successful taxi request integration that works across platforms. This may
    not seem important to anyone with a little experience in messaging systems; however,
    it is nothing short of a small miracle. Thanks to AMQP and RabbitMQ, the message
    broker can be replaced with any other AMQP-based message broker, and more services
    can be added in any chosen language.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，让我们暂停一下，享受一下现在有一个成功跨平台出租车请求集成的现实。对于在消息系统方面有一点经验的人来说，这可能并不重要；然而，这简直是一个小小的奇迹。多亏了AMQP和RabbitMQ，消息代理可以被任何其他基于AMQP的消息代理所取代，并且可以在任何选择的编程语言中添加更多服务。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter talked about prefetch and manual acknowledgment from the consumer.
    The fanout exchange was introduced, to be able to broadcast a single message to
    all active queues. Up next, CC has new plans for its RabbitMQ system – they want
    to be able to clean up old messages in a smooth way and tweak the message delivery.
    They also want to be able to send messages to individual drivers from the back
    office service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了消费者的预取和手动确认。介绍了fanout交换，以便能够向所有活跃队列广播单个消息。接下来，CC对其RabbitMQ系统有新的计划——他们希望能够以平稳的方式清理旧消息并调整消息投递。他们还希望能够从后台服务向个别司机发送消息。
- en: Continue on to the next chapter to find out what CC is up to!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 继续阅读下一章，了解CC正在做什么！
