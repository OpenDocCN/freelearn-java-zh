- en: Chapter 6. Concurrency in Scala
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Scala中的并发
- en: 'In this chapter, we will switch our focus from collections to a different topic:
    concurrency. Being able to take advantage of all the CPU resources that your hardware
    provides is critical to writing performant software. Unfortunately, writing concurrent
    code is not an easy task because it is easy to write unsafe programs. If you come
    from Java, you may still have nightmares involving `synchronized` blocks and locks!
    The `java.util.concurrent` package provides numerous tools that make writing concurrent
    code simpler. However, designing stable and reliable concurrent applications can
    still be a daunting challenge. In this chapter, we will explore the tools that
    are provided by the Scala standard library to take advantage of concurrency. After
    a short presentation of the main abstraction, `Future`, we will study its behavior
    and usage pitfalls that we should avoid. We will end this chapter by exploring
    a possible alternative to `Future` named `Task`, which is provided by the Scalaz
    library. In this chapter, we will explore the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从集合转向一个不同的主题：并发。能够利用硬件提供的所有CPU资源对于编写高性能软件至关重要。不幸的是，编写并发代码并不容易，因为很容易编写出不安全的程序。如果你来自Java，你可能仍然会梦魇般地涉及`synchronized`块和锁！`java.util.concurrent`包提供了许多工具，使编写并发代码变得简单。然而，设计稳定可靠并发应用仍然是一个艰巨的挑战。在本章中，我们将探讨Scala标准库提供的工具，以利用并发。在简要介绍主要抽象`Future`之后，我们将研究其行为和应避免的使用陷阱。我们将通过探索由Scalaz库提供的名为`Task`的`Future`的替代方案来结束本章。在本章中，我们将探讨以下主题：
- en: Concurrency versus parallelism
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发与并行
- en: Future usage considerations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来使用考虑
- en: Blocking calls and callbacks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞调用和回调
- en: Scalaz Task
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scalaz Task
- en: Parallelizing backtesting strategies
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行化回测策略
- en: The data scientists are off and running with the data analysis tools that you
    built for them to research trading strategies. However, they have hit a wall because
    backtesting strategies is becoming too expensive. As they have built more sophisticated
    strategies that require more historical data, and employ more stateful algorithms,
    backtesting has taken longer. Once again, you are being called upon to help out
    at MVT by leveraging Scala and the functional paradigm to deliver performant software.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家们正在使用你为他们构建的数据分析工具进行研究交易策略。然而，他们遇到了瓶颈，因为回测策略变得越来越昂贵。随着他们构建了更复杂的策略，这些策略需要更多的历史数据，并采用更多有状态的算法，回测所需时间更长。又一次，你被召唤到MVT，利用Scala和函数式范式来提供高性能软件。
- en: The data scientists have incrementally built out a backtesting tool that allows
    the team to determine a strategy's performance by replaying historical data. This
    works by providing a preset strategy to run, the ticker to test against, and the
    time interval of historical data to replay. The backtester loads market data and
    applies the strategy to generate trading decisions. Once the backtester finishes
    replaying historical data, it summarizes and displays strategy performance results.
    The backtester is heavily depended on to determine the efficacy of proposed trading
    strategies before putting them into production for live trading.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家们逐步构建了一个回测工具，该工具允许团队通过回放历史数据来确定策略的表现。这是通过提供一个预设的策略来运行，一个用于测试的股票代码，以及回放历史数据的时间间隔来实现的。回测器加载市场数据并将策略应用于生成交易决策。一旦回测器完成历史数据的回放，它将总结并显示策略性能结果。回测器在将策略投入实际交易生产之前，被大量依赖以确定所提交易策略的有效性。
- en: 'To begin familiarizing yourself with the backtester, you look into the code,
    as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始熟悉回测器，你可以查看以下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding snapshot from the data analysis repository, you see the primary
    method that drives backtesting. Given a `Strategy`, `Ticker`, and `Interval`,
    it can produce `BacktestPerformanceSummary`. Scanning the repository, you find
    a file named `CrazyIdeas.scala` that shows Dave as the only commit author. In
    here, you see example invocations of the backtester:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的数据分析仓库快照中，你可以看到驱动回测的主要方法。给定一个`Strategy`、`Ticker`和`Interval`，它可以生成`BacktestPerformanceSummary`。扫描仓库，你发现一个名为`CrazyIdeas.scala`的文件，显示Dave是唯一的提交作者。在这里，你可以看到回测器的示例调用：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The usage of the backtester gives you a clue to a possible performance improvement.
    It looks like when Dave has a new idea, he wants to evaluate its performance on
    multiple symbols and compare it against other strategies. In its current form,
    backtests are performed sequentially. One way to improve the execution speed of
    the backtester is to parallelize the execution of all backtesting runs. If each
    invocation of the backtester is parallelized and if there are spare hardware resources,
    then backtesting multiple strategies and symbols will finish faster. To understand
    how to parallelize the backtester, we first need to dive into the topic of asynchronous
    programming and then see how Scala supports concurrency.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回测工具可以给你一个可能的性能改进的线索。看起来当 Dave 有一个新想法时，他想要评估它在多个符号上的性能，并将其与其他策略进行比较。在其当前形式中，回测是顺序执行的。提高回测工具执行速度的一种方法是将所有回测运行的执行并行化。如果每个回测工具的调用都是并行化的，并且有额外的硬件资源，那么回测多个策略和符号将更快完成。为了理解如何并行化回测工具，我们首先需要深入研究异步编程的主题，然后看看
    Scala 如何支持并发。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before diving into the code, we need to enrich our vocabulary to discuss the
    properties of asynchronous programming. Concurrency and parallelism are often
    used interchangeably, but there is an important distinction between these two
    terms. Concurrency involves two (or more) tasks that are started and executed
    in overlapping time periods. Both tasks are in-progress (that is, they are running)
    at the same time, but only one task may be performing actual work at any instant
    in time. This is the case when you write concurrent code on a single-core machine.
    Only one task can progress at a time, but multiple tasks are ongoing concurrently.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，我们需要丰富我们的词汇来讨论异步编程的特性。并发性和并行性经常被互换使用，但这两个术语之间存在一个重要的区别。并发涉及两个（或更多）任务，它们在重叠的时间段内启动和执行。两个任务都在进行中（即，它们正在运行），但在任何给定的时间点，可能只有一个任务正在执行实际工作。这是你在单核机器上编写并发代码的情况。一次只有一个任务可以进步，但多个任务可以并发进行。
- en: Parallelism exists only when both tasks are truly running at the same time.
    With a dual-core machine, you can execute two tasks at the same time. From this
    definition, we see that parallelism depends on the hardware that is available
    for use. This means that the property of concurrency can be added to a program,
    but parallelism is outside the control of the software.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并行性只有在两个任务真正同时运行时才存在。在双核机器上，你可以同时执行两个任务。从这个定义中，我们可以看出并行性取决于可用的硬件。这意味着并发性可以添加到程序中，但并行性超出了软件的控制范围。
- en: To better illustrate these concepts, consider the example of painting a room.
    If there is only one painter, the painter can paint the first coat on a wall,
    move on to the next wall, go back to the first wall for the second coat and then
    finish the second wall. The painter is painting both walls concurrently, but can
    only spend time on one wall at any given time. If two painters are on the job,
    they can each focus on one wall and paint them in parallel.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明这些概念，可以考虑粉刷房间的例子。如果只有一个粉刷工，粉刷工可以在墙上刷第一层涂料，然后移动到下一面墙，再回到第一面墙刷第二层，然后完成第二面墙。粉刷工同时粉刷两面墙，但任何给定时间只能在一面墙上花费时间。如果有两个粉刷工在作业，他们可以各自专注于一面墙，并平行地粉刷它们。
- en: Exploring Future
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Future
- en: 'The primary construct in Scala to drive concurrent programming is `Future`.
    Found in the `scala.concurrent` package, `Future` can be seen as a container for
    a value that may not yet exist. Let''s look at a simple example to illustrate
    usage:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中用于驱动并发编程的主要构造是 `Future`。位于 `scala.concurrent` 包中，`Future` 可以被视为一个可能尚未存在的值的容器。让我们通过一个简单的例子来说明其用法：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding example shows a short method, creating a `Future` value simulates
    an expensive computation and prints a couple of lines to make it easier for us
    to understand the flow of the application. When running `example`, we see the
    following output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子展示了一个简短的方法，创建一个 `Future` 值模拟了昂贵的计算，并打印了几行以便我们更容易理解应用程序的流程。当运行 `example`
    时，我们看到以下输出：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see that `Future` was executed after the end of the `example` method.
    This is because when a `Future` is created, it starts its computation concurrently.
    You may be wondering, "What is this `context` object of the `ExecutionContext`
    type that is used when creating the `Future`?" We will explore `ExecutionContext`
    in-depth shortly, but for now, we treat it as the the object that is responsible
    for the execution of the `Future`. We import `scala.concurrent.ExecutionContext.global`,
    which is a default object that is created by the standard library to be able to
    execute the `Future`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`Future` 在 `example` 方法结束之后执行。这是因为当创建 `Future` 时，它开始并发地执行其计算。你可能想知道，“在创建
    `Future` 时使用的 `context` 对象是什么类型的 `ExecutionContext`？” 我们将在稍后深入探讨 `ExecutionContext`，但现在，我们将其视为负责
    `Future` 执行的对象。我们导入 `scala.concurrent.ExecutionContext.global`，这是一个由标准库创建的默认对象，以便能够执行
    `Future`。
- en: A `Future` object is a stateful object. It is either not yet complete when the
    computation is underway or completed once the computation finishes. Furthermore,
    a completed `Future` can be either a success when the computation was able to
    complete, or it can be a failure if an exception was thrown during the computation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 对象是一个有状态的对象。当计算正在进行时，它可能尚未完成；一旦计算完成，它就完成了。此外，一个完成的 `Future` 可以是计算成功时的成功状态，或者如果计算过程中抛出了异常，则可以是失败状态。'
- en: 'The `Future` API provides combinators to compose the `Future` instances and
    manipulate the result that they contain:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` API 提供了组合 `Future` 实例和操作它们包含的结果的组合器：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This snippet from the Scala console shows construction of a `Future` data type
    that wraps a constant integer value. We see that the integer contained in the `Future`
    data type is transformed using functions that are similar to the ones that we
    expect to find on `Option` and collection data types. These transforms are applied
    once the preceding `Future` completes, and return a new `Future`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Scala 控制台代码片段显示了构造一个包装常量整数值的 `Future` 数据类型。我们看到，包含在 `Future` 数据类型中的整数是通过类似于我们预期在
    `Option` 和集合数据类型上找到的函数转换的。这些转换在先前的 `Future` 完成后应用，并返回一个新的 `Future`。
- en: 'As promised, we now look into `ExecutionContext`. The `ExecutionContext` can
    be thought of as the machinery behind `Future` that provides runtime asynchrony.
    In the previous snippet, a `Future` was created to perform simple addition and
    modulo division without explicitly providing an `ExecutionContext` instance at
    the call site. Instead, only an import of the `global` object was provided. The
    snippet executes because `global` is an implicit value and the signature of `map`
    accepts an implicit `ExecutionContext`. Let''s look at the following signature
    of `map` to deepen our understanding:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，我们现在来探讨 `ExecutionContext`。`ExecutionContext` 可以被视为 `Future` 背后的机制，它提供了运行时异步性。在前面的代码片段中，创建了一个
    `Future` 来执行简单的加法和模除运算，而没有在调用位置显式提供 `ExecutionContext` 实例。相反，只提供了对 `global` 对象的导入。代码片段能够执行，因为
    `global` 是一个隐式值，而 `map` 的签名接受一个隐式的 `ExecutionContext`。让我们看看 `map` 的以下签名，以加深我们的理解：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From the signature of `map`, we see that unlike the `map` transformation on `List`,
    the `Future` requires a curried, implicit `ExecutionContext` argument. To understand
    how an `ExecutionContext` provides runtime asynchrony, we need to first understand
    its operations:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `map` 的签名中，我们可以看到，与 `List` 上的 `map` 转换不同，`Future` 需要一个柯里化的、隐式的 `ExecutionContext`
    参数。为了理解 `ExecutionContext` 如何提供运行时异步性，我们首先需要了解它的操作：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `execute` is a side-effecting method that operates on a `java.lang.Runnable`.
    For those familiar with concurrency in Java, you most likely recall that `Runnable`
    is the commonly-used interface to allow threads and other `java.util.concurrent`
    abstractions to execute code concurrently. Although we do not know how `Future`
    achieves runtime asynchrony yet, we do know there is a link between `Future` execution
    and creation of a `Runnable`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute` 是一个作用于 `java.lang.Runnable` 的副作用方法。对于那些熟悉 Java 并发的开发者，你很可能记得 `Runnable`
    是一个常用的接口，允许线程和其他 `java.util.concurrent` 抽象并发执行代码。尽管我们还不清楚 `Future` 如何实现运行时异步性，但我们确实知道
    `Future` 的执行和 `Runnable` 的创建之间存在联系。'
- en: 'The next question we will answer is, "How do I create an `ExecutionContext`?
    " By studying the companion object, we discover the following signatures:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要回答的问题是，“我该如何创建一个 `ExecutionContext`？” 通过研究伴随对象，我们发现以下签名：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The standard library provides convenient ways to create an `ExecutionContext`
    from either a `java.util.concurrent.Executor` or `java.util.concurrent.ExecutorService`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了方便的方法，可以从 `java.util.concurrent.Executor` 或 `java.util.concurrent.ExecutorService`
    创建 `ExecutionContext`。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unfamiliar with the machinery that is provided by the `java.util.concurrent`
    package and you are looking for a deeper treatment than that provided by the API
    documentation, we encourage you to read *Java Concurrency in Practice* by Brian
    Goetz ([http://jcip.net/](http://jcip.net/)). Although *Java Concurrency in Practice*
    was written around the release of JDK 6, it contains numerous principles that
    continue to apply today. Reading this book will provide you with a deep understanding
    of the JDK-provided concurrency primitives that are utilized by the Scala standard
    library.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 `java.util.concurrent` 包提供的机制，并且你希望获得比 API 文档提供的更深入的处理，我们鼓励你阅读 Brian
    Goetz 的《Java 并发实践》（[http://jcip.net/](http://jcip.net/)）。尽管《Java 并发实践》是围绕 JDK
    6 的发布编写的，但它包含了今天仍然适用的许多原则。阅读这本书将为你提供对 Scala 标准库使用的 JDK 提供的并发原语进行深入了解。
- en: 'The return type of the factory methods is a more specialized version of `ExecutionContext`.
    The standard library defines the following inheritance chain for `ExecutionContext`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法的返回类型是 `ExecutionContext` 的一个更专业的版本。标准库为 `ExecutionContext` 定义了以下继承链：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, in the `ExecutionContext` companion object, we find the implicit context
    used in our first example, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `ExecutionContext` 伴随对象中，我们可以找到我们第一个示例中使用的隐式上下文，如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The documentation for the definition of `Implicits.global` indicates that this `ExecutionContext`
    is backed by a thread pool with a thread count that is equal to the available
    processor count. Our dive into `ExecutionContext` shows us how the simple `Future`
    example runs. We can illustrate how a `Future` applies its `ExecutionContext`
    to execute on multiple threads:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Implicits.global` 的定义文档指出，这个 `ExecutionContext` 由一个线程池支持，其线程数等于可用的处理器数量。我们对
    `ExecutionContext` 的深入研究展示了简单的 `Future` 示例是如何运行的。我们可以展示 `Future` 如何将其 `ExecutionContext`
    应用到多个线程上执行：'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We extend the original snippet to print the name of the thread performing each
    transformation. When run on a machine with multiple cores, this snippet yields
    variable output, depending on which threads pick up the transformations. Here
    is an example output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了原始片段以打印执行每个转换的线程名称。在多核机器上运行时，此片段的输出是可变的，取决于哪些线程获取了转换。以下是一个示例输出：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example shows that one `worker-3` thread performed the `map` transformation
    while another `worker-5` thread performed the `filter` transformation. There are
    two key insights to draw from our simple example about how `Future` affects control
    flow. First, `Future` is a data type for concurrency that enables us to break
    the control flow of a program into multiple logical threads of processing. Second,
    our example shows that `Future` begins execution immediately upon creation. This
    means that transformations are applied immediately in a different flow of the
    program. We can use these insights to improve the runtime performance of Dave's
    crazy ideas.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例表明一个 `worker-3` 线程执行了 `map` 转换，而另一个 `worker-5` 线程执行了 `filter` 转换。从我们简单的示例中，我们可以得出两个关于
    `Future` 如何影响控制流的关键见解。首先，`Future` 是一种并发数据类型，使我们能够将程序的流程控制分解成多个逻辑处理线程。其次，我们的示例表明
    `Future` 在创建时立即开始执行。这意味着转换立即在程序的另一个流程中应用。我们可以利用这些见解来提高 Dave 的疯狂想法的运行时性能。
- en: Future and crazy ideas
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来与疯狂想法
- en: 'We apply `Future` to Dave''s set of backtests to improve performance. We believe
    there is an opportunity for a performance improvement because Dave''s laptop has
    four CPU cores. This means that by adding concurrency to our program, we will
    be able to benefit from runtime parallelism. Our first attempt utilizes a for-comprehension:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Future` 应用到 Dave 的回测集中以提高性能。我们相信存在改进性能的机会，因为 Dave 的笔记本电脑有四个 CPU 核心。这意味着通过向我们的程序添加并发性，我们将能够从运行时并行性中受益。我们的第一次尝试使用
    for-表达式：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each backtest invocation is wrapped with the creation of a `Future` instance
    by calling `Future.apply`. This companion object method uses a by-name parameter
    to defer evaluation of the argument, which, in this case, is the invocation of `backtest`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每次回测调用都通过调用 `Future.apply` 创建一个 `Future` 实例进行封装。这个伴随对象方法使用按名参数来延迟对参数的评估，在这种情况下，是调用
    `backtest`：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After running the new version of `CrazyIdeas.scala`, you are disappointed to
    see the runtime execution has not improved. You quickly double-check the number
    of CPUs on your Linux box, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`CrazyIdeas.scala`的新版本后，你失望地看到运行时执行并没有得到改善。你迅速地检查了Linux机器上的CPU数量，如下所示：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Having confirmed there are eight cores available on your laptop, you wonder
    why the execution time matches the original serial execution time. The solution
    here is to consider how the for-comprehension is compiled. The for-comprehension
    is equivalent to the following simpler example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 确认笔记本电脑上有八个核心后，你疑惑为什么执行时间与原始的串行执行时间相同。这里的解决方案是考虑for-comprehension是如何编译的。for-comprehension等同于以下更简单的示例：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this desugared representation of the for-comprehension, we see that the
    second `Future` is created and evaluated within the `flatMap` transformation of
    the first `Future`. Any transformation applied to a `Future` (for example, `flatMap`)
    is only invoked once the value provided to the transform has been computed. This
    means that the `Future` in the preceding example and the for-comprehension are
    executed sequentially. To achieve the concurrency that we are looking for, we
    must instead modify `CrazyIdeas.scala` to look like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个for-comprehension的简化表示中，我们看到第二个`Future`是在第一个`Future`的`flatMap`转换中创建和评估的。任何应用于`Future`的转换（例如`flatMap`）都只有在提供给转换的值被计算后才会被调用。这意味着先前的示例中的`Future`和for-comprehension是顺序执行的。为了达到我们想要的并发性，我们必须修改`CrazyIdeas.scala`使其看起来如下：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this snippet, four backtests are kicked off concurrently and the results
    are transformed into a `Future` of a `Tuple4` consisting of four `BacktestPerformanceSummary`
    values. Seeing is believing, and after showing Dave the faster runtime of his
    backtests, he is excited to iterate quickly on new backtest ideas. Dave never
    misses a chance to throw around a pun, exclaiming, "Using all my cores is making
    my laptop fans really whiz. Not sure I'm a fan of the noise, but I sure do like
    the performance!"
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，并发启动了四个回测，并将结果转换为一个包含四个`BacktestPerformanceSummary`值的`Tuple4`的`Future`。眼见为实，在向Dave展示他的回测运行速度更快后，他兴奋地快速迭代新的回测想法。Dave从不错过任何开玩笑的机会，他感叹道：“使用我所有的核心让我的笔记本电脑风扇转得飞快。不确定我是否喜欢这种噪音，但确实喜欢这种性能！”
- en: Future usage considerations
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Future`使用注意事项'
- en: In the previous example, we illustrated the ease of use of the `Future` API
    by investigating how to introduce concurrency to the backtester. Like any powerful
    tool, your usage of `Future` must be disciplined to ensure correctness and performance.
    This section evaluates topics that commonly cause confusion and error when using
    the `Future` to add concurrency to your program. We will detail performing side-effects,
    blocking execution, handling failures, choosing an appropriate execution context,
    and performance considerations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们通过研究如何将并发引入回测器来展示了`Future` API的易用性。像任何强大的工具一样，你对`Future`的使用必须是有纪律的，以确保正确性和性能。本节评估了在使用`Future`添加并发到程序时常见的一些混淆和错误。我们将详细讨论执行副作用、阻塞执行、处理失败、选择合适的执行上下文以及性能考虑。
- en: Performing side-effects
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行副作用
- en: 'When programming with `Future`, it is important to remember that `Future` is
    inherently a side-effecting construct. Unless the `success` or `failure` factory
    methods are used to lift a value into a `Future`, work is scheduled to be executed
    on a different thread (part of the `ExecutionContext` that is used to create the `Future`).
    More importantly, once executed, a `Future` cannot be executed again. Consider
    the following snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Future`编程时，重要的是要记住`Future`本质上是一个有副作用的构造。除非使用`success`或`failure`工厂方法将值提升到`Future`中，否则工作将被安排在另一个线程上执行（这是创建`Future`时使用的`ExecutionContext`的一部分）。更重要的是，一旦执行，`Future`就不能再次执行。考虑以下代码片段：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Future` is computed and prints `FOO` as expected. We can then access the
    value wrapped in the `Future`. Note that when accessing the value, nothing is
    printing on the console. Once completed, the `Future` is merely a wrapper for
    a realized value. If you want to perform the computation again, you need to create
    a new instance of `Future`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`被计算并按预期打印`FOO`。然后我们可以访问`Future`中包裹的值。注意，在访问值时，控制台上没有打印任何内容。一旦完成，`Future`仅仅是一个已实现值的包装器。如果你想再次执行计算，你需要创建一个新的`Future`实例。'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that the preceding example uses `Future.value` to extract the result of
    the computation. This is for the sake of simplicity. Production code should rarely,
    if ever, use this method. Its return type is defined as `Option[Try[A]]`. An `Option`
    is used to represent the case of a completed `Future` with a `Some`, and an unrealized `Future`
    with a `None`. Furthermore, remember that a realized `Future` can have two states:
    success or failure. This is the purpose of the inner `Try`. Like `Option.get`,
    it is almost never a good idea to use `Future.value`. To extract a value from
    a `Future`, refer to the additional techniques described next.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的例子使用了`Future.value`来提取计算的输出。这样做是为了简化。在生产代码中，很少甚至从不应该使用这种方法。它的返回类型定义为`Option[Try[A]]`。`Option`用于表示已完成的`Future`带有`Some`，以及未实现的`Future`带有`None`。此外，记住，已实现的`Future`可以有两种状态：成功或失败。这就是内部`Try`的目的。像`Option.get`一样，几乎从不建议使用`Future.value`。要从`Future`中提取值，请参考下面描述的附加技术。
- en: Blocking execution
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阻塞执行
- en: When we added concurrency to the backtester, we wrote a for-comprehension returning
    `Future[(BacktestPerformanceSummary, BacktestPerformanceSummary, BacktestPerformanceSummary,
    BacktestPerformanceSummary)]`, which may leave you wondering how you access the
    value wrapped in the `Future`. Another way of asking the question is, "Given `Future[T]`,
    how do I return `T`?" The short answer is, "You don't!" Programming with many `Future`
    requires a shift in thinking away from synchronous execution towards asynchronous
    execution. When programming with an asynchronous model, the goal is to avoid working
    with `T` directly because it implies a synchronous contract.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将并发性添加到回测器中时，我们编写了一个返回`Future[(BacktestPerformanceSummary, BacktestPerformanceSummary,
    BacktestPerformanceSummary, BacktestPerformanceSummary)]`的for-comprehension，这可能会让你想知道如何访问`Future`中包裹的值。另一种提问方式是，“给定`Future[T]`，我如何返回`T`？”简短的回答是，“你不能！”使用多个`Future`编程需要从同步执行向异步执行转变思维方式。在异步模型编程时，目标是避免直接与`T`交互，因为这暗示了一个同步合约。
- en: 'In practice, there are situations where it is useful to have the `Future[T]
    => T` function. For example, consider the backtester snippet. If the code from
    the snippet is used to create a program by defining an `object` extending `App`,
    the program will terminate before backtesting completes. As the threads in the `ExecutionContext`
    global are daemon threads, the JVM terminates immediately after creating the `Future`.
    In this scenario, we need a synchronization mechanism to pause execution until
    the result is ready. By extending the `Awaitable` trait, `Future` is able to provide
    such facilities. The `Await` module exposes two methods that achieve this goal:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，有些情况下拥有`Future[T] => T`函数是有用的。例如，考虑回测器的片段。如果从片段中的代码通过定义一个扩展`App`的`object`来创建程序，程序将在回测完成之前终止。由于`ExecutionContext`全局中的线程是守护线程，JVM在创建`Future`后立即终止。在这种情况下，我们需要一个同步机制来暂停执行，直到结果准备好。通过扩展`Awaitable`特质，`Future`能够提供这样的功能。`Await`模块公开了两个实现此目标的方法：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As `Future` extends `Awaitable`, a `Future` can be supplied as an argument
    to either method. The `ready` halts program flow until `T` is available and returns
    the completed `Future[T]`. In practice, `ready` is rarely used because it is conceptually
    strange to return a `Future[T]` from a synchronous call instead of `T`. You are
    more likely to commonly use `result`, which provides the desired transformation
    returning `T` given `Future[T]`. For example, `CrazyIdeas.scala` can be modified
    to look like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Future`扩展了`Awaitable`，`Future`可以作为参数传递给任一方法。`ready`方法会暂停程序流程，直到`T`可用，并返回完成的`Future[T]`。在实践中，`ready`很少使用，因为在同步调用中返回`Future[T]`而不是`T`在概念上是奇怪的。你更有可能经常使用`result`，它提供了所需的转换，给定`Future[T]`返回`T`。例如，`CrazyIdeas.scala`可以被修改成以下样子：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this snippet, we see the blocking, synchronous invocation of `Await.result`
    to return the `Tuple` of `Future[BacktestPerformanceSummary]`. This blocking call
    is parameterized with a timeout to defend against the scenario where the `Future`
    is not computed within a certain amount of time. Using a blocking call to retrieve
    the backtest results means that the JVM will only exit after the backtest completes
    or when the timeout expires. When the timeout expires and the backtest is incomplete, `result`
    and `ready` throw a `TimeoutException`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们看到阻塞、同步调用 `Await.result` 返回 `Future[BacktestPerformanceSummary]` 的
    `Tuple`。这个带有超时参数的阻塞调用是为了防御 `Future` 在一定时间内未计算的场景。使用阻塞调用检索回测结果意味着 JVM 只会在回测完成或超时到期后退出。当超时到期而回测未完成时，`result`
    和 `ready` 抛出 `TimeoutException`。
- en: Blocking execution of your program is potentially detrimental to your program's
    performance, and it should be used with caution. Using the methods on the `Await`
    companion object make blocking calls easy to recognize. As `ready` and `result`
    throw an exception when timing out, rather than returning a different data type,
    you must take extra caution to handle this scenario. You should treat any synchronous
    call involving asynchrony (that either does not provide a timeout or does not
    handle the timeout) as a bug.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞程序执行可能会对你的程序性能产生负面影响，因此应谨慎使用。使用 `Await` 伴生对象上的方法可以使阻塞调用易于识别。由于 `ready` 和 `result`
    在超时时抛出异常，而不是返回不同的数据类型，你必须格外小心地处理这种情况。你应该将任何涉及异步性的同步调用（要么不提供超时，要么不处理超时）视为错误。
- en: Programming asynchronously requires a mindset shift to write a program that
    describes what to do when the value appears rather than writing programs that
    require a value to exist before acting on it. You should be suspicious of any
    use of `Await` that interrupts transformation of a to-be-computed value. A set
    of transformations should be composed by acting upon `Future[T]` instead of `T`.
    Usage of `Await` should be restricted to scenarios where a program has no other
    work to perform and requires the result of the transformation, as we saw with
    the backtester.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程需要一种心态转变，编写描述值出现时做什么的程序，而不是编写在执行操作之前需要值存在的程序。你应该对任何中断待计算值转换的 `Await` 使用持怀疑态度。一系列转换应该通过作用于
    `Future[T]` 而不是 `T` 来组合。`Await` 的使用应限制在程序没有其他工作可做且需要转换结果的情况下，正如我们在回测器中看到的那样。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As the standard library models timeout with an exception instead of a different
    return type, it is hard to enforce that a timeout is always handled One way to
    improve safety is to write a utility method that returns `Option[T]` instead of `T`
    to account for the timeout scenario:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标准库模型使用异常而不是不同的返回类型来处理超时，因此很难强制执行始终处理超时的要求。提高安全性的一个方法是通过编写返回 `Option[T]` 而不是
    `T` 的实用方法来处理超时场景：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this new method, an entire error class is eliminated. As you encounter
    other unsafe transformations, consider defining methods that return a data type
    that encodes expected errors to avoid accidentally mishandling the transformation
    result. What other examples of unsafe transformations come to mind?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，可以消除整个错误类别。当你遇到其他不安全的转换时，考虑定义返回编码预期错误的数据类型的方法，以避免意外地处理转换结果不当。你还想到了哪些不安全转换的例子？
- en: Handling failures
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理失败
- en: 'Working with `Future` requires disciplined handling of error scenarios to avoid
    writing a set of transformations that are difficult to reason about. When an exception
    is thrown inside a `Future` transformation, it bubbles up within the transformation''s
    thread of computation and interrupts downstream transformations. Consider the
    following motivating example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Future` 一起工作需要纪律性地处理错误场景，以避免编写一组难以推理的转换。当一个异常在 `Future` 转换内部抛出时，它会在转换的计算线程中向上冒泡并中断下游的转换。考虑以下激励示例：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What do you expect to occur after the first `map` transformation? It is clear
    that the transformation will fail because the provided input cannot be cast to
    an integer. In this scenario, the `Future` is considered to be a failed `Future`
    and downstream transformations operating on the wrapped `Int` value, in this example,
    will not occur. In this simple example, it is obvious that the transformation
    cannot continue. Imagine a larger code base operating on data more complicated
    than a single integer with multiple failure scenarios across multiple namespaces
    and source files. In a real-world setting, it is more challenging to identify
    where an asynchronous computation broke down.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望在第一次`map`转换之后发生什么？很明显，转换将失败，因为提供的输入无法转换为整数。在这种情况下，`Future`被视为失败的`Future`，并且在此示例中，对包装的`Int`值执行的下游转换将不会发生。在这个简单的例子中，很明显转换无法继续。想象一下，在一个更大的代码库中，操作比单个整数更复杂的数据，并且有多个命名空间和源文件中的失败场景。在现实世界的设置中，确定异步计算失败的位置更具挑战性。
- en: '`Future` provides facilities for handling failures. It provides `recover` and `recoverWith`
    in order to continue downstream transformations. The signatures are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`提供了处理失败的功能。它提供了`recover`和`recoverWith`来继续下游转换。签名如下：'
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The difference between these two recovery methods is that the partial function
    provided to `recover` returns `U`, while `recoverWith` returns `Future[U]`. In
    our previous example, we can use `recover` to supply a default value to continue
    a transformation, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种恢复方法的区别在于，提供给`recover`的偏函数返回`U`，而`recoverWith`返回`Future[U]`。在我们的上一个例子中，我们可以使用`recover`来提供一个默认值以继续转换，如下所示：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running this snippet produces the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码片段会产生以下输出：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This approach allows you to continue a pipeline of transformations when one
    transform fails, but it suffers from the same shortcoming as the methods on `Await`.
    The returned `Future[T]` data type does not reflect the possibility of failure.
    Using recovery methods is error-prone because it is impossible to know whether
    the error conditions have been handled without reading through the code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许你在转换失败时继续转换管道，但它与`Await`上的方法具有相同的缺点。返回的`Future[T]`数据类型没有反映失败的可能性。使用恢复方法容易出错，因为无法知道是否处理了错误条件，除非阅读代码。
- en: 'The error handling that we investigated is appropriate to handle failures during
    a computation. It is likely that after a series of transformations complete, you
    will wish to perform special logic. Imagine you are building a web service that
    submits trading orders to exchanges. Order submission is successful if the order
    was submitted to the exchange; otherwise, it is considered a failed submission.
    As order submission involves communication with an external system, the exchange,
    you modeled this action with a `Future`. Here is what the method handling order
    submission looks like:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所研究的错误处理适用于处理计算过程中的失败。在一系列转换完成后，你可能会希望执行特殊的逻辑。想象一下，你正在构建一个提交交易订单到交易所的Web服务。如果订单已提交到交易所，则订单提交成功；否则，被视为失败的提交。由于订单提交涉及与外部系统（交易所）的通信，你使用`Future`来模拟这个动作。以下是处理订单提交的方法：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: An `ExecutionContext`, a way to submit orders, and a way to update a customer's
    trading positions after the trade is submitted allow a customer provided `RawOrder`
    to be submitted to the exchange. In the first processing step, the `RawOrder`
    is converted into a `ValidatedOrder`, and then lifted into a `Future`. `Future.failure`
    and `Future.successful` are convenient ways to lift or to wrap a computed value
    into a `Future`. The value is lifted into a `Future` to allow the entire sequence
    of steps to be written as a single for-comprehension.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutionContext`、提交订单的方式以及提交交易后更新客户交易位置的方式允许将客户提供的`RawOrder`提交到交易所。在第一个处理步骤中，`RawOrder`被转换为`ValidatedOrder`，然后提升到`Future`。`Future.failure`和`Future.successful`是方便地将计算值提升或包装到`Future`中的方式。值被提升到`Future`中，以便将整个步骤序列写成一个单一的for-comprehension。'
- en: Following the completion of all processing steps, `onComplete` is invoked to
    asynchronously handle completion of request processing. You can imagine in this
    context that completing request processing implies creating a serialized version
    of a response and transmitting this to the caller. Previously, the only mechanism
    at our disposal to perform work once a value is computed is to block using `Await`. `onComplete`
    is an asynchronously invoked callback that registers a function to be invoked
    when the value is completed. As shown in the example, `onComplete` supports handling
    success and failure cases, which makes it a general-purpose tool to handle the
    outcome of a `Future` transformation. In addition to `onComplete`, `Future` provides `onFailure`
    specifically for failure cases and `onSuccess` and `foreach` specifically for
    success cases.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有处理步骤之后，会异步调用`onComplete`来处理请求处理的完成。你可以想象在这个上下文中，完成请求处理意味着创建一个响应的序列化版本并将其传输给调用者。之前，我们唯一可用的机制是在值计算后执行工作，那就是使用`Await`进行阻塞。`onComplete`是一个异步调用的回调，它注册了一个在值完成时将被调用的函数。如示例所示，`onComplete`支持处理成功和失败情况，这使得它成为一个通用的工具，用于处理`Future`转换的结果。除了`onComplete`之外，`Future`还提供了`onFailure`专门用于失败情况，以及`onSuccess`和`foreach`专门用于成功情况。
- en: 'These callback methods expose a method signature that returns `Unit`. As a
    functional programmer, you should be leery of invoking these methods because they
    are side-effecting. The `onComplete` invocations should only happen at the absolute
    end of a computation when a side-effect can no longer be deferred. In the web
    service example, the side-effect is transmission of the response to the caller.
    Another common use case for using these side-effecting callbacks is to handle
    cross-cutting concerns, such as application metrics. Coming back to the web service,
    here is one way to increment an error counter when order submission to the exchange
    fails:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调方法公开了一个返回`Unit`的方法签名。作为一个函数式程序员，你应该对这些方法持谨慎态度，因为它们具有副作用。`onComplete`调用应该只在计算绝对结束时发生，此时副作用不能再被延迟。在Web服务示例中，副作用是将响应传输给调用者。使用这些具有副作用的回调的另一个常见用例是处理横切关注点，例如应用程序度量。回到Web服务，这是在订单提交到交易所失败时增加错误计数器的一种方法：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this snippet, a side-effect is performed when submission to the exchange
    fails via the `onFailure` callback. In this isolated example, it is straightforward
    to track where the side-effect is happening. However, in a larger system it can
    be a challenge to identify when and where callbacks were registered. Additionally,
    from the `Future` API documentation, we learn that callback execution is unordered,
    which indicates that all callbacks must be treated independently. This is why
    you must be disciplined about when and where you apply these side-effects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，当通过`onFailure`回调提交到交易所失败时，会执行副作用。在这个独立的例子中，跟踪副作用发生的位置很简单。然而，在一个更大的系统中，确定何时以及在哪里注册了回调可能是一个挑战。此外，从`Future`
    API 文档中，我们了解到回调执行是无序的，这意味着所有回调都必须独立处理。这就是为什么你必须有纪律地考虑何时以及在哪里应用这些副作用。
- en: 'An alternative approach to error handling is to use a data type that can encode
    errors. We have seen this approach applied with `Await` when `Option` was the
    returned data type. `Option` makes it clear that the computation might fail while
    remaining convenient to use because its transformations (for example, `map`) operate
    on the wrapped value. Unfortunately, `Option` does not allow us to encode the
    error. In this case, it is helpful to use another tool from the Scalaz library
    called disjunction. Disjunction is conceptually similar to `Either`, which can
    be used to represent one of two possible types. Disjunction is different from `Either`
    because its operations are right-biased. Let''s take a look at a simple example
    to illustrate this idea:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理的另一种方法是使用可以编码错误的数据类型。我们已经在`Option`作为返回数据类型时看到了这种方法的应用。`Option`使得计算可能失败这一点很清楚，同时使用起来也很方便，因为它的转换（例如，`map`）操作在包装值上。不幸的是，`Option`不允许我们编码错误。在这种情况下，使用Scalaz库中的另一个工具——析取（disjunction）是有帮助的。析取在概念上类似于`Either`，可以用来表示两种可能类型之一。析取与`Either`的不同之处在于它的操作是右偏的。让我们通过一个简单的例子来说明这个想法：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `\/` is the shorthand symbol used by Scalaz to represent a disjunction.
    In this example, a right disjunction is created by wrapping the one integer literal.
    This disjunction either has the `Throwable` value or the `Int` value, and it is
    analogous to `Either[Throwable, Int]`. In contrast to `Either`, the `map` transformation
    operates on the right side of the disjunction. In this example, `map` accepts
    an `Int` value as input because the right side of the disjunction is an `Int`
    value. As disjunction is right-biased, it is a natural fit to represent failure
    and success values. Using the infix notation, it is common to define error handling
    with `Future` as `Future[Throwable \/ T]`. In place of `Throwable`, one can define
    an ADT of possible error types to make error handling explicit. This approach
    is favorable because it enforces handling of failure cases without relying on
    the author to invoke a recovery method. If you are interested to learn more about
    how to use disjunction as a tool for error handling, review Eugene Yokota's excellent
    Scalaz tutorial at [http://eed3si9n.com/learning-scalaz/Either.html](http://eed3si9n.com/learning-scalaz/Either.html).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`\/` 是 Scalaz 用来表示析取的简写符号。在这个例子中，通过将一个整型字面量包裹起来创建了一个右析取。这个析取要么具有 `Throwable`
    值，要么具有 `Int` 值，它与 `Either[Throwable, Int]` 类似。与 `Either` 不同，`map` 转换作用于析取的右侧。在这个例子中，`map`
    接受一个 `Int` 值作为输入，因为析取的右侧是一个 `Int` 值。由于析取是右偏的，它很自然地适合表示失败和成功值。使用中缀表示法，通常使用 `Future`
    来定义错误处理，形式为 `Future[Throwable \/ T]`。代替 `Throwable`，可以定义一个可能的错误类型 ADT 来使错误处理更加明确。这种方法是可取的，因为它强制处理失败情况，而不依赖于作者调用恢复方法。如果您想了解更多关于如何将析取作为错误处理工具的信息，请查看
    Eugene Yokota 的优秀 Scalaz 教程 [http://eed3si9n.com/learning-scalaz/Either.html](http://eed3si9n.com/learning-scalaz/Either.html)。'
- en: Hampering performance through executor submissions
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过执行器提交影响性能
- en: 'As `Future` provides an expressive and easy-to-use API, it is common to perform
    numerous transforms to complete a computation in a large-scale system. Reflecting
    on the order submission web service mentioned in the previous section, you can
    imagine multiple application layers operating on a `Future`. A production-ready
    web service typically composes together multiple layers to service a single request.
    An example request flow may contain the following stages: request deserialization,
    authorization, application service invocation, database lookups and/or third-party
    service callouts, and response translation to a JSON format. If each of these
    stages in the workflow is modeled with a `Future`, then it is common to have five
    or more transformations to handle a single request.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Future` 提供了一个表达性强且易于使用的 API，在大型系统中执行计算时，通常会对它进行多次转换。回顾前一小节中提到的订单提交 web 服务，您可以想象多个应用层在
    `Future` 上操作。一个生产就绪的 web 服务通常将多个层组合起来以服务单个请求。一个示例请求流程可能包含以下阶段：请求反序列化、授权、应用服务调用、数据库查找和/或第三方服务调用，以及将响应转换为
    JSON 格式。如果在工作流程中的每个阶段都使用 `Future` 来建模，那么处理单个请求通常需要五个或更多的转换。
- en: Decomposing your software system into small areas of responsibility in a way
    that is similar to the preceding example is a good engineering practice to support
    testing in isolation and improving maintainability. However, this approach to
    software design comes with a performance cost when working with `Future`. As we
    have seen through our example usage, nearly all transforms on a `Future` require
    submitting work to an `Executor`. In our example workflow, most stages in the
    transformation are small. In this scenario, the overhead of submitting work to
    the executor dominates the execution time of the computation. If the order submission
    web service services numerous customers with stringent throughput and latency
    requirements, then it is possible that engineering practices focusing on testability
    and maintainability will result in poorly performing software.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的软件系统分解成与前面示例类似的小责任区域是一种良好的工程实践，这有助于支持独立测试和改进可维护性。然而，当与 `Future` 一起工作时，这种软件设计方法会带来性能成本。正如我们通过示例使用所看到的那样，几乎所有的
    `Future` 转换都需要提交工作到 `Executor`。在我们的示例工作流程中，转换的大多数阶段都很小。在这种情况下，提交工作到执行器的开销主导了计算的执行时间。如果订单提交
    web 服务需要处理大量具有严格吞吐量和延迟要求的客户，那么专注于可测试性和可维护性的工程实践可能会导致性能不佳的软件。
- en: '![Hampering performance through executor submissions](img/B05368_06_01.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![通过执行器提交影响性能](img/B05368_06_01.jpg)'
- en: If you consider the preceding diagram, you can see a thread pool with four threads
    being used to apply transforms to a `Future`. Each transform is submitted to the
    pool and there is a chance that a different thread is picked for the computation.
    This diagram visualizes how multiple small transforms may hamper performance due
    to the overhead of `Executor` submissions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑前面的图示，你可以看到一个线程池正在使用四个线程来对一个`Future`应用转换。每个转换都会提交到池中，并且有可能会选择不同的线程来进行计算。这个图示展示了多个小的转换可能会因为`Executor`提交的开销而影响性能。
- en: 'Just how large is the overhead of `Executor` submissions? This is the motivating
    question to write a benchmark to quantify the overhead of submitting work to an `Executor`.
    The benchmark focuses on adding 1 to an integer N-times in two ways. One approach
    is to perform the addition operation within a single `Future`, while the second
    approach is to perform each addition operation with a new `Future` transformation.
    The latter approach is a proxy for the stages of order submission request processing
    that uses multiple `Future` transformations in a larger software system. Performing
    integer addition is the proxy operation because it is an extremely cheap computation,
    which means that the execution time will be dominated by `Executor` submissions.
    The benchmarks look like the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`提交的开销究竟有多大？这是编写基准测试以量化提交工作到`Executor`开销的动机问题。这个基准测试关注以两种方式对整数N次加1。一种方法是在单个`Future`内执行加法操作，而第二种方法是用一个新的`Future`转换执行每个加法操作。后一种方法是一个代理，用于表示在更大的软件系统中使用多个`Future`转换的顺序提交请求处理阶段。执行整数加法是一个代理操作，因为它是一种极其低廉的计算，这意味着执行时间将由`Executor`提交主导。基准测试如下所示：'
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`TransformFutureState` allows the number of operations to be parameterized.
    `manyTransforms` represents each addition operation using a `map` transformation
    that involves submitting work to an `Executor`. `oneTransform` performs all addition
    operations using a single `Executor` submission via `Future.apply`. In this controlled
    test, `Await.result` is used as a blocking mechanism to await the completion of
    the computation. The results of running this test on a two-core machine with five
    transformations and ten transformations can be seen in the following table:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformFutureState`允许对操作数量进行参数化。`manyTransforms`使用涉及提交工作到`Executor`的`map`转换来表示每个加法操作。`oneTransform`通过`Future.apply`使用单个`Executor`提交执行所有加法操作。在这个受控测试中，`Await.result`被用作阻塞机制以等待计算的完成。在具有五个转换和十个转换的具有两个核心的机器上运行此测试的结果可以在以下表格中看到：'
- en: '| **Benchmark** | **Map count** | **Throughput (ops per second)** | **Error
    as percentage of throughput** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **映射计数** | **吞吐量（每秒操作数）** | **错误率（吞吐量的百分比）** |'
- en: '| `manyTransforms` | 5 | 463,614.88 | ± 1.10 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `manyTransforms` | 5 | 463,614.88 | ± 1.10 |'
- en: '| `oneTransform` | 5 | 412,675.70 | ± 0.81 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `oneTransform` | 5 | 412,675.70 | ± 0.81 |'
- en: '| `manyTransforms` | 10 | 118,743.55 | ± 2.34 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `manyTransforms` | 10 | 118,743.55 | ± 2.34 |'
- en: '| `oneTransform` | 10 | 316,175.79 | ± 1.79 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `oneTransform` | 10 | 316,175.79 | ± 1.79 |'
- en: While both scenarios yield comparable results with five transformations, we
    can see a clear difference with ten transforms being applied. This benchmark makes
    it clear that `Executor` submissions can dominate performance. Although the cost
    can be high, our advice to you is to model your system without considering this
    cost up-front. In our experience, it is easier to rework a well-modeled system
    for performance improvements than it is to extend or to rework a poorly-modeled
    but performant system. For this reason, we advise against going to great lengths
    to group `Executor` submissions when attempting to put together the initial version
    of a complex system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当两种场景都使用五个转换时，它们会产生可比较的结果，但当我们应用十个转换时，我们可以看到明显的差异。这个基准测试清楚地表明`Executor`提交可能会主导性能。尽管成本可能很高，但我们的建议是，在系统建模时不要一开始就考虑这个成本。根据我们的经验，重新设计一个良好建模的系统以改进性能比扩展或重新设计一个性能良好但建模不佳的系统要容易得多。因此，我们建议在尝试构建复杂系统的初始版本时，不要过分努力地分组`Executor`提交。
- en: Once you have a good design in place, the first step is to benchmark and to
    profile in order to identify whether `Executor` submissions are the bottleneck.
    In the event that you discover that your style of `Future` usage is causing performance
    bottlenecks, there are several courses of action you should consider.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个良好的设计，第一步就是进行基准测试和性能分析，以确定`Executor`提交是否是瓶颈。如果你发现你的`Future`使用方式导致了性能瓶颈，那么你应该考虑几个行动方案。
- en: The lowest cost development option is to replace unnecessarily costly `Future`
    creation with the use of `Future.success` or `Future.failure`. The order submission
    web service took advantage of these factory methods to lift values into a `Future`.
    As the value is already computed, these factory methods avoid submitting any tasks
    to the `Executor` that are referenced by the provided `ExecutionContext`. Replacing
    usages of `Future.apply` with either `Future.successful` or `Future.failure` when
    the value is already computed can yield cost savings.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 开发成本最低的选项是用`Future.success`或`Future.failure`替换不必要的昂贵的`Future`创建。订单提交Web服务利用了这些工厂方法将值提升到`Future`中。由于值已经计算，这些工厂方法避免了向由提供的`ExecutionContext`引用的任务提交任何任务。当值已经计算时，用`Future.successful`或`Future.failure`替换`Future.apply`的使用可以节省成本。
- en: A more expensive alternative in terms of development effort is to rework your
    implementation to group together `Future` transformations in a way similar to `manyTransforms`.
    This tactic involves reviewing each application layer to determine whether transforms
    within a single layer can be combined. If possible, we recommend that you avoid
    merging transformations across application layers (for example, between request
    deserialization or authorization and application service processing) because this
    weakens your model and increases maintenance cost.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发努力的角度来看，一个更昂贵的替代方案是对你的实现进行重构，以将`Future`转换组合在一起，类似于`manyTransforms`。这种策略涉及审查每个应用程序层，以确定单个层内的转换是否可以合并。如果可能的话，我们建议你避免跨应用程序层合并转换（例如，在请求反序列化或授权与应用程序服务处理之间），因为这会削弱你的模型并增加维护成本。
- en: If neither of these options produces acceptable performance, then it may be
    worthwhile to discuss with the product owners the option of addressing the performance
    issue with hardware. As your system's design has not been compromised and it reflects
    solid engineering practices, then it likely can be horizontally scaled or clustered.
    Depending on the state tracked by your system, this option might be possible without
    additional development work. Perhaps product owners value a system that can be
    easily maintained and extended more than performance. If this is the case, adding
    scale to your system may be a viable way forward.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些选项中的任何一个都不能产生可接受的性能，那么与产品所有者讨论使用硬件解决性能问题的选项可能是有价值的。由于你的系统设计没有受损，并且反映了稳健的工程实践，因此它很可能可以进行横向扩展或集群化。根据你的系统跟踪的状态，这个选项可能不需要额外的开发工作。也许产品所有者更重视一个易于维护和扩展的系统，而不是性能。如果是这样，给你的系统增加规模可能是一个可行的前进方式。
- en: Provided that you are unable to buy your way out of the performance challenge,
    then there are three additional possibilities. One option is to investigate an
    alternative to `Future`, named `Task`. This construct, which is provided by the
    Scalaz library, allows computations to be performed with fewer `Executor` submissions.
    This option involves significant development because the `Future` data type will
    need to be replaced throughout the application with `Task`. We will explore `Task`
    at the end of this chapter and investigate the performance benefits that it can
    provide.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你无法通过购买方式摆脱性能挑战，那么还有三种额外的可能性。一个选择是调查`Future`的替代方案，名为`Task`。这个由Scalaz库提供的结构允许以更少的`Executor`提交来执行计算。这个选项需要重大的开发工作，因为需要在整个应用程序中将`Future`数据类型替换为`Task`。我们将在本章末尾探讨`Task`，并研究它可能提供的性能优势。
- en: Independent of using `Task`, it can be useful to review your application's model
    to critically question whether or not there is unnecessary work being done on
    the critical path. As we saw with MVT's reporting infrastructure and the introduction
    of stream processing, it is sometimes possible to rethink a design to improve
    performance. Like the introduction of `Task`, reconsidering your system's architecture
    is a large-scale change. The last resort option is to merge application layers
    in order to support grouping `Future` transformations. We advise against exercising
    this option, unless all other suggestions have failed. This option results in
    a code base that is more difficult to reason about because concerns are no longer
    separated. In the short-run, you may reap performance benefits, but in our experience,
    these benefits are outweighed in the long-run by the cost of maintaining and extending
    such a system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是使用`Task`还是不使用`Task`，审查你的应用程序模型以批判性地质疑是否在关键路径上执行了不必要的操作都是有用的。正如我们在MVT的报表基础设施和引入流处理中看到的那样，有时重新思考设计可以提高性能。像`Task`的引入一样，重新考虑你的系统架构是一个大规模的变更。最后的手段是合并应用程序层以支持`Future`转换的分组。我们建议不要采取这个选项，除非所有其他建议都失败了。这个选项会导致代码库更难以推理，因为关注点不再分离。短期内，你可能会获得性能上的好处，但根据我们的经验，这些好处在长期内被维护和扩展这样一个系统的成本所抵消。
- en: Handling blocking calls and callbacks
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理阻塞调用和回调
- en: As described in the first part of this chapter, the `Future` API provides an
    elegant way to write concurrent programs. As it is considered a bad practice to
    block on a `Future`, it is not unusual to see `Future` being widely used across
    an entire code base. However, it is unlikely that your system is only composed
    of your own code. Most real-world applications leverage existing libraries and
    third-party software to avoid re-implementing existing solutions to some common
    problems (such as data encoding and decoding, communication over HTTP, database
    drivers, and so on). Unfortunately, not all libraries use the future API, and
    it may become a challenge to gracefully integrate them into your system. In this
    section, we will examine some common pitfalls that you may encounter and mention
    possible workarounds.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章第一部分所述，`Future` API提供了一种优雅的方式来编写并发程序。由于在`Future`上阻塞被认为是一种不好的做法，因此在整个代码库中广泛使用`Future`并不罕见。然而，你的系统可能不仅仅由你自己的代码组成。大多数现实世界的应用程序利用现有的库和第三方软件来避免重新实现一些常见问题的现有解决方案（如数据编码和解码、通过HTTP进行通信、数据库驱动程序等）。不幸的是，并非所有库都使用`Future`
    API，将它们优雅地集成到你的系统中可能成为一个挑战。在本节中，我们将检查你可能会遇到的一些常见陷阱，并提及可能的解决方案。
- en: ExecutionContext and blocking calls
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ExecutionContext`和阻塞调用'
- en: 'While working on the backtester, you noticed that one module of the code is
    used to load some historical buy orders from a relational database. Since you
    started rewriting the application to take advantage of `Future`, the module API
    is fully asynchronous:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发回测器时，你注意到代码中的一个模块被用来从一个关系型数据库中加载一些历史买入订单。由于你开始重写应用程序以利用`Future`，该模块API是完全异步的：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, after profiling the application, you noticed that this part of the
    code performs quite poorly. You attempted to increase the database connection
    count, first doubling it, then tripling it, both without success. Attempting to
    understand the cause of the problem, you look at all the locations where the method
    is called, and you noticed the following pattern:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在分析应用程序后，你注意到这部分代码的性能相当差。你尝试增加数据库连接数，首先将其翻倍，然后将其增加到三倍，但都没有成功。为了理解问题的原因，你查看所有调用该方法的位置，并注意到以下模式：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All the callers are importing the global `ExecutionContext` to be implicitly
    used by the method. The default thread pool is backed by a `ForkJoinPool`, and
    it is sized based on the available cores on the machine. As such, it is CPU-bound
    and designed to handle nonblocking, CPU intensive operations. This is a good choice
    for applications that do not perform blocking calls. However, if your application
    runs blocking calls asynchronously (that is, in a `Future` execution), relying
    on the default `ExecutionContext` will most likely quickly degrade performance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有调用者都导入全局的`ExecutionContext`以隐式地由方法使用。默认线程池由`ForkJoinPool`支持，其大小基于机器上的可用核心数。因此，它是CPU密集型的，旨在处理非阻塞、CPU密集型操作。这对于不执行阻塞调用的应用程序来说是一个不错的选择。然而，如果你的应用程序以异步方式（即在`Future`执行中）运行阻塞调用，依赖于默认的`ExecutionContext`很可能会迅速降低性能。
- en: Asynchronous versus nonblocking
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步与非阻塞的比较
- en: Before going further, we want to clarify some of the terms used in this section.
    Nonblocking can be a confusing term in the context of concurrency. When using
    `Future`, we perform asynchronous operations, meaning that we start a computation so it
    can proceed with the flow of the program. The computation is executed in the background
    and will eventually yield a result. This behavior is sometimes called nonblocking,
    meaning that the API call returns immediately. However, blocking and nonblocking
    most often refer to I/O operations and how they are performed, especially how
    the thread that is performing the operation is used. For example, writing a sequence
    of bytes to a local file can be a blocking operation because the thread calling `write`
    will have to wait (block) until the I/O operation is completed. When using nonblocking
    constructs, such as the ones provided in the `java.nio` package, it is possible
    to perform I/O operations that will be executed without blocking a thread.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们想要澄清本节中使用的一些术语。在并发的情况下，“非阻塞”可能是一个令人困惑的术语。当使用`Future`时，我们执行异步操作，这意味着我们开始一个计算过程，以便它可以与程序的流程一起进行。计算在后台执行，最终将产生一个结果。这种行为有时被称为非阻塞，意味着API调用立即返回。然而，阻塞和非阻塞通常指的是I/O操作及其执行方式，特别是执行操作的线程的使用方式。例如，将一系列字节写入本地文件可能是一个阻塞操作，因为调用`write`的线程将不得不等待（阻塞）直到I/O操作完成。当使用非阻塞构造，如`java.nio`包中提供的那样，可以执行不会阻塞线程的I/O操作。
- en: 'It is possible to implement an API with a combination of the following behaviors:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以实现一个具有以下行为的API组合：
- en: '| **API characteristics** | **Returns** | **Blocks a thread?** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **API特性** | **返回** | **会阻塞线程吗？** |'
- en: '| Synchronous/blocking | At the end of the computation | Yes, the calling thread
    executes the operation |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 同步/阻塞 | 计算结束时 | 是的，调用线程执行操作 |'
- en: '| Asynchronous/blocking | Immediately | Yes, this blocks a thread from a dedicated
    pool |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 异步/阻塞 | 立即 | 是的，这会阻塞来自专用池的线程 |'
- en: '| Asynchronous/nonblocking | Immediately | No, the thread is freed-up while
    the blocking operation is performed |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 异步/非阻塞 | 立即 | 不，在执行阻塞操作时线程被释放 |'
- en: Using a dedicated ExecutionContext to block calls
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用专用`ExecutionContext`来阻塞调用
- en: 'Clearly, our problem is that we are using the `ExecutionContext` global to
    perform blocking calls. We are querying a relational database, and most JDBC drivers
    are implemented to perform blocking calls. The pooled threads call the driver
    and block while waiting for the query and the response to travel over the network,
    making them unusable by other computations. An option is to create a dedicated `ExecutionContext`
    to execute the `Future`, including blocking operations. This `ExecutionContext`
    is sized with more threads in the anticipation that they will be blocked when
    performing their computation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的问题是我们在全局使用`ExecutionContext`来执行阻塞调用。我们正在查询关系型数据库，大多数JDBC驱动程序都是实现为执行阻塞调用。池化线程调用驱动程序，并在等待查询和响应通过网络传输时阻塞，这使得它们无法被其他计算使用。一个选项是创建一个专门的`ExecutionContext`来执行`Future`，包括阻塞操作。这个`ExecutionContext`的大小是根据预期它们在执行计算时会阻塞来设定的：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first benefit is that we have more threads available, meaning that we can
    initiate more queries concurrently. The second benefit is that the other asynchronous
    computations performed in our system are done on a separate pool (for example,
    the global context), and they will avoid starvation since no threads are blocked.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个好处是我们有更多的线程可用，这意味着我们可以并发地发起更多查询。第二个好处是我们系统中执行的其他异步计算是在一个单独的池（例如，全局上下文）中完成的，并且它们将避免饥饿，因为没有线程被阻塞。
- en: 'We write a short benchmark to evaluate the performance of our new system. In
    this example, we use a mock implementation of `findBuyOrders` to simulate querying
    the database:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个简短的基准测试来评估我们新系统的性能。在这个例子中，我们使用`findBuyOrders`的模拟实现来模拟查询数据库：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We pass the `ExecutionContext` as a parameter. Our benchmark compares the throughput
    of an application relying on the default `ExecutionContext` and one using an `ExecutionContext`,
    which is dedicated to blocking operations; the latter is initialized with twenty
    times more threads. The results are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`ExecutionContext`作为参数传递。我们的基准测试比较了一个依赖于默认`ExecutionContext`的应用程序和一个使用`ExecutionContext`（后者专门用于阻塞操作）的应用程序的吞吐量；后者初始化了二十倍更多的线程。结果如下：
- en: '| **Benchmark** | **Operation count** | **Throughput (ops per second)** | **Error
    as percentage of throughput** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **操作计数** | **吞吐量（每秒操作数）** | **错误率（吞吐量的百分比）** |'
- en: '| `withDefaultContext` | 10 | 3.21 | ± 0.65 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `withDefaultContext` | 10 | 3.21 | ± 0.65 |'
- en: '| `withDedicatedContext` | 10 | 9.34 | ± 1.00 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `withDedicatedContext` | 10 | 9.34 | ± 1.00 |'
- en: '| `withDefaultContext` | 1,000 | 0.04 | ± 2.56 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `withDefaultContext` | 1,000 | 0.04 | ± 2.56 |'
- en: '| `withDedicatedContext` | 1,000 | 0.73 | ± 0.41 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `withDedicatedContext` | 1,000 | 0.73 | ± 0.41 |'
- en: The results confirm our intuition. The dedicated pool is bigger than the default
    context in anticipation of threads being blocked waiting for a blocking operation
    to finish. Having more threads available, it is able to start more blocking operations
    concurrently, thus achieving a better throughput. Creating a dedicated `ExecutionContext`
    is a good way to isolate blocking operations and make sure that they do not slow
    down CPU-bound computations. When designing your dedicated thread pool, make sure
    that you understand how the underlying resources (for example, connections, file
    handles, and so on) are used. For example, when dealing with a relational database,
    we know that one connection can only be used to perform one query at a time. A
    good rule of thumb is to create a thread pool with as many threads as the amount
    of connections that you want to open with your database server. If the number
    of connections is less than the thread count, some threads may be waiting for
    a connection and remain unused. If you have more connections than threads, the
    opposite situation may occur and some connections may remain unused.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证实了我们的直觉。专用池比默认上下文大，这是为了预期线程在等待阻塞操作完成时被阻塞。由于有更多的线程可用，它能够并发地启动更多的阻塞操作，从而实现更好的吞吐量。创建一个专门的
    `ExecutionContext` 是隔离阻塞操作并确保它们不会减慢 CPU 密集型计算的好方法。在设计你的专用线程池时，确保你理解底层资源（例如，连接、文件句柄等）的使用方式。例如，当处理关系型数据库时，我们知道一个连接一次只能用于执行一个查询。一个很好的经验法则是创建一个线程池，其线程数与你想与数据库服务器打开的连接数相同。如果连接数少于线程数，一些线程可能会等待连接而保持未使用。如果你有比线程更多的连接，相反的情况可能会发生，一些连接可能会保持未使用。
- en: 'A good strategy is to rely on the type system and the compiler to ensure that
    you are not mixing up different `ExecutionContext` instances. Unless the type
    is differentiated, you may accidentally use a CPU-bound context when performing
    blocking operations. You can create your own `DatabaseOperationsExecutionContext`
    type wrapping an `ExecutionContext`, and accept this type when creating your database
    access module. Another idea is to use tagged types that are provided by Scalaz.
    Refer to [Chapter 3](ch03.html "Chapter 3. Unleashing Scala Performance"), *Unleashing
    Scala Performance*, for a refresher on tagged types. Consider the following example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的策略是依赖类型系统和编译器来确保你没有混淆不同的 `ExecutionContext` 实例。除非类型被区分，否则你可能会在执行阻塞操作时意外地使用
    CPU 密集型上下文。你可以创建自己的 `DatabaseOperationsExecutionContext` 类型，它包装了一个 `ExecutionContext`，并在创建数据库访问模块时接受此类型。另一个想法是使用
    Scalaz 提供的标记类型。参考 [第 3 章](ch03.html "第 3 章。释放 Scala 性能")，*释放 Scala 性能*，以复习标记类型。考虑以下示例：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using a tagged types for our `ExecutionContext` gives us additional safety.
    It is easy to make a mistake in the `main` method while wiring up your application,
    and inadvertently use the wrong `ExecutionContext` when creating your modules.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标记类型为我们的 `ExecutionContext` 提供了额外的安全性。在连接应用程序时，在 `main` 方法中犯错是很常见的，并且可能会在创建模块时无意中使用错误的
    `ExecutionContext`。
- en: Using the blocking construct
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用阻塞结构
- en: 'The standard library provides a `blocking` construct that can be used to signal
    blocking operations executed inside a `Future`. We can modify our previous example
    to leverage `blocking` instead of a dedicated `ExecutionContext`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了一个 `blocking` 构造，可以用来指示在 `Future` 内部执行的阻塞操作。我们可以修改之前的示例，利用 `blocking`
    而不是专门的 `ExecutionContext`：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that in the preceding implementation, we use the default `ExecutionContext`
    to execute the `Future`. The `blocking` construct is used to notify the `ExecutionContext`
    that a computation is blocking. This allows the `ExecutionContext` to adapt its
    execution strategy. For example, the default global `ExecutionContext` will temporarily
    increase the number of threads in the pool when it performs a computation wrapped
    with `blocking`. A dedicated thread is created in the pool to execute the blocking
    computation, making sure that the rest of the pool remains available for CPU-bound
    computations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的实现中，我们使用默认的`ExecutionContext`来执行`Future`。`blocking`构造用于通知`ExecutionContext`一个计算正在阻塞。这允许`ExecutionContext`调整其执行策略。例如，默认的全局`ExecutionContext`在执行被`blocking`包装的计算时，会临时增加线程池中的线程数量。线程池中会创建一个专用线程来执行阻塞计算，确保其余的线程池仍然可用于CPU密集型计算。
- en: You should use `blocking` cautiously. The `blocking` construct is merely used
    to notify `ExecutionContext` that the wrapped operation is blocking. It is the
    responsibility of the `ExecutionContext` to implement a specific behavior or ignore
    the notification. The only implementation that actually takes it into account
    and implements special behavior is the default `ExecutionContext` global.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 应谨慎使用`blocking`。`blocking`构造仅用于通知`ExecutionContext`被包装的操作正在阻塞。实现特定行为或忽略通知是`ExecutionContext`的责任。唯一真正考虑并实现特殊行为的实现是默认的全局`ExecutionContext`。
- en: Translating callbacks with Promise
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Promise翻译回调
- en: While `Future` is the main construct of the `scala.concurrent` API, another
    useful abstraction is `Promise`. `Promise` is another way to create and complete
    a `Future`. The `Future` is a read-only container for a result that will eventually
    be computed. `Promise` is a handle that allows you to explicitly set the value
    contained in a `Future`. A `Promise` is always associated with only one `Future`,
    and this `Future` is specific to the `Promise`. It is possible to complete the
    `Future` of a `Promise` with a successful result, or an exception (which will
    fail the `Future`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Future`是`scala.concurrent` API的主要构造，但另一个有用的抽象是`Promise`。`Promise`是创建和完成`Future`的另一种方式。`Future`是一个只读容器，用于存储最终将被计算的结果。`Promise`是一个句柄，允许你显式设置`Future`中包含的值。`Promise`始终与一个`Future`相关联，并且这个`Future`是特定于`Promise`的。可以使用成功结果或异常（这将使`Future`失败）来完成`Promise`的`Future`。
- en: 'Let''s look at a short example to understand how `Promise` works:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简短的例子来了解`Promise`是如何工作的：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A `Promise` can only be used once to complete its associated `Future`, either
    with a success or a failure. Attempting to complete an already realized `Promise`
    will throw an exception, unless you use `trySuccess`, `tryFailure`, or `tryComplete`.
    These three methods will attempt to complete the `Future` that is linked to the `Promise`
    and return `true` if the `Future` was completed or `false` if it was already previously
    completed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`只能用于一次完成其关联的`Future`，无论是成功还是失败。尝试完成已经实现的`Promise`将抛出异常，除非你使用`trySuccess`、`tryFailure`或`tryComplete`。这三个方法将尝试完成与`Promise`链接的`Future`，如果`Future`已完成则返回`true`，如果之前已经完成则返回`false`。'
- en: At this point, you may be wondering in what circumstances you would really take
    advantage of `Promise`. Especially considering the previous example, would it
    be simpler to return the internal `Future` instead of relying on a `Promise`?
    Keep in mind that the preceding snippet is meant to demonstrate a simple workflow
    that illustrates the `Promise` API. However, we understand your question. In practice,
    we see two common use cases for `Promise`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道在什么情况下你会真正利用`Promise`。特别是考虑到先前的例子，返回内部`Future`而不是依赖于`Promise`会简单一些吗？请记住，先前的代码片段旨在演示一个简单的流程，该流程说明了`Promise`
    API。然而，我们理解你的问题。在实践中，我们看到了两种常见的`Promise`使用场景。
- en: From callbacks to a Future-based API
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从回调到基于Future的API
- en: 'The first use case is to turn a callback-based API into a `Future`-based API.
    Imagine having to integrate with a third-party product, such as the proprietary
    database that MVT obtained recently by purchasing usage licenses. This is a great
    product that is used to store historical quotes per timestamp and ticker. It comes
    with a library to be used by a client application. Unfortunately, this library,
    while fully asynchronous and nonblocking, is callback-oriented, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用例是将基于回调的API转换为基于`Future`的API。想象一下，你需要与第三方产品集成，比如MVT最近通过购买使用许可证获得的专有数据库。这是一个非常好的产品，用于按时间戳和股票代码存储历史报价。它附带了一个客户端应用程序使用的库。不幸的是，这个库虽然完全异步和非阻塞，但却是基于回调的，如下所示：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There is no doubt that the client works fine; after all, MVT paid a lot of
    money for it! However, it will not be easy to integrate it with your own application.
    Your program relies heavily on `Future`. This is where `Promise` can help us,
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，客户端工作得很好；毕竟，MVT为此支付了一大笔钱！然而，将其与自己的应用程序集成可能并不容易。你的程序严重依赖于`Future`。这就是`Promise`能帮到我们的地方，如下所示：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Thanks to the `Promise` abstraction, we are able to return a `Future`. We simply
    use `success` and `failure` in the respective callbacks to call the proprietary
    client. This use case often arises in production when you have to integrate with
    a Java library. Even though Java 8 introduced a significant improvement to the
    Java concurrent package, most Java libraries still rely on callbacks to implement
    asynchronous behavior. Using `Promise`, you can fully leverage the existing Java
    ecosystem in your program without giving up on Scala support for concurrent programming.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`Promise`抽象，我们能够返回一个`Future`。我们只需在相应的回调中使用`success`和`failure`来调用专有客户端。这种用例在生产环境中很常见，当你需要与Java库集成时。尽管Java
    8对Java并发包进行了重大改进，但大多数Java库仍然依赖于回调来实现异步行为。使用`Promise`，你可以在程序中充分利用现有的Java生态系统，同时不放弃Scala对并发编程的支持。
- en: Combining Future with Promise
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Future与Promise结合
- en: '`Promise` can also be used to combine instances of `Future`. For example, let''s
    add a timeout capability to `Future`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`也可以用来组合`Future`的实例。例如，让我们给`Future`添加一个超时功能：'
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our method takes a by-name `Future` (that is, a `Future` that has not started
    its execution yet) as well as the timeout value to apply. In the method, we use
    a `Promise` as a container for the result. We start an internal `Future` that
    will block for the timeout duration before failing the `Promise` with an `Exception`.
    We also start the main `Future` and register a callback to complete the `Promise`
    with the result of the computation. The first of the two `Futures` that terminates
    will effectively complete the `Promise` with its result. Note that in this example,
    we use `tryFailure` and `tryCompleteWith`. It is likely that both `Futures` will
    eventually terminate and try to complete the `Promise`. We are only interested
    in the result of the first one that completes, but we also want to avoid throwing
    an `Exception` when attempting to complete an already realized `Promise`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法接受一个按名称传递的`Future`（即尚未开始执行执行的`Future`）以及要应用的超时值。在方法中，我们使用`Promise`作为结果的容器。我们启动一个内部的`Future`，在超时期间会阻塞，然后使用`Exception`失败`Promise`。我们还启动主要的`Future`并注册一个回调，以计算的结果完成`Promise`。这两个`Future`中的第一个终止的将有效地使用其结果完成`Promise`。请注意，在这个例子中，我们使用了`tryFailure`和`tryCompleteWith`。很可能这两个`Future`最终都会终止并尝试完成`Promise`。我们只对第一个完成的`Future`的结果感兴趣，但我们还希望避免在尝试完成已经实现的`Promise`时抛出`Exception`。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example is a naive implementation of a timeout. It is mostly a
    prototype used to demonstrate how `Promise` can be leveraged to enriched `Future`
    and implement complex behavior. A more realistic implementation would probably
    involve a `ScheduledExecutorService`. A `ScheduledExecutorService` allows you
    to schedule the execution of a computation after a certain delay. It allows us
    to schedule the call to `tryFailure` without blocking a thread with a call to `Thread.sleep`.
    We made the choice to keep this example simple and not introduce a new type, but
    we encourage you to research this implementation of `ScheduledExecutorService`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子是一个超时的简单实现。它主要是一个原型，用于展示如何利用`Promise`来丰富`Future`并实现复杂的行为。一个更现实的实现可能需要使用`ScheduledExecutorService`。`ScheduledExecutorService`允许你在一定延迟后调度一个计算的执行。它允许我们调度对`tryFailure`的调用，而不需要通过`Thread.sleep`调用阻塞线程。我们选择保持这个例子简单，并没有引入新的类型，但我们鼓励你研究这种`ScheduledExecutorService`的实现。
- en: In practice, you may occasionally have to write your own custom combinators
    for `Future`. `Promise` is a useful abstraction in your toolbox if you need to
    do this. However, `Future` and its companion object already provide a number of
    built-in combinators and methods that you should try to leverage as much as possible.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可能会偶尔需要编写自己的自定义组合器 `Future`。如果你需要这样做，`Promise` 是你的工具箱中的一个有用的抽象。然而，`Future`
    及其伴随对象已经提供了一系列内置的组合器和方法，你应该尽可能多地利用它们。
- en: Tasked with more backtest performance improvements
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承担更多回测性能改进的任务
- en: Discovering `Future` and adopting an asynchronous mindset helped you better
    utilize your computing resources to test multiple strategies and tickers faster.
    You improved performance by treating the backtest as a black box. Without changing
    the implementation of the backtest, there were straightforward performance wins.
    Identifying logical sequences of transformations as candidates for concurrency
    is a good strategy to apply when considering how to speed up your software.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 发现 `Future` 并采用异步思维有助于你更好地利用计算资源，更快地测试多个策略和股票代码。你通过将回测视为黑盒来提高性能。在不改变回测实现的情况下，可以轻松获得性能提升。将转换的逻辑序列识别为并发的候选策略是一个在考虑如何加快软件速度时可以应用的不错策略。
- en: Let's extend this idea to a smaller logical unit of processing within the backtester.
    A backtest exercises a strategy for a ticker across a time period. After speaking
    with Dave, you discover that MVT does not maintain positions overnight. At the
    end of each trading day, MVT trading systems mitigate risk by ensuring that all
    stock positions are liquidated. This is done to defend against volatile overnight
    price moves after the market closes, which the company is unable to react to by
    trading. As positions are not held overnight, each trading day can be simulated
    independently of the previous trading day. Returning to our asynchronous mindset,
    this insight implies that trading day simulations can be performed concurrently.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个想法扩展到回测器内部更小的逻辑处理单元。回测针对某个股票代码在一段时间内进行策略测试。在与Dave交谈后，你发现MVT不会在夜间保持仓位。在交易日的结束时，MVT交易系统通过确保所有股票仓位被清算来降低风险。这样做是为了防御市场关闭后价格波动的风险，公司无法通过交易来应对。由于仓位不在夜间持有，每个交易日可以独立于前一个交易日进行模拟。回到我们的异步思维模式，这个洞察意味着可以并行执行交易日模拟。
- en: Before jumping into the implementation using `Future`, we will share an alternative
    abstraction, named `Task`, which is provided by the Scalaz library. `Task` provides
    compelling usage reasons for our proposed backtest modifications. We introduce `Task`
    next, provided that you are up to the task!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `Future` 进行实现之前，我们将分享一个名为 `Task` 的替代抽象，这是由 Scalaz 库提供的。`Task` 为我们提出的回测修改提供了有说服力的使用理由。我们将在你准备好接受任务的情况下介绍
    `Task`！
- en: Introducing Scalaz Task
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Scalaz Task
- en: 'Scalaz `Task` provides a different approach to achieve concurrency. Although `Task`
    can be used in a way that mimics `Future`, there are important conceptual differences
    between these two abstractions. `Task` allows fine-grained control over asynchronous
    execution, which provides performance benefits. `Task` maintains referential transparency
    as well, which provides stronger reasoning abilities. Referential transparency
    is a property of expressions that are side-effect free. To better understand this
    principle, consider the following simple `sum` method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Scalaz `Task` 提供了一种不同的方法来实现并发。尽管 `Task` 可以以模仿 `Future` 的方式使用，但这两个抽象之间存在着重要的概念差异。`Task`
    允许对异步执行进行细粒度控制，这提供了性能优势。`Task` 还保持了引用透明性，这提供了更强的推理能力。引用透明性是表达式无副作用的属性。为了更好地理解这个原则，考虑以下简单的
    `sum` 方法：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Imagine that we are performing two summations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在执行两个求和操作：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As `sum` is side-effect free, we can replace `sum(2, 3)` with its result, as
    follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `sum` 是无副作用的，我们可以将其替换为以下结果：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This expression will always evaluate to 9, which satisfies referential transparency.
    Now imagine a twist in the implementation of `sum`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式将始终评估为 9，这满足了引用透明性。现在想象一下 `sum` 实现中的一个转折：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, `sum` includes a side-effect of writing to a database that breaks referential
    transparency. We can no longer perform the replacement of `sum(2, 3)` with the
    value 9 because then the database will not be updated. Referential transparency
    is a concept at the heart of the functional programming paradigm because it provides
    strong reasoning guarantees. The Haskell wiki provides additional commentary and
    examples worth reviewing at [https://wiki.haskell.org/Referential_transparency](https://wiki.haskell.org/Referential_transparency).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`sum` 包含一个写入数据库的副作用，这破坏了引用透明性。我们不能再用值 9 替换 `sum(2, 3)`，因为这样数据库就不会更新了。引用透明性是函数式编程范式核心的概念，因为它提供了强大的推理保证。Haskell
    维基提供了额外的评论和值得回顾的示例，请参阅 [https://wiki.haskell.org/Referential_transparency](https://wiki.haskell.org/Referential_transparency)。
- en: Let's take a look at common `Task` API usage to better understand how `Task`
    works.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看常见的 `Task` API 使用方法，以更好地理解 `Task` 的工作原理。
- en: Creating and executing Task
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和执行 Task
- en: 'The methods provided by the `Task` companion object are the main entry points
    to the API, and the best ways to create an instance of `Task`. The `Task.apply`
    is the first method to inspect. It takes a computation returning an instance of `A`
    (that is, a by-name parameter of the `A` type) and an implicit `ExecutorService`
    to run the computation. Contrary to `Future`, which uses `ExecutionContext` as
    an abstraction for a thread pool, `Task` uses the `ExecutorService`, which is
    defined in the Java standard library:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 伴生对象提供的方法是访问 API 的主要入口点，以及创建 `Task` 实例的最佳方式。`Task.apply` 是第一个需要检查的方法。它接受一个返回
    `A` 实例的计算（即 `A` 类型的按名参数）和一个隐式的 `ExecutorService` 来运行计算。与使用 `ExecutionContext`
    作为线程池抽象的 `Future` 不同，`Task` 使用的是定义在 Java 标准库中的 `ExecutorService`：'
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first thing that you may have noticed is that, even though we instantiated
    a new `Task`, nothing is printed on the screen. This is an important difference
    when comparing `Task` and `Future`; while `Future` is eagerly evaluated, a `Task`
    is not computed until you explicitly ask for it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到的是，尽管我们实例化了一个新的 `Task`，但屏幕上没有打印任何内容。这是比较 `Task` 和 `Future` 时的一个重要区别；虽然
    `Future` 是急切评估的，但 `Task` 不会计算，直到你明确请求它：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding example calls the `unsafePerformSync` instance method to execute
    the task. We can see the `println` as well as the returned result `42`. Note that `unsafePerformSync`
    is an unsafe call. If the computation throws an exception, the exception is re-thrown
    by `unsafePerformSync`. To avoid this side-effect, calling `unsafePerformSyncAttempt`
    is preferred. The `unsafePerformSyncAttempt` instance catches the exception and
    has a return type of `Throwable \/ A`, which allows you to cleanly handle the
    failure case. Note that when creating the task `t`, we did not provide an `ExecutorService`.
    By default, `apply` creates a `Task` to be run on `DefaultExecutorService`, a
    fixed thread pool for which the size is based on the count of available processors
    on the machine using a default parameter. The `DefaultExecutorService` is analogous
    to the global `ExecutionContext` that we explored with `Future`. It is CPU-bound
    and sized based on the available cores on the machine. We can also supply a different `ExecutorService`
    at creation time:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例调用 `unsafePerformSync` 实例方法来执行任务。我们可以看到 `println` 以及返回的结果 `42`。请注意，`unsafePerformSync`
    是一个不安全的调用。如果计算抛出异常，异常将由 `unsafePerformSync` 重新抛出。为了避免这种副作用，调用 `unsafePerformSyncAttempt`
    是首选的。`unsafePerformSyncAttempt` 实例捕获异常，并具有 `Throwable \/ A` 的返回类型，这允许你干净地处理失败情况。请注意，在创建任务
    `t` 时，我们没有提供 `ExecutorService`。默认情况下，`apply` 创建一个将在 `DefaultExecutorService` 上运行的
    `Task`，这是一个固定大小的线程池，其大小基于机器上可用的处理器数量，使用默认参数。`DefaultExecutorService` 与我们用 `Future`
    探索的全局 `ExecutionContext` 类似。它是 CPU 密集型，大小基于机器上的可用核心数。我们也可以在创建时提供一个不同的 `ExecutorService`：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The output shows that the `Task` is executed on the supplied `ExecutorService`,
    not on the main thread.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示 `Task` 是在提供的 `ExecutorService` 上执行的，而不是在主线程上。
- en: 'Speaking of `Task` execution, let''s perform a little experiment. We will create
    an instance of `Task` and call `unsafePerformSync` twice in a row:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到 `Task` 执行，让我们进行一个小实验。我们将创建一个 `Task` 实例，并连续两次调用 `unsafePerformSync`：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We observe that `Starting task` prints after each call to `unsafePerformSync`.
    This indicates that the full computation is executed each time we call `unsafePerformSync`.
    That is another difference with `Future`. While a `Future` memorizes its result
    after the computation, a `Task` performs its computation each time we call `unsafePerformSync`.
    In other words, `Task` is referentially transparent and, therefore, closer to
    the functional programming paradigm than `Future`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到每次调用`unsafePerformSync`后都会打印出“开始任务”。这表明每次我们调用`unsafePerformSync`时都会执行完整的计算。这与`Future`的另一个区别。当`Future`在计算后记住其结果时，`Task`每次我们调用`unsafePerformSync`都会执行其计算。换句话说，`Task`是引用透明的，因此比`Future`更接近函数式编程范式。
- en: Asynchronous behavior
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步行为
- en: 'Like `Future`, it is possible (and even recommended) to use `Task` in an asynchronous
    way. An instance of `Task` can be executed asynchronously by calling `unsafePerformAsync`.
    This method takes a callback of type`(Throwable \/ A) => Unit` that is called
    at the end of the computation. Observe the following snippet:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Future`一样，异步使用`Task`是可能的（甚至推荐）。可以通过调用`unsafePerformAsync`来异步执行`Task`的实例。此方法接受一个类型为`(Throwable
    \/ A) => Unit`的回调，在计算结束时被调用。观察以下片段：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We create our`Task`, and add a `Thread.sleep` to simulate an expensive computation.
    We call `unsafePerformAsync` and use a simple callback to print the answer (or
    an exception, if the computation fails). We call `createAndRunTask` and observe
    the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建我们的`Task`，并添加一个`Thread.sleep`来模拟昂贵的计算。我们调用`unsafePerformAsync`并使用一个简单的回调来打印答案（如果计算失败，则为异常）。我们调用`createAndRunTask`并观察以下输出：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can see that our last statement, "Waiting for the answer" was printed first.
    This is because `unsafePerformAsync` returns immediately. We can see the statement
    from our computation, as well as the answer printed in our callback. This method
    is a rough equivalent to `onComplete`, which is defined on Scala's `Future`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的最后一个语句“等待答案”首先被打印出来。这是因为`unsafePerformAsync`立即返回。我们可以看到我们的计算中的语句，以及回调中打印的答案。这种方法是Scala的`Future`上定义的`onComplete`的粗略等价物。
- en: 'Another useful method provided by the companion object of `Task` is `async`.
    Remember how we previously used `Promise` to turn a callback-based API into an
    API returning an instance of `Future`? It is possible to achieve the same goal
    with `Task`; that is, we can turn a callback-based API into a more monadic API
    returning a `Task`, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`的伴生对象还提供了一个有用的方法`async`。记得我们之前是如何使用`Promise`将基于回调的API转换为返回`Future`实例的API的吗？使用`Task`也可以实现相同的目标；也就是说，我们可以将基于回调的API转换为返回`Task`的更单调的API，如下所示：'
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Evaluating this method in the REPL yields the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中评估此方法会产生以下结果：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our `doCoolThingsToTask` method uses `Task.async` to create a `Task` instance
    from a callback-based API that is defined in `CallbackAPI`. The `Task.async` can
    even be used to turn a Scala `Future` into a Scalaz `Task`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`doCoolThingsToTask`方法使用`Task.async`从定义在`CallbackAPI`中的基于回调的API创建一个`Task`实例。`Task.async`甚至可以将Scala的`Future`转换为Scalaz的`Task`：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that we have to supply an `ExecutionContext` to be able to call `onComplete`
    on `Future`. This is due to `Future` eager evaluation. Almost all methods that
    are defined on `Future` will submit a computation to a thread pool immediately.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须提供一个`ExecutionContext`才能在`Future`上调用`onComplete`。这是由于`Future`的急切评估。几乎所有在`Future`上定义的方法都会立即将计算提交到线程池。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is also possible to convert a `Task` to a `Future`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将`Task`转换为`Future`：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The execution model
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行模型
- en: 'Understanding the `Task` execution model requires understanding the Scalaz `Future`
    execution model because `Task` composes a Scalaz `Future` and adds error handling.
    This is visible from the definition of `Task`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`Task`执行模型需要理解Scalaz的`Future`执行模型，因为`Task`组合了一个Scalaz的`Future`并添加了错误处理。这可以从`Task`的定义中看出：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this definition, `Future` is the not the Scala standard library version,
    but instead this is an alternative version that is provided by Scalaz. The Scalaz `Future`
    decouples defining transformations from execution strategy, providing us with
    fine-grained control over `Executor` submissions. Scalaz `Future` accomplishes
    this by defining itself as a trampolining computation. Trampolining is a technique
    that describes a computation as a discrete series of chunks that are run using
    constant space. To dive into the details of how a trampoline works, we recommend
    reading Runar Bjarnason's paper, *Stackless Scala With Free Monads*, available
    at [http://blog.higher-order.com/assets/trampolines.pdf](http://blog.higher-order.com/assets/trampolines.pdf).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义中，`Future`不是Scala标准库版本，而是Scalaz提供的替代版本。Scalaz的`Future`将定义转换与执行策略解耦，为我们提供了对`Executor`提交的精细控制。Scalaz的`Future`通过将自己定义为跳跃计算来实现这一点。跳跃是一种将计算描述为一系列离散块的技术，这些块使用恒定空间运行。要深入了解跳跃如何工作，我们建议阅读Runar
    Bjarnason的论文《无栈Scala与Free Monads》，可在[http://blog.higher-order.com/assets/trampolines.pdf](http://blog.higher-order.com/assets/trampolines.pdf)找到。
- en: '`Task` builds on Scalaz `Future` by providing error handling with the Scalaz `\/`
    disjunction. `Task` is the description of a computation. Transformations add to
    the description of the computation that will eventually be executed by a thread
    pool. To begin evaluation, a `Task` must be explicitly started. This behavior
    is interesting because when a `Task` is finally executed, we can limit computation
    execution to a single thread. This improves thread reuse and reduces context switching.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`基于Scalaz的`Future`，通过Scalaz的`\/`析取来提供错误处理。`Task`是对计算的描述。转换添加到最终将由线程池执行的计算的描述中。为了开始评估，必须显式启动`Task`。这种行为很有趣，因为当`Task`最终执行时，我们可以将计算执行限制在单个线程上。这提高了线程重用并减少了上下文切换。'
- en: '![The execution model](img/B05368_06_02.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![执行模型](img/B05368_06_02.jpg)'
- en: In the preceding diagram, we see various calls to `apply` and `map`. These calls
    are merely modifying the definition of the task to be performed. It is only when
    we call `unsafePerformAsync` that the computation is realized in a different thread.
    Note that all the transforms are applied by the same thread.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们看到对`apply`和`map`的各种调用。这些调用仅仅是在修改要执行的任务的定义。只有在调用`unsafePerformAsync`时，计算才在不同的线程中实现。注意，所有转换都是由同一个线程应用的。
- en: 'We can exercise `Future` and `Task` performance in a short microbenchmark comparing
    their throughput based on the transform (for example, `map` and `flatMap`), and
    the count of transformations applied. A snippet of the benchmark can be found,
    as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过比较基于转换（例如，`map`和`flatMap`）的吞吐量和应用的转换数量来在短微基准测试中锻炼`Future`和`Task`的性能。基准测试的片段如下：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Both scenarios run similar computations. We create an initial instance of `Future`
    or `Task` containing 0, and we apply several consecutive `map` operations to add
    1 to the accumulator. Two other scenarios performed the same computation but with `flatMap`
    instead. The results for `flatMap` are displayed in the following table:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 两种场景运行类似的计算。我们创建一个包含0的初始`Future`或`Task`实例，然后应用几个连续的`map`操作来将1添加到累加器中。另外两种场景执行了相同的计算，但使用的是`flatMap`。`flatMap`的结果显示在下表中：
- en: '| **Benchmark** | **Operation count** | **Throughput (ops per second)** | **Error
    as percentage of throughput** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **操作计数** | **吞吐量（每秒操作数）** | **错误率（吞吐量的百分比）** |'
- en: '| `flatMapWithFuture` | 5 | 41,602.33 | ± 0.69 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `flatMapWithFuture` | 5 | 41,602.33 | ± 0.69 |'
- en: '| `flatMapWithTask` | 5 | 59,478.50 | ± 2.14 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `flatMapWithTask` | 5 | 59,478.50 | ± 2.14 |'
- en: '| `flatMapWithFuture` | 10 | 31,738.80 | ± 0.52 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `flatMapWithFuture` | 10 | 31,738.80 | ± 0.52 |'
- en: '| `flatMapWithTask` | 10 | 43,811.15 | ± 0.47 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `flatMapWithTask` | 10 | 43,811.15 | ± 0.47 |'
- en: '| `flatMapWithFuture` | 100 | 4,390.11 | ± 1.91 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `flatMapWithFuture` | 100 | 4,390.11 | ± 1.91 |'
- en: '| `flatMapWithTask` | 100 | 13,415.30 | ± 0.60 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `flatMapWithTask` | 100 | 13,415.30 | ± 0.60 |'
- en: 'The results for `map` operations can be found in the following table:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`操作的结果可以在下表中找到：'
- en: '| **Benchmark** | **Operation count** | **Throughput (ops per second)** | **Error
    as percentage of throughput** |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **操作计数** | **吞吐量（每秒操作数）** | **错误率（吞吐量的百分比）** |'
- en: '| `mapWithFuture` | 5 | 45,710.02 | ± 1.30 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `mapWithFuture` | 5 | 45,710.02 | ± 1.30 |'
- en: '| `mapWithTask` | 5 | 93,666.73 | ± 0.57 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `mapWithTask` | 5 | 93,666.73 | ± 0.57 |'
- en: '| `mapWithFuture` | 10 | 44,860.44 | ± 1.80 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `mapWithFuture` | 10 | 44,860.44 | ± 1.80 |'
- en: '| `mapWithTask` | 10 | 91,932.14 | ± 0.88 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `mapWithTask` | 10 | 91,932.14 | ± 0.88 |'
- en: '| `mapWithFuture` | 100 | 19,974.24 | ± 0.55 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `mapWithFuture` | 100 | 19,974.24 | ± 0.55 |'
- en: '| `mapWithTask` | 100 | 46,288.17 | ± 0.46 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `mapWithTask` | 100 | 46,288.17 | ± 0.46 |'
- en: This benchmark highlights the performance gain due to the different execution
    model of `Task`. Even for a small number of transforms, the throughput is better
    with a deferred evaluation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基准突出了由于`Task`的不同执行模型所带来的性能提升。即使对于少量转换，延迟评估的吞吐量也更好。
- en: Modeling trading day simulations with Task
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Task`模拟交易日
- en: 'Equipped with our understanding of `Task`, we now have the knowledge necessary
    to add concurrency to the execution of a single backtest run. You may recall that
    we discovered from Dave that MVT closes its positions at the end of each trading
    day. This insight allows us to model each trading day independently. Let''s familiarize
    ourselves with the current implementation by beginning with the model, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 借助于我们对`Task`的理解，我们现在拥有了添加单个回测执行并发性的必要知识。你可能还记得，我们从Dave那里了解到MVT在每个交易日结束时关闭其头寸。这个洞察力使我们能够独立地模拟每个交易日。让我们从以下模型开始，熟悉当前的实现：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The profit-and-loss is the output of each simulated trading day. `PnL` provides
    a convenient method to add together two `PnL` instances, which can be used to
    sum the simulation `PnL` across multiple trading days. Once all the trading days
    are simulated, a `BacktestPerformanceSummary` is created to capture the simulation
    profit-and-loss. For our work on the backtester, we will use a `Thread.sleep`
    to simulate computationally expensive work in place of an actual decisioning strategy.
    The length of the sleep is parameterized by `DecisionDelayMillis`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 利润和损失是每个模拟交易日的输出。`PnL`提供了一个方便的方法来合并两个`PnL`实例，这可以用来汇总多个交易日的模拟`PnL`。一旦所有交易日都进行了模拟，就创建一个`BacktestPerformanceSummary`来捕获模拟的利润和损失。对于我们在回测器上的工作，我们将使用`Thread.sleep`来模拟计算密集型工作，而不是实际决策策略。睡眠的长度由`DecisionDelayMillis`参数化。
- en: 'We show a simplified version of the backtester that shows how `DecisionDelayMillis`
    is used to simulate a trading day, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了回测器的简化版本，展示了如何使用`DecisionDelayMillis`来模拟一个交易日，如下所示：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The original backtest displays how a list of days is simulated in a synchronous
    fashion. For reproducibility, we substitute a constant profit-and-loss of $10
    in place of a dynamic value. This backtest ignores the application of a ticker
    and a strategy to focus on the core of our dilemma: How can we use `Task` to add
    concurrency to a backtest?'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 原始回测显示了如何以同步方式模拟一系列日期。为了确保可重复性，我们用固定的$10利润和损失值代替动态值。这个回测忽略了应用股票行情和策略，以关注我们困境的核心：我们如何使用`Task`为回测添加并发性？
- en: 'From our examples, we saw that `Task` introduces concurrency through submission
    of multiple `Task`s to an `ExecutorService` and by performing the side-effect
    of running a `Task` with `unsafePerformAsync` to avoid a blocking wait for the
    result. As a first step, let''s implement a version of the backtest that uses `Task`
    without introducing concurrency:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的示例中，我们看到了`Task`通过向`ExecutorService`提交多个`Task`以及通过使用`unsafePerformAsync`运行`Task`以避免阻塞等待结果来引入并发性。作为第一步，让我们实现一个不引入并发性的回测`Task`版本：
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This implementation changes the return type to `Task[BacktestPerformanceSummary]`.
    Since the `Task` is not run, referential transparency is maintained within this
    method. Each trading day is simulated using `Task.delay`. `delay` is a lazy variant
    of `Task.now` that defers evaluation of the provided value. Let''s look at the
    following signature to confirm:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现将返回类型更改为`Task[BacktestPerformanceSummary]`。由于`Task`没有运行，因此在这个方法中保持了引用透明性。每个交易日都使用`Task.delay`进行模拟。`delay`是`Task.now`的惰性变体，它延迟评估提供的值。让我们查看以下签名以确认：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If we had instead used `Task.now` in place of `Task.delay`, the sleep (that
    is, the simulation) would have taken effect before running `Task`. We also see
    the use of another new capability, `Task.gatherUnordered`. `gatherUnordered` is
    useful when you wish to make the following transformation:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`Task.now`代替`Task.delay`，则睡眠（即模拟）将在运行`Task`之前生效。我们还看到了另一种新功能`Task.gatherUnordered`的使用。`gatherUnordered`在你希望进行以下转换时很有用：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Although `List` is used here, this relationship exists for any `Seq`. `gatherUnordered`
    provides a way to take a collection of `Task` and instead operate on a single `Task`
    that wraps a collection of the underlying type. Let''s look at the following signature
    to make our understanding more concrete:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里使用了`List`，但这种关系适用于任何`Seq`。`gatherUnordered`提供了一种方式，可以取一个`Task`集合，而不是操作一个包含底层类型集合的单个`Task`。让我们看看以下签名，以使我们的理解更加具体：
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This signature closely matches the previous function that we defined with the
    addition of an optional Boolean parameter. When `exceptionCancels` is set to `true`,
    any pending `Task` will not be evaluated. `gatherUnordered` allows us to merge
    together the results of each trading day's profit-and-loss and return a single `Task`
    wrapping `BacktestPerformanceSummary`. The Scala `Future` companion object provides
    an analogous method, named `sequence`, that performs the same operation on a sequence
    of `Future`s.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名与之前我们定义的函数非常相似，只是增加了一个可选的布尔参数。当`exceptionCancels`设置为`true`时，任何挂起的`Task`将不会被评估。`gatherUnordered`允许我们将每个交易日的盈亏结果合并在一起，并返回一个包含`BacktestPerformanceSummary`的单个`Task`。Scala的`Future`伴随对象提供了一个类似的方法，名为`sequence`，它对一系列`Future`执行相同的操作。
- en: 'This is a functioning implementation of the backtest, but it does not add concurrency
    to the simulation of historical trading days. For our next iteration, we take
    advantage of a new part of the `Task` API, `Task.fork`. Let''s see how it is used,
    and then we will explain how it works:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个功能性的回测实现，但它并没有将并发添加到历史交易日的模拟中。在我们的下一个迭代中，我们利用了`Task` API的新部分，`Task.fork`。让我们看看它是如何使用的，然后我们将解释它是如何工作的：
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This implementation gathers trading day `PnL` in the same way as before, but
    instead this uses a combination of `Task.fork` and `Task.now` to simulate the
    trading day. Let''s look at the signature of `Task.fork` to understand how runtime
    behavior changes:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现以与之前相同的方式收集交易日的`PnL`，但这次它使用`Task.fork`和`Task.now`的组合来模拟交易日。让我们看看`Task.fork`的签名，以了解运行时行为是如何变化的：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`fork` accepts a `Task` as a by-name parameter and an implicit `ExecutorService`
    that defaults to the CPU-bound executor. The signature shows that `fork` submits
    the provided `Task` to `pool` in order to fork the computation into a different
    thread. `fork` is an explicit way to control concurrency with `Task`. Conceptually, `fork`
    is analogous to any `Future` transformation (for example, `map`) that involves
    submission to an executor. As `fork` lazily evaluates its argument, `Task.now`
    can be used to lift the trading day''s profit-and-loss into a `Task`. With this
    implementation, the `Task` that represents each trading day is submitted to an
    executor. If we assume 30 trading days are being backtested and the computer used
    has two cores, then this implementation allows each core to simulate 15 trading
    days instead of a single core simulating 30 days.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork`接受一个`Task`作为按名参数和一个隐式的`ExecutorService`，默认为CPU密集型执行器。签名显示`fork`将提供的`Task`提交到`pool`，以便将计算分叉到不同的线程。`fork`是使用`Task`显式控制并发的明确方式。从概念上讲，`fork`类似于任何涉及提交到执行器的`Future`转换（例如，`map`）。由于`fork`是惰性评估其参数的，因此可以使用`Task.now`将交易日的盈亏提升到`Task`。在这个实现中，代表每个交易日的`Task`被提交到执行器。如果我们假设正在回测30个交易日，并且使用的计算机有两个核心，那么这个实现允许每个核心模拟15个交易日，而不是单个核心模拟30天。'
- en: 'As we saw in earlier benchmarks, submitting a high volume of small computations
    to an executor is expensive. As we have explicit control over concurrency with
    `Task` using `fork`, we can improve our performance by optimizing the frequency
    of executor submissions. In our third attempt, we take advantage of knowing the
    number of trading days to be simulated to control executor submissions. The implementation
    now looks like the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在早期的基准测试中看到的，向执行器提交大量的小型计算是昂贵的。通过使用`Task`的`fork`来显式控制并发，我们可以通过优化执行器提交的频率来提高我们的性能。在我们的第三次尝试中，我们利用了已知要模拟的交易日数量来控制执行器提交。现在的实现看起来如下：
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This implementation returns to representing the simulation of each trading day
    without any concurrency using `Task.delay`. In contrast to the previous implementations,
    the list of trading day simulation `Task`s is divided into chunks of 30 using `sliding`.
    Each chunk of 30 `Task`s is wrapped with an invocation of `Task.fork` to execute
    concurrently. This approach allows us to balance the benefits of concurrency with
    the overhead of executor submissions.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现返回到使用`Task.delay`表示每个交易日模拟而不使用任何并发。与之前的实现相比，交易日模拟`Task`的列表被使用`sliding`分成30个块。每个30个`Task`的块被一个`Task.fork`调用来并发执行。这种方法允许我们平衡并发的收益和执行器提交的开销。
- en: 'Of these three implementations, which is most performant? The answer is not
    straightforward because it depends on the number of simulation trading days and
    the computational cost of simulating a trading day. To better understand the tradeoffs,
    we write a microbenchmark that tests each of the three backtest implementations.
    We show the state required to run the benchmark, as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个实现中，哪个性能最好？答案并不直接，因为它取决于模拟交易日的数量和模拟交易日的计算成本。为了更好地理解权衡，我们编写了一个微基准测试来测试这三个回测实现。我们展示了运行基准测试所需的状态，如下所示：
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This benchmark allows us to sweep different backtest interval and decision
    delay combinations. Using a `daysWithin` method, which is omitted from the snippet,
    a count representing the number of months is converted into the list of simulation
    trading days. We display the implementation of only one benchmark because the
    other two are identical, as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此基准测试允许我们扫描不同的回测间隔和决策延迟组合。使用一个`daysWithin`方法（在代码片段中省略），将表示月份数量的计数转换为模拟交易日的列表。我们只显示一个基准测试的实现，因为其他两个是相同的，如下所示：
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To accurately time how long it takes to complete the `Task` computation, we
    start the computation with the blocking `unsafePerformSync` method. This is a
    rare example where it is acceptable to make a blocking call without a timeout.
    In this controlled test, we are confident that all invocations will return. For
    this test, we sweep the the month count, leaving the decision delay fixed at 1
    ms. Running this benchmark on a machine with four cores produces the following
    results:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准确测量完成`Task`计算所需的时间，我们使用阻塞的`unsafePerformSync`方法开始计算。这是一个罕见的例子，在没有超时的情况下进行阻塞调用是可以接受的。在这个受控测试中，我们确信所有调用都将返回。对于这个测试，我们扫描月份计数，将决策延迟固定在1毫秒。在具有四个核心的机器上运行此基准测试产生以下结果：
- en: '| **Benchmark** | **Months** | **Decision delay milliseconds** | **Throughput
    (ops per second)** | **Error as percentage of throughput** |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **Benchmark** | **Months** | **Decision delay milliseconds** | **Throughput
    (ops per second)** | **Error as percentage of throughput** |'
- en: '| `withoutConcurrency` | 1 | 1 | 25.96 | ± 0.46 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `withoutConcurrency` | 1 | 1 | 25.96 | ± 0.46 |'
- en: '| `withAllForked` | 1 | 1 | 104.89 | ± 0.36 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `withAllForked` | 1 | 1 | 104.89 | ± 0.36 |'
- en: '| `withBatchedForking` | 1 | 1 | 27.71 | ± 0.70 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `withBatchedForking` | 1 | 1 | 27.71 | ± 0.70 |'
- en: '| `withoutConcurrency` | 12 | 1 | 1.96 | ± 0.41 |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `withoutConcurrency` | 12 | 1 | 1.96 | ± 0.41 |'
- en: '| `withAllForked` | 12 | 1 | 7.25 | ± 0.22 |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `withAllForked` | 12 | 1 | 7.25 | ± 0.22 |'
- en: '| `withBatchedForking` | 12 | 1 | 8.60 | ± 0.49 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `withBatchedForking` | 12 | 1 | 8.60 | ± 0.49 |'
- en: '| `withoutConcurrency` | 24 | 1 | 0.76 | ± 2.09 |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `withoutConcurrency` | 24 | 1 | 0.76 | ± 2.09 |'
- en: '| `withAllForked` | 24 | 1 | 1.98 | ± 1.46 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `withAllForked` | 24 | 1 | 1.98 | ± 1.46 |'
- en: '| `WithBatchedForking` | 24 | 1 | 4.32 | ± 0.88 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `WithBatchedForking` | 24 | 1 | 4.32 | ± 0.88 |'
- en: The results make the tradeoff between the overhead and the benefits of batching
    clearer. Batching is a clear win as the number of months increase with a short
    1 ms computational delay. Consider the scenario of backtesting 24 months with
    a 1 ms decision delay. Assuming 30-day months, there are 720 trading days to simulate.
    Split into batches of 30, there are 24 invocations of `fork` instead of 720\.
    The overhead for splitting the `Task` into batches, and gathering each batch's
    results, is overshadowed by the order of magnitude of fewer executor submissions.
    Our explicit control over forking yielded a doubling of throughput in this scenario.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果使得在批处理的开销和收益之间的权衡更加清晰。随着月份的增加，批处理在1毫秒的计算延迟下是一个明显的胜利。考虑24个月回测且决策延迟为1毫秒的情况。假设每月30天，有720个交易日需要模拟。将这些交易日分成30个批次，就有24次`fork`调用而不是720次。将`Task`分割成批次的开销以及收集每个批次结果的成本，被更少的执行器提交的数量级所掩盖。我们对分叉的显式控制在这个场景中使得吞吐量翻倍。
- en: As the number of months decreases, the overhead of creating `Task` batches becomes
    a dominating factor. In a 12-month backtest, there are 360 trading days, yielding
    12 batches. Here, batching yields about a 20% throughput improvement over forking
    all `Task`. Cutting the number of trading days in half from the 24-month test
    reduced the performance advantage by more than half. In the worst-case scenario,
    when there is one month to simulate, the batching strategy fails to take to advantage
    of all the cores on the machine. In this scenario, one batch is created, leaving
    CPU resources underutilized.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 随着月份的减少，创建`任务`批次的开销成为一个主导因素。在一个12个月的回测中，有360个交易日，产生12个批次。在这里，批处理相对于所有`任务`的分支操作提高了大约20%的吞吐量。将24个月测试中的交易日数量减半，性能优势减少了超过一半。在最坏的情况下，当只有一个月需要模拟时，批处理策略未能充分利用机器上的所有核心。在这种情况下，只创建了一个批次，导致CPU资源利用率低下。
- en: Wrapping up the backtester
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结回测器
- en: As we have seen, there are a number of variables at play here. Accounting for
    computational costs, the number of available cores, the expected number of `Task`
    executor submissions, and batching overhead can be challenging. To extend our
    work, we can investigate a more dynamic batching strategy that takes better advantage
    of CPU resources with smaller backtest intervals. Using this benchmark, we got
    a taste for the additional tools that `Task` provides, and how explicit control
    of executor submissions can affect throughput.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这里有许多变量在发挥作用。考虑到计算成本、可用核心数、预期的`任务`执行者提交次数和批处理开销可能会很具挑战性。为了扩展我们的工作，我们可以研究一种更动态的批处理策略，该策略通过更小的回测间隔更好地利用CPU资源。使用这个基准，我们尝到了`任务`提供的额外工具的滋味，以及显式控制执行者提交如何影响吞吐量。
- en: The insights that we gleaned by working on the backtester can be applied to
    larger-scale software systems as well. We focused on analyzing results with a
    short 1 ms decision delay. As the cost of executing each `Task` increases (for
    example, 10 ms decision delay), diminishing marginal performance improvements
    are gained from batching. This is because the cost of executor submissions becomes
    overshadowed by the cost of the computation. While 1 ms appears to be a small
    amount of time, there are a potentially surprising number of computations that
    can be completed in this time frame. Consider that a throughput of 1,000 operations
    per second translates to 1 operation per millisecond. Reflecting on benchmarks
    that we have performed in our earlier efforts and through your own work, you can
    find numerous examples where we worked with operations that have a throughput
    higher than 1 operation per millisecond. The takeaway from this thought experiment
    is a large number of use cases fit within the definition of a short computation
    (that is, 1 ms), which means that there are a significant number of opportunities
    to optimize concurrency through the judicious use of `fork`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对回测器的工作，我们获得的见解也可以应用于更大规模的软件系统。我们专注于分析具有短1毫秒决策延迟的结果。随着执行每个`任务`的成本增加（例如，10毫秒决策延迟），批处理带来的边际性能提升逐渐减少。这是因为执行者提交的成本被计算成本所掩盖。虽然1毫秒看起来是一小段时间，但在这一时间框架内可以完成大量计算。考虑到我们在早期努力中以及通过你的工作所进行的基准测试，你可以找到许多我们处理吞吐量高于每毫秒1次操作的例子。从这个思想实验中得出的结论是，大量用例符合短计算（即1毫秒）的定义，这意味着有大量机会通过谨慎使用`fork`来优化并发性。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The backtester is a prime candidate for batching because the amount of work,
    namely the number of days to simulate, is known at the start of processing. In
    a stream processing environment, the amount of work is unknown. For example, consider
    the order book receiving events on-the-fly. How can you implement batching in
    a streaming environment?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 回测器是批处理的首选候选者，因为工作负载，即需要模拟的天数，在处理开始时是已知的。在流处理环境中，工作负载是未知的。例如，考虑接收实时事件的订单簿。如何在流处理环境中实现批处理？
- en: We hope that backtester provided an illustrative example to give you a feeling
    for `Task`. There are additional tools that are provided by `Task` that we did
    not explore. We invite you to read the documentation for `Task` in the Scalaz
    library. In the book entitled, *Functional Programming in Scala*, written by two
    Scalaz contributors, Rúnar Bjarnason and Paul Chiusano, there is an excellent
    chapter describing the implementation of a simplified version of Scalaz `Task`.
    This is a great resource to understand the design of the API.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望提供的回测器能够提供一个有说明性的例子，让你对 `Task` 有一个感觉。`Task` 还提供了其他一些我们没有探索的工具。我们邀请你阅读 Scalaz
    库中 `Task` 的文档。在由 Scalaz 贡献者 Rúnar Bjarnason 和 Paul Chiusano 撰写的《Scala 函数式编程》一书中，有一个出色的章节描述了
    Scalaz `Task` 的简化版本实现。这是一个了解 API 设计的绝佳资源。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered how to harness the power of asynchronous programming
    with the Scala standard library using `Future` and `Promise`. We improved MVT
    backtesting performance by introducing concurrency to improve runtime performance
    and discovered how `Promise` can be used to extend `Future`. Along the way, we
    investigated the shortcomings of `Future` along with the techniques to mitigate
    these shortcomings. We also explored an alternative to `Future` with Scalaz `Task`,
    which provides compelling performance benefits while retaining referential transparency.
    Using what you have learned in this chapter, you can take full advantage of multicore
    hardware using Scala to scale your software systems and deliver higher throughput.
    In our final chapter, [Chapter 7](ch07.html "Chapter 7. Architecting for Performance"), *Architecting
    for Performance*, we explore a set of advanced functional programming techniques
    and concepts to enrich your functional programming toolbox.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了如何利用 Scala 标准库中的 `Future` 和 `Promise` 来掌握异步编程的力量。我们通过引入并发来提高运行时性能，从而提高了
    MVT 回测的性能，并发现了如何使用 `Promise` 来扩展 `Future`。在这个过程中，我们还研究了 `Future` 的不足之处以及缓解这些不足的技术。我们还探索了
    `Future` 的替代方案——Scalaz 的 `Task`，它提供了令人信服的性能优势，同时保持了引用透明性。利用本章所学，你可以充分利用多核硬件，使用
    Scala 来扩展你的软件系统并提高吞吐量。在我们的最后一章，[第 7 章](ch07.html "第 7 章。针对性能进行架构设计")，*针对性能进行架构设计*中，我们探索了一系列高级函数式编程技术和概念，以丰富你的函数式编程工具箱。
