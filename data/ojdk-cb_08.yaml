- en: Chapter 8. Hacking OpenJDK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 破解OpenJDK
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Setting up the development environment with NetBeans
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetBeans设置开发环境
- en: Working with Mercurial forests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Mercurial森林协同工作
- en: Understanding OpenJDK 6 and 7 incremental builds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解OpenJDK 6和7增量构建
- en: Debugging Java code using NetBeans
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetBeans调试Java代码
- en: Debugging C++ code using NetBeans
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetBeans调试C++代码
- en: Using NetBeans to compile HotSpot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NetBeans编译HotSpot
- en: Using HotSpot dev parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HotSpot开发参数
- en: Adding new intrinsic to HotSpot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向HotSpot添加新的内建函数
- en: Building VisualVM from the source code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码构建VisualVM
- en: Creating a plugin for VisualVM
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为VisualVM创建插件
- en: Getting benefits from the AdoptOpenJDK project
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从AdoptOpenJDK项目中获得收益
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The real beauty of OpenJDK is its open nature, which means that developers can
    not only use it to run an application, but also change it to their needs or contribute
    to its development. The availability of the source code and ease of access to
    it opens huge opportunities to individuals who have special requirements, or just
    want to learn more about the way JVM works internally and want to adapt it for
    any special requirements. This chapter will help you to get into it and provide
    some recipes to make the process of setting up the required development environment
    as easy as possible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OpenJDK真正的美在于其开放性，这意味着开发者不仅可以使用它来运行应用程序，还可以根据需要对其进行更改或为其开发做出贡献。源代码的可用性和易于访问为有特殊要求的人或只是想了解更多关于JVM内部工作方式的人提供了巨大的机会，他们希望将其适应任何特殊要求。本章将帮助您进入这一领域，并提供一些食谱，使设置所需开发环境的过程尽可能简单。
- en: At first, it will cover how to set up the development environment and which
    tools are required to get started. It will cover the IDE setup, and some tweaks
    required to launch JVM and start debugging. The next step is to make changes and
    rebuild the code, and the latter is going to be slightly different from the normal
    build described in [Chapter 5](ch05.html "Chapter 5. Building IcedTea"), *Building
    IcedTea*, [Chapter 6](ch06.html "Chapter 6. Building IcedTea with Other VM Implementations"),
    *Building IcedTea with Other VM Implementations*, and [Chapter 7](ch07.html "Chapter 7. Working
    with WebStart and the Browser Plugin"), *Working with WebStart and the Browser
    Plugin*. The rest of that section dedicated to will be useful techniques which
    can be used to debug changes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它将涵盖如何设置开发环境以及启动所需的工具。它将涵盖IDE设置，以及启动JVM和开始调试所需的调整。下一步是更改代码并重新构建，后者将略不同于第5章中描述的正常构建，即[第5章](ch05.html
    "第5章. 构建 IcedTea")，*构建IcedTea*，[第6章](ch06.html "第6章. 使用其他虚拟机实现构建IcedTea")，*使用其他虚拟机实现构建IcedTea*，和[第7章](ch07.html
    "第7章. 使用WebStart和浏览器插件")，*使用WebStart和浏览器插件*。该部分剩余的内容将包含一些有用的技术，可用于调试更改。
- en: This chapter assumes that the reader has a reasonable knowledge of C++ and Java.
    Any knowledge of JVM is ideal, as the reader should know what JIT is and how it
    works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设读者对C++和Java有合理的了解。对JVM的了解是理想的，因为读者应该知道JIT是什么以及它是如何工作的。
- en: Most of the recipes in the JIT section are independent and can be executed separately,
    so the reader just can pick what he/she needs and proceed with it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JIT部分的大多数食谱都是独立的，可以单独执行，因此读者只需选择他们需要的部分并继续即可。
- en: Setting up the development environment with NetBeans
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NetBeans设置开发环境
- en: This recipe will cover the steps required to install, run, and set up the project
    in NetBeans IDE. NetBeans is an open source IDE for developing, primarily in Java.
    It also has rich support for C++ and that makes it a good tool for OpenJDK development
    which uses both languages. This recipe uses NetBeans IDE v.7.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将涵盖在NetBeans IDE中安装、运行和设置项目的步骤。NetBeans是一个开源IDE，主要用于Java开发。它还提供了对C++的丰富支持，这使得它成为OpenJDK开发的良好工具，因为OpenJDK使用这两种语言。本食谱使用NetBeans
    IDE v.7。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download the latest version of the NetBeans `All` bundle for your platform from
    [http://www.netbeans.org/downloads](http://www.netbeans.org/downloads). The `All`
    bundle must have C/C++ and Java support in the same IDE. It is also necessary
    to have the OpenJDK code checked out and available on the machine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://www.netbeans.org/downloads](http://www.netbeans.org/downloads)下载适用于您平台的最新NetBeans
    `All`捆绑包。`All`捆绑包必须在同一IDE中具有C/C++和Java支持。还必须在机器上检出并可用OpenJDK代码。
- en: Make sure that everything is set up for the OpenJDK build and it can be executed
    without errors. How to do that is described in [Chapter 2](ch02.html "Chapter 2. Building
    OpenJDK 6"), *Building OpenJDK 6*, [Chapter 3](ch03.html "Chapter 3. Building
    OpenJDK 7"), *Building OpenJDK 7*, and [Chapter 4](ch04.html "Chapter 4. Building
    OpenJDK 8"), *Building OpenJDK 8*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确保OpenJDK构建的设置已经完成，并且可以无错误地执行。如何做到这一点在[第2章](ch02.html "第2章。构建OpenJDK 6")、*构建OpenJDK
    6*、[第3章](ch03.html "第3章。构建OpenJDK 7")、*构建OpenJDK 7*和[第4章](ch04.html "第4章。构建OpenJDK
    8")、*构建OpenJDK 8*中有描述。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will install and configure the NetBeans IDE that is used in the OpenJDK project
    as the standard one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装并配置OpenJDK项目中使用的NetBeans IDE作为标准IDE。
- en: First we need to install the NetBeans IDE. This is a very simple process which
    consists of a few simple steps. Run the downloaded executable and at the bottom
    of the first screen, select the **Customize** button. This will show following
    window:![How to do it...](img/8405OT_08_01.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装NetBeans IDE。这是一个非常简单的过程，包括几个简单的步骤。运行下载的可执行文件，在第一个屏幕的底部，选择**自定义**按钮。这将显示以下窗口：![如何操作...](img/8405OT_08_01.jpg)
- en: Ensure that **Base IDE**, **Java SE**, **C/C++**, and **Features on Demand**
    are selected. The rest are optional and not required to run and debug OpenJDK,
    but there is no harm in installing that functionality.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保已选择**基本IDE**、**Java SE**、**C/C++**和**需求功能**。其余的都是可选的，不是运行和调试OpenJDK所必需的，但安装该功能并无害处。
- en: After the setup, all plugins you should update to the latest version. Updates
    are available via the **Help/Check for updates** menu item.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置完成后，您应该更新所有插件到最新版本。更新可通过**帮助/检查更新**菜单项进行。
- en: When NetBeans is set up, it is required to make a slight change to its configuration.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当NetBeans设置完成后，需要对其配置进行轻微的修改。
- en: 'OpenJDK is a big project and its memory requirements are bigger than the ones
    defined in the default settings. To increase the memory available for IDE:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: OpenJDK是一个大型项目，其内存需求比默认设置中定义的要大。为了增加IDE可用的内存：
- en: Go to the `$HOME/.netbeans/NETBEANS_VERSION/etc` folder (on Windows `$HOME`
    is `%HOMEPATH%`).
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`$HOME/.netbeans/NETBEANS_VERSION/etc`文件夹（在Windows中`$HOME`是`%HOMEPATH%`）。
- en: If the folder doesn't exist, create it.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件夹不存在，请创建它。
- en: Then, if that folder doesn't have the `netbeans.conf` file, copy it from the
    Netbeans installation directory, which is located in the `etc` folder.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果该文件夹中没有`netbeans.conf`文件，请从Netbeans安装目录中复制它，该目录位于`etc`文件夹中。
- en: 'Open the file with any text editor and locate the `netbeans_default_options`
    parameter which it should look similar to this:'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任何文本编辑器打开文件，并定位看起来类似于以下的`netbeans_default_options`参数：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the parameter is located, add `-J-Xmx2g`, or, if that option is already
    present, update it to a value not less than `2G` (2 gigabytes). This will increase
    the memory available to JDK to `2G`. Restart your IDE if it was running before
    in order to apply that change.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当找到参数时，添加`-J-Xmx2g`，或者如果该选项已经存在，更新它到一个不小于`2G`（2千兆字节）的值。这将增加JDK可用的内存到`2G`。如果IDE之前正在运行，请重新启动以应用该更改。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is worth adding that, because of the large memory requirement of Netbeans
    IDE, It's recommended to run it on a system that is capable of providing nothing
    less than 2 GB of memory to the process. Basically, it means that it should be
    a machine with a 64-bit OS and about 4 to 6 GB of RAM.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，由于Netbeans IDE对内存需求较大，建议在能够为进程提供至少2GB内存的系统上运行。基本上，这意味着它应该是一个64位操作系统，并拥有大约4到6GB的RAM。
- en: Now Netbeans IDE is ready for the project to be set up. Run it and go to **File**
    | **New Project** on the dialog box and select **C/C++ Project with Existing Sources**:![How
    to do it...](img/8405OT_08_02.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Netbeans IDE已准备好设置项目。运行它，并在对话框中转到**文件** | **新建项目**，选择**使用现有源文件的C/C++项目**：![如何操作...](img/8405OT_08_02.jpg)
- en: Then press **Next** and, on the following dialog box, select the folder with
    the root of OpenJDK sources:![How to do it...](img/8405OT_08_03.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后按**下一步**，在随后的对话框中，选择OpenJDK源根目录所在的文件夹：![如何操作...](img/8405OT_08_03.jpg)
- en: Tip
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can always obtain your OpenJDK code by typing `hg clone http://hg.openjdk.java.net/jdk6/jdk6
    && ./get_source.sh`
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过输入`hg clone http://hg.openjdk.java.net/jdk6/jdk6 && ./get_source.sh`来获取您的OpenJDK代码。
- en: Press **Finish** and Netbeans will attempt to clean and build the project. Clean,
    most probably, will execute without problems, but build will not work because
    it requires some environment setup, which we will do later on.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **完成** 按钮，Netbeans 将尝试清理和构建项目。清理，很可能会无问题执行，但构建将不会工作，因为它需要一些环境设置，我们将在稍后进行。
- en: After trying to build the project, Netbeans will spend a fair bit of time (minutes)
    scanning sources and building indexes. This would be a good time to have some
    coffee.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在尝试构建项目后，Netbeans 将花费相当多的时间（分钟）扫描源代码和构建索引。这时喝杯咖啡是个不错的选择。
- en: 'The next step is to configure Netbeans to build the project. As already mentioned,
    the build script requires some environment setup. The following is a simple bash
    script which can be used to create an appropriate environment:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是配置 Netbeans 以构建项目。如前所述，构建脚本需要一些环境设置。以下是一个简单的 bash 脚本，可以用来创建适当的环境：
- en: '[PRE1]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the root folder of the OpenJDK source tree, create a file `build.sh` and
    save this script in that folder.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OpenJDK 源树的根目录下创建一个名为 `build.sh` 的文件，并将此脚本保存在该文件夹中。
- en: Then navigate to the **Run** | **Set project configuration** | **Customize**
    menu item and, in the tree on the left-hand side, select **Build** | **Make**.
    There you will see the following dialog:![How to do it...](img/8405OT_08_04.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后导航到 **运行** | **设置项目配置** | **自定义** 菜单项，在左侧的树状结构中，选择 **构建** | **构建**。在那里，您将看到以下对话框：![如何操作...](img/8405OT_08_04.jpg)
- en: As shown in the screenshot, set the **Build Command** and **Clean Command**
    variables to execute your `./build.sh` with the `debug_build` and `clean` commands,
    respectively.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如截图所示，将 **构建命令** 和 **清理命令** 变量设置为执行您的 `./build.sh`，分别使用 `debug_build` 和 `clean`
    命令。
- en: If the `product` version of OpenJDK is required, then just create another configuration
    with `product_build` and the parameter for `build.sh`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要 OpenJDK 的 `product` 版本，那么只需创建另一个配置，包含 `product_build` 和 `build.sh` 的参数。
- en: See also
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Netbeans is not the only available IDE which supports both Java and C++. There
    are other IDEs which are similarly capable. One example is the Eclipse IDE which
    is also a powerful multiplatform IDE written in Java, and has similar functionality.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Netbeans 不是唯一支持 Java 和 C++ 的 IDE。还有其他类似功能的 IDE。一个例子是 Eclipse IDE，它也是一个用 Java
    编写的强大多平台 IDE，并且具有类似的功能。
- en: Working with Mercurial forest
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mercurial forest 进行工作
- en: Mercurial is a cross-platform version control system. It was designed to work
    with big projects and large amounts of code, which undoubtedly are present in
    the OpenJDK project. The OpenJDK official repository is a Mercurial.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Mercurial 是一个跨平台版本控制系统。它被设计用于处理大型项目和大量代码，这在 OpenJDK 项目中无疑是存在的。OpenJDK 的官方仓库是一个
    Mercurial 仓库。
- en: The Forest plugin is the one used for various OpenJDK subprojects to merge and
    coexist. It works with nested Mercurial repositories, which normally are regarded
    as isolated. The main idea is to propagate changes from the root repository to
    the nested ones.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Forest 插件是用于各种 OpenJDK 子项目合并和共存的插件。它与嵌套的 Mercurial 仓库一起工作，这些仓库通常被视为独立的。主要思想是从根仓库传播更改到嵌套的仓库。
- en: The main purpose of it is to allow a developer to work with the code, which
    is a minor part of a full OpenJDK project repository, without needing to make
    any changes to the whole repository (change a revision number, for example).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要目的是允许开发者在不需要对整个仓库（例如更改修订号）进行任何更改的情况下，与代码一起工作，这仅仅是完整 OpenJDK 项目仓库的一个小部分。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First of all, we will need to install Mercurial itself. On Windows it can be
    done by going to the official Mercurial site and downloading it from [http://mercurial.selenic.com/wiki/Download](http://mercurial.selenic.com/wiki/Download).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 Mercurial 本身。在 Windows 上，可以通过访问官方 Mercurial 网站并从 [http://mercurial.selenic.com/wiki/Download](http://mercurial.selenic.com/wiki/Download)
    下载它。
- en: For Linux distributions, there are, usually, Mercurial versions in their official
    repositories.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 发行版，通常在它们的官方仓库中有 Mercurial 版本。
- en: 'For example, on Debian and Debian-inherited distributions, Mercurial installs
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Debian 和 Debian 衍生发行版中，Mercurial 的安装方式如下：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you have any problems with a Mercurial installation, refer to the official
    site or to your Linux distribution resources.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 Mercurial 安装过程中遇到任何问题，请参考官方网站或您的 Linux 发行版资源。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's explain it with a simple, non Java-related example. We will assume that
    a Mercurial instance already exists in the OS. Since Mercurial has a command line
    tool, we will use a command line for everything.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单、非 Java 相关的例子来解释它。我们将假设在 OS 中已经存在一个 Mercurial 实例。由于 Mercurial 有一个命令行工具，我们将使用命令行做所有事情。
- en: 'Let''s create two repositories:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建两个仓库：
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will need to locate the `.hgrc` file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要找到 `.hgrc` 文件：
- en: '[PRE4]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's copy the `forest.py` file from [https://bitbucket.org/gxti/hgforest/src](https://bitbucket.org/gxti/hgforest/src).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 [https://bitbucket.org/gxti/hgforest/src](https://bitbucket.org/gxti/hgforest/src)
    复制 `forest.py` 文件。
- en: 'Then let''s edit your `.hgrc` file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们编辑你的 `.hgrc` 文件：
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We now have a brand new `fclone` command in our repository.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在我们的仓库中有一个全新的 `fclone` 命令。
- en: 'Let''s copy the first repository into the second one:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将第一个仓库复制到第二个仓库中：
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `repo-two` repository isn't an integral part of `repo-one`, it only lays
    inside it.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`repo-two` 仓库不是 `repo-one` 的一个整体部分，它只是位于其中。'
- en: 'Let''s clone a `repo-two` repository and attach `repo-one to it`, using the
    `fclone` command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 `fclone` 命令克隆一个 `repo-two` 仓库并将 `repo-one` 附接到它上：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've just copied `repo-two`, including `repo-two/one`.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚复制了 `repo-two`，包括 `repo-two/one`。
- en: 'Let''s make some changes to `repo-two/hello.txt` and `repo-two/one/hello.txt`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们对 `repo-two/hello.txt` 和 `repo-two/one/hello.txt` 进行一些修改：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will commit each change using a separate command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用单独的命令提交每个更改：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s push a result back to `repo-two`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将结果推回 `repo-two`：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will have two changed files in repo-one.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在 `repo-one` 中有两个更改的文件。
- en: 'Let''s push one of them further to `repo-two`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将其中一个推送到 `repo-two`：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the changes from `repo-two/one` are propagated to `repo-one`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`repo-two/one` 的更改已传播到 `repo-one`。
- en: How it works…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Mercurial is a relatively simple control system. It is vastly extendable with
    different plugins, which are configured through the `.hgrc` file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Mercurial 是一个相对简单的控制系统。它可以通过不同的插件进行大量扩展，这些插件通过 `.hgrc` 文件进行配置。
- en: The Mercurial `forest` plugin propagates changes in nested repositories to the
    root ones, and synchronizes the parent repository content with a nested one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Mercurial 的 `forest` 插件将嵌套仓库中的更改传播到根仓库，并将父仓库的内容与嵌套仓库同步。
- en: Understanding OpenJDK 6 and 7 incremental builds
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 OpenJDK 6 和 7 的增量构建
- en: The process of OpenJDK compilation is very time consuming. It is very boring,
    especially when one is developing a small part of the whole project, which needs
    full recompilation for testing purposes. To do it in a simple way and to compile
    only the necessary parts, there are incremental builds.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: OpenJDK的编译过程非常耗时。这非常无聊，尤其是在开发整个项目的一个小部分时，为了测试目的需要完全重新编译。为了简单地进行编译，并且只编译必要的部分，存在增量构建。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to download the OpenJDK (6 or 7) source code. You may need `libmotif`
    installed. Windows users may need to install Cygwin.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要下载 OpenJDK（6 或 7）的源代码。你可能需要安装 `libmotif`。Windows 用户可能需要安装 Cygwin。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will see how OpenJDK is built incrementally, avoiding adding any nasty bugs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到 OpenJDK 是如何进行增量构建的，以避免添加任何讨厌的虫子。
- en: 'First, let''s build OpenJDK for the first time:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们第一次构建 OpenJDK：
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will take some time, so have a cup of tea.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将花费一些时间，所以喝杯茶吧。
- en: 'Then, we will build it for the second time:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将第二次构建它：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see from the input that nothing was actually built.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入中你可以看到实际上并没有构建任何东西。
- en: Then, let's insignificantly change some source file (for example, `cardTableModRefBS.cpp`).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们对一些源文件（例如，`cardTableModRefBS.cpp`）进行微小的更改。
- en: 'Let''s `make` OpenJDK again, but this time we will `grep` the output:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次 `make` OpenJDK，但这次我们将 `grep` 输出：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We see that, in the output, only two files are actually compiled, `hotspot/src/share/vm/memory/cardTableModRefBS.cpp`
    and `hotspot/src/share/vm/runtime/vm_version.cpp`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到，在输出中，实际上只编译了两个文件，`hotspot/src/share/vm/memory/cardTableModRefBS.cpp` 和
    `hotspot/src/share/vm/runtime/vm_version.cpp`。
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The build program checks the files that were updated and compiles only those
    which were updated after the last compiler run. However, if any `.hpp` files are
    modified, the build will be performed in clean mode, for example, no optimization
    will be performed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构建程序会检查更新的文件，并只编译那些在最后一次编译运行之后更新的文件。但是，如果任何 `.hpp` 文件被修改，构建将以干净模式执行，例如，不会进行优化。
- en: There's more…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Weird things tend to happen while using incremental builds. The probability
    of such things is increased proportionally with build times.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用增量构建时，往往会发生奇怪的事情。这种事情的概率与构建时间成比例增加。
- en: 'There are, basically, two ways to perform a clean build:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两种执行清理构建的方法：
- en: 'One cleans all files, and compilation from scratch becomes necessary:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理所有文件，从头开始重新编译成为必要：
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The second is to specify parameters, which will force the clean mode of the
    build.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是指定参数，这将强制构建的清理模式。
- en: Debugging Java code using NetBeans
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NetBeans 调试 Java 代码
- en: Obviously, when someone is writing any code, some debugging is required. It
    is no surprise that NetBeans, as a high-standard IDE, provides some tools to do
    that. This recipe will show how to debug the Java code using NetBeans.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当有人编写任何代码时，都需要进行一些调试。NetBeans 作为一款高标准的 IDE，提供了一些工具来完成这项工作。本食谱将展示如何使用 NetBeans
    调试 Java 代码。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to install NetBeans and set up a development environment, as described
    previously in the chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装 NetBeans 并设置一个开发环境，如本章先前所述。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will use NetBeans to debug our own OpenJDK Java code. We will need to rebuild
    OpenJDK with debug symbols, and configure NetBeans to make debugging possible:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 NetBeans 调试我们自己的 OpenJDK Java 代码。我们需要重新构建 OpenJDK 并带有调试符号，并配置 NetBeans
    以便进行调试：
- en: 'First, let''s make our OpenJDK instance with debug symbols:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个带有调试符号的 OpenJDK 实例：
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s ensure that a debuggable version is built:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们确保构建了一个可调试的版本：
- en: '[PRE17]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we have a debuggable OpenJDK. Let's set it as the default for NetBeans.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了可调试的 OpenJDK。让我们将其设置为 NetBeans 的默认版本。
- en: Let's open the `etc/netbeans.conf` file in your NetBeans installation path.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 NetBeans 安装路径中打开 `etc/netbeans.conf` 文件。
- en: 'We will change one line:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将更改一行：
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After that, we will launch NetBeans and ensure that our JDK is loaded correctly.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将启动 NetBeans 并确保我们的 JDK 已正确加载。
- en: We will select **Tools** | **Java Platforms**, and the following screen will
    appear:![How to do it...](img/8405OT_08_05.jpg)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将选择 **工具** | **Java 平台**，随后会出现以下屏幕：![如何操作...](img/8405OT_08_05.jpg)
- en: Let's try to debug the `java.lang.String` class. We will set our breakpoints
    to an unavoidable part of this class—to one of the constructors, as shown in the
    following screenshot:![How to do it...](img/8405OT_08_06.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试调试 `java.lang.String` 类。我们将断点设置在这个类的不可避免部分——其中一个构造函数，如以下截图所示：![如何操作...](img/8405OT_08_06.jpg)
- en: 'This set of breakpoints is sufficient to hook up virtually every Java executable
    ever launched. But, if we decide to push things forward and attach a debugger,
    we will get an error message:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这组断点足以连接到迄今为止启动的几乎所有 Java 可执行文件。但如果我们决定更进一步并附加调试器，我们将得到一个错误消息：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To avoid this, we need to specify our Java sources directly to NetBeans. Our
    project is a C++ project, and it tends to ignore the Java files.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们需要直接将我们的 Java 源代码指定给 NetBeans。我们的项目是一个 C++ 项目，它倾向于忽略 Java 文件。
- en: The result for the `String` class will be as shown in the following screenshot:![How
    to do it...](img/8405OT_08_07.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `String` 类的结果将如以下截图所示：![如何操作...](img/8405OT_08_07.jpg)
- en: 'Then, just launch some Java executable, that uses strings:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，只需启动一些使用字符串的 Java 可执行文件：
- en: '[PRE20]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Attach the Java debugger, as shown:![How to do it...](img/8405OT_08_08.jpg)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤连接 Java 调试器：![如何操作...](img/8405OT_08_08.jpg)
- en: Enjoy, you can now see OpenJDK from the inside, in motion:![How to do it...](img/8405OT_08_09.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 享受吧，您现在可以从内部看到 OpenJDK 的动态：![如何操作...](img/8405OT_08_09.jpg)
- en: How it works…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: It's just a debugger with a few simple nuances.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个带有几个简单细微之处的调试器。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In some Linux distributions, you can install debug versions of OpenJDK with
    sources provided in a ZIP file. These sources are automatically picked up by NetBeans.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 Linux 发行版中，您可以使用 ZIP 文件中提供的源代码安装 OpenJDK 的调试版本。这些源代码会被 NetBeans 自动获取。
- en: Debugging C++ code using NetBeans
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NetBeans 调试 C++ 代码
- en: If you plan to make changes to HotSpot or any other C++ part of OpenJDK, then
    it is certain that you will need to do some step-by-step debugging of the code.
    This recipe will explain how to set up NetBeans IDE for that purpose.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划修改 HotSpot 或 OpenJDK 的任何其他 C++ 部分，那么您肯定需要逐步调试代码。本食谱将解释如何设置 NetBeans IDE
    以实现此目的。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, there are only a few things required—downloaded Open JDK sources
    and installed NetBeans IDE. It is assumed that the OpenJDK project is already
    set up and can build sources.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，只需要几样东西——下载的 Open JDK 源代码和安装的 NetBeans IDE。假设 OpenJDK 项目已经设置好并且可以构建源代码。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The first step is to set up an executable that will run. Go to **Run** | **Set
    project configuration** / **Customize** and then **Build** | **Make**, and set
    **build/linux-amd64-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg/gamma**
    as the build result, as shown in the following screenshot:![How to do it...](img/8405OT_08_10.jpg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是设置一个可运行的执行文件。转到**运行** | **设置项目配置** / **自定义**，然后**构建** | **Make**，并将**build/linux-amd64-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg/gamma**设置为构建结果，如下面的截图所示：![如何操作...](img/8405OT_08_10.jpg)
- en: Then select the **Run** option on the tree on the left had side and set **Run
    Command** as **"${OUTPUT_PATH}" –version**:![How to do it...](img/8405OT_08_11.jpg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在左侧树形结构中选择**运行**选项，并将**运行命令**设置为**"${OUTPUT_PATH}" –version**：![如何操作...](img/8405OT_08_11.jpg)
- en: The `–version` flag here is just the simplest thing you can run—get the Java
    version. You can later change it to whatever you want, for example, to run a Java
    program.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的`–version`标志只是你可以运行的 simplest thing——获取Java版本。你可以稍后将其更改为你想要的任何内容，例如，运行Java程序。
- en: The next step is to set up some environment variables required for Java to run.
    This can be done by setting them up in the **Environment** section as shown in
    the following dialog. Set `LD_LIBRARY_PATH` to `build/linux-amd64-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg`
    and `JAVA_HOME` to `build/linux-amd64-debug/j2sdk-server-image`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置一些Java运行所需的环境变量。这可以通过在以下对话框的**环境**部分设置它们来完成。将`LD_LIBRARY_PATH`设置为`build/linux-amd64-debug/hotspot/outputdir/linux_amd64_compiler2/jvmg`，将`JAVA_HOME`设置为`build/linux-amd64-debug/j2sdk-server-image`。
- en: Now it's all ready to debug. To check that it works, set a breakpoint in `hotspot/src/share/tools/launcher/java.c`
    somewhere at the beginning of the `main` function and go to **Debug** | **Debug
    Main Project** or use the shortcut *Ctrl* + *F5*.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，可以开始调试。为了检查它是否工作，在`hotspot/src/share/tools/launcher/java.c`中`main`函数的开始处设置一个断点，然后转到**调试**
    | **调试主项目**或使用快捷键*Ctrl* + *F5*。
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Careful readers may have noticed that **Debug** used `gamma` JVM launcher, instead
    of `java`, which is used when you run Java normally. This is to simplify things;
    `gamma` is the lightweight version of `java`, it doesn't perform checks which
    are not necessary for debugging purposes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者可能已经注意到，**调试**使用了`gamma` JVM启动器，而不是通常运行Java时使用的`java`。这是为了简化事情；`gamma`是`java`的轻量级版本，它不会执行调试目的不必要的检查。
- en: Using NetBeans to compile HotSpot
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NetBeans编译HotSpot
- en: When doing HotSpot development, it is very annoying to wait for a complete OpenJDK
    build to be executed. So, it makes sense to exclude other parts and compile just
    what we are interested in, that is, the HotSpot part. This recipe will explain
    how to do that.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行HotSpot开发时，等待完整的OpenJDK构建执行是非常令人烦恼的。因此，排除其他部分并仅编译我们感兴趣的部分，即HotSpot部分，是有意义的。这个配方将解释如何做到这一点。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The only prerequisite for this recipe is the availability of source code on
    the machine, and Netbeans installed, with an OpenJDK project created.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的唯一先决条件是机器上可用的源代码，已安装Netbeans，并已创建OpenJDK项目。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This is a very simple recipe to follow. If you have already completed *Setting
    up development environment with NetBeans*, the only thing which is required to
    be done is to change the argument `hotspot_build` and add another argument `DEBUG_NAME=debug`,
    the whole build command line should look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的配方，可以遵循。如果你已经完成了*使用NetBeans设置开发环境*，唯一需要做的事情是更改`hotspot_build`参数并添加另一个参数`DEBUG_NAME=debug`，整个构建命令行应该看起来像这样：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The **Build/Make** screen of the **Project Properties** dialog in that case
    will look like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**项目属性**对话框的**构建/Make**屏幕将看起来像这样：
- en: '![How to do it...](img/8405OT_08_12.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/8405OT_08_12.jpg)'
- en: How it works…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Luckily, there are targets created in the `make` configuration which only built
    the HotSpot bit. These targets can be located in the `./make/hotspot-rules.gmk`
    file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在`make`配置中已经创建了仅构建HotSpot位的目标。这些目标可以在`./make/hotspot-rules.gmk`文件中找到。
- en: The `debug` command which creates the non-optimized version or the HotSpot,
    is not the only option for the `DEBUG_NAME` variable. The `fastdebug` command
    is the other option in which build will create an optimized version with assertions.
    When `DEBUG_NAME` is not set, the product version of HotSpot is built.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建非优化版本或HotSpot的`debug`命令不是`DEBUG_NAME`变量的唯一选项。`fastdebug`命令是另一个选项，其中构建将创建一个带有断言的优化版本。当`DEBUG_NAME`未设置时，将构建HotSpot的产品版本。
- en: Using HotSpot dev parameters
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HotSpot开发参数
- en: HotSpot has other options, which may significantly change its behavior. Here
    we will make use of some of these options, which are used only on the dev versions
    of OpenJDK.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: HotSpot 有其他选项，这些选项可能会显著改变其行为。在这里，我们将使用其中一些选项，这些选项仅在 OpenJDK 的开发版本中使用。
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will need to compile a dev OpenJDK version, in order to use the dev options.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这些选项，我们需要编译一个开发 OpenJDK 版本。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will use parameters that are available in the developer version of OpenJDK.
    In the production builds, they are disabled or set as constant values.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 OpenJDK 开发版本中可用的参数。在生产构建中，它们被禁用或设置为常量值。
- en: 'To make use of these parameters, we will run Java as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些参数，我们将按照以下方式运行 Java：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here is a list of some usable dev options:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些可用的开发选项列表：
- en: '`InlineUnsafeOps`: This option will, if enabled, inline native memory operations
    from `sun.misc.Unsafe`. It may offer some performance improvements in some cases.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InlineUnsafeOps`：如果启用此选项，将内联来自 `sun.misc.Unsafe` 的原生内存操作。在某些情况下，它可能提供一些性能改进。'
- en: '`DieOnSafepointTimeout`: This option will kill the process if the safepoint
    is not reached, but the timeout is exceeded. It is disabled by default.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DieOnSafepointTimeout`：此选项如果安全点未达到但超时，则会终止进程。默认情况下是禁用的。'
- en: '`ZapResourceArea`: This option will zap freed resource / arena space with `0xABABABAB`.
    It is true in debug mode, but is deselected in production VMs. It may be used
    for really paranoid security reasons, though it has some performance impact.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZapResourceArea`：此选项将使用 `0xABABABAB` zaps 释放的资源/区域空间。在调试模式下是真实的，但在生产 VM 中被取消选中。尽管它有一些性能影响，但它可能用于真正的偏执安全原因。'
- en: '`ZapJNIHandleArea`: This option will zap freed JNI handle space with `0xFEFEFEFE`.
    It only has a debug value.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZapJNIHandleArea`：此选项将使用 `0xFEFEFEFE` zaps 释放的 JNI 处理空间。它仅具有调试值。'
- en: '`ZapUnusedHeapArea`: This option will zap unused heap space with `0xBAADBABE`.
    It may be used for security reasons.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZapUnusedHeapArea`：此选项将使用 `0xBAADBABE` zaps 未使用的堆空间。它可能用于安全原因。'
- en: '`Verbose`: This option prints additional debugging information from other modes.
    It is the main logging option of the dev HotSpot.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Verbose`：此选项从其他模式打印额外的调试信息。它是开发 HotSpot 的主要日志选项。'
- en: '`UsePrivilegedStack`: This option enables the security JVM functions. It is
    `true` by default, but in dev mode, you still have the opportunity to run HotSpot
    with disabled security.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UsePrivilegedStack`：此选项启用安全 JVM 功能。默认情况下是 `true`，但在开发模式下，您仍然有机会以禁用安全的方式运行
    HotSpot。'
- en: '`MemProfiling`: This option writes memory usage profiling to logfile. It is
    `false` by default, and can be run for some memory profiling issues.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MemProfiling`：此选项将内存使用分析写入日志文件。默认情况下是 `false`，可以用于一些内存分析问题。'
- en: '`VerifyParallelOldWithMarkSweep`: This option will use the `MarkSweep` GC code
    to verify phases of the parallel old. It may be used for debugging purposes when
    changing the JVM memory handling mechanism.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerifyParallelOldWithMarkSweep`：此选项将使用`MarkSweep` GC 代码来验证并行老代的阶段。在更改 JVM
    内存处理机制时，此选项可能用于调试目的。'
- en: '`ScavengeWithObjectsInToSpace`: This option is really interesting. Java uses
    two-space GC, where survivor space is concerned, and this options allows scavenges
    to occur when `to_space` contains objects. Also, when doing so, it clears an unused
    area, if `ZapUnusedHeapArea` is enabled.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScavengeWithObjectsInToSpace`：此选项非常有趣。Java 使用两空间 GC，在幸存空间方面，此选项允许在 `to_space`
    包含对象时进行清除。在这样做的时候，如果启用了 `ZapUnusedHeapArea`，它还会清除一个未使用的区域。'
- en: '`FullGCALot`: This option forces full GC at every *Nth* exit from the runtime
    system (`N=FullGCALotInterval`). It may be a very expensive operation, but some
    developers may build it into JDKs for desktop use. It may be cheaper than to use
    swap space to absorb endless megabytes from the overgrown heap.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FullGCALot`：此选项强制在从运行时系统退出时进行完全 GC（`N=FullGCALotInterval`）。这可能是一个非常昂贵的操作，但一些开发者可能将其构建到用于桌面应用的
    JDK 中。它可能比使用交换空间吸收不断增长的堆中的兆字节更便宜。'
- en: '`AdaptiveSizePolicyReadyThreshold`: This option is the number of collections
    before adaptive sizing is started. The default is `5`, but it may make sense to
    make it `1` on desktop systems since the biggest bottleneck of those is the swap
    space, especially if several Java programs are running simultaneously on one machine.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AdaptiveSizePolicyReadyThreshold`：此选项是在开始自适应大小调整之前的收集次数。默认值是 `5`，但在桌面系统中，将其设置为
    `1` 可能更有意义，因为这些系统的最大瓶颈是交换空间，特别是如果在一台机器上同时运行多个 Java 程序的话。'
- en: '`EagerInitialization`: This option eagerly initializes classes if possible.
    It is `false` by default, so maybe it is unsafe to turn it on. But the idea seems
    good, especially on server machines.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EagerInitialization`: 这个选项如果可能的话会积极初始化类。默认值是`false`，所以可能不安全将其打开。但这个想法似乎很好，尤其是在服务器机器上。'
- en: '`GuaranteedSafepointInterval`: This option guarantees a safepoint (at least)
    every few milliseconds (`0` means none). The default is `1000`. It may be used
    to tweak the stop-the-world state problem. The bigger the option value, the longer
    these stops will be; and if we make the value too small, we will have too many
    unnecessary stops.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GuaranteedSafepointInterval`: 这个选项保证每隔几毫秒（`0`表示没有）至少有一个安全点。默认值是`1000`。它可以用来调整停止世界状态问题。选项值越大，这些停止的时间越长；如果我们把值设置得太小，将会出现过多的不必要的停止。'
- en: '`MaxTrivialSize`: This option is the maximum bytecode size of a trivial method
    to be inline. It is `6` by default. It is similar to the C++ compiler inline options,
    but for the bytecode compiler.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxTrivialSize`: 这个选项是内联平凡方法的最大字节码大小。默认值是`6`。它与C++编译器的内联选项类似，但针对字节码编译器。'
- en: '`MinInliningThreshold`: This option is the minimal invocation count a method
    needs to have to be inline. It is `250` by default.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinInliningThreshold`: 这个选项是方法需要的最小调用次数才能进行内联。默认值是`250`。'
- en: '`SharedOptimizeColdStartPolicy`: This option is the reordering policy for `SharedOptimizeColdStart`.
    The `0` value favors the classload-time locality, `1` uses a balanced policy,
    and `2` favors runtime locality.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SharedOptimizeColdStartPolicy`: 这个选项是`SharedOptimizeColdStart`的重排序策略。`0`值优先考虑类加载时的局部性，`1`使用平衡策略，而`2`则优先考虑运行时局部性。'
- en: The default is `2` and it is rarely necessary to change it, but in some cases
    it will make sense to make it `1` if your application has too many classes that
    may load after the application starts.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是`2`，很少需要更改它，但在某些情况下，如果你的应用程序启动后有太多可能加载的类，将其设置为`1`可能是有意义的。
- en: Adding new intrinsic to HotSpot
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将新的内联函数添加到HotSpot
- en: Intrinsic is a function whose implementation is handled specially by a compiler.
    Typically, it means that the function call is replaced by automatically generated
    instructions. This is very similar to the inline functions, but the compiler knows
    more about intrinsics as they are part of the compiler itself, so it can use them
    more wisely.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数是一个由编译器特别处理的函数。通常这意味着函数调用被自动生成的指令所替换。这与内联函数非常相似，但编译器对内联函数了解得更多，因为它们是编译器本身的一部分，所以它可以更明智地使用它们。
- en: Intrinsics are usually more performance-oriented than native functions because
    there is no JNI overhead.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数通常比原生函数更注重性能，因为没有JNI开销。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, all we need is an installed NetBeans IDE for code editing and
    OpenJDK sources. The user should be able to read C++ code and a little knowledge
    of assembly would be beneficial.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们只需要安装NetBeans IDE用于代码编辑和OpenJDK源代码。用户应该能够阅读C++代码，并且对汇编语言有一点了解会有所帮助。
- en: It would be worth checking that SSE4.2 (an extended instruction set with six
    new commands, mostly for character searching and comparison) is supported by the
    CPU (the `CRC32` command used in our example is from that command set). It was
    introduced with Core i7 Intel chips back in 2009, so if you are using an Intel
    CPU, it should be present. The first time it was introduced for AMD was as Bulldozer
    chips back in 2011, so you should have relatively recent chips to support it.
    If your CPU is not compatible with that command, do not worry. The recipe is applicable
    to any intrinsics you may want to introduce; there is no difference, apart from
    the actual implementation of the code you want to intrinsify.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 值得检查一下CPU是否支持SSE4.2（一个包含六个新命令的扩展指令集，主要用于字符搜索和比较）。这个指令集在2009年随着Core i7英特尔芯片的推出而引入，所以如果你使用的是英特尔CPU，它应该存在。AMD第一次引入是在2011年的Bulldozer芯片上，所以你应该有相对较新的芯片来支持它。如果你的CPU不兼容该指令，请不要担心。这个方法适用于你可能想要引入的任何内联函数；除了你想要内联的代码的实际实现之外，没有区别。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Adding new intrinsics is not a simple process. Follow these instructions carefully.
    Ensure you compile the code after every step; doing so may save some time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的内联函数不是一个简单的过程。仔细遵循这些说明。确保在每一步之后编译代码；这样做可能会节省一些时间。
- en: The instruction which we are going to intrinsify is the CRC32 calculation, which
    is implemented by `java.util.zip.CRC32`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要内联的指令是CRC32计算，它由`java.util.zip.CRC32`实现。
- en: 'To start, let''s make a small amendment to the Java class that is responsible
    for the CRC32 calculation. We are going to add a method which will be intrinsified
    by HotSpot. Open the `jdk/src/share/classes/java/util/zip/CRC32.java` file and
    add a new method `doUpdateBytes`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对负责CRC32计算的Java类进行一个小修改。我们将添加一个将被HotSpot内建的方法。打开`jdk/src/share/classes/java/util/zip/CRC32.java`文件，并添加一个新的方法`doUpdateBytes`：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That implementation just makes a call to the currently used `updateBytes` native
    method. That's the only change in Java. The rest is going to be the C++ internals
    of the HotSpot.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现只是调用当前使用的`updateBytes`本地方法。这是Java中唯一的更改。其余的将是HotSpot的C++内部实现。
- en: 'Open the `hotspot/src/share/vm/precompiled/precompiled.hpp` file and add the
    following line into it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`hotspot/src/share/vm/precompiled/precompiled.hpp`文件，并在其中添加以下行：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `smmintrin.h` file contains GCC intrinsics, which are going to be used by
    our implementation of the CRC32 function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`smmintrin.h`文件包含GCC内建函数，这些函数将用于我们CRC32函数的实现。'
- en: 'Then, as we are using SSE4.2 instructions, we need to inform the compiler.
    To do so, open the `hotspot/make/linux/makefiles/gcc.make` file (assuming you
    are making the build on Linux), and locate the line consisting of `CFLAGS += -fno-rtti`.
    Just after that line, add the `-msse4.2` flag, so it will look like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，因为我们使用SSE4.2指令，我们需要通知编译器。为此，打开`hotspot/make/linux/makefiles/gcc.make`文件（假设你在Linux上构建），找到包含`CFLAGS
    += -fno-rtti`的行。就在该行之后，添加`-msse4.2`标志，使其看起来像这样：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we are ready to implement our CRC32 function in C++. In the `hotspot/src/cpu/x86/vm/`
    folder, create the `CRC32Calc` class and the `static_calcCrc32` static method.
    Here is the `CRC32Calc.hpp` file with the class declaration:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在C++中实现我们的CRC32函数。在`hotspot/src/cpu/x86/vm/`文件夹中，创建`CRC32Calc`类和`static_calcCrc32`静态方法。以下是包含类声明的`CRC32Calc.hpp`文件：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `CRC32Calc.cpp` file with its implementation is as shown:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`CRC32Calc.cpp`文件及其实现如下所示：'
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The following instructs HotSpot how to intrinsify our method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令告诉HotSpot如何内建我们的方法。
- en: 'Locate `hotspot/src/share/vm/classfile/vmSymbols.hpp`. That is the file which
    contains the declaration of all intrinsics and add the following definition to
    it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到`hotspot/src/share/vm/classfile/vmSymbols.hpp`文件。这是包含所有内建函数声明的文件，并向其中添加以下定义：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is the declaration of intrinsics which maps the Java method with the code
    which will replace it in the runtime. Be careful when adding it. It is based on
    macros, which means, if there is a typo or any other mistake, it will be very
    hard to figure out where the problem is.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将Java方法与将在运行时替换它的代码映射的内建函数声明。添加时要小心。它基于宏，这意味着，如果存在拼写错误或其他错误，将很难找出问题所在。
- en: 'The next step is to define which code we are going to generate for the intrinsic.
    We are not going to be very smart here, as this is just an exercise to see how
    the functionality works. So all our assembler is going to do is generate a call
    to the C function. Add the following into `hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp`
    and `hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义我们将为内建函数生成哪种代码。在这里我们不会特别聪明，因为这只是一个练习，看看功能是如何工作的。所以我们的汇编器将要做的只是生成对C函数的调用。将以下内容添加到`hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp`和`hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp`文件中：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now it''s a bit tricky and requires some low-level code. We are going to tell
    HotSpot how to generate the assembly for our method. To do so, add the `generator`
    method into the `StubGenerator` class which is declared in both `hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp`
    and `hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp` for x86_64 and x86 architectures
    respectively. The code for the method is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有点棘手，需要一些底层代码。我们将告诉HotSpot如何为我们的方法生成汇编代码。要做到这一点，将`generator`方法添加到在`hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp`和`hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp`中声明的`StubGenerator`类中，分别对应x86_64和x86架构。该方法的代码如下：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we need a variable which will contain the address of the generated method.
    To do so, add the following static member declaration to `hotspot/src/share/vm/runtime/stubRoutines.hpp`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个变量来包含生成方法的地址。为此，将以下静态成员声明添加到`hotspot/src/share/vm/runtime/stubRoutines.hpp`文件中：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To the same file, add the following method, which just returns the value of
    the declared variable:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 向同一文件添加以下方法，该方法仅返回声明的变量值：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, in `hotspot/src/share/vm/runtime/stubRoutines.cpp`, assign a default
    value to `_crc32_doUpdateBytes`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`hotspot/src/share/vm/runtime/stubRoutines.cpp`中，为`_crc32_doUpdateBytes`分配一个默认值：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, in both `hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp` and `hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp`,
    locate the `generate_all` method and assign the following value to the variable
    `_crc32_doUpdateBytes`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp`和`hotspot/src/cpu/x86/vm/stubGenerator_x86_32.cpp`中，找到`generate_all`方法，并将以下值赋给变量`_crc32_doUpdateBytes`：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next step is to add the method which creates a descriptor. The descriptor
    is the definition of our function—how many arguments it takes, which types of
    arguments it accepts, and so on. The first step is to add the method declaration
    into the `OptoRuntime` class in the `hotspot/src/share/vm/opto/runtime.hpp` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加创建描述符的方法。描述符是我们函数的定义——它需要多少个参数，它接受哪些类型的参数，等等。第一步是将方法声明添加到`hotspot/src/share/vm/opto/runtime.hpp`文件中的`OptoRuntime`类中：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will be the function which creates the type information for our method
    call—it describes the arguments and returns the parameters. After implementation
    it creates an array of types of input parameters and the type of the return value.
    Place it in the `hotspot/src/share/vm/opto/runtime.cpp` file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是创建我们方法调用类型信息的函数——它描述了参数并返回参数。实现后，它创建了一个输入参数的类型数组以及返回值的类型。将其放置在`hotspot/src/share/vm/opto/runtime.cpp`文件中：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we will implement the method that will inline the code in the runtime.
    In the `hotspot/src/share/vm/opto/library_call.cpp` file, locate the definition
    of the `LibraryCallKit` class, and add the following method declaration:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现内联代码的方法。在`hotspot/src/share/vm/opto/library_call.cpp`文件中，找到`LibraryCallKit`类的定义，并添加以下方法声明：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also, in the same file, add the implementation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在同一个文件中，添加实现：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally tell HotSpot that we indeed want to intrinsify our method call and make
    a call to the inlining method `inline_crc32`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后告诉HotSpot我们确实想要内联我们的方法调用，并调用内联方法`inline_crc32`。
- en: 'To tell HotSpot that we want to intrinsify the method, `Compile::make_vm_intrinsic`
    method in the file `hotspot/src/share/vm/opto/library_call.cpp` has to return
    a non-null pointer to `CallGenerator`. To do so, add the following line into the
    `switch(id)` switch statement in that method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉HotSpot我们想要内联该方法，`hotspot/src/share/vm/opto/library_call.cpp`文件中的`Compile::make_vm_intrinsic`方法必须返回一个非空指针到`CallGenerator`。要做到这一点，在该方法的`switch(id)`选择语句中添加以下行：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is not strictly required to have that case and break, the default works just
    well; but it makes it more explicit that we are using intrinsics for the CRC32
    calculation method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 并非严格要求有那个case和break，默认设置也完全可以；但它使得我们使用内建方法进行CRC32计算方法更为明确。
- en: 'Then, to make a call to the inlining method, in the same `hotspot/src/share/vm/opto/library_call.cpp`
    file, locate `LibraryCallKit::try_to_inline`, find `switch (intrinsic_id())`,
    and add the following line of code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了调用内联方法，在相同的`hotspot/src/share/vm/opto/library_call.cpp`文件中，定位`LibraryCallKit::try_to_inline`，找到`switch
    (intrinsic_id())`，并添加以下代码行：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To check whether the method was intrinsified, use the `-XX:+PrintCompilation`
    and `-XX:+PrintInlining` Java arguments. To see what the intrinsics are compiled
    into, use `-XX:+PrintAssembly` (this should be prepended by `-XX:+UnlockDiagnosticsVMOptions`
    when running on the product build).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查方法是否内联，使用Java参数`-XX:+PrintCompilation`和`-XX:+PrintInlining`。要查看内建函数编译成了什么，使用`-XX:+PrintAssembly`（当在产品构建上运行时，应在前面加上`-XX:+UnlockDiagnosticsVMOptions`）。
- en: There's more…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'To see if SSE4.2 is supported, just compile and run the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否支持SSE4.2，只需编译并运行以下代码：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There are lots of intrinsic methods. See `library_call.cpp` and `vmSymbols.hpp`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多内建方法。参见`library_call.cpp`和`vmSymbols.hpp`：
- en: '`Object.getClass` gives one or two instructions.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getClass`给出一个或两个指令。'
- en: '`Class.isInstance` and `Class.isAssignableFrom` are as cheap as instances of
    bytecodes when the operands are constants, and otherwise no more expensive than
    aastore type checks.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作数是常量时，`Class.isInstance`和`Class.isAssignableFrom`与字节码实例一样便宜，否则不会比aastore类型检查更昂贵。
- en: Most single-bit class queries are cheap and even constant-foldable.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数单比特类查询都很便宜，甚至可以常数折叠。
- en: Reflective array creation is about as cheap as the `newarray` or `anewarray`
    instructions.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射数组创建与`newarray`或`anewarray`指令一样便宜。
- en: '`Object.clone` is cheap and shares code with `Arrays.copyOf` (after Java6).'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.clone`在Java6之后与`Arrays.copyOf`共享代码，且成本较低。'
- en: Java is not the only language which uses intrinsics they are also widely used
    in C++ for SSE operations.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Java不是唯一使用内建的编程语言，它们在C++的SSE操作中也广泛使用。
- en: Interestingly, `_mm_crc32_u32` and `_mm_crc32_u8` are intrinsics themselves,
    known by the GCC or MS compiler, which are directly replaced by assembly instructions
    in the compiled code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`_mm_crc32_u32` 和 `_mm_crc32_u8` 本身就是内联函数，由GCC或MS编译器所知，在编译后的代码中直接被汇编指令替换。
- en: Building VisualVM from the source code
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源代码构建VisualVM
- en: VisualVM is an open source project which is not a part of OpenJDK. It is a powerful
    tool which is helpful to anyone who uses applications based on JDK. It allows
    us to monitor parameters of the system, browse heap dumps, create thread dumps,
    and so on. As the tool is open source, it is possible to get the source code and
    customize it as required, or simply just to see how it works. This recipe will
    go through the steps which are required to download the source code and build
    VisualVM from it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM是一个开源项目，它不是OpenJDK的一部分。它是一个强大的工具，对任何使用基于JDK的应用程序的人来说都很有帮助。它允许我们监控系统参数，浏览堆转储，创建线程转储等等。由于该工具是开源的，因此可以获取源代码并根据需要对其进行定制，或者只是简单地看看它是如何工作的。本食谱将介绍下载源代码并从中构建VisualVM所需的步骤。
- en: Getting ready
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires a machine with Subversion and Ant installed. Also, as VisualVM
    is a graphical application, a graphical environment is required to run it. It
    is possible to perform a build without launching the application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱需要安装了Subversion和Ant的机器。此外，由于VisualVM是一个图形应用程序，需要一个图形环境来运行它。可以在不启动应用程序的情况下执行构建。
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first step is to get the source code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是获取源代码：
- en: Create a folder for the sources, for example, `/home/user/visualvm`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为源文件创建一个文件夹，例如，`/home/user/visualvm`。
- en: 'Go to the newly created folder and, assuming you need sources from the `trunk`,
    run the following command:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往新创建的文件夹，假设您需要从`trunk`获取源代码，请运行以下命令：
- en: '[PRE42]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This will create the `trunk` folder with sources in the current directory.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在当前目录中创建一个包含源代码的`trunk`文件夹。
- en: 'To start, we need to download the NetBeans Platform binaries. The version needed
    depends on the version of VisualVM we are going to build. In this example, we
    will use `trunk`, the current development version which requires NetBeans Platform
    v.8; but as that may change, it is recommended to consult the page for the appropriate
    version using the link [http://visualvm.java.net/build.html](http://visualvm.java.net/build.html).
    These binaries are available directly from the VisualVM website, not from the
    NetBeans website. For this example, the URL is [https://java.net/projects/visualvm/downloads/download/dev/nb80_visualvm_27062014.zip](https://java.net/projects/visualvm/downloads/download/dev/nb80_visualvm_27062014.zip).
    When the file is downloaded, unpack it into the `trunk/visualvm` folder, as shown:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要下载NetBeans平台的二进制文件。所需版本取决于我们将要构建的VisualVM版本。在这个例子中，我们将使用`trunk`，当前的开发版本，它需要NetBeans平台v.8；但鉴于这可能会改变，建议使用链接[http://visualvm.java.net/build.html](http://visualvm.java.net/build.html)咨询适当的版本页面。这些二进制文件可以直接从VisualVM网站获取，而不是从NetBeans网站获取。在这个例子中，URL是[https://java.net/projects/visualvm/downloads/download/dev/nb80_visualvm_27062014.zip](https://java.net/projects/visualvm/downloads/download/dev/nb80_visualvm_27062014.zip)。当文件下载完成后，将其解压到`trunk/visualvm`文件夹中，如下所示：
- en: Now, execute Ant to run the build.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行Ant以运行构建。
- en: '[PRE43]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the build is complete, we should see something similar to the following
    output in the command prompt:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，我们应该在命令提示符中看到以下类似的输出：
- en: '[PRE44]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This indicates that the build was successful. This step is not required if we
    just need to run VisualVM, as Ant will also run the build target; but if there
    is no need to run, and just build is required, this step can be useful.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表示构建成功。如果我们只需要运行VisualVM，这一步不是必需的，因为Ant也会运行构建目标；但如果不需要运行，只需要构建，这一步可能很有用。
- en: 'To run VisualVM, run the following command:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行VisualVM，请运行以下命令：
- en: '[PRE45]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the application is not built yet, then Ant will build it first and then run
    it. As VisualVM is a GUI application, we will see the following screen:![How to
    do it...](img/8405OT_08_13.jpg)
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序尚未构建，那么Ant将首先构建它，然后运行它。由于VisualVM是一个GUI应用程序，我们将看到以下屏幕：![如何操作...](img/8405OT_08_13.jpg)
- en: This is the landing screen of VisualVM. The fact that we can see it means that
    the application is built and works properly. The zipped archive file with the
    distribution can be found in the `visualvm/dist` folder.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是VisualVM的登录屏幕。我们能看到它意味着应用程序已构建并正常工作。包含分发的压缩存档文件可以在`visualvm/dist`文件夹中找到。
- en: See also
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: More information about VisualVM build is available on the home page [http://visualvm.java.net/build.html](http://visualvm.java.net/build.html).
    Each version has a different page, as build instructions vary from version to
    version. For example, each build may require a slightly different version of the
    Netbeans platform.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于VisualVM构建的更多信息可在主页[http://visualvm.java.net/build.html](http://visualvm.java.net/build.html)上找到。每个版本都有一个不同的页面，因为构建说明因版本而异。例如，每个构建可能需要NetBeans平台的不同版本。
- en: Creating a plugin for VisualVM
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为VisualVM创建插件
- en: VisualVM is just an application which has a predefined and limited set of features.
    It is a framework, which means that it is possible to extend it. The way in which
    VisualVM provides for extension is via the plugin API which allows us to create
    new plugins which are then available through the application. Such plugins can
    do various things, but are mostly used to provide new ways of monitoring or controlling
    the JVM applications.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM只是一个具有预定义和有限功能的应用程序。它是一个框架，这意味着可以扩展它。VisualVM提供扩展的方式是通过插件API，这允许我们创建新的插件，然后通过应用程序访问它们。这样的插件可以执行各种操作，但主要用于提供监控或控制JVM应用程序的新方法。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The current (at the time of writing) trunk version of VisualVM requires the
    NetBeans platform and IDE v.8\. So we need to ensure that the current version
    of the platform is available on the machine. If there is any doubt, check the
    page with VisualVM trunk build instructions at [http://visualvm.java.net/build/build.html](http://visualvm.java.net/build/build.html).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当前（在撰写本文时）VisualVM的分支版本需要NetBeans平台和IDE v.8。因此，我们需要确保当前版本的平台在机器上可用。如果有任何疑问，请检查VisualVM分支构建说明页面[http://visualvm.java.net/build/build.html](http://visualvm.java.net/build/build.html)。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s start with what we are going to monitor. It seems like the simplest
    thing we can do is to build a component which will tick the data that we can read.
    For example, look at the following class:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们要监控的内容开始。看起来我们能做的最简单的事情就是构建一个组件，它会更新我们可以读取的数据。例如，看看下面的类：
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code sleeps for 100 ms and measures how long it actually slept. The value
    is not going to be exact, but will be about `100`. It publishes the last measurement
    of the sleep time via the `lastSleepSample` variable which is available via the
    `SleepProbeMBean` interface:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码休眠100毫秒并测量实际休眠的时间。这个值不会非常精确，但大约是`100`。它通过`lastSleepSample`变量发布最后一次休眠时间的测量结果，该变量可通过`SleepProbeMBean`接口访问：
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This class and interface should be put into a separate project, so you can
    run them independently of the VirtualVM plugin project:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类和接口应该放入一个单独的项目中，这样你就可以独立于VirtualVM插件项目运行它们：
- en: To start, we need to create a plugin project in IDE. Launch the IDE, go to **File**
    | **New Project** and select **NetBeans Platform Application** from the project
    type:![How to do it...](img/8405OT_08_14.jpg)
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，我们需要在IDE中创建一个插件项目。启动IDE，转到**文件** | **新建项目**，从项目类型中选择**NetBeans平台应用程序**：![如何操作...](img/8405OT_08_14.jpg)
- en: On the next screen, select **VisualVM** as the **NetBeans Platform** (if it
    is not available, see further instructions), the project name, and the location,
    as shown:![How to do it...](img/8405OT_08_15.jpg)
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏上，选择**VisualVM**作为**NetBeans平台**（如果不可用，请参阅后续说明），项目名称和位置，如图所示：![如何操作...](img/8405OT_08_15.jpg)
- en: If **VisualVM** is not available in the list of platforms, then click on the
    Manage icon and, in the displayed dialog, add a new platform by pointing it to
    the folder with the VisualVM distribution, as shown in the following screenshot:![How
    to do it...](img/8405OT_08_16.jpg)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**VisualVM**不在平台列表中，请点击管理图标，在显示的对话框中，通过指向VisualVM发行版的文件夹添加一个新的平台，如图所示：![如何操作...](img/8405OT_08_16.jpg)
- en: In this example, the distribution was built from source (see the *Building VisualVM
    from the source code* recipe). Press **Next** and then **Finish**.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，发行版是从源代码构建的（请参阅*从源代码构建VisualVM*配方）。按**下一步**然后按**完成**。
- en: Now just complete the wizard and you will have a new empty project with some
    properties and build script.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在只需完成向导，你将拥有一个带有一些属性和构建脚本的全新空项目。
- en: Note that there is a known bug in some versions of NetBeans ([https://netbeans.org/bugzilla/show_bug.cgi?id=242564](https://netbeans.org/bugzilla/show_bug.cgi?id=242564)),
    which is causing problem with dependencies and which will not allow us to add
    the required dependencies later. To work around this, right click on the project
    and then click on **Properties**. On the **Project Properties** dialog, select
    **Libraries**:![How to do it...](img/8405OT_08_17.jpg)
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，NetBeans的一些版本中存在一个已知错误（[https://netbeans.org/bugzilla/show_bug.cgi?id=242564](https://netbeans.org/bugzilla/show_bug.cgi?id=242564)），这会导致依赖项问题，并且不允许我们稍后添加所需的依赖项。为了解决这个问题，右键单击项目，然后点击**属性**。在**项目属性**对话框中，选择**库**：![如何操作...](img/8405OT_08_17.jpg)
- en: Uncheck **JavaFX wrapper** under the platform component. Ensure that all the
    other checkboxes are checked, including **profiles** and **visualvm** nodes.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在平台组件下取消选中**JavaFX包装器**。确保所有其他复选框都已选中，包括**配置文件**和**visualvm**节点。
- en: Now we need to create a module for our plugin. Right click on the **Modules**
    item in the project tree and select **Add New…**:![How to do it...](img/8405OT_08_18.jpg)
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为我们的插件创建一个模块。在项目树中的**模块**项上右键单击并选择**添加新…**：![如何操作...](img/8405OT_08_18.jpg)
- en: Name it as `SamplingModule` and press **Next**. On the next screen, put `net.cookbook.openjdk`
    as `Code Name Base` and press on **Finish**. This will create an empty module
    where we will need to add some components.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`SamplingModule`并点击**下一步**。在下一屏幕上，将`net.cookbook.openjdk`作为`代码名称基础`并点击**完成**。这将创建一个空模块，我们需要在其中添加一些组件。
- en: The next step is to add the dependencies to the module. Right click on the module
    and select **Properties**, then go to **Libraries** | **Module Dependencies**,
    and click on **Add Dependency**. On the **Add Module Dependency** dialog, put
    `VisualVM` into the **Filter** field as shown:![How to do it...](img/8405OT_08_19.jpg)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是向模块添加依赖项。在模块上右键单击并选择**属性**，然后转到**库** | **模块依赖项**，并点击**添加依赖项**。在**添加模块依赖项**对话框中，将`VisualVM`放入**过滤器**字段中，如图所示：![如何操作...](img/8405OT_08_19.jpg)
- en: Select **VisualVM-Application**, **VisualVM-Core**, and **VisualVM-Tools** (not
    visible on the screenshot), then click on **OK**.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**VisualVM-Application**、**VisualVM-Core**和**VisualVM-Tools**（在截图上不可见），然后点击**确定**。
- en: The next step is to add the installer and some source code. To do so, right
    click on the newly created module and go to **New** | **Other**. This will show
    the dialog with the option to select the file type. Click on **Installer/Activator**
    and click on **Next**, as shown:![How to do it...](img/8405OT_08_20.jpg)
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加安装程序和一些源代码。为此，在新创建的模块上右键单击并转到**新建** | **其他**。这将显示一个对话框，可以选择文件类型。点击**安装程序/激活器**并点击**下一步**，如图所示：![如何操作...](img/8405OT_08_20.jpg)
- en: Then just complete the wizard by clicking on **Finish**. This will create a
    class with the name `Installer` in the package `net.cookbook.openjdk`. For now,
    leave that class as it is, we will update it later in the recipe.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后只需通过点击**完成**来完成向导。这将创建一个名为`Installer`的类，位于`net.cookbook.openjdk`包中。目前，请保持该类不变，我们将在后面的步骤中更新它。
- en: 'The next step is to create a component which will draw a graph for us. To do
    so, we will create a simple panel which will refresh itself every half a second
    with a new sample from the sampler `MBean`. In the `net.cookbook.openjdk` package,
    create a new class and name it as `SamplingGraphPanel`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个为我们绘制图表的组件。为此，我们将创建一个简单的面板，该面板将每半秒刷新一次，使用来自`sampler MBean`的新样本。在`net.cookbook.openjdk`包中创建一个新类，并将其命名为`SamplingGraphPanel`：
- en: '[PRE48]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This class will read a value from the `MBean` implements on the first step of
    this receipt every 500ms, and add the value to the list with samples. Then it
    refreshes the graph, which gets repainted. Fundamentally, that code is just a
    Java Swing code, which can be run in any application. The only VisualVM-specific
    bit here is some helper classes used to get `MBean` from the `Application` object.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此类将每隔500毫秒从本食谱第一步中实现的`MBean`读取一个值，并将其添加到包含样本的列表中。然后它刷新图表，进行重绘。基本上，这段代码只是一个Java
    Swing代码，可以在任何应用程序中运行。这里VisualVM特有的部分是一些辅助类，用于从`Application`对象中获取`MBean`。
- en: 'Now, in `SamplingModule`, create a class which will be responsible for showing
    the data. Name it `SamplingView` and put it into the `net.cookbook.openjdk` package,
    as shown below:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`SamplingModule`中创建一个负责显示数据的类。将其命名为`SamplingView`并将其放入`net.cookbook.openjdk`包中，如下所示：
- en: '[PRE49]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It is important that the file referenced by `IMAGE_PATH` actually exists, otherwise
    the plugin will not start and will fail with an exception. The simplest way you
    can do this is to download any of available free icons from the Internet, for
    example at [https://www.iconfinder.com/icons/131715/download/png/32](https://www.iconfinder.com/icons/131715/download/png/32)
    and put it into the same package folder as the `SamplingView` class.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要的一点是，由 `IMAGE_PATH` 引用的文件实际上必须存在，否则插件将无法启动并会抛出异常。您可以做的最简单的事情是从互联网上下载任何可用的免费图标，例如在
    [https://www.iconfinder.com/icons/131715/download/png/32](https://www.iconfinder.com/icons/131715/download/png/32)
    上，并将其放入与 `SamplingView` 类相同的包文件夹中。
- en: 'The next step is to create a provider which will create the view instance and
    identify that the application we are connected to is supported by the plugin.
    In the `net.cookbook.openjdk` package, create a class with the name `SamplingProvider`
    and with the following implementation:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个提供者，该提供者将创建视图实例并识别我们连接的应用程序是否由插件支持。在 `net.cookbook.openjdk` 包中，创建一个名为
    `SamplingProvider` 的类，并具有以下实现：
- en: '[PRE50]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The main methods of this class are `supportsViewFor` and `createView`. The `createView`
    method is small and easy, it just creates a view instance and passes through the
    application so that the view can get data out of it. The `supportsViewFor` class
    is slightly bigger, but it doesn't really match. It connects to the given application
    via JMX and tries to get the instance of `MBean` which our plugin is interested
    in. If `MBean` is not there, it means that the application is not supported and
    the method returns `false`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该类的主要方法为 `supportsViewFor` 和 `createView`。`createView` 方法很小且简单，它只是创建一个视图实例，并通过应用程序传递，以便视图可以从其中获取数据。`supportsViewFor`
    类稍微大一些，但它并不真正匹配。它通过JMX连接到指定的应用程序，并尝试获取我们插件感兴趣的 `MBean` 实例。如果 `MBean` 不存在，则表示该应用程序不受支持，方法返回
    `false`。
- en: Now it is time to see how the plugin works. To do this, first start the application
    created on the first step of this receipt. Then right-click on **SamplingModule**
    and select **Run**. This will start VisualVM with our plugin. From the list of
    processes in VisualVM, select our process and click on the **Sampling Application**
    tab. There you will see our graph showing slight changes in the sleep time as
    shown in the following screenshot:![How to do it...](img/8405OT_08_21.jpg)
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候看看插件是如何工作的了。为此，首先启动本食谱第一步创建的应用程序。然后右键单击 **SamplingModule** 并选择 **运行**。这将启动带有我们插件的VisualVM。从VisualVM中的进程列表中选择我们的进程，并点击
    **Sampling Application** 选项卡。在那里，您将看到我们的图表，显示睡眠时间略有变化，如下面的截图所示：![如何操作...](img/8405OT_08_21.jpg)
- en: After following these steps, it should not be a problem for the reader to extend
    this example and use it for any kind of monitoring applications that he/she wants
    in VisualVM.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循这些步骤之后，读者应该能够扩展此示例，并在VisualVM中使用任何他们想要的监控应用程序。
- en: See also
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: There is some documentation available on the VisualVM website, which helps with
    creating the plugin for VisualVM and which covers, in more detail, some classes
    which are used in this receipt, at [http://visualvm.java.net/api-quickstart.html](http://visualvm.java.net/api-quickstart.html).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM网站上有一些文档可供参考，这些文档有助于创建VisualVM插件，并详细介绍了在此食谱中使用的一些类，请参阅 [http://visualvm.java.net/api-quickstart.html](http://visualvm.java.net/api-quickstart.html)。
- en: It is also worth having a look at existing plugins source code and some samples
    available. These can be found in `<code_root>/plugins` and `<code_root>/samples`
    respectively. For instructions on how to download the source code, please see
    the *Building VisualVM from the source code* recipe.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看的是现有的插件源代码和一些示例。这些可以在 `<code_root>/plugins` 和 `<code_root>/samples` 分别找到。有关如何下载源代码的说明，请参阅
    *从源代码构建VisualVM* 的食谱。
- en: Getting benefits from the AdoptOpenJDK project
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从AdoptOpenJDK项目中获得收益
- en: AdoptOpenJDK is a program, initially developed by a small group of enthusiasts,
    but which became part of an official OpenJDK community. Some of the purposes are
    to clarify and simplify OpenJDK building, installation, and usage, but there is
    still more. It provides build automation, a report generator, build testing, and
    more. We will cover some basic features that will be useful for everyone.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: AdoptOpenJDK是一个项目，最初由一小群爱好者开发，但后来成为官方OpenJDK社区的一部分。其中一些目的是澄清和简化OpenJDK的构建、安装和使用，但还有更多。它提供构建自动化、报告生成器、构建测试等。我们将介绍一些对每个人都有用的基本功能。
- en: Getting ready
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow this recipe, we will need an OpenJDK instance installed, and an Internet
    connection established.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循这个食谱，我们需要安装一个OpenJDK实例，并建立互联网连接。
- en: How to do it...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: AdoptOpenJDK is a very helpful and a very sophisticated project set with quite
    a few different subprojects. Many of them concern testing and evangelism, so we
    could not include them here as recipes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: AdoptOpenJDK是一个非常有帮助且非常复杂的项目集，包含许多不同的子项目。其中许多与测试和宣传有关，所以我们无法在这里作为食谱包含它们。
- en: Visualizing JIT logs
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可视化JIT日志
- en: 'There is a project named Jitwatch in AdoptOpenJDK. Its purpose is to visualize
    JIT compiler logs. It helps to find some of our project''s performance deficiencies
    and inspect a native assembly output, as it''s just fun after all. Have a look
    at the following points:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在AdoptOpenJDK中有一个名为Jitwatch的项目。它的目的是可视化JIT编译器的日志。它有助于发现我们项目中的一些性能缺陷，并检查原生汇编输出，因为毕竟这很有趣。以下是一些要点：
- en: First, let's download an executable jar [http://www.chrisnewland.com/images/jitwatch.jar](http://www.chrisnewland.com/images/jitwatch.jar).
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们下载一个可执行的jar文件[http://www.chrisnewland.com/images/jitwatch.jar](http://www.chrisnewland.com/images/jitwatch.jar)。
- en: 'In order to analyze an executable, we will need to run it with the following
    switches:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了分析一个可执行文件，我们需要用以下开关运行它：
- en: '[PRE51]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `UnlockDiagnosticVMOptions` parameter gives access to other diagnostic options,
    such as `SharedOptimizeColdStart`, `PauseAtStartup`, and so on.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UnlockDiagnosticVMOptions`参数提供了访问其他诊断选项的权限，例如`SharedOptimizeColdStart`、`PauseAtStartup`等等。'
- en: The `LogCompilation` logs compilation activity in detail to `hotspot.log` or
    `LogFile`, which is yet another VM option.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LogCompilation`详细记录编译活动到`hotspot.log`或`LogFile`，这是另一个VM选项。'
- en: The `TraceClassLoading` parameter lets JVM ensure that all loaded classes are
    visible, even the ones without any JIT-compiled code related to them.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`TraceClassLoading`参数让JVM确保所有加载的类都是可见的，即使是没有与之相关的任何JIT编译代码的类。'
- en: The `PrintAssembly` parameter lets us see the assembler output of the JIT compilation.
    It uses `hsdis`, a HotSpot disassembler, which is a part of OpenJDK.
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PrintAssembly`参数让我们看到JIT编译的汇编输出。它使用`hsdis`，这是一个HotSpot反汇编器，它是OpenJDK的一部分。'
- en: 'Start the analyzer:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动分析器：
- en: '[PRE52]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You will see the following screen:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到以下屏幕：
- en: '![Visualizing JIT logs](img/8405OT_08_22.jpg)'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![可视化JIT日志](img/8405OT_08_22.jpg)'
- en: Open your `hotspot.log` and, then press **Start**.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`hotspot.log`，然后按**开始**。
- en: Enjoy the experience.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 享受体验。
- en: Securing your javadocs
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护你的javadoc
- en: We will try to eliminate a javadoc vulnerability (CVE-2013-1571) that seems
    to exist in Java releases before 7u22.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将尝试消除似乎存在于Java 7u22之前版本中的javadoc漏洞（CVE-2013-1571）。
- en: 'To do that, we will need to clone a repository, such as:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要克隆一个仓库，例如：
- en: '[PRE53]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Build the project
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建项目
- en: '[PRE54]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will try to scan a directory for potential vulnerabilities. We will run
    the following command from the directory in which the `JavadocPatchTool.jar` file
    is located:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从包含`JavadocPatchTool.jar`文件的目录中运行以下命令来扫描潜在漏洞：
- en: '[PRE55]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the tool finds any applicable HTML files, it will print out a list of such
    files.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果工具找到任何适用HTML文件，它将打印出此类文件的列表。
- en: 'To fix a single applicable file, we will run the following command:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要修复单个适用文件，我们将运行以下命令：
- en: java -jar JavadocPatchTool.jar <path>
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: java -jar JavadocPatchTool.jar <path>
- en: Here, `<path>` is the path to the directory which contains the applicable file.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`<path>`是包含适用文件的目录的路径。
- en: 'To fix all the applicable files in the tree, run the following command:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要修复树中所有适用文件，请运行以下命令：
- en: '[PRE56]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Tip
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To learn about more benefits from the AdoptOpenJDK project, visit the appropriate
    page at [https://java.net/projects/adoptopenjdk/pages/Benefits](https://java.net/projects/adoptopenjdk/pages/Benefits).
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要了解AdoptOpenJDK项目带来的更多好处，请访问[https://java.net/projects/adoptopenjdk/pages/Benefits](https://java.net/projects/adoptopenjdk/pages/Benefits)的相关页面。
- en: How it works…
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: JIT log visualizer is no more than a tool to process logs generated by OpenJDK.
    But it is a very useful tool that may significantly improve performance.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: JIT日志可视化器只是一个处理由OpenJDK生成的日志的工具。但它是一个非常有用的工具，可能会显著提高性能。
- en: Java is used in various projects that need security, so the vulnerability in
    javadocs has an impact on those who still use Java 6 and are unable to change
    it to Java 7\. So the tool that fixes it with no transitions in the technology
    is really invaluable.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Java被用于各种需要安全性的项目中，因此javadoc中的漏洞对仍然使用Java 6且无法将其更改为Java 7的用户产生了影响。因此，无需技术转换即可修复它的工具确实非常宝贵。
- en: There's more...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many more projects in AdoptOpenJDK. Most of them are evangelist or
    testing ones; thus, they are slightly beyond the scope of this book.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: AdoptOpenJDK 中有更多项目。其中大多数是传教士或测试性质的项目；因此，它们略超出了本书的范围。
- en: However, you can always find them on various AdoptOpenJDK sites. There is no
    need to mention all of them in this book, they are tightly linked. In order to
    find them, it is sufficient to just look around.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你总可以在各种 AdoptOpenJDK 网站上找到它们。本书无需提及所有这些项目，它们之间紧密相连。为了找到它们，只需四处看看就足够了。
