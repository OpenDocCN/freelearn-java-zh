- en: Distributed Configuration with Spring Cloud Config
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Config的分布式配置
- en: It is the right time to introduce a new element in our architecture, a distributed
    configuration server. Similar to service discovery, this is one of the key concepts
    around microservices. In the previous chapter, we discussed in detail how to prepare
    discovery, both on the server and client sides. But so far, we have always provided
    a configuration for the application using properties placed inside a fat JAR file.
    That approach has one big disadvantage, it requires a recompilation and a redeployment
    of the microservice's instance. Another approach supported by Spring Boot assumes
    the use of an explicit configuration stored in a filesystem outside of the fat
    JAR. It can be easily configured for an application during startup with the `spring.config.location`
    property. That approach does not require a redeployment, but it is also not free
    from drawbacks. With a lot of microservices, a configuration management based
    on explicit files placed in a filesystem may be really troublesome. In addition,
    let’s imagine that there are many instances of every microservice and each of
    them has a specific configuration. Well, with that approach it is better not to
    imagine it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是引入我们架构中的一个新的元素，一个分布式配置服务器的时候了。与服务发现一样，这是微服务周围的的关键概念之一。在上一章中，我们详细讨论了如何准备发现，包括服务器和客户端两侧。但到目前为止，我们总是通过在一个胖JAR文件内部放置属性来为应用程序提供配置。这种方法有一个很大的缺点，它需要重新编译和部署微服务的实例。Spring
    Boot支持另一种方法，它假定使用一个存储在胖JAR外部文件系统中的显式配置。在应用程序启动时，可以通过`spring.config.location`属性轻松地为应用程序配置。这种方法不需要重新部署，但它也不是没有缺点。对于很多微服务，基于显式文件放置在文件系统上的配置管理可能真的非常麻烦。此外，让我们想象一下，每个微服务都有很多实例，并且每个实例都有特定的配置。好吧，用那种方法最好不要去想象。
- en: Anyway, a distributed configuration is a very popular standard in a cloud-native
    environment. Spring Cloud Config provides server-side and client-side support
    for externalized configuration in a distributed system. With that solution, we
    have one central place where we can manage external properties for applications
    across all environments. The concept is really simple and easy to implement. A
    server does nothing more than expose HTTP and resource-based API interfaces, which
    returns `property` files in JSON, YAML, or properties formats. Additionally, it
    performs decryption and encryption operations for returned property values. A
    client needs to fetch configuration settings from a server, and also decrypt them
    if such a feature has been enabled on the server side.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，分布式配置在云原生环境中是一个非常流行的标准。Spring Cloud Config为分布式系统中的外部化配置提供了服务器端和客户端支持。有了这个解决方案，我们有一个中心位置，可以管理跨所有环境的应用程序的外部属性。这个概念真的很简单，易于实现。服务器所做的不仅仅是暴露HTTP和基于资源的API接口，返回`property`文件以JSON、YAML或属性格式。此外，它还执行返回属性值的解密和加密操作。客户端需要从服务器获取配置设置，如果服务器端启用了此类功能，还需要对其进行解密。
- en: Configuration data may be stored in different repositories. The default implementation
    of `EnvironmentRepository` uses a Git backend. It is also possible to set up other
    VCS systems such as SVN. If you don't want to take advantage of features provided
    by VCS as a backend, you may use the filesystem or Vault. Vault is a tool for
    managing secrets, which stores and controls access to such resources as tokens,
    passwords, certificates, and API keys.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 配置数据可能存储在不同的仓库中。`EnvironmentRepository`的默认实现使用Git后端。也可以设置其他VCS系统，如SVN。如果你不想利用VCS作为后端所提供的特性，你可以使用文件系统或Vault。Vault是一个管理秘密的工具，它存储并控制对令牌、密码、证书和API密钥等资源的访问。
- en: 'The topics we will cover in this chapter are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要覆盖的主题有：
- en: HTTP API exposed by Spring Cloud Config Server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Spring Cloud Config Server暴露的HTTP API
- en: Different types of repository backend on the server side
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端的不同的仓库后端类型
- en: Integrating with service discovery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合服务发现
- en: Reloading the configuration automatically with Spring Cloud Bus and message
    broker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Bus和消息代理自动重新加载配置
- en: Introduction to HTTP API resources
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP API资源介绍
- en: 'The Config Server provides the HTTP API, which may be invoked in various ways.
    The following endpoints are available:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器提供HTTP API，可以通过多种方式调用。以下端点可用：
- en: '`/{application}/{profile}[/{label}]`: This returns data in a JSON format; the
    label parameter is optional'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/{application}/{profile}[/{label}]`: 这返回以JSON格式数据；标签参数是可选的'
- en: '`/{application}-{profile}.yml`: This returns the YAML format'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/{application}-{profile}.yml`: 这返回YAML格式。'
- en: '`/{label}/{application}-{profile}.yml`: A variant of the previous endpoint,
    where we can pass an optional label parameter'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/{label}/{application}-{profile}.yml`: 此为前一个端点的变种，其中我们可以传递一个可选的标签参数。'
- en: '`/{application}-{profile}.properties`: This returns the simple key/value format
    used by properties files'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/{application}-{profile}.properties`: 这返回属性文件使用的简单键/值格式。'
- en: '`/{label}/{application}-{profile}.properties`: A variant of the previous endpoint,
    where we can pass an optional label parameter'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/{label}/{application}-{profile}.properties`: 此为前一个端点的变种，其中我们可以传递一个可选的标签参数。'
- en: From a client point of view, the application parameter is the name of the application,
    which is taken from the `spring.application.name` or `spring.config.name` property,
    and profile is an active profile or comma-separated list of active profiles. The
    last available parameter `label` is an optional property, important only while
    working with Git as a backend store. It sets the name of the Git branch for configuration
    and defaults to `master`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度来看，应用程序参数是应用程序的名称，它来自于`spring.application.name`或`spring.config.name`属性，配置文件参数是活动配置文件或由逗号分隔的活动配置文件列表。最后一个可用的参数`label`是一个可选属性，仅在作为后端存储的Git中工作时才重要。它设置了配置的Git分支名称，默认为`master`。
- en: Native profile support
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生配置文件支持
- en: 'Let’s begin with the simplest example, based on a filesystem backend. By default,
    Spring Cloud Config Server tries to fetch configuration data from a Git repository.
    To enable the native profile, we should launch the server with the `spring.profiles.active` option set
    to `native`. It searches for files stored in the following locations, `classpath:/`,
    `classpath:/config`, `file:./`, `file:./config`. It means that properties or YAML
    files may be also placed inside a JAR file. For test purposes, I created a config
    folder inside `src/main/resources`. Our configuration files will be stored in
    that location. Now, we need to go back for a moment to the example from the previous
    chapter. As you probably remember, I introduced the configuration for a clustered
    discovery environment, where each client service instance was launched in a different
    zone. There were three available zones and three client instances, each of them
    has its own profile in the `application.yml` file. The source code for that example
    is available in the `config` branch. Here''s the link:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的例子开始，该例子基于文件系统后端。默认情况下，Spring Cloud Config Server尝试从Git仓库获取配置数据。要启用原生配置文件，我们应该使用`spring.profiles.active`选项将服务器启动设置为`native`。它会在以下位置搜索存储的文件，`classpath:/`、`classpath:/config`、`file:./`、`file:./config`。这意味着属性文件或YAML文件也可以放在JAR文件内部。为了测试目的，我在`src/main/resources`内部创建了一个config文件夹。我们的配置文件将存储在该位置。现在，我们需要回到前一章节的例子。正如您可能记得的，我介绍了集群发现环境的配置，每个客户端服务实例在不同的区域启动。有三个可用的区域和三个客户端实例，每个实例在其`application.yml`文件中都有自己的配置文件。该示例的源代码在`config`分支中可用。这是链接：[https://github.com/piomin/sample-spring-cloud-netflix/tree/config](https://github.com/piomin/sample-spring-cloud-netflix/tree/config)。
- en: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config](https://github.com/piomin/sample-spring-cloud-netflix/tree/config)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config](https://github.com/piomin/sample-spring-cloud-netflix/tree/config)'
- en: 'Our current task is to migrate that configuration to the Spring Cloud Config
    Server. Let''s remind ourselves the properties set for that example. Here are
    the profile settings used for the first instance of the client application. According
    to the selected profile, there are a changing instance running port, a default
    discovery server URL and a zone name:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的任务是将该配置迁移到Spring Cloud Config Server。让我们回顾一下该示例中设置的属性。以下是为客户端应用程序的第一个实例使用的配置文件设置。根据所选配置文件，有一个可变的实例运行端口、一个默认的发现服务器URL和一个区域名称：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the described example I placed all of the profiles settings in a single
    `application.yml` file for simplicity. That file might as well be divided into
    three different files with the names including the profiles, `application-zone1.yml`,
    `application-zone2.yml`, and `application-zone3.yml`. Of course, such names are
    unique to a single application, so if we decided to move the files into a remote
    configuration server, we should take care of their names. The client application
    name is injected from `spring.application.name` and in this case, it is `client-service`.
    So, to conclude, I created three configuration files with the name `client-service-zone[n].yml`
    in the `src/main/resources/config` catalog, where [`n`] is an instance''s number.
    Now, when you call the `http://localhost:8888/client-service/zone1` endpoint, you
    will receive the following response in JSON format:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在所描述的示例中，我把所有配置文件设置放在了一个单独的`application.yml`文件中，以简化问题。这个文件完全可以被分成三个不同的文件，文件名包含各自配置文件，如`application-zone1.yml`、`application-zone2.yml`和`application-zone3.yml`。当然，这样的名字对于单个应用来说是唯一的，所以如果我们决定将这些文件移动到远程配置服务器，我们需要注意它们的名称。客户端应用程序名称是从`spring.application.name`注入的，在这个例子中，它是`client-service`。所以，总结来说，我在`src/main/resources/config`目录下创建了三个名为`client-service-zone[n].yml`的配置文件，其中[`n`]是实例编号。现在，当你调用`http://localhost:8888/client-service/zone1`端点时，你将以JSON格式收到以下响应：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also call `http://localhost:8888/client-service-zone2.properties` for
    the second instance, which returns the following response as a list of properties:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以调用`http://localhost:8888/client-service-zone2.properties`获取第二个实例，它将以下响应作为属性列表返回：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The last available version of the HTTP API endpoint, `http://localhost:8889/client-service-zone3.yml`,
    returns data identical to the input file. Here''s the result for the third instance:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个可用的HTTP API端点，`http://localhost:8889/client-service-zone3.yml`，返回与输入文件相同的数据。这是第三个实例的结果：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Building a server-side application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务器端应用程序
- en: 'We have started by discussing HTTP, a resource-based API provided by the Spring
    Cloud Config Server, and the way of creating and storing properties there. But
    now let''s move back to the basics. The same as a discovery server, a Config Server
    may be run as a Spring Boot application. To enable it on the server side, we should
    include `spring-cloud-config-server` in our dependencies in the `pom.xml` file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了由Spring Cloud Config Server提供的基于资源的HTTP API以及在该处创建和存储属性的方法。但现在让我们回到基础。与发现服务器一样，Config
    Server也可以作为Spring Boot应用程序运行。要在服务器端启用它，我们应在`pom.xml`文件中包含`spring-cloud-config-server`在我们的依赖项中：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition to this, we should enable the Config Server on the main application
    class. It would be a good idea to change the server port to `8888`, because it
    is the default value of the `spring.cloud.config.uri` property on the client side.
    For example, it is auto configured on the client side. To switch the server to
    a different port, you should set the `server.port` property on `8888` or launch
    it with the `spring.config.name=configserver` property. There is a `configserver.yml`
    embedded in the `spring-cloud-config-server` library:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们应在主应用程序类上启用Config Server。将服务器端口更改为`8888`是个好主意，因为它是客户端侧`spring.cloud.config.uri`属性的默认值。例如，客户端会自动配置。要更改服务器端口，你应该设置`server.port`属性为`8888`，或者使用`spring.config.name=configserver`属性启动它。`spring-cloud-config-server`库中有一个`configserver.yml`：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building a client-side application
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建客户端应用程序
- en: 'If you set port `8888` as the default for the server, the configuration on
    the client side is really simple. All you need to do is to provide the `bootstrap.yml`
    file with the application name and include the following dependency in your `pom.xml`.
    Of course, that rule is applicable only on localhost, because the auto-configured
    Config Server address for a client is `http://localhost:8888`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把`8888`设置为服务器的默认端口，客户端的配置就非常简单了。你只需要提供`bootstrap.yml`文件，其中包含应用程序名称，并在你的`pom.xml`中包含以下依赖关系。当然，这个规则只适用于本地主机，因为客户端自动配置的Config
    Server地址是`http://localhost:8888`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you set a port different than `8888` for the server, or it is running on
    a different machine than the client application, you should also set its current
    address in `bootstrap.yml`. Here are the bootstrap context settings, which allow
    you to fetch properties for `client-service` from the server available on port 
    `8889`. When running the application with the `--spring.profiles.active=zone1` argument, it
    automatically fetches the properties set for the `zone1` profile in the configuration
    server:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为服务器设置了不同于`8888`的端口，或者它运行在与客户端应用程序不同的机器上，您还应该在`bootstrap.yml`中设置其当前地址。以下是引导上下文设置，它允许您从端口`8889`上运行的服务器获取`client-service`的属性。当使用`--spring.profiles.active=zone1`参数运行应用程序时，它将自动获取配置服务器中为`zone1`配置文件设置的属性：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding a Eureka Server
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Eureka服务器
- en: As you have probably noticed, there is the discovery service network location
    address in the client's properties. So, before launching the client service we
    should have a Eureka Server running. Of course, Eureka also has its own configuration,
    which has been stored in the `application.yml` file for the example from the previous
    chapter. That configuration, similar to `client-service`, has been divided into
    three profiles, where each of them differ from the others in such properties as
    the number of the server's HTTP port and the list of discovery peers to communicate
    with.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，客户端属性中有一个发现服务网络位置的地址。所以，在启动客户端服务之前，我们应该有一个Eureka服务器在运行。当然，Eureka也有自己的配置，它已经被存储在前一章节的`application.yml`文件中。那个配置，类似于`client-service`，被分成了三个配置文件，每个文件在诸如服务器HTTP端口号和要通信的发现对等体列表等属性上与其他文件不同。
- en: 'Now, we place those `property` files on the configuration server. Eureka fetches
    all of the settings assigned to the selected profile on startup. File naming is
    consistent with the already described standard, which means `discovery-service-zone[n].yml`.
    Before running the Eureka Server, we should include `spring-cloud-starter-config`
    in the dependencies to enable Spring Cloud Config Client, and replace `application.yml`
    with `bootstrap.yml`, which is shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将这些`property`文件放在配置服务器上。Eureka在启动时获取分配给所选配置文件的所有的设置。文件命名与已经描述的标准一致，即`discovery-service-zone[n].yml`。在运行Eureka服务器之前，我们应该在依赖项中包括`spring-cloud-starter-config`以启用Spring
    Cloud Config客户端，并用以下所示的`bootstrap.yml`替换`application.yml`：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we may run three instances of the Eureka Server in peer-to-peer communication
    mode by setting a different profile name in the `--spring.profiles.active` property.
    After launching three instances of `client-service`, our architecture looks like
    the following diagram. In comparison to the example from the previous chapter,
    both client and discovery services fetch the configuration from the Spring Cloud
    Config Server, instead of keeping it as a YML file inside a fat JAR:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在`--spring.profiles.active`属性中设置不同的配置文件名称，以对等通信模式运行三个Eureka服务器实例。在启动三个`client-service`实例之后，我们的架构如下所示。与前一章节的示例相比，客户端和服务发现服务都从Spring
    Cloud Config服务器获取配置，而不是将其保存在胖JAR内的YML文件中：
- en: '![](img/9423cf78-f43e-4e95-89a7-fe1beeae4cff.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9423cf78-f43e-4e95-89a7-fe1beeae4cff.png)'
- en: Client-side bootstrap approaches
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端引导方法
- en: In the example solution described previously, all of the applications must hold
    the network location of the configuration server. The network location of service
    discovery is stored there as a property. At this point, we are confronted with
    an interesting problem to discuss. We could ask whether our microservices should
    be aware of the Config Server's network address. In previous discussions, we have
    agreed that the main place all the service’s network locations should be kept
    is the service discovery server. The configuration server is also a Spring Boot
    application like other microservices, so logically it should register itself with
    Eureka to enable the automated discovery mechanism for other services that have
    to fetch data from the Spring Cloud Config Server. This in turn requires placing
    the service discovery connection settings in `bootstrap.yml` instead of the `spring.cloud.config.uri`
    property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例解决方案中，所有应用程序必须持有配置服务器的网络位置。服务发现的位置作为属性存储在那里。在此时，我们面临一个有趣的问题进行讨论。我们可以问一下我们的微服务是否应该知道Config
    Server的网络地址。在之前的讨论中，我们已经同意所有服务的网络位置的主要位置应该是服务发现服务器。配置服务器也是像其他微服务一样的Spring Boot应用程序，所以从逻辑上讲，它应该向Eureka注册自己，以使其他必须从Spring
    Cloud Config Server获取数据的服务能够使用自动发现机制。这反过来又要求将服务发现连接设置放在`bootstrap.yml`中，而不是`spring.cloud.config.uri`属性。
- en: Choosing between these two different approaches is one of the decisions you
    need to make while designing your system architecture. It's not that one solution
    is better than the other. The default behavior for any application that uses the `spring-cloud-config-client`
    artifact is called **Config First Bootstrap** in Spring Cloud nomenclature. When
    a config client starts up, it binds to the server and initializes the context
    with remote property sources. That approach has been presented in the first example
    in this chapter. In the second solution, the Config Server registers with the
    service discovery and all of the applications may use `DiscoveryClient` to locate
    it. That approach is called **Discovery First Bootstrap**. Let's implement an
    example that illustrates that concept.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计系统架构时需要做出的决定之一就是在这两种不同的方法之间进行选择。并不是说一种解决方案比另一种更好。对于使用`spring-cloud-config-client`工件的任何应用程序，其默认行为在Spring
    Cloud命名法中称为**Config First Bootstrap**。当配置客户端启动时，它会绑定到服务器并使用远程属性源初始化上下文。这种方法在本章的第一个示例中已经介绍过。在第二种解决方案中，Config
    Server向服务发现注册，所有应用程序可以使用`DiscoveryClient`来定位它。这种方法称为**Discovery First Bootstrap**。让我们实现一个示例来阐述这个概念。
- en: Config Server discovery
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务器发现
- en: 'To access that example on GitHub, you need to switch to the `config_with_discovery` branch.
    Here''s the link:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问GitHub上的这个示例，你需要切换到`config_with_discovery`分支。这是链接：
- en: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery)。'
- en: 'The first change is related to the `sample-service-discovery` module. We don’t
    need the `spring-cloud-starter-config` dependency there. The simple configuration
    is not fetched from remote property sources, but set in `bootstrap.yml`. In contrast
    to the previous example, we launch a single standalone Eureka instance in order
    to simplify the exercise:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次更改与`sample-service-discovery`模块有关。在那里我们不需要`spring-cloud-starter-config`依赖。简单的配置不再从远程属性源获取，而是设置在`bootstrap.yml`中。与之前的示例相比，为了简化练习，我们启动一个单一的独立Eureka实例：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By contrast, we should include the `spring-cloud-starter-eureka` dependency
    for the Config Server. Now, the full list of dependencies is shown in the following
    code. Moreover, a discovery client has to be enabled by declaring the `@EnableDiscoveryClient`
    annotation on the main class, and the Eureka Server address should be provided
    by setting the `eureka.client.serviceUrl.defaultZone` property to `http://localhost:8761/eureka/`
    in the `application.yml` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们应该为Config Server包含`spring-cloud-starter-eureka`依赖。现在，依赖关系的完整列表如下所示。此外，必须通过在主类上声明`@EnableDiscoveryClient`注解来启用发现客户端，并且通过在`application.yml`文件中将`eureka.client.serviceUrl.defaultZone`属性设置为`http://localhost:8761/eureka/`来提供Eureka
    Server地址：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On the client application side, it is no longer needed to hold the address
    of the configuration server. The only thing that has to be set is the service
    ID, in case it is different than the Config Server. In accordance with the naming
    convention used for the services in the presented examples, that ID is `config-server`.
    It should be overridden with the `spring.cloud.config.discovery.serviceId` property.
    In order to allow discovery mechanism enable the discovery mechanism to fetch
    remote property sources from the configuration server, we should set `spring.cloud.config.discovery.enabled=true`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端应用程序方面，不再需要持有配置服务器的地址。只需要设置服务ID，以防它与Config Server不同。根据本例中服务命名惯例，该ID是`config-server`。它应该使用`spring.cloud.config.discovery.serviceId`属性覆盖。为了允许发现机制启用发现机制从配置服务器获取远程属性源，我们应该设置`spring.cloud.config.discovery.enabled=true`：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the screen with the Eureka dashboard, with one instance of the Config
    Server and three instances of `client-service` registered. Every instance of the
    client''s Spring Boot application is the same as for the previous example and
    was launched with the `--spring.profiles.active=zone[n]` parameter, where `n`
    is the number of the zone. The only difference is that all of the client''s service
    configuration files served by the Spring Cloud Config Server have the same connection
    address as the Eureka Server:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是带有Config Server的一个实例和三个`client-service`实例注册的Eureka仪表板屏幕。客户端的Spring Boot应用程序的每个实例都与之前的示例相同，并使用`--spring.profiles.active=zone[n]`参数启动，其中`n`是区域编号。唯一不同的是，Spring
    Cloud Config Server提供的所有客户端服务配置文件都有与Eureka Server相同的连接地址：
- en: '![](img/11dbf317-7acc-465c-8714-af1143dd5297.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11dbf317-7acc-465c-8714-af1143dd5297.png)'
- en: Repository backend types
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库后端类型
- en: All of the previous examples in this chapter have used the filesystem backend,
    which means that the config files were loaded from the local filesystem or classpath.
    This type of backend is very good for tutorial purposes or for testing. If you
    would like to use Spring Cloud Config in production, it is worth considering the
    other options. The first of them is a repository backend based on Git, which is
    also enabled by default. It is not the only one **version control system** (**VCS**)
    that can be used as a repository for configuration sources. The other option is
    SVN, or we can even decide to create a composite environment, which may consist of
    both Git and SVN repositories. The next supported backend type is based on a tool
    provided by HashiCorp, Vault. It is especially useful when managing security properties
    such as passwords or certificates. Let's take a closer look at each of the solutions
    listed here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中前面的所有示例都使用了文件系统后端，这意味着配置文件是从本地文件系统或类路径中加载的。这种后端对于教程目的或测试来说非常不错。如果你想在生产环境中使用Spring
    Cloud Config，考虑其他选项是值得的。这些选项中的第一个是基于Git的仓库后端，它也是默认启用的。它不是唯一一个可以用作配置源仓库的**版本控制系统**（**VCS**）。另一个选项是SVN，或者我们可以决定创建一个复合环境，这可能包括Git和SVN仓库。下一个支持的后端类型是基于HashiCorp提供的工具Vault。当管理诸如密码或证书的安全属性时，它特别有用。让我们更详细地看看这里列出的每个解决方案。
- en: Filesystem backend
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统后端
- en: I won't write a lot about this topic, because it has already been discussed
    in the previous examples. All of them have shown how to store property sources
    in the classpath. There is also the ability to load them from disk. By default,
    the Spring Cloud Config Server tries to locate files inside an application's working
    directory or the config subdirectory at this location. We can override the default
    location with the `spring.cloud.config.server.native.searchLocations` property.
    The search location path may contain placeholders for `application`, `profile`,
    and `label`. If you don't use any placeholders in the location path, the repository
    automatically appends the label parameter as a suffix.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会写太多关于这个主题的内容，因为已经在之前的示例中讨论过了。它们都展示了如何将属性源存储在类路径中。还有从磁盘加载它们的能力。默认情况下，Spring
    Cloud Config Server尝试在应用程序的工作目录或此位置的config子目录内定位文件。我们可以使用`spring.cloud.config.server.native.searchLocations`属性来覆盖默认位置。搜索位置路径可能包含`application`、`profile`和`label`的占位符。如果在位置路径中不使用任何占位符，仓库会自动将标签参数作为后缀添加。
- en: As a consequence, the configuration files are loaded from each search location
    and a subdirectory with the same name as the label. For example, `file:/home/example/config`
    is the same as `file:/home/example/config,file:/home/example/config/{label}`.
    This behavior may be disabled by setting `spring.cloud.config.server.native.addLabelLocations`
    to `false`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，配置文件从每个搜索位置和与标签同名的子目录中加载。例如，`file:/home/example/config`与`file:/home/example/config,file:/home/example/config/{label}`相同。可以通过将`spring.cloud.config.server.native.addLabelLocations`设置为`false`来禁用这种行为。
- en: As I have already mentioned, a filesystem backend is not a good choice for a
    production deployment. If you place property sources in a classpath inside a JAR
    file, every change requires a recompilation of the application. On the other hand,
    using a filesystem outside of a JAR does not need recompilation, but this approach
    may be troublesome if you have more than one instance of a config service working
    in a high availability mode. In that case, share the filesystem across all of
    the instances or hold a copy of all of the property sources per running instance.
    The Git backend is free from such disadvantages, and that's why it is recommended
    for production use.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我前面所提到的，文件系统后端不是生产部署的好选择。如果你将属性源放在JAR文件内的类路径中，每次更改都需要重新编译应用程序。另一方面，在JAR之外使用文件系统不需要重新编译，但如果你有多个实例的配置服务在高级可用性模式下工作，这种方法可能会有麻烦。在这种情况下，将文件系统跨所有实例共享或将每个运行实例的属性源副本保留。Git后端免除了这些缺点，这就是为什么它推荐用于生产环境的原因。
- en: Git backend
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git后端
- en: The Git version control system has some features that make it very useful as
    a repository for property sources. It allows you to easily manage and audit changes.
    By using well-known VCS mechanisms such as commit, revert, and branching, we can
    perform important operations a lot easier than in a filesystem approach. This
    type of backend also has another two key advantages. It forces a separation between
    the Config Server source code and the `property` files repository. If you take
    a look one more time at the previous examples, you will see that the `property`
    files were stored together with the application source code. Probably some of
    you would say that even if we used a filesystem backend, we can store the whole
    configuration as a separate project on Git and upload it to a remote server on
    demand. Of course, you would be right. But when using a Git backend with the Spring
    Cloud Config, you have those mechanisms available out of the box. In addition,
    it resolves the problems related to running multiple instances of the server.
    If you use a remote Git server, the changes may be easily shared across all of
    the running instances.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Git版本控制系统有一些功能使其作为属性源的仓库非常有用。它允许你轻松地管理和审计更改。通过使用众所周知的版本控制机制，如提交、回滚和分支，我们可以比文件系统方法更容易地执行重要的操作。这种后端还有另外两个关键优势。它强制将配置服务器源代码和`property`文件仓库分开。如果你再次查看之前的示例，你会发现`property`文件与应用程序源代码一起存储。也许有些人会说，即使我们使用文件系统后端，也可以将整个配置作为单独的项目存储在Git中，并在需要时上传到远程服务器上。当然，你的观点是正确的。但是，当使用与Spring
    Cloud Config结合的Git后端时，你可以直接获得这些机制。此外，它还解决了与运行服务器多个实例相关的问题。如果你使用远程Git服务器，更改可能很容易在所有运行实例之间共享。
- en: Different protocols
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的协议
- en: To set the location of the Git repository for the application, we should use
    the `spring.cloud.config.server.git.uri` property in `application.yml`. If you
    are familiar with Git, you well know that cloning may be realized using file,
    http/https, and ssh protocols. The local repository access allows you to get started
    quickly without a remote server. It is configured with file, prefix, for example,
    `spring.cloud.config.server.git.uri=file:/home/git/config-repo`. For more advanced
    usage when running Config Server in the high availability mode, you should use
    the remote protocols SSH or HTTPS. In this case, Spring Cloud Config clones a
    remote repository and then bases it on the local working copy as a cache.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要为应用程序设置Git仓库的位置，我们应该在`application.yml`中使用`spring.cloud.config.server.git.uri`属性。如果你熟悉Git，你就会知道克隆可以通过文件、http/https和ssh协议来实现。本地仓库访问允许你快速开始，而不需要远程服务器。它使用文件、前缀进行配置，例如，`spring.cloud.config.server.git.uri=file:/home/git/config-repo`。当在高级可用性模式下运行Config
    Server时，你应该使用远程协议SSH或HTTPS。在这种情况下，Spring Cloud Config克隆远程仓库，然后基于本地工作副本作为缓存。
- en: Using placeholders in URIs
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在URI中使用占位符
- en: All the recently listed placeholders, `application`, `profile`, and `label`,
    are also supported here. We can create a single repository per application using
    a placeholder as in `https://github.com/piomin/{application}`, or even per profile, `https://github.com/piomin/{profile}`.
    This type of backend implementation maps the label parameter of the HTTP resource
    to a Git label, which may refer to commit ID, branch, or tag name. The most appropriate
    way to discover interesting features for us is obviously through an example. Let's
    begin by creating a Git repository dedicated to storing the application's property
    sources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里支持所有最近列出的占位符，`application`、`profile`和`label`。我们可以使用占位符为每个应用程序创建一个单一仓库，如`https://github.com/piomin/{application}`，甚至可以为每个配置文件创建，`https://github.com/piomin/{profile}`。这种后端实现将HTTP资源的label参数映射到Git标签，可能指的是提交ID、分支或标签名。显然，发现对我们感兴趣的功能的最合适方式是通过一个示例。让我们先通过创建一个用于存储应用程序属性源的Git仓库开始。
- en: Building a server application
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务器应用程序
- en: 'I created an example configuration repository, which is available on GitHub
    here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个示例配置仓库，您可以在GitHub上在此处找到它：
- en: '[https://github.com/piomin/sample-spring-cloud-config-repo.git](https://github.com/piomin/sample-spring-cloud-config-repo.git).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://github.com/piomin/sample-spring-cloud-config-repo.git](https://github.com/piomin/sample-spring-cloud-config-repo.git)。
- en: 'I placed all of the property sources used in the first example in this chapter,
    which illustrated native profile support for client applications running in different
    discovery zones. Now, our repository holds the files visible in this list:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我将本章中使用的所有属性源放在了这里，这些示例展示了客户端应用程序在不同发现区域对本地配置文件的支持。现在，我们的仓库包含了此列表中可见的文件：
- en: '![](img/d2b06957-1a0d-4f84-ade1-8637cdc7d591.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2b06957-1a0d-4f84-ade1-8637cdc7d591.png)'
- en: 'The Spring Cloud Config Server by default tries to clone a repository after
    the first HTTP resource call. If you would like to force cloning it after startup,
    you should set the `cloneOnStart` property to `true`. Beyond this, it is required
    to set the repository connection settings and the account authentication credentials:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Cloud Config Server在第一次HTTP资源调用后尝试克隆一个仓库。如果你想在启动后强制克隆，你应该将`cloneOnStart`属性设置为`true`。此外，还需要设置仓库连接设置和账户认证凭据：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After running the server, we can call the endpoints known from the previous
    exercises, for example, `http://localhost:8889/client-service/zone1` or `http://localhost:8889/client-service-zone2.yml`.
    The result would be the same as for the earlier tests; the only difference is
    in the data source. Now, let's perform another exercise. As you probably remember,
    we had to change the client's properties a little when we created the example
    with discovery first bootstrap with the `native` profile enabled. Because right
    now we are using a Git backend, we can develop a smarter solution for that case.
    In the current approach, we would create `discovery` branch ([https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery](https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery))
    at our configuration repository on GitHub, and we would place the files dedicated
    to the application illustrating the discovery first bootstrap mechanism. If you
    call the Config Server endpoints with the `label` parameter set to `discovery`,
    you will fetch data from our new branch. Try to call `http://localhost:8889/client-service/zone1/discovery`
    and/or `http://localhost:8889/discovery/client-service-zone2.yml` and check the
    result*. *
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器运行后，我们可以调用之前练习中已知端点，例如`http://localhost:8889/client-service/zone1`或`http://localhost:8889/client-service-zone2.yml`。结果与早期测试相同；唯一不同的是数据源。现在，让我们进行另一个练习。正如您可能记得的，当我们首先使用`native`配置文件启用发现引导时，我们必须稍微更改客户端的属性。因为现在我们使用的是Git后端，我们可以为这种情况开发一个更聪明的解决方案。在当前方法中，我们将在GitHub上的配置仓库中创建`discovery`分支（[https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery](https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery)），并将专为应用程序演示发现首先引导机制的文件放置在此分支上。如果您用`label`参数设置为`discovery`调用Config
    Server端点，您将获取我们新分支的数据。尝试调用`http://localhost:8889/client-service/zone1/discovery`和/或`http://localhost:8889/discovery/client-service-zone2.yml`并检查结果*.*
- en: 'Let''s consider another situation. I changed the server port for the third
    instance of `client-service`, but for some reason I would like to move back to
    the previous value. Do I have to change and commit `client-service-zone3.yml`
    with the previous port value? No, all I have to do is to pass the commit ID as
    a `label` parameter while calling the HTTP API resource. The change performed is
    illustrated in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一种情况。我更改了 `client-service` 第三实例的服务器端口，但出于某种原因，我想恢复到以前的价值。我必须更改并提交 `client-service-zone3.yml`
    以使用以前的端口值吗？不用，我只需要在调用 HTTP API 资源时传递 `label` 参数即可。下面截图展示了所执行的更改：
- en: '![](img/b6069696-66ed-4ace-bfda-741529faf834.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6069696-66ed-4ace-bfda-741529faf834.png)'
- en: 'If I invoke the API endpoint with the parent commit ID instead of branch name,
    the older port number would be returned as a response. Here''s the result of calling `http://localhost:8889/e546dd6/client-service-zone3.yml`,
    where `e546dd6` is the previous commit ID:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我用父提交 ID 调用 API 端点而不是分支名，那么会返回较旧的端口号作为响应。以下是调用 `http://localhost:8889/e546dd6/client-service-zone3.yml`
    的结果，其中 `e546dd6` 是之前的提交 ID：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Client-side configuration
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端配置
- en: 'While building the server side with a Git backend, I have only shown you examples
    of HTTP resource calls.  Here''s the example configuration for the client''s application.
    Instead of setting the `profile` property inside `bootstrap.yml`, we may also
    pass it in the `spring.profiles.active` running parameter. This configuration
    makes the client fetch properties from the `discovery` branch. We may also decide
    to switch to a certain commit ID by setting it in the `label` property, as I have
    already mentioned:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在用 Git 后端构建服务器端时，我仅向您展示了 HTTP 资源调用的例子。以下是客户端应用程序的配置示例。我们不仅可以设置 `bootstrap.yml`
    中的 `profile` 属性，还可以在 `spring.profiles.active` 运行参数中传递它。这个配置使得客户端从 `discovery`
    分支获取属性。我们还可以通过在 `label` 属性中设置某个提交 ID 来决定切换到某个提交 ID，正如我刚才已经提到的：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Multiple repositories
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个仓库
- en: 'Sometimes, you may need to configure multiple repositories for a single Config
    Server. I can imagine the situation that you would have to separate the business
    configuration from a typical technical configuration. This is absolutely possible:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要为单个 Config Server 配置多个仓库。我可以想象到您需要将业务配置从典型的技术配置中分离出来的情况。这是完全可能的：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Vault backend
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vault 后端
- en: 'I have already mentioned Vault as a tool for securely accessing secrets through
    a unified interface. In order to enable the Config Server to use that type of
    backend, you must run it with the Vault profile `--spring.profiles.active=vault`.
    Of course, before running the Config Server you need to install and launch the
    Vault instance. I suggest you use Docker for this. I know that this is our first
    contact with Docker in this book, and not everyone has knowledge of that tool.
    I have provided a short introduction to Docker, its basic commands, and use cases
    in [Chapter 14](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml)*, Docker Support*.
    So, if this is your first contact with that technology, please first take a look
    at that introduction. For those of you who are familiar with Docker, here''s the
    command for running a Vault container in development mode. We may override the
    default listen address with the `VAULT_DEV_LISTEN_ADDRESS` parameter or the ID
    of the initial generated root token with the `VAULT_DEV_ROOT_TOKEN_ID` parameter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了 Vault 作为一个通过统一接口安全访问密钥的工具。为了使 Config Server 使用这种类型的后端，您必须使用 Vault 配置文件
    `--spring.profiles.active=vault` 运行它。当然，在运行 Config Server 之前，您需要安装并启动 Vault 实例。我建议您使用
    Docker 来做这件事。我知道这是本书中第一次接触 Docker，并不是每个人都熟悉这个工具。我在[第 14 章](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml)*，Docker
    支持*中提供了 Docker 的简要介绍，包括其基本命令和用例。所以，如果您是第一次接触这项技术，请先查看这个介绍。对于那些熟悉 Docker 的同学，这里是在开发模式下运行
    Vault 容器的命令。我们可以使用 `VAULT_DEV_LISTEN_ADDRESS` 参数或初始生成的根令牌 ID 覆盖默认监听地址：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Getting started with Vault
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Vault
- en: 'Vault provides a command line interface, which may be used for adding new values
    to the server and reading them from the server. Examples of calling those commands
    are shown here. However, we have run Vault as a Docker container, so the most
    convenient way to manage the secrets is through the HTTP API:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 提供了一个命令行界面，可用于向服务器添加新值和从服务器读取它们。下面展示了调用这些命令的示例。然而，我们已经以 Docker 容器的形式运行了
    Vault，所以最方便管理密钥的方式是通过 HTTP API：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The HTTP API is available for our instance of Vault under the `http://192.168.99.100:8200/v1/secret` address.
    When calling every method of that API, you need to pass a token as the request
    header `X-Vault-Token`. Because we set that value in the `VAULT_DEV_ROOT_TOKEN_ID`
    environment parameter while launching a Docker container, it is equal to `client`.
    Otherwise, it would be automatically generated during startup and may be read
    from logs by invoking the command `docker logs vault`. To start working with Vault,
    we in fact need to be aware of two HTTP methods—`POST` and `GET`. When calling
    the `POST` method, we may define the list of secrets that should be added to the
    server. The parameters passed in the `curl` command shown here are created using
    the kv backend, which acts like a key/value store:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Vault在我们实例中的HTTP API可以通过`http://192.168.99.100:8200/v1/secret`地址进行访问。调用该API的每一个方法时，你需要传递一个令牌作为请求头`X-Vault-Token`。因为我们启动Docker容器时在`VAULT_DEV_ROOT_TOKEN_ID`环境变量中设置了这个值，所以它等于`client`。否则，在启动过程中会自动生成，并且可以通过调用命令`docker
    logs vault`从日志中读取。实际上，要与Vault一起工作，我们需要了解两种HTTP方法——`POST`和`GET`。调用`POST`方法时，我们可以定义应该添加到服务器的密钥列表。这里所示的`curl`命令中的参数是使用kv后端创建的，它像一个键/值存储器：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The newly added values may be read from the server by using the `GET` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 新添加的值可以通过使用`GET`方法从服务器读取：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Integration with Spring Cloud Config
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Spring Cloud Config集成
- en: 'As I have mentioned before, we have to run the Spring Cloud Config Server with
    the `--spring.profiles.active=vault` parameter to enable Vault as a backend store.
    To override the default auto configured settings, we should define the properties
    under the `spring.cloud.config.server.vault.*` key. The current configuration
    for our example application is shown here. An example application is available
    on GitHub; you need to switch to the `config_vault` branch ([https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault))
    to access it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们必须使用`--spring.profiles.active=vault`参数运行Spring Cloud Config Server，以启用Vault作为后端存储。为了覆盖默认的自动配置设置，我们应该在`spring.cloud.config.server.vault.*`键下定义属性。我们示例应用程序的当前配置如下所示。一个示例应用程序可以在GitHub上找到；你需要切换到`config_vault`分支([https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault))来访问它：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you may call the endpoint exposed by the Config Server. You have to pass
    the token in the request header, but this time its name is `X-Config-Token`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以调用Config Server暴露的端点。你必须在上传请求头中传递令牌，但这次它的名称是`X-Config-Token`：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The response should be the same as what is shown next. These properties are
    the default for all of the profiles of the client application. You may also add
    specific settings for the selected profile by calling the Vault HTTP `API` method
    with the profile name after a comma character, like this, `http://192.168.99.100:8200/v1/secret/client-service,zone1`. If
    such a profile name is included in the calling path, the properties for both the
    `default` and `zone1` profiles are returned in the response:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应该与下面显示的相同。这些属性是客户端应用程序所有配置文件的全局默认值。你也可以通过在Vault HTTP `API`方法中调用带有逗号字符的选定配置文件名称来为选定的配置文件添加特定设置，如下所示，`http://192.168.99.100:8200/v1/secret/client-service,zone1`。如果调用路径中包含了这样的配置文件名称，响应中会返回`default`和`zone1`配置文件的所有属性：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Client-side configuration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端配置
- en: 'When using Vault as a backend to your Config Server, the client will need to
    pass a token for the server to be able to retrieve values from Vault. This token
    should be provided in the client configuration settings with the `spring.cloud.config.token`
    property in the `bootstrap.yml` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Vault作为Config Server的后端时，客户端需要传递一个令牌，以便服务器能够从Vault检索值。这个令牌应该在客户端配置设置中提供，在`bootstrap.yml`文件中的`spring.cloud.config.token`属性：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Additional features
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外特性
- en: Let's take a look at some other useful features of the Spring Cloud Config.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Spring Cloud Config的一些其他有用特性。
- en: Fail on start and retry
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动失败并重试
- en: Sometimes it doesn't make any sense to launch the application if the Config
    Server is unavailable. In this case, we would like to halt a client with an exception.
    To achieve this, we have to set the bootstrap configuration property `spring.cloud.config.failFast`
    to `true`. Such a radical solution is not always the desired behavior. If a Config
    Server is unreachable only occasionally, the better approach would be to keep
    trying to reconnect until it succeeds. The `spring.cloud.config.failFast` property still
    has to be equal to `true`, but we would also need to add the `spring-retry` library
    and `spring-boot-starter-aop` to the application classpath. The default behavior
    assumes to retry six times with an initial backoff interval of 1000 milliseconds. You
    may override these settings by using the `spring.cloud.config.retry.*` configuration
    properties.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时如果Config Server不可用，启动应用程序就没有任何意义。在这种情况下，我们希望能够用异常停止客户端。为了实现这一点，我们必须将引导配置属性`spring.cloud.config.failFast`设置为`true`。这种激进的解决方案并不总是期望的行为。如果Config
    Server只是偶尔不可达，更好的方法是在成功之前一直尝试重新连接。`spring.cloud.config.failFast`属性仍然必须等于`true`，但我们还需要在应用程序类路径中添加`spring-retry`库和`spring-boot-starter-aop`。默认行为假设重试六次，初始退避间隔为1000毫秒。您可以使用`spring.cloud.config.retry.*`配置属性覆盖这些设置。
- en: Secure client
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护客户端
- en: 'The same as for the service discovery, we may secure the Config Server with
    basic authentication. It can be easily enabled on the server side with Spring
    Security. In that case, all the client needs to set is the username and password
    in the `bootstrap.yml` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务发现一样，我们可以通过基本认证来保护Config Server。使用Spring Security可以在服务器端轻松启用。在这种情况下，客户端只需要在`bootstrap.yml`文件中设置用户名和密码：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Reload configuration automatically
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动重新加载配置
- en: We have already discussed the most important features of Spring Cloud Config.
    At that point, we implemented examples illustrating how to use different backend
    storage as a repository. But no matter whether we decided to choose filesystem,
    Git, or Vault, our client-side application needed to restart to be able to fetch
    the newest configuration from the server. However, sometimes this is not an optimal
    solution, especially if we have many microservices running and some of them use
    the same generic configuration.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Spring Cloud Config最重要的特性。在那一刻，我们实现了示例，说明如何使用不同的后端存储作为存储库。但是，无论我们决定选择文件系统、Git还是Vault，我们的客户端应用程序都需要重新启动，才能从服务器获取最新的配置。然而，有时这并不是一个最优的解决方案，尤其是如果我们有许多微服务在运行，其中一些使用相同的通用配置。
- en: Solution architecture
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案架构
- en: Even if we created a dedicated `property` file per single application, an opportunity
    to dynamically reload it without restart could be very helpful. As you may have
    deduced, such a solution is available for Spring Boot and therefore for Spring
    Cloud. In [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*
    while describing deregistration from the service discovery server, I introduced
    an endpoint, `/shutdown`, which may be used for gracefully shutting down. There
    is also an endpoint available for Spring context restart, which works in a similar
    way to that for shutdown.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们为每个单一的应用程序创建了一个专用的`property`文件，动态地重新加载它而不重新启动的机会也非常有帮助。正如您可能已经推断出的那样，这样的解决方案对Spring
    Boot和因此对Spring Cloud都是可用的。在[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)，*服务发现*中，在介绍从服务发现服务器注销时，我引入了一个端点`/shutdown`，可以用于优雅地关闭。还有一个用于Spring上下文重启的端点，其工作方式与关闭相似。
- en: 'An endpoint on the client side is just one component of the much larger system
    that needs to be included to enable push notifications for the Spring Cloud Config. The
    most popular source code repository providers, such as GitHub, GitLab, and Bitbucket,
    are able to send notifications about changes in a repository by providing a WebHook
    mechanism. We may configure the WebHook using the provider''s web dashboard as
    a URL and a list of selected event types. Such a provider will call the `POST`
    method defined in the WebHook with a body containing a list of commits. It is
    required to include a Spring Cloud Bus dependency in the project to enable the
    monitor endpoint on the Config Server side. When this endpoint is invoked as a
    result of the WebHook activation, a Config Server prepares and sends an event
    with a list of property sources that has been modified by the last commit. That
    event is sent to a message broker. The Spring Cloud Bus provides implementations
    for RabbitMQ and Apache Kafka. The first may be enabled for the project by including
    the `spring-cloud-starter-bus-amqp` dependency, and the second by including the `spring-cloud-starter-bus-kafka`
    dependency. Those dependencies should also be declared for a client application
    to enable receiving messages from a message broker. We should also enable the
    dynamic refresh mechanism on the client side by annotating the selected configuration
    class with `@RefreshScope`. An architecture of this solution is shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端端的端点只是需要包含以使Spring Cloud Config支持推送通知的更大系统中的一个组件。最受欢迎的源代码仓库提供商，如GitHub、GitLab和Bitbucket，通过提供WebHook机制，能够发送有关仓库中变化的通知。我们可以通过提供商的网页控制台，以URL和选择的事件类型列表来配置WebHook。这样的提供商将通过调用WebHook中定义的`POST`方法，发送包含提交列表的正文。在Config
    Server端启用监控端点需要在项目中包含Spring Cloud Bus依赖。当由于WebHook的激活而调用此端点时，Config Server会准备并发送一个事件，其中包含由最后提交修改的属性源列表。该事件被发送到消息代理。Spring
    Cloud Bus为RabbitMQ和Apache Kafka提供了实现。第一个可以通过包含`spring-cloud-starter-bus-amqp`依赖项启用于项目，第二个可以通过包含`spring-cloud-starter-bus-kafka`依赖项启用于项目。这些依赖项还应该在客户端应用程序中声明，以使能够从消息代理接收消息。我们还可以通过在选择的配置类上使用`@RefreshScope`注解来启用客户端端的动态刷新机制。该解决方案的架构示例如下：
- en: '![](img/f0318c08-6af4-40fc-a44a-e1b8885e6a01.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0318c08-6af4-40fc-a44a-e1b8885e6a01.png)'
- en: Reload configuration with @RefreshScope
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@RefreshScope刷新配置
- en: 'This time we will start unusually from the client side. The example application
    is available on GitHub ([https://github.com/piomin/sample-spring-cloud-config-bus.git](https://github.com/piomin/sample-spring-cloud-config-bus.git)).
    The same as the previous examples, it uses a Git repository as backend storage,
    which is also created on GitHub ([https://github.com/piomin/sample-spring-cloud-config-repo](https://github.com/piomin/sample-spring-cloud-config-repo)).
    I added some new properties to the client''s configuration file and committed
    changes to the repository. Here''s the current version of the client''s configuration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将从客户端端开始，这很不寻常。示例应用程序可以在GitHub上找到([https://github.com/piomin/sample-spring-cloud-config-bus.git](https://github.com/piomin/sample-spring-cloud-config-bus.git))。与之前的示例一样，它使用Git仓库作为后端存储，该仓库也是在大GitHub上创建的([https://github.com/piomin/sample-spring-cloud-config-repo](https://github.com/piomin/sample-spring-cloud-config-repo))。我在客户端的配置文件中添加了一些新属性，并将更改提交到仓库。以下是客户端当前配置的版本：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I disabled security for Spring Boot Actuator endpoints by setting `management.security.enabled`
    to `false`. It is required to be able to call those endpoints without passing
    security credentials. I also added two test parameters, `sample.string.property`
    and `sample.int.property`, to demonstrate bean refresh mechanisms based on their
    values in the example. Spring Cloud provides some additional HTTP management endpoints
    for the Spring Boot Actuator. One of them is `/refresh`, which is responsible
    for reloading the bootstrap context and refreshing beans annotated with `@RefreshScope`.
    This is an HTTP `POST` method, which may be called on our client''s instance at `http://localhost:8081/refresh`.
    Before testing that functionality, we need to have the discovery and Config Servers
    running. The client application should be launched with the `--spring.profiles.active=zone1 `parameter.
    Here''s the class where the test properties `sample.string.property` and `sample.int.property`
    are injected into the fields:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`management.security.enabled`设置为`false`，我禁用了Spring Boot Actuator端点的Security。这样我们就可以调用这些端点，而无需传递安全凭据。我还添加了两个测试参数，`sample.string.property`和`sample.int.property`，以演示基于它们值的重试机制在示例中。Spring
    Cloud为Spring Boot Actuator提供了一些额外的HTTP管理端点。其中之一是`/refresh`，它负责重新加载引导上下文和刷新注解为`@RefreshScope`的bean。这是一个HTTP
    `POST`方法，可以在`http://localhost:8081/refresh`的客户端实例上调用。在测试该功能之前，我们需要使发现和Config Servers运行。客户端应用程序应该使用`--spring.profiles.active=zone1`参数启动。下面是测试属性`sample.string.property`和`sample.int.property`被注入到字段中的类：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That bean is injected into the `ClientController` class and invoked inside
    the `ping` method, which is exposed at `http://localhost:8081/ping`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个bean被注入到`ClientController`类中，并在`ping`方法中调用，该方法在`http://localhost:8081/ping`上暴露：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s change the values for test properties in `client-service-zone1.yml`
    and commit them. If you call the Config Server HTTP endpoint `/client-service/zone1`,
    you''ll see the newest values returned as a response. But when you call the `/ping`
    method exposed on the client application, you will still see older values visible
    on the left side of the following screen. Why? Although the Config Server automatically
    detects repository changes, the client application is not able to automatically
    refresh without any trigger. It requires a restart to read the newest settings,
    or we may force a configuration reload by invoking the previously described `/refresh`
    method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改`client-service-zone1.yml`中的测试属性值并提交它们。如果你调用Config Server HTTP端点`/client-service/zone1`，你将看到最新的值作为响应返回。但是，当你调用客户端应用程序上暴露的`/ping`方法时，你仍然会看到以下屏幕左侧显示的较旧值。为什么？尽管Config
    Server可以自动检测仓库更改，但客户端应用程序没有触发器是无法自动刷新的。它需要重启以读取最新的设置，或者我们可以通过调用前面描述的`/refresh`方法强制重新加载配置：
- en: '![](img/49a8d206-7a6b-4477-8b85-40b5427c13f9.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49a8d206-7a6b-4477-8b85-40b5427c13f9.png)'
- en: 'After calling the `/refresh` endpoint on the client application, you will see
    in the log files that the configuration has been reloaded. Now, if you invoke
    `/ping` one more time, the newest property values are returned in the response.
    That example illustrates how a hot reload works for a Spring Cloud application,
    but it is obviously not our target solution. The next step is to enable communication
    with the message broker:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端应用程序上调用`/refresh`端点后，你将在日志文件中看到配置已重新加载。现在，如果你再调用一次`/ping`，最新的属性值将返回在响应中。这个例子说明了Spring
    Cloud应用程序的热重载是如何工作的，但它显然不是我们的目标解决方案。下一步是启用与消息代理的通信：
- en: '![](img/7c79dd98-0c3d-45ae-a736-678d2cec1cb1.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c79dd98-0c3d-45ae-a736-678d2cec1cb1.png)'
- en: Consuming events from a message broker
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从消息代理中消费事件
- en: I have already mentioned that we may choose between two message brokers that
    are integrated with the Spring Cloud Bus. In this example, I'm going to show you
    how to run and use RabbitMQ. Let me just say a few words about that solution,
    because we are dealing with it for the first time in the book. RabbitMQ has grown
    into the most popular message broker software. It is written in Erlang and implements
    **Advanced Message Queueing Protocol** (**AMQP**). It is easy to use and configure,
    even if we are talking about such mechanisms as clustering or high availability.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到，我们可以选择两种与Spring Cloud Bus集成的消息代理。在这个例子中，我将向你展示如何运行和使用RabbitMQ。让我简单说一下这个解决方案，因为这是我们书中第一次接触到它。RabbitMQ已经成为最受欢迎的消息代理软件。它用Erlang编写，实现了**高级消息队列协议**
    (**AMQP**)。即使我们谈论的是如集群或高可用性这样的机制，它也易于使用和配置。
- en: 'The most convenient way to run RabbitMQ on your machine is through a Docker
    container. Two ports have been exposed outside the container. The first of them
    is used for client connections (`5672`) and the second is dedicated to the management
    dashboard (`15672`). I also ran the image with the management tag to enable the
    UI dashboard, which is not available in the default version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的机器上运行RabbitMQ最方便的方式是通过一个Docker容器。有两个端口已经暴露在容器外。第一个用于客户端连接（`5672`）第二个专用于管理仪表板（`15672`）。我还用管理标签运行了镜像以启用UI仪表板，这在默认版本中是不可用的：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To enable support for the RabbitMQ broker for our example client application,
    we should include the following dependency in `pom.xml`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持我们的示例客户端应用程序的RabbitMQ代理，我们应该在`pom.xml`中包含以下依赖项：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That library contains auto-configuration settings. Because I run Docker on
    Windows, I need to override some default properties. The full service configuration
    is stored inside a Git repository, so the changes affect only remote files. We
    should add the following parameters to the previously used version of the client''s
    property source:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那个库包含了自动配置设置。因为我是在Windows上运行Docker，所以我需要覆盖一些默认属性。完整的服务配置存储在一个Git仓库中，所以更改只影响远程文件。我们应该在之前使用的客户端属性源中添加以下参数：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you run the client application, an exchange and a queue would be automatically
    created in RabbitMQ. You can easily check this out by logging in to the management
    dashboard available at `http://192.168.99.100:15672`. The default username and
    password are `guest/guest`. Here''s the screen from my RabbitMQ instance. There
    is one exchange with the name `SpringCloudBus` created, with two bindings to the
    client queue and Config Server queue (I have already run it with the changes described
    in the next section). At this stage, I wouldn''t like to go into the detail about
    RabbitMQ and its architecture. A good place for such a discussion would be in
    the [Chapter 11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message-Driven
    Microservices* on the Spring Cloud Stream project:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行客户端应用程序，RabbitMQ会自动创建一个交换区和一个队列。你可以通过登录到位于`http://192.168.99.100:15672`的管理仪表板轻松查看这一点。默认的用户名和密码是`guest/guest`。以下是来自我RabbitMQ实例的屏幕截图。有一个名为`SpringCloudBus`的交换区被创建，与客户端队列和Config
    Server队列有两个绑定（我已经运行了下一节描述的更改）。在这个阶段，我不想深入了解RabbitMQ及其架构的细节。这样的讨论的好地方将是Spring Cloud
    Stream项目的[第11章](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml)，*消息驱动的微服务*：
- en: '![](img/c29e1292-6fa9-412f-812f-c60bb2ab2033.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c29e1292-6fa9-412f-812f-c60bb2ab2033.png)'
- en: Monitoring repository changes on a Config Server
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控Config Server上的仓库更改
- en: 'Spring Cloud Config Server has to perform two tasks in the previously described
    process. First of all, it has to detect changes in a `property` file stored in
    a Git repository. This may be achieved by exposing a special endpoint, which would
    be called through a WebHook by the repository provider. The second step is to
    prepare and send a `RefreshRemoteApplicationEvent` targeted at the applications
    that might have been changed.  This in turn requires us to establish connection
    with a message broker. The `spring-cloud-config-monitor` library is responsible
    for enabling the `/monitor` endpoint. To enable support for the RabbitMQ broker,
    we should include the same starter artifact as for the client application:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server在前面描述的过程中必须执行两项任务。首先，它必须检测存储在Git仓库中的`property`文件的变化。这可能通过暴露一个特殊的端点来实现，该端点将通过WebHook由仓库提供商调用。第二步是准备并向可能已更改的应用程序发送一个`RefreshRemoteApplicationEvent`。这需要我们建立与消息代理的连接。`spring-cloud-config-monitor`库负责启用`/monitor`端点。为了支持RabbitMQ代理，我们应该包含与客户端应用程序相同的启动工件：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That''s not all. The configuration monitor should also be activated in `application.yml`.
    Because each repository provider has a dedicated implementation in Spring Cloud,
    it is necessary to select which of them should be enabled:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此。配置监视器还应在`application.yml`中激活。因为每个仓库提供商在Spring Cloud中都有专门的实现，所以有必要选择哪个应该被启用：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The change detection mechanism may be customized. By default, it detects changes
    in files that match the application name. To override that behavior, you need
    to provide a custom implementation of `PropertyPathNotificationExtractor`. It
    accepts the request headers and body parameters, and returns a list of file paths
    that have been changed. To support notifications from GitHub, we may use `GithubPropertyPathNotificationExtractor`
    provided by `spring-cloud-config-monitor`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 更改检测机制可以自定义。默认情况下，它检测与应用程序名称匹配的文件中的更改。要覆盖此行为，你需要提供一个自定义的`PropertyPathNotificationExtractor`实现。它接受请求头和正文参数，并返回一个已更改的文件路径列表。为了支持来自GitHub的通知，我们可以使用`spring-cloud-config-monitor`提供的`GithubPropertyPathNotificationExtractor`：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Simulating change events manually
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动模拟更改事件
- en: 'A monitor endpoint can be invoked by a WebHook configured on a Git repository
    provider such as GitHub, Bitbucket, or GitLab. Testing such a feature with the
    application running on localhost is troublesome. It turns out that we may easily
    simulate such a WebHook activation by calling `POST /monitor` manually. For example,
    the `Github` command should have the header `X-Github-Event` included in the request.
    The JSON body with changes in the `property` files should look as shown in this
    cURL request:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 监控端点可以通过配置在Git仓库提供商（如GitHub、Bitbucket或GitLab）上的WebHook来调用。在本地主机上运行的应用程序测试这种功能是麻烦的。结果是我们可以通过手动调用`POST
    /monitor`来轻松模拟这种WebHook的激活。例如，`Github`命令应该在请求中包含`X-Github-Event`头。带有`property`文件中更改的JSON体应该如下所示：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, let's change and commit a value of one property in the `client-service-zone1.yml`
    file, for example, `sample.int.property`. Then, we may call the `POST /monitor`
    method with the parameters shown in the previous example command. If you configured
    everything according to my descriptions, you should  see the following log line
    on your client application side, `Received remote refresh request. Keys refreshed
    [sample.int.property]`. If you call the `/ping` endpoint exposed by the client
    microservice, it should return the newest value of the changed property.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改并提交`client-service-zone1.yml`文件中的一个属性值，例如`sample.int.property`。然后，我们可以使用前一个示例命令中显示的参数调用`POST
    /monitor`方法。如果你根据我的描述配置了所有内容，你应该在客户端应用程序侧看到以下日志行`Received remote refresh request.
    Keys refreshed [sample.int.property]`。如果你调用客户端微服务暴露的`/ping`端点，它应该返回更改属性的最新值。
- en: Testing locally with a GitLab instance
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitLab实例在本地测试
- en: 'For those who do not prefer simulating events, I''m proposing a more practical
    exercise. However, I would point out that it requires not only development skills
    from you, but also a basic knowledge of Continuous Integration tools. We will
    start by running a GitLab instance locally using its Docker image. GitLab is an
    open sourced web-based Git repository manager with wiki and issue tracking features.
    It is very similar to such tools as GitHub or Bitbucket, but may be easily deployed
    on your local machine:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不喜欢模拟事件的人来说，我提出一个更实用的练习。然而，我要指出这不仅需要你的开发技能，还需要对持续集成工具的基本了解。我们将从使用GitLab的Docker镜像在本地运行一个GitLab实例开始。GitLab是一个开源的基于Web的Git仓库管理器，具有wiki和问题跟踪功能。它与GitHub或Bitbucket等工具非常相似，但可以轻松部署在你的本地机器上：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A web dashboard is available at `http://192.168.99.100:10080`. The first step
    is to create an admin user and then log in using the credentials provided. I won''t
    go into the details of GitLab. It has a user-friendly and intuitive GUI interface,
    so I''m pretty sure you will able to handle it without too much effort. Anyway,
    going forward, I created a project in GitLab with the name `sample-spring-cloud-config-repo`.
    It may be cloned from `http://192.168.99.100:10080/root/sample-spring-cloud-config-repo.git`.
    I committed there the same set of configuration files, which is available in our
    example repository on GitHub.  The next step is to define a WebHook that invokes
    the Config Server''s `/monitor` endpoint with a push notification. To add a new
    WebHook for the project, you need to go to the Settings | Integration section
    and then fill in the URL field with the server address (use your hostname instead
    of localhost). Leave the Push events checkbox selected:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 网页仪表板可在`http://192.168.99.100:10080`访问。第一步是创建一个管理员用户，然后使用提供的凭据登录。我不会详细介绍GitLab。它有一个用户友好且直观的图形界面，所以我确信您不需要花费太多努力就能掌握它。无论如何，继续前进，我在GitLab中创建了一个名为`sample-spring-cloud-config-repo`的项目。它可以从`http://192.168.99.100:10080/root/sample-spring-cloud-config-repo.git`克隆。我在那里提交了与GitHub上我们的示例存储库中相同的配置文件集。下一步是定义一个WebHook，当有推送通知时调用Config
    Server的`/monitor`端点。要为项目添加新的WebHook，您需要前往设置 | 集成部分，然后将URL字段填写为服务器地址（使用您的hostname而不是localhost代替）。保留推送事件复选框的选择：
- en: '![](img/d7c24aea-9d7a-45ed-b69f-b6aa818239d7.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7c24aea-9d7a-45ed-b69f-b6aa818239d7.png)'
- en: 'In comparison with the Config Server implementation with GitHub as a backend
    repository provider, we need to change the enabled monitor type in `application.yml`
    and of course provide a different address:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用GitHub作为后端存储提供商的Config Server实现相比，我们需要在`application.yml`中更改启用的监控类型，当然也要提供不同的地址：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We should also register another bean implementing `PropertyPathNotificationExtractor`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注册另一个实现`PropertyPathNotificationExtractor`的bean：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, you may make and push some changes in the configuration files. The
    WebHook should be activated and the client application's configuration should
    be refreshed. That is the last example in this chapter; we may proceed to the
    conclusion.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能需要在配置文件中做一些更改并推送它们。WebHook应该被激活，客户端应用程序的配置应该被刷新。这是本章的最后一个例子；我们可以继续到结论。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I have described the most important features of a Spring Cloud
    Config project. The same as for service discovery, we started from the basics,
    a simple use case on the client and server sides. We discussed the different backend
    repository types for a Config Server. I implemented the examples illustrating
    how to use filesystem, Git, and even third-party tools such as Vault as a repository
    for your `property` files. I put particular focus on interoperability with other
    components, such as service discovery or multiple instances of microservices within
    a larger system. Finally, I showed you how to reload an application's configuration
    without restart, based on WebHooks and a message broker. To conclude, after reading
    this chapter you should be able to use Spring Cloud Config as one element of your
    microservice-based architecture and take an advantage of its main features.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了Spring Cloud Config项目的最重要特性。与服务发现一样，我们从基础开始，讨论了客户端和服务器端的简单用例。我们探讨了Config
    Server的不同后端存储类型。我实现了示例，说明了如何使用文件系统、Git，甚至第三方工具如Vault作为`property`文件的存储库。我特别关注与其他组件的互操作性，如服务发现或大型系统中的多个微服务实例。最后，我向您展示了如何基于WebHooks和消息代理无需重新启动应用程序来重新加载配置。总之，阅读本章后，您应该能够将Spring
    Cloud Config作为微服务架构的一个组成部分使用，并利用其主要特性。
- en: After we have discussed an implemetation of service discovery and configuration
    server with Spring Cloud, we may proceed to an inter-service communication. In
    the next two chapters we will analyze basic and some more advanced samples that
    illustrate synchronous communication between a few microservices.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了使用Spring Cloud的服务发现和配置服务器实现之后，我们可以继续研究服务间的通信。在接下来的两章中，我们将分析一些基本和更高级的示例，这些示例说明了几个微服务之间的同步通信。
