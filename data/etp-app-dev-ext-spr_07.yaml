- en: Chapter 7. The Web Request Handling Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 网络请求处理层
- en: The request handling layer is the glue that binds the HTTP client to the services
    provided by your application. It is the interpretation of requests and the transfer
    of data that is the realm of this layer. Our focus will be on the data that is
    consumed and submitted by Ext JS 4 clients. This data is in JSON format and we
    will hence discuss JSON parsing and generation using the Java API for JSON Processing.
    It is important to note, however, that any type of data can be exposed by an appropriate
    request handling implementation. It is just as easy to implement an RMI or RESTful
    interface, if required.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理层是将HTTP客户端与应用程序提供的服务粘合在一起的胶水。这一层的领域是请求的解释和数据的传输。我们的重点将放在Ext JS 4客户端消耗和提交的数据上。这些数据是以JSON格式存在，因此我们将讨论使用Java
    JSON处理API进行JSON解析和生成。然而，需要注意的是，任何类型的数据都可以通过适当的请求处理实现来暴露。如果需要的话，实现RMI或RESTful接口同样容易。
- en: A brief history of Web MVC
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web MVC的简要历史
- en: It may seem strange to discuss the **Model-View-Controller** (**MVC**) paradigm
    in a historical context, as a majority of web applications still use this technology
    today. The MVC design pattern first came to prominence in the early 2000's with
    the open source Struts framework. This framework encouraged the use of MVC architecture
    to promote a clear demarcation of responsibilities when processing and serving
    requests. The MVC paradigm for server-side Java development has been around ever
    since in a variety of formats, culminating in the well-designed and powerful Spring
    MVC framework.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史背景下讨论**模型-视图-控制器**（MVC）范式可能看起来有些奇怪，因为大多数Web应用程序今天仍在使用这项技术。MVC设计模式最早在2000年初就开始在开源的Struts框架中引起关注。这个框架鼓励使用MVC架构来促进处理和提供请求时的责任清晰划分。服务器端Java开发的MVC范式一直存在，以各种形式存在，最终演变成了设计良好且功能强大的Spring
    MVC框架。
- en: 'The rationale for using an MVC approach is quite simple. The web layer implementing
    interactions between the clients and the application can be divided into the following
    three different kinds of objects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MVC方法的理由非常简单。实现客户端和应用程序之间交互的Web层可以分为以下三种不同类型的对象：
- en: Model objects that represent the data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表数据的模型对象
- en: View objects that have the responsibility of displaying the data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责显示数据的视图对象
- en: Controller objects that respond to actions and provide model data for the view
    object to process
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应操作并为视图对象提供模型数据的控制器对象
- en: Each MVC object would behave independently with loose coupling. For example,
    the view technology was of no concern to the controller. It did not matter if
    the view was generated by a FreeMarker template, an XSLT transformation, or a
    combination of Tiles and JSPs. The controller would simply pass on the responsibility
    to the view object to process the model data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MVC对象都会独立行事，耦合度低。例如，视图技术对控制器来说并不重要。视图是由FreeMarker模板、XSLT转换或Tiles和JSP的组合生成并不重要。控制器只是将处理模型数据的责任传递给视图对象。
- en: One important point to note in this historical discussion is that all of the
    MVC processing was performed *on the server*. With the rise in the number of JavaScript
    frameworks, in particular for Ext JS 4, the MVC paradigm has been moved from the
    server to the client browser. This is a fundamental change to how web applications
    are being developed and is the very reason that you are reading this book!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个历史讨论中需要注意的一个重要点是，所有的MVC处理都是在服务器上进行的。随着JavaScript框架数量的增加，特别是Ext JS 4，MVC范式已经从服务器转移到客户端浏览器。这是Web应用程序开发方式的根本变化，也是你正在阅读本书的原因！
- en: Request handling for enterprise web applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业Web应用程序的请求处理
- en: 'The following diagram clearly identifies where the request handling layer resides
    in the overall application architecture:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表清楚地标识了请求处理层在整体应用架构中的位置：
- en: '![Request handling for enterprise web applications](img/5457OS_07_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![企业Web应用程序的请求处理](img/5457OS_07_01.jpg)'
- en: The request handling layer accepts client requests and forwards the respective
    action to the appropriate service layer method. The returned DTO (or Value Object
    as it is also known in Domain-Driven Design) is examined and an appropriate response
    is then sent to the client. Unlike the historical server-side MVC programming,
    the request handling layer has no knowledge of presentation and simply acts as
    a request-processing interface to the application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理层接受客户端请求，并将相应的操作转发给适当的服务层方法。返回的DTO（或者在领域驱动设计中也称为值对象）被检查，然后适当的响应被发送给客户端。与历史上的服务器端MVC编程不同，请求处理层不了解展示，只是作为应用程序的请求处理接口。
- en: Building the request handling layer
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建请求处理层
- en: The web request handling layer for Ext JS 4 clients is a JSON-generating proxy
    to the service layer interfaces. The domain entities are converted into JSON representations
    within this layer; so our first step is to create some helper code to make this
    task easier.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 4客户端的网络请求处理层是服务层接口的JSON生成代理。在这一层内，领域实体被转换为JSON表示；因此我们的第一步是创建一些辅助代码来简化这个任务。
- en: There are several excellent open source JSON generation projects that can assist
    in this task including Jackson ([http://jackson.codehaus.org](http://jackson.codehaus.org))
    and Google Gson ([http://code.google.com/p/google-gson/](http://code.google.com/p/google-gson/)).
    Such libraries parse POJOs into an appropriate JSON representation via their declared
    fields. With the release of Java EE 7, we no longer have a need for third-party
    libraries. The Java API for JSON Processing (JSR-353) is available in all Java
    EE 7-compliant application servers including GlassFish 4\. We will leverage this
    API for generating and parsing JSON data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个优秀的开源JSON生成项目可以帮助完成这项任务，包括Jackson（[http://jackson.codehaus.org](http://jackson.codehaus.org)）和Google
    Gson（[http://code.google.com/p/google-gson/](http://code.google.com/p/google-gson/)）。这些库通过它们声明的字段将POJO解析为适当的JSON表示。随着Java
    EE 7的发布，我们不再需要第三方库。Java API for JSON Processing (JSR-353)在所有Java EE 7兼容的应用服务器中都可用，包括GlassFish
    4。我们将利用这个API来生成和解析JSON数据。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unable to use a Java EE 7 application server, you will need to select
    an alternate JSON-generating strategy, such as Jackson or Google Gson.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法使用Java EE 7应用服务器，您将需要选择替代的JSON生成策略，例如Jackson或Google Gson。
- en: Preparing for JSON generation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为JSON生成做准备
- en: 'Our first addition is a new domain interface:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个添加是一个新的领域接口：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This very simple interface defines two methods to help with JSON generation.
    The `toJson` method creates a `JsonObject` that represents the entity. The `addJson`
    method adds the entity properties to a `JsonObjectBuilder` interface. We will
    see how these two methods are used very soon.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的接口定义了两个方法来帮助生成JSON。`toJson`方法创建一个代表实体的`JsonObject`。`addJson`方法将实体属性添加到`JsonObjectBuilder`接口。我们很快就会看到这两种方法是如何使用的。
- en: 'Each of our domain entities will need to implement the `JsonItem` interface,
    and this can be achieved by simply adding the interface to the abstract superclass
    of all the domain entities:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个领域实体都需要实现`JsonItem`接口，这可以通过简单地将接口添加到所有领域实体的抽象超类中来实现：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `JsonObjectBuilder` interface defines a set of methods that add the name/value
    pairs to the JSON object associated with the builder. The `builder` instance adds
    the fields defined in the descendent classes that implement the `addJson` method.
    We will start with the `Company` object.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonObjectBuilder`接口定义了一组方法，用于向与构建器关联的JSON对象添加名称/值对。`builder`实例添加了实现`addJson`方法的后代类中定义的字段。我们将从`Company`对象开始。'
- en: Implementing the Company addJson method
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Company addJson方法
- en: 'The `addJson` method that needs to be added to the `Company` class is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加到`Company`类的`addJson`方法如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `JsonObject` representation of the `Company` instance is created by calling
    the `builder.build()` method in the superclass. The generated `JsonObject` can
    then be written by a `JsonWriter` instance to an output source.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Company`实例的`JsonObject`表示是通过在超类中调用`builder.build()`方法创建的。然后，生成的`JsonObject`可以由`JsonWriter`实例写入输出源。'
- en: Implementing the Project addJson method
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Project addJson方法
- en: 'The `addJson` method that needs to be added to the `Project` class is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加到`Project`类的`addJson`方法如下：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that it is always a good practice to perform `null` object tests before
    accessing the object methods. It is possible to create a `project` object without
    a `company` instance and hence we perform the `company != null` test prior to
    adding the `company` JSON properties to the project `builder` instance. We could
    have used the following code to add the `company` properties to the project `builder`
    instance directly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在访问对象方法之前执行`null`对象测试始终是一个良好的做法。可以创建一个没有`company`实例的`project`对象，因此我们在向项目`builder`实例添加`company`
    JSON属性之前执行`company != null`测试。我们可以直接使用以下代码将`company`属性添加到项目`builder`实例中：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, we would now have replicated the `builder.add("idCompany"…)` code across
    two classes (`Company.addJson` and `Project.addJson`), thus making the future
    maintenance prone to errors. Changing the JSON property name from `idCompany`
    to `companyId`, for example, would require the scanning of code to check for possible
    usage across all classes, not just the `Company` class. The creation of `Company`
    JSON should belong with the `Company` class as we have implemented.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们现在已经在两个类（`Company.addJson`和`Project.addJson`）中复制了`builder.add("idCompany"…)`的代码，这样未来的维护容易出现错误。例如，将JSON属性名称从`idCompany`更改为`companyId`将需要扫描代码以检查可能在所有类中使用，而不仅仅是`Company`类。`Company`
    JSON的创建应该属于`Company`类，因为我们已经实现了。
- en: Implementing the Task addJson method
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Task addJson方法
- en: 'This `Task` class will implement the `addJson` method as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Task`类将实现如下的`addJson`方法：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note once again how we chain the call to `addJson` for both the `project` and
    `company` classes to add their JSON properties to the task's `builder` instance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们如何将`project`和`company`类的`addJson`调用链接到任务的`builder`实例，以添加它们的JSON属性。
- en: Implementing the User addJson method
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现User addJson方法
- en: 'The `User.addJson` method is defined as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.addJson`方法定义如下：'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `fullName` property is for convenience only; we can just as easily create
    a `fullName` field that concatenates the `firstName` and `lastName` fields in
    our Ext JS code. However, keeping this code at the source of the JSON generation
    allows for easier maintenance. Consider the business change request "add a `middleName`
    field to the `User` entity". The `fullName` inclusion of the new `middleName`
    field is then a trivial exercise and would be available to the Ext JS client without
    any further changes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`fullName`属性仅供方便使用；我们可以在我们的Ext JS代码中轻松地创建一个`fullName`字段，它连接`firstName`和`lastName`字段。然而，将这段代码保留在JSON生成的源头可以更容易地进行维护。考虑业务变更请求“向`User`实体添加`middleName`字段”。然后，`fullName`包含新的`middleName`字段就变得非常简单，并且可以在不进行任何进一步更改的情况下提供给Ext
    JS客户端。'
- en: Implementing the TaskLog addJson method
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现TaskLog addJson方法
- en: 'The `addJson` method adds all of the `TaskLog` fields to the `builder` instance.
    The `DATE_FORMAT_yyyyMMdd` constant is used to format the `taskLogDate` to an
    8-digit representation of the year/month/day and is added to the `TaskLog` class
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`addJson`方法将所有`TaskLog`字段添加到`builder`实例中。`DATE_FORMAT_yyyyMMdd`常量用于将`taskLogDate`格式化为年/月/日的8位表示，并添加到`TaskLog`类中，如下所示：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `addJson` method will use the `SimpleDateFormat` instance to format the
    `taskLogDate` field:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`addJson`方法将使用`SimpleDateFormat`实例来格式化`taskLogDate`字段：'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `taskLogDate` field is being formatted in a way that cannot be misunderstood
    when converting to a JavaScript `Date` object in Ext JS clients. Without the use
    of the `SimpleDateFormat` instance, the `builder` instance would call the default
    `toString` method on the `taskLogDate` object to retrieve the String representation,
    resulting in an output similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskLogDate`字段的格式化方式在转换为Ext JS客户端的JavaScript `Date`对象时不会被误解。如果没有使用`SimpleDateFormat`实例，`builder`实例将调用`taskLogDate`对象的默认`toString`方法来检索字符串表示，结果类似于以下内容：'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using the `SimpleDateFormat` instance configured with a date pattern of `yyyyMMdd`
    will ensure that such a date is formatted to `20130814`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置为`yyyyMMdd`日期模式的`SimpleDateFormat`实例将确保这样的日期格式为`20130814`。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Date formatting in enterprise applications can cause many issues if not approached
    with a standard strategy. This is even more applicable when we are developing
    applications to be used worldwide, with multiple timezones and different languages.
    The dates should always be formatted in a way that can be interpreted in the same
    way regardless of language, timezone, and user preferences.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，日期格式化可能会导致许多问题，如果没有采用标准策略。当我们开发应用程序供全球使用，涉及多个时区和不同语言时，这一点更加适用。日期应始终以一种可以在不同语言、时区和用户偏好设置下被解释的方式进行格式化。
- en: A note on JSON
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于JSON的说明
- en: We will be using JSON to transmit data between the GlassFish server and the
    Ext JS client. The transfer is bidirectional; the server will send the JSON data
    to the Ext JS client, and the Ext JS client will be sending the data in the JSON
    format back to the server. The server and client will consume *and* produce the
    JSON data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JSON在GlassFish服务器和Ext JS客户端之间传输数据。传输是双向的；服务器将向Ext JS客户端发送JSON数据，而Ext JS客户端将以JSON格式将数据发送回服务器。服务器和客户端都将消耗*和*生成JSON数据。
- en: 'There are no rules for structuring the JSON data as long as it conforms to
    the specifications ([http://tools.ietf.org/html/rfc4627](http://tools.ietf.org/html/rfc4627)).
    Ext JS 4 models allow any form of valid JSON structure through the use of associations;
    our approach keeps the JSON structure to its simplest form. The previously defined
    `addJson` methods return simple, flat data structures without nesting or arrays.
    As an example, a `task` instance could be serialized into the following JSON object
    (formatting included for readability):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 只要符合规范（[http://tools.ietf.org/html/rfc4627](http://tools.ietf.org/html/rfc4627)），对于构造JSON数据没有规则。Ext
    JS 4模型允许通过关联使用任何形式的有效JSON结构；我们的方法将JSON结构保持在其最简单的形式。先前定义的`addJson`方法返回简单的、扁平的数据结构，没有嵌套或数组。例如，`task`实例可以序列化为以下JSON对象（包含格式化以便阅读）：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `data` payload represents the `task` object that will be consumed by the
    Ext JS 4 client. We could have defined the JSON representation of the `task` object
    as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`负载表示将被Ext JS 4客户端消耗的`task`对象。我们可以定义`task`对象的JSON表示如下：'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this structure we see that the `task` instance belongs to a `project`, which
    in turn belongs to a `company`. Both these JSON representations are legal; they
    both contain the same `task` data in valid JSON format. However, which of these
    two will be easier to parse? Which will be easier to debug? As an enterprise application
    developer we should always keep the KISS principle in mind. The **Keep It Simple,
    Stupid** (**KISS**)principle states that most systems work best if they are kept
    simple and unnecessary complexities should be avoided.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，我们看到`task`实例属于一个`project`，而`project`又属于一个`company`。这两种JSON表示都是合法的；它们都包含相同的`task`数据，以有效的JSON格式。然而，这两者中哪一个更容易解析？哪一个更容易调试？作为企业应用程序开发人员，我们应该始终牢记KISS原则。**保持简单，愚蠢**（KISS）原则指出，大多数系统如果保持简单，并避免不必要的复杂性，将能够发挥最佳作用。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep your JSON simple! We know that complex structures are possible; this is
    achieved only through additional complexities when defining the Ext JS 4 models
    along with the associated data processing when reading or writing JSON data. A
    simple JSON structure is easier to understand and maintain.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 保持你的JSON简单！我们知道复杂的结构是可能的；这只是通过在定义Ext JS 4模型以及读取或写入JSON数据时附加复杂性来实现的。简单的JSON结构更容易理解和维护。
- en: Creating the request handlers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建请求处理程序
- en: 'We will now build the handlers that are used to serve the HTTP requests from
    our Ext JS client. These handlers will be added to a new `web` directory, as shown
    in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将构建用于为我们的Ext JS客户端提供HTTP请求的处理程序。这些处理程序将被添加到一个新的`web`目录中，如下截图所示：
- en: '![Creating the request handlers](img/5457OS_07_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![创建请求处理程序](img/5457OS_07_02.jpg)'
- en: Each handler will use the Spring Framework `@Controller` annotation to indicate
    that the class serves the role of a "controller". Strictly speaking, the handlers
    that we will be defining are *not* controllers in the traditional sense of a Spring
    MVC application. We will only be using a very small portion of the available Spring
    controller functionality to process requests. This will ensure that our request
    handling layer is very lightweight and easy to maintain. As always, we will start
    by creating a base class that all the handlers will implement.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理程序都将使用Spring Framework的`@Controller`注解来指示该类充当“控制器”的角色。严格来说，我们将要定义的处理程序在传统意义上并不是Spring
    MVC应用程序的控制器。我们只会使用非常小部分可用的Spring控制器功能来处理请求。这将确保我们的请求处理层非常轻量且易于维护。和往常一样，我们将首先创建一个所有处理程序都将实现的基类。
- en: Defining the AbstractHandler superclass
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义AbstractHandler超类
- en: The `AbstractHandler` superclass defines several important methods that are
    used to simplify JSON generation. As we are working toward integration with Ext
    JS 4 clients, the structure of the JSON object generated by our handlers is specific
    to data structures expected by Ext JS 4 components. We will always generate a
    JSON object with a `success` property that holds a Boolean `true` or `false` value.
    Likewise, we will always generate a JSON object with a payload property named
    `data`. This `data` property will have a valid JSON object as its value, either
    as a simple JSON object or as a JSON array.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractHandler`超类定义了几个重要的方法，用于简化JSON生成。由于我们正在与Ext JS 4客户端集成，我们处理程序生成的JSON对象的结构特定于Ext
    JS 4组件期望的数据结构。我们将始终生成一个具有`success`属性的JSON对象，该属性包含一个布尔值`true`或`false`。同样，我们将始终生成一个名为`data`的有效负载属性的JSON对象。这个`data`属性将具有一个有效的JSON对象作为其值，可以是一个简单的JSON对象，也可以是一个JSON数组。'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that all of the generated JSON objects will be in a format that can
    be consumed by Ext JS 4 components without the need for additional configuration.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有生成的JSON对象都将以一种格式呈现，可以被Ext JS 4组件消费，而无需额外的配置。
- en: 'The definition of the `AbstractHandler` class is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractHandler`类的定义如下：'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The overloaded `getJsonSuccessData` methods will each generate a JSON string
    with the `success` property set to `true` and an appropriate `data` JSON payload.
    The `getJsonXXXMsg` variants will also generate a JSON String with an appropriate
    `success` property (either `true` for a successful action or `false` for a failed
    action) and an `msg` property that holds the appropriate message for consumption
    by the Ext JS component.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的`getJsonSuccessData`方法将分别生成一个JSON字符串，其中`success`属性设置为`true`，并且包含适当的`data`
    JSON有效负载。`getJsonXXXMsg`变体也将生成一个JSON字符串，其中包含适当的`success`属性（对于成功的操作为`true`，对于失败的操作为`false`），以及一个包含适当消息的`msg`属性，供Ext
    JS组件使用。
- en: The `parseJsonObject` method will parse a JSON string *into* a `JsonObject`
    using the `JsonReader` instance. The `toJsonString` method will *write* a `JsonObject`
    to its JSON string representation using the `JsonWriter` instance. These classes
    are part of the Java EE 7 `javax.json` package, and they make working with JSON
    very easy.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseJsonObject`方法将使用`JsonReader`实例将JSON字符串解析为`JsonObject`。`toJsonString`方法将使用`JsonWriter`实例将`JsonObject`写入其JSON字符串表示。这些类是Java
    EE 7 `javax.json`包的一部分，它们使得使用JSON非常容易。'
- en: 'The `getIntegerValue` method is used to parse a `JsonValue` object into an
    `Integer` type. A `JsonValue` object may be of several different types as defined
    by the `javax.json.jsonValue.ValueType` constants, and appropriate checks are
    performed on the value prior to attempting to parse the `JsonValue` object into
    an `Integer`. This will allow us to send JSON data from Ext JS clients in the
    following form:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`getIntegerValue`方法用于将`JsonValue`对象解析为`Integer`类型。`JsonValue`对象可以是由`javax.json.jsonValue.ValueType`常量定义的几种不同类型，对值进行适当检查后，才尝试将`JsonValue`对象解析为`Integer`。这将允许我们以以下形式从Ext
    JS客户端发送JSON数据：'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the `idCompany` property has a value of `null`. The `getIntegerValue`
    method allows us to parse integers that *may* be `null`, something that is not
    possible when using the default `JsonObject.getInt(key)` method (which throws
    an exception if a `null` value is encountered).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`idCompany`属性的值为`null`。`getIntegerValue`方法允许我们解析可能为`null`的整数，这是使用默认的`JsonObject.getInt(key)`方法时不可能的（如果遇到`null`值，它会抛出异常）。
- en: Let's now define our first handler class that will process user authentication.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义我们的第一个处理程序类，用于处理用户身份验证。
- en: Defining the SecurityHandler class
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义SecurityHandler类
- en: 'We first define a simple helper class that can be used to verify whether a
    user session is active:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个简单的辅助类，用于验证用户会话是否处于活动状态：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The static constant `SESSION_ATTRIB_USER` will be used as the name of the session
    property that holds the authenticated user. All handler classes will call the
    `SecurityHelper.getSessionUser` method to retrieve the authenticated `user` from
    the session. A user session may time out due to inactivity, and the HTTP session
    will then be removed by the application server. When this happens, the `SecurityHelper.getSessionUser`
    method will return `null`, and the 3T application must handle this gracefully.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 静态常量`SESSION_ATTRIB_USER`将被用作保存经过身份验证的用户的会话属性的名称。所有处理程序类将调用`SecurityHelper.getSessionUser`方法从会话中检索经过身份验证的用户。用户会话可能因为不活动而超时，然后HTTP会话将被应用服务器移除。当这种情况发生时，`SecurityHelper.getSessionUser`方法将返回`null`，3T应用程序必须优雅地处理这种情况。
- en: The `SecurityHandler` class is used to authenticate the user credentials. If
    a user is successfully authenticated, the `user` object is stored in the HTTP
    session using the `SESSION_ATTRIB_USER` attribute. It is also possible for the
    user to log out of the 3T application by clicking on the **Log Out** button. In
    this case the user is removed from the session.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityHandler`类用于验证用户凭据。如果用户成功验证，`user`对象将使用`SESSION_ATTRIB_USER`属性存储在HTTP会话中。用户也可以通过单击**注销**按钮从3T应用程序注销。在这种情况下，用户将从会话中移除。'
- en: 'The verification and logout functionalities are implemented as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 验证和注销功能的实现如下：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `SecurityHandler` class introduces many new Spring annotations and concepts
    that need to be explained in detail.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecurityHandler`类引入了许多新的Spring注解和概念，需要详细解释。'
- en: The @Controller and @RequestMapping annotations
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Controller和@RequestMapping注解'
- en: The `@Controller` annotation indicates that this class serves the role of a
    Spring controller. The `@Controller` annotated classes are autodetected by Spring
    component scanning, the configuration of which is defined later in this chapter.
    But what exactly is a controller?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Controller`注解表示这个类充当Spring控制器的角色。由`@Controller`注释的类将被Spring组件扫描自动检测到，其配置在本章后面定义。但是控制器到底是什么？'
- en: 'A Spring controller is part of the Spring MVC framework and usually acts with
    models and views to process requests. We have no need for either models or views;
    in fact, our processing lifecycle is managed entirely by the controller itself.
    Each controller is responsible for a URL mapping as defined in the class-level
    `@RequestMapping` annotation. This mapping maps a URL path to the controller.
    In our 3T application, any URL starting with `/security/` will be directed to
    the `SecurityHandler` class for further processing. Any subpath will then be used
    to match a method-level `@RequestMapping` annotation. We have two methods defined,
    each with their own unique mapping. This results in the following URL path-to-method
    mappings:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Spring控制器是Spring MVC框架的一部分，通常与模型和视图一起处理请求。我们既不需要模型也不需要视图；事实上，我们的处理生命周期完全由控制器本身管理。每个控制器负责一个URL映射，如类级`@RequestMapping`注释中定义的。这个映射将URL路径映射到控制器。在我们的3T应用程序中，任何以`/security/`开头的URL将被定向到`SecurityHandler`类进行进一步处理。然后将使用任何子路径来匹配方法级`@RequestMapping`注释。我们定义了两种方法，每种方法都有自己独特的映射。这导致以下URL路径到方法的映射：
- en: '`/security/logon` will map to the `logon` method'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/security/logon`将映射到`logon`方法'
- en: '`/security/logout` will map to the `logout` method'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/security/logout`将映射到`logout`方法'
- en: Any other URL starting with `/security/` will not match the defined methods
    and would produce a `404` error.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他以`/security/`开头的URL都不会匹配已定义的方法，并且会产生`404`错误。
- en: The name of the method is not important; it is the `@RequestMapping` annotation
    that defines the method used to serve a request.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的名称并不重要；重要的是`@RequestMapping`注释定义了用于处理请求的方法。
- en: There are two additional properties defined in the `logon` `@RequestMapping`
    annotation. The `method=RequestMethod.POST` property specifies that the logon
    request URL `/security/logon` must be submitted as a `POST` request. If any other
    request type was used for the `/security/logon` submission, a `404` error would
    be returned. Ext JS 4 stores and models using AJAX will submit `POST` requests
    by default. Actions that read data, however, will be submitted using a `GET` request
    unless configured otherwise. The other possible methods used in RESTful web services
    include `PUT` and `DELETE`, but we will only define the `GET` and `POST` requests
    in our application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`logon`的`@RequestMapping`注释中定义了两个额外的属性。`method=RequestMethod.POST`属性指定了`/security/logon`登录请求URL必须以`POST`请求提交。如果对`/security/logon`提交使用了其他请求类型，将返回`404`错误。Ext
    JS 4使用AJAX存储和模型默认提交`POST`请求。然而，读取数据的操作将使用`GET`请求提交，除非另有配置。在RESTful web服务中使用的其他可能方法包括`PUT`和`DELETE`，但我们只会在我们的应用程序中定义`GET`和`POST`请求。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is considered a best practice to ensure that each `@RequestMapping` method
    has an appropriate `RequestMethod` defined. The actions that modify data should
    always be submitted using a `POST` request. The actions that hold sensitive data
    (for example, passwords) should also be submitted using a `POST` request to ensure
    that the data is not sent in a URL-encoded format. The read actions may be sent
    as either a `GET` or a `POST` request depending on your application needs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 确保每个`@RequestMapping`方法都有适当的`RequestMethod`定义被认为是最佳实践。修改数据的操作应始终使用`POST`请求提交。持有敏感数据（例如密码）的操作也应使用`POST`请求提交，以确保数据不以URL编码格式发送。根据您的应用程序需求，读取操作可以作为`GET`或`POST`请求发送。
- en: 'The `produces = {"application/json"}` property defines the producible media
    types of the mapped request. All of our requests will produce JSON data that has
    the media type `application/json`. Each HTTP request submitted by a browser has
    an `Accept` header, such as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`produces = {"application/json"}`属性定义了映射请求的可生产媒体类型。我们所有的请求都将生成具有`application/json`媒体类型的JSON数据。每个由浏览器提交的HTTP请求都有一个`Accept`头，例如：'
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the `Accept` request does not include the `produces` property media type,
    then the following `406 Not Acceptable` error is returned by the GlassFish 4 server:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Accept`请求不包括`produces`属性媒体类型，则GlassFish 4服务器将返回以下`406 Not Acceptable`错误：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All modern browsers will accept the `application/json` content type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代浏览器都将接受`application/json`内容类型。
- en: The @ResponseBody annotation
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@ResponseBody注释'
- en: This annotation is used by Spring to identify the methods that should return
    the content directly to the HTTP response output stream (not placed in a model
    or interpreted as a view name, which is the default Spring MVC behavior). How
    this is achieved will depend on the return type of the method. All of our request
    handling methods will return Java Strings, and Spring will internally use a `StringHttpMessageConverter`
    instance to write the String to the HTTP response output stream with a `Content-Type`
    of value `text/plain`. This is a very easy way of returning JSON data object String
    to an HTTP client and thus makes request handling a trivial process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Spring使用此注释来标识应直接将内容返回到HTTP响应输出流的方法（不放置在模型中或解释为视图名称，这是默认的Spring MVC行为）。实现这一点将取决于方法的返回类型。我们所有的请求处理方法都将返回Java字符串，Spring将在内部使用`StringHttpMessageConverter`实例将字符串写入HTTP响应输出流，并使用值为`text/plain`的`Content-Type`。这是将JSON数据对象字符串返回给HTTP客户端的一种非常简单的方法，因此使得请求处理成为一个微不足道的过程。
- en: The @RequestParam annotation
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@RequestParam注释'
- en: 'This annotation on a method argument maps a request parameter to the argument
    itself. In the `logon` method we have the following definition:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法参数上的注释将请求参数映射到参数本身。在`logon`方法中，我们有以下定义：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Assuming that the `logon` method was of the type `GET` (it is set to `POST`
    in the `SecurityHandler` class, and hence the following URL encoding would not
    work), a URL such as the following would call the method with a `username` value
    of `bjones` and a `password` value of `admin`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`logon`方法是`GET`类型（在`SecurityHandler`类中设置为`POST`，因此以下URL编码将无法工作），例如以下URL将调用具有`username`值为`bjones`和`password`值为`admin`的方法：
- en: '`/security/logon.json?username=bjones&password=admin`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`/security/logon.json?username=bjones&password=admin`'
- en: 'We could just as easily have written this method with the following definition:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用以下定义来编写这个方法：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This would then map a URL of the following form:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将映射以下形式的URL：
- en: '`/security/logon.json?user=bjones&pwd=admin`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`/security/logon.json?user=bjones&pwd=admin`'
- en: Note that it is the `value` property of the `@RequestParam` annotation that
    maps to the request parameter name.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`@RequestParam`注解的`value`属性映射到请求参数名称。
- en: 'The `required` property of the `@RequestParam` annotation defines if this parameter
    is a required field. The following URL would result in an exception:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestParam`注解的`required`属性定义了该参数是否为必填字段。以下URL将导致异常：'
- en: '`/security/logon.json?username=bjones`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`/security/logon.json?username=bjones`'
- en: The password parameter is obviously missing, which does not adhere to the `required=true`
    definition.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 显然缺少密码参数，这不符合`required=true`的定义。
- en: 'Note that the `required=true` property only checks for the existence of a request
    parameter that matches the `value` of the `@RequestParam` annotation. It is entirely
    valid to have a request parameter that is empty. The following URL would not throw
    an exception:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`required=true`属性仅检查是否存在与`@RequestParam`注解的`value`匹配的请求参数。请求参数为空是完全有效的。以下URL不会引发异常：
- en: '`/security/logon.json?username=bjones&password=`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`/security/logon.json?username=bjones&password=`'
- en: 'Optional parameters may be defined by using the `required=false` property and
    may also include a `defaultValue`. Consider the following method argument:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数可以通过使用`required=false`属性进行定义，也可以包括`defaultValue`。考虑以下方法参数：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also consider the following three URLs:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还考虑以下三个URL：
- en: '`/user/address.json?address=Melbourne`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/address.json?address=Melbourne`'
- en: '`/user/address.json?address=`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/address.json?address=`'
- en: '`/user/address.json?`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/address.json?`'
- en: The first URL will result in an address value `Melbourne`, the second URL will
    have a null address, and the third URL will have an "unknown address". Note that
    the `defaultValue` will only be used if the request does not have a valid address
    parameter, and not if the address parameter is empty.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个URL将导致地址值为`墨尔本`，第二个URL将具有空地址，第三个URL将具有“未知地址”。请注意，仅当请求没有有效的地址参数时，`defaultValue`才会被使用，而不是地址参数为空时。
- en: Authenticating a user
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证用户
- en: 'The `logon` method in our `SecurityHandler` class is very simple thanks to
    our implementation of the service-layer business logic. We call the `userService.findByUsernamePassword(username,
    password)` method and check the returned `Result`. If the `Result` is successful,
    the `SecurityHandler.logon` method will return a JSON representation of the authenticated
    user. This is achieved by the line `getJsonSuccessData(user)`, which will result
    in the following output being written to the HTTP response:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SecurityHandler`类中的`logon`方法非常简单，这要归功于我们对服务层业务逻辑的实现。我们调用`userService.findByUsernamePassword(username,
    password)`方法并检查返回的`Result`。如果`Result`成功，`SecurityHandler.logon`方法将返回经过身份验证的用户的JSON表示。这是通过`getJsonSuccessData(user)`这一行实现的，它将导致以下输出被写入HTTP响应：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the preceding formatting is for readability only. The actual response
    will be a stream of characters. The authenticated user is then added to the HTTP
    session with the attribute `SESSION_ATTRIB_USER`. We are then able to identify
    the authenticated user by calling `SecurityHelper.getSessionUser(request)` in
    our request handlers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述格式仅用于可读性。实际响应将是一系列字符。然后将经过身份验证的用户添加到具有属性`SESSION_ATTRIB_USER`的HTTP会话中。然后，我们可以通过在我们的请求处理程序中调用`SecurityHelper.getSessionUser(request)`来识别经过身份验证的用户。
- en: 'A `Result` instance that has failed will call the `getJsonErrorMsg(ar.getMsg())`
    method, which will result in the following JSON object being returned in the HTTP
    response:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的`Result`实例将调用`getJsonErrorMsg(ar.getMsg())`方法，这将导致在HTTP响应中返回以下JSON对象：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `msg` text is set on the `Result` instance in the `UserServiceImpl.findByUsernamePassword`
    method. The Ext JS frontend will process each result differently depending on
    the `success` property.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg`文本在`UserServiceImpl.findByUsernamePassword`方法中设置在`Result`实例上。根据`success`属性，Ext
    JS前端将以不同方式处理每个结果。'
- en: Logging out
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登出
- en: 'The logic in this method is very simple: remove the user from the session and
    return a successful JSON message. The Ext JS frontend will then take an appropriate
    action. There is no `RequestMethod` defined in the `@RequestMapping` annotation
    as no data is being sent. This means that any `RequestMethod` may be used to map
    this URL (`GET`, `POST`, and so on). The JSON object returned from this method
    is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法中的逻辑非常简单：从会话中删除用户并返回成功的JSON消息。由于没有在`@RequestMapping`注解中定义`RequestMethod`，因此可以使用任何`RequestMethod`来映射此URL（`GET`，`POST`等）。从此方法返回的JSON对象如下：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Defining the CompanyHandler class
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义CompanyHandler类
- en: This handler processes company actions and is mapped to the `/company/` URL
    pattern.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理程序处理公司操作，并映射到`/company/` URL模式。
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each method is mapped to a different sub URL as defined by the method-level
    `@RequestMapping` annotation. The `CompanyHandler` class will hence be mapped
    to the following URLs:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都根据方法级`@RequestMapping`注解定义的不同子URL进行映射。因此，`CompanyHandler`类将映射到以下URL：
- en: '`/company/find` will map it to the `find` method using a `GET` request'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/company/find`将使用`GET`请求将其映射到`find`方法'
- en: '`/company/store` will map it to the `store` method using a `POST` request'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/company/store`将使用`POST`请求将其映射到`store`方法'
- en: '`/company/findAll` will map it to the `findAll` method using a `GET` request'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/company/findAll`将使用`GET`请求将其映射到`findAll`方法'
- en: '`/company/remove` will map it to the `remove` method using a `POST` request'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/company/remove`将使用`POST`请求将其映射到`remove`方法'
- en: 'The following are a few things to note:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的事项：
- en: Each handler method is defined with either a `RequestMethod.POST` or `RequestMethod.GET`.
    The `GET` method is used for finder methods, and the `POST` method is used for
    data-modifying methods. These method types are the defaults used by Ext JS for
    each action.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个处理程序方法都使用`RequestMethod.POST`或`RequestMethod.GET`进行定义。`GET`方法用于查找方法，`POST`方法用于修改数据的方法。这些方法类型是Ext
    JS用于每个操作的默认值。
- en: Each method retrieves the user from the HTTP session by calling `getSessionUser(request)`
    and then tests if the `user` value is `null`. If the user is not in session, the
    message "`User is not logged on"` is returned in the JSON-encoded HTTP response.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个方法通过调用`getSessionUser(request)`从HTTP会话中检索用户，然后测试`user`值是否为`null`。如果用户不在会话中，则在JSON编码的HTTP响应中返回消息"`用户未登录`"。
- en: The `POST` methods have a single request parameter that holds the JSON data
    submitted by the Ext JS client. This JSON string is then parsed into a `JsonObject`
    before calling the appropriate service layer method using the required parameters.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`方法具有一个保存Ext JS客户端提交的JSON数据的请求参数。然后在使用所需参数调用适当的服务层方法之前，将此JSON字符串解析为`JsonObject`。'
- en: 'A typical JSON data payload for adding a new company would look like the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新公司的典型JSON数据有效负载如下：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that the `idCompany` value is `null`. If you are modifying an existing
    company record, the JSON data payload must contain a valid `idCompany` value:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`idCompany`值为`null`。如果要修改现有公司记录，则JSON数据有效负载必须包含有效的`idCompany`值：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note also that the JSON data holds exactly one company record. It is possible
    to configure Ext JS clients to submit multiple records per request by submitting
    a JSON array similar to the following array:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，JSON数据仅包含一个公司记录。可以配置Ext JS客户端通过提交类似以下数组的JSON数组来提交每个请求的多个记录：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, we will restrict our logic to processing a single record per request.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们将限制我们的逻辑以处理每个请求的单个记录。
- en: Defining the ProjectHandler class
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义ProjectHandler类
- en: 'The `ProjectHandler` class processes the project actions and is mapped to the
    `/project/` URL pattern as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProjectHandler`类处理项目操作，并将其映射到`/project/` URL模式如下：'
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `ProjectHandler` class will hence be mapped to the following URLs:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProjectHandler`类将被映射到以下URL：'
- en: '`/project/find` will map to the `find` method using a `GET` request'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/project/find`将使用`GET`请求映射到`find`方法'
- en: '`/project/store` will map to the `store` method using a `POST` request'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/project/store`将使用`POST`请求映射到`store`方法'
- en: '`/project/findAll` will map to the `findAll` method using a `GET` request'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/project/findAll`将使用`GET`请求映射到`findAll`方法'
- en: '`/project/remove` will map to the `remove` method using a `POST` request'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/project/remove`将使用`POST`请求映射到`remove`方法'
- en: 'Note that in the `store` method, we are once again retrieving the required
    data from the parsed `JsonObject`. The structure of the JSON `data` payload when
    adding a new project is in the following format:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`store`方法中，我们再次从解析的`JsonObject`中检索所需的数据。添加新项目时，JSON`data`有效负载的结构如下：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When updating an existing project, the JSON structure is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 更新现有项目时，JSON结构如下：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will also notice that we once again have the same block of code replicated
    in each method, as we did in the `CompanyHandler` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到，我们在每个方法中再次复制了相同的代码块，就像在`CompanyHandler`类中一样：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Every method in each of the remaining handlers will also require the same check;
    a user *must* be in session to perform the action. This is precisely why we will
    simplify our code by introducing the concept of Spring request handler interceptors.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个剩余处理程序中的每个方法也将需要相同的检查；用户*必须*在会话中才能执行操作。这正是为什么我们将通过引入Spring请求处理程序拦截器的概念来简化我们的代码。
- en: The Spring HandlerInterceptor interface
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring HandlerInterceptor接口
- en: 'Spring''s request handling mapping mechanism includes the ability to intercept
    requests by using handler interceptors. These interceptors are used to apply some
    type of functionality to the requests as in our example of checking whether a
    user is in session. The interceptors must implement the `HandlerInterceptor` interface
    from the `org.springframework.web.servlet` package where it is possible to apply
    the functionality in the following three ways:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的请求处理映射机制包括使用处理程序拦截器拦截请求的能力。这些拦截器用于对请求应用某种功能，例如我们的示例中检查用户是否在会话中。拦截器必须实现`org.springframework.web.servlet`包中的`HandlerInterceptor`接口，可以通过以下三种方式应用功能：
- en: Before the handler method is executed by implementing the `preHandle` method
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现`preHandle`方法之前执行处理程序方法
- en: After the handler method is executed by implementing the `postHandle` method
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现`postHandle`方法执行处理程序方法后
- en: After the complete request has finished execution by implementing the `afterCompletion`
    method
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现`afterCompletion`方法执行完整请求后
- en: 'The `HandlerInterceptorAdapter` abstract class, along with the predefined empty
    implementations for each method, is normally used to implement custom handlers.
    Our `UserInSessionInterceptor` class is defined as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用`HandlerInterceptorAdapter`抽象类以及每个方法的预定义空实现来实现自定义处理程序。我们的`UserInSessionInterceptor`类定义如下：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When intercepting a request with the `UserInSessionInterceptor`, the code in
    the `preHandle` method checks if there is a user in session. If a `sessionUser`
    is found, the handler returns `true` to indicate that normal processing should
    continue. Normal processing may result in additional handler interceptors being
    called, if configured, before finally reaching the mapped handler method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`UserInSessionInterceptor`拦截请求时，`preHandle`方法中的代码检查是否有用户在会话中。如果找到`sessionUser`，处理程序将返回`true`，表示应继续正常处理。正常处理可能导致调用其他处理程序拦截器（如果已配置），最终到达映射的处理程序方法之前。
- en: If a `sessionUser` is not found, a simple JSON string is immediately sent to
    the response output stream. The `preHandle` method then returns `false` to indicate
    that the interceptor has already dealt with the response and no further processing
    is required.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到`sessionUser`，则立即向响应输出流发送一个简单的JSON字符串。然后，`preHandle`方法返回`false`，表示拦截器已经处理了响应，不需要进一步处理。
- en: 'By applying the `UserInSessionInterceptor` to each request that requires the
    user session test, we can remove the following code from each handler method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`UserInSessionInterceptor`应用于需要用户会话测试的每个请求，我们可以从每个处理程序方法中删除以下代码：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How do we apply the interceptor to the appropriate handler methods? This is
    done when we customize the Spring MVC configuration.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将拦截器应用于适当的处理程序方法？这是在我们自定义Spring MVC配置时完成的。
- en: The Spring MVC configuration
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC配置
- en: 'The Spring MVC framework can be configured with XML files or Java configuration
    classes. We will configure our application using Spring MVC configuration classes,
    the first being the `WebAppConfig` class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC框架可以使用XML文件或Java配置类进行配置。我们将使用Spring MVC配置类来配置我们的应用程序，首先是`WebAppConfig`类：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `WebAppConfig` class extends `WebMvcConfigurerAdapter`, which is a convenient
    base class that provides empty implementations for each of the `WebMvcConfigurer`
    interface methods. We override the `addInterceptors` method to register our `UserInSessionInterceptor`
    and define the handler mappings that will be used to apply the interceptor. The
    path pattern `/**` will intercept *all* the mappings from which we *exclude* the
    `/security/**` mappings. The security mappings should *not* include a user session
    check because the user has not yet been authenticated and will not be in session.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAppConfig`类扩展了`WebMvcConfigurerAdapter`，这是一个方便的基类，为`WebMvcConfigurer`接口的每个方法提供了空实现。我们重写`addInterceptors`方法来注册我们的`UserInSessionInterceptor`并定义将用于应用拦截器的处理程序映射。路径模式`/**`将拦截*所有*映射，我们从中*排除*`/security/**`映射。安全映射*不*应包含用户会话检查，因为用户尚未经过身份验证并且不会在会话中。'
- en: The `@ComponentScan("com.gieman.tttracker.web")` annotation will trigger a scan
    for `@Controller` annotated classes in the `com.gieman.tttracker.web` package.
    Our handler classes will then be identified and loaded by Spring. The `@EnableWebMvc`
    annotation identifies this class as a Spring web MVC configuration class. This
    annnotation results in Spring loading the required `WebMvcConfigurationSupport`
    configuration properties. The remaining `@Configuration` annotation identifies
    the class as a candidate for component scanning during Spring application startup.
    The `WebAppConfig` class is then automatically loaded for use in the Spring MVC
    container.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ComponentScan("com.gieman.tttracker.web")`注解将触发对`com.gieman.tttracker.web`包中`@Controller`注释类的扫描。然后，Spring将识别和加载我们的处理程序类。`@EnableWebMvc`注解将此类标识为Spring
    Web MVC配置类。此注释导致Spring加载所需的`WebMvcConfigurationSupport`配置属性。剩下的`@Configuration`注解在Spring应用程序启动期间将此类标识为组件扫描的候选类。然后，`WebAppConfig`类将自动加载以在Spring
    MVC容器中使用。'
- en: 'The `WebAppConfig` class configures the MVC environment; it is the `WebApp`
    class that configures the `servlet` container:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAppConfig`类配置了MVC环境；`WebApp`类配置了`servlet`容器：'
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `AbstractAnnotationConfigDispatcherServletInitializer` class was introduced
    in Spring 3.2 as a base class for `WebApplicationInitializer` implementations.
    These implementations register a `DispatcherServlet` configured with annotated
    classes as defined in the `WebAppConfig` class (note how this class is returned
    in the `getServletConfigClasses` method).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractAnnotationConfigDispatcherServletInitializer`类在Spring 3.2中作为`WebApplicationInitializer`实现的基类引入。这些实现注册使用`WebAppConfig`类中定义的注释类配置的`DispatcherServlet`（请注意，此类在`getServletConfigClasses`方法中返回）。'
- en: 'The final configuration item of interest is the `getServletMappings` method,
    which maps incoming requests to the `WebAppConfig` set of handlers that are discovered
    via the `@ComponentScan` annotation. Every URL in our application that starts
    with `/ttt/` will be directed to an appropriate request handler for processing.
    Some example URLs submitted from an Ext JS 4 client could include the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的最终配置项是`getServletMappings`方法，它将传入的请求映射到通过`@ComponentScan`注解发现的`WebAppConfig`处理程序集。我们应用程序中以`/ttt/`开头的每个URL都将被定向到适当的请求处理程序进行处理。从Ext
    JS 4客户端提交的一些示例URL可能包括以下内容：
- en: '`/ttt/company/findAll.json` will map to the `CompanyHandler.findAll` method'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ttt/company/findAll.json`将映射到`CompanyHandler.findAll`方法'
- en: '`/ttt/project/find.json?idProject=5` will map to the `ProjectHandler.find`
    method'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ttt/project/find.json?idProject=5`将映射到`ProjectHandler.find`方法'
- en: Note that the `/ttt/` prefix in the URL defines the *entry point* to our Spring
    MVC components. URLs that do not start with `/ttt/` will *not* be handled by the
    Spring MVC container.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，URL中的`/ttt/`前缀定义了我们Spring MVC组件的*入口点*。不以`/ttt/`开头的URL将*不*由Spring MVC容器处理。
- en: We will now implement one more handler to introduce data binding in Spring controllers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现一个处理程序来介绍Spring控制器中的数据绑定。
- en: Defining the TaskLogHandler class
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义`TaskLogHandler`类
- en: 'The `TaskLogHandler` class processes the task log actions and is mapped to
    the `/taskLog/` URL pattern:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskLogHandler`类处理任务日志操作，并映射到`/taskLog/` URL模式：'
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `TaskLogHandler` class will, hence, be mapped to the following URLs:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`TaskLogHandler`类将映射到以下URL：
- en: '`/taskLog/find` will map to the `find` method using a `GET` request'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/taskLog/find`将使用`GET`请求映射到`find`方法'
- en: '`/taskLog/store` will map to the `store` method using a `POST` request'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/taskLog/store`将使用`POST`请求映射到`store`方法'
- en: '`/taskLog/findByUser` will map to the `findByUser` method using a `GET` request'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/taskLog/findByUser`将使用`GET`请求映射到`findByUser`方法'
- en: '`/taskLog/remove` will map to the `remove` method using a `POST` request'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/taskLog/remove`将使用`POST`请求映射到`remove`方法'
- en: 'We have also introduced a new annotation: the `@InitBinder` annotation.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还引入了一个新的注解：`@InitBinder`注解。
- en: The @InitBinder annotation
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`@InitBinder`注解'
- en: The `@InitBinder` annotation is used to mark a method as "data binding aware".
    The method initializes the `WebDataBinder` object with editors that are used to
    transform String parameters into their Java equivalent. The most common need for
    this transformation is in the case of dates.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`@InitBinder`注解用于将方法标记为“数据绑定感知”。该方法使用编辑器初始化`WebDataBinder`对象，这些编辑器用于将String参数转换为它们的Java等效形式。这种转换最常见的需求是日期的情况。'
- en: 'A date can be represented in many different ways. All of the following dates
    are equivalent:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 日期可以用许多不同的方式表示。以下所有日期都是等效的：
- en: 06-Dec-2013
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 06-Dec-2013
- en: 6 Dec 2013
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2013年12月6日
- en: 06-12-2013 (UK date, short form)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 06-12-2013（英国日期，简写形式）
- en: 12-06-2013 (U.S. date, short form)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12-06-2013（美国日期，简写形式）
- en: 06-Dez-2013 (German date)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 06-Dez-2013（德国日期）
- en: December 6, 2013
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2013年12月6日
- en: 'Sending date representations via HTTP requests can be confusing to say the
    least! We all understand what most of these dates represent, but how can we convert
    these dates into a `java.util.Date` object? This is where the `@InitBinder` method
    is used. The code to specify the required date format involves registering a `CustomDateEditor`
    constructor for the `Date` class:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTP请求发送日期表示可能会令人困惑！我们都了解这些日期大部分代表什么，但是如何将这些日期转换为 `java.util.Date` 对象呢？这就是
    `@InitBinder` 方法的用途。指定所需日期格式的代码涉及为 `Date` 类注册 `CustomDateEditor` 构造函数：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will allow Spring to use the `DATE_FORMAT_yyyyMMdd` instance to parse
    the dates sent by clients in the `yyyyMMdd` format. The following URL will now
    be transformed correctly for the arguments required in the `findByUser` method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许Spring使用 `DATE_FORMAT_yyyyMMdd` 实例来解析客户端以 `yyyyMMdd` 格式发送的日期。以下URL现在将正确转换为
    `findByUser` 方法所需的参数：
- en: '`/taskLog/findByUser?username=bjones&startDate=20130719&endDate=20130812`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`/taskLog/findByUser?username=bjones&startDate=20130719&endDate=20130812`'
- en: The `true` argument in the `CustomDateEditor` constructor ensures that empty
    dates are given the value `null`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomDateEditor` 构造函数中的 `true` 参数确保空日期被赋予值 `null`。'
- en: More on Spring MVC
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于Spring MVC
- en: 'Our handler methods and Spring MVC implementations use only a small portion
    of the Spring MVC framework. There will be scenarios that the real-world applications
    encounter that have not been covered in this chapter. These include requirements
    such as the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理程序方法和Spring MVC实现仅使用了Spring MVC框架的一小部分。在这一章节中未涵盖到的真实应用程序可能遇到的情景包括以下要求：
- en: URI template patterns to access portions of a URL through path variables. They
    are especially useful to simplify RESTful processing and allow the handler methods
    to access the variables in URL patterns. The company `find` method could then
    be mapped to a URL such as `/company/find/5/`, where `5` represents the `idCompany`
    value. This is achieved through the use of the `@PathVariable` annotations and
    mappings in the form of `/company/find/{idCompany}`.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI模板模式用于通过路径变量访问URL的部分。它们特别有用于简化RESTful处理，并允许处理程序方法访问URL模式中的变量。公司 `find` 方法可以映射到诸如
    `/company/find/5/` 的URL，其中 `5` 代表 `idCompany` 的值。这是通过使用 `@PathVariable` 注解和形式为
    `/company/find/{idCompany}` 的映射来实现的。
- en: Using the `@SessionAttrribute` annotation to store data in the HTTP session
    between requests.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@SessionAttrribute` 注解在请求之间在HTTP会话中存储数据。
- en: Mapping cookie values with the `@CookieValue` annotation to allow a method parameter
    to be bound to the value of an HTTP cookie.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@CookieValue` 注解将 cookie 值映射到方法参数，以便将其绑定到 HTTP cookie 的值。
- en: Mapping request header attributes with the `@RequestHeader` annotation to allow
    a method parameter to be bound to a request header.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@RequestHeader` 注解将请求头属性映射到方法参数，以便将其绑定到请求头。
- en: Asynchronous request processing to allow the main servlet container thread to
    be released and allowed to process other requests.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步请求处理允许释放主Servlet容器线程并允许处理其他请求。
- en: Integrating Spring MVC with Spring Security (highly recommended for enterprise
    applications).
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Spring MVC与Spring Security集成（强烈推荐企业应用程序）。
- en: Parsing multipart requests to allow the users to upload files from HTML forms.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析多部分请求以允许用户从HTML表单上传文件。
- en: The testing of the handler classes using the Spring MVC Test framework should
    also be considered for enterprise Spring MVC applications. For more information,
    see the comprehensive guide at [http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/testing.html#spring-mvc-test-framework](http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/testing.html#spring-mvc-test-framework).
    The framework provides JUnit support for testing the client- and server-side Spring
    MVC applications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 应该考虑使用Spring MVC测试框架测试处理程序类。有关更多信息，请参阅[http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/testing.html#spring-mvc-test-framework](http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/testing.html#spring-mvc-test-framework)的全面指南。该框架提供了用于测试客户端和服务器端Spring
    MVC应用程序的JUnit支持。
- en: There is much more to the Spring MVC framework than can ever be covered in a
    single chapter. We recommend users find out more about Spring MVC capabilities
    from the excellent online resource at [http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html](http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC 框架远不止一个章节能够涵盖的内容。我们建议用户从[http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html](http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html)这个在线资源中了解更多关于Spring
    MVC功能的信息。
- en: Exercises
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Implement the `UserHandler` and `TaskHandler` classes, mapping the requests
    to the following methods:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `UserHandler` 和 `TaskHandler` 类，将请求映射到以下方法：
- en: '`/task/find` will map to the `TaskHandler.find` method using a `GET` request'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/task/find` 将使用 `GET` 请求映射到 `TaskHandler.find` 方法'
- en: '`/task/store` will map to the `TaskHandler.store` method using a `POST` request'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/task/store` 将使用 `POST` 请求映射到 `TaskHandler.store` 方法'
- en: '`/task/findAll` will map to the `TaskHandler.findAll` method using a `GET`
    request'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/task/findAll` 将使用 `GET` 请求映射到 `TaskHandler.findAll` 方法'
- en: '`/task/remove` will map to the `TaskHandler.remove` method using a `POST` request'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/task/remove` 将使用 `POST` 请求映射到 `TaskHandler.remove` 方法'
- en: '`/user/find` will map to the `UserHandler.find` method using a `GET` request'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/find` 将使用 `GET` 请求映射到 `UserHandler.find` 方法'
- en: '`/user/store` will map to the `UserHandler.store` method using a `POST` request'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/store` 将使用 `POST` 请求映射到 `UserHandler.store` 方法'
- en: '`/user/findAll` will map to the `UserHandler.findAll` method using a `GET`
    request'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/findAll` 将使用 `GET` 请求映射到 `UserHandler.findAll` 方法'
- en: '`/user/remove` will map to the `UserHandler.remove` method using a `POST` request'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/user/remove` 将使用 `POST` 请求映射到 `UserHandler.remove` 方法'
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Our Java web interface is now complete—we have created a fully functional request
    handling layer that is optimized for Ext JS 4 clients. The HTTP client-accessible
    URLs are mapped to the request-handling classes through the `@RequestMapping`
    annotations at the class and method levels. Each handler method interacts with
    the service layer through well-defined interfaces and processes the `Result` data
    transfer objects before returning JSON data in the HTTP response. We have configured
    the Spring Web MVC container with Java configuration classes and implemented a
    Spring interceptor to check whether a user has been authenticated.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Java Web界面现在已经完成 - 我们已经创建了一个针对Ext JS 4客户端进行了优化的完全功能的请求处理层。HTTP客户端可访问的URL通过类和方法级别的`@RequestMapping`注解映射到请求处理类。每个处理程序方法通过明确定义的接口与服务层交互，并在返回HTTP响应中的JSON数据之前处理`Result`数据传输对象。我们已经使用Java配置类配置了Spring
    Web MVC容器，并实现了一个Spring拦截器来检查用户是否已经经过身份验证。
- en: In [Chapter 8](ch08.html "Chapter 8. Running 3T on GlassFish"), *Running 3T
    on GlassFish*, we will complete our Spring configuration and deploy the 3T application
    on the GlassFish 4 server. Each layer in our application stack will then be ready
    to play its part in serving the Ext JS 4 client requests.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。在GlassFish上运行3T")中，“在GlassFish上运行3T”，我们将完成我们的Spring配置，并在GlassFish
    4服务器上部署3T应用程序。然后，我们应用程序堆栈中的每个层将准备好在为Ext JS 4客户端请求提供服务时发挥其作用。
