- en: Chapter 1. Building Microservices with Spring Boot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：使用 Spring Boot 构建 Microservices
- en: As we discussed in the last lesson, we are moving toward architectures with
    smaller, independently deployable microservices. This would mean that there will
    be a huge number of smaller microservices developed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一课中讨论的，我们正在向具有更小、独立可部署的微服务的架构迈进。这意味着将会有大量的较小微服务被开发。
- en: An important consequence is that we would need to be able to quickly get off
    the ground and get running with new components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的后果是，我们需要能够快速启动并运行新的组件。
- en: 'Spring Boot aims to solve the problem of getting off fast with a new component.
    In this lesson, we will start with understanding the capabilities Spring Boot
    brings to the table. We will answer the following questions:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 旨在解决快速启动新组件的问题。在本课中，我们将从了解 Spring Boot 带来的功能开始。我们将回答以下问题：
- en: Why Spring Boot?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 Spring Boot？
- en: What are the features that Spring Boot provides?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 提供了哪些功能？
- en: What is auto-configuration?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是自动配置？
- en: What is Spring Boot not?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 不是什么？
- en: What happens in the background when you use Spring Boot?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用 Spring Boot 时，后台会发生什么？
- en: How do you use Spring Initializr to create new Spring Boot projects?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何使用 Spring Initializr 创建新的 Spring Boot 项目？
- en: How do you create basic RESTful services with Spring Boot?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何使用 Spring Boot 创建基本的 RESTful 服务？
- en: What is Spring Boot?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Spring Boot？
- en: 'First of all, let''s start with clearing out a few misconceptions about Spring
    Boot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们先澄清一些关于 Spring Boot 的误解：
- en: Spring Boot is not a code generation framework. It does not generate any code.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 不是一个代码生成框架。它不会生成任何代码。
- en: Spring Boot is neither an application server, nor is it a web server. It provides
    good integration with different ranges of applications and web servers.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 既不是应用服务器，也不是网络服务器。它与不同范围的应用程序和网络服务器提供了良好的集成。
- en: Spring Boot does not implement any specific frameworks or specifications.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 不实现任何特定的框架或规范。
- en: 'These questions still remain:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题仍然存在：
- en: What is Spring Boot?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Spring Boot？
- en: Why has it become so popular in the last couple of years?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么它在过去几年变得如此流行？
- en: To answer these questions, let's build a quick example. Let's consider an example
    application that you want to quickly prototype.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，让我们构建一个快速示例。让我们考虑一个你想要快速原型化的示例应用程序。
- en: Building a Quick Prototype for a Microservice
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为微服务构建快速原型
- en: Let's say we want to build a microservice with Spring MVC and use JPA (with
    Hibernate as the implementation) to connect to the database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使用 Spring MVC 和 JPA（以 Hibernate 作为实现）来连接数据库，构建一个微服务。
- en: 'Let''s consider the steps in setting up such an application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑设置此类应用程序的步骤：
- en: Decide which versions of Spring MVC, JPA and Hibernate to use.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定要使用哪些版本的 Spring MVC、JPA 和 Hibernate。
- en: Set up a Spring context to wire all the different layers together.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 Spring 上下文以将所有不同的层连接在一起。
- en: 'Set up a web layer with Spring MVC (including Spring MVC configuration):'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Spring MVC（包括 Spring MVC 配置）设置一个网络层：
- en: Configure beans for DispatcherServlet, handler, resolvers, view resolvers, and
    so on
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 DispatcherServlet、处理器、解析器、视图解析器等配置 Bean
- en: 'Set up Hibernate in the data layer:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据层设置 Hibernate：
- en: Configure beans for SessionFactory, data source, and so on
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 SessionFactory、数据源等配置 Bean
- en: Decide and implement how to store your application configuration, which varies
    between different environments.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定并实现如何存储你的应用程序配置，这些配置在不同环境中会有所不同。
- en: Decide how you would want to do your unit testing.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定你将如何进行单元测试。
- en: Decide and implement your transaction management strategy.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定并实现你的事务管理策略。
- en: Decide and implement how to implement security.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定并实现如何实现安全性。
- en: Set up your logging framework.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置你的日志框架。
- en: Decide and implement how you want to monitor your application in production.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定并实现你希望在生产中监控应用程序的方式。
- en: Decide and implement a metrics management system to provide statistics about
    the application.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定并实现一个指标管理系统，以提供有关应用程序的统计数据。
- en: Decide and implement how to deploy your application to a web or application
    server.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定并实现如何将你的应用程序部署到网络或应用服务器。
- en: At least a few of the steps mentioned have to be completed before we can start
    with building our business logic. And this might take a few weeks at the least.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有一些提到的步骤必须在我们可以开始构建我们的业务逻辑之前完成。这至少需要几周的时间。
- en: When we build microservices, we would want to make a quick start. All the preceding
    steps will not make it easy to develop a microservice. And that's the problem
    Spring Boot aims to solve.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建微服务时，我们希望快速开始。所有前面的步骤都不会使开发微服务变得容易。这正是Spring Boot旨在解决的问题。
- en: 'The following quote is an extract from the Spring Boot website ([http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-documentation](http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-documentation)):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引用摘自Spring Boot网站([http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-documentation](http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-documentation))：
- en: Spring Boot makes it easy to create stand-alone, production-grade Spring based
    applications that you can "just run". We take an opinionated view of the Spring
    platform and third-party libraries so you can get started with minimum fuss. Most
    Spring Boot applications need very little Spring configuration
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Spring Boot使得创建独立、生产级别的基于Spring的应用程序变得容易，你可以“直接运行”。我们对Spring平台和第三方库持有一个有见地的观点，这样你可以以最小的麻烦开始。大多数Spring
    Boot应用程序需要非常少的Spring配置
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Spring Boot enables developers to focus on the business logic behind their microservice.
    It aims to take care of all the nitty-gritty technical details involved in developing
    microservices.
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Spring Boot使开发者能够专注于微服务背后的业务逻辑。它旨在处理开发微服务所涉及的所有繁琐的技术细节。
- en: Primary Goals
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要目标
- en: 'The primary goals of Spring Boot are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot的主要目标如下：
- en: Enable quickly getting off the ground with Spring-based projects.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使基于Spring的项目能够快速启动。
- en: Be opinionated. Make default assumptions based on common usage. Provide configuration
    options to handle deviations from defaults.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有见地。基于常见用法做出默认假设。提供配置选项以处理与默认值的偏差。
- en: Provide a wide range of nonfunctional features out of the box.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一系列开箱即用的非功能性特性。
- en: Do not use code generation and avoid using a lot of XML configuration.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用代码生成，并避免使用大量的XML配置。
- en: Nonfunctional Features
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非功能性特性
- en: 'A few of the nonfunctional features provided by Spring Boot are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供的部分非功能性特性如下：
- en: Default handling of versioning and configuration of a wide range of frameworks,
    servers, and specifications
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认处理各种框架、服务器和规范的版本和配置
- en: Default options for application security
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序安全性的默认选项
- en: Default application metrics with possibilities to extend
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认应用度量并提供扩展的可能性
- en: Basic application monitoring using health checks
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用健康检查进行基本的应用程序监控
- en: Multiple options for externalized configuration
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种外部化配置选项
- en: Spring Boot Hello World
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot Hello World
- en: We will start with building our first Spring Boot application in this lesson.
    We will use Maven to manage dependencies.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本课中开始构建我们的第一个Spring Boot应用程序。我们将使用Maven来管理依赖。
- en: 'The following steps are involved in starting up with a Spring Boot application:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Spring Boot应用程序涉及以下步骤：
- en: Configure `spring-boot-starter-parent` in your `pom.xml` file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`pom.xml`文件中配置`spring-boot-starter-parent`。
- en: Configure the `pom.xml` file with the required starter projects.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`pom.xml`文件以包含所需的启动项目。
- en: Configure `spring-boot-maven-plugin` to be able to run the application.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`spring-boot-maven-plugin`以能够运行应用程序。
- en: Create your first Spring Boot launch class.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的第一个Spring Boot启动类。
- en: Let's start with step 1, configuring the starter projects.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步，配置启动项目开始。
- en: Configure spring-boot-starter-parent
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置spring-boot-starter-parent
- en: 'Let''s start with a simple `pom.xml` file with `spring-boot-starter-parent`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从包含`spring-boot-starter-parent`的简单`pom.xml`文件开始：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first question is this: why do we need `spring-boot-starter-parent`?'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是这样的：为什么我们需要`spring-boot-starter-parent`？
- en: A `spring-boot-starter-parent` dependency contains the default versions of Java
    to use, the default versions of dependencies that Spring Boot uses, and the default
    configuration of the Maven plugins.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-parent`依赖包含要使用的Java默认版本、Spring Boot使用的依赖默认版本以及Maven插件的默认配置。'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `spring-boot-starter-parent` dependency is the parent POM providing dependency
    and plugin management for Spring Boot-based applications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-parent`依赖是提供基于Spring Boot应用程序的依赖和插件管理的父POM。'
- en: Let's look at some of the code inside `spring-boot-starter-parent` to get a
    deeper understanding about `spring-boot-starter-parent`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`spring-boot-starter-parent`内部的代码，以更深入地了解`spring-boot-starter-parent`。
- en: spring-boot-starter-parent
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: spring-boot-starter-parent
- en: 'The `spring-boot-starter-parent` dependency inherits from `spring-boot-dependencies`,
    which is defined at the top of the POM. The following code snippet shows an extract
    from `spring-boot-starter-parent`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-parent` 依赖项继承自 `spring-boot-dependencies`，它在 POM 的顶部定义。以下代码片段展示了
    `spring-boot-starter-parent` 的一个摘录：'
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `spring-boot-dependencies` provides default dependency management for all
    the dependencies that Spring Boot uses. The following code shows the different
    versions of various dependencies that are configured in `spring-boot-dependencies`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-dependencies` 为 Spring Boot 使用的所有依赖项提供默认的依赖管理。以下代码展示了在 `spring-boot-dependencies`
    中配置的各种依赖项的不同版本：'
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we want to override a specific version of a dependency, we can do that by
    providing a property with the right name in the `pom.xml` file of our application.
    The following code snippet shows an example of configuring our application to
    use version 1.10.20 of Mockito:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想覆盖特定版本的依赖项，我们可以在应用程序的 `pom.xml` 文件中提供一个具有正确名称的属性来实现。以下代码片段展示了如何配置我们的应用程序使用
    Mockito 的 1.10.20 版本：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following are some of the other things defined in `spring-boot-starter-parent`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 `spring-boot-starter-parent` 中定义的一些其他内容：
- en: The default Java version`<java.version>1.8</java.version>`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的 Java 版本 `<java.version>1.8</java.version>`
- en: 'The default configuration for Maven plugins:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven插件的默认配置：
- en: '`maven-failsafe-plugin`'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maven-failsafe-plugin`'
- en: '`maven-surefire-plugin`'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maven-surefire-plugin`'
- en: '`git-commit-id-plugin`'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git-commit-id-plugin`'
- en: Compatibility between different versions of frameworks is one of the major problems
    faced by developers. How do I find the latest Spring Session version that is compatible
    with a specific version of Spring? The usual answer would be to read the documentation.
    However, if we use Spring Boot, this is made simple by `spring-boot-starter-parent`.
    If we want to upgrade to a newer Spring version, all that we need to do is to
    find the `spring-boot-starter-parent`dependency for that Spring version. Once
    we upgrade our application to use that specific version of `spring-boot-starter-parent`,
    we would have all the other dependencies upgraded to the versions compatible with
    the new Spring version. One less problem for developers to handle. Always make
    me happy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不同框架版本之间的兼容性是开发者面临的主要问题之一。我如何找到与特定版本 Spring 兼容的最新 Spring Session 版本？通常的答案会是阅读文档。然而，如果我们使用
    Spring Boot，这通过 `spring-boot-starter-parent` 变得简单。如果我们想升级到较新的 Spring 版本，我们只需要找到那个
    Spring 版本的 `spring-boot-starter-parent` 依赖项。一旦我们将应用程序升级到使用那个特定的 `spring-boot-starter-parent`
    版本，我们就会拥有所有其他依赖项升级到与新 Spring 版本兼容的版本。这减少了开发者需要处理的问题。总是让我感到高兴。
- en: Configure pom.xml with the Required Starter Projects
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用必需的入门项目配置 pom.xml
- en: Whenever we want to build an application in Spring Boot, we would need to start
    looking for starter projects. Let's focus on understanding what a starter project
    is.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想在 Spring Boot 中构建应用程序时，我们都需要开始寻找入门项目。让我们专注于理解入门项目是什么。
- en: Understanding Starter Projects
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解入门项目
- en: 'Starters are simplified dependency descriptors customized for different purposes.
    For example, `spring-boot-starter-web` is the starter for building web application,
    including RESTful, using Spring MVC. It uses Tomcat as the default embedded container.
    If I want to develop a web application using Spring MVC, all we would need to
    do is include `spring-boot-starter-web` in our dependencies, and we get the following
    automatically pre-configured:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 入门项目是针对不同目的简化的依赖描述符。例如，`spring-boot-starter-web` 是用于构建 Web 应用程序（包括 RESTful）的入门项目，使用
    Spring MVC。它使用 Tomcat 作为默认的嵌入式容器。如果我想使用 Spring MVC 开发 Web 应用程序，我们只需要在我们的依赖项中包含
    `spring-boot-starter-web`，我们就会自动获得以下预配置：
- en: Spring MVC
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC
- en: Compatible versions of `jackson-databind` (for binding) and hibernate-validator
    (for form validation)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jackson-databind`（用于绑定）和 hibernate-validator（用于表单验证）的兼容版本'
- en: '`spring-boot-starter-tomcat` (starter project for Tomcat)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-tomcat`（Tomcat 的入门项目）'
- en: 'The following code snippet shows some of the dependencies configured in `spring-boot-starter-web`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了在 `spring-boot-starter-web` 中配置的一些依赖项：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see in the preceding snippet, when we use`spring-boot-starter-web`,
    we get a lot of frameworks auto-configured.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个摘录中所示，当我们使用 `spring-boot-starter-web` 时，我们会自动配置许多框架。
- en: 'For the web application we would like to build, we would also want to do some
    good unit testing and deploy it on Tomcat. The following snippet shows the different
    starter dependencies that we would need. We would need to add this to our `pom.xml`
    file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要构建的 Web 应用程序，我们还想做一些良好的单元测试，并在 Tomcat 上部署它。以下片段显示了我们需要的不同启动依赖项。我们需要将其添加到我们的
    `pom.xml` 文件中：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We add three starter projects:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了三个启动项目：
- en: We've already discussed `spring-boot-starter-web`. It provides us with the frameworks
    needed to build a web application with Spring MVC.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经讨论了 `spring-boot-starter-web`。它为我们提供了构建带有 Spring MVC 的 Web 应用程序所需的框架。
- en: 'The `spring-boot-starter-test` dependency provides the following test frameworks
    needed for unit testing:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-test` 依赖项提供了以下单元测试所需的测试框架：'
- en: '**JUnit**: Basic unit test framework'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JUnit**：基本的单元测试框架'
- en: '**Mockito**: For mocking'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mockito**：用于模拟'
- en: '**Hamcrest**, **AssertJ**: For readable asserts'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hamcrest**、**AssertJ**：用于可读断言'
- en: '**Spring Test**: A unit testing framework for spring-context based applications'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Test**：基于 spring-context 的应用程序的单元测试框架'
- en: The `spring-boot-starter-tomcat` dependency is the default for running web applications.
    We include it for clarity. The `spring-boot-starter-tomcat` is the starter for
    using Tomcat as the embedded servlet container.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-tomcat` 依赖项是运行 Web 应用程序时的默认选项。我们包括它以增加清晰度。`spring-boot-starter-tomcat`
    是使用 Tomcat 作为嵌入式 Servlet 容器的启动器。'
- en: We now have our `pom.xml` file configured with the starter parent and the required
    starter projects. Let's add `spring-boot-maven-plugin` now, which would enable
    us to run Spring Boot applications.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经配置了 `pom.xml` 文件，包括启动父项目和所需的启动项目。现在让我们添加 `spring-boot-maven-plugin`，这将使我们能够运行
    Spring Boot 应用程序。
- en: Configuring spring-boot-maven-plugin
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 spring-boot-maven-plugin
- en: 'When we build applications using Spring Boot, there are a couple of situations
    that are possible:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Spring Boot 构建应用程序时，可能存在几种情况：
- en: We would want to run the applications in place without building a JAR or a WAR
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望在不构建 JAR 或 WAR 文件的情况下运行应用程序
- en: We would want to build a JAR and a WAR for later deployment
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望构建 JAR 和 WAR 文件以供后续部署
- en: 'The `spring-boot-maven-plugin` dependency provides capabilities for both of
    the preceding situations. The following snippet shows how we can configure `spring-boot-maven-plugin`
    in an application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-maven-plugin` 依赖项为上述两种情况都提供了功能。以下片段显示了如何在应用程序中配置 `spring-boot-maven-plugin`：'
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `spring-boot-maven-plugin` dependency provides several goals for a Spring
    Boot application. The most popular goal is run (this can be executed as `mvn spring-boot:run`
    on the command prompt from the root folder of the project).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-boot-maven-plugin` 依赖项为 Spring Boot 应用程序提供了几个目标。最受欢迎的目标是运行（这可以在项目根目录的命令提示符下作为
    `mvn spring-boot:run` 执行）。'
- en: Creating Your First Spring Boot Launch Class
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的第一个 Spring Boot 启动类
- en: 'The following class explains how to create a simple Spring Boot launch class.
    It uses the static run method from the `SpringApplication` class, as shown in
    the following code snippet:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类解释了如何创建一个简单的 Spring Boot 启动类。它使用 `SpringApplication` 类中的静态 `run` 方法，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code is a simple Java `main` method executing the static `run`
    method on the `SpringApplication` class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码是一个简单的 Java `main` 方法，在 `SpringApplication` 类上执行静态 `run` 方法。
- en: The SpringApplication Class
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SpringApplication 类
- en: The `SpringApplication` class can be used to Bootstrap and launch a Spring application
    from a Java `main` method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpringApplication` 类可用于从 Java `main` 方法中引导和启动 Spring 应用程序。'
- en: 'The following are the steps that are typically performed when a Spring Boot
    application is bootstrapped:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Spring Boot 应用程序启动时通常执行的步骤：
- en: Create an instance of Spring's `ApplicationContext`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Spring 的 `ApplicationContext` 实例。
- en: Enable the functionality to accept command-line arguments and expose them as
    Spring properties.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用接受命令行参数并将其作为 Spring 属性公开的功能。
- en: Load all the Spring beans as per the configuration.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据配置加载所有 Spring Bean。
- en: The @SpringBootApplication Annotation
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@SpringBootApplication` 注解'
- en: 'The `@SpringBootApplication` annotation is a shortcut for three annotations:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SpringBootApplication` 注解是三个注解的快捷方式：'
- en: '`@Configuration`: Indicates that this a Spring application context configuration
    file.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Configuration`：表示这是一个 Spring 应用程序上下文配置文件。'
- en: '`@EnableAutoConfiguration`: Enables auto-configuration, an important feature
    of Spring Boot. We will discuss auto-configuration later in a separate section.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableAutoConfiguration`：启用自动配置，这是 Spring Boot 的重要功能。我们将在单独的部分中稍后讨论自动配置。'
- en: '`@ComponentScan`: Enables scanning for Spring beans in the package of this
    class and all its sub packages.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ComponentScan`：启用在此类及其所有子包中扫描Spring bean。'
- en: Running Our Hello World Application
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的Hello World应用程序
- en: 'We can run the Hello World application in multiple ways. Let''s start running
    it with the simplest option--running as a Java application. In your IDE, right-click
    on the application **class** and run it as **Java Application**. The following
    screenshot shows some of the log from running our `Hello World` application:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用多种方式运行Hello World应用程序。让我们从最简单的方式开始运行它--以Java应用程序的方式运行。在你的IDE中，右键单击应用程序**类**，然后以**Java应用程序**的方式运行它。以下截图显示了运行我们的`Hello
    World`应用程序的一些日志：
- en: '![Running Our Hello World Application](img/1.1.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的Hello World应用程序](img/1.1.jpg)'
- en: 'The following are the key things to note:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要注意的关键事项：
- en: 'Tomcat server is launched on port `8080`--`Tomcat started on port(s): 8080
    (http)`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Tomcat服务器在端口`8080`上启动--`Tomcat在端口(s): 8080 (http)上启动`。'
- en: '`DispatcherServlet` is configured. This means that Spring MVC Framework is
    ready to accept requests--`Mapping servlet: ''dispatcherServlet'' to [/]`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`已配置。这意味着Spring MVC框架已准备好接受请求--`将servlet: ''dispatcherServlet''映射到[/]`。'
- en: Four filters--`characterEncodingFilter`, `hiddenHttpMethodFilter`, `httpPutFormContentFilter`
    and `requestContextFilter`--are enabled by default
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认启用了四个过滤器--`characterEncodingFilter`、`hiddenHttpMethodFilter`、`httpPutFormContentFilter`和`requestContextFilter`
- en: The default error page is configured--`Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String,
    java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)`
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认错误页面已配置--`将"{[/error]}"映射到公共org.springframework.http.ResponseEntity<java.util.Map<java.lang.String,
    java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)`
- en: WebJars are autoconfigured. WebJars enable dependency management for static
    dependencies such as Bootstrap and query--`Mapped URL path [/webjars/**] onto
    handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebJars已自动配置。WebJars使静态依赖项（如Bootstrap和查询）的依赖项管理成为可能--`将URL路径[/webjars/**]映射到类型为[class
    org.springframework.web.servlet.resource.ResourceHttpRequestHandler]`的处理程序`
- en: 'The following screenshot shows the application layout as of now. We have just
    two files, `pom.xml` and `Application.java`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当前的应用程序布局。我们只有两个文件，`pom.xml`和`Application.java`：
- en: '![Running Our Hello World Application](img/1.2.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的Hello World应用程序](img/1.2.jpg)'
- en: With a simple `pom.xml` file and one Java class, we were able to get to launch
    the Spring MVC application, with all the preceding functionality described. The
    most important thing about Spring Boot is to understand what happens in the background.
    Understanding the preceding start up log is the first. Let's look at the Maven
    dependencies to get a deeper picture.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用一个简单的`pom.xml`文件和一个Java类，我们就能够启动Spring MVC应用程序，并具有前面描述的所有功能。关于Spring Boot最重要的东西是理解后台发生了什么。理解前面的启动日志是第一步。让我们看看Maven依赖项以获得更清晰的了解。
- en: 'The following screenshot shows some of the dependencies that are configured
    with the basic configuration in the `pom.xml` file that we created:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们在创建的`pom.xml`文件中的基本配置中配置的一些依赖项：
- en: '![Running Our Hello World Application](img/1.3.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的Hello World应用程序](img/1.3.jpg)'
- en: Spring Boot does a lot of magic. Once you have the application configured and
    running, I recommend that you play around with it to gain a deeper understanding
    that will be useful when you are debugging problems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot做了很多魔法。一旦你的应用程序配置并运行，我建议你玩一玩它，以获得更深入的理解，这将有助于你在调试问题时。
- en: As Spiderman says, with great power, comes great responsibility. This is absolutely
    true in the case of Spring Boot. In the time to come, the best developers with
    Spring Boot would be the ones who understand what happens in the background--dependencies
    and auto-configuration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如蜘蛛侠所说，能力越大，责任越大。这在Spring Boot的情况下绝对正确。在未来的时间里，最好的Spring Boot开发者将是那些理解后台发生什么的人--依赖项和自动配置。
- en: Auto-configuration
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动配置
- en: 'To enable us to understand auto-configuration further, let''s expand our application
    class to include a few more lines of code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们进一步理解自动配置，让我们扩展我们的应用程序类以包含更多代码行：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We get all the beans that are defined in the Spring application context and
    print their names. When `Application.java` is run as a Java program, it prints
    the list of beans, as shown in the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取在Spring应用程序上下文中定义的所有bean并打印它们的名称。当`Application.java`作为Java程序运行时，它将打印bean列表，如下面的输出所示：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Important things to think about are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的重要事项如下：
- en: Where are these beans defined?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些bean在哪里定义？
- en: How are these beans created?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些bean是如何创建的？
- en: That's the magic of Spring auto-configuration.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Spring自动配置的魔力。
- en: Whenever we add a new dependency to a Spring Boot project, Spring Boot auto-configuration
    automatically tries to configure the beans based on the dependency.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们向Spring Boot项目添加一个新的依赖项时，Spring Boot自动配置会自动尝试根据依赖项配置bean。
- en: 'For example, when we add a dependency in `spring-boot-starter-web`, the following
    beans are auto-configured:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们向`spring-boot-starter-web`添加依赖项时，以下bean将被自动配置：
- en: '`basicErrorController`, `handlerExceptionResolver`: It is the basic exception
    handling. It shows a default error page when an exception occurs.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`basicErrorController`、`handlerExceptionResolver`：它是基本的异常处理。当发生异常时，它显示默认的错误页面。'
- en: '`beanNameHandlerMapping`: It is used to resolve paths to a handler (controller).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beanNameHandlerMapping`：它用于解析到处理器（控制器）的路径。'
- en: '`characterEncodingFilter`: It provides default character encoding UTF-8.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`characterEncodingFilter`：它提供默认字符编码UTF-8。'
- en: '`dispatcherServlet`: It is the front controller in Spring MVC applications.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatcherServlet`：它是Spring MVC应用程序的前端控制器。'
- en: '`jacksonObjectMapper`: It translates objects to JSON and JSON to objects in
    REST services.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jacksonObjectMapper`：它在REST服务中将对象转换为JSON，并将JSON转换为对象。'
- en: '`messageConverters`: It is the default message converters to convert from objects
    into XML or JSON and vice versa.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messageConverters`：它是默认的消息转换器，用于将对象转换为XML或JSON，反之亦然。'
- en: '`multipartResolver`: It provides support to upload files in web applications.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multipartResolver`：它为Web应用程序提供上传文件的支持。'
- en: '`mvcValidator`: It supports validation of HTTP requests.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mvcValidator`：它支持HTTP请求的验证。'
- en: '`viewResolver`: It resolves a logical view name to a physical view.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewResolver`：它将逻辑视图名称解析为物理视图。'
- en: '`propertySourcesPlaceholderConfigurer`: It supports the externalization of
    application configuration.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertySourcesPlaceholderConfigurer`：它支持应用程序配置的外部化。'
- en: '`requestContextFilter`: It defaults the filter for requests.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestContextFilter`：它默认为请求设置过滤器。'
- en: '`restTemplateBuilder`: It is used to make calls to REST services.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restTemplateBuilder`：它用于调用REST服务。'
- en: '`tomcatEmbeddedServletContainerFactory`: Tomcat is the default embedded servlet
    container for Spring Boot-based web applications.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tomcatEmbeddedServletContainerFactory`：Tomcat是Spring Boot基于Web应用程序的默认嵌入式servlet容器。'
- en: In the next section, let's look at some of the starter projects and the auto-configuration
    they provide.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看一些入门项目和它们提供的自动配置。
- en: Starter Projects
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门项目
- en: 'The following table shows some of the important starter projects provided by
    Spring Boot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了Spring Boot提供的一些重要入门项目：
- en: '| Starter | Description |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 入门项目 | 描述 |'
- en: '| --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `spring-boot-starter-webservices` | This is a starter project to develop
    XMLbased web services. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-webservices` | 这是一个用于开发基于XML的Web服务的入门项目。|'
- en: '| `spring-boot-starter-web` | This is a starter project to build Spring MVC-based
    web applications or RESTful applications. It uses Tomcat as the default embedded
    servlet container. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-web` | 这是一个用于构建基于Spring MVC的Web应用程序或RESTful应用程序的入门项目。它使用Tomcat作为默认的嵌入式servlet容器。|'
- en: '| `spring-boot-starter-activemq` | This supports message-based communication
    using JMS on ActiveMQ. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-activemq` | 这支持在ActiveMQ上使用JMS进行基于消息的通信。|'
- en: '| `spring-boot-starterintegration` | This supports the Spring Integration Framework
    that provides implementations for Enterprise Integration Patterns. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starterintegration` | 这支持提供企业集成模式实现的Spring Integration框架。|'
- en: '| `spring-boot-starter-test` | This provides support for various unit testing
    frameworks, such as JUnit, Mockito, and Hamcrest matchers. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-test` | 这提供了对各种单元测试框架的支持，例如JUnit、Mockito和Hamcrest匹配器。|'
- en: '| `spring-boot-starter-jdbc` | This provides support for using Spring JDBC.
    It configures a Tomcat JDBC connection pool by default. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-jdbc` | 这提供了使用Spring JDBC的支持。它默认配置了一个Tomcat JDBC连接池。|'
- en: '| `spring-boot-startervalidation` | This provides support for the Java Bean
    Validation API. Its default implementation is hibernate-validator. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-startervalidation` | 这提供了对Java Bean Validation API的支持。它的默认实现是hibernate-validator。|'
- en: '| `spring-boot-starter-hateoas` | HATEOAS stands for Hypermedia as the Engine
    of Application State. RESTful services that use HATEOAS return links to additional
    resources that are related to the current context in addition to data. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-hateoas` | HATEOAS 代表超媒体作为应用程序状态引擎。使用 HATEOAS 的 RESTful
    服务除了数据外，还返回与当前上下文相关的附加资源的链接。|'
- en: '| `spring-boot-starter-jersey` | JAX-RS is the Java EE standard to develop
    REST APIs. Jersey is the default implementation. This starter project provides
    support to build JAX-RS-based REST APIs. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-jersey` | JAX-RS 是 Java EE 标准用于开发 REST API。Jersey 是默认实现。此启动项目提供了基于
    JAX-RS 的 REST API 的支持。|'
- en: '| `spring-boot-starterwebsocket` | HTTP is stateless. WebSockets allow you
    to maintain a connection between the server and the browser. This starter project
    provides support for Spring WebSockets. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-websocket` | HTTP 是无状态的。WebSockets 允许你保持服务器和浏览器之间的连接。此启动项目提供了对
    Spring WebSockets 的支持。|'
- en: '| `spring-boot-starter-aop` | This provides support for Aspect Oriented Programming.
    It also provides support for AspectJ for advanced aspect-oriented programming.
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-aop` | 这提供了对面向方面编程的支持。它还提供了对 AspectJ 的支持，用于高级面向方面编程。|'
- en: '| `spring-boot-starter-amqp` | With RabbitMQ as the default, this starter project
    provides message passing with AMQP. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-amqp` | 以 RabbitMQ 为默认，此启动项目提供了基于 AMQP 的消息传递。|'
- en: '| `spring-boot-starter-security` | This starter project enables auto-configuration
    for Spring Security. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-security` | 此启动项目使 Spring Security 的自动配置成为可能。|'
- en: '| `spring-boot-starter-data-jpa` | This provides support for Spring Data JPA.
    Its default implementation is Hibernate. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-data-jpa` | 这提供了对 Spring Data JPA 的支持。其默认实现是 Hibernate。|'
- en: '| `spring-boot-starter` | This is a base starter for Spring Boot applications.
    It provides support for auto-configuration and logging. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter` | 这是 Spring Boot 应用程序的基础启动项目。它提供了自动配置和日志记录的支持。|'
- en: '| `spring-boot-starter-batch` | This provides support to develop batch applications
    using Spring Batch. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-batch` | 这提供了使用 Spring Batch 开发批处理应用程序的支持。|'
- en: '| `spring-boot-starter-cache` | This is the basic support for caching using
    Spring Framework. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-cache` | 这是使用 Spring 框架进行缓存的基本支持。|'
- en: '| `spring-boot-starter-datarest` | This is the support to expose REST services
    using Spring Data REST. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-data-rest` | 这是使用 Spring Data REST 暴露 REST 服务的支持。|'
- en: 'Until now, we have set up a basic web application and understood some of the
    important concepts related to Spring Boot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了一个基本的 Web 应用程序，并理解了与 Spring Boot 相关的一些重要概念：
- en: Auto-configuration
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动配置
- en: Starter projects
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动项目
- en: '`spring-boot-maven-plugin`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-maven-plugin`'
- en: '`spring-boot-starter-parent`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-boot-starter-parent`'
- en: Annotation `@SpringBootApplication`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解 `@SpringBootApplication`
- en: Now let's shift our focus to understanding what REST is and building a REST
    Service.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们将重点转向理解 REST 是什么以及如何构建 REST 服务。 '
- en: What is REST?
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 REST？
- en: '**Representational State Transfer** (**REST**) is basically an architectural
    style for the web. REST specifies a set of constraints. These constraints ensure
    that clients (service consumers and browsers) can interact with servers in flexible
    ways.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移** (**REST**) 基本上是一种网络架构风格。REST 规定了一系列约束。这些约束确保客户端（服务消费者和浏览器）可以以灵活的方式与服务器交互。'
- en: 'Let''s first understand some common terminologies:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解一些常见的术语：
- en: '**Server**: Service provider. Exposes services which can be consumed by clients.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：服务提供者。提供客户端可以消费的服务。'
- en: '**Client**: Service consumer. Could be a browser or another system.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：服务消费者。可能是浏览器或另一个系统。'
- en: '**Resource**: Any information can be a resource: a person, an image, a video,
    or a product you want to sell.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：任何信息都可以是资源：一个人、一张图片、一个视频或你想要出售的产品。'
- en: '**Representation**: A specific way a resource can be represented. For example,
    the product resource can be represented using JSON, XML, or HTML. Different clients
    might request different representations of the resource.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示**：资源可以表示的特定方式。例如，产品资源可以使用 JSON、XML 或 HTML 来表示。不同的客户端可能会请求资源的不同表示形式。'
- en: 'Some of the important REST constraints are listed as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的 REST 约束：
- en: '**Client-Server**: There should be a server (service provider) and a client
    (service consumer). This enables loose coupling and independent evolution of the
    server and client as new technologies emerge.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端-服务器**：应该有一个服务器（服务提供者）和一个客户端（服务消费者）。这使服务器和客户端能够随着新技术的出现而松散耦合和独立演进。'
- en: '**Stateless**: Each service should be stateless. Subsequent requests should
    not depend on some data from a previous request being temporarily stored. Messages
    should be self-descriptive.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：每个服务应该是无状态的。后续请求不应依赖于之前请求中临时存储的一些数据。消息应该是自我描述的。'
- en: '**Uniform interface**: Each resource has a resource identifier. In the case
    of web services, we use this URI example: `/users/Jack/todos/1`. In this, URI
    Jack is the name of the user. `1` is the ID of the todo we would want to retrieve.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一接口**：每个资源都有一个资源标识符。在 Web 服务的情况下，我们使用这个 URI 示例：`/users/Jack/todos/1`。在这里，URI
    中的 Jack 是用户的名称，`1` 是我们想要检索的待办事项的 ID。'
- en: '**Cacheable**: The service response should be cacheable. Each response should
    indicate whether it is cacheable.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存**：服务响应应该是可缓存的。每个响应都应该指示它是否可缓存。'
- en: '**Layered system**: The consumer of the service should not assume a direct
    connection to the service provider. Since requests can be cached, the client might
    be getting the cached response from a middle layer.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层系统**：服务的消费者不应假设与服务提供者有直接连接。由于请求可以被缓存，客户端可能会从中间层获取缓存的响应。'
- en: '**Manipulation of resources through representations**: A resource can have
    multiple representations. It should be possible to modify the resource through
    a message with any of these representations.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过表示修改资源**：资源可以有多个表示。应该可以通过带有这些表示之一的消息来修改资源。'
- en: '**Hypermedia as the engine of application state** (**HATEOAS**): The consumer
    of a RESTful application should know about only one fixed service URL. All subsequent
    resources should be discoverable from the links included in the resource representations.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超媒体作为应用程序状态引擎**（**HATEOAS**）：RESTful 应用程序的消费者应该只知道一个固定的服务 URL。所有后续资源都应该可以从资源表示中包含的链接中找到。'
- en: 'An example response with the HATEOAS link is shown here. This is the response
    to a request to retrieve all todos:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了带有 HATEOAS 链接的示例响应。这是请求检索所有待办事项的响应：
- en: '[PRE10]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding response includes links to the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的响应包括以下链接：
- en: Specific todos (`http://localhost:8080/todos/1`)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的待办事项（`http://localhost:8080/todos/1`）
- en: Search `resource` (`http://localhost:8080/todos/search`)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索 `resource`（`http://localhost:8080/todos/search`）
- en: If the service consumer wants to do a search, it has the option of taking the
    search URL from the response and sending the search request to it. This would
    reduce coupling between the service provider and the service consumer.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务消费者想要进行搜索，它可以选择从响应中获取搜索 URL 并向其发送搜索请求。这将减少服务提供者与服务消费者之间的耦合。
- en: The initial services we develop will not be adhering to all these constraints.
    As we move on to the next lessons, we will introduce you to the details of these
    constraints and add them to the services to make them more RESTful.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初开发的服务将不会遵守所有这些约束。随着我们进入下一课，我们将向您介绍这些约束的细节并将它们添加到服务中，使它们更加 RESTful。
- en: First REST Service
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个 REST 服务
- en: 'Let''s start with creating a simple REST service returning a welcome message.
    We will create a simple POJO `WelcomeBean` class with a member field called message
    and one argument constructor, as shown in the following code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的 REST 服务开始，该服务返回一个欢迎消息。我们将创建一个简单的 POJO `WelcomeBean` 类，其中有一个名为 message
    的成员字段和一个参数构造函数，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Simple Method Returning String
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单返回字符串的方法
- en: 'Let''s start with creating a simple REST Controller method returning a string:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的 REST 控制器方法返回一个字符串开始：
- en: '[PRE12]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A few important things to note are as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`@RestController`: The `@RestController` annotation provides a combination
    of `@ResponseBody` and `@Controller` annotations. This is typically used to create
    REST Controllers.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RestController`：`@RestController` 注解提供了 `@ResponseBody` 和 `@Controller` 注解的组合。这通常用于创建
    REST 控制器。'
- en: '`@GetMapping("welcome")`: `@GetMapping` is a shortcut for `@RequestMapping(method
    = RequestMethod.GET)`. This annotation is a readable alternative. The method with
    this annotation would handle a Get request to the `welcome` URI.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GetMapping("welcome")`：`@GetMapping` 是 `@RequestMapping(method = RequestMethod.GET)`
    的快捷方式。这个注解是一个可读的替代方案。带有此注解的方法将处理对 `welcome` URI 的 GET 请求。'
- en: 'If we run `Application.java` as a Java application, it would start up the embedded
    Tomcat container. We can launch up the URL in the browser, as shown in the following
    screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `Application.java` 作为 Java 应用程序运行，它将启动嵌入的 Tomcat 容器。我们可以在浏览器中打开这个 URL，如下面的截图所示：
- en: '![Simple Method Returning String](img/01_03.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![简单返回字符串的方法](img/01_03.jpg)'
- en: Unit Testing
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Let''s quickly write a unit test to test the preceding `controller` method:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速编写一个单元测试来测试前面的`controller`方法：
- en: '[PRE13]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding unit test, we will launch up a Mock MVC instance with `BasicController`.
    A few quick things to note are as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的单元测试中，我们将使用`BasicController`启动一个Mock MVC实例。以下是一些需要注意的快速事项：
- en: '`@RunWith(SpringRunner.class)`: SpringRunner is a shortcut to the `SpringJUnit4ClassRunner`
    annotation. This launches up a simple Spring context for unit testing.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RunWith(SpringRunner.class)`: SpringRunner是`SpringJUnit4ClassRunner`注解的快捷方式。这将为单元测试启动一个简单的Spring上下文。'
- en: '`@WebMvcTest(BasicController.class)`: This annotation can be used along with
    SpringRunner to write simple tests for Spring MVC controllers. This will load
    only the beans annotated with Spring-MVC-related annotations. In this example,
    we are launching a Web MVC Test context with the class under test being BasicController.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WebMvcTest(BasicController.class)`: 这个注解可以与SpringRunner一起使用来编写简单的Spring MVC控制器测试。这将只加载带有Spring-MVC相关注解的bean。在这个例子中，我们使用BasicController作为测试类启动一个Web
    MVC测试上下文。'
- en: '`@Autowired private MockMvc mvc`: Autowires the MockMvc bean that can be used
    to make requests.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Autowired private MockMvc mvc`: 自动装配可以用来发送请求的MockMvc bean。'
- en: '`mvc.perform(MockMvcRequestBuilders.get("/welcome").accept(MediaType.APPLICATION_JSON))`:
    Performs a request to `/welcome` with the `Accept` header value `application/json`.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mvc.perform(MockMvcRequestBuilders.get("/welcome").accept(MediaType.APPLICATION_JSON))`:
    执行一个带有`Accept`头值为`application/json`的请求到`/welcome`。'
- en: '`andExpect(status().isOk())`: Expects that the status of the response is 200
    (success).'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`andExpect(status().isOk())`: 期望响应的状态是200（成功）。'
- en: '`andExpect(content().string(equalTo("Hello World")))`: Expects that the content
    of the response is equal to `"Hello World"`.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`andExpect(content().string(equalTo("Hello World")))`: 期望响应的内容等于`"Hello World"`。'
- en: Integration Testing
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'When we do integration testing, we would want to launch the embedded server
    with all the controllers and beans that are configured. This code snippet shows
    how we can create a simple integration test:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行集成测试时，我们希望启动带有所有配置的控制器和bean的嵌入式服务器。以下代码片段显示了如何创建一个简单的集成测试：
- en: '[PRE14]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A few important things to note are as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`@SpringBootTest(classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)`:
    It provides additional functionality on top of the Spring `TestContext`. Provides
    support to configure the port for fully running the container and `TestRestTemplate`
    (to execute requests).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SpringBootTest(classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)`:
    它在Spring `TestContext`之上提供了额外的功能。提供了配置完全运行容器和`TestRestTemplate`（执行请求）端口的支撑。'
- en: '`@LocalServerPort private int port`: The `SpringBootTest` would ensure that
    the port on which the container is running is autowired into the `port` variable.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@LocalServerPort private int port`: `SpringBootTest`将确保容器运行的端口自动装配到`port`变量中。'
- en: '`private String createURL(String uri)`: The method to append the local host
    URL and port to the URI to create a full URL.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private String createURL(String uri)`: 该方法将本地主机URL和端口附加到URI以创建一个完整的URL。'
- en: '`private TestRestTemplate template = new TestRestTemplate()`: The `TestRestTemplate`
    is typically used in integration tests. It provides additional functionality on
    top of `RestTemplate`, which is especially useful in the integration test context.
    It does not follow redirects so that we can assert response location.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private TestRestTemplate template = new TestRestTemplate()`: `TestRestTemplate`通常用于集成测试。它提供了在`RestTemplate`之上的额外功能，这在集成测试上下文中特别有用。它不会跟随重定向，这样我们就可以断言响应位置。'
- en: '`template.getForEntity(createURL("/welcome"), String.class)`: It executes a
    get request for the given URI.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template.getForEntity(createURL("/welcome"), String.class)`: 它执行了对给定URI的GET请求。'
- en: '`assertThat(response.getBody(), equalTo("Hello World"))`: It asserts that the
    response body content is `"Hello World"`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertThat(response.getBody(), equalTo("Hello World"))`: 它断言响应体内容为`"Hello
    World"`。'
- en: Simple REST Method Returning an Object
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的REST方法返回一个对象
- en: 'In the previous method, we returned a string. Let''s create a method that returns
    a proper JSON response. Take a look at the following method:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们返回了一个字符串。让我们创建一个返回适当JSON响应的方法。看看以下方法：
- en: '[PRE15]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This preceding method returns a simple `WelcomeBean` initialized with a message:
    `"Hello World"`.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法返回了一个初始化为消息`"Hello World"`的简单`WelcomeBean`。
- en: Executing a Request
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行请求
- en: 'Let''s send a test request and see what response we get. The following screenshot
    shows the output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发送一个测试请求并查看我们得到的响应。以下截图显示了输出：
- en: '![Executing a Request](img/01_04.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![执行请求](img/01_04.jpg)'
- en: 'The response for the `http://localhost:8080/welcome-with-object` URL is shown
    as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `http://localhost:8080/welcome-with-object` URL 的响应如下：
- en: '[PRE16]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The question that needs to be answered is this: how does the `WelcomeBean`
    object that we returned get converted into JSON?'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 需要回答的问题是：我们返回的 `WelcomeBean` 对象是如何被转换为 JSON 的？
- en: Again, it's the magic of Spring Boot auto-configuration. If Jackson is on the
    classpath of an application, instances of the default object to JSON (and vice
    versa) converters are auto-configured by Spring Boot.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是 Spring Boot 自动配置的魔力。如果一个应用中存在 Jackson，Spring Boot 会自动配置默认的对象到 JSON（反之亦然）转换器实例。
- en: Unit Testing
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Let''s quickly write a unit test checking for the JSON response. Let''s add
    the test to `BasicControllerTest`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速编写一个检查 JSON 响应的单元测试。让我们将测试添加到 `BasicControllerTest`：
- en: '[PRE17]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test is very similar to the earlier unit test except that we are using
    `containsString` to check whether the content contains a substring `"Hello World"`.
    We will learn how to write proper JSON tests a little later.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试与早期的单元测试非常相似，只是我们使用 `containsString` 来检查内容是否包含子字符串 `"Hello World"`。我们将在稍后学习如何编写正确的
    JSON 测试。
- en: Integration Testing
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'Let''s shift our focus to writing an integration test. Let''s add a method
    to `BasicControllerIT`, as shown in the following code snippet:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把重点转向编写集成测试。让我们在 `BasicControllerIT` 中添加一个方法，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method is similar to the earlier integration test except that we are asserting
    for a sub-string using the `String`method.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与早期的集成测试类似，只是我们使用 `String` 方法断言子字符串。
- en: Get Method with Path Variables
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有路径变量的 Get 方法
- en: 'Let''s shift our attention to path variables. Path variables are used to bind
    values from the URI to a variable on the controller method. In the following example,
    we want to parameterize the name so that we can customize the welcome message
    with a name:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向路径变量。路径变量用于将 URI 中的值绑定到控制器方法上的变量。在以下示例中，我们想参数化名字，以便我们可以使用名字自定义欢迎消息：
- en: '[PRE19]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A few important things to note are as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要事项如下：
- en: '`@GetMapping("/welcome-with-parameter/name/{name}")`: `{name}` indicates that
    this value will be the variable. We can have multiple variable templates in a
    URI.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GetMapping("/welcome-with-parameter/name/{name}")`: `{name}` 表示这个值将是变量。一个
    URI 中可以有多个变量模板。'
- en: '`welcomeWithParameter(@PathVariable String name)`: `@PathVariable` ensures
    that the variable value from the URI is bound to the variable name.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`welcomeWithParameter(@PathVariable String name)`: `@PathVariable` 确保从 URI
    绑定变量值到变量 name。'
- en: '`String.format(helloWorldTemplate, name)`: A simple string format to replace
    `%s` in the template with the name.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.format(helloWorldTemplate, name)`: 一个简单的字符串格式，用名字替换模板中的 `%s`。'
- en: Executing a Request
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行请求
- en: 'Let''s send a test request and see what response we get. The following screenshot
    shows the response:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发送一个测试请求并查看我们得到的响应。以下截图显示了响应：
- en: '![Executing a Request](img/01_05.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![执行请求](img/01_05.jpg)'
- en: 'The response for the `http://localhost:8080/welcome-with-parameter/name/Buddy`
    URL is as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `http://localhost:8080/welcome-with-parameter/name/Buddy` URL 的响应如下：
- en: '[PRE20]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As expected, the name in the URI is used to form the message in the response.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，URI 中的名字被用来形成响应中的消息。
- en: Unit Testing
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Let''s quickly write a unit test for the preceding method. We would want to
    pass a name as part of the URI and check whether the response contains the name.
    The following code shows how we can do that:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速编写一个针对前面方法的单元测试。我们希望将名字作为 URI 的一部分传递，并检查响应是否包含该名字。以下代码显示了如何做到这一点：
- en: '[PRE21]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A few important things to note are as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要事项如下：
- en: '`MockMvcRequestBuilders.get("/welcome-with-parameter/name/Buddy")`: This matches
    against the variable template in the URI. We pass in the name `Buddy`.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockMvcRequestBuilders.get("/welcome-with-parameter/name/Buddy")`: 这与 URI
    中的变量模板匹配。我们传递名字 `Buddy`。'
- en: '`.andExpect(content().string(containsString("Hello World, Buddy")))`: We expect
    the response to contain the message with the name.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.andExpect(content().string(containsString("Hello World, Buddy")))`: 我们期望响应中包含带有名字的消息。'
- en: Integration Testing
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'The integration test for the preceding method is very simple. Take a look at
    the following `test` method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的集成测试非常简单。看看下面的 `test` 方法：
- en: '[PRE22]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A few important things to note are as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要事项如下：
- en: '`createURL("/welcome-with-parameter/name/Buddy")`: This matches against the
    variable template in the URI. We are passing in the name, Buddy.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createURL("/welcome-with-parameter/name/Buddy")`：这与 URI 中的变量模板相匹配。我们传递了名称，Buddy。'
- en: '`assertThat(response.getBody(), containsString("Hello World, Buddy"))`: We
    expect the response to contain the message with the name.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertThat(response.getBody(), containsString("Hello World, Buddy"))`：我们期望响应包含带有名称的消息。'
- en: In this section, we looked at the basics of creating a simple REST service with
    Spring Boot. We also ensured that we have good unit tests and integration tests.
    While these are really basic, they lay the foundation for more complex REST services
    we will build in the next section.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了使用 Spring Boot 创建简单 REST 服务的基础知识。我们还确保了拥有良好的单元测试和集成测试。虽然这些非常基础，但它们为我们在下一节中构建的更复杂的
    REST 服务奠定了基础。
- en: The unit tests and integration tests we implemented can have better asserts
    using a JSON comparison instead of a simple substring comparison. We will focus
    on it in the tests we write for the REST services we will create in the next sections.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的单元测试和集成测试可以使用 JSON 比较而不是简单的子字符串比较来有更好的断言。我们将在下一节中为我们将创建的 REST 服务编写的测试中关注这一点。
- en: Creating a Todo Resource
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建待办事项资源
- en: 'We will focus on creating REST services for a basic todo management system.
    We will create services for the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于创建基本的待办事项管理系统中的 REST 服务。我们将为以下内容创建服务：
- en: Retrieving a list of todos for a given user
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索特定用户的待办事项列表
- en: Retrieving details for a specific todo
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索特定待办事项的详细信息
- en: Creating a todo for a user
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户创建待办事项
- en: Request Methods, Operations, and Uris
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求方法、操作和 URI
- en: One of the best practices of REST services is to use the appropriate HTTP request
    method based on the action we perform. In the services we exposed until now, we
    used the `GET` method, as we focused on services that read data.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: REST 服务的最佳实践之一是根据我们执行的操作使用适当的 HTTP 请求方法。在我们至今公开的服务中，我们使用了 `GET` 方法，因为我们专注于读取数据的服务。
- en: 'The following table shows the appropriate HTTP Request method based on the
    operation that we perform:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了根据我们执行的操作适当的 HTTP 请求方法：
- en: '| HTTP Request Method | Operation |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 请求方法 | 操作 |'
- en: '| --- | --- |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GET` | Read--Retrieve details for a resource |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 读取--检索资源的详细信息 |'
- en: '| `POST` | Create--Create a new item or resource |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 创建--创建一个新的条目或资源 |'
- en: '| `PUT` | Update/replace |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 更新/替换 |'
- en: '| `PATCH` | Update/modify a part of the resource |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 更新/修改资源的一部分 |'
- en: '| `DELETE` | Delete |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除 |'
- en: 'Let''s quickly map the services that we want to create to the appropriate request
    methods:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速将我们想要创建的服务映射到适当的请求方法：
- en: '**Retrieving a list of todos for a given user**: This is READ. We will use
    GET. We will use a URI: `/users/{name}/todos`. One more good practice is to use
    plurals for static things in the URI: users, todo, and so on. This results in
    more readable URIs.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检索特定用户的待办事项列表**：这是读取操作。我们将使用 GET 方法。我们将使用 URI：`/users/{name}/todos`。另一个好的做法是在
    URI 中使用复数形式表示静态事物：users、todo 等等。这会产生更易读的 URI。'
- en: '**Retrieving details for a specific todo**: Again, we will use `GET`. We will
    use a URI `/users/{name}/todos/{id}`. You can see that this is consistent with
    the earlier URI that we decided for the list of todos.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检索特定待办事项的详细信息**：同样，我们将使用 `GET` 方法。我们将使用 URI `/users/{name}/todos/{id}`。你可以看到这与我们之前决定的待办事项列表的
    URI 一致。'
- en: '**Creating a todo for a user**: For the create operation, the suggested HTTP
    Request method is `POST`. To create a new todo, we will post to `URI /users/{name}/todos`.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为用户创建待办事项**：对于创建操作，建议的 HTTP 请求方法是 `POST`。要创建一个新的待办事项，我们将向 `URI /users/{name}/todos`
    发送 POST 请求。'
- en: Beans and Services
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bean 和服务
- en: To be able to retrieve and store details of a todo, we need a Todo bean and
    a service to retrieve and store the details.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够检索和存储待办事项的详细信息，我们需要一个待办事项 Bean 和一个用于检索和存储详细信息的服务。
- en: 'Let''s create a Todo Bean:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个待办事项 Bean：
- en: '[PRE23]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have a created a simple Todo bean with the ID, the name of user, the description
    of the todo, the todo target date, and an indicator for the completion status.
    We added a constructor and getters for all fields.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的待办事项 Bean，包含 ID、用户名称、待办事项描述、待办事项目标日期和完成状态指示器。我们为所有字段添加了构造函数和获取器。
- en: 'Let''s add `TodoService` now:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加 `TodoService`：
- en: '[PRE24]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Quick things to note are as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的快速事项如下：
- en: To keep things simple, this service does not talk to the database. It maintains
    an in-memory array list of todos. This list is initialized using a static initializer.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保持简单，此服务不与数据库通信。它维护一个内存中的待办事项数组列表。此列表使用静态初始化器初始化。
- en: We are exposing a couple of simple retrieve methods and a method to add a to-do.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们公开了一些简单的检索方法和一个添加待办事项的方法。
- en: Now that we have the service and bean ready, we can create our first service
    to retrieve a list of to-do's for a user.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经准备好了服务和bean，我们可以创建我们的第一个服务来检索用户的待办事项列表。
- en: Retrieving a Todo List
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索待办事项列表
- en: 'We will create a new `RestController` annotation called `TodoController`. The
    code for the retrieve todos method is shown as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`RestController`注解，称为`TodoController`。检索待办事项方法的代码如下所示：
- en: '[PRE25]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A couple of things to note are as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的事项：
- en: We are autowiring the todo service using the `@Autowired` annotation
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`@Autowired`注解自动装配待办事项服务
- en: We use the `@GetMapping` annotation to map the Get request for the `"/users/{name}/todos"`
    URI to the `retrieveTodos` method
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`@GetMapping`注解将`"/users/{name}/todos"` URI的GET请求映射到`retrieveTodos`方法
- en: Executing the Service
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行服务
- en: 'Let''s send a test request and see what response we get. The following screenshot
    shows the output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发送一个测试请求并查看我们得到什么响应。以下截图显示了输出：
- en: '![Executing the Service](img/01_06.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![执行服务](img/01_06.jpg)'
- en: 'The response for the `http://localhost:8080/users/Jack/todos` URL is as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/users/Jack/todos` URL的响应如下：'
- en: '[PRE26]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unit Testing
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'The code to unit test the `TodoController` class is shown in the following
    screenshot:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`TodoController`类的代码截图如下：
- en: '[PRE27]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A few important things to note are as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一些需要注意的重要事项如下：
- en: We are writing a unit test. So, we want to test only the logic present in the
    `TodoController` class. So, we initialize a Mock MVC framework with only the `TodoController`
    class using `@WebMvcTest(TodoController.class)`.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在编写一个单元测试。因此，我们只想测试`TodoController`类中存在的逻辑。所以，我们使用`@WebMvcTest(TodoController.class)`初始化一个只包含`TodoController`类的Mock
    MVC框架。
- en: '`@MockBean private TodoService service`: We are mocking out the `TodoService`
    using the `@MockBean`annotation. In test classes that are run with `SpringRunner`,
    the beans defined with `@MockBean` will be replaced by a mock, created using the
    Mockito framework.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@MockBean private TodoService service`：我们使用`@MockBean`注解模拟`TodoService`。在运行`SpringRunner`的测试类中，使用`@MockBean`定义的bean将被Mockito框架创建的模拟所替换。'
- en: '`when(service.retrieveTodos(anyString())).thenReturn(mockList)`: We are mocking
    the `retrieveTodos` service method to return the mock list.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when(service.retrieveTodos(anyString())).thenReturn(mockList)`：我们正在模拟`retrieveTodos`服务方法以返回模拟列表。'
- en: '`MvcResult result = ..`: We are accepting the result of the request into an
    MvcResult variable to enable us to perform assertions on the response.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MvcResult result = ..`：我们将请求的结果接受到MvcResult变量中，以便我们可以在响应上执行断言。'
- en: '`JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(),
    false)`: JSONAssert is a very useful framework to perform asserts on JSON. It
    compares the response text with the expected value. `JSONAssert` is intelligent
    enough to ignore values that are not specified. Another advantage is a clear failure
    message in case of assertion failures. The last parameter, false, indicates using
    non-strict mode. If it is changed to true, then the expected should exactly match
    the result.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(),
    false)`：JSONAssert是一个非常有用的框架，用于对JSON执行断言。它将响应文本与预期值进行比较。`JSONAssert`足够智能，可以忽略未指定的值。另一个优点是在断言失败时有一个清晰的失败消息。最后一个参数false表示使用非严格模式。如果将其更改为true，则预期值应与结果完全匹配。'
- en: Integration Testing
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'The code to perform integration testing on the `TodoController` class is shown
    in the following code snippet. It launches up the entire Spring context with all
    the controllers and beans defined:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中显示了在`TodoController`类上执行集成测试的代码。它启动了包含所有控制器和bean的整个Spring上下文：
- en: '[PRE28]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This test is very similar to the integration test for `BasicController`, except
    that we are using `JSONAssert` to assert the response.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与`BasicController`的集成测试非常相似，除了我们使用`JSONAssert`来断言响应。
- en: Retrieving Details for a Specific Todo
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索特定待办事项的详细信息
- en: 'We will now add the method to retrieve details for a specific Todo:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加一个用于检索特定待办事项详细信息的函数：
- en: '[PRE29]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A couple of things to note are as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的事项：
- en: The URI mapped is `/users/{name}/todos/{id}`
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射的URI是`/users/{name}/todos/{id}`
- en: We have two path variables defined for `name` and `id`
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为 `name` 和 `id` 定义了两个路径变量
- en: Executing the Service
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行服务
- en: 'Let''s send a test request and see what response we will get, as shown in the
    following screenshot:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发送一个测试请求，看看我们会得到什么响应，如下面的截图所示：
- en: '![Executing the Service](img/01_07.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![执行服务](img/01_07.jpg)'
- en: 'The response for the `http://localhost:8080/users/Jack/todos/1` URL is shown
    as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `http://localhost:8080/users/Jack/todos/1` URL 的响应如下所示：
- en: '[PRE30]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unit Testing
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'The code to unit test `retrieveTodo` is as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试 `retrieveTodo` 的代码如下：
- en: '[PRE31]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A few important things to note are as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要事项如下：
- en: '`when(service.retrieveTodo(anyInt())).thenReturn(mockTodo)`: We are mocking
    the `retrieveTodo` service method to return the mock todo.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when(service.retrieveTodo(anyInt())).thenReturn(mockTodo)`: 我们正在模拟 `retrieveTodo`
    服务方法以返回模拟的 Todo。'
- en: '`MvcResult result = ..`: We are accepting the result of the request into an
    MvcResult variable to enable us to perform assertions on the response.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MvcResult result = ..`: 我们将请求的结果接受到 MvcResult 变量中，以便我们可以在响应上执行断言。'
- en: '`JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(),
    false)`: Asserts whether the result is as expected.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSONAssert.assertEquals(expected, result.getResponse().getContentAsString(),
    false)`: 断言结果是否符合预期。'
- en: Integration Testing
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'The code to perform integration testing on `retrieveTodos` in `TodoController`
    is shown in the following code snippet. This would be added to the `TodoControllerIT`
    class:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TodoController` 中对 `retrieveTodos` 进行集成测试的代码如下。这将添加到 `TodoControllerIT` 类中：
- en: '[PRE32]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Adding A Todo
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Todo
- en: 'We will now add the method to create a new Todo. The HTTP method to be used
    for creation is `Post`. We will post to a `"/users/{name}/todos"` URI:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加创建新 Todo 的方法。用于创建的 HTTP 方法是 `POST`。我们将向 `"/users/{name}/todos"` URI 发送
    POST 请求：
- en: '[PRE33]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A few things to note are as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个事项如下：
- en: '`@PostMapping("/users/{name}/todos")`: `@PostMapping` annotations map the `add()`
    method to the HTTP Request with a `POST` method.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PostMapping("/users/{name}/todos")`: `@PostMapping` 注解将 `add()` 方法映射到使用 `POST`
    方法的 HTTP 请求。'
- en: '`ResponseEntity<?> add(@PathVariable String name, @RequestBody Todo todo)`:
    An HTTP post request should ideally return the URI to the created resources. We
    use `ResourceEntity` to do this. `@RequestBody` binds the body of the request
    directly to the bean.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResponseEntity<?> add(@PathVariable String name, @RequestBody Todo todo)`:
    一个 HTTP POST 请求理想情况下应返回创建资源的 URI。我们使用 `ResourceEntity` 来做这件事。`@RequestBody` 将请求体直接绑定到
    Bean。'
- en: '`ResponseEntity.noContent().build()`: Used to return that the creation of the
    resource failed.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResponseEntity.noContent().build()`: 用于返回资源创建失败。'
- en: '`ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(createdTodo.getId()).toUri()`:
    Forms the URI for the created resource that can be returned in the response.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(createdTodo.getId()).toUri()`:
    形成可以返回在响应中的创建资源的 URI。'
- en: '`ResponseEntity.created(location).build()`: Returns a status of `201(CREATED)`
    with a link to the resource created.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResponseEntity.created(location).build()`: 返回状态为 `201(CREATED)` 并带有创建的资源链接。'
- en: Postman
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Postman
- en: If you are on Mac, you might want to try the Paw application as well.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Mac，你可能还想尝试 Paw 应用程序。
- en: 'Let''s send a test request and see what response we get. The following screenshot
    shows the response:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发送一个测试请求并查看我们得到的响应。以下截图显示了响应：
- en: '![Postman](img/01_08.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![Postman](img/01_08.jpg)'
- en: We will use Postman app to interact with the REST Services. You can install
    it from the website, [https://www.getpostman.com/](https://www.getpostman.com/).
    It is available on Windows and Mac. A Google Chrome plugin is also available.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Postman 应用程序与 REST 服务进行交互。您可以从网站安装它，[https://www.getpostman.com/](https://www.getpostman.com/)。它在
    Windows 和 Mac 上可用。还有一个 Google Chrome 插件。
- en: Executing the POST Service
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行 POST 服务
- en: 'To create a new Todo using `POST`, we would need to include the JSON for the
    Todo in the body of the request. The following screenshot shows how we can use
    the Postman app to create the request and the response after executing the request:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `POST` 方法创建一个新的 Todo，我们需要在请求体中包含 Todo 的 JSON。以下截图显示了我们可以如何使用 Postman 应用程序创建请求和执行请求后的响应：
- en: '![Executing the POST Service](img/01_09.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![执行 POST 服务](img/01_09.jpg)'
- en: 'A few important things to note are as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几个重要事项如下：
- en: We are sending a POST request. So, we choose the `POST` from the top-left dropdown.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在发送一个 POST 请求。因此，我们从左上角的下拉菜单中选择 `POST`。
- en: To send the Todo JSON as part of the body of the request, we select the `raw`
    option in the `Body` tab (highlighted with a blue dot). We choose the content
    type as JSON (`application/json`).
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将 Todo JSON 作为请求体的一部分发送，我们在“Body”选项卡中选择“raw”选项（用蓝色圆点突出显示）。我们选择内容类型为 JSON (`application/json`)。
- en: 'Once the request is successfully executed, you can see the status of the request
    in the bar in the middle of the screen: `Status: 201 Created`.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求成功执行后，您可以在屏幕中间的栏中看到请求的状态：“状态：201 已创建”。
- en: The location is `http://localhost:8080/users/Jack/todos/5`. This is the URI
    of the newly created todo that is received in the response.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置是 `http://localhost:8080/users/Jack/todos/5`。这是响应中接收到的新的 todo 的 URI。
- en: 'Complete details of the request to `http://localhost:8080/users/Jack/todos`
    are shown in the block, as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 请求 `http://localhost:8080/users/Jack/todos` 的完整细节如下所示：
- en: '[PRE34]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Unit Testing
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'The code to unit test the created Todo is shown as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试创建的 Todo 的代码如下所示：
- en: '[PRE35]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A few important things to note are as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`String todo = "{"user":"Jack","desc":"Learn Spring MVC","done":false}"`: The
    Todo content to post to the create todo service.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String todo = "{"user":"Jack","desc":"Learn Spring MVC","done":false}"`：要发送到创建
    todo 服务的 Todo 内容。'
- en: '`when(service.addTodo(anyString(), anyString(), isNull(), anyBoolean())).thenReturn(mockTodo)`:
    Mocks the service to return a dummy todo.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when(service.addTodo(anyString(), anyString(), isNull(), anyBoolean())).thenReturn(mockTodo)`：模拟服务以返回一个虚拟的
    todo。'
- en: '`MockMvcRequestBuilders.post("/users/Jack/todos").content(todo).contentType(MediaType.APPLICATION_JSON))`:
    Creates a POST to a given URI with the given content type.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockMvcRequestBuilders.post("/users/Jack/todos").content(todo).contentType(MediaType.APPLICATION_JSON))`：创建一个具有给定内容类型的
    POST 请求到指定的 URI。'
- en: '`andExpect(status().isCreated())`: Expects that the status is created.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`andExpect(status().isCreated())`：期望状态为已创建。'
- en: '`andExpect(header().string("location",containsString("/users/Jack/todos/" +
    CREATED_TODO_ID)))`: Expects that the header contains `location` with the URI
    of created resource.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`andExpect(header().string("location",containsString("/users/Jack/todos/" +
    CREATED_TODO_ID)))`：期望头部包含带有创建资源的 URI 的 `location`。'
- en: Integration Testing
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'The code to perform integration testing on the created todo in `TodoController`
    is shown as follows. This would be added to the `TodoControllerIT` class, as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TodoController` 中对创建的 todo 进行集成测试的代码如下所示。这将添加到 `TodoControllerIT` 类中，如下所示：
- en: '[PRE36]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A few important things to note are as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的重要事项：
- en: '`URI location = template.postForLocation(createUrl("/users/Jill/todos"), todo)`:
    `postForLocation` is a utility method especially useful in tests to create new
    resources. We are posting the todo to the given URI and getting the location from
    the header.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URI location = template.postForLocation(createUrl("/users/Jill/todos"), todo)`：`postForLocation`
    是一个特别有用的实用方法，尤其是在测试中创建新资源时。我们正在将 todo 发送到给定的 URI，并从头部获取位置。'
- en: '`assertThat(location.getPath(), containsString("/users/Jill/todos/4"))`: Asserts
    that the location contains the path to the newly created resource.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertThat(location.getPath(), containsString("/users/Jill/todos/4"))`：断言位置包含指向新创建资源的路径。'
- en: Spring Initializr
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Initializr
- en: Do you want to auto-generate Spring Boot projects? Do you want to quickly get
    started with developing your application? Spring Initializr is the answer.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要自动生成 Spring Boot 项目吗？您想要快速开始开发您的应用程序吗？Spring Initializr 就是答案。
- en: 'Spring Initializr is hosted at [http://start.spring.io](http://start.spring.io).
    The following screenshot shows how the website looks:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Initializr 域名是 [http://start.spring.io](http://start.spring.io)。以下截图显示了网站的外观：
- en: '![Spring Initializr](img/01_10.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![Spring Initializr](img/01_10.jpg)'
- en: 'Spring Initializr provides a lot of flexibility in creating projects. You have
    options to do the following:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Initializr 在创建项目方面提供了很多灵活性。您有以下选项：
- en: 'Choose your build tool: Maven or Gradle.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您的构建工具：Maven 或 Gradle。
- en: Choose the Spring Boot version you want to use.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您想要使用的 Spring Boot 版本。
- en: Configure a `Group ID` and `Artifact ID` for your component.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的组件配置 `Group ID` 和 `Artifact ID`。
- en: Choose the starters (dependencies) that you would want for your project. You
    can click on the link at the bottom of the screen, `Switch to the full version`,
    to see all the starter projects you can choose from.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您项目所需的启动器（依赖项）。您可以通过点击屏幕底部的链接，`切换到完整版本`，查看您可以选择的所有启动器项目。
- en: 'Choose how to package your component: JAR or WAR.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择如何打包您的组件：JAR 或 WAR。
- en: Choose the Java version you want to use.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您想要使用的 Java 版本。
- en: Choose the JVM language you want to use.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您想要使用的 JVM 语言。
- en: 'The following screenshot shows some of the options Spring Initializr provides
    when you expand (click on the link) to the full version:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当您展开（点击链接）到完整版本时，Spring Initializr提供的部分选项：
- en: '![Spring Initializr](img/01_11.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![Spring Initializr](img/01_11.jpg)'
- en: Creating Your First Spring Initializr Project
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的第一个Spring Initializr项目
- en: 'We will use the full version and enter the values, as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用完整版本并输入以下值：
- en: '![Creating Your First Spring Initializr Project](img/01_12.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![创建您的第一个Spring Initializr项目](img/01_12.jpg)'
- en: 'Things to note are as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的事项如下：
- en: '`Build tool`: `Maven`'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`构建工具`: `Maven`'
- en: '`Spring Boot version`: Choose the latest available'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spring Boot 版本`: 选择最新可用的'
- en: '`Group`: `com.mastering.spring`'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`组`: `com.mastering.spring`'
- en: '`Artifact`: `first-spring-initializr`'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`工件`: `first-spring-initializr`'
- en: '`Selected dependencies`: Choose `Web, JPA, Actuator and Dev Tools`. Type in
    each one of these in the textbox and press *Enter* to choose them. We will learn
    more about Actuator and Dev Tools in the next section'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`选定的依赖项`: 选择 `Web, JPA, Actuator 和 Dev Tools`。在文本框中输入每个这些，然后按 *Enter* 键选择它们。我们将在下一节中了解更多关于
    Actuator 和 Dev Tools 的信息。'
- en: '`Java version`: `1.8`'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Java 版本`: `1.8`'
- en: Go ahead and click on the **Generate Project** button. This will create a `.zip`
    file and you can download it to your computer.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**生成项目**按钮。这将创建一个 `.zip` 文件，您可以将其下载到您的计算机上。
- en: 'The following screenshot shows the structure of the project created:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了创建的项目结构：
- en: '![Creating Your First Spring Initializr Project](img/01_13.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![创建您的第一个Spring Initializr项目](img/01_13.jpg)'
- en: 'We will now import this project into your IDE. In Eclipse, you can perform
    the following steps:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把这个项目导入到您的 IDE 中。在 Eclipse 中，您可以执行以下步骤：
- en: Launch Eclipse.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eclipse。
- en: Navigate to **File** | **Import**.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**文件** | **导入**。
- en: Choose the existing Maven projects.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择现有的 Maven 项目。
- en: Browse and select the folder that is the root of the Maven project (the one
    containing the `pom.xml` file).
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览并选择 Maven 项目的根目录（包含 `pom.xml` 文件的目录）。
- en: Proceed with the defaults and click on **Finish**`.`
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认设置并点击**完成**。`
- en: 'This will import the project into Eclipse. The following screenshot shows the
    structure of the project in Eclipse:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把项目导入到 Eclipse 中。以下截图显示了 Eclipse 中项目的结构：
- en: '![Creating Your First Spring Initializr Project](img/01_14.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![创建您的第一个Spring Initializr项目](img/01_14.jpg)'
- en: Let's look at some of the important files from the generated project.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看生成项目中的一些重要文件。
- en: pom.xml
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pom.xml
- en: 'The following snippet shows the dependencies that are declared:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了声明的依赖项：
- en: '[PRE37]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A few other important observations are as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他重要的观察如下：
- en: The packaging for this component is `.jar`
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此组件的打包格式为 `.jar`
- en: '`org.springframework.boot:spring-boot-starter-parent` is declared as the parent
    POM'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.boot:spring-boot-starter-parent` 被声明为父 POM'
- en: '`<java.version>1.8</java.version>`: The Java version is 1.8'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<java.version>1.8</java.version>`: Java 版本是 1.8'
- en: Spring Boot Maven Plugin (`org.springframework.boot:spring-boot-maven-plugin`)
    is configured as a plugin
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot Maven 插件 (`org.springframework.boot:spring-boot-maven-plugin`) 被配置为插件
- en: FirstSpringInitializrApplication.java Class
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FirstSpringInitializrApplication.java 类
- en: '`FirstSpringInitializrApplication.java` is the launcher for Spring Boot:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstSpringInitializrApplication.java` 是 Spring Boot 的启动器：'
- en: '[PRE38]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: FirstSpringInitializrApplicationTests Class
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FirstSpringInitializrApplicationTests 类
- en: '`FirstSpringInitializrApplicationTests` contains the basic context that can
    be used to start writing the tests as we start developing the application:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstSpringInitializrApplicationTests` 包含可以用来开始编写测试的基本上下文，随着我们开始开发应用程序：'
- en: '[PRE39]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A Quick Peek into Auto-Configuration
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速了解自动配置
- en: Auto-configuration is one of the most important features of Spring Boot. In
    this section, we will take a quick peek behind the scenes to understand how Spring
    Boot auto-configuration works.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 自动配置是 Spring Boot 最重要的功能之一。在本节中，我们将快速了解幕后，以了解 Spring Boot 自动配置是如何工作的。
- en: Most of the Spring Boot auto-configuration magic comes from `spring-boot-autoconfigure-{version}.jar`.
    When we start any Spring Boot applications, a number of beans get auto-configured.
    How does this happen?
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分 Spring Boot 自动配置的魔法都来自 `spring-boot-autoconfigure-{version}.jar`。当我们启动任何
    Spring Boot 应用程序时，许多 bean 都会自动配置。这是如何发生的？
- en: 'The following screenshot shows an extract from `spring.factories` from `spring-boot-autoconfigure-{version}.jar`.
    We have filtered out some of the configuration in the interest of space:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了从 `spring-boot-autoconfigure-{version}.jar` 的 `spring.factories` 的一个摘录。我们出于空间考虑过滤掉了一些配置：
- en: '![A Quick Peek into Auto-Configuration](img/01_15.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![快速浏览自动配置](img/01_15.jpg)'
- en: 'The preceding list of auto-configuration classes is run whenever a Spring Boot
    application is launched. Let''s take a quick look at one of them:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 每次启动Spring Boot应用程序时，都会运行前面列出的自动配置类列表。让我们快速查看其中之一：
- en: '`org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration`.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration`。'
- en: 'Here''s a small snippet:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小的代码片段：
- en: '[PRE40]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Some of the important points to note are as follows:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要点如下：
- en: '`@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class
    })`: This auto-configuration is enabled if any of the mentioned classes are in
    the classpath. When we add a web starter project, we bring in dependencies with
    all these classes. Hence, this auto-configuration will be enabled.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class
    })`：如果类路径中包含上述提到的任何类，则启用此自动配置。当我们添加一个Web启动项目时，我们会引入包含所有这些类的依赖项。因此，此自动配置将被启用。'
- en: '`@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)`: This auto-configuration
    is enabled only if the application does not explicitly declare a bean of the `WebMvcConfigurationSupport.class`
    class.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)`：只有当应用程序没有显式声明`WebMvcConfigurationSupport.class`类的bean时，此自动配置才会启用。'
- en: '`@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)`: This specifies the
    precedence of this specific auto-configuration.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)`：这指定了此特定自动配置的优先级。'
- en: 'Let''s look at another small snippet showing one of the methods from the same
    class:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个小的代码片段，展示同一类中的一个方法：
- en: '[PRE41]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'View resolvers are one of the beans configured by `WebMvcAutoConfiguration`
    class. The preceding snippet ensures that if a view resolver is not provided by
    the application, then Spring Boot auto-configures a default view resolver. Here
    are a few important points to note:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 视图解析器是`WebMvcAutoConfiguration`类配置的bean之一。前面的代码片段确保如果应用程序没有提供视图解析器，那么Spring
    Boot将自动配置一个默认的视图解析器。以下是一些需要注意的重要点：
- en: '`@ConditionalOnBean(ViewResolver.class)`: Create this bean if `ViewResolver.class`
    is on the classpath'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ConditionalOnBean(ViewResolver.class)`：如果`ViewResolver.class`在类路径上，则创建此bean。'
- en: '`@ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)`:
    Create this bean if there are no explicitly declared beans of the name `viewResolver`
    and of type `ContentNegotiatingViewResolver.class`'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class)`：如果没有显式声明名为`viewResolver`且类型为`ContentNegotiatingViewResolver.class`的bean，则创建此bean。'
- en: The rest of the method is configured in the view resolver
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的其他部分在视图解析器中进行配置
- en: To summarize, all the auto-configuration logic is executed at the start of a
    Spring Boot application. If a specific class (from a specific dependency or starter
    project) is available on the classpath, then the auto configuration classes are
    executed. These auto-configuration classes look at what beans are already configured.
    Based on the existing beans, they enable the creation of the default beans.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，所有自动配置逻辑都在Spring Boot应用程序启动时执行。如果类路径上有特定依赖项或启动项目中的特定类，则执行自动配置类。这些自动配置类查看已经配置的bean。根据现有的bean，它们启用默认bean的创建。
- en: Summary
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Spring Boot makes the development of Spring-based applications easy. It enables
    us to create production-ready applications from day one of a project.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot使得基于Spring的应用程序开发变得简单。它使我们能够从项目的第一天开始就创建生产就绪的应用程序。
- en: In this lesson, we covered the basics of Spring Boot and REST services. We discussed
    the different features of Spring Boot and created a few REST services with great
    tests. We understood what happens in the background with an in-depth look at auto-configuration.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们介绍了Spring Boot和REST服务的基础知识。我们讨论了Spring Boot的不同特性，并创建了一些具有良好测试的REST服务。我们通过深入了解自动配置，了解了后台发生了什么。
- en: In the next lesson, we will shift our attention toward adding more features
    to the REST services.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将把注意力转向向REST服务添加更多功能。
- en: Assessments
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: The _______ class can be used to bootstrap and launch a Spring application from
    a Java main method.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用_______类从Java主方法启动和运行Spring应用程序。
- en: Which of the following methods is used to append the local host URL and port
    to the URI to create a full URL?
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个方法用于将本地主机URL和端口附加到URI以创建完整的URL？
- en: Private URL(String uri)
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有URL（String uri）
- en: private String create(String uri)
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: private String create(String uri)
- en: private String CreateURL(String uri)
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: private String CreateURL(String uri)
- en: private String createURL(String uri)
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: private String createURL(String uri)
- en: 'State whether True or False: Tomcat server is launched on port 8080--Tomcat
    started on port(s): 8080 (http).'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：Tomcat 服务器在端口 8080 上启动--Tomcat 在端口(s)：8080 (http) 上启动。
- en: Which of the following starter templates provides support for various unit testing
    frameworks such as JUnit, Mockito, and Hamcrest? These frameworks does the work
    of orchestrating the lock contention in Spring Boot.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个启动模板提供了对各种单元测试框架（如 JUnit、Mockito 和 Hamcrest）的支持？这些框架在 Spring Boot 中负责协调锁竞争。
- en: spring-boot-starter-test
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: spring-boot-starter-test
- en: spring-boot-starter-testframe
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: spring-boot-starter-testframe
- en: spring-boot-starter-unittest
  id: totrans-497
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: spring-boot-starter-unittest
- en: spring-boot-starter-testorchestration
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: spring-boot-starter-testorchestration
- en: 'State whether True or False: The multipartResolver does not provide support
    to upload files in web applications.'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：multipartResolver 不提供在 Web 应用程序中上传文件的支持。
