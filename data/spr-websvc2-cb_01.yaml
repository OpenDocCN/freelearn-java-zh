- en: Chapter 1. Building SOAP Web-Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。构建SOAP Web服务
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using Maven for building and running a Spring-WS project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven构建和运行Spring-WS项目
- en: Creating a data contract
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据合同
- en: Setting up a Web-Service using `DispatcherServlet`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DispatcherServlet`设置Web服务
- en: Simplifying the creation of a Web-Service using `MessageDispatcherServlet`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`MessageDispatcherServlet`简化Web服务的创建
- en: Setting up a Web-Service on JMS transport
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JMS传输上设置Web服务
- en: Setting up a Web-Service on E-mail transport
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在电子邮件传输上设置Web服务
- en: Setting up a Web-Service on embedded HTTP server transport
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在嵌入式HTTP服务器传输上设置Web服务
- en: Setting up a Web-Service on XMPP transport
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XMPP传输上设置Web服务
- en: Setting up a simple endpoint mapping for the Web-Service
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Web服务设置简单的端点映射
- en: Setting up a contract-first Web-Service
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置基于契约的Web服务
- en: Setting up an endpoint by annotating the payload-root
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注释payload-root设置端点
- en: Setting up a transport-neutral WS-Addressing endpoint
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个与传输无关的WS-Addressing端点
- en: Setting up an endpoint using an XPath expression
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XPath表达式设置端点
- en: Handling the incoming XML messages using DOM
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DOM处理传入的XML消息
- en: Handling the incoming XML messages using JDOM
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JDOM处理传入的XML消息
- en: Handling the incoming XML messages using JAXB2
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JAXB2处理传入的XML消息
- en: Validating the XML messages on the server side using an interceptor
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用拦截器在服务器端验证XML消息
- en: Introduction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: SOAP (Simple Object Access Protocol) was designed to be language-, transport-,
    and platform-independent, which is an alternative to the old fashioned middleware
    technologies such as CORBA and DCOM. SOAP was also designed to be extensible.
    The standards referred to as WS-* — WS-Addressing, WS-Policy, WS-Security, and
    so on are built on the SOAP protocol.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP（Simple Object Access Protocol）旨在成为语言、传输和平台无关的，这是一种替代传统中间件技术（如CORBA和DCOM）的选择。SOAP也被设计为可扩展的。所谓的WS-*标准——WS-Addressing、WS-Policy、WS-Security等都是基于SOAP协议构建的。
- en: 'The Web-Services that use SOAP, along with WSDL and XML schema, have become
    the standard for exchanging the XML-based messages. The Spring Web-Services facilitate
    SOAP service development, by providing a comprehensive set of APIs and configurations
    for the creation of flexible Web-Services. The following diagram shows how a Spring-WS
    works when it receives an incoming message (the diagram is in abstract form):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SOAP的Web服务，以及WSDL和XML模式，已经成为交换基于XML的消息的标准。Spring Web服务通过提供一套全面的API和配置，为灵活的Web服务的创建提供了便利。下图显示了Spring-WS在接收到传入消息时的工作方式（图表以抽象形式呈现）：
- en: '![Introduction](img/5825_01_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](img/5825_01_01.jpg)'
- en: '`MessageDispatcher` is the central point for a Spring Web-Service and dispatches
    Web-Service messages to the registered endpoint. In Spring-WS, request/response
    messages are wrapped inside the `MessageContext` object and the `MessageContext`
    will be passed to the `MessageDispatcher` (response will be set into MessageContext
    after invoking the endpoint). When a message arrives, MessageDispatcher uses the
    request object to get the endpoint. (Mapping a request to an endpoint is called
    **endpoint mapping** and it can be done by using data from beans registration
    within application context, scanning, and autodetection of annotations). Then
    the `MessageDispatcher` by using the endpoint, gets endpopint''s interceptors
    (which range from zero to many) and calls handleRequest method on them.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageDispatcher`是Spring Web服务的中心点，将Web服务消息分派到注册的端点。在Spring-WS中，请求/响应消息被包装在`MessageContext`对象中，并且`MessageContext`将被传递给`MessageDispatcher`（在调用端点后，响应将被设置到`MessageContext`中）。当消息到达时，`MessageDispatcher`使用请求对象获取端点。（将请求映射到端点称为**端点映射**，可以通过使用应用程序上下文中的bean注册数据、扫描和自动检测注释来完成）。然后，`MessageDispatcher`通过使用端点，获取端点的拦截器（从零到多个），并在它们上调用`handleRequest`方法。'
- en: An interceptor (`EndpointInterceptor` here), as the name suggests, intercepts
    the request/response to perform some operations prior to (for request)/after (for
    response) invoking the endpoint. This `EndpointInterceptor` gets called before/after
    calling the appropriate endpoint to perform several processing aspects such as
    logging, validating, security, and so on. Next, `MessageDispatcher` gets appropriate
    endpoint adapter for the endpoint method to be called. This adapter offers compatibility
    with various types of endpoint methods. Each adapter is specialized to call a
    method with specific method parameter and return type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器（这里是`EndpointInterceptor`）拦截请求/响应，在调用端点之前/之后执行一些操作。这个`EndpointInterceptor`在调用适当的端点之前/之后被调用，执行诸如日志记录、验证、安全等多个处理方面。接下来，`MessageDispatcher`获取适当的端点适配器，用于调用端点方法。每个适配器都专门用于调用具有特定方法参数和返回类型的方法。
- en: And Finally, `EndpointAdapter` invokes the endpoint's method and transforms
    the response to the desired form and set it into the `MessageContext` object.
    Now the initial message context that was passed to `MessageDispatcher`, contains
    the response object, that will be forwarded to the client (by the caller of `MessageDispatcher)`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`EndpointAdapter`调用端点的方法，并将响应转换为所需的形式，并将其设置到`MessageContext`对象中。现在，最初传递给`MessageDispatcher`的消息上下文包含了响应对象，该对象将被转发给客户端（由`MessageDispatcher`的调用者）。
- en: 'Spring-WS only supports the contract-first development style in which creating
    the contract (XSD or WSDL) is the first step. The required steps to build a contract-first
    Web-Service using Spring-WS are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Spring-WS只支持基于契约的开发风格，其中创建契约（XSD或WSDL）是第一步。使用Spring-WS构建基于契约的Web服务的必要步骤如下：
- en: Contract definition (either XSD or WSDL)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合同定义（XSD或WSDL）
- en: 'Creating endpoint: the class that receives and processes an incoming message.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建端点：接收和处理传入消息的类。
- en: Configuration of Spring beans and the endpoint.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring bean和端点的配置。
- en: There are two types of endpoints, namely, payload endpoints and message endpoints.
    While message endpoints can access the entire XML SOAP envelop, the payload endpoint
    will only access the payload part of a SOAP envelop, that is, the body of a SOAP
    envelop. In this book, the focus is on creating payload endpoints.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的端点，即有效载荷端点和消息端点。虽然消息端点可以访问整个XML SOAP包络，有效载荷端点只能访问SOAP包络的有效载荷部分，也就是SOAP包络的主体。在本书中，重点是创建有效载荷端点。
- en: In this chapter, after a recipe for the explanation of creating contract from
    a set of XML messages, the major focus will be on implementing endpoints and its
    related configuration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，在解释从一组XML消息创建合同的教程之后，主要关注点将放在实现端点及其相关配置上。
- en: For the purpose of illustrating the construction process of Web-Services, this
    book uses a simple business scenario of a fictitious restaurant, Live Restaurant,
    which needs to accept online orders from customers. Live Restaurant decides to
    publish its `OrderService` component as a Web-Service. For simplicity, just two
    operations are considered for the `OrderService` (Java interface).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明Web服务的构建过程，本书使用了一个虚构的餐厅Live Restaurant的简单业务场景，该餐厅需要接受来自客户的在线订单。Live Restaurant决定将其`OrderService`组件发布为Web服务。为简单起见，`OrderService`（Java接口）只考虑了两个操作。
- en: '![Introduction](img/5825_01_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](img/5825_01_02.jpg)'
- en: 'The project will follow the following domain model:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 项目将遵循以下领域模型：
- en: '![Introduction](img/5825_01_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](img/5825_01_03.jpg)'
- en: Each recipe in this book will incrementally build parts of the project to make
    it a complete Web-Service application. The Java project name is `LiveRestaurant`,
    and each recipe will use a slightly different version of the project, with the
    extension `_R-x.x`. For example, the first recipe in this chapter will use `LiveRestaurant_R-1.1`
    for the Web-Service server and `LiveRestaurant_R-1.1-Client for the client` as
    the project name.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的每个教程都将逐步构建项目的各个部分，使其成为完整的Web服务应用程序。Java项目名称为`LiveRestaurant`，每个教程将使用项目的略有不同的版本，带有扩展名`_R-x.x`。例如，本章的第一个教程将使用`LiveRestaurant_R-1.1`作为Web服务服务器，`LiveRestaurant_R-1.1-Client`作为客户端的项目名称。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Setting up a Web-Service is the goal of this chapter, so more emphasis is on
    explanation of the server-side code and settings. Client-side code is used in
    this chapter for checking the functionality of the server. More about client side
    code, settings, and testing will be discussed in the following chapters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是设置Web服务，因此更多的重点是在服务器端代码和设置的解释上。本章中使用客户端代码来检查服务器的功能。有关客户端代码、设置和测试的更多内容将在接下来的章节中讨论。
- en: Using Maven for building and running a Spring-WS project
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven构建和运行Spring-WS项目
- en: Recent modern software development, based on enterprise-grade open source technologies,
    requires a new generation of build and project management tools. Such tools can
    make a standard way for building, managing, and deploying small scale to large
    scale applications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 基于企业级开源技术的最新现代软件开发需要一代新的构建和项目管理工具。这些工具可以为构建、管理和部署小规模到大规模应用程序提供标准的方式。
- en: Maven, hosted by the Apache Software Foundation, is a project management and
    automated build and deploy tool. Maven is built upon Ant's features and adds several
    features such as feature dependency and project management. Maven was initially
    used for Java programming, but it can also be used to build and manage projects
    written in other programming languages. In recent years, Maven has been used to
    automate the process of building, managing, and testing the deployments of major
    open source projects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Maven是由Apache软件基金会托管的项目管理和自动化构建和部署工具。Maven建立在Ant的功能基础之上，并添加了诸如特性依赖和项目管理等功能。Maven最初用于Java编程，但也可以用于构建和管理其他编程语言编写的项目。近年来，Maven已被用于自动化构建、管理和测试主要开源项目的部署过程。
- en: This recipe details the steps required to set up Maven for building, testing,
    and deploying the projects used in this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程详细介绍了设置Maven用于构建、测试和部署本书中使用的项目所需的步骤。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe requires the installation of the following software or tools:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程需要安装以下软件或工具：
- en: 'Java 6 or higher and Maven 3.0.2: For download and installation, refer to [http://maven.apache.org/](http://maven.apache.org/)
    and [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 6或更高版本和Maven 3.0.2：有关下载和安装，请参阅[http://maven.apache.org/](http://maven.apache.org/)和[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)。
- en: Add your custom repositories to `settings.xml` under `MAVEN_HOME/conf` or `.m2`
    folders `(MAVEN_HOME` is the folder in which Maven is installed and `.m2` is the
    folder in which Maven downloads its artifacts to).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的自定义存储库添加到`MAVEN_HOME/conf`或`.m2`文件夹下的`settings.xml`中（`MAVEN_HOME`是安装Maven的文件夹，`.m2`是Maven下载其构件的文件夹）。
- en: 'Later, you can add an extra repository to your custom repositories. You can
    disable this repository by setting `activeByDefault` to `false` (the file that
    contains repositories is in the `resources` folder):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，您可以向自定义存储库添加额外的存储库。您可以通过将`activeByDefault`设置为`false`来禁用此存储库（包含存储库的文件位于`resources`文件夹中）：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An alternative way to include the Maven repositories to your Maven build is
    to include repository data in the POM file directly. Samples of both ways to include
    repositories are included under the `Using Maven` folder in the resource bundle
    of this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将Maven存储库包含到Maven构建中的另一种方法是直接在POM文件中包含存储库数据。本章的资源包的`Using Maven`文件夹中包含了包含存储库的两种方式的示例。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Build and deploy a project.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和部署项目。
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Browse the following Web-Service WSDL file:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览以下Web服务WSDL文件：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the browser''s output:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器的输出如下：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the output of the Maven command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是Maven命令的输出：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to import a Maven project into an Eclipse IDE:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Maven项目导入Eclipse IDE，可以选择以下方法：
- en: 'Go to the root of the project (\chapterOne\LiveRestaurant_R-1.1) and execute:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 转到项目的根目录（\chapterOne\LiveRestaurant_R-1.1）并执行：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, you can import the Maven project as an Eclipse project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将Maven项目导入Eclipse项目。
- en: 'In case Maven cannot find a JAR file, you can use your custom repository using
    the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Maven找不到一个JAR文件，可以使用以下命令使用自定义存储库：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`mvn clean package` installs the required components into a local repository
    and creates a WAR/JAR file of the project:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn clean package`将所需的组件安装到本地存储库，并创建项目的WAR/JAR文件：'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`mvn tomcat:run` runs a WAR file of the project on the Tomcat plugin. `mvn
    jetty:run` runs the WAR file of the project on the Jetty plugin:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`mvn tomcat:run`在Tomcat插件上运行项目的WAR文件。`mvn jetty:run`在Jetty插件上运行项目的WAR文件：'
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating a data contract
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据合同
- en: A WSDL document, known as a service contract, provides a standard way in which
    a Web-Service client and server exchange data. Using WSDL, the client and server
    could be on a different application or platform. XML Schema Definition(XSD), known
    as data contract, describes the structure of the datatypes that are being exchanged
    between the Web-Service server and client. XSD describes the types, fields, and
    any validation on those fields (such as max/min or pattern, and so on). While
    WSDL is specific to the Web-Service and describes a Web-Service's artifacts, such
    as methods and data passed through these methods (WSDL itself uses an XSD for
    that), URL, and so on; XSD only presents the structure of the data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: WSDL文档，也称为服务合同，提供了Web服务客户端和服务器交换数据的标准方式。使用WSDL，客户端和服务器可以位于不同的应用程序或平台上。XML Schema
    Definition（XSD），也称为数据合同，描述了Web服务服务器和客户端之间交换的数据类型的结构。XSD描述了类型、字段以及这些字段上的任何验证（如最大/最小或模式等）。虽然WSDL是特定于Web服务的，描述了Web服务的工件，如方法和通过这些方法传递的数据（WSDL本身使用XSD进行描述），URL等；XSD只呈现数据的结构。
- en: 'To be able to set up a Spring Web-Service, we need a contract. There are four
    different ways of defining such a contract for XML:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够设置Spring Web服务，我们需要一个合同。有四种不同的方法可以为XML定义这样的合同：
- en: DTDs
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTDs
- en: XML Schema (XSD)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML Schema（XSD）
- en: RELAX NG
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RELAX NG
- en: Schematron
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Schematron
- en: DTDs have limited namespace support, so they are not suitable for Web-Services.
    RELAX NG and Schematron certainly are easier than XML Schema. Unfortunately, they
    are not so widely supported across platforms. Spring-WS uses XML Schema.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: DTDs对命名空间的支持有限，因此不适用于Web服务。RELAX NG和Schematron肯定比XML Schema更容易。不幸的是，它们在各个平台上的支持并不如此广泛。Spring-WS使用XML
    Schema。
- en: A data contract is the center of Spring-WS and a service contract can be generated
    from a data contract. The easiest way to create an XSD is to infer it from the
    sample documents. Any good XML editor or Java IDE offers this functionality. Basically,
    these tools use some sample XML documents and generate a schema from it that validates
    them all. In this recipe, we will discuss sample XML data massages and how to
    convert them into a single schema file. The generated schema is used in this book
    as a data contract.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数据合同是Spring-WS的中心，服务合同可以从数据合同中生成。创建XSD的最简单方法是从样本文档中推断出来。任何良好的XML编辑器或Java IDE都提供了这种功能。基本上，这些工具使用一些样本XML文档，并从中生成一个模式，用于验证它们。在这个配方中，我们将讨论样本XML数据消息以及如何将它们转换为单个模式文件。生成的模式文件在本书中用作数据合同。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Install Java (as described in the first recipe).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Java（如第一个配方中所述）。
- en: Install xmlbeans-2.5.0 from [http://xmlbeans.apache.org/](http://xmlbeans.apache.org/).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[http://xmlbeans.apache.org/](http://xmlbeans.apache.org/)安装xmlbeans-2.5.0。
- en: The resources for this recipe are included in the folder Create Data Contract.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本配方的资源包含在文件夹Create Data Contract中。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Copy your XML messages `(placeOrderRequest.xml, placeOrderResponse, cancelOrderRequest.xml`,
    and `cancelOrderResponse.xml)` to the `xmlbeans-2.5.0\bin` working folder.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的XML消息（placeOrderRequest.xml、placeOrderResponse、cancelOrderRequest.xml和cancelOrderResponse.xml）复制到`xmlbeans-2.5.0\bin`工作文件夹中。
- en: 'Run the following command:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding command creates the `schema0.xsd` schema file. The generated
    schema result certainly needs to be modified, but it''s a great starting point.
    Here is the final polished schema `(orderService.xsd)`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令创建了`schema0.xsd`模式文件。生成的模式结果肯定需要修改，但这是一个很好的起点。这是最终精心制作的模式（orderService.xsd）：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Initially, the input and output sample messages are required. In this book,
    there are four XML messages (placeOrderRequest.xml, `placeOrderResponse, cancelOrderRequest.xml`,
    and `cancelOrderResponse.xml)` and all the recipes use these message data formats
    for communication. `Inst2xsd` generates a schema file from the existing XML sample
    messages. Resources of this recipe are included under the `Create Data Contract`
    folder in the resource bundle of this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要输入和输出样本消息。在本书中，有四个XML消息（placeOrderRequest.xml、`placeOrderResponse、cancelOrderRequest.xml`和`cancelOrderResponse.xml`），所有的配方都使用这些消息数据格式进行通信。`Inst2xsd`从现有的XML样本消息生成模式文件。本配方的资源包含在本章的资源包中的`Create
    Data Contract`文件夹中。
- en: Setting up a Web-Service using DispatcherServlet
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DispatcherServlet设置Web服务
- en: Spring-WS provides one of the easiest mechanisms to develop Web-Services in
    the Java platform. This recipe focuses on building a very simple Web-Service using
    the Spring-MVC `DispatcherServlet` and the components provided by Spring-WS.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Spring-WS提供了在Java平台上开发Web服务的最简单机制之一。这个配方专注于使用Spring-WS提供的Spring-MVC `DispatcherServlet`和组件构建一个非常简单的Web服务。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.2` with the following
    Maven dependencies:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，项目的名称是`LiveRestaurant_R-1.2`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`log4j-1.2.9.jar`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-1.2.9.jar`'
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Copy the service contract from the `resources` folder `(orderService.wsdl).`
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`resources`文件夹中复制服务合同（orderService.wsdl）。
- en: Create an endpoint `(OrderSeviceMessageReceiverEndpoint)`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个端点（OrderSeviceMessageReceiverEndpoint）。
- en: Configure the endpoint, service contract, `WebServiceMessageReceiverHandlerAdapter,
    MessageDispatcher`, and `WsdlDefinitionHandlerAdapter`, in the server Spring configuration
    file `(Dispatcher-servlet.xml)` .
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器Spring配置文件（`Dispatcher-servlet.xml`）中配置端点、服务合同、`WebServiceMessageReceiverHandlerAdapter,
    MessageDispatcher`和`WsdlDefinitionHandlerAdapter`。
- en: Configure `DispatcherServlet` inside the `web.xml` file.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`web.xml`文件中配置`DispatcherServlet`。
- en: 'Run the server using the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行服务器：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the output:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To browse your service WSDL, open the following link inside your browser:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要浏览您的服务WSDL，请在浏览器中打开以下链接：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To test, open a new command window, go to the folder `LiveRestaurant_R-1.2-Client`,
    and run the following command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行测试，打开一个新的命令窗口，转到文件夹`LiveRestaurant_R-1.2-Client`，并运行以下命令：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the server-side output:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是服务器端输出：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`DispatcherServlet` receives all the incoming requests, and based on request
    context, it forwards the request to the endpoint (the general form of a request
    URL is `http://<host>:<port>/<appcontext>/<requestcontext>` (here `appcontext`
    is Liverestaurant and `requestcontext` should start with `/Dispatcher/)`. The
    requests context that ends with `/OrderService` go to `OrderSeviceMessageReceiverEndpoint`
    and requests that end with `*.wsdl` go to `SimpleWsdl11Definition)`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`接收所有传入的请求，并根据请求上下文将请求转发到端点（请求URL的一般形式为`http://<host>:<port>/<appcontext>/<requestcontext>`（这里`appcontext`是Liverestaurant，`requestcontext`应以`/Dispatcher/`开头）。以`/OrderService`结尾的请求上下文转到`OrderSeviceMessageReceiverEndpoint`，以`*.wsdl`结尾的请求转到`SimpleWsdl11Definition`）。'
- en: '`DispatcherServlet` configured in `web.xml` is responsible for receiving all
    requests with a URL mapping `[/Dispatcher/*]`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web.xml`中配置的`DispatcherServlet`负责接收所有具有URL映射`[/Dispatcher/*]`的请求。
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can change the URL pattern to suit your requirement.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更改URL模式以满足您的需求。
- en: '`DispatcherServlet` plays a major role in intercepting the HTTP requests and
    then loads the Spring bean configuration file. By default, it detects the bean
    configuration file by name`<servlet-name>-servlet.xml`. Since we have named the
    `DispatcherServlet` as `Dispatcher` in `web.xml` file, the server looks for `Dispatcher-servlet.xml`
    as application context filename. You may configure another file, using the following
    context `param` in the `web.xml:`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`在拦截HTTP请求并加载Spring bean配置文件方面起着重要作用。默认情况下，它通过名称`<servlet-name>-servlet.xml`来检测bean配置文件。由于我们在`web.xml`文件中将`DispatcherServlet`命名为`Dispatcher`，服务器会寻找`Dispatcher-servlet.xml`作为应用程序上下文文件名。您可以使用`web.xml`中的以下上下文`param`来配置另一个文件：'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`DispatcherServlet` needs separate instances of `WebServiceMessageReceiverHandlerAdapter,
    MessageDispatcher`, and `WsdlDefinitionHandlerAdapter` that in this recipe are
    configured inside `Dispatcher-servlet.xml`. The `DispatcherServlet`, by default,
    delegates to controllers for handling requests, but in the configuration file,
    it is configured to delegate to a `MessageDispatcher` `(WebServiceMessageReceiverHandlerAdapter).
    SaajSoapMessageFactory` is a specific message factory for message creation in
    Spring-WS.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`需要`WebServiceMessageReceiverHandlerAdapter, MessageDispatcher`和`WsdlDefinitionHandlerAdapter`的单独实例，这些实例在`Dispatcher-servlet.xml`中进行了配置。默认情况下，`DispatcherServlet`委托给控制器处理请求，但在配置文件中，它被配置为委托给`MessageDispatcher`（`WebServiceMessageReceiverHandlerAdapter）。SaajSoapMessageFactory`是Spring-WS中用于消息创建的特定消息工厂。'
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To let `DispatcherServlet` handle the WSDL contract, `WsdlDefinitionHandlerAdapter`,
    which is registered in the configuration file; it reads the WSDL file source using
    the `WsdlDefinition` implementation `(SimpleWsdl11Definition)` and writes that
    as the result to the `HttpServletResponse`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让`DispatcherServlet`处理WSDL合同，需要在配置文件中注册`WsdlDefinitionHandlerAdapter`；它使用`WsdlDefinition`实现（`SimpleWsdl11Definition`）来读取WSDL文件源，并将其作为结果写入`HttpServletResponse`。
- en: '`SimpleUrlHandlerMapping` is to redirect the client requests to the appropriate
    endpoints using the URL patterns. Here the request URL that ends with `*.wsdl`
    will be redirected to `sampleServiceDefinition` (that is, `SimpleWsdl11Definition`
    that uses `OrderService.wsdl` to generate the response), and if the request URL
    contains `/OrderService`, it will be redirected to `OrderSeviceMessageReceiverEndpoint.
    SOAPMessageDispatcher` is to dispatch a SOAP message to the registered endpoint(s)
    `(OrderSeviceMessageReceiverEndpoint)`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleUrlHandlerMapping`用于使用URL模式将客户端请求重定向到适当的端点。在这里，以`*.wsdl`结尾的请求URL将被重定向到`sampleServiceDefinition`（即使用`OrderService.wsdl`生成响应的`SimpleWsdl11Definition`），如果请求URL包含`/OrderService`，它将被重定向到`OrderSeviceMessageReceiverEndpoint。SOAPMessageDispatcher`用于将SOAP消息分派到已注册的端点（`OrderSeviceMessageReceiverEndpoint`）。'
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can change the URL pattern to suit your requirement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以更改URL模式以满足您的需求。
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See also
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Setting up a Web-Service using MessageDispatcherServlet* recipe in this
    chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的*使用MessageDispatcherServlet设置Web服务*食谱。
- en: Simplifying the creation of a Web-Service using MessageDispatcherServlet
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化使用MessageDispatcherServlet创建Web服务
- en: '`MessageDispatcherServlet` is the core component of Spring-WS. With simple
    configuration, a Web-Service can be set up in minutes. This servlet came as a
    simple way to configure an alternative to the Spring-MVC `DispatcherServlet`.
    As in the second recipe, *Setting up a Web-Service using DispatcherServlet*, `DispatcherServlet`
    needs separate instances of `WebServiceMessageReceiverHandlerAdapter, MessageDispatcher`,
    and `WsdlDefinitionHandlerAdapter`. However, `MessageDispatcherServlet` can dynamically
    detect `EndpointAdapters, EndpointMappings, EndpointExceptionResolvers`, and `WsdlDefinition`
    by setting inside the application context.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageDispatcherServlet`是Spring-WS的核心组件。通过简单的配置，可以在几分钟内设置Web服务。这个servlet作为配置Spring-MVC`DispatcherServlet`的替代方案而出现。与第二个食谱中*使用DispatcherServlet设置Web服务*一样，`DispatcherServlet`需要单独的`WebServiceMessageReceiverHandlerAdapter,
    MessageDispatcher`和`WsdlDefinitionHandlerAdapter`的实例。然而，`MessageDispatcherServlet`可以通过在应用程序上下文中设置来动态检测`EndpointAdapters,
    EndpointMappings, EndpointExceptionResolvers`和`WsdlDefinition`。'
- en: Since this is the default method for configuring Spring Web-Services, it will
    be used in later recipes. In this recipe, a very basic implementation of setting
    up a Spring-WS is detailed. More advance implementation will be explained later
    in the recipe *Setting up a contract-first Web-Service*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是配置Spring Web服务的默认方法，因此将在后续配方中使用。在此配方中，详细介绍了设置Spring-WS的基本实现。更高级的实现将在后面的配方*设置基于契约的Web服务*中解释。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.3` with the following
    Maven dependencies:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，项目名称为LiveRestaurant_R-1.3，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spring-ws-core-2.0.1.RELEASE.jar
- en: '`log4j-1.2.9.jar`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-1.2.9.jar`'
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Copy the service contract from the `resources` folder `(orderService.wsdl)`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从资源文件夹（orderService.wsdl）复制服务合同。
- en: Create an endpoint `(OrderSeviceMethodEndpoint)`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建端点（OrderSeviceMethodEndpoint）。
- en: Configure the endpoint. The service contract is in the server Spring configuration
    file `(spring-ws-servlet.xml)`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置端点。服务合同在服务器Spring配置文件（spring-ws-servlet.xml）中。
- en: Configure `MessageDispatcherServlet` inside the `web.xml` file.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在web.xml文件中配置MessageDispatcherServlet。
- en: 'Run the server using the following command:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行服务器：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the output after the server is run successfully:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功运行服务器后的输出如下：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To browse your service WSDL, open the following link in your browser:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要浏览您的服务WSDL，请在浏览器中打开以下链接：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To test, open a new command window, go to the folder `LiveRestaurant_R-1.3-Client`,
    and run the following command:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行测试，打开一个新的命令窗口，转到文件夹LiveRestaurant_R-1.3-Client，并运行以下命令：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is the server-side output:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是服务器端的输出：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MessageDispatcherServlet` is configured in the web configuration file `web.xml:`
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: MessageDispatcherServlet在web配置文件web.xml中配置：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.PacktPub.com](http://www.PacktPub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了本书，可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册，以便文件直接通过电子邮件发送给您。
- en: '`MessageDispatcherServlet` is the central element that handles the incoming
    SOAP requests, with the help of other components `(EndpointAdapters, EndpointMappings,
    EndpointExceptionResolvers`, and `WsdlDefinition)`. It combines the attributes
    of both `DispatcherServlet` and `MessageDispatcher` that dispatch to the appropriate
    endpoint. This is the standard servlet recommended to build Web-Services with
    Spring-WS.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: MessageDispatcherServlet是处理传入SOAP请求的中心元素，借助其他组件（EndpointAdapters，EndpointMappings，EndpointExceptionResolvers和WsdlDefinition）。它结合了DispatcherServlet和MessageDispatcher的属性，以将请求分派到适当的端点。这是建议使用Spring-WS构建Web服务的标准servlet。
- en: Since the `MessageDispatcherServlet` is inherited from `FrameworkServlet`, it
    looks for a configuration file named`<servlet-name>-servlet.xml` in the class
    path (you can change the configuration filename using the `context-param, contextConfigLocation`
    settings in the `web.xml`, as described in the recipe *Setting up a Web-Service
    using DispatcherServlet)*. In the example, since the servlet name in the `web.xml`
    file is set to Spring-WS, the file `spring-ws-servlet.xml` is the Web-Services
    configuration file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MessageDispatcherServlet是从FrameworkServlet继承的，它会在类路径中查找名为<servlet-name>-servlet.xml的配置文件（您可以使用web.xml中的context-param，contextConfigLocation设置更改配置文件名，如在配方*使用DispatcherServlet设置Web服务中所述）。在本例中，由于web.xml文件中的servlet名称设置为Spring-WS，因此文件spring-ws-servlet.xml是Web服务配置文件。
- en: '`MessageDispatcherServlet` then looks up for an endpoint mapping element in
    the configuration file, for the purpose of mapping the client requests to the
    endpoint. Here,`<sws:static-wsdl` sets the data contract in the WSDL format. This
    is the element to be configured in `spring-ws-servlet.xml` to set up a Web-Service:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，MessageDispatcherServlet在配置文件中查找端点映射元素，以将客户端请求映射到端点。在这里，<sws:static-wsdl设置WSDL格式的数据合同。这是在spring-ws-servlet.xml中配置的元素，用于设置Web服务：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The example uses `SimpleMethodEndpointMapping` that maps the client requests
    to `MethodEnpoints`. It maps the incoming request to a method that starts with
    the `handle+root` element of the message `(handle+placeOrderRequest)`. In the
    endpoint class `(OrderSeviceMethodEndpoint), a method with the name handleplaceOrderRequest`
    should be defined.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用SimpleMethodEndpointMapping将客户端请求映射到MethodEnpoints。它将传入请求映射到以消息的handle+root元素（handle+placeOrderRequest）开头的方法。在端点类（OrderSeviceMethodEndpoint）中，应定义一个名为handleplaceOrderRequest的方法。
- en: 'In this method, the parameter source includes the incoming message and input
    parameters to call order service could be extracted from this parameter, then
    the method calls to the `orderService` method and wraps the outgoing message in
    the `StringSource` that is to be sent back to the client:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，参数源包括传入消息和从该参数中提取调用订单服务的输入参数，然后该方法调用orderService方法，并将传出消息包装在StringSource中，以发送回客户端：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The endpoint mappings will be detailed in the later recipes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 端点映射将在后面的配方中详细说明。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipes *Setting up a Web-Service using DispatcherServlet, Setting up a
    simple endpoint mapping for the Web-Service*, and *Setting up a contract-first
    Web-Service* discussed in this chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中讨论的配方*使用DispatcherServlet设置Web服务，为Web服务设置简单的端点映射*和*设置基于契约的Web服务*。
- en: Setting up a Web-Service on JMS transport
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JMS传输上设置Web服务
- en: HTTP is the most common Web-Service protocol. However, Web-Services are currently
    built on multiple transports, each with different scenarios.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是最常见的Web服务协议。但是，Web服务目前是建立在多种传输上的，每种传输都有不同的场景。
- en: 'JMS was included in Java 2, J2EE by Sun Microsystems in 1999\. Using JMS, systems
    are able to communicate synchronously or asynchronously and are based on point-to-point
    and publish-subscribe models. SOAP over JMS inherits the JSM features and meets
    the following requirements:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: JMS 在 1999 年由 Sun Microsystems 包含在 Java 2、J2EE 中。使用 JMS，系统能够同步或异步通信，并基于点对点和发布-订阅模型。SOAP
    over JMS 继承了 JSM 的特性，并满足以下要求：
- en: Where asynchronous messaging is required
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要异步消息传递时
- en: Where the message consumers are slower than the producers
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当消息消费者比生产者慢时
- en: To guarantee the delivery of messages
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保证消息的传递
- en: To have a publisher/subscriber(multiple) model
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要有发布者/订阅者（多个）模型
- en: When sender/receiver might be disconnected
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发送者/接收者可能断开连接时
- en: Spring Web-Services provide features to set up a Web-Service over JMS protocol
    that is built upon the JMS functionality in the Spring framework. In this recipe,
    how to set up a Spring-WS over JMS is presented.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Web 服务提供了在 JMS 协议上设置 Web 服务的功能，该功能是建立在 Spring 框架中的 JMS 功能之上的。在这个配方中，介绍了如何在
    JMS 上设置 Spring-WS。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.4` with the following
    Maven dependencies:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，项目的名称是 `LiveRestaurant_R-1.4`，具有以下 Maven 依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`spring-ws-support-2.0.1.RELEASE.jar`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-support-2.0.1.RELEASE.jar`'
- en: '`spring-test-3.0.5.RELEASE.jar`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-test-3.0.5.RELEASE.jar`'
- en: '`spring-jms-3.0.5.RELEASE.jar`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-jms-3.0.5.RELEASE.jar`'
- en: '`junit-4.7.jar`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junit-4.7.jar`'
- en: '`xmlunit-1.1.jar`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xmlunit-1.1.jar`'
- en: '`log4j-1.2.9.jar`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-1.2.9.jar`'
- en: '`jms-1.1.jar`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jms-1.1.jar`'
- en: '`activemq-core-4.1.1.jar`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activemq-core-4.1.1.jar`'
- en: In this recipe, Apache ActiveMQ is used to set up a JMS server and to create
    JMS server-related objects (queue and broker are used here). Spring-WS family
    JARs provide a functionality to set up a Spring-WS and `spring-jms` and `jms`
    JARs provide the JMS functionality that the Spring-WS, over JMS, is built upon
    it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，使用 Apache ActiveMQ 来设置 JMS 服务器并创建 JMS 服务器相关的对象（这里使用了队列和代理）。Spring-WS
    家族的 JAR 提供了设置 Spring-WS 的功能，而 `spring-jms` 和 `jms` JAR 提供了 Spring-WS 在 JMS 上建立的
    JMS 功能。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create an endpoint `(OrderSeviceMethodEndpoint)`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建端点 `(OrderSeviceMethodEndpoint)`。
- en: Configure the `MessageListenerContainer, MessageListener`, and `connectionFactory`
    in the Spring configuration file (`applicationContext.xml`).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Spring 配置文件 (`applicationContext.xml`) 中配置 `MessageListenerContainer`、`MessageListener`
    和 `connectionFactory`。
- en: Configure `MessageDispatcher` that includes the endpoint mappings inside `applicationContext.xml`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `applicationContext.xml` 中配置包括端点映射的 `MessageDispatcher`。
- en: 'Run the recipe project using the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行配方项目：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is the output once the project runs successfully:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目成功运行，以下是输出：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`DefaultMessageListenerContainer` listens to `destinationName` `(RequestQueue)`
    for incoming messages. When a message arrives, this listener will use the message
    factory `(messageFactory)` to extract the message and use the dispatcher `(messageDispatcher)`
    to dispatch the message to the endpoint `(SimplePayloadEndpoint)`.............'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultMessageListenerContainer` 监听 `destinationName` `(RequestQueue)` 以接收传入的消息。当消息到达时，此监听器将使用消息工厂
    `(messageFactory)` 提取消息，并使用调度程序 `(messageDispatcher)` 将消息分派到端点 `(SimplePayloadEndpoint)`.............'
- en: 'In the application context, `WebServiceMessageListener` is a listener inside
    `MessageListenerContainer`. The message container uses `connectionfactory` to
    connect to the destination (RequestQueue):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序上下文中，`WebServiceMessageListener` 是 `MessageListenerContainer` 中的监听器。消息容器使用
    `connectionfactory` 连接到目的地（RequestQueue）：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This listener uses `message Dispatcher` and `messageFactory` to receive incoming
    messages and to send outgoing SOAP messages. Inside `messageDiapatcher`, endpoint''s
    mapping is included, which sets the endpoint `(SimplePayloadEndpoint)` and type
    of endpoint mapping `(PayloadRootQNameEndpointMapping)`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此监听器使用 `message Dispatcher` 和 `messageFactory` 来接收传入的消息并发送传出的 SOAP 消息。在 `messageDiapatcher`
    中，包括端点的映射，设置端点 `(SimplePayloadEndpoint)` 和端点映射的类型 `(PayloadRootQNameEndpointMapping)`：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `invoke` method from the endpoint `(SimplePayloadEndpoint)` will be called
    when a request comes to the server, and the response will be returned to be sent
    back to the client:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达服务器时，端点 `(SimplePayloadEndpoint)` 的 `invoke` 方法将被调用，并且将返回响应以发送回客户端：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`JmsTransportWebServiceIntegrationTest` is included in the project to load
    the application context, set up the JMS server, and test the Web-Service. However,
    these details are not discussed here. The client of JMS transport will be discussed
    in the next chapter.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`JmsTransportWebServiceIntegrationTest` 包含在项目中，用于加载应用程序上下文，设置 JMS 服务器并测试 Web
    服务。但这些细节在这里没有讨论。JMS 传输的客户端将在下一章中讨论。'
- en: See also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a Web-Service client on JMS transport* recipe discussed in [Chapter
    2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"), *Building Clients
    for SOAP Web-Services* and the *Exposing Web-Services using JMS as the underlying
    communication protocol* recipe discussed in [Chapter 10](ch10.html "Chapter 10. Spring
    Remoting"),*Spring Remoting.*
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](ch02.html "第 2 章。构建 SOAP Web 服务的客户端")中讨论了 *在 JMS 传输上创建 Web 服务客户端* 配方，*构建
    SOAP Web 服务的客户端* 和在[第 10 章](ch10.html "第 10 章。Spring 远程调用")中讨论了 *使用 JMS 作为底层通信协议暴露
    Web 服务* 的配方，*Spring 远程调用*。
- en: Setting up a Web-Service on E-mail transport
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在电子邮件传输上设置 Web 服务
- en: HTTP is easy to understand and therefore has been most often defined and implemented,
    but it's clearly not the most suitable transport for Web-Services in any scenario.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 容易理解，因此通常被定义和实现，但在任何情况下都不是 Web 服务的最合适的传输方式。
- en: Web-Service on E-mail transport can take advantage of store-and-forward messaging
    to provide an asynchronous transport for SOAP. In addition, there is no firewall
    concern on e-mail and those applications that are able to communicate together
    don't need web servers to set up a Web-Service. This allows SOAP, over mail transport,
    to be used in a number of scenarios where HTTP is not suitable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件传输的Web服务可以利用存储转发消息传递来提供SOAP的异步传输。此外，电子邮件上没有防火墙问题，那些能够相互通信的应用程序无需设置Web服务器来建立Web服务。这允许在HTTP不适用的许多场景中使用SOAP通过邮件传输。
- en: 'The reasons why setting up a Web-Service over HTTP is not suitable and e-mail
    might be a solution as a transport protocol are listed as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Web服务通过HTTP不适合的原因，以及电子邮件可能作为传输协议的解决方案如下所列：
- en: If a system is protected by a firewall, there is no control over the HTTP request/response,
    but e-mail is always is accessible.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系统受到防火墙的保护，就无法控制HTTP请求/响应，但是电子邮件始终是可访问的。
- en: If a system expects no request/response conventional model. For example, publish/subscriber
    model is required.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系统不期望传统的请求/响应模型。例如，需要发布/订阅模型。
- en: If a request takes too long to complete. For example, if the server has to run
    complex and time-consuming services, the client would get an HTTP timeout error.
    In such a scenario, Web-Service over e-mail is more appropriate.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求花费太长时间来完成。例如，如果服务器必须运行复杂和耗时的服务，客户端将收到HTTP超时错误。在这种情况下，通过电子邮件的Web服务更合适。
- en: In this recipe, setting up a Web-Service over E-mail transport is presented.
    To load the application context and test the Web-Service, a test class is used.
    This class also starts up and shuts down the server.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，介绍了通过电子邮件传输设置Web服务。为了加载应用程序上下文并测试Web服务，使用了一个测试类。这个类还启动和关闭服务器。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.5` with the following
    Maven dependencies:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，项目的名称是`LiveRestaurant_R-1.5`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`spring-ws-support-2.0.1.RELEASE.jar`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-support-2.0.1.RELEASE.jar`'
- en: '`spring-test-3.0.5.RELEASE.jar`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-test-3.0.5.RELEASE.jar`'
- en: '`mail-1.4.1.jar`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mail-1.4.1.jar`'
- en: '`mock-javamail-1.6.jar`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock-javamail-1.6.jar`'
- en: '`junit-4.7.jar`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junit-4.7.jar`'
- en: '`xmlunit-1.1.jar`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xmlunit-1.1.jar`'
- en: Setting up a mail server outside a system that is using JavaMail for testing
    purpose is difficult. Mock JavaMail addresses this issue and provides a pluggable
    component to the system using JavaMail. The system can use this component to send/receive
    e-mails against the temporary in-memory *mailbox*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JavaMail进行测试的系统外设置邮件服务器是困难的。模拟JavaMail解决了这个问题，并为使用JavaMail的系统提供了可插拔的组件。系统可以使用这个组件来针对临时的内存*邮箱*发送/接收电子邮件。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create an endpoint `(SimplePayloadEndpoint)`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建端点`(SimplePayloadEndpoint)`。
- en: Configure `MessageReceiver` and `MessageDispatcher` that include endpoint mappings
    inside `applicationContext.xml`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`applicationContext.xml`中配置包含端点映射的`MessageReceiver`和`MessageDispatcher`。
- en: 'Run the recipe project using the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行配方项目：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following is the output:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Messages sent to an address will be saved in an inbox. The message receiver
    `(messageReceiver)` monitors the inbox at continuous intervals and as soon as
    it detects a new E-mail, it reads the E-mail, extracts the message, and forwards
    the message to a message dispatcher `(messageDispatcher)`. The message dispatcher
    will call the `invoke` method inside its default endpoint `(SamplePayloadEndpoint)`,
    and inside the handler method `(invoke)`, the response will be sent back to the
    client.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到地址的消息将保存在收件箱中。消息接收器`(messageReceiver)`会在连续的间隔中监视收件箱，一旦检测到新的电子邮件，它就会读取电子邮件，提取消息，并将消息转发给消息调度程序`(messageDispatcher)`。消息调度程序将调用其默认端点`(SamplePayloadEndpoint)`内的`invoke`方法，并在处理程序方法`(invoke)`内将响应发送回客户端。
- en: 'When the application context is being loaded, `MailMessageReceiver` starts
    up a mail receiver and its inbox folder `(imap://server@packtpubtest.com/INBOX)`,
    that is, a temporary in-memory inbox. After loading the application context, the
    `messageReceiver` bean acts as a server monitor for the incoming messages based
    on a pluggable strategy `(monotoringStrategy)` that monitors the `INBOX` folder
    `(imap://server@packtpubtest.com/INBOX)` for new messages on `pollingInterval`
    of 1000 ms. `storeUri` is the location to be monitored for the incoming messages
    `(imap://server@packtpubtest.com/INBOX)` and `transportUri` is the mail server
    for sending the responses:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载应用程序上下文时，`MailMessageReceiver`启动邮件接收器及其收件箱文件夹`(imap://server@packtpubtest.com/INBOX)`，即临时内存收件箱。加载应用程序上下文后，`messageReceiver`
    bean充当基于可插拔策略`(monotoringStrategy)`监视`INBOX`文件夹`(imap://server@packtpubtest.com/INBOX)`上的新消息的服务器监视器，轮询间隔为1000毫秒。`storeUri`是要监视传入消息的位置`(imap://server@packtpubtest.com/INBOX)`，`transportUri`是用于发送响应的邮件服务器：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside `messageDiapatcher`, endpoint mapping is included that sets the endpoint
    `(SimplePayloadEndpoint)` and type of the endpoint mapping `(PayloadRootQNameEndpointMapping)`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在`messageDiapatcher`中包含了端点映射，设置了端点`(SimplePayloadEndpoint)`和端点映射的类型`(PayloadRootQNameEndpointMapping)`：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`SimplePayloadEndpoint` receives a request and returns a fixed dummy response
    using `OrderService`. When a request comes to the server, the `invoke` method
    will be called and the response will be returned that is to be sent back to the
    client:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimplePayloadEndpoint`接收请求并使用`OrderService`返回固定的虚拟响应。当请求到达服务器时，将调用`invoke`方法，并返回要发送回客户端的响应。'
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To test this recipe, a `webServiceTemplate` is used. We will discuss it in the
    next chapter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个配方，使用了`webServiceTemplate`。我们将在下一章讨论它。
- en: '`MailTransportWebServiceIntegrationTest` is included in the project to load
    the application context, set up the mail server, and to test the Web-Service.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailTransportWebServiceIntegrationTest`包含在项目中，用于加载应用程序上下文，设置邮件服务器并测试Web服务。'
- en: See also
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating Web-Service client on E-mail transport* recipe, discussed in [Chapter
    2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*BuildingClients
    for SOAP Web-Services.*
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。构建SOAP Web服务的客户端")中讨论的*在电子邮件传输上创建Web服务客户端*配方，*构建SOAP Web服务的客户端*。
- en: Setting up a Web-Service on embedded HTTP transport
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在嵌入式HTTP传输上设置Web服务
- en: External HTTP servers might be able to provide several features, but they are
    not light and they need a configuration to set up.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 外部HTTP服务器可能能够提供多种功能，但它们不够轻便，需要配置才能设置。
- en: Spring-WS provides a feature to set up an HTTP-based Web-Service using embedded
    Sun's JRE 1.6 HTTP server. The embedded HTTP server is a light-weight standalone
    server that could be used as an alternative to external servers. While configuration
    of the web server is a must in a conventional external server `(web.xml)`, the
    embedded HTTP server doesn't need any deployment descriptor to operate and its
    only requirement is to configure an instance of the server through the application
    context.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Spring-WS提供了一个功能，可以使用嵌入式Sun的JRE 1.6 HTTP服务器设置基于HTTP的Web服务。嵌入式HTTP服务器是一个轻量级的独立服务器，可以作为外部服务器的替代方案。在传统的外部服务器中，必须配置Web服务器的配置`(web.xml)`，而嵌入式HTTP服务器不需要任何部署描述符来操作，它唯一的要求是通过应用程序上下文配置服务器的实例。
- en: In this recipe, setting up a Spring Web-Service on the embedded HTTP server
    is presented. Since there is no external HTTP server, a Java class is used to
    load application context and start up the server.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，介绍了在嵌入式HTTP服务器上设置Spring Web服务。由于没有外部HTTP服务器，因此使用一个Java类来加载应用程序上下文并启动服务器。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.6` with the following
    Maven dependencies:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，项目的名称是`LiveRestaurant_R-1.6`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`log4j-1.2.9.jar`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-1.2.9.jar`'
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Copy the service contract `(OrderService.wsdl)` from the resource folder.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从资源文件夹中复制服务契约`(OrderService.wsdl)`。
- en: Create a service and an implementation of it and annotate its implementation
    with `@Service("serviceName")` `(OrderSevice,OrderServiceImpl)`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个服务及其实现，并使用`@Service("serviceName")`注解其实现`(OrderSevice,OrderServiceImpl)`。
- en: Configure the service in the application context `(applicationContext)` that
    is to be scanned and detected automatically.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序上下文`(applicationContext)`中配置要自动扫描和检测的服务。
- en: Configure the embedded HTTP server inside the application context.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序上下文中配置嵌入式HTTP服务器。
- en: Add a Java class with the main method to load the application context to set
    up the embedded HTTP server.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个具有主方法的Java类，以加载应用程序上下文来设置嵌入式HTTP服务器。
- en: 'Run the server using the following command:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行服务器：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'From `LiveRestaurant_R-1.6-Client`, run the following command:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`LiveRestaurant_R-1.6-Client`运行以下命令：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following is the output when the server runs successfully:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器成功运行时，以下是输出：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following is the client-side output:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是客户端的输出：
- en: '[PRE42]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the application context, `SimpleHttpFactoryBean` creates a simple HTTP server
    (from embedded Sun's JRE 1.6) and it starts the HTTP server on initialization
    and stops it on destruction.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序上下文中，`SimpleHttpFactoryBean`创建一个简单的HTTP服务器（来自嵌入式Sun的JRE 1.6），并在初始化时启动HTTP服务器，在销毁时停止它。
- en: The HTTP server that has a context property sets up a Web-Service with the service
    class `(orderServiceImpl)` set as the endpoint and specifies the URL defined by
    the properties inside the context `(localhost:3478/OrderService)`. This service
    interface is registered within the context property.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 具有上下文属性的HTTP服务器使用服务类`(orderServiceImpl)`设置Web服务端点，并指定上下文内定义的URL`(localhost:3478/OrderService)`。此服务接口在上下文属性中注册。
- en: However, the service implementation is autodetected using `component-scan. HttpInvokerProxyFactoryBean`
    creates a client's proxy for a specific server URL.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，服务实现是使用`component-scan`自动检测的。`HttpInvokerProxyFactoryBean`为特定服务器URL创建客户端代理。
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`IOrderServiceEndPointImpl` and `IOrderServiceEndPoint` are simple service
    interface and implementation classes. `IOrderServiceEndPointImpl` is annotated
    by `@Service` `(orderServiceImpl)` and is to be detected as a service implementation.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`IOrderServiceEndPointImpl`和`IOrderServiceEndPoint`是简单的服务接口和实现类。`IOrderServiceEndPointImpl`被`@Service`注解`(orderServiceImpl)`，并且将被检测为服务实现。'
- en: '[PRE44]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`ServerStartUp.java` is used to load the application context and start up the
    server:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerStartUp.java`用于加载应用程序上下文并启动服务器：'
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Setting up Spring-WS on XMPP transport
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在XMPP传输上设置Spring-WS
- en: HTTP is most often used as a Web-Service transport protocol. However, it is
    not able to meet the asynchronous communication requirements.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP通常用作Web服务传输协议。然而，它无法满足异步通信的要求。
- en: Web-Service on XMPP transport is capable of asynchronous communication in which
    a client doesn't need to wait for a response from a service; instead, the service
    sends the response to the client when the process is completed. Spring-WS 2.0
    includes XMPP (Jabber) support in which a Web-Service can communicate over the
    XMPP protocol. In this recipe, setting up a Spring-WS on XMPP transport is presented.
    Since there is no external HTTP server, a test class is used to load the application
    context.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: XMPP传输上的Web服务能够进行异步通信，客户端无需等待服务端的响应；相反，服务在完成过程后将响应发送给客户端。Spring-WS 2.0包括XMPP（Jabber）支持，其中Web服务可以通过XMPP协议进行通信。在这个配方中，介绍了在XMPP传输上设置Spring-WS的过程。由于没有外部HTTP服务器，因此使用一个测试类来加载应用程序上下文。
- en: Getting ready
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.7`, which has the
    following Maven dependencies:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，项目的名称是`LiveRestaurant_R-1.7`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`spring-ws-support-2.0.1.RELEASE.jar`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-support-2.0.1.RELEASE.jar`'
- en: '`spring-test-3.0.5.RELEASE.jar`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-test-3.0.5.RELEASE.jar`'
- en: '`junit-4.7.jar`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`junit-4.7.jar`'
- en: '`xmlunit-1.1.jar`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xmlunit-1.1.jar`'
- en: '`smack-3.1.0.jar`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smack-3.1.0.jar`'
- en: How to do it...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create an endpoint `(SamplePlayLoadEndPoint).`
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个端点`(SamplePlayLoadEndPoint)`。
- en: Configure connection to the XMPP server in the application context `(applicationContext.xml)`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序上下文（`applicationContext.xml`）中配置与XMPP服务器的连接。
- en: Configure the message receiver in the application context.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序上下文中配置消息接收器。
- en: 'Run the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE46]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following is the response received:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是收到的响应：
- en: '[PRE47]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the application context, the `messageFactory` bean is responsible for creating
    the incoming and outgoing SOAP messages. The `messageReceiver` bean acts as a
    server, using a connection (to `XMPP server:google talk)`, and listens to the
    host on a specific service with a username and password.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序上下文中，`messageFactory` bean负责创建传入和传出的SOAP消息。`messageReceiver` bean充当服务器，使用连接（到`XMPP服务器：google
    talk`），并侦听具有用户名和密码的特定服务的主机。
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once the message is sent by the client, it will be forwarded to the endpoint
    `(SamplePlayLoadEndPoint` that is configured within `messageDispatcher)` by the
    message dispatcher and the response will be returned to the client:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端发送消息，它将通过消息分发器转发到端点（`SamplePlayLoadEndPoint`配置在`messageDispatcher`中），并将响应返回给客户端：
- en: '[PRE49]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`Webservicetemplate` is used here as a client; it will be discussed in the
    next chapter.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Webservicetemplate`在这里用作客户端；将在下一章中讨论。'
- en: '`SamplePlayLoadEndPoint` just receives a request and returns a response:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`SamplePlayLoadEndPoint`只接收请求并返回响应：'
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: A test class is included in the project to load the application context, set
    up the XMPP Web-Service server, and test the Web-Service.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中包含一个测试类，用于加载应用程序上下文，设置XMPP Web服务服务器，并测试Web服务。
- en: See also
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating Web-Service client on XMPP transport* recipe discussed in [Chapter
    2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*Clients for
    SOAP Web-Services.*
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。为SOAP Web服务构建客户端")中讨论的*在XMPP传输上创建Web服务客户端*教程，*SOAP Web服务的客户端*。
- en: Setting up a contract-first Web-Service
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立基于合同的Web服务
- en: Generating WSDL and XSD contracts from Java code and setting up a Web-Service
    is called **contract-last development**. The major drawback to this approach is
    the contracts (WSDL or XSD) of the Web-Service could eventually change if there
    are any changes in Java classes. In this way, the client side has to update the
    client-side classes and that always is not favorable. The contract-first approach
    was introduced as an alternative to tackle the contract-last's bottleneck. In
    the contract-first approach, the contract (WSDL or schema) are primary artifacts
    to set up a Web-Service.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java代码生成WSDL和XSD合同并设置Web服务称为**合同后开发**。这种方法的主要缺点是Web服务的合同（WSDL或XSD）最终可能会发生变化，如果Java类发生任何更改。通过这种方式，客户端必须更新客户端类，这并不总是令人满意。合同优先方法被引入作为解决合同后瓶颈的替代方法。在合同优先方法中，合同（WSDL或模式）是设置Web服务的主要工件。
- en: 'Some of the advantages of the contract-first approach over contract-last are
    as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 合同优先方法相对于合同后方法的一些优点如下：
- en: 'Performance: In contract-last, some extra data, that is, serialization of Java
    code might be exchanged between client and server, which decreases the performance,
    while contract-last precisely exchanges the required data and maximizes the performance.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：在合同后方法中，可能会在客户端和服务器之间交换一些额外的数据，即Java代码的序列化，这会降低性能，而合同优先方法精确交换所需的数据并最大化性能。
- en: 'Consistency: Different vendors may generate different WSDL in the contract-last
    approach, while the contract-first approach eliminates this problem by standing
    on the same contract.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性：在合同后方法中，不同的供应商可能会生成不同的WSDL，而合同优先方法通过依赖于相同的合同来消除这个问题。
- en: 'Versioning: Changing the version of a contract-last Web-Service means changing
    Java classes in both client and server side and that might eventually be expensive
    in case there are a lot of clients that call a Web-Service, while in contract-first,
    since the contract is decoupled from implementation, versioning could be simply
    done by adding a new method implementation in the same endpoint class or using
    a stylesheet to convert an old message format into new message format.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制：更改合同后Web服务的版本意味着在客户端和服务器端更改Java类，如果有很多客户端调用Web服务，这可能最终会很昂贵，而在合同优先方法中，由于合同与实现解耦，版本控制可以通过在同一端点类中添加新的方法实现或使用样式表将旧消息格式转换为新消息格式来简单完成。
- en: 'Maintenance/enhancement cost: Changing only a contract is much cheaper than
    changing Java code in both client and server side. In this recipe, we will discuss
    how to set up a contract-first Web-Service using Spring-WS.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护/增强成本：仅更改合同比在客户端和服务器端的Java代码中更改要便宜得多。在本教程中，我们将讨论如何使用Spring-WS建立基于合同的Web服务。
- en: Getting ready
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.8`, with the following
    Maven dependencies:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，项目名称为`LiveRestaurant_R-1.8`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`jdom-1.0.jar`'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdom-1.0.jar`'
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Copy the data contract `(orderService.xsd)` from the resources folder.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从资源文件夹复制数据合同（`orderService.xsd`）。
- en: Create an endpoint `(OrderEndpoint)`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个端点（`OrderEndpoint`）。
- en: Configure the auto-detection of the endpoint using the component scan in the
    server Spring configuration file `(spring-ws-servlet.xml)`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器Spring配置文件（`spring-ws-servlet.xml`）中使用组件扫描配置端点的自动检测。
- en: Configure the dynamic generation of WSDL from the data contract `(orderService.xsd)`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置从数据合同（`orderService.xsd`）动态生成WSDL。
- en: 'Run the server using the following command:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行服务器：
- en: '[PRE51]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Browse to the following link to see the WSDL:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览以下链接以查看WSDL：
- en: '[PRE52]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Run client from `LiveRestaurant_R-1.8-Client:`
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`LiveRestaurant_R-1.8-Client`运行客户端：
- en: '[PRE53]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following is the output when the server runs successfully:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器成功运行时，以下是输出：
- en: '[PRE54]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The steps of this recipe are the same as that of the recipe *Simplifying the
    creation of a Web-Service using MessageDispatcherServlet*, except the implementation
    of endpoint handling methods.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的步骤与*使用MessageDispatcherServlet简化创建Web服务*的配方相同，只是端点处理方法的实现。
- en: 'This annotation serves as a specialization of `@Component`, allowing for the
    implementation classes to be autodetected through classpath scanning, which is
    configured in the server application context file `(spring-ws-servlet.xml)`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释作为`@Component`的特化，允许通过类路径扫描自动检测实现类，这在服务器应用程序上下文文件（`spring-ws-servlet.xml`）中进行了配置：
- en: '[PRE55]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`OrderEndpoint` is the `endPoint` of this recipe and the `@Endpoint` annotation
    is also the same as `@service`, allowing for the implementation classes to be
    autodetected through classpath scanning. A request with the root element `placeOrderRequest`
    `(localPart = "placeOrderRequest")` and the namespace `http://www.packtpub.com/liverestaurant/OrderService/schema`
    will be forwarded to call the corresponding method `(handlePlaceOrderRequest)`.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderEndpoint`是本配方的`endPoint`，`@Endpoint`注释也与`@service`相同，允许通过类路径扫描自动检测实现类。具有根元素`placeOrderRequest`（`localPart
    = "placeOrderRequest"`）和命名空间`http://www.packtpub.com/liverestaurant/OrderService/schema`的请求将被转发到调用相应的方法（`handlePlaceOrderRequest`）。'
- en: '[PRE56]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Other details about annotations and how the request will be mapped to an endpoint
    method are contained in this chapter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 有关注释和请求如何映射到端点方法的其他详细信息包含在本章中。
- en: The following setting in the `spring-ws-servlet.xml` file causes the application
    to automatically generate the WSDL file from the data contract `(orderService.xsd)`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-ws-servlet.xml`文件中的以下设置会导致应用程序从数据合同（`orderService.xsd`）自动生成WSDL文件。'
- en: '[PRE57]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Even though WSDL can be generated automatically from the data contract (XSD),
    Spring-WS recommends avoiding autogeneration of WSDL for these reasons:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管WSDL可以从数据合同（XSD）自动生成，但Spring-WS建议出于以下原因避免自动生成WSDL：
- en: To keep consistency between releases (there might be slight differences among
    autogenerated WSDLs for different versions)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保持发布之间的一致性（自动生成的不同版本的WSDL可能会有轻微差异）
- en: Autogeneration of WSDL is slow, although once generated, WSDL will be cached
    and used later.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WSDL的自动生成速度较慢，尽管一旦生成，WSDL将被缓存并在以后使用。
- en: Therefore, Spring-WS recommends, while developing, autogenerate WSDL once via
    the browser and save it and use static WSDL to expose the service contract.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Spring-WS建议在开发时通过浏览器自动生成WSDL一次并保存，并使用静态WSDL来公开服务合同。
- en: See also
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipes *Setting up an endpoint by annotating the payload-root, Simplifying
    the creation of a Web-Service using MessageDispatcherServlet*, discussed in this
    chapter and the *Creating a Web-Service client on HTTP transport* recipe, discussed
    in [Chapter 2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*Building
    Clients forSOAP Web-Services.*
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的配方*通过注释有效载荷根设置端点，简化使用MessageDispatcherServlet创建Web服务*，以及[第2章](ch02.html
    "第2章。为SOAP Web服务构建客户端")中讨论的*为SOAP Web服务构建客户端*配方。
- en: Also see the recipes discussed in [Chapter 10](ch10.html "Chapter 10. Spring
    Remoting"), *Spring Remoting*, to find out how to set up contract-last Web-Services.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以查看[第10章](ch10.html "第10章。Spring远程调用")中讨论的配方*Spring远程调用*，了解如何设置基于契约的Web服务。
- en: Setting up a simple endpoint mapping for the Web-Service
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Web服务设置简单的端点映射
- en: This recipe demonstrates a very simple endpoint mapping that maps a Web-Service
    request to a Java class method.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方演示了一个非常简单的端点映射，将Web服务请求映射到Java类方法。
- en: Getting ready
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.9`, with the following
    Maven dependencies:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，项目名称为`LiveRestaurant_R-1.9`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`log4j-12.9.jar`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-12.9.jar`'
- en: How to do it...
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The steps of this recipe are the same as that of the previous recipe, *Setting
    up a contract-first Web-Service*, except that the registration of the endpoint,
    that is, method endpoint mapping and is configured in `spring-ws-servlet.xml`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的步骤与前一个配方*设置基于契约的Web服务*相同，只是端点的注册，即方法端点映射，并在`spring-ws-servlet.xml`中进行配置。
- en: Define an endpoint `(OrderSeviceMethodEndpoint)` based on the method mapping
    standard `(SimpleMethodEndpointMapping)`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于方法映射标准（`SimpleMethodEndpointMapping`）定义端点（`OrderSeviceMethodEndpoint`）。
- en: Configure the method endpoint mapping in `spring-ws-servlet.xml`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`spring-ws-servlet.xml`中配置方法端点映射。
- en: 'Run the `mvn clean package tomcat:run` command and browse to see the WSDL:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`mvn clean package tomcat:run`命令并浏览以查看WSDL：
- en: '[PRE58]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To test, open a new command window, go to `Liverestaurant_R-1.9-Client`, and
    run the following command:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试，打开一个新的命令窗口，转到`Liverestaurant_R-1.9-Client`，并运行以下命令：
- en: '[PRE59]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here is the server-side output:'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是服务器端的输出：
- en: '[PRE60]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`SimpleMethodEndpointMapping` maps from the local name of the request payload
    `(placeOrderRequest)` to the methods of the POJO classes. Here is a sample of
    the request payload (note the local name of the request payload):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleMethodEndpointMapping`从请求有效负载的本地名称（`placeOrderRequest`）映射到POJO类的方法。以下是请求有效负载的示例（请注意请求有效负载的本地名称）：'
- en: '[PRE61]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The endpoint bean is registered using the `endpoints` property. This property
    tells you that there should be a method in the `endpoint` class `(OrderServiceEndpoint)`
    with a name that starts with `methodPrefix(handle)` and ends with the request
    payload local name `(placeOrderRequest)`. This increases the flexibility of the
    endpoint naming by using the configuration in `spring-ws-servlet.xml:`
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 端点bean是使用`endpoints`属性注册的。该属性告诉您`endpoint`类（`OrderServiceEndpoint`）中应该有一个以`methodPrefix(handle)`开头并以请求有效负载本地名称（`placeOrderRequest`）结尾的方法。这通过在`spring-ws-servlet.xml`中使用配置增加了端点命名的灵活性：
- en: '[PRE62]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The endpoint method name should match the `handle+request` message root name
    `(handleplaceOrderRequest)`. In the body of the method, we should process the
    request and finally return the response in the form of `javax.xml.transform.Source:`
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 端点方法名称应与`handle+request`消息根名称匹配（`handleplaceOrderRequest`）。在方法的主体中，我们应该处理请求，并最终以`javax.xml.transform.Source`的形式返回响应：
- en: '[PRE63]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: See also
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipes *Setting up a transport-neutral WS-Addressing endpoint* and *Setting
    up an endpoint by annotating the payload-root*, discussed in this chapter.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的食谱*设置一个与传输无关的WS-Addressing端点*和*通过注释payload-root设置端点*。
- en: Setting up an endpoint by annotating the payload-root
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过注释payload-root设置端点
- en: Spring-WS simplifies the creation of complex Web-Services further by its annotation
    features and reduces the code and configuration in XML.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Spring-WS通过其注解功能进一步简化了复杂Web服务的创建，并减少了XML中的代码和配置。
- en: Getting ready
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.10`, with the following
    Maven dependencies:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，项目的名称是`LiveRestaurant_R-1.10`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`log4j-12.9.jar`'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-12.9.jar`'
- en: How to do it...
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The steps of this recipe are the same as that of *Setting up a contract-first
    Web-Service* and here we want to describe the endpoint mapping using annotation
    in the `endpoint` class.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的步骤与*设置一个基于契约的Web服务*的步骤相同，这里我们想要描述在`endpoint`类中使用注解的端点映射。
- en: 'Run the following command:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE64]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Browse to the following link to see the WSDL:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览以下链接查看WSDL：
- en: '[PRE65]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To test, open a new command window, go to `LiveRestaurant-1.10-Client`, and
    run the following command:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试，打开一个新的命令窗口，转到`LiveRestaurant-1.10-Client`，并运行以下命令：
- en: '[PRE66]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here is the server-side output:'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是服务器端的输出：
- en: '[PRE67]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'By including component scan and annotation-driven settings in the Spring-WS
    configuration file `(spring-ws-servlet.xml)`, the Spring container will scan the
    entire package for endpoints, services, and dependencies to inject and autowire
    each other to build the Web-Service blocks. You cannot see the adapters and other
    handlers here, since the container smartly picks the right/default adapter, dynamically
    (messageDispatcher runs support method of an adapter from a list of existing adapters
    for the endponit, and if support method returns `true`, that adapter is the right
    adapter):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Spring-WS配置文件（`spring-ws-servlet.xml`）中包含组件扫描和注解驱动的设置，Spring容器将扫描整个包以查找端点、服务和依赖项，以相互注入和自动装配构建Web服务块。您在这里看不到适配器和其他处理程序，因为容器会智能地选择正确/默认的适配器，动态地（messageDispatcher运行适配器的支持方法，从现有适配器列表中选择支持方法返回`true`的适配器）：
- en: '[PRE68]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `@Endpoint` annotation of `OrderSeviceAnnotationEndpoint` makes it an endpoint,
    with `PayloadRootAnnotationMethodEndpointMapping`, with the exact pointers to
    the method-endpoint mapping with the method-level annotations:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderSeviceAnnotationEndpoint`的`@Endpoint`注解使其成为一个端点，具有`PayloadRootAnnotationMethodEndpointMapping`，具有指向方法级别注解的方法端点映射：'
- en: '[PRE69]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`@PayloadRoot` helps the `MessageDispatcher` to map the request to the method,
    with the help of an argument annotation, `@RequestPayload`, which specifies the
    exact message payload part of the entire SOAP message as an argument into the
    method (it finds the method by root element of a request equal to `localPart`,
    for example, `placeOrderRequest` or `placeCancelRequest). @RequestPayload` tells
    the container that the argument `RequestPayload` is to be extracted from the SOAP
    message and injected to the method as an argument at runtime.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PayloadRoot`帮助`MessageDispatcher`将请求映射到方法，借助参数注释`@RequestPayload`的帮助，该注释指定整个SOAP消息的确切消息有效负载部分作为方法的参数（它通过请求的根元素等于`localPart`来找到方法，例如，`placeOrderRequest`或`placeCancelRequest）。`@RequestPayload`告诉容器，要从SOAP消息中提取参数`RequestPayload`并在运行时注入到方法中作为参数。'
- en: The return type annotation, `@ResponsePayload`, instructs `MessageDispatcher`
    that the instance of `javax.xml.transform.Source` is `ResponsePayload`. The smart
    Spring-WS framework detects the type of these objects at runtime and delegates
    to the appropriate `PayloadMethodProcessor`. In this case, it is `SourcePayloadMethodProcessor`,
    since the input argument and the return value are of the type `javax.xml.transform.Source`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型注释`@ResponsePayload`指示`MessageDispatcher`，`javax.xml.transform.Source`的实例是`ResponsePayload`。聪明的Spring-WS框架在运行时检测这些对象的类型，并委托给适当的`PayloadMethodProcessor`。在这种情况下，它是`SourcePayloadMethodProcessor`，因为输入参数和返回值的类型都是`javax.xml.transform.Source`。
- en: See also
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipes *Setting up a transport-neutral WS-Addressing endpoint* and *Setting
    up a simple endpoint mapping for the Web-Service*, discussed in this chapter.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的食谱*设置一个与传输无关的WS-Addressing端点*和*为Web服务设置一个简单的端点映射*。
- en: Setting up a transport-neutral WS-Addressing endpoint
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个与传输无关的WS-Addressing端点
- en: Using HTTP transport information inside the XML messages for routing messages
    to endpoints mixes data and operation together, and these messages will be replied
    to for the requested client.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML消息中使用HTTP传输信息来路由消息到端点，将数据和操作混合在一起，这些消息将被回复给请求的客户端。
- en: WS-Addressing standardizes routing mechanism by separating routing data and
    including it inside the SOAP headers. WS-Addressing may use its own metadata instead
    of using HTTP transport data for endpoint routing. In addition, a request from
    a client may return to a different client in WS-Addressing. For example, considering
    the following request from a client, the client side can set `ReplyTo` to its
    own address and `FaultTo` to admin the endpoint address. Then, the server will
    send successful messages to the client and fault messages to the admin address
    `[<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: WS-Addressing通过将路由数据与SOAP头部中的数据分离并包含在其中来标准化路由机制。WS-Addressing可能使用自己的元数据，而不是使用HTTP传输数据进行端点路由。此外，来自客户端的请求可能会返回到WS-Addressing中的不同客户端。例如，考虑来自客户端的以下请求，客户端可以将`ReplyTo`设置为自己的地址，将`FaultTo`设置为管理员端点地址。然后，服务器将成功消息发送到客户端，将故障消息发送到管理员地址`[<SOAP-ENV:Envelope
    xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">`。
- en: '[PRE70]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this recipe, we will set up a Spring-WS using WS-Addressing.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用WS-Addressing设置Spring-WS。
- en: Getting ready
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.11` with the following
    Maven dependencies:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，项目的名称是`LiveRestaurant_R-1.11`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`log4j-12.9.jar`'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-12.9.jar`'
- en: How to do it...
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: The steps of this recipe are the same as that of *Setting up an endpoint by
    annotating the payload-root*, except for the endpoint class. So, follow the steps
    of the mentioned recipe and define a new endpoint with WS-Addressing standards.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的步骤与*通过注释负载根设置端点*的步骤相同，只是端点类不同。因此，请按照上述配方的步骤，并使用WS-Addressing标准定义一个新的端点。
- en: 'Run the following command:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE71]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To test, open a new command window to `Liverestaurant_R-1.11-Client` and run
    the following command:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行测试，打开一个新的命令窗口到`Liverestaurant_R-1.11-Client`，并运行以下命令：
- en: '[PRE72]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following is the server-side output:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是服务器端的输出：
- en: '[PRE73]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Same as the previous recipe, *Setting up an endpoint by annotating the payload-root*,
    the incoming WS-Addressing SOAP messages will be forwarded to the endpoint `(OrderEndpoint`,
    which is autodetected by `@Endpoint)`. As you can see from the output, a header
    is added to the SOAP envelop that WS-Addressing uses for mapping and dispatching
    purposes of the endpoint method.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个配方*通过注释负载根设置端点*相同，传入的WS-Addressing SOAP消息将被转发到端点`(OrderEndpoint)`，该端点由`@Endpoint`自动检测到。从输出中可以看出，头部被添加到SOAP信封中，WS-Addressing用于端点方法的映射和调度目的。
- en: '[PRE74]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this recipe, the server applies `AnnotationActionEndpointMapping`, which
    uses `@Action` (http://www.packtpub.com/OrderService/OrdReq). `@Action` is similar
    to `@PayloadRoot` for recognizing the handling methods `(handleOrderRequest)`
    in the endpoint `(OrderEndpoint)` .
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，服务器应用了`AnnotationActionEndpointMapping`，它使用`@Action`（http://www.packtpub.com/OrderService/OrdReq）。`@Action`类似于`@PayloadRoot`，用于识别端点`(OrderEndpoint)`中的处理方法`(handleOrderRequest)`。
- en: '[PRE75]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: See also
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipe *Creating Web-Service client for WS-Addressing endpoint*, discussed
    in [Chapter 2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),
    *Building Clients for SOAP Web-Services*, and the recipe *Setting up an endpoint
    by annotating the payload root*, discussed in this chapter.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。构建SOAP Web服务的客户端")中讨论的配方*为WS-Addressing端点创建Web服务客户端*，*构建SOAP
    Web服务的客户端*，以及在本章中讨论的配方*通过注释负载根设置端点*。
- en: Setting up an endpoint using an XPath expression
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XPath表达式设置端点
- en: 'Spring-WS allows us to extract the passed parameters in the `endpoint` method''s
    signature using annotations with the XPath expressions. For example, in the `endpoint`
    method''s `handleOrderRequest` (@RequestPayload `Source source)`, if you want
    to find the value of any element in the source object, you have to use Java API
    to extract the value. You can eliminate using Java API in the handler method by
    using XPath in the method''s signature to extract the data from the incoming XML
    data, as shown as follows: `handleOrderRequest(@XPathParam("/OrderRequest/message")
    String message)`.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Spring-WS允许我们使用XPath表达式和注释从`端点`方法的签名中提取传递的参数。例如，在`端点`方法的`handleOrderRequest`（@RequestPayload
    `Source source`）中，如果要查找源对象中任何元素的值，必须使用Java API来提取该值。您可以通过在方法的签名中使用XPath来从传入的XML数据中提取数据来消除在处理程序方法中使用Java
    API，如下所示：`handleOrderRequest(@XPathParam("/OrderRequest/message") String message)`。
- en: This recipe illustrates the usage of XPath expressions in endpoint mapping with
    the help of annotation.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方演示了使用注释在端点映射中使用XPath表达式。
- en: Getting ready
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.12` with the following
    Maven dependencies:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，项目的名称是`LiveRestaurant_R-1.12`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`log4j-12.9.jar`'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-12.9.jar`'
- en: How to do it...
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: The steps of this recipe are the same as that of *Setting up an endpoint by
    annotating the payload-root*, except for the implementation of endpoint handling
    methods. So, follow the steps of the mentioned recipe and use XPath expressions
    to extract data from incoming message and create a response.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的步骤与*通过注释负载根设置端点*的步骤相同，只是端点处理方法的实现不同。因此，请按照上述配方的步骤，并使用XPath表达式从传入消息中提取数据并创建响应。
- en: Run the following command from `LiveRestaurant_R-1.12:`
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`LiveRestaurant_R-1.12`运行以下命令：
- en: '[PRE76]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Browse to the following link to see the Web-Service service contract:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览以下链接以查看Web服务服务合同：
- en: '[PRE77]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To test, open a new command window, go to `LiveRestaurant_R-1.12-Client`, and
    run the following command:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行测试，请打开一个新的命令窗口，转到`LiveRestaurant_R-1.12-Client`，并运行以下命令：
- en: '[PRE78]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following is the server-side output:'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是服务器端的输出：
- en: '[PRE79]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How it works...
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Passing the method parameter is the same as the recipe *Setting up an endpoint
    by annotating the payload-root*, except that it uses `@XPathParam`, which specifies
    the path of the data in a message that is to be passed as an argument into the
    method. Here `XpathParamMethodArgumentResolver` is responsible for extracting
    the value from the message and passing it to the method.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 传递方法参数与通过注释有效负载根设置端点的方法相同，只是它使用了`@XPathParam`，它指定了消息中要作为参数传递给方法的数据的路径。在这里，`XpathParamMethodArgumentResolver`负责从消息中提取值并将其传递给方法。
- en: The annotation `XpathParam` helps the `MethodArgumentResolvers (XpathParamMethodArgumentResolver)`
    to extract information out of the XML and binds a node value to a method argument
    (using `// cause`, the whole message is searched recursively, for example, `//lName`
    searches the whole `placeRequestRequest` message). The same implementation is
    used for the method `cancelOrderRequest:`
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 注释`XpathParam`帮助`MethodArgumentResolvers（XpathParamMethodArgumentResolver）`从XML中提取信息并将节点值绑定到方法参数（使用`//
    cause`，整个消息被递归搜索，例如，`//lName`搜索整个`placeRequestRequest`消息）。相同的实现也用于方法`cancelOrderRequest：`
- en: '[PRE80]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The method argument can be any of the following:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数可以是以下任何一种：
- en: '`boolean` or `Boolean`'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`或`Boolean`'
- en: '`double` or `Double`'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`或`Double`'
- en: '`String`'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`'
- en: '`Node`'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node`'
- en: '`NodeList`'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NodeList`'
- en: See also
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipe *Setting up an endpoint by annotating the payload-root*, discussed
    in this chapter.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了通过注释有效负载根来设置端点的方法。
- en: Handling the incoming XML messages using DOM
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DOM处理传入的XML消息
- en: The implementation of the endpoint requires us to get the incoming XML messages
    and extract its data. In Java, there are various methods `(W3C DOM, SAX, XPath,
    JAXB, Castor, XMLBeans, JiBX`, or `XStream)` for extracting data from an input
    XML message, but most of them are not language-neutral.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 端点的实现要求我们获取传入的XML消息并提取其数据。在Java中，有各种方法（W3C DOM、SAX、XPath、JAXB、Castor、XMLBeans、JiBX或XStream）用于从输入的XML消息中提取数据，但大多数方法都不是语言中立的。
- en: DOM was created to be language-neutral and initially used for JavaScript manipulation
    of HTML pages. In Java, W3C DOM library is provided to interact with XML data.
    Classes, such as `org.w3c.dom.Document, org.w3c.dom.Element, org.w3c.dom.Node`,
    and `org.w3c.dom.Text` from W3C DOM library, are for extracting data from an input
    XML message.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: DOM是为了语言中立而创建的，最初用于JavaScript操作HTML页面。在Java中，W3C DOM库用于与XML数据交互。来自W3C DOM库的类，例如`org.w3c.dom.Document、org.w3c.dom.Element、org.w3c.dom.Node`和`org.w3c.dom.Text`，用于从输入的XML消息中提取数据。
- en: In this recipe, W3C DOM is used to extract the data from incoming messages.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，W3C DOM用于从传入的消息中提取数据。
- en: Getting ready
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.13`, with the following
    Maven dependencies:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，项目的名称是`LiveRestaurant_R-1.13`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`log4j-1.2.9.jar`'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-1.2.9.jar`'
- en: How to do it...
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The steps of this recipe are the same as that of the recipe *Setting up an endpoint
    by annotating the payload-root*, except for the implementation of the endpoint-handling
    methods. So, follow the steps of the mentioned recipe and use DOM to extract data
    from the incoming message and create the response.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的步骤与通过注释有效负载根设置端点的配方相同，只是端点处理方法的实现不同。因此，按照所述的配方的步骤，并使用DOM从传入的消息中提取数据并创建响应。
- en: 'Run the command `mvn clean package tomcat:run` and browse to the following
    link:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令`mvn clean package tomcat:run`并浏览到以下链接：
- en: '[PRE81]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To test, open a new command window and run the following command:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试，打开一个新的命令窗口并运行以下命令：
- en: '[PRE82]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The following is the server-side output:'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是服务器端的输出：
- en: '[PRE83]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works...
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Passing the method parameter is the same as the recipe *Setting up an endpoint
    by annotating the payload-root*, except that we use `@RequestPayload`, which specifies
    the DOM element of data in a message to be passed as an argument into the method.
    Here, `DomPayloadMethodProcessor` is responsible for extracting the value from
    the message and passing it to the method. Since the return type which is specified
    by `@ResponsePayload` is also a DOM element type, `DomPayloadMethodProcessor`
    is being used as return handler.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 传递方法参数与通过注释有效负载根设置端点的方法相同，只是我们使用了`@RequestPayload`，它指定了消息中要作为参数传递给方法的DOM元素数据。在这里，`DomPayloadMethodProcessor`负责从消息中提取值并将其传递给方法。由于返回类型也是由`@ResponsePayload`指定的DOM元素类型，因此`DomPayloadMethodProcessor`被用作返回处理程序。
- en: The `@PayloadRoot` annotation informs Spring-WS that the `handleCancelOrderRequest`
    method is a handling method for XML messages. The sort of message that this method
    can handle is indicated by the annotation values (the `@RequestPayload` element
    tells it is of the DOM element type). In this case, it can handle XML elements
    that have the `placeOrderRequest` local part and the `http://www.packtpub.com/liverestaurant/OrderService/schema`
    namespace.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`@PayloadRoot`注释告诉Spring-WS`handleCancelOrderRequest`方法是XML消息的处理方法。此方法可以处理的消息类型由注释值指示（`@RequestPayload`元素告诉它是DOM元素类型）。在这种情况下，它可以处理具有`placeOrderRequest`本地部分和`http://www.packtpub.com/liverestaurant/OrderService/schema`命名空间的XML元素。'
- en: '[PRE84]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The preceding code extracts the elements `refNumber, fName`, and `lName` from
    the incoming XML message `(placeOrderRequest)` via the method `getElementsByTagNameNS`.
    Then, it finds and returns the text content of the first item in the `refNumber,
    fName`, and `lName` elements (by `item(0).getTextContent())`.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从传入的XML消息（placeOrderRequest）中提取元素`refNumber、fName`和`lName`，通过方法`getElementsByTagNameNS`找到并返回`refNumber、fName`和`lName`元素中第一项的文本内容（通过`item(0).getTextContent()`）。
- en: 'The following part of the code creates an outgoing XML message by creating
    the `placeOrderResponse` element (using `document.createElementNS)`. Then, it
    creates the child element `refNumber` (using `document.createElementNS)` and creates
    the text of this element (using `createTextNode and appendChild)`. Then, it appends
    the `refNumber` element to the response element `placeOrderResponse` (using the
    `appendChild` method):'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的以下部分通过创建`placeOrderResponse`元素（使用`document.createElementNS)来创建传出的XML消息）。然后，它创建子元素`refNumber`（使用`document.createElementNS)`并创建此元素的文本（使用`createTextNode和appendChild)。然后，它将`refNumber`元素附加到响应元素`placeOrderResponse`（使用`appendChild`方法）：
- en: '[PRE85]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: See also
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipe *Setting up an endpoint by annotating the payload-root*, discussed
    in this chapter and the recipe *Creating a Web-Service client on HTTP transport*,
    discussed in [Chapter 2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*Building
    Clients for SOAP Web-Services.*
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章讨论的配方*通过注释有效负载根设置端点*和在[第2章](ch02.html "第2章。构建SOAP Web服务的客户端")中讨论的配方*在HTTP传输上创建Web服务客户端*，*构建SOAP
    Web服务的客户端*。
- en: Handling the incoming XML messages using JDOM
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JDOM处理传入的XML消息
- en: Implementation of endpoints requires us to get the incoming XML messages and
    extract its data. DOM can fetch the data from an XML document, but it is slow
    and memory consuming and has very basic features.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 端点的实现要求我们获取传入的XML消息并提取其数据。DOM可以从XML文档中提取数据，但它速度慢，消耗内存，并且具有非常基本的功能。
- en: JDOM document is not built into the memory; it is built on demand (lazy initialization
    design pattern). In addition, JDOM makes navigating through the document tree
    or manipulating the elements easier by providing a standard Java-based collection
    interface. In this recipe, JDOM is used to extract data from incoming messages.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: JDOM文档不会构建到内存中；它是按需构建的（延迟初始化设计模式）。此外，JDOM通过提供标准的基于Java的集合接口，使得在文档树中导航或操作元素更容易。在这个配方中，JDOM用于从传入的消息中提取数据。
- en: Getting ready
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.14`, with the following
    Maven dependencies:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，项目的名称是`LiveRestaurant_R-1.14`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`jdom-1.0.jar`'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdom-1.0.jar`'
- en: '`log4j-1.2.9.jar`'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-1.2.9.jar`'
- en: '`jaxen-1.1.jar`'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jaxen-1.1.jar`'
- en: '`xalan-2.7.0.jar`'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xalan-2.7.0.jar`'
- en: How to do it...
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The steps of this recipe are the same as that of the *Setting up an endpoint
    by annotating the payload-root* recipe, except for the implementation of the endpoint-handling
    methods. So, follow the steps of the aforementioned recipe, use JDOM to extract
    the data from incoming message, and create the response.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的步骤与*通过注释有效负载根设置端点*配方的步骤相同，只是端点处理方法的实现不同。因此，请按照前述配方的步骤，使用JDOM从传入消息中提取数据，并创建响应。
- en: 'Run the following command:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE86]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Browse to the following link:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览以下链接：
- en: '[PRE87]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'To test, open a new command window and run the following command:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试，打开一个新的命令窗口并运行以下命令：
- en: '[PRE88]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The following is the server-side output:'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是服务器端的输出：
- en: '[PRE89]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: How it works...
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It works in the same way as explained in the previous recipe, except that it
    uses `JDOM` in its method implementation.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与前面的配方中解释的方式相同，只是在其方法实现中使用了`JDOM`。
- en: 'The following part of the code extracts the values `refNumber, fName`, and
    `lName` from the incoming XML message `(placeOrderRequest)` by using namespace
    and XPath object:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的以下部分通过使用命名空间和XPath对象从传入的XML消息（placeOrderRequest）中提取值`refNumber, fName`和`lName`：
- en: '[PRE90]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The following part of the code creates an outgoing message by creating the
    `placeOrderResponse` element (using `new Element(...))`. Then, it creates the
    child element `refNumber` (using `new Element(...))` and creates the text of this
    element (using `setText(...))`. Then, it appends the message element to the response
    element `placeOrderResponse` (using the `addContent` method):'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的以下部分通过创建`placeOrderResponse`元素（使用`new Element(...))`）来创建传出消息。然后，它创建子元素`refNumber`（使用`new
    Element(...))`并创建此元素的文本（使用`setText(...))`。然后，它将消息元素附加到响应元素`placeOrderResponse`（使用`addContent`方法）：
- en: '[PRE91]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: See also
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipes *Setting up an endpoint by annotating the payload-root* and *Handling
    incoming XML Messages using DOM*, discussed in this chapter.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章讨论的配方*通过注释有效负载根设置端点*和*使用DOM处理传入的XML消息*。
- en: The recipe *Creating a Web-Service client on HTTP transport*, discussed in [Chapter
    2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*Building Clients
    for SOAP Web-Services.*
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。构建SOAP Web服务的客户端")中讨论的配方*在HTTP传输上创建Web服务客户端*，*构建SOAP Web服务的客户端*。
- en: Handling the incoming XML messages using JAXB2
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JAXB2处理传入的XML消息
- en: Java Architecture for XML Binding (JAXB) is a Java standard for Object-XML marshalling.
    JAXB defines a programmer API for reading and writing Java objects to / from XML
    documents. The object-XML mapping is generally annotated in classes. JAXB provides
    a set of useful annotations with the default values for most of them that make
    this marshalling an easy job.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: Java Architecture for XML Binding（JAXB）是用于对象-XML编组的Java标准。JAXB定义了一个用于从XML文档读取和写入Java对象的程序员API。对象-XML映射通常在类中进行注释。JAXB提供了一组有用的注释，其中大多数具有默认值，使得这种编组工作变得容易。
- en: This recipe demonstrates how to handle the incoming XML message in a Web-Service
    using JAXB in a very simple way. For simplicity and a continuation from the previous
    recipes, the same recipes are re-used with little improvements in converting the
    XML schema into domain classes to demonstrate the usage of JAXB.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方演示了如何以非常简单的方式使用JAXB处理Web服务中的传入XML消息。为了简单起见，并且延续之前的配方，相同的配方被重新使用，稍微改进了将XML模式转换为域类的方法，以演示JAXB的用法。
- en: Getting ready
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.15` and has the
    following Maven dependencies:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，项目的名称是`LiveRestaurant_R-1.15`，并且具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`log4j-1.2.9.jar`'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-1.2.9.jar`'
- en: How to do it...
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The steps of this recipe are the same as that of the recipe *Setting up an endpoint
    by annotating the payload-root*, except for the implementation of the endpoint
    handling methods. So, follow the steps of the aforementioned recipe and use JAXB
    Marshaller/Un-Mashaller to convert payload into/from POJO.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的步骤与食谱*通过注释payload-root设置端点*的步骤相同，只是端点处理方法的实现不同。因此，按照前述食谱的步骤，并使用JAXB Marshaller/Un-Mashaller将有效载荷转换为POJO。
- en: First, we define a set of domain objects we need to marshal to/from XML from
    the data contract `OrderService.xsd` (refer to the recipe *Marshalling with JAXB2*,
    discussed in [Chapter 6](ch06.html "Chapter 6. Marshalling and Object-XML Mapping
    (OXM)"),
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一组领域对象，我们需要从数据合同`OrderService.xsd`（参考食谱*使用JAXB2进行编组*）中编组到XML/从XML中编组（参见[第6章](ch06.html
    "第6章。编组和对象-XML映射（OXM）")）。
- en: Change the implementation of the endpoint `(OrderEndpoint)` to use JAXB.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改端点的实现`(OrderEndpoint)`以使用JAXB。
- en: 'Run the following command:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE92]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Browse to the following link:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览以下链接：
- en: '[PRE93]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'To test, open a new command window to `Liverestaurant_R-1.15-Client` and run
    the following command:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试，打开一个新的命令窗口到`Liverestaurant_R-1.15-Client`并运行以下命令：
- en: '[PRE94]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The following is the server-side output:'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是服务器端的输出：
- en: '[PRE95]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: How it works...
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding code, the XML is bound with Java classes at runtime using
    `JAXB`. The incoming XML is converted into Java objects (unmarshalling) and after
    processing the objects, the resultant objects are marshalled back to XML before
    returning to the caller:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，XML在运行时与Java类绑定使用`JAXB`。传入的XML被转换为Java对象（解组）并在处理对象后，结果对象被编组回XML然后返回给调用者：
- en: '[PRE96]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `JAXB` context binds the Java classes passed via the constructor with the
    incoming XML, with the help of annotations in the classes at runtime, which instructs
    the unmarshaller to instantiate and load data from the XML tags into the objects.
    The objects are now passed to the service classes `(OrderServiceImpl)` for processing:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`JAXB`上下文通过构造函数传递的Java类与类中的注释绑定，指示解组器在运行时将数据从XML标记实例化和加载到对象中。现在将对象传递给服务类`(OrderServiceImpl)`进行处理：'
- en: '[PRE97]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This approach allows the developer to work with Java objects instead of XML
    code with simple marshalling technology.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许开发人员使用简单的编组技术与Java对象而不是XML代码一起工作。
- en: See also
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipe *Setting up an endpoint by annotating the payload-root*, discussed
    in this chapter.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中讨论的食谱*通过注释payload-root设置端点*。
- en: The recipe *Marshalling with JAXB2*, discussed in [Chapter 6](ch06.html "Chapter 6. Marshalling
    and Object-XML Mapping (OXM)"),*Marshalling and Object-XMLMapping (OXM) — Converting
    POJO to/from XML messages using Marshallers andUn-Marshallers.*
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。编组和对象-XML映射（OXM）")中讨论的食谱*使用JAXB2进行编组*，*编组和对象-XML映射（OXM）-使用编组器和解组器将POJO转换为XML消息/从XML消息转换为POJO*。
- en: Validating the XML messages at the server side using an interceptor
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用拦截器在服务器端验证XML消息
- en: Data contract is a basic concept used to set up a Spring-WS. However, validation
    is a basic requirement before a SOAP message sends/replies on the server side/client
    side.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 数据合同是在设置Spring-WS时使用的基本概念。然而，在服务器端/客户端发送/回复SOAP消息之前，验证是一个基本要求。
- en: Spring-WS supports validation of messages on the server side as well as the
    client side. In this recipe, server-side validation is applied and when the incorrect
    request comes to the server or the incorrect response replays from the server
    to the client, it throws an exception.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: Spring-WS支持服务器端和客户端消息的验证。在这个食谱中，应用了服务器端验证，当不正确的请求到达服务器或不正确的响应从服务器发送到客户端时，它会抛出异常。
- en: Getting ready
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: 'In this recipe, the project''s name is `LiveRestaurant_R-1.16` with the following
    Maven dependencies:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，项目的名称是`LiveRestaurant_R-1.16`，具有以下Maven依赖项：
- en: '`spring-ws-core-2.0.1.RELEASE.jar`'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-ws-core-2.0.1.RELEASE.jar`'
- en: '`log4j-1.2.9.jar`'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log4j-1.2.9.jar`'
- en: How to do it...
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The steps of this recipe are the same as that of *Handling the incoming XML
    messages using DOM*, except for the validation of request/response message.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的步骤与*使用DOM处理传入的XML消息*的步骤相同，只是验证请求/响应消息的验证不同。
- en: Modify `spring-ws-servlet.xml` to include `PayloadValidatingInterceptor`.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`spring-ws-servlet.xml`以包括`PayloadValidatingInterceptor`。
- en: 'Run the following command:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE98]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Browse to the following link:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览以下链接：
- en: '[PRE99]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'To test, open a new command window to `Liverestaurant_R-1.16-Client` and run
    the following command:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试，打开一个新的命令窗口到`Liverestaurant_R-1.16-Client`并运行以下命令：
- en: '[PRE100]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The following is the server-side output:'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是服务器端的输出：
- en: '[PRE101]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: How it works...
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`spring-ws-servlet.xml` is almost the same, as described in the recipe *Handling
    the incoming XML messages using DOM*, except that it includes the interceptor
    that uses schema for validation, `validateRequest`, and `validateResponse`.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring-ws-servlet.xml`几乎与食谱*使用DOM处理传入的XML消息*中描述的相同，只是包括使用模式进行验证的拦截器`validateRequest`和`validateResponse`。'
- en: '[PRE102]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When running the client, two requests will be sent to the server. The first
    one will be processed and the response will be sent back to the client, while
    the second one contains the wrong element (address instead of `addressPrimary)`
    that will send the faulty response back:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行客户端时，将向服务器发送两个请求。第一个将被处理并将响应发送回客户端，而第二个包含错误的元素（地址而不是`addressPrimary`），将发送错误的响应：
- en: '[PRE103]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: See also
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipe *Setting up an endpoint by annotating the payload-root*, discussed
    in this chapter.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中讨论的食谱*通过注释payload-root设置端点*。
- en: The recipe *Creating a Web-Service client on HTTP transport*, discussed in [Chapter
    2](ch02.html "Chapter 2. Building Clients for SOAP Web-Services"),*BuildingClients
    for SOAP Web-Services.*
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。为SOAP Web服务构建客户端")中讨论的食谱*在HTTP传输上创建Web服务客户端*。
