- en: Configuring Storage for Your Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的应用程序配置存储
- en: In this chapter, we will start by learning the theoretical basis of OpenShift
    storage configuration. Later, we will show you how to deploy a database in the
    cloud and configure your cloud applications to use it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先学习 OpenShift 存储配置的理论基础。稍后，我们将向您展示如何在云端部署数据库以及如何配置您的云应用程序以使用它。
- en: In the last section of the preceding chapter, we deployed the simple version
    of `CatalogService` in the cloud, using OpenShift. We also got an initial feeling
    for the web console and OpenShift `cli`. Now, it is time to go further. We will
    reconfigure our application to use the database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的最后部分，我们使用 OpenShift 在云端部署了 `CatalogService` 的简单版本。我们还对 Web 控制台和 OpenShift
    `cli` 有了一个初步的了解。现在，是时候更进一步了。我们将重新配置我们的应用程序以使用数据库。
- en: Before doing that, we will cover OpenShift persistence storage concepts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在做那之前，我们将介绍 OpenShift 持久化存储的概念。
- en: OpenShift storage concepts
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift 存储概念
- en: In the previous chapter, we hinted a the volume concept—the tool that is used
    by OpenShift to implement storage. Let's start by looking at it more thoroughly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到了卷的概念——OpenShift 用于实现存储的工具。让我们先更深入地了解一下它。
- en: Volumes
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷
- en: As we mentioned in the preceding chapter, OpenShift's unit of deployment and
    scaling is a pod, which can contain many containers. The containers in the pod
    are ephemeral—they can be stopped and started at any moment by Kubernetes. The
    data stored in the container will be lost when the container goes down because
    during the restart the fresh container is recreated from the image.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中提到的，OpenShift 的部署和扩展单元是 Pod，它可以包含许多容器。Pod 中的容器是短暂的——Kubernetes 可以在任何时候停止和启动它们。当容器关闭时，容器中的数据将会丢失，因为在重启过程中，新的容器是从镜像中重新创建的。
- en: As a result, we will need another tool to implement the storage. Such a tool
    is the volume.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要另一个工具来实现存储。这个工具就是卷。
- en: So, what is a volume? From the technical point of view, volumes are basically
    directories on the node that runs the pod, which are mapped into the container
    filesystem. Also, volumes have an explicitly defined life cycle, which equals
    the pod life cycle. Whenever the pod is stopped, the volume is destroyed. On the
    other hand, when the containers inside the pod are restarted, the volume is unchanged;
    it just has to be remounted inside the container.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是卷呢？从技术角度来看，卷基本上是运行 Pod 的节点上的目录，这些目录映射到容器文件系统中。此外，卷有一个明确定义的生命周期，与 Pod 生命周期相等。每当
    Pod 停止时，卷就会被销毁。另一方面，当 Pod 内的容器重启时，卷保持不变；它只需在容器内重新挂载即可。
- en: Linux directory can also be a link to another directory or remote filesystem,
    such as **Network File System** (**NFS**). As a result, removing the directory
    when the pod is stopped doesn't necessarily mean removing all the pieces of data.
    As a result, the way in which a volume behaves depends on its type—we will describe
    it in the next section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 目录也可以是另一个目录或远程文件系统的链接，例如 **网络文件系统**（**NFS**）。因此，当 Pod 停止时删除目录并不一定意味着删除所有数据。因此，卷的行为方式取决于其类型——我们将在下一节中描述它。
- en: OpenShift allows you to configure a number of volume types. Let's look at the
    most common of them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 允许你配置多种卷类型。让我们来看看其中最常见的一些。
- en: Empty directory
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空目录
- en: Empty directory is, as its name suggests, an empty directory created in the
    node's filesystem. The directory is created when the pod is instantiated and is
    present as long as the pod runs on that node. When the pod is removed from the
    node for any reason, the directory is deleted.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 空目录，正如其名所示，是在节点的文件系统中创建的一个空目录。当 Pod 实例化时创建该目录，并且只要 Pod 在该节点上运行，目录就存在。当 Pod 因任何原因从节点上移除时，目录将被删除。
- en: The empty directory can be mounted inside any of the containers running inside
    the pod. An example usage for this kind of pod may be a directory shared between
    the containers that are used to gather common data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 空目录可以挂载在 Pod 内运行的任何容器中。这种 Pod 的一个示例用途可能是用于收集公共数据的容器之间的共享目录。
- en: As we mentioned in the *Volumes* section, restarting any of the containers does
    not result in the deletion of the directory. The directory will be present till
    the pod exists and will be remounted inside a container that has a dependency
    on it after the container restart.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *卷* 部分中提到的，重新启动任何容器都不会导致目录的删除。目录将一直存在，直到 Pod 存在，并在容器重启后重新挂载到依赖于它的容器中。
- en: Host path
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机路径
- en: Host path is another type of persistent volume, which mounts the directory from
    the node's filesystem. In contrast to the empty directory, this kind of persistent
    volume does not create or destroy any new directories. For example, when a container
    needs access to some part of a configuration of the host, an administrator can
    mount the directory with this configuration inside the container filesystem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 主机路径是另一种持久卷类型，它从节点的文件系统中挂载目录。与空目录不同，这种持久卷不会创建或销毁任何新的目录。例如，当容器需要访问主机配置的某些部分时，管理员可以将包含此配置的目录挂载到容器文件系统中。
- en: Remote filesystems
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程文件系统
- en: As we hinted previously, a volume's directory doesn't have to point to the local
    filesystem. It can also point to remote filesystem directories. It is here that
    interesting stuff starts to happen. Let's look at it closer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所暗示的，卷的目录不必指向本地文件系统。它也可以指向远程文件系统目录。从这里开始，有趣的事情开始发生。让我们更仔细地看看。
- en: Quick recall here, when you use a remote filesystem, you have to create the
    storage on the server, export it, and then mount it on the client. On the client
    side, the mounting directory will be implemented as a remote filesystem client.
    As a result, operations on that directory will be propagated (using the given
    remote filesystem protocol) to the server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下，当你使用远程文件系统时，你必须在服务器上创建存储，导出它，然后将其挂载到客户端。在客户端，挂载目录将作为远程文件系统客户端实现。因此，对该目录的操作将通过给定的远程文件系统协议传播到服务器。
- en: OpenShift supports a number of remote filesystem protocols, for example, NFS,
    or Fiber Channel. Additionally, if you have knowledge of your cluster architecture,
    you can use proprietary remote filesystems, such as gcePersistentDisk (Google
    Cloud) or awsElasticBlockStore (Amazon Web Services).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift支持多种远程文件系统协议，例如NFS或光纤通道。此外，如果你了解你的集群架构，你可以使用专有远程文件系统，如gcePersistentDisk（Google
    Cloud）或awsElasticBlockStore（Amazon Web Services）。
- en: Given the knowledge that we have, let's analyze the behavior of remote filesystems
    with OpenShift. When the pod with a remote filesystem volume is started, OpenShift
    creates a client directory on the node and mounts it inside the appropriate containers,
    according to the configuration. As usual, when containers are stopped, nothing
    happens to the directory, and it is remounted again when a container is restarted.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们所拥有的知识，让我们分析OpenShift中远程文件系统的行为。当启动具有远程文件系统卷的pod时，OpenShift在节点上创建一个客户端目录，并根据配置将其挂载到适当的容器中。像往常一样，当容器停止时，目录不会受到影响，当容器重新启动时，它会被重新挂载。
- en: More interesting stuff happens when the pod is being removed or when the node
    crashes. In this scenario, the client directory is being deleted. Contrary to
    the empty directory scenario, this doesn't mean a loss of data. Deleting a client
    directory means that only one of the clients of the remote filesystem has been
    destroyed. The data inside the filesystem stays untouched.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当pod正在被删除或节点崩溃时，更有趣的事情发生了。在这种情况下，客户端目录正在被删除。与空目录场景相反，这并不意味着数据丢失。删除客户端目录意味着远程文件系统的一个客户端已被销毁。文件系统中的数据保持不变。
- en: As you can see, remote volumes enable us to create persistent storage, which
    can be mounted to our application. Also, the lifecycle is independent of the pods.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，远程卷使我们能够创建持久存储，可以将其挂载到我们的应用程序中。此外，其生命周期与pod独立。
- en: 'OK, we already know how volumes work and would gladly add them to our application.
    However, there is one problem, the configuration. The developer who would like
    to use one of those volumes has to have a lot of information on the cluster configuration:
    what kind of remote filesystem has been configured, or on which node it runs.
    More importantly, even if you gather such information from your administrator,
    you would need to ensure that it is configured correctly in each of your environments.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经知道了卷是如何工作的，并且很乐意将它们添加到我们的应用程序中。然而，有一个问题，那就是配置。希望使用这些卷之一的开发者必须对集群配置有大量信息：配置了哪种远程文件系统，或者它在哪个节点上运行。更重要的是，即使你从管理员那里收集了这些信息，你也需要确保它在你的每个环境中都配置正确。
- en: That's not good for a number of reasons. Firstly, we would like to decouple
    a developer from the cluster administrator. Ideally, the developer will specify
    the type of volume they need without needing to learn the details of the cluster
    configuration. Secondly, we emphasized in the preceding chapter the importance
    of a unified view of the cloud. Since this unified view is compromised now, you
    would have to reconfigure your pods for the testing environment to use NFS instead
    of Google disk. We clearly don't want that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很好，有多个原因。首先，我们希望将开发者与集群管理员解耦。理想情况下，开发者将指定他们需要的卷类型，而不需要了解集群配置的细节。其次，在前一章中，我们强调了统一云视图的重要性。由于这个统一视图现在受到了损害，您将不得不重新配置您的pods，以便在测试环境中使用NFS而不是Google磁盘。我们显然不希望这样。
- en: We need a tool that will solve those problems. Let's discuss **persistent volumes**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个工具来解决这些问题。让我们讨论**持久卷**。
- en: PersistentVolume and PersistentVolumeClaims
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久卷和持久卷声明
- en: Persistent volumes, similar to regular volumes, allow you to define different
    types of persistent storage. In fact, you can use persistent volumes to define
    storage types analogous to regular volumes, such as node directories or remote
    filesystems. Then, what is the difference?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 持久卷，类似于常规卷，允许您定义不同类型的持久存储。实际上，您可以使用持久卷来定义类似于常规卷的存储类型，例如节点目录或远程文件系统。那么，区别在哪里？
- en: 'Persistent volumes are Kubernetes objects, just as pods and services are objects.
    Their lifecycle is not related to any of the pods. In this context, we can think
    about persistent modules similar to the nodes—they are part of cluster infrastructure.
    Let''s take a look at the sample `PersistentVolume`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 持久卷是Kubernetes对象，就像pods和服务一样。它们的生命周期与任何pods无关。在这种情况下，我们可以将持久模块视为类似于节点——它们是集群基础设施的一部分。让我们看看以下示例`PersistentVolume`：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see in the preceding code, the `PersistentVolume` specifies the
    NFS server to which it is going to connect, in the same way as the volume. Compared
    to regular volume, it has a few additional fields: capacity, access mode, and
    metadata labels. You will learn in a moment why they are needed.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中看到的，`PersistentVolume`指定了它将要连接的NFS服务器，就像卷一样。与常规卷相比，它有几个额外的字段：容量、访问模式和元数据标签。您很快就会了解到为什么它们是必需的。
- en: In the end, we would like to have this persistent storage mounted to our containers.
    How can we achieve that? We can do so using `PersistentVolumeClaims`. The `PersistentVolumeClaim`
    is an object that specifies the characteristics of the `PersistentVolume` that
    we need.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望将这种持久存储挂载到我们的容器上。我们如何实现这一点？我们可以使用`PersistentVolumeClaims`。`PersistentVolumeClaim`是一个指定我们所需的`PersistentVolume`特性的对象。
- en: 'Let''s look at the example again:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看这个例子：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in the preceding code, the `PersistentModule` claim specifies
    the amount of storage we need and the access type. As usual, in OpenShift, you
    are also able to use the label mechanism to provide additional match characteristics.
    In our example, we use those to specify from which zone the `PersistentVolume`
    should be taken.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中看到的，`PersistentVolume`声明指定了我们需要的存储量以及访问类型。在OpenShift中，您还可以使用标签机制来提供额外的匹配特性。在我们的例子中，我们使用这些来指定`PersistentVolume`应从哪个区域获取。
- en: The `PersistentVolume` provides us with the capability of declaring persistent
    storage, which is a part of cluster infrastructure, and the `PersistentVolumeClaim`
    is a set of criteria that allows us to specify the `PersistentStorage` that we
    need.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersistentVolume`为我们提供了声明持久存储的能力，这是集群基础设施的一部分，而`PersistentVolumeClaim`是一组标准，允许我们指定所需的`PersistentStorage`。'
- en: However, how does the match process look and how does it actually relate to
    the pods that we are creating?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，匹配过程看起来如何，它实际上是如何与我们创建的pods相关的？
- en: The `PersistentVolumeClaim` technically is a kind of a volume, and, as a result,
    you can refer to the given `PersistentVolumeClaim` from within your pod configuration.
    When the pod with such a claim is started, the `PersistentStorage` objects available
    in the system are evaluated. If a matching `PersistentVolume` can be found, it
    is mounted inside the containers that depend on that claim.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，`PersistentVolumeClaim`是一种卷，因此，您可以在您的pods配置中引用给定的`PersistentVolumeClaim`。当具有这种声明的pods启动时，系统中的可用`PersistentStorage`对象将被评估。如果可以找到匹配的`PersistentVolume`，它将被挂载到依赖于该声明的容器中。
- en: 'Let''s take a look at the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can note, we were able to refer to the previously created `PersistentVolumeClaim`
    in our pod configuration. With this configuration, when `mypod` starts, `myclaim`
    would be evaluated, and if a matching `PersistentVolume` is found, it will be
    mounted inside `my-container`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，我们能够在我们的pod配置中引用之前创建的`PersistentVolumeClaim`。使用此配置，当`mypod`启动时，`myclaim`将被评估，如果找到匹配的`PersistentVolume`，它将被挂载到`my-container`内部。
- en: It's time to take a look at the bigger picture of the `PersistentVolume` and
    `PersistentVolumeClaims` architecture; those objects decouple storage provisioning
    from pod configuration. As a result, a developer is able to specify the characteristics
    of the storage that they need. They don't have to configure those volumes, and
    don't need to have the knowledge of the architecture of the given cluster. Also,
    the `PersistentVolume` is part of a cluster configuration, whereas the `PersistentVolumeClaim`
    is part of an application configuration; both can be created independently. The
    application that contains `PersistentVolumeClaim` objects can be created by a
    developer and deployed without changes in many OpenShift clusters. On the other
    hand, those clusters may contain different persistent storage configurations created
    by the administrators of those clusters. The details of those configurations are
    abstracted away from the developer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看`PersistentVolume`和`PersistentVolumeClaims`架构的更大图景了；这些对象将存储配置与pod配置解耦。因此，开发者能够指定他们需要的存储特性。他们不需要配置这些卷，也不需要了解给定集群的架构。此外，`PersistentVolume`是集群配置的一部分，而`PersistentVolumeClaim`是应用程序配置的一部分；两者都可以独立创建。包含`PersistentVolumeClaim`对象的应用程序可以由开发者创建并在许多OpenShift集群中部署而无需更改。另一方面，这些集群可能包含由集群管理员创建的不同持久存储配置。这些配置的详细信息被抽象化，从开发者那里隐藏起来。
- en: The catalog-service with database
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有数据库的目录服务
- en: You have learned the essential knowledge to understand how to work with persistent
    storage in the OpenShift cloud. Now, let's take a look at this with a practical
    example. Let's update our catalog-service deployment so that it connects to the
    database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学到了理解如何在OpenShift云中与持久存储工作的基本知识。现在，让我们通过一个实际例子来看看这一点。让我们更新我们的catalog-service部署，使其连接到数据库。
- en: Configuring PostgreSQL database
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置PostgreSQL数据库
- en: 'First, let''s ensure that we have removed the previous version of the `catalog-service`.
    In order to do that, we will need to use the `oc` delete command. The command
    interface is the same as the interface for the get operation. You will be able
    to delete an object by directly specifying its name or use labels to indicate
    objects that you want to delete. There are many objects related to a single application,
    and we obviously don''t want to delete them one by one. As a result, we will use
    the label version of the `delete` command for that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保我们已经删除了之前的`catalog-service`版本。为了做到这一点，我们需要使用`oc` delete命令。命令界面与get操作的界面相同。您可以直接指定对象名称来删除对象，或者使用标签来指示要删除的对象。与单个应用程序相关的对象有很多，我们显然不想逐个删除它们。因此，我们将使用`delete`命令的标签版本：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we are ready to deploy the database. Open your web console and click on
    the Add to the Project button. We will search for the PostgreSQL project:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备部署数据库。打开您的网页控制台，点击“添加到项目”按钮。我们将搜索PostgreSQL项目：
- en: '![](img/f2ceef6b-9893-4b4b-ab22-1f573cafa24b.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f2ceef6b-9893-4b4b-ab22-1f573cafa24b.png)'
- en: 'The search results in a number of options; we need to choose the data store
    option:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索结果会显示多个选项；我们需要选择数据存储选项：
- en: '![](img/d58deab6-0a05-4bd8-a3b0-6ccd8af2cba4.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d58deab6-0a05-4bd8-a3b0-6ccd8af2cba4.png)'
- en: 'When you click on the Select button, the following form opens:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击“选择”按钮时，以下表单会打开：
- en: '![](img/54bfbd1c-40d8-4d80-bc33-06d001db2812.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54bfbd1c-40d8-4d80-bc33-06d001db2812.png)'
- en: We changed the name of the database server and the name of the database instance
    to `catalogdb`. For convenience purposes, we have set both the user and password
    to catalog.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据库服务器名称和数据库实例名称更改为`catalogdb`。为了方便起见，我们将用户名和密码都设置为catalog。
- en: 'We will also override Labels:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将覆盖标签：
- en: '![](img/40376223-9280-47bd-b433-ce535e617d5c.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40376223-9280-47bd-b433-ce535e617d5c.png)'
- en: We will use a bunch of database containers for our different services. As a
    result, we can't use standard application and template labels. We change them
    to catalogdb-template and `catalogdb`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的不同服务使用一系列数据库容器。因此，我们不能使用标准的应用程序和模板标签。我们将它们更改为catalogdb-template和`catalogdb`。
- en: After we have done that, we are ready to create an application; let's click
    on the Create button at the bottom of the page.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成之后，我们就准备好创建一个应用程序了；让我们点击页面底部的“创建”按钮。
- en: 'We have to wait for the moment till the pod has been started. Let''s click
    on the Overview page button and further on postgresql deployment; we have to wait
    till there is one replica active:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须等待 Pod 启动。让我们点击“概览”页面按钮，然后点击 postgresql 部署；我们必须等待有一个副本处于活动状态：
- en: '![](img/95a98108-243e-4fc1-af2a-53cbcfd261da.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95a98108-243e-4fc1-af2a-53cbcfd261da.png)'
- en: 'The application is running. Let''s fill our database with a number of pets
    so that we can test our service behavior. To do that we need to get access to
    the console of the container on which the database run. In order to achieve that
    we have to go to applications/pods menu, choose the pod on which PostgreSQL runs,
    and the terminal button:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正在运行。让我们用一些宠物填充我们的数据库，以便我们可以测试我们的服务行为。为此，我们需要访问运行数据库的容器控制台。为了实现这一点，我们必须转到“应用程序/Pods”菜单，选择运行
    PostgreSQL 的 Pod，然后点击终端按钮：
- en: '![](img/61f80c88-b737-4606-ad97-0f92769c288c.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61f80c88-b737-4606-ad97-0f92769c288c.png)'
- en: 'Let''s fill the database now. Let''s log into the user directory and create
    the SQL script there:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们填充数据库。让我们登录到用户目录并创建 SQL 脚本：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The script is very similar to the load scripts that we created in previous
    applications:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本与我们之前在应用程序中创建的加载脚本非常相似：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Please note, that we have changed the convention here. Instead of using names
    as item identifiers, we start using UIDs we will be the consistent ID for pets
    in the whole application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里改变了惯例。我们不再使用名称作为项目标识符，而是开始使用 UIDs，它将成为整个应用程序中宠物的唯一标识符。
- en: 'Finally, we are going to execute the script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将执行脚本：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The command above run PostgreSQL command line client. The `-U` parameter specifies
    the user (catalog in our example) and the `catalogdb` parameter specifies the
    schema on which the client must operate.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令运行 PostgreSQL 命令行客户端。`-U` 参数指定用户（在我们的例子中是 catalog）和 `catalogdb` 参数指定客户端必须操作的架构。
- en: 'Our database is ready now and the question that comes to your mind may be:
    where are my persistent volumes? And the answer is: again OpenShift has done everything
    for you. Let''s inspect it a little bit further.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库现在准备好了，你可能会想到的问题可能是：我的持久卷在哪里？答案是：再次是 OpenShift 为你做了所有的事情。让我们进一步检查一下。
- en: Inspecting the volumes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查卷
- en: 'In order to take a look at how the database is configured, let''s use `cli`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看数据库是如何配置的，让我们使用 `cli`：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will be able to see that this deployment configuration has defined a volume
    of the `PersistentVolumeClaim` type:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够看到，此部署配置已定义了一个 `PersistentVolumeClaim` 类型的卷：
- en: '![](img/25f673f5-c9fa-48ce-b72b-1bbe6d49e433.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25f673f5-c9fa-48ce-b72b-1bbe6d49e433.png)'
- en: 'Going further, let''s analyze the `catalogdb` persistent volume claim:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，让我们分析 `catalogdb` 持久卷声明：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will be able to see that the claim has been created according to the database
    type that we provided and that it has been already bound:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够看到，声明已经根据我们提供的数据库类型创建，并且它已经被绑定：
- en: '![](img/fae0a7c9-2216-4142-997d-cbe035f6334c.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fae0a7c9-2216-4142-997d-cbe035f6334c.png)'
- en: As you see in the preceding screenshot, OpenShift has created a `PersitentVolumeClaim`
    based on information that you provided when an application was created from the
    template. The claim has been bound to one of the `PersitentVolumes` on the cluster.
    Since we are using Minishift now, the `PersitentVolumes` are implemented using
    disks inside the virtual machine. But we want to emphasize again that your application
    config wouldn't change an iota if you decided to deploy your application on any
    other OpenShift cluster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的屏幕截图中所见，OpenShift 已经根据您在从模板创建应用程序时提供的信息创建了一个 `PersistentVolumeClaim`。该声明已经绑定到集群中的一个
    `PersistentVolume`。由于我们现在使用 Minishift，`PersistentVolume` 是通过虚拟机内部的磁盘实现的。但我们要再次强调，如果您决定在其他
    OpenShift 集群上部署应用程序，您的应用程序配置不会发生任何变化。
- en: Let's return to our example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子。
- en: Updating catalog-service
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新目录服务
- en: We have to reconfigure our catalog-service again so that it works with the PostgreSQL
    database.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须再次重新配置我们的目录服务，以便它与 PostgreSQL 数据库兼容。
- en: 'Examples refrence: `chapter7/catalog-service**-**openshift**-**postgresql`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter7/catalog-service**-**openshift**-**postgresql`。
- en: 'Let''s start with the `pom.xml` changes—we have to add Postgres dependency
    to it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `pom.xml` 的更改开始——我们必须向其中添加 Postgres 依赖项：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have changed the database driver from `h2` to `PostgreSQL` (1).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将数据库驱动程序从 `h2` 更改为 `PostgreSQL`（1）。
- en: 'Let''s change the datasource configuration:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改数据源配置：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have to reconfigure the JDBC driver to user `postgresql` classes and reconfigure
    the datasource, so that it contains the data of our application. The meaning of
    catalogdb.petstore.svc address will be explained in the next chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须重新配置JDBC驱动程序以使用`postgresql`类，并重新配置数据源，使其包含应用程序的数据。catalogdb.petstore.svc地址的含义将在下一章中解释。
- en: 'As in the previous database examples, we have to provide the `persistence`
    file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的数据库示例一样，我们必须提供`persistence`文件：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, we have to add the `postgreSQL` JDBC module to the application...
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将`postgreSQL` JDBC模块添加到应用程序中...
- en: '![](img/fe71f5cd-a059-4447-9f43-2e6cc2b3e7bf.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe71f5cd-a059-4447-9f43-2e6cc2b3e7bf.png)'
- en: 'With the following contents:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 内容如下：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: OK, now that we have reconfigured our catalog-service, it is time for interesting
    stuff. Let's deploy our application to OpenShift.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经重新配置了我们的catalog-service，是时候做一些有趣的事情了。让我们将我们的应用程序部署到OpenShift。
- en: 'We will use the source-to-image build again as we did in the last chapter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用源到镜像构建，就像我们在上一章中做的那样：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have to wait till our fat-JAR has started. To verify that, we may take a
    look at the log of the pod on which the application was started:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须等待我们的fat-JAR启动。为了验证这一点，我们可以查看启动应用程序的Pod的日志：
- en: '![](img/ff92ae62-f574-4270-b600-093719a2445b.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff92ae62-f574-4270-b600-093719a2445b.png)'
- en: 'As in the preceding example, we have to create a route. After doing that, let''s
    find out the address of catalog-service visible from outside the cluster:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的示例一样，我们必须创建一个路由。完成之后，让我们找出从集群外部可见的catalog-service地址：
- en: '![](img/85c23ccc-45d2-47fe-a606-94cc6552f4b7.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85c23ccc-45d2-47fe-a606-94cc6552f4b7.png)'
- en: 'Let''s copy the route name and use `curl` to check whether we can get pet information
    using catalog-service:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制路由名称并使用`curl`检查我们是否可以使用catalog-service获取宠物信息：
- en: '![](img/20becbce-beeb-4eac-abff-7c126e3c94d1.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20becbce-beeb-4eac-abff-7c126e3c94d1.png)'
- en: It works. Let's extend our service now so that it is able to persist data to
    the database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功了。现在让我们扩展我们的服务，使其能够将数据持久化到数据库。
- en: 'Let''s extend our `CatalogService`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的`CatalogService`：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have extended the service with the `add` method (1). Note that the method
    is transactional and generates UUID for the items in the store (2). We have also
    added a method that lists all the items in the store (3). Note that we would need
    also to add NamedQuery for that:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`add`方法（1）扩展了服务。请注意，该方法具有事务性，并为存储中的项目生成UUID（2）。我们还添加了一个列出存储中所有项目的方法（3）。请注意，我们还需要为它添加NamedQuery：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We also have to add the `POST` method to the `CatalogResource`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须向`CatalogResource`添加`POST`方法：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have implemented the `addNew` method, which uses the `CatalogService` instance
    to add an `Item` object(1) to the database. As you will have noticed in the preceding
    code, both the `Request` parameter and `Response` are JSON objects. They are parsed
    automatically by a server; the only thing that we must do is annotate the method
    with the `@Produces` (2) and `@Consumes` (3) annotations. In the method, we use
    the `catalogService` to store a given Item object. Finally, we return either the
    `ok` response (5) or an error response (6) based on the result of the store operation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了`addNew`方法，它使用`CatalogService`实例将`Item`对象（1）添加到数据库。如您在先前的代码中所注意到的，`Request`参数和`Response`都是JSON对象。它们由服务器自动解析；我们唯一需要做的是使用`@Produces`（2）和`@Consumes`（3）注解方法。在方法中，我们使用`catalogService`存储给定的Item对象。最后，我们根据存储操作的结果返回`ok`响应（5）或错误响应（6）。
- en: We have also implemented `getAll` method which will allow us to request information
    about all the pets in the store (2).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了`getAll`方法，这将允许我们请求商店中所有宠物的信息（2）。
- en: 'After the application is ready, you have to commit the changed files and push
    them to GitHub. When you do this, you can enter the web console and trigger the
    build of the updated service. In order to do it, you have to click on Build |
    Build in the Webconsole, select the catalog-service, and click on the Start Build
    button in the top-right corner:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序准备就绪后，您必须提交更改的文件并将它们推送到GitHub。当您这样做时，您可以进入Web控制台并触发更新服务的构建。为了做到这一点，您必须在Web控制台中点击构建
    | 构建，选择catalog-service，然后在右上角点击开始构建按钮：
- en: '![](img/663eda07-e9f5-4e52-adf8-570303ba0a6b.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/663eda07-e9f5-4e52-adf8-570303ba0a6b.png)'
- en: 'After the application starts, we have to wait till it has been deployed in
    the cloud. Let''s use `curl` to `POST` new Item in our store:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动后，我们必须等待它被部署到云端。让我们使用`curl`向我们的存储中`POST`新的项目：
- en: '![](img/fe1bf0c4-269c-4f17-bf7b-eb9f27f2ceca.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe1bf0c4-269c-4f17-bf7b-eb9f27f2ceca.png)'
- en: 'Everything seems fine, so let''s check what items are available in the store
    using the request that we have just implemented:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一切似乎都很正常，所以让我们使用我们刚刚实现的请求来检查存储中可用的项目：
- en: '![](img/4aea7c58-3c7d-4dff-b67c-be6d2145dab1.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4aea7c58-3c7d-4dff-b67c-be6d2145dab1.png)'
- en: There are three rabbits in our database. Our service is working correctly inside
    the OpenShift cluster.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据库中有三只兔子。我们的服务在OpenShift集群内部运行正常。
- en: We may now check that the storage is indeed persistent. Let's get into the web
    console and terminate both catalog-service and database pods. In order to do that,
    enter web console, click Applications | Pods and choose the database pod. Later
    click on Actions in the right, upper corner and choose Delete. Repeat those actions
    for catalog-service pod. After both pods have been restarted (you can monitor
    that in Applications | Pods view), you can again list all items. You should be
    able to see extract the same result as on the preceding screenshot.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查存储是否确实持久。让我们进入网页控制台并终止catalog-service和数据库Pod。为了做到这一点，进入网页控制台，点击应用程序
    | Pods并选择数据库Pod。稍后点击右上角的操作，并选择删除。对catalog-service Pod重复这些操作。当这两个Pod都重新启动后（你可以在应用程序
    | Pods视图中监控这一点），你又可以列出所有项目。你应该能够看到提取的结果与前面的截图相同。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to configure persistence for the services deployed
    in OpenShift.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在OpenShift中配置已部署服务的持久性。
- en: This chapter started with theoretical knowledge, giving you more details on
    volumes and their different types. Later, you learned a particularly useful type
    of the volume the `PersistentVolumeClaim`. You also learned why it is necessary,
    how it is related to the `PersistentVolume`, and how to use it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从理论知识开始，为你提供了关于卷及其不同类型的更多细节。稍后，你学习了卷的一个特别有用的类型，即`PersistentVolumeClaim`。你还学习了为什么它是必要的，它与`PersistentVolume`的关系以及如何使用它。
- en: Finally, we extended your `catalogService` so that it uses the `postgresql`
    database as the storage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们扩展了你的`catalogService`，使其使用`postgresql`数据库作为存储。
