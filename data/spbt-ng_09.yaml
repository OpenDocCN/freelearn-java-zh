- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Writing Tests in Spring Boot
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Spring Boot中编写测试
- en: In the previous chapter, you have learned about the importance of loggers, their
    concepts, and how they can help developers debug and maintain applications. You
    have learned about Log4j2, which is a third-party framework for Spring Boot that
    offers several features such as **Appenders**, **Filters**, and **Markers** that
    can assist in making log events categorized and formatted for developers. We have
    also discussed SLF4J, which is an abstraction of logging frameworks that allows
    us to switch between different frameworks during runtime or at deployment, and
    lastly, we have implemented and configured the logging frameworks with XML configuration
    and Lombok.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你已经了解了日志记录器的重要性、它们的概念以及它们如何帮助开发者调试和维护应用程序。你已经学习了Log4j2，这是一个为Spring Boot提供的第三方框架，它提供了诸如**Appenders**、**Filters**和**Markers**等特性，可以帮助开发者对日志事件进行分类和格式化。我们还讨论了SLF4J，它是对日志框架的抽象，允许我们在运行时或部署期间在多个框架之间切换，最后，我们使用XML配置和Lombok实现了并配置了日志框架。
- en: This chapter will now focus on writing unit tests for our Spring Boot application;
    we will discuss the most commonly used testing frameworks with Java, JUnit, and
    **AssertJ** and implement them in our application. We will also be integrating
    Mockito with our unit test for mocking objects and services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将现在专注于为我们的Spring Boot应用程序编写单元测试；我们将讨论最常用的Java测试框架JUnit和**AssertJ**，并在我们的应用程序中实现它们。我们还将集成Mockito到我们的单元测试中，以进行对象和服务模拟。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding JUnit and AssertJ
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解JUnit和AssertJ
- en: Writing a test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试
- en: Writing tests in a service using Mockito
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务中使用Mockito编写测试
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The link to the finished version of this chapter is here: [https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-09](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-09).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成版本的链接在此：[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-09](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-09)。
- en: Understanding JUnit and AssertJ
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JUnit和AssertJ
- en: After every development of an application, testing will always be the next step,
    and this is one of the most important tasks before delivering or deploying our
    application into production for the world. The testing phase is critical for companies,
    as this ensures the quality and effectiveness of their products.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个应用程序开发之后，测试总是下一步，这是在将我们的应用程序交付或部署到生产环境之前最重要的任务之一。测试阶段对公司来说至关重要，因为这确保了他们产品的质量和有效性。
- en: As this is one of the essential processes, there should be little room for errors
    in testing, and manual testing is not enough, as this is prone to human errors
    and has a more significant chance of missing the existing issues in an application.
    This is where unit testing comes to the rescue – unit testing is automated testing
    that allows the developer to write tests for a single class or entity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是基本流程之一，测试过程中应该几乎没有错误空间，而手动测试是不够的，因为手动测试容易出错，并且有更大的机会错过应用程序中存在的问题。这就是单元测试发挥作用的地方——单元测试是自动化测试，允许开发者为单个类或实体编写测试。
- en: 'It is a form of **regression testing** that runs all of the tests to validate
    whether the code still passes the test cases after several changes or updates
    have been applied to the application code. Unit tests help maintain the quality
    of our applications, as they bring the following benefits:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种**回归测试**的形式，它会运行所有测试以验证在应用代码经过几次更改或更新后，代码是否仍然通过测试用例。单元测试有助于保持我们应用程序的质量，因为它们带来了以下好处：
- en: '**Speed**: Unit testing will be less time-consuming compared to manual testing,
    as this is programmable and will deliver the results in a short period.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：与手动测试相比，单元测试将节省更多时间，因为这是可编程的，并且将在短时间内提供结果。'
- en: '**Cost reduction**: Unit testing is automated, which means fewer testers will
    be required for testing the application.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本降低**：单元测试是自动化的，这意味着将需要更少的测试人员来测试应用程序。'
- en: '**Fewer errors**: Unit testing will significantly reduce the number of errors
    made, as testing is not done manually by humans.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误减少**：单元测试将显著减少犯错误的数量，因为测试不是由人类手动完成的。'
- en: '**Programmable**: Unit tests can produce sophisticated tests that detect hidden
    information in the application.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可编程性**：单元测试可以生成复杂的测试，以检测应用程序中的隐藏信息。'
- en: Unit tests are widely used now in both frontend and backend development, especially
    in Java, because of their advantages and testing. There are already several testing
    frameworks available in Java, but we will discuss the first and most commonly
    used framework, **JUnit**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试现在在前后端开发中都广泛使用，尤其是在Java中，因为它们的优点和测试。Java中已经存在几个测试框架，但我们将讨论第一个也是最常用的框架，**JUnit**。
- en: JUnit framework
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JUnit框架
- en: JUnit is a regression testing framework mainly used for writing tests and assertions
    for single classes in a Java application; it promotes the idea of *first testing
    and then coding*, which states that we need to create test data for a piece of
    code to be tested before implementation. JUnit is also an open source framework,
    which makes it more reliable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit是一个回归测试框架，主要用于为Java应用程序中的单个类编写测试和断言；它提倡“先测试后编码”的理念，即我们需要在实现之前为要测试的代码创建测试数据。JUnit也是一个开源框架，这使得它更加可靠。
- en: There is a large community supporting the framework, it uses assertions to test
    expected results and annotations to identify the methods for testing, and it can
    be efficiently utilized and integrated with Maven and Gradle projects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个庞大的社区支持此框架，它使用断言来测试预期结果，并使用注解来识别测试方法，它可以有效地利用并集成到Maven和Gradle项目中。
- en: 'Let’s discuss the features of JUnit that we will use for writing tests:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论我们将用于编写测试的JUnit特性：
- en: '`setUp()`: This method is executed *before* every test is invoked.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setUp()`: 此方法在每次测试被调用之前执行。'
- en: '`tearDown()`: This method is executed *after* every test is invoked:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tearDown()`: 此方法在每次测试被调用之后执行：'
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code example, we can see that there are two test methods defined,
    which are `testSubtract()` and `testMultiply()`, before each method is called.
    The `setUp()` fixture will be called first to assign the values of the `value1`
    and `value2` variables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到定义了两个测试方法，分别是`testSubtract()`和`testMultiply()`，在每个方法被调用之前。`setUp()`设置将首先被调用，以分配`value1`和`value2`变量的值。
- en: '`@RunWith` and `@Suite` annotations to run the tests. Let’s have a look at
    the following example:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@RunWith`和`@Suite`注解用于运行测试。让我们看看以下示例：'
- en: '[PRE15]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code example, we can see that we have two defined classes with
    a method with the `@Test` annotation; the test methods will be executed together,
    as we have bundled them using the `@``Suite.SuiteClasses` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们定义了两个类，其中一个带有`@Test`注解的方法；测试方法将一起执行，因为我们已经使用`@Suite.SuiteClasses`方法将它们捆绑在一起。
- en: '`runClasses()` method to run the test cases inside a specific class. Let’s
    have a look at a basic example here:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runClasses()`方法用于在特定类中运行测试用例。让我们看看以下基本示例：'
- en: '[PRE38]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Classes**: JUnit classes are mainly used for writing the tests for our application;
    these include the following:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：JUnit类主要用于编写我们应用程序的测试；这些包括以下内容：'
- en: '**Assert**: Includes the set of assert methods'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**包括断言方法集'
- en: '**Test case**: Includes the test cases that contain the fixtures for running
    multiple tests'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例**包括包含运行多个测试的设置的测试用例'
- en: '**Test result**: Includes the methods to gather all of the results from an
    executed test case'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试结果**包括收集执行测试用例的所有结果的方法'
- en: Assertions in JUnit
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JUnit中的断言
- en: '`Assert` class, and some of the essential methods from Assert are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert`类，以及一些来自Assert的基本方法如下：'
- en: '`void assertTrue(boolean condition)`: Validates whether the condition is `true`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void assertTrue(boolean condition)`: 验证条件是否为`true`'
- en: '`void assertFalse(boolean condition)`: Validates whether the condition is `false`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void assertFalse(boolean condition)`: 验证条件是否为`false`'
- en: '`void assertNotNull(Object obj)`: Checks whether the object is not null'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void assertNotNull(Object obj)`: 检查对象是否不为null'
- en: '`void assertNull(Object obj)`: Checks whether the object is null'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void assertNull(Object obj)`: 检查对象是否为null'
- en: '`void assertEquals(Object obj1, Object obj2)`: Checks whether two objects or
    primitives are equal'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void assertEquals(Object obj1, Object obj2)`: 检查两个对象或原始数据是否相等'
- en: '`void assertArrayEquals(Array array1, Array array2)`: Validates whether two
    arrays are equal to each other'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void assertArrayEquals(Array array1, Array array2)`: 验证两个数组是否彼此相等'
- en: Annotations
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解
- en: '**Annotations** are meta tags that we add to methods and classes; this provides
    additional information to JUnit about which methods should run before and after
    the test methods and which will be ignored during the test execution.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**注解**是元标签，我们将其添加到方法和类中；这为JUnit提供了额外信息，说明哪些方法应该在测试方法之前和之后运行，哪些将在测试执行期间被忽略。'
- en: 'Here are the annotations that we can use in JUnit:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是JUnit中我们可以使用的注解：
- en: '`@Test`: This annotation is used for a `public void` method to signify that
    the method is a test case that can be executed.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Test`: 该注解用于一个`public void`方法，表示该方法是一个可以执行的测试用例。'
- en: '`@Ignore`: This annotation is used to ignore a test case not being executed.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Ignore`: 该注解用于忽略未执行的测试用例。'
- en: '`@Before`: This annotation is used for a `public void` method to run the method
    before each test case method. This is commonly used if we want to declare similar
    objects used by all test cases.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Before`: 该注解用于一个`public void`方法，在每次测试用例方法之前运行该方法。如果我们想声明所有测试用例都使用的类似对象，这通常会被使用。'
- en: '`@After`: The annotation is used for a `public void` method to run the method
    after each test case method; this is commonly used if we want to release or clean
    several resources before running a new test case.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@After`: 该注解用于一个`public void`方法，在每次测试用例方法之后运行该方法；如果我们想在运行新的测试用例之前释放或清理多个资源，这通常会被使用。'
- en: '`@BeforeClass`: The annotation allows a `public static void` method to run
    once before all of the test cases are executed.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@BeforeClass`: 该注解允许一个`public static void`方法在所有测试用例执行之前运行一次。'
- en: '`@AfterClass`: The annotation allows a `public static void` method to run once
    all test cases are executed.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AfterClass`: 该注解允许一个`public static void`方法在所有测试用例执行之后运行一次。'
- en: 'Let’s have an example test with annotations and their sequence of execution:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个带有注解及其执行顺序的示例测试来看看：
- en: '[PRE48]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding code example, we have a `JunitAnnotationSequence` class that
    has several annotated methods. When we execute the test, we will have the following
    output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们有一个`JunitAnnotationSequence`类，它有几个注解方法。当我们执行测试时，我们将得到以下输出：
- en: '[PRE49]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can see in the preceding example that the methods annotated with `@BeforeClass`
    and `@AfterClass` are only called once and they are called at the start and end
    of the test execution. On the other hand, the methods annotated with `@Before`
    and `@After` are called at the beginning and the end of each test method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到，使用`@BeforeClass`和`@AfterClass`注解的方法只调用一次，它们在测试执行的开始和结束时被调用。另一方面，使用`@Before`和`@After`注解的方法在每个测试方法的开始和结束时被调用。
- en: We have learned about the basics of JUnit in unit testing; now, let’s discuss
    the concepts of AssertJ.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了单元测试中JUnit的基础知识；现在，让我们讨论AssertJ的概念。
- en: Using AssertJ
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AssertJ
- en: We have just explored the concepts and features of JUnit in the last part, and
    we have learned that in JUnit alone, we can apply assertions using the `Assert`
    class, but we can make our assertions more fluent and flexible by using AssertJ.
    **AssertJ** is a library mainly used for writing assertions; its primary goal
    is to improve the readability of test code and make the maintenance of tests simpler.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分，我们刚刚探讨了JUnit的概念和功能，我们了解到，仅使用JUnit，我们可以通过`Assert`类应用断言，但通过使用AssertJ，我们可以使断言更加流畅和灵活。**AssertJ**是一个主要用于编写断言的库；它的主要目标是提高测试代码的可读性，并简化测试的维护。
- en: 'Let’s compare how to write assertions in JUnit and AssertJ:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下在JUnit和AssertJ中如何编写断言：
- en: 'JUnit checking whether the condition returns `true`:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit检查条件是否返回`true`：
- en: '[PRE50]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'AssetJ checking whether the condition returns `true`:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AssertJ检查条件是否返回`true`：
- en: '[PRE51]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can see in the preceding example that in AssertJ, we will always pass the
    object to be compared in the `assertThat()` method, and we will call the next
    method, which is the actual assertion. Let’s have a look at the different kinds
    of assertions we can use in AssertJ.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到，在AssertJ中，我们将在`assertThat()`方法中始终传递要比较的对象，然后调用下一个方法，即实际的断言。让我们看看在AssertJ中我们可以使用哪些不同类型的断言。
- en: Boolean assertions
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔断言
- en: '`true` or `false`. The assertion methods are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`或`false`。断言方法如下：'
- en: '`isTrue()`: Checks whether the condition is `true`:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTrue()`: 检查条件是否为`true`：'
- en: '[PRE52]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`isFalse()`: Checks whether the condition is `false`:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFalse()`: 检查条件是否为`false`：'
- en: '[PRE53]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Character assertions
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符断言
- en: '**Character assertions** are used to compare the object to a character or check
    whether the character is in the Unicode table; the assertion methods are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符断言**用于将对象与字符进行比较或检查字符是否在Unicode表中；断言方法如下：'
- en: '`isLowerCase()`: Reviews whether the given character is lowercase:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLowerCase()`: 检查给定的字符是否为小写：'
- en: '[PRE54]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`isUpperCase()`: Checks whether the character is uppercase:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isUpperCase()`: 检查字符是否为大写：'
- en: '[PRE55]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`isEqualTo()`: Checks whether the two given characters are equal:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEqualTo()`: 检查两个给定的字符是否相等：'
- en: '[PRE56]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`isNotEqualTo()`: Checks whether the two given characters are not equal:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNotEqualTo()`: 检查两个给定的字符是否不相等：'
- en: '[PRE57]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`inUnicode()`: Checks whether the character is included in the Unicode table:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inUnicode()`: 检查字符是否包含在Unicode表中：'
- en: '[PRE58]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: These are just some of the assertions available under `AbstractCharacterAssert`.
    For the complete documentation, you can go to [https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharacterAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharacterAssert.html).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是`AbstractCharacterAssert`下可用的一些断言。对于完整的文档，您可以访问[https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharacterAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharacterAssert.html).
- en: Class assertions
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类断言
- en: '**Class assertions** are used to check the fields, types, access modifiers,
    and annotations in a specific class. The following are some of the class assertion
    methods:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**类断言**用于检查特定类的字段、类型、访问修饰符和注解。以下是一些类断言方法：'
- en: '`isNotInterface()`: Verifies that the class is not an interface:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNotInterface()`: 验证该类不是接口：'
- en: '[PRE59]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`isInterface()`: Verifies that the class is an interface:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isInterface()`: 验证该类是接口：'
- en: '[PRE62]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`isPublic()`: Verifies that the class is public:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPublic()`: 验证该类是公开的：'
- en: '[PRE65]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`isNotPublic()`: Verifies that the class is not public:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNotPublic()`: 验证该类不是公开的：'
- en: '[PRE68]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: These are just some of the assertions available under `AbstractClassAssert`.
    For the complete documentation, you can go to [https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractClassAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractClassAssert.html).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是`AbstractClassAssert`下可用的一些断言。对于完整的文档，您可以访问[https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractClassAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractClassAssert.html).
- en: Iterable assertions
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器断言
- en: '**Iterable assertions** are used to verify an iterable or array object based
    on its length and contents. The following are some of the iterable assertion methods:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代器断言**用于根据其长度和内容验证迭代器或数组对象。以下是一些迭代器断言方法：'
- en: '`contains()`: Demonstrates that the iterable has the given values:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains()`: 展示迭代器包含指定的值：'
- en: '[PRE71]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`isEmpty()`: Verifies whether the given iterable has a length greater than
    `0`:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty()`: 验证给定的迭代器长度是否大于`0`：'
- en: '[PRE74]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`isNotEmpty()`: Verifies whether the given iterable has a length of `0`:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNotEmpty()`: 验证给定的迭代器长度是否为`0`：'
- en: '[PRE76]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`hasSize()`: Verifies whether the length of the iterable is equal to the given
    value:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasSize()`: 验证迭代器的长度是否等于指定的值：'
- en: '[PRE79]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'These are just some of the assertions available under `AbstractIterableAssert`.
    For the complete documentation, you can go to the link provided here: [https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是`AbstractIterableAssert`下可用的一些断言。对于完整的文档，您可以访问此处提供的链接：[https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html).
- en: File assertions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件断言
- en: '**File assertions** are used to verify whether a file exists, can be written,
    or is readable, and also verify its contents. The following are some of the file
    assertion methods:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件断言**用于验证文件是否存在、是否可写或可读，并验证其内容。以下是一些文件断言方法：'
- en: '`exists()`: Proves that the file or directory exists:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exists()`: 证明文件或目录存在：'
- en: '[PRE82]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`isFile()`: Verifies whether the given object is a file (providing a directory
    will result in a failed test):'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isFile()`: 验证给定的对象是否是文件（提供目录将导致测试失败）：'
- en: '[PRE84]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`canRead()`: Verifies whether the given file is readable by the application:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canRead()`: 验证给定的文件是否可由应用程序读取：'
- en: '[PRE86]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`canWrite()`: Verifies whether the given file is modifiable by the application:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canWrite()`: 验证给定的文件是否可由应用程序修改：'
- en: '[PRE88]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'These are just some of the assertions available under `AbstractFileAssert`.
    For the complete documentation, you can go to the link provided here: [https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractFileAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractFileAssert.html).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是`AbstractFileAssert`下可用的一些断言。对于完整的文档，您可以访问此处提供的链接：[https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractFileAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractFileAssert.html).
- en: Map assertions
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射断言
- en: '**Map assertions** are used to check a map based on its entries, keys, and
    size. The following are some of the map assertion methods:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射断言**用于根据其条目、键和大小检查映射。以下是一些映射断言方法：'
- en: '`contains()`: Verifies whether the map contains the given entries:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains()`: 验证映射是否包含给定的条目：'
- en: '[PRE90]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '`containsAnyOf()`: Verifies whether the map contains at least one of the entries:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containsAnyOf()`: 验证映射是否至少包含一个条目：'
- en: '[PRE96]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '`hasSize()`: Verifies that the size of the map is equal to the given value:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasSize()`: 验证映射的大小是否等于给定的值：'
- en: '[PRE101]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`isEmpty()`: Verifies that the given map is empty:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty()`: 验证给定的映射是否为空：'
- en: '[PRE106]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`isNotEmpty()`: Verifies that the given map is not empty:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isNotEmpty()`: 验证给定的映射不为空：'
- en: '[PRE108]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'These are just some of the assertions available under `AbstractMapAssert`.
    For the complete documentation, you can go to the link provided here: [https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractMapAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractMapAssert.html).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是`AbstractMapAssert`下可用的一些断言。对于完整的文档，你可以访问这里提供的链接：[https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractMapAssert.html](https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractMapAssert.html)。
- en: We have learned about the different assertion methods using AssertJ; now, we
    will implement and write our unit test in our Spring Boot application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了使用AssertJ的不同断言方法；现在，我们将在Spring Boot应用程序中实现并编写我们的单元测试。
- en: Writing a test
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: In this section, we will now start writing our unit tests in our Spring Boot
    application. As we go back to our application, the **services** and **repository**
    are the essential parts of our application where we need to implement unit tests,
    as the services contain the business logic and can be modified often, especially
    when new features are added. The repository includes methods for CRUD and other
    operations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们现在将开始在Spring Boot应用程序中编写我们的单元测试。当我们回到我们的应用程序时，**服务**和**仓库**是我们应用程序的基本部分，我们需要在这里实现单元测试，因为服务包含业务逻辑并且经常被修改，尤其是在添加新功能时。仓库包括CRUD和其他操作的方法。
- en: We will be implementing two approaches in writing our unit tests. The first
    method is using an in-memory database such as H2 to store our created data when
    running unit tests. The second method is mocking our objects and repository using
    the Mockito framework.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在编写单元测试时采用两种方法。第一种方法是使用内存数据库，如H2，在运行单元测试时存储我们创建的数据。第二种方法是使用Mockito框架来模拟我们的对象和仓库。
- en: Testing with the H2 database
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用H2数据库进行测试
- en: The first approach that we will implement in writing our tests is using JUnit
    and AssertJ with the H2 database. The H2 database is an in-memory database that
    allows us to store data in the system memory. Once the application is closed,
    it will delete all the stored data. H2 is usually used for **Proof-of-Concept**
    or unit testing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在编写测试时实施的第一个方法是使用JUnit和AssertJ与H2数据库。H2数据库是一个内存数据库，允许我们在系统内存中存储数据。一旦应用程序关闭，它将删除所有存储的数据。H2通常用于**概念验证**或单元测试。
- en: 'We have already added an H2 database in [*Chapter 4*](B18159_04.xhtml#_idTextAnchor079),
    *Setting Up the Database and Spring Data JPA*, but if you have missed this part,
    in order for us to add the H2 dependency, we will add the following into our `pom.xml`
    file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第4章*](B18159_04.xhtml#_idTextAnchor079)中添加了H2数据库，*设置数据库和Spring Data JPA*，但如果你错过了这部分，为了我们能够添加H2依赖项，我们将在`pom.xml`文件中添加以下内容：
- en: '[PRE113]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'After successfully adding the dependency, we will add our `h2` configuration
    under our `test/java` folder. We will add a new resource bundle and create a new
    application to accomplish this. A properties file will be used for the unit tests
    and we will place the following configuration:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功添加依赖项后，我们将在`test/java`文件夹下添加我们的`h2`配置。我们将添加一个新的资源包并创建一个新的应用程序来完成此操作。我们将使用属性文件进行单元测试，并将以下配置放置在其中：
- en: '[PRE114]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: In the preceding example configuration, first, we have specified that we want
    to store our data in a `test.mv.db` file using the `spring.datasource.url` property.
    We can also override the username and password for our *H2* console using the
    `spring.datasource.username` and `spring.datasource.password` properties, and
    we have also specified that the tables will be created once the application starts
    and will be dropped when the application stops.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例配置中，首先，我们指定我们想要使用`spring.datasource.url`属性将数据存储在`test.mv.db`文件中。我们还可以使用`spring.datasource.username`和`spring.datasource.password`属性覆盖我们的*H2*控制台的用户名和密码，并且我们还指定了在应用程序启动时创建表，在应用程序停止时删除表。
- en: Testing a service
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试服务
- en: Now, we will create a package under our `test/java` folder. This is where we
    will write our tests. We will create a similar package from our main folder. In
    this case, we will make `com.example.springbootsuperheroes.superheroes.antiHero.h2.service`.
    Under the newly created package, we will create a new class named `AntiHeroH2ServiceTest`,
    where we will start writing our tests for `AntiHeroService`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的`test/java`文件夹下创建一个包。这是我们编写测试的地方。我们将从主文件夹创建一个类似的包。在这种情况下，我们将创建`com.example.springbootsuperheroes.superheroes.antiHero.h2.service`。在新建的包下，我们将创建一个名为`AntiHeroH2ServiceTest`的新类，我们将在这里开始编写对`AntiHeroService`的测试。
- en: 'The first step we need to take is to annotate our class using the `@DataJpaTest`
    annotation. The annotation allows the service to focus only on the JPA components
    by disabling the full auto-configuration and just applying the configuration related
    to the tests. The next step is to add the dependency of our `AntiHeroService`,
    which is `AntiHeroRepository`. We will declare a new `AntiHeroRepository` and
    use the `@Autowired` annotation to inject the dependency, and we will also declare
    `AntiHeroService`, as this is the service that we need to test. We will have the
    following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的第一个步骤是使用`@DataJpaTest`注解注解我们的类。该注解允许服务通过禁用完整的自动配置并仅应用与测试相关的配置来专注于JPA组件。下一步是添加我们的`AntiHeroService`的依赖项，即`AntiHeroRepository`。我们将声明一个新的`AntiHeroRepository`并使用`@Autowired`注解注入依赖项，我们还将声明`AntiHeroService`，因为这是我们需要测试的服务。我们将有以下的代码：
- en: '[PRE115]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'After injecting our dependency and annotating our class, the next thing we
    would want to consider is what the possible properties we want to have before
    running each of the tests are; in this case, we would like to have an instance
    of `AntiHeroService` created before running a test case. To accomplish this, we
    will make a method annotated with the `@BeforeEach` annotation, and create a new
    instance of `AntiHeroService` with `AutoWired AntiHeroRepository` as the parameter:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入我们的依赖项并注解我们的类之后，我们接下来想要考虑的是在运行每个测试之前我们想要有哪些可能的属性；在这种情况下，我们希望在运行测试用例之前创建一个`AntiHeroService`的实例。为了实现这一点，我们将创建一个带有`@BeforeEach`注解的方法，并使用`AutoWired
    AntiHeroRepository`作为参数创建一个新的`AntiHeroService`实例：
- en: '[PRE116]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Now, we can write a test case for our service; our goal is to write a test for
    each method that `AntiHeroService` possesses.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的服务编写一个测试用例；我们的目标是编写对`AntiHeroService`拥有的每个方法的测试。
- en: 'Let’s have the list of the methods for `AntiHeroService`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`AntiHeroService`的方法列表：
- en: '`Iterable<AntiHeroEntity> findAllAntiHeroes`: Should return the list of anti-heroes.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable<AntiHeroEntity> findAllAntiHeroes`: 应返回反英雄的列表。'
- en: '`AntiHeroEntity addAntiHero(AntiHeroEntity antiHero)`: Should add a new anti-hero
    entity.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AntiHeroEntity addAntiHero(AntiHeroEntity antiHero)`: 应添加一个新的反英雄实体。'
- en: '`void updateAntiHero(UUID id, AntiHeroEntity antiHero)`: Should update the
    anti-hero based on the given ID.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void updateAntiHero(UUID id, AntiHeroEntity antiHero)`: 应根据给定的ID更新反英雄。'
- en: '`AntiHeroEntity findAntiHeroById(UUID id)`: Should return the anti-hero with
    the given ID; if it is not found, it will return `NotFoundException`.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AntiHeroEntity findAntiHeroById(UUID id)`: 应返回具有给定ID的反英雄；如果未找到，则返回`NotFoundException`。'
- en: '`void removeAntiHeroById(UUID id)`: Should remove the anti-hero in the database
    based on the given ID.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void removeAntiHeroById(UUID id)`: 应根据给定的ID从数据库中删除反英雄。'
- en: 'Let’s first write a test for the `findAllAntiHeroes()` method. The possible
    test case for the method is to check whether the method retrieves all the anti-heroes
    successfully in the database. To test this scenario, we would want to add a single
    entity or a list of test anti-hero entities to our H2 database first. We can call
    the `findAllAntiHeroes()` method to retrieve the newly added entities in the database.
    Let’s see the example unit test here:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为`findAllAntiHeroes()`方法编写一个测试。该方法的可能测试用例是检查方法是否成功检索数据库中的所有反英雄。为了测试这个场景，我们首先需要将单个实体或一系列测试反英雄实体添加到我们的H2数据库中。我们可以调用`findAllAntiHeroes()`方法来检索数据库中刚添加的实体。让我们看看下面的示例单元测试：
- en: '[PRE117]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: In the preceding code example, we can see that we have created a new anti-hero
    instance to be an exemplary piece of data in the database memory first. We have
    added the data to our database using the `addAntiHero()` method. After successfully
    inserting the data, we can check or assert whether we can retrieve the newly created
    anti-hero using the `findAllAntiHeroes()` method. In the scenario here, we have
    retrieved the first data in our anti-hero list. We used `assertThat(savedAntiHero).isNotNull()`
    to validate that the first element of the list is not null.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们首先创建了一个新的反英雄实例，作为数据库内存中的示范数据。我们使用`addAntiHero()`方法将数据添加到我们的数据库中。在成功插入数据后，我们可以使用`findAllAntiHeroes()`方法检查或断言是否可以检索到新创建的反英雄。在这个场景中，我们检索了反英雄列表中的第一条数据。我们使用`assertThat(savedAntiHero).isNotNull()`来验证列表的第一个元素不是null。
- en: Now, let’s write a test for the `addAntiHero()` method. The test that we will
    create for the following method is mostly similar to the test that we have created
    for the `findAllAntiHeroes()` method. The possible test case for the following
    method is to check whether the entity is being added to our database successfully.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为`addAntiHero()`方法编写一个测试。我们将为以下方法创建的测试与为`findAllAntiHeroes()`方法创建的测试大致相似。该方法的可能测试用例是检查实体是否成功添加到我们的数据库中。
- en: 'Let’s have a look at the following example unit test:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例单元测试：
- en: '[PRE118]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We created a new anti-hero entity in the preceding code example and inserted
    it into our database using the `addAntiHero()` method. After adding the latest
    data, we can retrieve the list and validate whether our new data is in the database.
    In the given scenario, we retrieved the first piece of data in our anti-hero list,
    and we used `assertThat(antiHero).isEqualTo(savedAntiHero);` to check whether
    the data we retrieved was equal to the data we instantiated.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了一个新的反英雄实体，并使用`addAntiHero()`方法将其插入到我们的数据库中。在添加最新数据后，我们可以检索列表并验证我们的新数据是否在数据库中。在给定场景中，我们检索了反英雄列表中的第一条数据，并使用`assertThat(antiHero).isEqualTo(savedAntiHero);`来检查我们检索到的数据是否与我们实例化的数据相等。
- en: Next, let’s now write the test for `updateAntiHeroMethod();`. The possible test
    case for the following method is to check whether the method successfully modifies
    a piece of information for a specific entity in our database.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，现在让我们编写`updateAntiHeroMethod();`的测试。该方法的可能测试用例是检查该方法是否成功修改了我们数据库中特定实体的信息。
- en: 'Let’s have a look at the example unit test that satisfies the test case here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看满足此测试用例的示例单元测试：
- en: '[PRE119]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: We created a new anti-hero entity in the preceding code example and inserted
    it into our database using the `addAntiHero()` method. After adding the entity,
    we updated the added anti-hero’s house information to `"San Francisco"` and saved
    it in our database using `updateAntiHeroMethod()`. Lastly, we have retrieved the
    modified anti-hero using its ID and validated that the house information was modified
    by adding the `assertThat(foundAntiHero.getHouse()).isEqualTo("San` `Francisco");`
    assertion.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了一个新的反英雄实体，并使用`addAntiHero()`方法将其插入到我们的数据库中。在添加实体后，我们更新了添加的反英雄的住宅信息为`"San
    Francisco"`，并使用`updateAntiHeroMethod()`将其保存到数据库中。最后，我们使用其ID检索了修改后的反英雄，并通过添加`assertThat(foundAntiHero.getHouse()).isEqualTo("San`
    `Francisco");`断言来验证住宅信息是否已修改。
- en: Next, we would now create a unit test for the `removeAntiHeroById()` method.
    The possible test case for the method is to validate whether an entity with a
    corresponding ID has successfully been deleted from the database.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们现在将为`removeAntiHeroById()`方法创建一个单元测试。该方法可能的测试用例是验证具有相应ID的实体是否已成功从数据库中删除。
- en: 'Let’s have a look at the example unit test that satisfies the test case:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看满足此测试用例的示例单元测试：
- en: '[PRE120]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: In the preceding example, we can see that we have added some additional elements
    in writing our unit test; we have created a new instance of `Executable()`, where
    we have placed our main code. We have asserted our `Executable()` with `NotFoundException.class`.
    The main reason for this is that we expect that `findAntiHeroByID()` will return
    the `NotFoundException` error, as we have deleted the entity in our database.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到我们在编写单元测试时添加了一些额外的元素；我们创建了一个新的`Executable()`实例，其中放置了我们的主要代码。我们用`NotFoundException.class`断言了我们的`Executable()`。这样做的主要原因是我们期望`findAntiHeroByID()`将返回`NotFoundException`错误，因为我们已经从我们的数据库中删除了实体。
- en: Remember that when asserting errors, we should use `assertThrows()`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在断言错误时，我们应该使用`assertThrows()`。
- en: We have successfully written a test for our services and now, we will implement
    unit tests at the repository level.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功为我们的服务编写了测试，现在，我们将实现仓库级别的单元测试。
- en: Testing a repository
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试仓库
- en: Writing a test for the repository of our application is mostly the same as how
    we write our tests at the service level; we also treat them as services and we
    test them if there are additional methods added to the repository.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的应用程序的仓库编写测试与我们在服务级别编写测试的方式大致相同；我们也把它们当作服务来对待，并在仓库中添加了额外的方法时对它们进行测试。
- en: 'The example that we will take is writing a unit test for our `UserRepository`.
    Let’s have a recap of the methods that `UserRepository` possesses:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用的例子是编写我们的`UserRepository`的单元测试。让我们回顾一下`UserRepository`拥有的方法：
- en: '`Boolean selectExistsEmail(String email)`: Returns `true` when the user exists
    with the given email'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean selectExistsEmail(String email)`: 当用户存在给定邮箱时返回`true`'
- en: '`UserEntity findByEmail(String email)`: Returns the user when the given email
    exists in the database'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserEntity findByEmail(String email)`: 当给定邮箱存在于数据库中时返回用户'
- en: To start writing our test, first, we will create a new package named `user.repository`
    under the `com.example.springbootsuperheroes.superheroes` package, and we will
    make a new class called `UserRepositoryTest`. After successfully creating the
    repository, we will annotate the class with `@DataJPATest` so that it focuses
    only on the JPA components and inject `AntiHeroRepostiory` using the `@``Autowired`
    annotation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写我们的测试，首先，我们将在`com.example.springbootsuperheroes.superheroes`包下创建一个名为`user.repository`的新包，并创建一个名为`UserRepositoryTest`的新类。在成功创建仓库后，我们将使用`@DataJPATest`注解该类，使其仅关注JPA组件，并使用`@Autowired`注解注入`AntiHeroRepostiory`。
- en: 'Our class will now look as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的类将如下所示：
- en: '[PRE121]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Now, we can write our tests after successfully injecting the repository. First,
    we want to write a test for the `selectExistsEmail()` method. The possible test
    case for the method is that it should return `true` if the email exists in our
    database.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在成功注入仓库后，我们可以编写我们的测试。首先，我们想要为`selectExistsEmail()`方法编写一个测试。该方法的可能测试用例是，如果邮箱存在于我们的数据库中，它应该返回`true`。
- en: 'Let’s have a look at the following example code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例代码：
- en: '[PRE122]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: We have added an example user entity into our database in the example unit test.
    The `selectExistsEmail()` method is expected to return `true`. This should retrieve
    the added user with the given email.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例单元测试中，我们已经将一个示例用户实体添加到我们的数据库中。`selectExistsEmail()`方法预期将返回`true`。这应该检索给定邮箱添加的用户。
- en: The next test is for the `findByEmail()` method; this is almost similar to the
    test we have created for the `selectExistsEmail()` method. The only thing we need
    to modify is the assertion, as we are expecting a return value of the `User` type.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试是为`findByEmail()`方法；这几乎与为`selectExistsEmail()`方法创建的测试相同。唯一需要修改的是断言，因为我们期望返回`User`类型的值。
- en: 'Let’s have a look at the following example code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例代码：
- en: '[PRE123]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We have successfully written a test for our services and repository with JUnit,
    AssertJ, and the H2 database. In the next section, we will use the second implementation
    on writing unit tests using JUnit and AssertJ with Mockito.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用JUnit、AssertJ和H2数据库成功为我们的服务和仓库编写了测试。在下一节中，我们将使用JUnit和AssertJ的第二个实现来编写单元测试，并使用Mockito。
- en: Writing tests in a service using Mockito
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mockito在服务中编写测试
- en: In the previous section, we created our unit tests using the H2 database; in
    this approach, we will completely omit the use of the database and utilize the
    concept of mocking in creating sample data in our unit tests. We will achieve
    this by using **Mockito**. Mockito is a mocking framework in Java that allows
    us to test classes in isolation; it does not require any databases.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用 H2 数据库创建了我们的单元测试；在这个方法中，我们将完全省略数据库的使用，并在单元测试中利用模拟的概念来创建样本数据。我们将通过使用
    **Mockito** 来实现这一点。Mockito 是一个 Java 模拟框架，允许我们隔离测试类；它不需要任何数据库。
- en: 'It will enable us to return dummy data from a mocked object or service. Mockito
    is very useful, as this makes unit testing less complex, especially for larger
    applications, as we don’t want to test the services and dependencies simultaneously.
    The following are the other benefits of using Mockito:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够从模拟的对象或服务中返回虚拟数据。Mockito 非常有用，因为它使得单元测试变得更加简单，尤其是在大型应用程序中，因为我们不想同时测试服务和依赖项。以下是使用
    Mockito 的其他好处：
- en: '**Supports return values**: Supports mocking return values.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持返回值**：支持模拟返回值。'
- en: '**Supports exceptions**: Can handle exceptions in unit tests.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持异常**：可以在单元测试中处理异常。'
- en: '**Supports annotation**: Can create mocks using annotation.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持注解**：可以使用注解创建模拟。'
- en: '**Safe from refactoring**: Renaming method names or changing the order of parameters
    will not affect the tests, as mocks are created at runtime.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全于重构**：重命名方法名称或更改参数的顺序不会影响测试，因为模拟是在运行时创建的。'
- en: Let’s explore the different features of Mockito for writing unit tests.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 Mockito 的不同功能，以编写单元测试。
- en: Adding behavior
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加行为
- en: Mockito contains the `when()` method where we can mock the object return value.
    This is one of the most valuable features of Mockito, as we can define a dummy
    return value of a service or a repository.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 包含 `when()` 方法，我们可以用它来模拟对象的返回值。这是 Mockito 最有价值的功能之一，因为我们可以为服务或仓库定义一个虚拟的返回值。
- en: 'Let’s have a look at the following code example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码示例：
- en: '[PRE124]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: In the preceding code example, we can see that we have mocked `HeroService`
    in our test. We have done this to isolate the class and not test the functionality
    of `Heroservice` itself; what we want to test is just the functionality of `HeroApp`.
    We have added behavior for the `heroService.getHouse()` method by specifying a
    mock return `thenReturn()` method. In this case, we expect that the `getHouse()`
    method will return a value of `"``San Francisco"`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们在测试中模拟了 `HeroService`。我们这样做是为了隔离类，而不是测试 `Heroservice` 本身的功能；我们想要测试的是
    `HeroApp` 的功能。我们通过指定模拟返回 `thenReturn()` 方法为 `heroService.getHouse()` 方法添加了行为。在这种情况下，我们期望
    `getHouse()` 方法返回 `"San Francisco"` 的值。
- en: Verifying behavior
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证行为
- en: The next feature that we can use from Mockito is behavior verification in unit
    tests. This allows us to verify whether the mocked method is called and executed
    with parameters. This can be achieved using the `verify()` method.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 Mockito 中使用的下一个功能是单元测试中的行为验证。这允许我们验证模拟的方法是否被调用并带有参数执行。这可以通过使用 `verify()`
    方法来实现。
- en: 'Let’s take the same class example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以相同的类示例为例：
- en: '[PRE125]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: In the preceding code example, we can see that we have added `verify(heroService).getHouse()`
    to our code. This validates whether we have called the `getHouse()` method. We
    can also validate whether the method is called with some given parameters.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们在代码中添加了 `verify(heroService).getHouse()`。这验证了我们是否调用了 `getHouse()`
    方法。我们还可以验证该方法是否带有一些给定的参数被调用。
- en: Expecting calls
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 期望调用
- en: '`times(n)` method. At the same time, we can also validate whether it has been
    called using the `never()` method.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`times(n)` 方法。同时，我们还可以使用 `never()` 方法验证它是否被调用。'
- en: 'Let’s have a look at the following example code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例代码：
- en: '[PRE126]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: In the preceding code example, we can see that we have used the `times(2)` method
    to validate whether the `getName()` method from `heroService` has been called
    two times. We have also used the `never()` method, which checks that the `getPowers()`
    method has not been called.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们可以看到我们使用了 `times(2)` 方法来验证 `heroService` 的 `getName()` 方法是否被调用了两次。我们还使用了
    `never()` 方法，它检查 `getPowers()` 方法是否没有被调用。
- en: 'Mockito, other than `times()` and `never()`, also provides additional methods
    to validate the expected call counts, and these methods are the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito 除了 `times()` 和 `never()` 之外，还提供了其他方法来验证预期的调用次数，这些方法如下：
- en: '`atLeast (int min)`: Validates whether the method is called at least *n* times'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atLeast (int min)`: 验证方法是否至少被调用*n*次'
- en: '`atLeastOnce ()`: Validates whether the method is called at least once'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atLeastOnce ()`: 验证方法是否至少被调用一次'
- en: '`atMost (int max)`: Validates whether the method is called at most *n* times'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atMost (int max)`: 验证方法是否最多被调用*n*次'
- en: Exception handling
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: Mockito also provides exception handling in unit tests; it allows us to throw
    exceptions on mocks to test errors in our application.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito还在单元测试中提供了异常处理；它允许我们在模拟上抛出异常以测试应用程序中的错误。
- en: 'Let’s have a look at the following example code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的示例代码：
- en: '[PRE127]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In the preceding example, we have configured `heroService.getHouse()`, once
    it is called, to throw `RunTimeException`. This will allows us to test and cover
    the error blocks in our application.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们配置了`heroService.getHouse()`，一旦被调用，就抛出`RunTimeException`。这将允许我们测试并覆盖应用程序中的错误块。
- en: We have learned about the different features available in Mockito. Now, let’s
    proceed with writing our tests in our Spring Boot application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了Mockito中可用的不同功能。现在，让我们继续在我们的Spring Boot应用程序中编写我们的测试。
- en: Mockito in Spring Boot
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Boot中的Mockito
- en: In this section, we will now implement Mockito for writing unit tests in our
    Spring Boot application. We will be writing tests for our service again, and we
    will create another package under our `test/java` folder, which will be used for
    our unit tests using Mockito; we will make `com.example.springbootsuperheroes.superheroes.antiHero.service`.
    Under the newly created package, we will create a new class named `AntiHeroServiceTest`,
    where we will start writing our tests for `AntiHeroService`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们现在将在我们的Spring Boot应用程序中实现Mockito以编写单元测试。我们将再次为我们的服务编写测试，并在我们的`test/java`文件夹下创建另一个包，该包将用于使用Mockito进行单元测试；我们将创建`com.example.springbootsuperheroes.superheroes.antiHero.service`。在新创建的包下，我们将创建一个名为`AntiHeroServiceTest`的新类，我们将开始编写对`AntiHeroService`的测试。
- en: 'After successfully creating our class, we will need to annotate the class with
    `@ExtendWith(MockitoExtension.class)` to be able to use the Mockito methods and
    features. The next step is to mock our `AntiHeroRepository` and inject it into
    our `AntiHeroRepositoryService`. To accomplish this, we would use the `@Mock`
    annotation with the declared repository and the `@InjectMocks` annotation with
    the declared service, and our class would now look as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功创建我们的类之后，我们需要使用`@ExtendWith(MockitoExtension.class)`注解我们的类，以便能够使用Mockito的方法和功能。下一步是模拟我们的`AntiHeroRepository`并将其注入到我们的`AntiHeroRepositoryService`中。为了完成这个任务，我们将使用`@Mock`注解来声明仓库，并使用`@InjectMocks`注解来声明服务，此时我们的类将如下所示：
- en: '[PRE128]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In the preceding example, we successfully mocked our repository and injected
    it into our service. We can now start mocking our repository’s return values and
    behavior in our tests.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们成功模拟了我们的仓库并将其注入到我们的服务中。现在，我们可以开始在测试中模拟仓库的返回值和行为。
- en: Let’s have some example tests in our `AntiHeroService`; in an example scenario,
    we will write a test for the `addAntiHero()` method. The possible test case for
    this one is to verify whether the `save()` method from the repository is called
    and the anti-hero is successfully added.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`AntiHeroService`中添加一些示例测试；在一个示例场景中，我们将为`addAntiHero()`方法编写一个测试。这个测试的可能用例是验证仓库中的`save()`方法是否被调用，并且反英雄是否成功添加。
- en: 'Let’s have a look at the example code here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的示例代码：
- en: '[PRE129]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In the preceding example, the first step is always to create a sample entity
    that we can use as a parameter for adding a new anti-hero; after invoking the
    `addAntiHero()` method that we are testing, we have verified whether the `save()`
    method of `AntiHeroRepository` has been invoked using the `verify()` method.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，第一步始终是创建一个样本实体，我们可以将其用作添加新反英雄的参数；在调用我们正在测试的`addAntiHero()`方法之后，我们使用`verify()`方法验证了`AntiHeroRepository`的`save()`方法是否被调用。
- en: We have also used `ArgumentCaptor` to capture the argument values we have used
    in the previous way, which will be used for further assertions. In this case,
    we have asserted that the captured anti-hero is equal to the anti-hero instance
    we have created.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`ArgumentCaptor`来捕获我们之前使用的方式中使用的参数值，这些值将被用于进一步的断言。在这种情况下，我们断言捕获的反英雄等于我们创建的反英雄实例。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: With this, we have reached the end of this chapter. Let’s have a recap of the
    valuable things you have learned; you have learned about the concepts of JUnit,
    which is a testing framework that offers features such as fixtures, test suites,
    and classes to test the methods in our application. You have also learned about
    the application of AssertJ with JUnit, which provides a more flexible way of asserting
    objects in our unit tests; and lastly, you have also learned about the importance
    of Mockito, which provides us with the ability to mock objects and services.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经到达了本章的结尾。让我们回顾一下你学到的宝贵知识；你学习了JUnit的概念，JUnit是一个提供诸如固定值、测试套件和用于测试我们应用中方法的类等功能的测试框架。你还学习了JUnit中AssertJ的应用，它为我们的单元测试提供了更灵活的断言对象的方式；最后，你还学习了Mockito的重要性，它为我们提供了模拟对象和服务的能力。
- en: In the next chapter, we will now develop our frontend application using Angular.
    We will discuss how to organize our features and modules, structure our components
    inside our Angular file structure, and add Angular Material to the user interface.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Angular开发我们的前端应用程序。我们将讨论如何组织我们的功能和模块，在Angular文件结构中构建我们的组件，并将Angular
    Material添加到用户界面中。
- en: 'Part 3: Frontend Development'
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：前端开发
- en: 'This part contains a real-world scenario of developing an Angular 13 application.
    The following chapters are covered in this part:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含了一个开发Angular 13应用程序的真实场景。以下章节包含在本部分中：
- en: '[*Chapter 10*](B18159_10.xhtml#_idTextAnchor188), *Setting Up Our Angular Project
    and Architecture*'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18159_10.xhtml#_idTextAnchor188), *设置我们的Angular项目和架构*'
- en: '[*Chapter 11*](B18159_11.xhtml#_idTextAnchor203), *Building Reactive Forms*'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18159_11.xhtml#_idTextAnchor203), *构建响应式表单*'
- en: '[*Chapter 12*](B18159_12.xhtml#_idTextAnchor224), *Managing States with NgRx*'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18159_12.xhtml#_idTextAnchor224), *使用NgRx管理状态*'
- en: '[*Chapter 13*](B18159_13.xhtml#_idTextAnchor253), *Saving, Deleting, and Updating
    with NgRx*'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18159_13.xhtml#_idTextAnchor253), *使用NgRx进行保存、删除和更新*'
- en: '[*Chapter 14*](B18159_14.xhtml#_idTextAnchor275), *Adding Authentication in
    Angular*'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18159_14.xhtml#_idTextAnchor275), *在Angular中添加身份验证*'
- en: '[*Chapter 15*](B18159_15.xhtml#_idTextAnchor293), *Writing Tests in Angular*'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B18159_15.xhtml#_idTextAnchor293), *在Angular中编写测试*'
