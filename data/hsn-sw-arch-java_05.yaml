- en: 'Chapter 4: Best Practices for Design and Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：设计和开发的最佳实践
- en: The developers reading this book have probably viewed the previous chapters
    as appetizers. If that's the case, with this chapter, we are moving on to the
    main course. While collecting requirements and designing the architecture are
    crucial steps (I cannot highlight this enough), anyone who comes from a development
    background will surely want to get their hands dirty with code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本书的开发者可能将前几章视为开胃菜。如果是这样，随着本章，我们将进入主菜。虽然收集需求和设计架构是关键步骤（我无法强调这一点的重要性），但任何有开发背景的人肯定都希望亲自动手编写代码。
- en: In this chapter, we will focus on how to implement the concepts that we have
    theorized so far in the source code. Of course, in the real world, the edges are
    not so smooth, and the architectural design (including **UML** or **C4** schemas)
    and requirements management will continue during the implementation phase. However,
    in this chapter, we will focus on some well-known techniques to translate those
    design ideas into working software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于如何将我们迄今为止理论化的概念实现到源代码中。当然，在现实世界中，边缘并不那么平滑，架构设计（包括**UML**或**C4**图）和需求管理将在实施阶段继续进行。然而，在本章中，我们将专注于将那些设计思想转化为工作软件的一些知名技术。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Understanding **Domain Driven Design** (**DDD**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**领域驱动设计**（**DDD**）
- en: Introducing **Test Driven Development** (**TDD**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍**测试驱动开发**（**TDD**）
- en: Exploring **Behavior Driven Development** (**BDD**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索**行为驱动开发**（**BDD**）
- en: User story mapping and value slicing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户故事映射和值切片
- en: Case studies and examples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究和示例
- en: After reading this chapter, you will be able to model complex use cases into
    elegant software concepts and define domains, objects, and patterns. You will
    learn how to use TDD and BDD to conduct development activities and implement meaningful
    use cases with each release. You will understand the concept of **Minimum Viable
    Products** (**MVPs**) and the technique of value slicing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，您将能够将复杂的使用案例建模成优雅的软件概念，并定义领域、对象和模式。您将学习如何使用TDD和BDD进行开发活动，并在每次发布中实现有意义的用例。您将理解**最小可行产品**（**MVPs**）和值切片技术。
- en: But first, we'll start with DDD, which will provide a solid foundation to build
    upon.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们将从DDD开始，这将为构建坚实的基础。
- en: Understanding Domain Driven Design
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解领域驱动设计
- en: DDD takes its name from the book of the same name by Eric Evans (2003). The
    subtitle beautifully clarifies what the goal is—**Tackling complexity in the heart
    of software**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DDD的名字来源于埃里克·埃文斯（2003年）的同名书籍。副标题完美地阐明了目标——**解决软件核心的复杂性**。
- en: In this section, we will learn about the domain model, ubiquitous language,
    layered architecture, DDD patterns, and bounded contexts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习关于领域模型、通用语言、分层架构、DDD模式和边界上下文的内容。
- en: DDD is a widely adopted modeling technique to build rich and expressive domains.
    It is considered to be behind modern approaches such as microservices development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DDD是一种广泛采用的建模技术，用于构建丰富和表达性的领域。它被认为是现代方法，如微服务开发背后的技术。
- en: The idea behind DDD is discovering how to model our software in a way that mirrors
    the problem we are facing in the real world. It is expected that if properly modeled,
    our software will be readable, will adhere to requirements, and will work properly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: DDD背后的理念是发现如何以反映我们在现实世界中遇到的问题的方式来对我们的软件进行建模。预期如果建模得当，我们的软件将是可读的，将遵循需求，并且能够正常工作。
- en: 'Of course, there is no magic recipe for that: DDD provides a toolkit of patterns,
    best practices, and ideas to implement this modeling. This approach works particularly
    well with complex domains, but it might be overkill for smaller and simpler projects.
    Additionally, it is true that DDD provides a lot of good ideas, and you might
    consider adopting it partially if that fits your needs. But first, let''s begin
    with some considerations about the completeness of the domain model.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有魔法配方：DDD提供了一套模式、最佳实践和想法的工具包，以实现这种建模。这种方法特别适用于复杂领域，但对于较小和较简单的项目可能有些过度。此外，确实DDD提供了许多好想法，如果您觉得适合您的需求，您可能考虑部分采用它。但首先，让我们从关于领域模型完整性的考虑开始。
- en: The anemic domain model
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚弱领域模型
- en: In his seminal paper about this domain model, Martin Fowler defines the **anemic
    domain model** as an antipattern, which defies any basic purpose of **object-oriented
    programming**. Of course, I cannot disagree with that at all. Nevertheless, this
    kind of modeling is far too widespread, as it's a kind of quick and dirty way
    to design an application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在他关于这种领域模型的经典论文中，Martin Fowler将**贫血领域模型**定义为一种反模式，它违背了面向对象编程的基本目的。当然，我完全同意这一点。然而，这种建模方式过于普遍，因为它是一种快速且简单的设计应用的方法。
- en: Essentially, in the anemic domain model, each object maps with its real-world
    counterpart, including fields and relationships. Those are, in a way, kinds of
    data objects. What's missing in the anemic domain model's objects is the behavior,
    meaning the specific actions that are logically associated with that particular
    concept in the real world. Usually, the objects in an anemic domain model have
    getter and setter methods, and not much more. All of the behavior is codified
    as part of specific service objects, operating across all of the other data objects
    through specific methods.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在贫血领域模型中，每个对象都与其实际世界的对应物相对应，包括字段和关系。这些在某种程度上是数据对象。贫血领域模型的对象中缺失的是行为，即与该特定概念在现实世界中逻辑相关的特定动作。通常，贫血领域模型中的对象有获取器和设置器方法，没有更多。所有行为都被编码为特定服务对象的一部分，通过特定方法在所有其他数据对象上操作。
- en: The issue, here, is that the domain model is simply slipping away from object-oriented
    programming and toward an overengineered procedural model. This could be good
    enough in simple scenarios and, indeed, is common in **Create, Read, Update, and
    Delete** (**CRUD**) applications over a relational database, where you are, more
    or less, exposing tables directly as an application, with very limited business
    logic on top.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于领域模型正逐渐从面向对象编程滑向一个过度设计的程序模型。在简单场景下，这或许足够好，实际上，在基于关系数据库的**创建、读取、更新和删除**（**CRUD**）应用中，这种情况很常见，你几乎是将表格直接暴露为应用，并且在上层只有非常有限的业务逻辑。
- en: If the model is bigger, and it encompasses more complete business logic, this
    way of modeling starts to show some limits. The data objects become similar, and
    it's harder to group them and define relationships. The service objects have more
    and more methods, with growing complexity. You start to gain the cons of both
    the procedural and object-oriented methods. After all, you have very few (if any)
    of the pros of object-oriented modeling. DDD aims for the opposite—building rich
    and expressive object-oriented designs. Let's examine how to start modeling applications
    on DDD principles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型更大，并且包含了更完整的业务逻辑，这种建模方式开始显示出一些局限性。数据对象变得相似，难以将它们分组并定义关系。服务对象的方法越来越多，复杂性也在增长。你开始感受到程序和面向对象方法的缺点。毕竟，你几乎没有（如果有的话）面向对象建模的优点。DDD的目标正好相反——构建丰富且具有表现力的面向对象设计。让我们来看看如何根据DDD原则开始建模应用。
- en: Understanding ubiquitous language
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解通用语言
- en: Indeed, the very first concept of DDD is the principle of good collaboration.
    To define a good domain model, you have to use both technical language and business
    language.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，领域驱动设计（DDD）的第一个概念就是良好的协作原则。为了定义一个好的领域模型，你必须使用技术语言和业务语言。
- en: This means having a team composed of domain experts besides software developers.
    *But how will those kinds of people cooperate when they speak different languages?*
    You will require a lingua franca to ensure they work together.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着团队由领域专家和软件开发者组成。*但是当这些人使用不同的语言时，他们将如何合作呢？* 你将需要一个通用语来确保他们能够共同工作。
- en: The concept around the ubiquitous language is simple and brilliant, that is,
    to define a shared dictionary for a business (for instance, analysts, domain experts,
    or whoever you want to include) and developers to talk together with fewer misunderstandings.
    However, it's a kind of abstract concept, and there is no magic recipe to achieve
    it. You can think about it as a shared culture built into the team. Unfortunately,
    no one has defined a template document or a kind of diagram that can solve the
    ubiquitous language challenge for everybody.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通用语言的概念简单而巧妙，即定义一个业务（例如，分析师、领域专家或你希望包括的任何人）和开发者之间共享的字典，以便他们可以更少地产生误解地进行交流。然而，这是一个抽象的概念，没有神奇的配方可以实现它。你可以将其视为团队中内置的共享文化。不幸的是，没有人定义一个模板文档或某种图表，可以解决每个人的通用语言挑战。
- en: Indeed, what's advised in DDD's essential literature is to use UML diagrams
    (especially class diagrams) and written documents (no particular format is required).
    However, what's essential is how you get to the shared understanding of ubiquitous
    language, and there is probably only one way to do this—by working together.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，DDD基本文献中建议使用UML图（特别是类图）和书面文档（不需要特定的格式）。然而，关键是如何达到对通用语言的共同理解，可能只有一种方法——通过共同工作。
- en: Ubiquitous language is all about how to name the concepts in your model properly.
    And by concepts, we are not necessarily referring to **Java** classes (as they
    are an implementation detail), nor to business processes (as, perhaps, they are
    not mapped one to one in our application). We are referring to something in the
    middle, that is, a model that is understandable and makes sense for a business
    and is translatable in meaningful ways into software artifacts by developers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通用语言的核心是如何恰当地命名模型中的概念。通过概念，我们不一定是指**Java**类（因为它们是实现细节），也不是指业务流程（因为，也许，它们在我们的应用程序中不是一对一映射的）。我们指的是中间的东西，即一个对业务有可理解性和意义，并且可以通过开发者以有意义的方式翻译成软件工件的模型。
- en: Of course, the model will comprehend objects, the relationships behind them,
    and the actions they perform. It is also essential for the team to share the meanings
    of each operation. Simply defining the name of each interaction might not solve
    any ambiguities. Once a shared understanding has been reached (it might be a recurrent
    effort with many cycles), then it must be strictly respected.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，模型将理解对象、它们背后的关系以及它们执行的操作。对于团队来说，共享每个操作的含义也是至关重要的。仅仅定义每个交互的名称可能无法解决任何歧义。一旦达成共同理解（可能是一个反复进行、包含多个循环的努力），就必须严格遵守。
- en: This includes using the naming consistently in code and in all of the other
    artifacts produced (such as analysis documents, test plans, and more), as well
    as referring to things with the right name in meetings and documenting this shared
    understanding in some way (as I said, the format is up to you). As we discussed
    earlier, ubiquitous language is all about creating a shared culture in a working
    team across different specialties.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括在代码和所有其他产生的工件（如分析文档、测试计划等）中一致地使用命名，以及在会议中用正确的名称指代事物，并以某种方式记录这种共同理解（正如我所说的，格式由你决定）。正如我们之前讨论的，通用语言的核心是创建一个跨不同专业的工作团队中的共享文化。
- en: The concept might appear abstract; nevertheless, it is essential and can be
    a useful tool even if you are not fully going with DDD. However, DDD also defines
    more concrete concepts, such as **layered architecture**, which we will look at
    in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可能看起来很抽象；然而，它是基本的，即使你不完全采用DDD，它也可以是一个有用的工具。然而，DDD还定义了更具体的概念，如**分层架构**，我们将在下一节中探讨。
- en: Getting familiar with layered architecture
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉分层架构
- en: When we start to define the conceptual model around our application, it's natural
    to wonder where this model practically fits in our implementation and how to keep
    it pure, regardless of the technology we are using. Think about persistence (the
    database), the **User Interface** (**UI**), and such. Those technologies probably
    have constructs that differ from our model. They might not even be object-oriented
    at all. And for sure, we don't want a change driven by technological reasons (such
    as the optimization of a query or a change in the UI) to affect our domain model.
    DDD tackles this concept directly by suggesting a layered architecture approach.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始定义围绕我们应用程序的概念模型时，自然会想知道这个模型在实际实施中如何定位，以及如何保持其纯粹性，无论我们使用什么技术。考虑持久性（数据库）、**用户界面**（UI）等。这些技术可能具有与我们模型不同的结构。它们甚至可能根本不是面向对象的。当然，我们不希望技术原因（如查询优化或UI的变化）导致我们的领域模型受到影响。领域驱动设计（DDD）通过建议分层架构方法直接处理这个概念。
- en: Here, the idea is to partition the application code into different layers, loosely
    coupled to each other. Then, you implement your domain model into one of those
    layers, encapsulating the technological details in the other layers, each one
    with well-defined responsibilities.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，想法是将应用程序代码划分为不同的层，它们之间松散耦合。然后，你将领域模型实现到这些层中的一层，将技术细节封装在其他层中，每一层都有明确的职责。
- en: 'A simple and common example of this is with the four layers divided, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单且常见的例子是将四个层次划分为以下部分：
- en: '![Figure 4.1 – Layered architecture'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 分层架构'
- en: '](img/Figure_4.01_B16354.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.01](img/Figure_4.01_B16354.jpg)'
- en: Figure 4.1 – Layered architecture
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 分层架构
- en: 'As you can see, the layered architecture is divided as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，分层架构被划分为以下几部分：
- en: '**Presentation Layer**: This layer includes all of the code required to present
    and collect the data for users. Additionally, this could include machine-to-machine
    interactions (such as in API calls).'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：这一层包括所有用于向用户展示和收集数据的代码。此外，这还可能包括机器到机器的交互（例如，在API调用中）。'
- en: '**Application Layer**: This layer is similar to what''s implemented in the
    **Backends for Frontends** pattern (we''ll cover this in [*Chapter 6*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141),
    *Exploring Essential Java Architectural Patterns*). Essentially, this layer is
    a proxy, stateless and without business logic, which simply coordinates the interactions
    between the presentation layer and the rest of the application.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这一层类似于在**前后端分离模式**（我们将在[*第6章*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141)，*探索核心Java架构模式*中介绍）中实现的内容。本质上，这一层是一个代理，无状态且没有业务逻辑，它仅仅协调表示层与其他应用部分之间的交互。'
- en: The application layer can store session data and perform basic orchestration
    (such as aggregating or ordering calls to the underlying layers). In my opinion,
    this layer can be considered optional in some kinds of applications. The risk
    is that if you avoid it, it will couple the presentation layer tightly to the
    rest of the architecture. On the other hand, if you decide to adopt it, you should
    be mindful of the risk of sneaking in too much business logic.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层可以存储会话数据并执行基本编排（例如，对底层层的调用进行聚合或排序）。在我看来，在某些类型的应用中，这一层可以被认为是可选的。风险是，如果你避免使用它，它将紧密地将表示层与其他架构部分耦合在一起。另一方面，如果你决定采用它，你应该注意过多引入业务逻辑的风险。
- en: '**Domain Layer**: This layer is, of course, the core of proper DDD. Here lies
    the whole business model, adherent to what we are representing, in terms of objects,
    their state, and their behavior. The domain layer exposes the functionalities
    of the higher levels and uses the underlying layer for technical matters.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域层**：当然，这一层是正确实现领域驱动设计（DDD）的核心。整个商业模式，包括我们所代表的对象、其状态和其行为，都位于这一层。领域层暴露了更高层的功能，并使用底层来处理技术问题。'
- en: '**Infrastructure Layer**: This layer is a supporting layer that deals with
    all of the other layers. It can be defined as the glue between the layers themselves
    and the technological layers providing functionalities. Here, a classic feature
    is persistence—objects in the domain layer use features exposed by the infrastructure
    layer, which deals with the database (or other persistent technology) using its
    native protocols and libraries.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施层**：这一层是一个支持层，处理所有其他层。它可以被定义为层与层之间的粘合剂，以及提供功能的科技层。在这里，一个经典的功能是持久性——领域层中的对象使用基础设施层暴露的功能，该层使用其本地的协议和库来处理数据库（或其他持久化技术）。'
- en: This organization might look familiar to you, as it's described in various forms
    and variants in the software area (you might find some similarities with the **Model-View-Controller**
    pattern, which we will examine in [*Chapter 6*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141),
    *Exploring Essential Java Architectural Patterns*). However, do take into account
    that this is mostly a way to nicely group responsibilities. It doesn't necessarily
    mean that each layer should be deployed on its own, as a separate process or artifact.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织结构可能对你来说很熟悉，因为它在软件领域以各种形式和变体被描述（你可能会在[*第6章*](B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141)，*探索核心Java架构模式*中找到一些相似之处）。然而，请注意，这主要是一种将责任很好地分组的方法。这并不一定意味着每个层都应该单独部署，作为一个独立的过程或工件。
- en: 'Having discussed layered architecture, let''s focus on the heart of DDD: the
    **Domain Model** and its parts.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了分层架构之后，让我们集中讨论DDD的核心：**领域模型**及其部分。
- en: Learning about the domain model
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解领域模型
- en: The **Domain Model** is an elegant way to represent reality and implement it
    in an object-oriented way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域模型**是一种优雅地表示现实并在面向对象方式中实现它的方法。'
- en: Essentially, you can consider the domain model as the opposite of the anemic
    model that we looked at earlier. In the anemic model, the objects simply include
    data and very limited (or even absent) behavior. The domain model of DDD stresses
    the expressiveness of objects and their behavior.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以将领域模型视为我们之前所讨论的贫血模型的反面。在贫血模型中，对象仅仅包含数据，并且行为非常有限（甚至没有）。DDD 的领域模型强调对象的表达性和它们的行为。
- en: 'Put simply, the domain model is simply the concept of comprehending the data
    and behavior of an application. DDD implements this idea by defining the elements
    detailed in the following sections, as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，领域模型就是理解应用程序的数据和行为的概念。DDD 通过定义以下章节中详细说明的元素来实现这一想法，如图所示：
- en: '![Figure 4.2 – The domain model'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2 – 领域模型'
- en: '](img/Figure_4.02_B16354.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.02_B16354.jpg)'
- en: Figure 4.2 – The domain model
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 领域模型
- en: We will discuss each of the sections next.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论每个部分。
- en: Entities
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体
- en: The **entity** is a core concept of the domain model. Essentially, it is related
    to modeling objects that have an identity and a history throughout the life cycle
    of our use case. The keyword for defining an entity is **identity**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体**是领域模型的一个核心概念。本质上，它与建模在整个用例生命周期中具有身份和历史的对象相关。定义实体的关键字是**身份**。'
- en: 'If an object in our use case has a strong identity concept, it will probably
    map with entities. A classic example is a person: in many use cases (including
    the mobile payments example that we are carrying throughout this book), a person''s
    identity is strongly defined, regardless of the values contained in its representing
    objects. In other words, if I have a person object, made up of the classic name,
    surname, and other details, having two objects with the same name and surname
    does not necessarily mean I am referring to the same person.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用例中的对象具有强烈的身份概念，它很可能与实体相对应。一个经典的例子是个人：在许多用例中（包括我们在整本书中贯穿的移动支付示例），一个人的身份被强烈定义，无论其代表对象中包含的值如何。换句话说，如果我有一个由经典的名字、姓氏和其他细节组成的人对象，有两个具有相同名字和姓氏的对象并不一定意味着我指的是同一个人。
- en: Indeed, I often resort to specific identifying fields (such as a tax code or
    something specific to my application domain—perhaps an account number) to distinguish
    a person object from another one. Moreover, the identity concept will still be
    valid even if the object is persisted (and retrieved). In other words, if I persist
    (or passivate) an entity object somewhere (such as in a database), it should be
    clear that it will refer to the same person (in real life) when it's loaded again.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我经常求助于特定的标识字段（例如税号或与我应用领域相关的东西——可能是一个账户号码）来区分一个人对象与另一个对象。此外，即使对象被持久化（和检索），身份概念仍然有效。换句话说，如果我在某个地方（例如数据库）持久化（或钝化）一个实体对象，那么当它再次被加载时，应该清楚它将指向同一个真实生活中的个人。
- en: 'As is clear, defining an entity is a cross-cutting concern between a business
    and the developers. It is much more than simply identifying a unique field distinguishing
    objects from one another. Consider bank accounts: they are usually identified
    by a standard code that is internationally recognized, at the very least, across
    Europe (IBAN code). However, you might find that a bank account changes the associated
    IBAN code (such as when a merger between different banks occurs). In this case,
    *do the two IBAN codes refer to the same account?* *Will the old account disappear
    and be replaced by a new one?* *Should I instead use a third identifier (such
    as a UUID) to bridge between the two entities and bypass the problem?*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，定义一个实体是业务和开发者之间的一个横切关注点。它远不止是简单地识别一个区分对象的唯一字段。考虑银行账户：它们通常由一个在国际上得到认可的标准化代码来识别，至少在欧洲是这样（IBAN
    代码）。然而，你可能会发现银行账户会更改相关的 IBAN 代码（例如，当不同银行之间的合并发生时）。在这种情况下，*两个 IBAN 代码是否指向同一个账户？*
    *旧账户会消失并被新账户取代吗？* *我应该使用第三个标识符（例如 UUID）来在两个实体之间建立桥梁并绕过这个问题吗？*
- en: Usually, the answer is that it depends. In this scenario, it depends on the
    domain around which your use case is modeled. The identity concept can also be
    different in the same application (in an extended way). Ultimately, an entity
    object is very much related to the point of view you are considering. However,
    for sure, it needs to be an object with a very well-defined identity, regardless
    of the value of its attributes, which links us to a different kind of object—**value
    objects**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，答案是这取决于情况。在这种情况下，这取决于你的用例所基于的领域。在同一个应用中（以扩展的方式），身份概念也可能不同。最终，实体对象与你的视角有很大关系。然而，可以肯定的是，它需要是一个具有非常明确身份的对象，无论其属性值如何，这使我们联系到不同类型的对象——**值对象**。
- en: Value objects
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值对象
- en: Conceptually, value objects complement entity objects. Simply put, in a value
    object, the data inside the fields of the object is more important than the object's
    identity. Value objects simply transport information, and they can be shared,
    copied, and reused with ease. A typical example of a value object is an address
    (such as a city, street name, or zip code). It doesn't matter what the identity
    of each one is; what does matter is the data inside.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，值对象补充了实体对象。简单来说，在值对象中，对象字段中的数据比对象的身份更重要。值对象只是传输信息，它们可以轻松地共享、复制和重用。值对象的典型例子是地址（如城市、街道名称或邮政编码）。每个对象的身份无关紧要；重要的是里面的数据。
- en: 'Value objects should be immutable. Because they are immutable, they are simpler
    to use. One common example is multithreading: multiple threads can access the
    same object instance concurrently, and there is no need for locks, nor any risk
    of inconsistent value (as the value cannot be changed). It''s the same with passing
    object instances to methods: you can be sure that whatever happens, the value
    of the object cannot be changed. Essentially, with immutable objects, the life
    cycle is just easier to manage.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象应该是不可变的。因为它们是不可变的，所以使用起来更简单。一个常见的例子是多线程：多个线程可以同时访问同一个对象实例，无需加锁，也不会有值不一致的风险（因为值不能被更改）。将对象实例传递给方法也是一样：你可以确信无论发生什么，对象的值都不会改变。本质上，使用不可变对象，生命周期更容易管理。
- en: Value objects are usually lighter and safer to manage than entity objects. Additionally,
    they can be part of an entity, that is, our person entity might have a link to
    an address value object. However, you should balance the usage of entities and
    value objects. If you only resort to value objects, you will probably fall into
    an anemic domain. There is still an important thing to discuss regarding object
    content, that is, *where can we put the behavior that doesn't belong to either
    entities or value objects?* The answer is **services**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象通常比实体对象更轻量级且更易于管理。此外，它们可以是实体的一部分，也就是说，我们的个人实体可能有一个链接到地址值对象的链接。然而，你应该平衡实体和值对象的使用。如果你只依赖值对象，你可能会陷入贫血领域。关于对象内容，还有一件重要的事情要讨论，那就是*我们可以将不属于实体或值对象的行为放在哪里？*
    答案是**服务**。
- en: Services
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: As mentioned earlier, entities and value objects are different in terms of identity.
    Instead, they share the grouping around a logical area, including data and behavior.
    In other words, both entities and value objects contain data (class attributes),
    the methods for manipulating it (getters and setters), and more sophisticated
    behavior (the business logic).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，实体和值对象在身份方面是不同的。相反，它们在逻辑区域周围的分组上共享，包括数据和行为。换句话说，实体和值对象都包含数据（类属性）、操作它的方法（获取器和设置器）以及更复杂的行为（业务逻辑）。
- en: What's missing in this model is the cross-cutting behavior. Indeed, there are
    some actions that don't feel right when placed in a particular object. That's
    because those actions involve more than an object type, or they are simply ambiguous.
    It's important to not force those actions into an unrelated object, as this will
    impact the expressiveness of the model. Let's think about our mobile payment example
    again. *Should we put the peer-to-peer payment functionality in the sender or
    receiver account?*
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型缺少的是横切行为。确实，有些动作放在特定对象中感觉不合适。这是因为这些动作涉及到的不仅仅是对象类型，或者它们本身就是模糊的。重要的是不要将这些动作强加给无关的对象，因为这会影响模型的表达能力。让我们再次思考我们的移动支付示例。*我们应该将点对点支付功能放在发送者账户还是接收者账户中？*
- en: 'For all of these scenarios, you can define a **service**. A service explicitly
    maps actions that are directly linked to the domain as a whole, rather than to
    a specific object type. In this way, you can nicely group similar actions together
    without polluting entities or value objects with behavior that doesn''t belong
    there. It''s all about keeping the domain model rationally organized, which is
    also the goal of the next concept: the **aggregate**.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些场景，你可以定义一个**服务**。服务明确地将与整个领域直接相关的动作映射出来，而不是映射到特定的对象类型。这样，你可以很好地将类似动作分组在一起，而不会污染实体或值对象，使其包含不属于那里的行为。这完全是关于保持领域模型合理组织，这也是下一个概念——**聚合**的目标。
- en: Aggregates
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合
- en: We mentioned the concept of **aggregates** in [*Chapter 2*](B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034),
    *Software Requirements – Collecting, Documenting, Managing*, when discussing event
    storming. It's worth saying that the whole idea of event storming is strictly
    related to DDD and one of the ways to put DDD into practice.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034)“软件需求 - 收集、记录、管理”中提到了**聚合**的概念，当时在讨论事件风暴。值得一提的是，事件风暴的整个想法与领域驱动设计（DDD）密切相关，并且是实施DDD的一种方式。
- en: Let's return to the concept of aggregates; it's probably one of the most widely
    known ideas of DDD, and it's also widely used outside of DDD. Put simply, aggregates
    can be seen as transactional boundaries. The basic idea is to group a set of objects
    (that is, entities and/or value objects) by data changes. The objects in an aggregate
    are considered as a whole when it comes to changes to their internal status.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到聚合的概念；这可能是DDD最广为人知的思想之一，并且它也在DDD之外得到广泛应用。简单来说，聚合可以被视为事务边界。基本思想是按数据变化将一组对象（即实体和/或值对象）分组。在聚合中，当涉及到它们内部状态的变化时，这些对象被视为一个整体。
- en: An aggregate has an entry point object, called a **root entity**. Any change
    to any object part of the aggregate must be carried out through the root entity,
    which will then perform changes on the linked entities. That's from a technical
    point of view rather than a domain model point of view. What you are doing is
    invoking operations (or, even better, actions that are as meaningful in the real
    world as in the domain model) in the root entity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合有一个入口对象，称为**根实体**。对聚合中任何对象的任何更改都必须通过根实体进行，然后根实体将对相关实体执行更改。这更多是从技术角度而不是领域模型角度来说的。你所做的是在根实体中调用操作（或者更好的是，在现实世界和领域模型中都具有意义的动作）。
- en: This will also mean changing the linked objects under the hood. However, this
    is an implementation detail. From a logical standpoint, all of the interactions
    with objects in the aggregate are mediated by the root entity. For this reason,
    the aggregate is a core concept in DDD. It strictly maps the consistency of the
    model and can be easily translated into technical concepts such as database transactions.
    Aggregates can then be seen as a sort of **super object** made by the coordination
    of different objects. As such, the construction of an aggregate can become complex.
    For this reason, DDD introduces the **Factory pattern**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将意味着在底层更改相关对象。然而，这是一个实现细节。从逻辑角度来看，与聚合中对象的全部交互都由根实体介导。因此，聚合是DDD中的一个核心概念。它严格映射模型的完整性，可以轻松地转换为技术概念，如数据库事务。然后，聚合可以被视为由不同对象协调的**超级对象**。因此，聚合的构建可能会变得复杂。因此，DDD引入了**工厂模式**。
- en: Glancing at DDD patterns
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速浏览DDD模式
- en: DDD encompasses some patterns to provide support functionalities for the domain
    model, such as building and managing objects (such as entities and value objects).
    The factory pattern is the first pattern that we will look at.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: DDD包含一些模式，为领域模型提供支持功能，例如构建和管理对象（如实体和值对象）。工厂模式是我们将要探讨的第一个模式。
- en: Factory
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂
- en: The **factory** pattern is not a new concept. You can refer to the *Design Patterns*
    book by the Gang of Four, where this has been widely explained. Simply put, if
    you want to programmatically control the creation of an object (or a set of objects
    such as an aggregate), and not rely on the logic of a constructor, you can use
    the factory pattern.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂**模式不是一个新概念。你可以参考四人帮的《设计模式》一书，其中对此有广泛的解释。简单来说，如果你想以编程方式控制对象的创建（或一组对象，如聚合），而不依赖于构造函数的逻辑，你可以使用工厂模式。'
- en: Factory is particularly useful to instantiate an aggregate. By invoking the
    factory pattern on the root element, you will coordinate the creation of the root
    itself and all of the other objects linked to the root (entities and value objects).
    Additionally, you can enforce transactionality on the creation of the objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式特别适用于实例化聚合。通过在根元素上调用工厂模式，你可以协调根本身的创建以及所有与根相关联的其他对象（实体和值对象）。此外，你还可以在对象的创建上强制执行事务性。
- en: If the creation of one of the objects fails, then you might want to abort the
    creation of the whole aggregate. The factory pattern can also be used to recreate
    objects from the database. In this scenario, rather than an instantiation from
    scratch, it's a retrieval of the existing root entity (and the linked subobjects).
    That's fine for addressing the retrieval of a known object (given its identity),
    *but how do you provide different kinds of lookups?* DDD suggests the usage of
    the **Repository pattern**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建一个对象失败，那么你可能想要取消整个聚合的创建。工厂模式也可以用来从数据库中重新创建对象。在这种情况下，它不是从头开始实例化，而是检索现有的根实体（以及相关的子对象）。这对于处理已知对象的检索（给定其标识）是可行的，*但是如何提供不同类型的查找呢？*
    领域驱动设计（DDD）建议使用**仓库模式**。
- en: Repository
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仓库
- en: A **repository**, in the DDD world, is a registry that is used to keep references
    to objects already instantiated (or persisted on a database). Simply put, a repository
    can be used to add, remove, and find objects. When used to find objects, typically,
    a repository acts as a bridge between the domain and the infrastructure layer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计（DDD）的世界里，**仓库**是一个注册表，用于保存已实例化（或已持久化到数据库中）的对象引用。简单来说，仓库可以用来添加、删除和查找对象。当用于查找对象时，通常，仓库充当领域层和基础设施层之间的桥梁。
- en: It helps to decouple the features and hide the implementation details of the
    persistence layer. You can retrieve objects using complex or vendor-specific queries
    in the infrastructure layer, and this is wrapped by an operation in the repository.
    It might even be that the infrastructure layer retrieves objects in different
    ways, such as invoking external web services rather than a database. Nothing will
    change from a repository point of view. The services exposed by the repository
    must have an explicit domain meaning, whereas the internal implementation might
    appear closer to the infrastructure logic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它有助于解耦功能并隐藏持久化层的实现细节。你可以在基础设施层使用复杂或供应商特定的查询来检索对象，这由仓库中的操作封装。甚至可能基础设施层以不同的方式检索对象，例如调用外部Web服务而不是数据库。从仓库的角度来看，这一切都不会改变。仓库公开的服务必须具有明确的领域意义，而内部实现可能看起来更接近基础设施逻辑。
- en: So far, in all of the concepts that we have examined, we have implicitly assumed
    that everything falls under one single domain model. Now, we will learn how to
    make different domains interact with each other by using the concept of a **Bounded
    Context**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们所考察的所有概念中，我们都隐含地假设一切都在一个单一的领域模型之下。现在，我们将学习如何通过使用**有限上下文**的概念，使不同的领域相互交互。
- en: Bounded Context
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限上下文
- en: It is common to identify a domain model using one application. That's a hard
    way to delimit the model boundaries. However, that's not always the case. When
    dealing with large applications, it could be that different models need to coexist.
    This is because a unified model is impractical (that is, too big or too complex),
    or because of the model's conflict (that is, an object has different meanings,
    depending on the point of view and the use cases touching it).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们会使用一个应用程序来识别领域模型。这是一个界定模型边界的方法。然而，情况并不总是如此。当处理大型应用程序时，可能不同的模型需要共存。这是因为统一模型不切实际（即太大或太复杂），或者因为模型存在冲突（即一个对象根据观点和使用案例的不同而具有不同的含义）。
- en: In those scenarios, you might need to define a border around each domain model.
    A bounded context, then, is the area in which ubiquitous language is valid. If
    a bounded context can be seen as a country, with defined borders, ubiquitous language
    is the official (and only) language spoken of that country.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中，你可能需要为每个领域模型定义一个边界。因此，有限上下文是普遍语言有效的区域。如果将有限上下文视为一个有明确边界的国家，那么普遍语言就是该国的官方（也是唯一）语言。
- en: Usually, a bounded context belongs to one team, and it has some well-defined
    coordinates, such as a portion of the code base and other subsets of related technologies
    (such as a defined set of tables of the database). Two different bounded contexts
    cannot share objects, nor call arbitrary methods of each other. The communication
    must follow well-defined interfaces. In order to support the cooperation between
    two different bounded contexts, a context map can be used.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个有界上下文属于一个团队，并且它有一些定义良好的坐标，例如代码库的一部分和其他相关技术的子集（例如数据库中定义的表集）。两个不同的有界上下文不能共享对象，也不能调用彼此的任意方法。通信必须遵循定义良好的接口。为了支持两个不同有界上下文之间的合作，可以使用上下文映射。
- en: 'A context map is a way to translate, when possible, concepts from one bounded
    context to another. There are some patterns suggested by DDD to realize context
    maps. These patterns include the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文映射是一种在可能的情况下将一个有界上下文的概念翻译到另一个有界上下文的方法。DDD 提出了一些模式来实现上下文映射。以下是一些模式：
- en: '**Shared kernel**: This is when two bounded contexts share a subset of the
    domain model. While this technique is easy and intuitive, it can be hard to maintain,
    since the two teams managing the different bounded contexts must agree on any
    changes, and in any case, the risk of breaking functionalities in the other context
    is always present, so every change must be thoroughly tested (automatic is better).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享内核**：这是两个有界上下文共享领域模型的一个子集的情况。虽然这个技术简单直观，但维护起来可能很困难，因为管理不同有界上下文的两个团队必须就任何变更达成一致，并且在任何情况下，破坏其他上下文功能的风险始终存在，因此每个变更都必须彻底测试（自动测试更好）。'
- en: '**Customer supplier**: This is similar, in a way, to the shared kernel approach,
    but the relationship here is asymmetrical. One of the two bounded contexts (the
    supplier) will own the interface, developing and maintaining the features, while
    the customer will simply ask for what is needed. This simplifies the synchronization
    a bit between the two teams. However, it can still create issues when priorities
    and milestones start to clash.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户供应商**：在某种程度上，这与共享内核方法相似，但这里的关系是不对称的。两个有界上下文之一（供应商）将拥有接口，开发和维护功能，而客户只需请求所需的内容。这简化了两个团队之间的同步。然而，当优先级和里程碑开始冲突时，仍然可能产生问题。'
- en: '**Conformity**: This shares the customer-supplier type of relationship. The
    difference here is that the customer domain model completely adopts and imports
    a subset of the supplier domain model, as it did in the shared kernel approach.
    However, unlike shared kernel, the relationship stays asymmetric. This means that
    the customer cannot change (or ask for changes in) the shared model.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：这共享了客户-供应商类型的关系。这里的区别在于，客户领域模型完全采用并导入供应商领域模型的一个子集，就像在共享内核方法中做的那样。然而，与共享内核不同，这种关系保持不对称。这意味着客户不能更改（或请求更改）共享模型。'
- en: '**Anti-corruption layer**: This is a different approach. In this case, there
    is a translator layer between the two domain objects. This layer acts as a demilitarized
    zone, preventing objects and behaviors from sneaking from one bounded context
    to another. This approach is commonly used when dealing with legacy applications,
    more than when two bounded contexts belong to the same application.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反腐败层**：这是一种不同的方法。在这种情况下，两个领域对象之间存在一个翻译层。这个层充当非军事区，防止对象和行为从一个有界上下文偷偷地渗透到另一个有界上下文。这种方法在处理遗留应用程序时更为常见，而不是当两个有界上下文属于同一应用程序时。'
- en: It is worth noting that a proper DDD implementation is not easy to follow. There
    are several common errors that could slip into a DDD architectural design. The
    first and most common is the aforementioned anemic domain model, which is the
    most important reason why you would want to adopt something like DDD. However,
    it's also common to have some technology considerations slip into the domain model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一个适当的 DDD 实现并不容易遵循。在 DDD 架构设计中可能会出现一些常见的错误。首先是前面提到的贫血领域模型，这是你想要采用 DDD
    的最重要的原因。然而，技术考虑因素也可能不小心渗透到领域模型中。
- en: That's particularly true when it comes to the **persistent layer**. It is a
    common practice to design the domain in a way that mimics the database tables
    and relationships (in this case, we are using a relational database as a persistent
    backend). Last but not least, one common error is to design the domain model without
    engaging with domain experts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其适用于**持久层**。设计领域时模仿数据库表和关系是一种常见做法（在这种情况下，我们使用关系型数据库作为持久后端）。最后但同样重要的是，一个常见的错误是在没有与领域专家交流的情况下设计领域模型。
- en: We could be tempted to design everything for the IT department, thinking we
    have a proper understanding of the world we would like to represent. Even if this
    is partially true, it's still worthwhile engaging with business experts, to better
    discuss the business jargon (please refer to the *Understanding ubiquitous language*
    section) and rely on their experience of the specific domain model.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会倾向于为IT部门设计一切，认为我们对想要表示的世界有适当的理解。即使这部分是正确的，与业务专家进行交流仍然值得，以便更好地讨论业务术语（请参阅*理解通用语言*部分）并依靠他们在特定领域模型方面的经验。
- en: This section concludes our brief overview of DDD. As we have learned, DDD provides
    elegant ways in which to realize the ideas we have collected in the previous sections
    (including requirements and architectural designs) and put them into code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本节总结了我们对DDD的简要概述。正如我们所学的，DDD提供了一种优雅的方式来实现我们在前几节中收集的想法（包括需求和架构设计），并将它们转化为代码。
- en: This starts with the concept of ubiquitous language, which we discussed at the
    beginning of this section and is one of the big ideas of DDD, allowing common
    ground between all the stakeholders involved in the application development.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这始于通用语言的概念，我们在本节开头讨论过，是DDD的一个主要思想，它允许所有参与应用程序开发的利益相关者之间达成共识。
- en: Following this, we moved on to the core concepts of DDD, such as the application
    *shape* (the layered architecture), the definition of objects and methods (the
    domain model and the encompassed objects), and the recommended practices (patterns)
    regarding how to address common concerns. A dedicated mention is needed for the
    concept of bounded contexts, which is a way to structure big applications into
    more than one *self-contained* model.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们转向DDD的核心概念，例如应用程序的*形状*（分层架构）、对象和方法定义（领域模型和包含的对象），以及关于如何解决常见问题的推荐实践（模式）。需要特别提及的是边界上下文的概念，这是一种将大型应用程序结构化为多个*自包含*模型的方法。
- en: As we will learn in [*Chapter 9*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230),
    *Designing Cloud-Native Architectures*, DDD has some common ideas with microservices
    architectures.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[*第9章*](B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230)中学习到的，《设计云原生架构》，领域驱动设计（DDD）与微服务架构有一些共同的理念。
- en: In the next section, we will look at another common practice to drive the implementation
    of our design ideas—TDD.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨另一种常见的实践来推动我们设计想法的实现——TDD。
- en: Introducing Test Driven Development
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍测试驱动开发
- en: TDD is a development technique based on a simple idea, that is, no code should
    exist without test coverage.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种基于简单想法的开发技术，即没有测试覆盖的代码不应存在。
- en: In order to pursue this goal, TDD inverts our point of view. Instead of developing
    code, and then writing a unit test to cover its testing, you should start writing
    a test case. Of course, initially, the test case would intentionally fail while
    invocating empty or incomplete functions. However, you will have a clear goal,
    that is, your piece of code is complete when all tests are satisfied.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了追求这个目标，TDD颠倒了我们的观点。不是先开发代码，然后编写单元测试来覆盖测试，你应该先编写测试用例。当然，最初，测试用例会故意失败，调用空或不完整的函数。然而，你将有一个明确的目标，即当所有测试都通过时，你的代码块是完整的。
- en: Starting from the end, you clearly define the boundaries of your software and
    the extent of its functions. Then, you run the tests, which will all fail. You
    keep developing the features, piece after piece, until all of the tests are satisfied.
    Finally, you move to the next piece of code (or class or package)—it's that simple.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从最后开始，你清楚地定义了软件的边界和其功能的范围。然后，你运行测试，所有的测试都会失败。你继续开发特性，一块接一块，直到所有测试都通过。最后，你转向下一块代码（或类或包）——就这么简单。
- en: Remember that this approach doesn't necessarily guarantee any particular quality
    or elegance in your code. Having a test pass does not imply that you are using
    good patterns or efficient solutions. In theory, you might as well simply hardcode
    the expected results to get a green light.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这种方法并不一定保证你的代码具有特定的质量或优雅性。测试通过并不意味着你正在使用良好的模式或高效的解决方案。理论上，你甚至可以直接硬编码预期的结果以获得绿色信号。
- en: However, this technique will have a very useful byproduct, that is, you can't
    forget (or purposefully avoid) to prove/test your code using test cases.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这项技术将产生一个非常有用的副产品，那就是你不会忘记（或故意避免）使用测试用例来证明/测试你的代码。
- en: Anyway, there are several factors to take into account. First of all, some features
    might require external systems to work. You can test the interaction of such systems,
    simulating them with mocks, but of course, this will mean more code to write,
    more components (the mocks themselves), and a further degree of approximation
    (meaning that your test will be less representative of reality). Following this,
    you might need to test things that are less easy to automate, such as UIs and
    interactions with devices (for example, mobile devices). Yes, there are a number
    of solutions for this (such as automating browser navigation), but this will complicate
    things.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，有几个因素需要考虑。首先，一些特性可能需要外部系统才能工作。你可以测试这些系统的交互，通过模拟它们来模拟，但当然，这意味着需要编写更多的代码，更多的组件（模拟本身），以及更高的近似度（这意味着你的测试将不太能代表现实）。接下来，你可能需要测试一些不太容易自动化的东西，比如
    UI 和与设备的交互（例如，移动设备）。是的，有几种解决方案（例如自动化浏览器导航），但这将使事情复杂化。
- en: Let me highlight that, even if this will require a significant amount of effort,
    tests cannot be ditched. Testability is a crucial requirement, and it might also
    be a drive to rearchitect your code base, increasing modularity and simplifying
    it, in order to improve testability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我强调一下，即使这需要大量的努力，测试也不能被丢弃。可测试性是一个关键要求，它也可能成为重构代码库的驱动力，增加模块化并简化它，以提高可测试性。
- en: Moreover, you might have dependencies between the features. This means coordinating
    tests or, worse, having test results depend on the order in which they are running.
    Of course, this is not easy to maintain and, in general, is not a good idea.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能会在特性之间存在依赖关系。这意味着需要协调测试，或者更糟糕的是，测试结果依赖于它们运行的顺序。当然，这不容易维护，通常也不是一个好主意。
- en: In this specific case, you might want to properly structure your tests, in order
    to provide adequate setup and teardown phases, making everything simpler and reproducible
    and greatly increasing the quality of what you are testing. Then, you have to
    think about the granularity of the tests. It can be tempting to create one generic
    test and slip in as many hidden features as you can. On the other hand, if your
    tests are simply unit tests, covering every sub-function, you'll need to aggregate
    them in a meaningful way, in order to track down the advancements in implementing
    the features. In other words, shifting your point of view away from testing specific
    code sections toward testing application behavior.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，你可能想要合理地构建你的测试，以便提供适当的设置和拆卸阶段，使一切更加简单和可重复，并极大地提高测试质量。然后，你必须考虑测试的粒度。可能会诱使你创建一个通用的测试，并尽可能多地包含隐藏的特性。另一方面，如果你的测试仅仅是单元测试，覆盖每个子功能，你需要以有意义的方式聚合它们，以便追踪实现特性的进展。换句话说，改变你的视角，从测试特定的代码部分转向测试应用程序的行为。
- en: This is the idea behind BDD.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 BDD 的理念。
- en: Exploring Behavior Driven Development
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索行为驱动开发
- en: BDD is a technique that extends the TDD approach while also using some DDD concepts.
    In particular, the workflow is the same as TDD, that is, write a test, run it
    (initially, it will fail), and implement the feature until the test succeeds.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 是一种扩展了 TDD 方法同时使用一些 DDD 概念的技术。特别是，工作流程与 TDD 相同，即编写一个测试，运行它（最初，它将失败），然后实现特性直到测试通过。
- en: What changes is how the test is written. Instead of focusing on single functions
    (or, even better, relying on the developer to pick the right granularity), BDD
    defines the extent of each test a bit better. In particular, as highlighted in
    the name of the methodology, BDD tests are focused on the expected behavior, that
    is, the functionality implemented by each use case.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 变化的是测试的编写方式。而不是专注于单个函数（或者，更好的是，依赖开发者选择正确的粒度），BDD定义了每个测试的范围，使其更加明确。特别是，正如方法论名称所强调的，BDD测试专注于预期的行为，即每个用例实现的功能。
- en: In this sense, it is an explicit suggestion to keep high-level functionalities,
    rather than method-by-method unit tests. BDD is also linked to DDD concepts. In
    particular, it is recommended that you use ubiquitous language as a way to specify
    each behavior. In this way, you have an explicit mapping between a business use
    case, expressed with ubiquitous language, translated into an automatic test case.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种意义上，这是一个明确建议保持高级功能，而不是逐个方法的单元测试。BDD也与DDD概念相关。特别是，建议使用通用语言作为指定每个行为的方式。这样，你就有了一个业务用例（用通用语言表达）与自动测试用例之间的明确映射。
- en: 'BDD describes a way to define behaviors. In practice, each behavior is defined
    as a user story, with a structure given as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: BDD描述了一种定义行为的方式。在实践中，每个行为都被定义为一个用户故事，其结构如下所示：
- en: '**As a**: This is a person or a role.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**As a**：这是一个人或一个角色。'
- en: '**I want**: This is a specific functionality.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I want**：这是一个特定的功能。'
- en: '**So that**: This is when we can get some benefits from using that functionality.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**So that**：这是我们可以从使用该功能中获得一些好处的时候。'
- en: 'Provided that a number of scenarios are associated with the user story, each
    scenario is, essentially, an acceptance criterion, which can be easily translated
    into automated use cases:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有多个场景与用户故事相关联，每个场景本质上都是一个验收标准，它可以很容易地转换为自动化用例：
- en: '**Given**: This is used for one or more initial conditions.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Given**：这用于一个或多个初始条件。'
- en: '**When**: This is used for when something happens.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**When**：这用于某事发生时。'
- en: '**Then**: This is used for when one or more results are expected.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Then**：这用于预期一个或多个结果时。'
- en: This structure is very self-explanatory. By using a similar template, and sticking
    to ubiquitous language, you will have a straightforward way in which to define
    use cases. It is a way that is meaningful for non-technical people and can be
    easily translated to automated use cases by technical people.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构非常直观。通过使用类似的模板，并坚持使用通用语言，你将有一个直接的方式来定义用例。这是一种对非技术人员有意义的、可以轻易被技术人员转换为自动化用例的方法。
- en: Walking backward, you implement code that will gradually cover the test cases,
    mapping to a behavior specification that will give direct feedback to the business
    on which use cases are complete.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 向后走，你实现代码，将逐步覆盖测试用例，映射到一个行为规范，这将直接向业务反馈哪些用例已完成。
- en: This approach offers a structured way to understand what we are implementing
    and possibly select and prioritize the user story to approach as a development
    team. This is also the focus of the practice that we will look at in the next
    section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法提供了一种结构化的方式来理解我们正在实施的内容，并可能选择和优先考虑作为开发团队要处理的故事。这也是我们将在下一节中探讨的实践的重点。
- en: Comparing DDD, TDD, and BDD
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较DDD、TDD和BDD
- en: So far, we have rapidly discussed three different "Something-Driven Development"
    techniques. It must be clear that such practices should not necessarily be seen
    as alternatives, but they might have some complementarity.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已迅速讨论了三种不同的“由...驱动开发”技术。必须清楚，这些实践不一定被视为替代品，但它们可能有一些互补性。
- en: In particular, DDD relates more to the modeling of the application domain. In
    this sense, it can be observed from a more architectural point of view, defining
    how our application is modularized, the different layers, and even how different
    parts of our broader application (or, if you wish, different teams) should cooperate.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，领域驱动设计（DDD）更多地与应用程序域的建模相关。从这个意义上讲，它可以从更架构的角度来观察，定义我们的应用程序如何模块化，不同的层，甚至我们更广泛的应用程序（或者，如果你愿意，不同的团队）应该如何合作。
- en: Once we have designed such layers and components, both TDD and BDD can be used
    as a way to drive our day-to-day development, ensuring we have the right testability
    and feature coverage requested within our code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设计了这样的层和组件，TDD和BDD都可以作为推动我们日常开发的方式，确保我们在代码中拥有所需的正确可测试性和功能覆盖率。
- en: On the other hand, DDD is not a requirement for TDD or BDD, which can be seen
    as a simple technique that is also applicable to smaller applications, or to software
    architectures defined with approaches alternative to DDD. As you will often find
    in this book, those concepts can be viewed as tools, briefly introduced to give
    you an idea of their potentiality. It's up to you to then take what's needed for
    your specific project and combine it in a useful way.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，领域驱动设计（DDD）并不是TDD或BDD的必要条件，它可以被看作是一种简单的技术，也适用于较小的应用程序，或者使用不同于DDD的方法定义的软件架构。正如你在这本书中经常会发现的，这些概念可以被视为工具，简要介绍以给你一个它们潜在性的概念。然后取决于你根据自己的具体项目需要什么，并以有用的方式将其结合起来。
- en: Learning about user story mapping
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解用户故事映射
- en: '**User story mapping** is a way to put user stories into context, identify
    what it takes to implement them, and plan accordingly.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户故事映射**是一种将用户故事置于上下文中的方法，确定实现它们所需的内容，并据此进行规划。'
- en: In this section, we will learn what a user story is and how it can be used as
    a planning method, in order to choose what features to include in each release,
    following a meaningful pace.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习用户故事是什么，以及它如何被用作规划方法，以便选择在每次发布中包含哪些功能，并按照有意义的节奏进行。
- en: The user story is the same concept that we saw as part of BDD. So, it describes
    a feature from the point of view of a specific persona (**As a**...), the functionalities
    required (**I want to**...), and the expected outcome (**So that**...).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事与我们在BDD中看到的概念相同。因此，它从特定角色（**作为**...）的角度描述了一个功能，所需的功能（**我想**...），以及预期的结果（**以便**...）。
- en: As you might observe, all pieces in the puzzle of those seemingly unrelated
    practices eventually start to match. User story mapping is often described as
    a **product backlog** on steroids.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能观察到的，这些看似无关的实践中的所有部分最终开始匹配。用户故事映射经常被描述为**产品待办事项**的强化版。
- en: We will discuss product backlogs in the next chapter. However, for now, consider
    them as lists of features to implement. Features are added as long as analysis
    occurs (or new requirements arise). These are then prioritized and picked by the
    development team to be implemented.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论产品待办事项。然而，现在请将它们视为要实现的功能列表。只要进行分析（或出现新的需求），就会添加功能。然后，这些功能会被优先考虑并由开发团队选择实现。
- en: User story mapping extends this approach by giving more dimensions to the product
    backlog, enriching the information related to each feature, and linking it to
    a broader vision of the product. User stories stay on top of the mapping. They
    describe the high-level features that a system should provide. User stories are
    organized in a horizontal line and ordered by both importance and the temporal
    sequence in which they happen, all from the user's point of view.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事映射通过为产品待办事项提供更多维度，丰富与每个功能相关的信息，并将其与产品的更广泛愿景联系起来，扩展了这种方法。用户故事位于映射的顶部。它们描述了一个系统应该提供的高级功能。用户故事按水平线组织，并按重要性和它们发生的时序顺序排列，所有这些都是从用户的角度来看。
- en: 'For each user story, a list of tasks is provided. Essentially, these are the
    sub-features (also known as **activities**) that each user story encompasses.
    So, we are detailing each feature, but not yet coming to a level of detail that
    can be directly mapped into software (at least, not easily). Each task is then
    attached to a list of subtasks (or task details), which are easier to map to software
    features. This is what user story mapping looks like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个用户故事，都提供了一个任务列表。本质上，这些是每个用户故事所包含的子功能（也称为**活动**）。因此，我们正在详细说明每个功能，但还没有达到可以直接映射到软件（至少，不容易）的详细程度。每个任务都附有一个子任务列表（或任务详情），这些更容易映射到软件功能。这就是用户故事映射的样子：
- en: '![Figure 4.3 – User story mapping](img/Figure_4.03_B16354.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 用户故事映射](img/Figure_4.03_B16354.jpg)'
- en: Figure 4.3 – User story mapping
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 用户故事映射
- en: The interesting thing about this model is that you will not have to prioritize
    the tasks. You just need everything included there (sooner or later); however,
    you can prioritize the subtasks, gradually improving the completeness of each
    task, release after release.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型有趣的地方在于你不需要优先考虑任务。你只需要包括那里的一切（迟早）；然而，你可以优先考虑子任务，逐步提高每个任务的完整性，并在每次发布后进行改进。
- en: This model has a series of positive outcomes. First of all, as with BDD, you
    have a direct mapping between the subtask the development team is working on and
    the user story (or activity). Essentially, it gives visibility to the business
    regarding the finish line toward which we are rowing. Moreover, an interesting
    practice is applicable to this matrix of tasks and subtasks, namely, **value slicing**.
    This means picking what to implement for each release.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型有一系列积极的结果。首先，与BDD（行为驱动开发）一样，你有一个直接映射，即开发团队正在工作的子任务与用户故事（或活动）之间的映射。本质上，它为业务提供了我们划桨的终点的可见性。此外，一个有趣的实践可以应用于这个任务和子任务的矩阵，即**价值切割**。这意味着为每个发布选择要实现的内容。
- en: Given that you will have a finite number of resources (such as programmers,
    time, and whatever else is required to implement each subtask), you cannot, of
    course, deliver everything in one release. Well, you could, but it would be risky
    since you would have to wait a long time before receiving feedback and being able
    to test the software. We will elaborate more on the **release early, release often
    approach** (the well-known incremental product releases technique that is widely
    used in **Agile** and **DevOps**) in the next chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将拥有有限数量的资源（如程序员、时间和实现每个子任务所需的其他一切），你当然不能在一次发布中交付所有内容。好吧，你可以，但这很冒险，因为你必须等待很长时间才能收到反馈并能够测试软件。我们将在下一章中更详细地阐述**尽早发布、经常发布**的方法（这是在**敏捷**和**DevOps**中广泛使用的知名增量产品发布技术）。
- en: 'For now, what matters is that it is better to release value incrementally,
    by picking the subtasks that implement, at least partially, one or more tasks
    and then the related user stories. Here is what this would look like compared
    to *Figure 4.3*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重要的是要逐步释放价值，通过选择至少部分实现一个或多个任务及其相关用户故事的子任务。以下是与*图4.3*相比的示例：
- en: '![Figure 4.4 – Value slicing'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.4 – Value slicing'
- en: '](img/Figure_4.04_B16354.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 4.04_B16354.jpg]'
- en: Figure 4.4 – Value slicing
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 价值切割
- en: As you can see, the approach here is oriented toward an MVP.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这里的方法是面向MVP的。
- en: The MVP
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVP
- en: The concept of MVP deserves some additional explanation. The term was created
    before the user story mapping technique and is an independent idea. It is also
    applicable to products that are different from the software code. The goal of
    the MVP is to maximize the value of the product (in terms of return of investment
    or, trivially, how useful, popular, and beneficial your product will be) while
    minimizing the risks and efforts required to build it. The perfect MVP requires
    a very low level of effort and risk to build, but it can become greatly popular
    and appreciated when used (and, optionally, sold).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: MVP（最小可行产品）的概念需要一些额外的解释。这个术语是在用户故事映射技术之前被创造的，是一个独立的概念。它也适用于与软件代码不同的产品。MVP的目标是在最小化构建产品的风险和努力的同时，最大化产品的价值（从投资回报的角度来看，或者简单地说，你的产品将有多有用、多受欢迎以及多有益）。完美的MVP在构建时需要非常低的努力和风险水平，但在使用（以及可选的出售）时可以变得非常受欢迎和受到赞赏。
- en: 'The purpose of an MVP is to start getting feedback on the product from potential
    end users (usually, a subset of early adopters). Due to this, the MVP should contain
    a meaningful subset of features: not too many, to avoid wasting effort in case
    the product is not well received by customers, but just enough in order to represent
    what the complete product will be like. Early feedback, in the spirit of Agile
    development methodologies, could also be beneficial if some steering is required
    in the product direction, by stressing more on one aspect or another.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: MVP的目的是从潜在最终用户那里开始获取对产品的反馈（通常，是早期采用者的一部分）。因此，MVP应该包含一个有意义的特征子集：不是太多，以避免在产品不受客户欢迎的情况下浪费努力，但足以代表完整产品的样子。在敏捷开发方法的精神下，如果需要对产品方向进行一些引导，强调某一方面的更多内容，早期的反馈也可能是有益的。
- en: In this section, we learned about user story mapping, which is the final technique
    we will explore in this chapter. In the next section, we will examine some examples
    of those approaches, as applied to our mobile payments use case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了用户故事映射，这是我们将在本章中探索的最后一项技术。在下一节中，我们将检查一些将这些方法应用于我们的移动支付用例的示例。
- en: Case studies and examples
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究和示例
- en: As is easy to imagine, a complete and extensive example of DDD, TDD, BDD, and
    user story mapping, applied to our mobile payments case study, could easily take
    more than one book. For this reason, as we mentioned in [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065),
    *Common Architecture Design Techniques*, unfortunately, we can only look at some
    highlights of those techniques used in our example. However, in this section,
    I think it is pretty useful to take a look at, even if to just practically visualize
    some concepts that might appear abstract so far.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如同想象的那样，一个完整且广泛的领域驱动设计（DDD）、测试驱动开发（TDD）、行为驱动开发（BDD）和用户故事映射的示例，应用到我们的移动支付案例研究中，可能需要超过一本书的内容。因此，正如我们在[*第3章*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065)，*常见架构设计技术*中提到的，不幸的是，我们只能看看我们示例中使用的那些技术的亮点。然而，在本节中，我认为看看这些内容是非常有用的，即使只是为了实际地可视化一些到目前为止可能看起来比较抽象的概念。
- en: The mobile payments domain model
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动支付领域模型
- en: 'In [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065), *Common Architecture
    Design Techniques*, we looked at the basic modeling of mobile payment objects
    based on the UML notation. To elaborate more on this, in DDD, you will mostly
    have the following concepts:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065)，*常见架构设计技术*中，我们探讨了基于UML符号的移动支付对象的基本建模。为了更详细地阐述这一点，在领域驱动设计（DDD）中，你将主要遇到以下概念：
- en: The user is an entity. This concept is pretty straightforward, that is, the
    identity is very well defined, and each user has a well-defined life cycle (from
    registration to deletion).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户也是一个实体。这个概念相当直接，即身份定义得非常明确，每个用户都有一个定义良好的生命周期（从注册到删除）。
- en: Payment is an entity, too. Each user will want to keep track of exactly each
    transaction, including the time, the amount, the receiver, and more. It is also
    likely that there will be regulations for you to uniquely identify each payment
    transaction.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付也是一个实体。每个用户都希望跟踪每一笔交易的具体情况，包括时间、金额、接收者等。很可能还会有法规要求你唯一标识每一笔支付交易。
- en: As we've already mentioned, a peer-to-peer payment is out of place as a method,
    both in the sender and receiver entity. So, it is probably worth modeling a payment
    service that can also work as a bridge toward classical CRUD operations in the
    infrastructure layer.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，点对点支付作为方法，在发送者和接收者实体中都是不合适的。因此，可能值得建模一个支付服务，它也可以作为基础设施层中经典CRUD操作的中介。
- en: On the assumption that our application is operating on a global scale, you will
    need to manage transactions in different currencies. `ExchangeRate` is a typical
    example of a value object. It is immutable and composed of currency symbols and
    a number representing the exchange rate. It is a disposable object and can be
    easily shared between different payments, as no identity (nor state) is considered.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们的应用程序在全球范围内运行，你需要管理不同货币的交易。`ExchangeRate`是一个典型的值对象。它是不可变的，由货币符号和表示汇率的数字组成。它是一个可丢弃的对象，可以轻松地在不同的支付之间共享，因为不考虑身份（或状态）。
- en: Once we have defined (a very small subset of) the domain model of mobile payments,
    we are going to look at the layered architecture of this application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了（一个非常小的子集）移动支付的领域模型，我们就会查看这个应用的分层架构。
- en: The layered architecture of mobile payments
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动支付的分层架构
- en: If you remember the diagrams designed in [*Chapter 1*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013),
    *Designing Software Architectures in Java – Methods and Styles*, and the C4 model
    drafted in [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065), *Common
    Architecture Design Techniques*, you are already familiar with some of the technical
    components that implement our mobile payment architecture.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得在[*第1章*](B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013)，*Java软件架构设计 –
    方法与风格*中设计的图表，以及在第3章[*常见架构设计技术*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065)中草拟的C4模型，你已经熟悉了一些实现我们的移动支付架构的技术组件。
- en: 'There, the mapping between components was pretty much coarse-grained. This
    is because you would associate the mobile application with the **Presentation
    Layer**, the business logic with the **Domain Layer**, and so on. However, with
    DDD, we are progressing further with the analysis of our application. We are going
    one level down toward something similar to the **C4 Container** diagram (please
    refer to *Figure 3.8* in [*Chapter 3*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065),
    *Common Architecture Design Techniques*) but from a different point of view. My
    idea of the layered architecture of our application looks similar to the following
    diagram:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，组件之间的映射相当粗粒度。这是因为你会将移动应用程序与**表示层**关联，将业务逻辑与**领域层**关联，等等。然而，随着领域驱动设计（DDD）的应用，我们在分析我们的应用程序方面又前进了一步。我们正在向类似于**C4容器**图（请参阅[*第3章*](B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065)，*常见架构设计技术*）的方向前进，但视角不同。我对我们应用程序分层架构的想法看起来类似于以下图示：
- en: '![Figure 4.5 – The DDD layered architecture'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – DDD 层次架构'
- en: '](img/Figure_4.05_B16354.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.05_B16354.jpg)'
- en: Figure 4.5 – The DDD layered architecture
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – DDD 层次架构
- en: 'From the preceding diagram, you might observe the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，你可能观察到以下内容：
- en: All of the views in the **Presentation Layer** are a subset of the mobile application
    functionalities. You will probably have more functionalities in the real world.
    However, it's interesting to observe how some concepts of the **Domain Layer**
    (hence, the ubiquitous language) are echoed here. Yet, this is a pretty technical
    layer, so it does not strictly observe the ubiquitous language.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**中的所有视图都是移动应用程序功能的子集。在现实世界中，你可能会拥有更多功能。然而，观察一些**领域层**的概念（因此，是通用语言）在这里得到反映是很有趣的。然而，这是一个相当技术性的层，因此它并不严格遵循通用语言。'
- en: The **Application Layer** is a support area, decoupling the needs of the frontend
    with the services provided by the domain model in the **Domain Layer**. The relationship
    with the **Presentation Layer** is not one-to-one in this case, but that's up
    to you to decide according to your context. Additionally, this layer has a dependency
    on the **Domain Layer**.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**是一个支持区域，将前端的需求与**领域层**中提供的领域模型服务解耦。在这种情况下，与**表示层**的关系不是一对一，这取决于你根据你的上下文来决定。此外，这一层依赖于**领域层**。'
- en: In the `ExchangeRate` is not represented).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ExchangeRate`中未表示）。
- en: The **Infrastructure Layer** is the technological glue, providing services to
    other layers, and abstracting technology-specific details. So, in this case, you
    can see that **UserRepo** will mediate calls to IDM and other systems (for example,
    databases or CRMs), while **TransactionDataAdapter** abstracts calls to databases
    and legacy systems. Consider that in this scenario, there are no direct links
    between the **Presentation Layer** and the **Infrastructure Layer**, as everything
    is proxied by the **Application Layer**. However, that's not a strict requirement.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施层**是技术粘合剂，为其他层提供服务，并抽象化特定技术的细节。因此，在这种情况下，你可以看到**UserRepo**将充当对IDM和其他系统（例如数据库或CRM）的调用中介，而**TransactionDataAdapter**则抽象化对数据库和旧系统的调用。考虑到在这个场景中，**表示层**和**基础设施层**之间没有直接链接，因为所有内容都通过**应用层**进行代理。然而，这并不是一个严格的要求。'
- en: In the next section, I will share my views on how BDD could be applied to mobile
    payments.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将分享我对如何将行为驱动开发（BDD）应用于移动支付的看法。
- en: BDD of mobile payments
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动支付的BDD
- en: 'As we detailed in the *Exploring Behavior Driven Development* section, BDD
    starts with a user story. A basic user story for mobile payments could be the
    following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 *探索行为驱动开发* 部分中详细阐述的，BDD 从用户故事开始。一个基本的移动支付用户故事可能如下所示：
- en: '**User Story**: Making a payment:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户故事**：进行支付：'
- en: '**As a** registered user.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为**一个注册用户。'
- en: '**I want** to make a payment to another user.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我想要**向另一个用户进行支付。'
- en: '**So that** I can transfer money (and benefit from services or goods in exchange
    for that).'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以便**我可以转账（并从中获得服务或商品作为交换）。'
- en: As you might have gathered, this user story implies other user stories (such
    as **Registration of a user** and **Login**).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个用户故事暗示了其他用户故事（例如**用户注册**和**登录**）。
- en: 'The next logical step is to enumerate some scenarios (or acceptance criteria)
    linked to that story:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤是列举与该故事相关的一些场景（或验收标准）：
- en: '**Given** that I am registered.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**给定**我已经注册。'
- en: '**And** I am logged in.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并且**我已经登录。'
- en: '**When** I select the payment feature.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当**我选择支付功能时。'
- en: '**Then** I am redirected to the payment view.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**然后**我被重定向到支付视图。'
- en: '**Given** that I am at the payment view.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**给定**我在支付视图中。'
- en: '**And** I am logged in.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并且**我已经登录。'
- en: '**And** I enter a valid recipient.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并且**我输入了一个有效的收款人。'
- en: '**And** I enter a valid amount.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并且**我输入了一个有效的金额。'
- en: '**When** I click on the pay button.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当**我点击支付按钮时。'
- en: '**Then** a payment transaction is created.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**然后**创建了一个支付交易。'
- en: '**And** a notification is sent.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并且**发送了一条通知。'
- en: As demonstrated in the preceding examples, each user story usually corresponds
    to more than one acceptance criteria, which is then codified as a set of (possibly
    automated) test cases. Following this, you can start to iteratively implement
    features until each acceptance criteria is met, ultimately fully covering the
    related user story. Now, let's expand on this user story by means of user story
    mapping.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述示例所示，每个用户故事通常对应多个验收标准，这些标准随后被编码为一组（可能是自动化的）测试用例。在此之后，您可以开始迭代地实现功能，直到每个验收标准都得到满足，最终完全覆盖相关的用户故事。现在，让我们通过用户故事映射来扩展这个用户故事。
- en: User story mapping of mobile payments
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动支付的用户故事映射
- en: In the *Learning about user story mapping* section, we discovered that the top-level
    element is the user story. So, we will start with the stories that we have just
    observed in the previous section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在*了解用户故事映射*部分，我们发现顶级元素是用户故事。因此，我们将从上一节中观察到的故事开始。
- en: 'Take into account that while it can be considered as a task attached to each
    user story, the acceptance criterion is usually considered more like an orthogonal
    concept, to validate the implementation of each story. Usually, the attached tasks
    are simply more detailed features composing the story itself. Let''s view an example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然它可以被认为是附加到每个用户故事的每个任务的，但验收标准通常被认为是一个正交的概念，用于验证每个故事的实现。通常，附加的任务只是故事本身的更详细的功能。让我们看一个例子：
- en: '![Figure 4.6 – User story mapping example'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 用户故事映射示例'
- en: '](img/Figure_4.06_B16354.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.06_B16354.jpg)'
- en: Figure 4.6 – User story mapping example
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 用户故事映射示例
- en: As you can see in the preceding (simplified) example, for each activity (mapping
    to a user story, as per the *BDD of mobile payments* section) there are one or
    more related tasks. Activities and tasks are ordered following a time (and priority)
    direction. Then, each task is attached to a list of subtasks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的（简化）示例中所见，对于每个活动（根据*移动支付的BDD*部分映射到用户故事）都有一个或多个相关任务。活动和任务是按照时间（和优先级）方向排序的。然后，每个任务都附有一系列子任务。
- en: 'It''s a logical next step to plan how to group a set of subtasks as a release,
    progressively delivering value to the final customer (think about MVPs). We''ve
    described this approach as value slicing, which appears as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将一组子任务规划为发布版本，逐步向最终客户提供价值（想想MVPs），这是一个逻辑上的下一步。我们将这种方法描述为价值切片，如下所示：
- en: '![Figure 4.7 – Value slicing example'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – 价值切片示例'
- en: '](img/Figure_4.07_B16354.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_4.07_B16354.jpg)'
- en: Figure 4.7 – Value slicing example
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 价值切片示例
- en: As you can see in the preceding diagram, we've represented a simple slicing
    of features as two releases. In the first release (**Release 1**), you will provide
    the bare minimum functionalities. It will be possible to create users, to **Sign
    in** (but not using a social account), and to **Make a payment** (but without
    receiving a notification).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图中所见，我们将特征的一个简单切片表示为两个发布版本。在第一个发布版本（**发布1**）中，您将提供最基本的功能。将能够创建用户，**登录**（但不能使用社交账户），以及**进行支付**（但不能接收通知）。
- en: There will be no functionalities regarding lost passwords and payment disputes.
    In the second release (**Release 2**), no new features will be added to the registration
    activity, the **Lost password** task will be completed (being made of just one
    subtask), and the whole **Dispute a payment** task will be completed (in both
    its two subtasks).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将不会有关于丢失密码和支付争议的功能。在第二个发布版本（**发布2**）中，将不会向注册活动添加新功能，**丢失密码**任务将被完成（仅由一个子任务组成），并且整个**争议支付**任务将被完成（包括其两个子任务）。
- en: All of the other subtasks are part of the backlog, meaning they are yet to be
    planned (and more subtasks can then be added). Of course, each line representing
    a release is drawn together with business/product owners, which will define the
    priority and helps to aggregate subtasks in a meaningful way. With value slicing,
    we have completed the objectives of this chapter. Let's look at a quick recap
    of all the notions we have encountered.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他子任务都是待办事项的一部分，这意味着它们尚未被规划（然后可以添加更多子任务）。当然，每一条代表一个发布的线都是由业务/产品所有者绘制的，这将定义优先级并有助于以有意义的方式聚合子任务。通过价值切片，我们已经完成了本章的目标。让我们快速回顾一下我们遇到的所有概念。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at a set of techniques to start transforming architecture
    principles into working software components. DDD is a pretty complete framework
    that is used to define objects and the way they interact with each other. It puts
    a number of clever ideas down on paper, such as layered architectures, patterns,
    and bounded contexts.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了一系列技术，以开始将架构原则转化为可工作的软件组件。领域驱动设计（DDD）是一个相当完整的框架，用于定义对象以及它们相互交互的方式。它将许多巧妙的思想记录在纸上，例如分层架构、模式和边界上下文。
- en: Following this, we moved on to Test Driven Design and BDD. You now understand
    specific ways of structuring the development of new code and mapping it to business
    features. Finally, we looked at user story mapping as a way to pick functionalities
    to implement and link them to tasks and activities.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们转向了测试驱动设计和BDD。你现在理解了结构化新代码和将其映射到业务特性的具体方法。最后，我们探讨了用户故事映射作为一种选择要实现的功能并将其与任务和活动链接起来的方法。
- en: All of these techniques will be better framed in the next chapter, where we
    will discuss **Agile** methodologies, which include some of the practices that
    we have just discussed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术将在下一章中更好地阐述，我们将讨论**敏捷**方法，其中包括我们刚刚讨论的一些实践。
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Anemic Domain Model* by Martin Fowler ([https://martinfowler.com/bliki/AnemicDomainModel.html](https://martinfowler.com/bliki/AnemicDomainModel.html))'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Martin Fowler 的《*贫血领域模型*》([https://martinfowler.com/bliki/AnemicDomainModel.html](https://martinfowler.com/bliki/AnemicDomainModel.html))
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software* by Eric
    Evans ([https://www.domainlanguage.com/](https://www.domainlanguage.com/))'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eric Evans 的《*领域驱动设计：解决软件核心的复杂性*》([https://www.domainlanguage.com/](https://www.domainlanguage.com/))
- en: '*Domain-Driven Design Quickly*, by Abel Avram and Floyd Marinescu, published
    by C4Media (2007)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Abel Avram 和 Floyd Marinescu 著，由 C4Media 出版的《*领域驱动设计快速入门*》（2007年）
- en: '*10 Common DDD Mistakes to Avoid* by Jan Stenberg ([https://www.infoq.com/news/2015/07/ddd-mistakes/](https://www.infoq.com/news/2015/07/ddd-mistakes/))'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jan Stenberg 的《*避免十大常见DDD错误*》([https://www.infoq.com/news/2015/07/ddd-mistakes/](https://www.infoq.com/news/2015/07/ddd-mistakes/))
- en: '*Introducing BDD* by Dan North ([https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/))'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dan North 的《*引入BDD*》([https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/))
- en: '*BDD in Action: Behavior-Driven Development for the Whole Software Lifecycle*,
    by John Ferguson Smart, published by Manning Publications (2004)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: John Ferguson Smart 著，由 Manning Publications 出版的《*BDD实战：全软件生命周期的行为驱动开发*》（2004年）
- en: '*User Story Mapping & Value Slicing* by Matt Takane and Ryan DeBeasi ([https://openpracticelibrary.com/practice/user-story-mapping/](https://openpracticelibrary.com/practice/user-story-mapping/))'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matt Takane 和 Ryan DeBeasi 的《*用户故事映射与价值切片*》([https://openpracticelibrary.com/practice/user-story-mapping/](https://openpracticelibrary.com/practice/user-story-mapping/))
- en: '*Top 5 Biggest Challenges when Building an MVP and how to Avoid Them* by Ilya
    Matanov ([https://expertise.jetruby.com/top-5-biggest-challenges-when-building-an-mvp-and-how-to-avoid-them-2969703e5757](https://expertise.jetruby.com/top-5-biggest-challenges-when-building-an-mvp-and-how-to-avoid-them-2969703e5757))'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ilya Matanov 的《*构建MVP时面临的五大挑战以及如何避免它们*》([https://expertise.jetruby.com/top-5-biggest-challenges-when-building-an-mvp-and-how-to-avoid-them-2969703e5757](https://expertise.jetruby.com/top-5-biggest-challenges-when-building-an-mvp-and-how-to-avoid-them-2969703e5757))
- en: '*The New User Story Backlog is a Map* by Jeff Patton ([https://www.jpattonassociates.com/the-new-backlog/](https://www.jpattonassociates.com/the-new-backlog/))'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jeff Patton 的《*新的用户故事待办事项是一张地图*》([https://www.jpattonassociates.com/the-new-backlog/](https://www.jpattonassociates.com/the-new-backlog/))
