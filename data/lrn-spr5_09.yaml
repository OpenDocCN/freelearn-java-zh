- en: 'Chapter 9. Exchange the Message: The Messaging'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章。交换消息：消息传递
- en: 'Up till now we have discussed a lot about bidirectional web applications, which
    happens over the traditional HTTP communication. These browser based applications
    provide two way communication by opening multiple connections. The **websocket
    protocol** provides a mean for messaging over TCP which doesn''t rely on the opening
    of multiple HTTP connections. In this chapter, we will discuss websocket protocol
    with the help of following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了很多关于基于传统HTTP通信的双向网络应用程序。这些基于浏览器的应用程序通过打开多个连接提供双向通信。**WebSocket协议**提供了一种基于TCP的消息传递方式，不依赖于打开多个HTTP连接。在本章中，我们将通过以下几点讨论WebSocket协议：
- en: '**Introduction to messaging**'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息传递简介**'
- en: '**Introduction to WebSocket protocol**'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebSocket协议简介**'
- en: '**WebSocket API**'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebSocket API**'
- en: '**Overview of STOMP**'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STOMP概览**'
- en: 'In web applications the bidirectional communication between client and server
    happens to be synchronous where the client request the resource and server sends
    the notification as the HTTP call. It addresses the following problems:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用程序中，客户端和服务器之间的双向通信是同步的，其中客户端请求资源，服务器发送HTTP调用通知。它解决了以下问题：
- en: The multiple connections have to open to send the information and to collect
    the incoming messages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须打开多个连接以发送信息并收集传入消息
- en: The track of mapping outgoing connections to the incoming connections so as
    to track the request and its replies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪将外出连接映射到进入连接，以便跟踪请求及其回复
- en: The better solution will be to maintain a single TCP connection for both sending
    as well as receiving which has been provided by WebSocket as low level protocol
    without headers. As headers are not getting added, the amount of data being transmitted
    over the network decreases, in turn the load reduces. It is done by the process
    known as pull technology instead of push technology done in long pulling as in
    AJAX. Now a days, developers are using **XMLHttpRequest (XHR)** for the asynchronous
    HTTP communication. WebSocket uses the HTTP as transport layer to support the
    existing infrastructure using 80, 443 ports. In such two way communication of
    successful connection data transfer happens independently on their will.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是维护一个用于发送和接收的单一TCP连接，这正是WebSocket作为无头部的低层协议所提供的。由于没有添加头部，传输网络的数据量减少，从而降低了负载。这是通过称为拉取技术的过程来实现的，而不是AJAX中使用的长拉取的推技术。现在，开发者们正在使用**XMLHttpRequest（XHR）**进行异步HTTP通信。WebSocket使用HTTP作为传输层，以支持使用80、443端口的基础设施。在这种双向通信中，成功的连接数据传输是独立于他们的意愿进行的。
- en: 'The RFC 6455 defines the WebSocket protocol as, one which facilitates the two
    way communication between the client and the server where the client is running
    in the controlled environment communicating to the remote host, who had given
    the permission to accept mail, email or any direct communication from the code.
    The protocol consists of opening the handshake followed by the basic message framing
    which is layered over the TCP protocol. The HTTP status code 101 is sent by the
    server, if it agrees denoting successful handshake. Now the connection will remain
    open and the message exchange can be done. The following diagram gives an idea
    how the communication happens:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 《RFC 6455》将WebSocket协议定义为，一种在客户端运行在受控环境中与远程主机通信的客户端和服务器之间的双向通信协议，该远程主机已允许接受邮件、电子邮件或任何直接从代码发出的通信。该协议包括打开握手，随后是基本的报文框架，该框架建立在TCP协议之上。如果服务器同意，它会发送HTTP状态码101，表示成功的握手。现在连接将保持开放，可以进行消息交换。以下图表给出了通信如何进行的大致概念：
- en: '![](img/image_10_001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_001.png)'
- en: 'The WebSocket does the following things on top of TCP:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket在TCP之上执行以下操作：
- en: It adds the web security model to the browser.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它向浏览器添加了网络安全模型。
- en: As one port needs to supports multiple host names and multiple services, it
    adds addressing and naming mechanism to provide such support.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于一个端口需要支持多个主机名和多个服务，因此它增加了地址和命名机制以提供这种支持。
- en: It forms a layer framing mechanism on top of TCP to facilitate IP packet mechanism.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在TCP之上形成了一层框架机制，以促进IP包机制。
- en: A closing handshake mechanism.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭握手机制。
- en: The data transfer in WebSocket uses a sequence of the frames. Such data frames
    can be transmitted by either side at any time after opening the handshake, but
    before the endpoint has sent the Close frame.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebSocket中的数据传输使用一系列的帧。这样的数据帧可以在打开握手之后，在端点发送Close帧之前，由任一方随时传输。
- en: Spring and Messaging
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring和消息传递
- en: '* * *'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: From Spring 4.0 onwards, there is a support for WebSocket introducing spring-websocket
    module, which is compatible with Java WebSocket API(JSR-356). The HTTPServlet
    and REST application uses URLs, HTTP methods to exchange the data between the
    client and the server. But opposite to this the WebSocket application may use
    single URL for the initial handshakes which is asynchronous, messaging and even
    driven architecture as JMS or AMQP. Spring 4 includes spring-messaging module
    to integrate Message, MessageChannel, MessageHandler, a set of annotations for
    mapping messages to the methods and many more to support the basic messaging architecture.
    The @Controller and @RestController which we already used to create Spring MVC
    web application and RESTful web services which allows handling HTTP request also
    support handler methods for WebSocket messaging. Also the handler methods from
    Controllers can broadcasts the message to either all interested or user specific
    WebSocket client.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从Spring 4.0开始，就有对WebSocket的支持，引入了spring-websocket模块，该模块与Java WebSocket API（JSR-356）兼容。HTTPServlet和REST应用程序使用URL、HTTP方法在客户端和服务器之间交换数据。但与这种相反，WebSocket应用程序可能使用单个URL进行初始握手，这是异步的、消息传递的，甚至是基于JMS或AMQP的架构。Spring
    4包括spring-messaging模块，以集成消息、消息通道、消息处理器，一系列注解用于将消息映射到方法，以及许多其他功能以支持基本的消息传递架构。@Controller和@RestController我们已经用来创建Spring
    MVC网络应用程序和RESTful网络服务，它允许处理HTTP请求也支持WebSocket消息的处理方法。此外，控制器中的处理方法可以将消息广播给所有感兴趣的用户特定的WebSocket客户端。
- en: The Use
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用
- en: 'The WebSocket architecture is suitable in all those web applications, which
    needs to exchange events frequently but where the time with which the data exchanged
    to the target matters as:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket架构适用于所有那些需要频繁交换事件的网络应用程序，在这些应用程序中，数据交换到目标的时间是非常重要的，例如：
- en: The social media is playing a very important role now days and playing a vital
    role to be in touch with family and friends. The user always enjoys real time
    updates of the feed done by their circle.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交媒体目前在日常生活中扮演着非常重要的角色，并且对于与家人和朋友保持联系起着至关重要的作用。用户总是喜欢实时接收他们圈子内完成的Feed更新。
- en: Now a day's many online multiplayer games are available on web. In such games,
    each player is always keen to know what his opponent is doing. Nobody wants to
    discover opponents move when they took their action.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如今，许多在线多人游戏都可以在网络上找到。在这样的游戏中，每个玩家总是急于知道他的对手正在做什么。没有人希望在对手采取行动时发现对手的举动。
- en: In development the version control tools like Tortoise SVN, Git helps to keep
    the track of the files. So that, the exchange of the code becomes easier without
    conflict. But here, we won't get information about who is working on which of
    the file at real time.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中，版本控制工具如Tortoise SVN、Git有助于跟踪文件。这样，在代码交换时就不会发生冲突，变得更加容易。但在这里，我们无法实时获取谁正在处理哪个文件的信息。
- en: In financial investments one always wants to know the real time price of the
    company in which he is interested and the not the one before some time.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在金融投资中，人们总是希望知道他所感兴趣公司的实时股价，而不是之前的某个时间的股价。
- en: Overview of WebSocket API
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WebSocket API概述
- en: '* * *'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The spring framework facilitates creation of WebSocket by providing the APIs
    to adopt various WebSocket engines. Today Tomcat7.0.47+, Jetty 9.1+, WebLogic
    12.1.3+, GlassFish 4.1+ provides runtime environments for WebSocket.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: springframework框架通过提供采用各种WebSocket引擎的API，实现了WebSocket的创建。如今Tomcat7.0.47+、Jetty
    9.1+、WebLogic 12.1.3+、GlassFish 4.1+为WebSocket提供了运行环境。
- en: Creation of WebSocket handler
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WebSocket处理器的创建
- en: 'The creation of WebSocketHandler can be done either by implementing the WebSocketHandler
    interface or extending from TextWebSocketHandler or BinaryWebSocketHandler as
    we have done in the following snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现WebSocketHandler接口或从TextWebSocketHandler或BinaryWebSocketHandler继承来创建WebSocketHandler，如下代码片段所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The WebSocketDecorator class can be used to decorate the WebSocketHandler. Spring
    provides some decorator classes to handle exceptions, logging mechanism, and handling
    binary. The class ExceptionWebSocketHandler, is an Exception handling WebSocketHandlerDecorator
    which helps in handling all instances of the Throwable. The LoggingWebSocketHandlerDecorator,
    adds the logging to events which takes place in the life cycle of the WebSocket.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用WebSocketDecorator类来装饰WebSocketHandler。Spring提供了一些装饰器类来处理异常、日志机制和处理二进制数据。`ExceptionWebSocketHandler`是一个异常处理的WebSocketHandlerDecorator，它可以帮助处理所有Throwable实例。`LoggingWebSocketHandlerDecorator`为WebSocket生命周期中发生的事件添加日志记录。
- en: Registering WebSocketHandler
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册WebSocketHandler
- en: The WebSocket handlers are mapped to a specific URL to register this mapping
    .The framework can be done either by Java configuration or XML based configuration.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket处理器被映射到特定的URL以注册此映射。此框架可以通过Java配置或XML基础配置来完成。
- en: Java Based configuration
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于Java的配置
- en: 'The WebSocketConfigurer is used to map the handler with its specific URL in
    the `registerWebSocketHandlers()` method as shown in the code below:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocketConfigurer` 用于在`registerWebSocketHandlers()`方法中将处理器与其特定的URL映射，如下面的代码所示：'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here our WebSocketHandler is mapped to /webSocketHandler URL.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处，我们的WebSocketHandler被映射到了`/webSocketHandler` URL。
- en: 'The customization of the WebSocketHandler to customize the handshake can be
    done as:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义WebSocketHandler以自定义握手的操作可以如下进行：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The HandshakeInterceptor exposes `beforeHandshake()` and `afterhandshake()`
    methods to customize the WebSocket handshake. The `HttpSessionHandshakeInterceptor`
    facilitates binding information from HtttpSession to the handshake attributes
    under the name `HTTP_SESSION_ID_ATTR_NAME`. These attribute can be used as `WebSocketSession.getAttributes()` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 握手拦截器暴露了`beforeHandshake()`和`afterhandshake()`方法，以自定义WebSocket握手。`HttpSessionHandshakeInterceptor`促进了将HtttpSession中的信息绑定到名为`HTTP_SESSION_ID_ATTR_NAME`的握手属性下。这些属性可以用作`WebSocketSession.getAttributes()`方法。
- en: XML Based configuration
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: XML基础配置
- en: 'The registration done in the above Java snippet, can be done in XML as well.
    We need to register the web-socket namespace in the XML and then configure the
    handler as shown below:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述Java代码片段中的注册也可以用XML完成。我们需要在XML中注册WebSocket命名空间，然后如以下所示配置处理器：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The customised WebSocketConfigurer in XML can be written as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML中自定义的WebSocketConfigurer可以写成如下形式：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: WebSocket Engine Configuration
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: WebSocket引擎配置
- en: 'Tomcat7.0.47+, Jetty 9.1+,WebLogic 12.1.3+, GlassFish 4.1+ provides runtime
    environments for WebSocket. The characteristics such as buffer size of the messages,
    timeout, can be configured for Tomcat runtime environment by adding the bean for
    WebSocketConfigurer as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat7.0.47+, Jetty 9.1+,WebLogic 12.1.3+, GlassFish 4.1+ 为WebSocket提供运行环境。可以通过添加WebSocketConfigurer的bean来为Tomcat运行环境配置消息缓冲区大小、超时等特性，如下所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The equivalent XML configuration can be written as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的XML配置可以写成：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Configuration of allowed origins
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 允许的来源配置
- en: The 'origin' is the scope of the privilege by the agent. The variety of content
    exists in various format created by numerous authors, something out of which may
    be harmful. The content created by one origin can freely interact with the content
    created by other origin. The agents has the facility to set up the rules under
    which one content interact with other called as **'same-origin policy'**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`origin`是代理商的特权范围。由众多作者以各种格式创建的内容存在其中，其中一些可能是有害的。由一个来源创建的内容可以自由地与其他来源的内容进行交互。代理商有设置规则的权限，其中一个内容与其他内容交互，称为**“同源策略”**。'
- en: Let's take an example of HTML, where we are having form submission. Whenever
    the user agent enters the data, the entered data is exported to the URI. Here
    the URI declares the trust on the integrity of the information which the script
    file has received through the URI.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以HTML为例，其中有表单提交。每当用户代理输入数据时，输入的数据会被导出到URI。在此处，URI声明了对脚本文件通过URI接收的信息的完整性信任。
- en: '`http://packt.com/`, `http://packt.com:8080/`, `http://www.packt.com/`, `https://packt.com:80/`,
    `https://packt.com/`, `http://packt.org/` are different URIs.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://packt.com/`, `http://packt.com:8080/`, `http://www.packt.com/`, `https://packt.com:80/`,
    `https://packt.com/`, `http://packt.org/` 是不同的URI。'
- en: 'There are three ways to configure origin as:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 配置来源有三种方式：
- en: Allow same origin
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许同源
- en: Allow specified list of origins
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许指定的来源列表。
- en: Allow all origins
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许所有来源
- en: 'Let''s first discuss in detail about the creation and use of WebSocket for
    client server communication:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先详细讨论关于客户端服务器通信中WebSocket的创建和使用：
- en: 'Creation of WebSocket:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebSocket的创建：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Where URL contains:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL包含的内容：
- en: '**Schema**: the URL must contain either `ws` denoting insecure connection or
    `wss` denoting secure connections'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协议**：URL必须包含`ws`，表示不安全连接，或`wss`，表示安全连接。'
- en: '**Host:** it''s a name or IP of the server'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机名：**这是服务器的一个名称或IP地址。'
- en: '**Port**: the remote port where you the we want to get connected ws connection
    by default uses port ''80'' and wss uses 443'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：我们要连接的远程端口，ws连接默认使用端口''80''，而wss使用443。'
- en: '**Resource name**: path URL of the resource to fetch'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源名称**：要获取的资源的路径URL。'
- en: 'We can write the URL for WebSocket as:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将WebSocket的URL写为：
- en: scheme://host_name:port_no/resource_path
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议://主机名:端口号/资源路径
- en: ws://host_name:port_no/resource_path
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ws://主机名:端口号/资源路径
- en: wss://host_name:port_no/resource_path
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: wss://主机名:端口号/资源路径
- en: 'Closing the WebSocket:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭WebSocket：
- en: To close the connection we use `close()` method as `close(code, reason).`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭连接时，我们使用`close()`方法，如`close(code, reason)`。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'code: It''s a numeric status sent to the server. 1000 indicates normal closing
    of connections.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：这是一个发送给服务器的数值状态。1000表示正常关闭连接。
- en: 'States of the WebSocket:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebSocket的状态：
- en: 'Following are the connection states of the WebSocket, giving information in
    which state it is:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是WebSocket的连接状态，提供它处于哪种状态的信息：
- en: '**Connecting**: The WebSocket is constructed and it is attempting to connect
    to the specified URL. This state is considered as the connecting state having
    ready State as 0.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接中**：构造WebSocket，并尝试连接到指定URL。这个状态被认为是连接状态，准备状态值为0。'
- en: '**Open**: Once the WebSocket is successfully connected to the URL it will enter
    to the open state. The data can be sent to and from the network only when the
    WebSocket is in open state. The ready state value of open state is "1".'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打开**：一旦WebSocket成功连接到URL，它将进入打开状态。只有在WebSocket处于打开状态时，数据才能在网络之间发送和接收。打开状态的准备状态值是"1"。'
- en: '**Closing**: The WebSocket won''t directly close, it must communicate to the
    server to inform it is disconnecting. This state is considered as closing state.
    The ready state value of open state is"2".'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**：WebSocket不会直接关闭，它必须与服务器通信，通知它正在断开连接。这个状态被认为是关闭状态。"open"状态的准备状态值是"2"。'
- en: '**Closed**: After the successful disconnection from the server the WebSocket
    enters in the closed state. The WebSocket in the closed state has a "readyState"
    value of 3.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已关闭**：从服务器成功断开连接后，WebSocket进入关闭状态。处于关闭状态的WebSocket有一个"readyState"值为3。'
- en: 'Event Handling in WebSocket:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在WebSocket中的事件处理：
- en: 'The WebSocket works on the principle of event handling, where the call back
    methods get invoked to complete the process. Following are the events which occurs
    in the life cycle of the WebSocket:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket基于事件处理原理工作，其中回调方法被调用以完成过程。以下是WebSocket生命周期中发生的事件：
- en: '**onopen**: When the WebSocket transit to open state the "onopen" event handler
    gets called.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onopen**：当WebSocket过渡到开放状态时，"onopen"事件处理程序会被调用。'
- en: '**onmessage**: When the WebSocket receives data from the server the "onmessage"
    event handler gets called. The received data gets stored in the "data" field of
    the "message" event.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onmessage**：当WebSocket从服务器接收数据时，"onmessage"事件处理程序会被调用。接收到的数据将存储在"message"事件的"data"字段中。'
- en: 'The data field has the parameters as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 数据字段有参数：
- en: '**onclose**: When the WebSocket is closed the "onclose" event handler gets
    called. The event object will get passed to "onclose". It has three fields named:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onclose**：当WebSocket关闭时，"onclose"事件处理程序会被调用。事件对象将传递给"onclose"。它有三个字段：'
- en: '**code**: a numeric status value provided by the server'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**：服务器提供的数值状态值。'
- en: '**reason**: its a string describing the close event.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原因**：这是一个描述关闭事件的字符串。'
- en: '**wasClean**: has a boolean value indicating whether the connection closed
    without any problem. Under normal circumstances, "wasClean" is true.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wasClean**：有一个布尔值，表示连接是否没有问题地关闭。在正常情况下，"wasClean"是true。'
- en: '**onerror**: When a WebSocket encounters any problem the "onerror" event handler
    gets called. The event passed to the handler will be a standard error object which
    includes "name" and "message" fields.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onerror**：当WebSocket遇到任何问题时，"onerror"事件处理程序会被调用。传递给处理程序的事件将是一个标准错误对象，包括"name"和"message"字段。'
- en: 'Sending the data:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送数据：
- en: The data transmission happens via `send()` method which deals with UTF-8 text
    data, data of type ArrayBuffer and a data of type blob. The 'bufferedAmount '
    property with value as zero ensures data sent successfully.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输通过`send()`方法进行，该方法处理UTF-8文本数据、ArrayBuffer类型的数据以及blob类型的数据。'bufferedAmount'属性值为零确保数据发送成功。
- en: 'Let us develop a demo for WebSocket with the help of following steps to find
    capital of the country:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤开发一个WebSocket演示来查找国家首都：
- en: Create Ch10_Spring_Message_Handler as dynamic web application.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ch10_Spring_Message_Handler作为动态网络应用程序。
- en: Add jars for Spring core, Spring web , spring-websocket, spring-messaging modules.
    Also add jars for Jackson.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Spring核心、Spring网络、spring-websocket、spring-messaging模块的jar文件。还要添加Jackson的jar文件。
- en: 'Let''s add MyMessageHandler as a child of TextWebSocketHandler in the compackt.ch10.config
    package. Override the methods for handling message, WebSocket connection, connection
    closing as shown below:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在compackt.ch10.config包中添加MyMessageHandler作为TextWebSocketHandler的子项。覆盖处理消息、WebSocket连接、连接关闭的方法，如下所示：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This MessageHandler needs to register with WebSocketConfigurer for URL ''/myHandler''
    for all origins as shown below:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个MessageHandler需要注册到WebSocketConfigurer，为所有源的URL'/myHandler'，如下所示：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Add Front controller mapping in web.xml as we did in earlier applications with
    servlet name as 'books'.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在web.xml中添加前端控制器映射，就像在之前的应用程序中一样，servlet名称是'books'。
- en: Add books-servlet.xml to add bean for 'viewResolver'. You can decide adding
    it as a bean depending upon the application requirement.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了添加`viewResolver`的bean，请添加books-servlet.xml文件。你可以根据应用程序的需求决定是否添加它作为一个bean。
- en: 'Also add configuration to enable spring web MVC as:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要添加配置以启用Spring Web MVC，如下所示：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add country.jsp as a JSP page having list of countries where user can select
    the country from drop down to get name of its capital:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加country.jsp作为一个JSP页面，其中包含一个国家列表，用户可以从下拉列表中选择国家以获取其首都名称：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the SockJS support by adding sockjs-0.3.4.js in your resources or adding
    the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在你的资源中添加sockjs-0.3.4.js，或者通过添加以下代码来添加SockJS支持：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On form submission a method of JavaScript gets invoked, where we handle the
    WebSocket events onopen, onmessage etc as discussed earlier:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单提交时，会调用一个JavaScript方法，我们在前面讨论过的onopen、onmessage等WebSocket事件上处理该方法。
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We already discussed about how to write the WebSocket URLs and event handling
    mechanism.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过如何编写WebSocket URL和事件处理机制。
- en: Deploy the application and access the page. Select the country from dropdown
    and click on show capital button. The message will appear displaying the name
    of the capital.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序并访问页面。从下拉列表中选择国家，然后点击显示首都按钮。将显示首都名称的消息。
- en: 'The following diagram shows the flow of the application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了应用程序的流程：
- en: '![](img/image_10_002.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_002.png)'
- en: We had added the Console logs as well as the Alert messages to know the progress
    and to and fro of the messages. As per requirement you can customize it or can
    completely omit as well.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了控制台日志以及警告消息，以了解进度和消息的往返。根据需求，你可以自定义它，也可以完全省略。
- en: In the earlier example, we have used WebSocket for communication but still its
    support is limited. The SockJS is a JavaScript library which provides the objects
    like WebSocket.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们使用了WebSocket进行通信，但其支持仍然有限。SockJS是一个JavaScript库，它提供了类似于WebSocket的对象。
- en: SockJS
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SockJS
- en: '* * *'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '****'
- en: 'The SockJS library provides cross browser, JavaScript API to enable low latency,
    cross domain communication between the browser and server. It aims to support
    the following goals:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SockJS库提供跨浏览器、JavaScript API，以实现浏览器和服务器之间的低延迟、跨域通信。它旨在支持以下目标：
- en: Instead of using WebSocket instance, the SockJS instance is used
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SockJS实例，而不是WebSocket实例。
- en: The API which are close to WebSocket API both for server as well as client side
    APIs
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些API对于服务器和客户端的API来说都非常接近WebSocket API。
- en: Faster communication support
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持更快的通信
- en: JavaScript for client side
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端的JavaScript
- en: It comes with some chosen protocols which supports cross domain communication
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它带有支持跨域通信的一些选择性协议
- en: 'The following code shows how to enable in the SockJS support for WebSocketConfigurere
    as:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何为WebSocketConfigurer启用SockJS支持：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or even we can configure in XML as:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以在XML中配置：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can update the Capital demo developed earlier to support SockJS as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面开发的Capital演示更新以支持SockJS，如下所示：
- en: 'Add country_sockjs.jsp in WebContent to use with SockJS as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在WebContent中添加country_sockjs.jsp，以便与SockJS一起使用，如下所示：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add MyWebSocketConfigurer_sockjs in com.packt.ch10.config package to configure
    the WebSocket as we did earlier. To enable the SockJS support we have to modify
    the `registerWebSocketHandlers()` method as shown in the configuration above using
    `withSockJS()`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch10.config包中添加MyWebSocketConfigurer_sockjs以配置WebSocket，就像我们之前做的那样。为了启用SockJS支持，我们必须修改`registerWebSocketHandlers()`方法，像上面配置中显示的那样使用`withSockJS()`。
- en: Run the application and request for country_sockjs.jsp to use the SockJS. You
    can observe the console logs as well.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并请求country_sockjs.jsp以使用SockJS。你也可以观察控制台日志。
- en: In the above example, we had use WebSocket to get the connection and handle
    the events. The new WebSocket protocol also has been introduced for the communication
    which we used here. It uses less bandwidth. It has no headers like HTTP gives
    simpler, efficient communication. We can also use STOMP for the communication.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们使用了WebSocket来获取连接并处理事件。这里还引入了新的WebSocket协议用于通信。它使用更少的带宽。它没有HTTP那样的头部，使得通信更简单、高效。我们也可以使用STOMP进行通信。
- en: STOMP
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STOMP
- en: '* * *'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: '**Simple (or Streaming) Text Oriented Message Protocol (STOMP)** over WebSocket
    provides a straightforward mapping from a STOMP frame to a JavaScript object.
    WebSocket is fastest protocol but, still it is not supported by all browsers.
    The browsers have problems to support proxies and protocol handling. It will take
    a while to get wide support by all the browsers, meanwhile we need to find some
    substitute or real time solution. The SockJS supports STOMP protocol for communicating
    with any message broker from the scripting languages and is an alternative to
    AMQP. STOMP is lightweight and easy to implement both on client as well as server
    side. It comes with reliable sending single message and then disconnect or consume
    all messages from the destination It defines following different frames that are
    mapped to WebSocket frames:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单（或流式）文本导向消息协议（STOMP）**通过WebSocket为STOMP帧到JavaScript对象的直接映射提供了支持。WebSocket是最快的协议，但仍然不被所有浏览器支持。浏览器在支持代理和协议处理方面存在问题。所有浏览器广泛支持还需要一段时间，与此同时我们需要找到一些替代方案或实时解决方案。SockJS支持STOMP协议，通过脚本语言与任何消息代理进行通信，是AMQP的一个替代方案。STOMP在客户端和服务器端都很容易实现，并且提供了可靠地发送单条消息的功能，然后断开连接或从目的地消费所有消息。它定义了以下不同的帧，这些帧映射到WebSocket帧：'
- en: '**CONNECT**: It connects the client to the server.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CONNECT（连接客户端和服务器）**：'
- en: '**SUBSCRIBE**: It is used to register which can listen to the given destination.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SUBSCRIBE（用于注册，可以监听给定目的地）**：'
- en: '**UNSUBSCRIBE**: It is used to remove existing subscription.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UNSUBSCRIBE（用于移除现有订阅）**：'
- en: '**SEND (messages sent to the server)**: The frame sends a message to the destination.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SEND（发送给服务器的消息）**：该帧将消息发送到目的地。'
- en: '**MESSAGE (for messages send from the server**): It conveys the messages from
    the subscriptions to the client.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MESSAGE（来自服务器的消息）**：它将来自订阅的消息传递给客户端。'
- en: '**BEGIN:** It starts the transaction.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BEGIN（开始事务）**：'
- en: '**COMMIT**: It commits the ongoing transaction.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COMMIT（提交进行中的事务）**：'
- en: '**ABORT**: It rollbacks the ongoing transaction.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ABORT（回滚进行中的事务）**：'
- en: '**DISCONNECT**: It disconnects the client from the server.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DISCONNECT（使客户端与服务器断开连接）**：'
- en: 'It also supports the following standard headers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它还支持以下标准头：
- en: '**content-length:** The SEND, MESSAGE and ERROR frames contain content-length
    header having its value as content length of the message body.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容长度（content-length）**：SEND、MESSAGE和ERROR帧包含内容长度头，其值为消息体的内容长度。'
- en: '**content-type**: The SEND, MESSAGE and ERROR frames contain content-type.
    It is similar to MIME type in web technology.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容类型（content-type）**：SEND、MESSAGE和ERROR帧包含内容类型。它在Web技术中类似于MIME类型。'
- en: '**receipt**: The CONNECT frame may contain receipt as header attribute to acknowledge
    the server of the RECEIPT frame.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收据（receipt）**：CONNECT帧可能包含收据作为头属性，以确认服务器收到RECEIPT帧。'
- en: '**heart-beat**: It got added by the CONNECT and CONNECTED frames. It contains
    two positive integer values separated by the comma.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**心跳（heart-beat）**：它由CONNECT和CONNECTED帧添加。它包含两个由逗号分隔的正整数值。'
- en: 1st value represents outgoing heart beats. '0' specifies it cannot send heart
    beats.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个值代表外出心跳。'0'指定它不能发送心跳。
- en: 2nd value denotes incoming heart beats. '0' denotes unwillingness to receive
    the heart beats.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个值表示进入心跳。'0'表示不愿意接收心跳。
- en: Spring STOMP support
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring STOMP支持
- en: The Spring WebSocket application works as a STOMP broker to all the clients.
    Each message will be routed through the Spring controllers. These controllers
    are capable of handling HTTP request and response by @RequestMapping annotation.
    Similarly they are capable of handling WebSocket Messages in all those methods
    who are annotated by @Messaging. Spring also facilitates integration of RabbitMQ,
    ActiveMQ as the STOMP brokers for the message broad casting.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebSocket应用程序作为STOMP代理对所有客户端工作。每个消息将通过Spring控制器进行路由。这些控制器通过@RequestMapping注解处理HTTP请求和响应。同样，它们也通过@Messaging注解处理WebSocket消息。Spring还提供了将RabbitMQ、ActiveMQ作为STOMP代理以进行消息广播的集成。
- en: 'Let'' us develop an application to use STOMP step by step:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步开发一个使用STOMP的应用程序：
- en: Create Ch10_Spring_Messaging_STOMP as a dynamic web application and add the
    jars which we added earlier.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Ch10_Spring_Messaging_STOMP作为一个动态网络应用程序，并添加我们之前添加的jar文件。
- en: Add mapping for DispatcherServlet in web.xml having books as name and 'webS'
    as URL pattern.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在web.xml中为DispatcherServlet添加映射，其名称为books，URL模式为'webS'。
- en: Add books-servlet.xml to register bean for 'viewResolver'. Registration to discover
    the controllers and to consider all MVC annotations.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加books-servlet.xml以注册`viewResolver`bean。注册以发现控制器，并考虑所有MVC注解。
- en: 'Add WebSocketConfig_custom as a class in com.packt.ch10.config package to add
    the ''`/book''` as endpoint enabled for SockJS. ''`/topic''` as SimpleBroker for
    ''`/bookApp''` as prefix. The code is as shown below:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch10.config包中添加WebSocketConfig_custom作为一个类，以将`'/book'`作为SockJS的端点，将`'/topic'`作为`'/bookApp'`前缀的SimpleBroker。代码如下：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The @EnableWebSocketMessageBroker enables the class to act as a message broker.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableWebSocketMessageBroker`使类能够作为消息代理。'
- en: Add POJO MyBook with bookName as data member in com.packt.ch10.model package.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch10.model包中添加具有bookName作为数据成员的MyBook POJO。
- en: 'Similarly add Result having result as data member as POJO having getOffer method
    as:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，添加一个结果为数据成员的Result POJO，其具有getOffer方法如下：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add index.html to have the link for the ''`bookPage''` from the controller
    as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加index.html以从控制器获取'`bookPage`'链接如下：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Add WebSocketController class in com.packt.ch10.controller package and annotate
    it by @Controller("webs").
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch10.controller包中添加WebSocketController类，并用@Controller("webs")注解它。
- en: 'Add `bookPage()` method annotated by @RequestMapping to send bookPage.jsp to
    the client as shown below:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加注解为@RequestMapping的`bookPage()`方法，以将bookPage.jsp发送给客户端，如下所示：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add bookPage.jsp in the jsps folder. The page will display book names to get
    offers associated with them. The code will be as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在jsps文件夹中添加bookPage.jsp。该页面将显示获取相关优惠的书籍名称。代码如下：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will be handling the call back methods, once the client click the button.
    Add the scripts for sockjs and STOMP as:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦客户端点击按钮，我们将处理回调方法，并添加sockjs和STOMP的脚本如下：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we will add connect, disconnect, send, subscribe one by one. Let'' us first
    add connect method to get the STOMP connection as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将逐一添加连接、断开连接、发送、订阅的方法。让我们首先添加如下获取STOMP连接的连接方法：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The connect method creates an object of SockJS and using `Stomp.over()` adds
    support for STOMP protocol. The connection adds the `subscribe()` to subscribe
    the messages from `''topic/showOffer''` handler. We had added ''`/topic''` as
    the SimpleBroker in the WebSocketConfig_custom class. We are handling, sending
    and receiving the JSON objects. The offers received by the Result JSON object
    will be in form of result: `value_of_offer`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '连接方法创建了一个SockJS对象，并使用`Stomp.over()`为STOMP协议添加支持。连接添加了`subscribe()`来订阅`''topic/showOffer''`处理器的消息。我们在WebSocketConfig_custom类中添加了`''/topic''`作为SimpleBroker。我们正在处理、发送和接收JSON对象。由Result
    JSON对象接收的优惠将以`result: value_of_offer`的形式出现。'
- en: 'Add disconnect method as:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加断开连接的方法如下：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add sendBook to sent the request to get the offer as:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加sendBook以发送获取优惠的请求如下：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `send()` gives request to the handler `/bookApp/book`, which will accept
    JSON object having `bookName` data member. We registered destination prefix as
    '`bookApp`' which we are using while sending the request.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`向处理程序`/bookApp/book`发送请求，该处理程序将接受具有`bookName`数据成员的JSON对象。我们注册了目的地前缀为''`bookApp`''，我们在发送请求时使用它。'
- en: 'Add method to display the offer as:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加显示优惠的方法如下：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let us add the handler method in controller for ''`/book''`. This method
    will be annotated by `@SendTo("/topic/showOffer''` as below:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在控制器中为'`/book`'添加处理程序方法。此方法将以下面所示的方式注解为`@SendTo("/topic/showOffer'`：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Deploy the application. And click on the link to get offer page.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署应用程序。然后点击链接获取优惠页面。
- en: Click on connect to get server connection. Select the book to know offer and
    click on send. The offers associated with the book will get displayed.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“连接”以获取服务器连接。选择书籍以了解优惠并点击发送。与书籍相关的优惠将显示出来。
- en: 'The following diagram explains the application flow:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了应用程序流程：
- en: '![](img/image_10_003.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_003.png)'
- en: 'On console the log will be displayed as below showing different frames of STOMP:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台上，日志将以下面的形式显示，展示了STOMP的不同帧：
- en: '![](img/image_10_004.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_004.png)'
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '* * *'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In this chapter we discussed in depth about the messaging using WebSocket. We
    took overview of why WebSocket is important and how it differs from the traditional
    web applications as well as the XMLHttpRequest based AJAX applications. We discussed
    the areas in which WebSocket can play a vital role. Spring provides API to work
    with WebSocket. We had seen WebSocketHandler, WebSocketConfigurer and its registration
    both using Java classes as well as XML based configurations using Capital of Country
    application. The SockJS library provides cross browser, JavaScript API to enable
    low latency, cross domain communication between the browser and server. We enabled
    the SockJS both in XML and Java configuration. We had also seen in depth about
    STOMP to be used in WebSocket over SockJS and to enable it and its event handling
    methods.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入讨论了使用WebSocket进行消息传递。我们概述了WebSocket的重要性以及它与传统网络应用程序以及基于XMLHttpRequest的AJAX应用程序的区别。我们讨论了WebSocket可以发挥重要作用的领域。Spring提供了与WebSocket一起工作的API。我们看到了WebSocketHandler、WebSocketConfigurer以及它们的使用，既使用了Java类，也使用了基于XML的配置，这些都使用国家首都应用程序来完成。SockJS库提供了跨浏览器、JavaScript
    API，以实现浏览器和服务器之间低延迟、跨域通信。我们在XML和Java配置中都启用了SockJS。我们还深入了解了STOMP，它是用于SockJS上的WebSocket以及如何启用它及其事件处理方法。
- en: In the next chapter, we will discover the reactive web programming.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章节中，我们将探索反应式网络编程。
- en: '![](img/image_01_038.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_01_038.png)'
- en: If you have any feedback on this eBook or are struggling with something we haven't
                                               covered, let us know at survey [link](https://goo.gl/y7BQfO).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对这本电子书有任何反馈，或者我们在*未覆盖*的方面遇到了困难，请在调查[链接](https://goo.gl/y7BQfO)处告诉我们。
- en: If you have any concerns you can also get in touch with us at
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有任何疑虑，您还可以通过以下方式与我们联系：
- en: '[customercare@packtpub.com](mailto:customercare@packtpub.com)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[customercare@packtpub.com](mailto:customercare@packtpub.com)'
- en: We will send you the next chapters when they are ready.........!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在准备好时发送给您下一章节........!
- en: Hope you like the content presented.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢我们呈现的内容。
