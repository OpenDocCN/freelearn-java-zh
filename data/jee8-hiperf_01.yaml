- en: Money – The Quote Manager Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 货币 – 引用管理器应用程序
- en: Before working on evaluating and enhancing the performance of your application,
    you need to indeed have an application. In this part, we will create a small application
    that we will use to illustrate every part of the book. This chapter doesn't intend
    to explain all the steps required to create a Java EE application. It will give
    you the overall steps and ensure that the references to the steps will be obvious
    later.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估和增强您应用程序的性能之前，您确实需要一个应用程序。在本部分中，我们将创建一个小应用程序，我们将用它来展示本书的每个部分。本章的目的不是解释创建
    Java EE 应用程序所需的全部步骤。它将给出总体步骤并确保后续步骤的引用将是明显的。
- en: 'The use case of this application will be a microservice that provides a set
    of web services to manage stocks and shares. This chapter will, therefore, introduce
    you to the application environment:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用程序的使用案例将是一个微服务，它提供一组网络服务来管理股票和股份。因此，本章将向您介绍应用程序环境：
- en: Application code structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序代码结构
- en: Database setup
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库设置
- en: Data persistence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据持久化
- en: Exposing data over HTTP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 HTTP 暴露数据
- en: Deploying your application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署您的应用程序
- en: Setting up the environment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: Before starting with writing code, make sure that you have an environment ready
    to work with Java EE. We need a **Java Virtual Machine 8** (**JVM 8**) and, more
    particularly, the **Java Development Kit** **8** (**JDK** **8**). As a quick reminder,
    Java EE version *V* is based on **Java Standalone Edition** (**Java SE**) version
    *V* as well. You can download the JDK on the Oracle website ([http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，请确保您有一个准备好的 Java EE 工作环境。我们需要一个 **Java 虚拟机 8**（**JVM 8**）以及更具体地说，**Java
    开发工具包** **8**（**JDK 8**）。作为一个快速提醒，Java EE 版本 *V* 基于 **Java 独立版**（**Java SE**）版本
    *V*。您可以在 Oracle 网站上下载 JDK（[http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)）。
- en: Alternatively, you can download the OpenJDK version of the JDK on the OpenJDK
    project website ([http://openjdk.java.net/install/](http://openjdk.java.net/install/)),
    but I recommend that you use the Oracle version. We will discuss this later in
    the book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在 OpenJDK 项目网站上下载 JDK 的 OpenJDK 版本（[http://openjdk.java.net/install/](http://openjdk.java.net/install/)），但我建议您使用
    Oracle 版本。我们将在本书的后续章节中讨论这个问题。
- en: Don't forget to accept the license agreement and select the right distribution
    for your operating system (Windows, Linux, or macOS).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记接受许可协议并选择适合您操作系统的正确发行版（Windows、Linux 或 macOS）。
- en: Now that we have a JDK, we need a tool to build our application and convert
    it into a format that we will be able to deploy in our Java EE server. This book
    will use Apache Maven ([https://maven.apache.org/](https://maven.apache.org/)) to
    build the application. It can be downloaded on the Apache Maven download page
    ([https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)).
    We need the binary distribution; Linux users have to select the `tar.gz` format
    while Windows users have to select the `.zip` archive.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 JDK，我们需要一个工具来构建我们的应用程序并将其转换为可以在我们的 Java EE 服务器上部署的格式。本书将使用 Apache Maven（[https://maven.apache.org/](https://maven.apache.org/)）来构建应用程序。它可以在
    Apache Maven 下载页面上下载（[https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)）。我们需要二进制发行版；Linux
    用户必须选择 `tar.gz` 格式，而 Windows 用户必须选择 `.zip` 归档。
- en: At this point, we have everything we need to create our application. You will
    probably want to have an **Integrated Development Environme****nt** (**IDE**),
    such as NetBeans ([https://netbeans.org/](https://netbeans.org/)), Eclipse ([https://eclipse.org/ide/](https://eclipse.org/ide/)),
    or Intellij Idea ([https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)).
    Since this book is more about performance than development, we won't go into much
    detail about IDEs. If you need one, just select the one you are the most familiar
    with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经拥有了创建我们应用程序所需的一切。您可能希望有一个 **集成开发环境**（**IDE**），例如 NetBeans（[https://netbeans.org/](https://netbeans.org/)）、Eclipse（[https://eclipse.org/ide/](https://eclipse.org/ide/)）或
    Intellij Idea（[https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)）。由于本书更多地关于性能而不是开发，我们不会深入讨论
    IDE。如果您需要，只需选择您最熟悉的即可。
- en: 'To ensure that the environment is ready, we will set variables to define where
    to find the software without having to use the full path to the binary or script
    each time. `JAVA_HOME` will point to the folder you extracted from the JDK, and
    `MAVEN_HOME` will point to the folder you extracted from the Apache Maven archive.
    Here is an example for Linux (replace `export` with `set` for a DOS shell):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保环境已准备就绪，我们将设置变量以定义软件的位置，而无需每次都使用完整的二进制文件或脚本的完整路径。`JAVA_HOME` 将指向您从 JDK 中提取的文件夹，而
    `MAVEN_HOME` 将指向您从 Apache Maven 存档中提取的文件夹。以下是一个 Linux 的示例（对于 DOS shell，请将 `export`
    替换为 `set`）：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we need to ensure that the JDK and Maven tools are available. For this,
    we add them to `PATH` on Linux and `Path` on Windows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保 JDK 和 Maven 工具可用。为此，我们将它们添加到 Linux 的 `PATH` 和 Windows 的 `Path` 中：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can validate your setup by executing the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令来验证您的设置：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To run a Java EE application, we also need a container, such as GlassFish, WildFly,
    WebSphere Liberty Profile, or Apache TomEE. The deployment being specific and
    Java EE 8 being very recent, we will use GlassFish in this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 Java EE 应用程序，我们还需要一个容器，例如 GlassFish、WildFly、WebSphere Liberty Profile 或
    Apache TomEE。由于部署是特定的，Java EE 8 非常新，我们将在这本书中使用 GlassFish。
- en: 'Finally, to get everything ready, we will use a database. We will use MySQL
    as a very common case, but any other relational database will work as well. You
    can download MySQL from [https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/),
    but most Linux distributions will have a package ready to install. For instance,
    on Ubuntu you can just execute the following line:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使一切准备就绪，我们将使用数据库。我们将使用 MySQL 作为一个非常常见的案例，但任何其他关系型数据库也可以正常工作。您可以从 [https://dev.mysql.com/downloads/mysql/](https://dev.mysql.com/downloads/mysql/)
    下载 MySQL，但大多数 Linux 发行版都将有一个可安装的软件包。例如，在 Ubuntu 上，您只需执行以下行：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The application architecture
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序架构
- en: Our application will import some stock quotations daily; it will then expose
    them and allow you to update them through a web service.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将每天导入一些股票报价；然后将其公开，并允许您通过 Web 服务进行更新。
- en: 'To implement it, we will use a standard Java EE architecture:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现它，我们将使用标准的 Java EE 架构：
- en: The persistence layer will use JPA 2.2 and store the data in a MySQL database.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久层将使用 JPA 2.2 并将数据存储在 MySQL 数据库中。
- en: 'A service layer will implement the business logic and orchestrate the persistence
    layer. It will rely on the following:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层将实现业务逻辑并协调持久层。它将依赖于以下内容：
- en: '**Java Transaction API** (**JTA**) 1.2 for transactionality'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 事务 API** （**JTA**） 1.2 用于事务性'
- en: '**Context and Dependency Injection** 2.0 (**CDI**) for **Inversion of Control**
    (**IoC**)'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文和依赖注入** 2.0 （**CDI**） 用于 **控制反转** （**IoC**）'
- en: Bean Validation 2.0 for validations
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bean Validation 2.0 用于验证
- en: 'A front layer will expose a part of the service layer through HTTP. It will
    rely on the following:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端层将通过 HTTP 公开服务层的一部分。它将依赖于以下内容：
- en: JAX-RS 2.1 for stateless endpoints
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS 2.1 用于无状态端点
- en: WebSocket 1.1 for stateful communications
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket 1.1 用于有状态通信
- en: JSON-B 1.0 for marshalling/unmarshalling
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-B 1.0 用于序列化/反序列化
- en: 'Here is a picture summarizing this structure:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一张总结此结构的图片：
- en: '![](img/ae41dfe2-23c1-40d1-8b26-2005e62ebb7e.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae41dfe2-23c1-40d1-8b26-2005e62ebb7e.png)'
- en: Application project highlights
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序项目亮点
- en: To be able to create and run this application, we will need to set up a build
    tool. For this book, it will be Apache Maven; however, Gradle, Ant, or any other
    alternative will work perfectly as well. We will then identify some key parts
    of the application code and, finally, we will insert some data to ensure that
    our application is usable before investigating its performance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够创建和运行此应用程序，我们需要设置一个构建工具。对于本书，它将是 Apache Maven；然而，Gradle、Ant 或任何其他替代品也可以完美工作。然后我们将确定应用程序代码的一些关键部分，最后，我们将插入一些数据以确保在调查其性能之前我们的应用程序是可用的。
- en: The build
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: 'The only dependency Java EE requires is the Java EE API:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 所需的唯一依赖项是 Java EE API：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you prefer, you can indeed register all the individual specifications, but
    it will require more work to maintain the list with Java EE upgrades. For this
    reason, the bundle is often preferred.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您确实可以注册所有单个规范，但这将需要更多的工作来维护与 Java EE 升级同步的列表。因此，通常更倾向于使用捆绑包。
- en: Here, the point is to ensure that the API is provided, which means it will not
    be packaged in the deliverable and will inherit from the server API. The server
    providing the services associated with the API also provides the API with the
    right supported version and the right defaults matching the built-in implementations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，重点是确保提供API，这意味着它将不会包含在交付物中，并将继承自服务器API。提供与API相关服务的服务器还提供了与内置实现匹配的正确支持的版本和默认值。
- en: 'Since Java EE 6, there are two main flavors of Java EE: the web profile and
    the full profile. The web profile is a light version, with only half the specifications
    compared with the full profile, more or less. The web profile supports only web
    applications and, therefore, `war` files. Most of this book will work with a web
    profile server, so we will package our application as `war`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java EE 6以来，Java EE有两种主要版本：Web版本和完整版本。Web版本是一个轻量级版本，与完整版本相比，规格大约少一半。Web版本仅支持Web应用程序和`war`文件。本书的大部分内容将使用Web版本服务器，因此我们将我们的应用程序打包为`war`：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since we need Java 8, don''t forget to configure the Java source and target
    version in the build. It can be done in different ways, but configuring `maven-compiler-plugin` as
    follows is an efficient one:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要Java 8，不要忘记在构建中配置Java源和目标版本。这可以通过不同的方式完成，但将`maven-compiler-plugin`配置如下是一种有效的方法：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The persistence layer
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久层
- en: 'Our data model will be simple: a *quote* will be linked to a *customer*. This
    means that a *customer* can see a set of *quotes*, and *quotes* can be seen by
    a set of customers. In terms of use cases, we want to be able to monetize our
    API and make the customers pay to access some quote prices. To do so, we will
    need a sort of whitelist of quotes per customer.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据模型将是简单的：一个*报价*将与一个*客户*相关联。这意味着一个*客户*可以查看一组*报价*，而*报价*可以被一组客户看到。在用例方面，我们希望能够货币化我们的API并让客户为访问某些报价价格付费。为此，我们需要为每个客户创建一种报价的白名单。
- en: 'JPA uses a descriptor called `persistence.xml`, placed in the META-INF repository
    of resources (or WEB-INF), which defines how `EntityManager`, which is a class
    that allows the manipulation of our model, will be instantiated. Here is what
    it looks like for our application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JPA使用一个名为`persistence.xml`的描述符，位于资源（或WEB-INF）的META-INF存储库中，它定义了`EntityManager`的实例化方式，这是一个允许操作我们模型的类。以下是我们的应用程序的示例：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The link between the database and the Java code is done through entities. An
    entity is a **plain old java object** (**POJO**) that is decorated with the `javax.persistence`
    annotations. They mainly define the mapping between the database and the Java
    model. For instance, `@Id` marks a Java field that must match the database identifier.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库和Java代码之间的链接是通过实体完成的。实体是一个**普通的Java对象**（**POJO**），它被`javax.persistence`注解装饰。它们主要定义了数据库和Java模型之间的映射。例如，`@Id`标记了一个必须与数据库标识符匹配的Java字段。
- en: 'Here is an example of our `Quote` entity:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的`Quote`实体的一个示例：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This simple model implicitly defines a *QUOTE* table with three columns, *ID,
    NAME,* and *VALUE* (the casing can depend on the database), and a table to manage
    the relationship with the *CUSTOMER* table, which is named  `QUOTE_CUSTOMER` by
    default.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的模型隐式定义了一个具有三个列（*ID, NAME, VALUE*）（大小写可能取决于数据库）的*QUOTE*表，以及一个用于管理与*CUSTOMER*表关系的表，默认命名为`QUOTE_CUSTOMER`。
- en: 'In the same spirit, our `Customer` entity just defines an identifier and name
    as columns and also the reverse relationship to the `Quote` entity:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的精神，我们的`Customer`实体仅定义了标识符和名称作为列，以及与`Quote`实体的反向关系：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What is important here is to notice the relationships in the model. We will
    deal with this later on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里重要的是要注意模型中的关系。我们稍后会处理这个问题。
- en: The service layer
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务层
- en: The goal of the book being to discuss the performance and not how to write a
    Java EE application, we will not detail the whole service layer here. However,
    to ensure a common knowledge of what we are dealing with, we will illustrate the
    code with one service.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的目的是讨论性能而不是如何编写Java EE应用程序，我们不会在这里详细说明整个服务层。然而，为了确保我们对所处理内容的共同理解，我们将用一个服务来展示代码。
- en: 'We are using JTA 1.2 with JPA 2.2 to establish a link between our database
    and the Java model. The `QuoteService` bean, responsible for managing the `Quote`
    persistence, can therefore look like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用JTA 1.2和JPA 2.2来在数据库和Java模型之间建立连接。因此，负责管理`Quote`持久性的`QuoteService`组件可以如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: JPA may or may not be used in a transactional context, depending on the kind
    of operation you do. When you *read* data, you can often do it without any transaction
    until you need some lazy loading. However, when you *write* data (insert/update/delete
    entities), JPA requires a running transaction to be able to execute the action.
    This is to ensure consistency of data but also has some implications on the code.
    To respect that requirement, and have an active transaction, we use `@Transactional` on
    methods instead of relying on **Enterprise Java Bean** **3.2** (**EJB 3.2**),
    so we can reuse the power of CDI (`@ApplicationScoped`, for instance, which will
    avoid creating a new instance per injection).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JPA可能在事务性上下文中使用，也可能不使用，这取决于你进行的操作类型。当你*读取*数据时，你通常可以在不需要任何事务的情况下完成，直到你需要一些懒加载。然而，当你*写入*数据（插入/更新/删除实体）时，JPA需要一个正在运行的事务来执行操作。这是为了确保数据的一致性，但也对代码有一些影响。为了遵守这一要求，并保持一个活跃的事务，我们在方法上使用`@Transactional`而不是依赖于**企业Java
    Bean 3.2**（**EJB 3.2**），这样我们就可以重用CDI（例如`@ApplicationScoped`，这将避免每次注入时创建一个新的实例）的力量。
- en: 'Our finders are very simple and directly use the `EntityManager` API. The only
    new thing Java 8 brings us in this code is the ability to wrap the result with
    `Optional` which offers a programmatic way to deal with the presence or absense
    of the entity instead of relying on a null check. Concretely, the caller can use
    our finder this way:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的查找器非常简单，直接使用`EntityManager` API。Java 8在这个代码中带给我们的唯一新功能是使用`Optional`包装结果的能力，这提供了一种程序化的方式来处理实体是否存在，而不是依赖于空值检查。具体来说，调用者可以使用我们的查找器这样：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This kind of code hides the conditional branches behind a fluent API, which
    makes it more expressive and readable, while the lambdas stay small enough.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码将条件分支隐藏在流畅的API之后，这使得代码更加易于表达和阅读，同时lambda表达式保持足够的小。
- en: Finally, we used inline queries in this code, not static ones like in the `@NamedQuery`
    API.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在代码中使用了内联查询，而不是像在`@NamedQuery` API中那样的静态查询。
- en: The JAX-RS layer
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAX-RS层
- en: 'If we step back one second and think about which stopover the application will
    execute, we can identify a few of them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们退后一步，思考应用程序将执行哪些操作，我们可以识别出其中的一些：
- en: HTTP communication handling
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP通信处理
- en: Payload (un)marshalling
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载（反）序列化
- en: Routing
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: Service invocation
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务调用
- en: 'Because of the separation of concern principles, or simply for technical constraints
    between layers, it is very common to use a Data Transfer Object between the JAX-RS/front
    layer and the CDI/business layer. Of course, this statement can be applied to
    the business sub-layers as well, but in the case of this book, we will just do
    it in the JAX-RS layer. To make it obvious in the book, we will prefix the JAX-RS
    model with `Json`. Check out the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关注点分离原则，或者简单地说，由于层与层之间的技术约束，在JAX-RS/前端层和CDI/业务层之间使用数据传输对象（DTO）是非常常见的。当然，这个陈述也可以应用于业务子层，但在这个书中，我们只会在JAX-RS层这样做。为了在书中使其明显，我们将JAX-RS模型前缀为`Json`。查看以下代码片段：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this context, the front layer role is to delegate most of the logic to the
    service layer and convert the business model to the front model (it can almost
    be seen as a Java to JavaScript conversion for a lot of modern applications):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，前端层的角色是将大部分逻辑委托给服务层，并将业务模型转换为前端模型（对于许多现代应用来说，这几乎可以看作是Java到JavaScript的转换）：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We set the JAX-RS `@ApplicationPath` to `/api` to ensure that our endpoints
    are deployed under the `/api` subcontext.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将JAX-RS的`@ApplicationPath`设置为`/api`，以确保我们的端点部署在`/api`子上下文中。
- en: The WebSocket layer
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket层
- en: Why use JAX-RS and WebSocket? Don't they serve the same purpose? Not exactly,
    in fact, it is becoming more and more common to use both in the same application
    even if WebSocket is still a bit recent.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用JAX-RS和WebSocket？它们不是有相同的作用吗？实际上并不完全相同，事实上，在同一个应用程序中使用两者变得越来越普遍，即使WebSocket仍然相对较新。
- en: JAX-RS (and, more generally, HTTP/1 and the brand new HTTP/2) is generally web
    application oriented. Understand that it is often used for applications with a
    user interface (which needs to be compatible with all browsers). It is also commonly
    used in environments where you cannot assume much about the network setup. More
    particularly, in environments where you cannot assume the network setup, the proxies
    will let WebSocket connections work properly (either preventing them completely
    or disconnecting them too early). The last common case where HTTP-based solutions
    make a lot of sense is to try to target a market where clients can be developed
    in any language (Java, Python, Ruby, Go, Node.js, and so on). The fact that the
    technology is today spreading all over the world and works well with stateless
    connections, makes it easier to get started with, and it is therefore more accessible
    than WebSocket, which requires some care from client developers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS（以及更一般地，HTTP/1和全新的HTTP/2）通常是面向Web应用的。理解这一点，它通常用于需要与所有浏览器兼容的用户界面应用。它也常用于无法假设太多关于网络设置的环境。更具体地说，在无法假设网络设置的环境中，代理将允许WebSocket连接正常工作（要么完全阻止它们，要么过早地断开它们）。HTTP基于的解决方案在许多情况下都很有意义，例如尝试针对一个市场，其中客户端可以用任何语言（Java、Python、Ruby、Go、Node.js等）开发。事实上，这项技术今天在全球范围内传播，并且与无状态连接配合良好，这使得它更容易上手，因此比WebSocket更易于访问，因为WebSocket需要客户端开发者进行一些维护。
- en: However, WebSocket will fit cases where you have higher performance or reactivity
    constraints, a state to maintain in order to handle the business use case, or
    you simply want to push the information from the server without requiring a client
    operation (such as polling).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，WebSocket适合那些有更高性能或反应性约束、需要维护状态以处理业务用例，或者你只是想从服务器推送信息而不需要客户端操作（如轮询）的情况。
- en: 'When you start using a connected protocol such as WebSocket, the first thing
    to define is your own communication protocol: the format of the message you send/receive
    and the order of the messages (if needed).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用如WebSocket这样的连接协议时，首先要定义的是你自己的通信协议：你发送/接收的消息格式以及消息的顺序（如果需要）。
- en: 'Our WebSocket layer will be responsible for enabling a client to quickly access the quote prices.
    Therefore, we will react on a client''s request (it will contain the name of the quote
    that we want to get the price for) and we will respond with two pieces of information:
    whether we found the quote and the current price, if existing.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的WebSocket层将负责使客户端能够快速访问报价价格。因此，我们将对客户端的请求做出反应（它将包含我们想要获取价格的报价名称）并且我们将提供两块信息：是否找到了报价以及当前价格（如果存在）。
- en: Then, you need to pick a format to prepare the content sent through the WebSocket
    over the wire. Here, the choice is often guided by a trade-off between the client
    (consumers of the service), the requirements, the performances, and the ease of
    implementation. In our case, we will consider that our clients can be written
    in Java as well as in JavaScript. That is why we will use JSON.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要选择一个格式来准备通过WebSocket发送的内容。在这里，选择通常由客户端（服务的消费者）、需求、性能和实现简便性之间的权衡来指导。在我们的案例中，我们将考虑我们的客户端可以用Java以及JavaScript编写。这就是为什么我们将使用JSON。
- en: 'To summarize the protocol, here is a full communication round-trip, as shown
    in the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结协议，以下是一个完整的通信往返过程，如图所示：
- en: '![](img/047d3c1b-cce8-44cd-96bb-a5cc090c638c.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/047d3c1b-cce8-44cd-96bb-a5cc090c638c.png)'
- en: 'The communication protocol is based on a single message type in our case, so
    a full client/server communication looks like these steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，通信协议基于单一的消息类型，因此客户端/服务器通信看起来像以下步骤：
- en: The client will connect to the server.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将连接到服务器。
- en: The client will request the price of a quote N times, based on its symbol (name/identifier).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将根据其符号（名称/标识符）请求报价的价格N次。
- en: Assuming there is no I/O error or timeout, the client will trigger a disconnect,
    which will end the communication.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设没有I/O错误或超时，客户端将触发断开连接，从而结束通信。
- en: 'In terms of code, we need multiple bricks of Java EE and we need the following
    to put them together:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们需要多个Java EE组件，并且需要以下内容来将它们组合在一起：
- en: The WebSocket API, obviously
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然是WebSocket API
- en: JSON-B (we could use JSON-P, but it is less friendly) for the Java to JSON conversion
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON-B（我们可以使用JSON-P，但它不太友好）用于Java到JSON的转换
- en: CDI, to link the WebSocket to the business layer
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI，用于将WebSocket连接到业务层
- en: 'To start easy, we can modelize our payloads. Our request has only one `name`
    attribute, so JSON-B allows us to define it this way:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们可以对负载进行建模。我们的请求只有一个`name`属性，因此JSON-B允许我们这样定义它：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the other side (that is, the response), we have to return a `value` attribute
    with the price of the quote and a `found` Boolean marking `value` as filled or
    not. Here again, JSON-B allows us to do a direct mapping of this model with a
    plain POJO:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一边（即响应），我们必须返回一个带有报价价格的`value`属性和一个标记`value`是否填充的`found`布尔值。在这里，JSON-B也允许我们直接将此模型与一个普通的POJO进行映射：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we need to ensure that the WebSocket will be able to deserialize and serialize these
    objects as required. The specification defines `Encoder` and `Decoder` APIs for
    this purpose. Since we will back our implementation by JSON-B, we can directly
    implement it using the (I/O) stream flavors of these APIs (called `TextStream`).
    Actually, before doing so, we need to get a `Jsonb` instance. Considering that
    we have already created one and made it available in CDI, we can then simply inject
    the instance in our coders:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保WebSocket能够按需反序列化和序列化这些对象。规范定义了`Encoder`和`Decoder` API来实现这个目的。由于我们将使用JSON-B作为我们的实现后端，我们可以直接使用这些API的（I/O）流版本（称为`TextStream`）来实现它。实际上，在这样做之前，我们需要获取一个`Jsonb`实例。考虑到我们已经在CDI中创建了一个并使其可用，我们可以在我们的编码器中简单地注入该实例：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The decoding side is now fast to develop, thanks to the JSON-B API, which fits
    this usage very well with its `fromJson()` API. We will just note that this side
    is specific to `ValueRequest`*,* since we need to specify the type to instantiate
    it (compared with the encoding side, which can determine it dynamically):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSON-B API非常适合这种用法，解码部分现在开发起来很快，我们将注意这一部分是针对`ValueRequest`的，因为我们需要指定要实例化的类型（与编码部分相比，编码部分可以动态确定它）：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have a way to handle our messages, we need to bind our WebSocket
    endpoint and implement the `@OnMessage` method to find the price and send it back
    to the client relying on our business layer. In terms of implementation, we will
    react to a `ValueRequest` message, try to find the corresponding quote, fill the
    response payload, and send it back to the client:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了处理消息的方法，我们需要绑定我们的WebSocket端点并实现`@OnMessage`方法，以便根据我们的业务层找到价格并将其发送回客户端。在实现方面，我们将响应一个`ValueRequest`消息，尝试找到相应的报价，填充响应负载，并将其发送回客户端：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Provision some data
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置一些数据
- en: At this point, we have our application. Now, we need to ensure that it has some
    data and, then, move on to evaluating its performance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了我们的应用程序。现在，我们需要确保它有一些数据，然后继续评估其性能。
- en: 'Without delving too much into the business details, we will implement the provisioning
    in two passes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入业务细节，我们将分两步实现配置：
- en: Find all the symbols to update
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到所有需要更新的符号
- en: For each symbol found, update the price in the database
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于找到的每个符号，更新数据库中的价格
- en: 'To do so, we will use two public webservices:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用两个公开的web服务：
- en: '[http://www.cboe.com/publish/ScheduledTask/MktData/cboesymboldir2.csv](http://www.cboe.com/publish/ScheduledTask/MktData/cboesymboldir2.csv),
    to find a set of symbols'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.cboe.com/publish/ScheduledTask/MktData/cboesymboldir2.csv](http://www.cboe.com/publish/ScheduledTask/MktData/cboesymboldir2.csv)，以找到一组符号'
- en: '[https://query1.finance.yahoo.com/v10/finance/quoteSummary/{symbol}?modules=financialData](https://query1.finance.yahoo.com/v10/finance/quoteSummary/%7Bsymbol%7D?modules=financialData),
    to find the current price of each quote'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://query1.finance.yahoo.com/v10/finance/quoteSummary/{symbol}?modules=financialData](https://query1.finance.yahoo.com/v10/finance/quoteSummary/%7Bsymbol%7D?modules=financialData)，以找到每个报价的当前价格'
- en: The first one is a plain CSV file, which we will parse without any library to
    keep things simple and because the format does not require special escaping/parsing. The
    second one will return a JSON payload, which we can read directly using the JAX-RS
    2.1 client API.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是普通的CSV文件，我们将不使用任何库来解析它，以保持事情简单，因为该格式不需要特殊的转义/解析。第二个将返回一个JSON负载，我们可以直接使用JAX-RS
    2.1客户端API读取。
- en: 'Here is how we can retrieve our data:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们检索数据的方式：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we directly read a buffered reader backed by the HTTP response stream. Once
    the symbols are extracted, we can simply iterate over them and request the price
    of each quote:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们直接读取由HTTP响应流支持的缓冲读取器。一旦提取了符号，我们就可以简单地遍历它们并请求每个报价的价格：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This piece of code sends an HTTP request, thanks to the JAX-RS client API and
    JSON-B, which unmarshalls a data model. Then, we use the obtained data to update
    our database quote if it already exists; otherwise, we use the data to create
    the database quote.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过 JAX-RS 客户端 API 和 JSON-B 发送一个 HTTP 请求，它解包一个数据模型。然后，我们使用获得的数据更新我们的数据库报价，如果它已经存在；否则，我们使用这些数据创建数据库报价。
- en: 'The code now needs to be wired to be executed. We have multiple options here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在需要被连接起来以便执行。我们在这里有多种选择：
- en: Execute it at startup
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动时执行
- en: Execute it regularly
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期执行
- en: Execute it when an endpoint is called
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当端点被调用时执行
- en: In the context of this book, we will use the first two options. The startup
    is common for us, even if it is not as realistic, because once started, we will
    get some data. The second option will use an EJB 3.2 `@Schedule`, which will run
    hourly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的上下文中，我们将使用前两个选项。启动对我们来说很常见，即使它并不那么现实，因为一旦启动，我们就会得到一些数据。第二个选项将使用 EJB 3.2
    的 `@Schedule`，它将每小时运行一次。
- en: 'The startup implementation requires a simple CDI bean with a method calling
    the previous logic when `@ApplicationScoped` is created (at startup):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 启动实现需要一个简单的 CDI 容器，当创建 `@ApplicationScoped`（在启动时）时调用之前的逻辑：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The scheduling is done, thanks to the Enterprise Java Bean `@Schedule` API,
    which allows us, in one annotation, to request the container to regularly execute
    a method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 调度是通过企业 Java Bean `@Schedule` API 完成的，它允许我们通过一个注解请求容器定期执行一个方法：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In a real application, you will probably want to configure the refresh frequency
    and use the `TimerService` API to trigger the execution based on the application
    configuration. In the same spirit, the startup execution could be ignored based
    on the configuration in order to have a faster startup.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用程序中，你可能希望配置刷新频率并使用 `TimerService` API 根据应用程序配置触发执行。同样，根据配置可以忽略启动执行以实现更快的启动。
- en: Application summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序摘要
- en: 'When working on the performance, it is always important to keep two things
    in mind:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理性能时，始终需要记住两点：
- en: The application business (what the application does)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序业务（应用程序做什么）
- en: The application technical stack (how the application was designed)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序技术栈（应用程序是如何设计的）
- en: Even if the information you have about these two points is very high-level,
    ensure that you know them before working on the performance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你对这两个点的信息非常高级，但在处理性能之前，确保你知道它们。
- en: Let's do this exercise with our application and ensure that we know how to answer
    both the questions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们的应用程序来做这个练习，并确保我们知道如何回答这两个问题。
- en: The application business
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序业务
- en: Our application is responsible for providing the quote prices to HTTP or WebSocket
    clients. With its model and customer/quote relationship, it can enable us to provide
    (or not provide) the price accessed by the customer if we add permissions or rules,
    for instance. What is important to see at this stage is that both the entities
    are in a relationship and that our application can visit this relationship for
    its business needs and trigger an implicit lazy loading of the relationship entities.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序负责向 HTTP 或 WebSocket 客户端提供报价价格。凭借其模型和客户/报价关系，它可以使我们提供（或不对客户提供）价格，如果我们添加权限或规则，例如。在这个阶段，重要的是要看到这两个实体之间存在关系，并且我们的应用程序可以访问这个关系以满足其业务需求并触发关系实体的隐式延迟加载。
- en: The data is injected into the system based on two external HTTP sources (CBOE
    and Yahoo). The first one provides a symbol dictionary of the quotes*,* and the
    second one, the prices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数据基于两个外部 HTTP 源（CBOE 和 Yahoo）注入到系统中。第一个提供报价的符号字典，第二个提供价格。
- en: The application design
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序设计
- en: Technically, the provisioning of the quote and prices is done asynchronously
    (not when a customer request is sent). It retrieves the data using a JAX-RS 2.1
    client and inserts it as fast as possible into the database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，报价和价格的提供是异步完成的（不是在客户请求发送时）。它使用 JAX-RS 2.1 客户端检索数据，并尽可能快地将其插入数据库。
- en: Access to the application is gained either through HTTP or WebSocket. In both
    cases, the application uses a JSON format for message exchange.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 访问应用程序是通过 HTTP 或 WebSocket 实现的。在两种情况下，应用程序都使用 JSON 格式进行消息交换。
- en: The application server
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序服务器
- en: Java EE defines specifications and, therefore, you can find several different
    implementations. Each major vendor has its own server but, of course, for us and
    Java EE, a lot of servers are fully open source. As Java EE 8 is very recent,
    we will use GlassFish, which is the reference implementation and is therefore
    the first one to be compliant with the specification (it must be released with
    the specification). However, there are a lot of alternatives (such as Apache TomEE,
    Wildfly, Payara, Liberty Profile, and so on), which will probably follow in the
    coming months.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE 定义规范，因此你可以找到几个不同的实现。每个主要供应商都有自己的服务器，但当然，对我们和 Java EE 来说，许多服务器是完全开源的。由于
    Java EE 8 非常新，我们将使用 GlassFish，它是参考实现，因此是第一个符合规范（它必须与规范一起发布）的实现。然而，有很多替代方案（如 Apache
    TomEE、Wildfly、Payara、Liberty Profile 等），它们可能会在未来几个月内出现。
- en: GlassFish can be downloaded from its website ([https://javaee.github.io/glassfish/download](https://javaee.github.io/glassfish/download)). We
    need the 5.x version to target Java EE 8, but due to its early release, a major
    part of this book will work with the previous versions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从其网站下载 GlassFish ([https://javaee.github.io/glassfish/download](https://javaee.github.io/glassfish/download))。我们需要
    5.x 版本来针对 Java EE 8，但由于其早期发布，本书的大部分内容将使用之前的版本。
- en: 'If you want to integrate it with your development environment (and Maven),
    you can add the GlassFish repository to `pom.xml`, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将其与你的开发环境（以及 Maven）集成，你可以将 GlassFish 仓库添加到 `pom.xml` 中，如下所示：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the GlassFish plugin without forgetting to specify the version of the server
    in order to override the default one, which is now quite old:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加 GlassFish 插件时，不要忘记指定服务器的版本以覆盖默认版本，现在的默认版本相当老旧：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this setup, you can run the following command to package the application as
    `war` and deploy it in GlassFish:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，你可以运行以下命令来打包应用程序为 `war` 并在 GlassFish 中部署：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To shut down the server, type *X* and *ENTER*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭服务器，请输入 *X* 和 *ENTER*。
- en: Testing the application
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: Before starting to work on our application from the performance window, let's
    get a bit familiar with it. We will not browse and test all the endpoints but
    just check how to get a price using the JAX-RS layer and WebSocket layer. In other
    words, we will define two customer use cases of our application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从性能窗口开始工作我们的应用程序之前，让我们先熟悉一下它。我们不会浏览和测试所有端点，而只是检查如何使用 JAX-RS 层和 WebSocket
    层获取价格。换句话说，我们将定义我们应用程序的两个客户用例。
- en: The goal here is to ensure that we know how to use the application to be able
    to write test scenarios later. To do so, we will execute some requests manually
    on both fronts (HTTP and WebSocket).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的目标是确保我们知道如何使用应用程序来编写测试场景。为此，我们将在两个前端（HTTP 和 WebSocket）上手动执行一些请求。
- en: Get a quote price the JAX-RS way
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以 JAX-RS 方式获取报价价格
- en: The endpoint we saw previously has been deployed on `/<application_context>/api/quote/{quoteId}`
    with the context of the web application, `application_context`. If you used the
    previous setup, it is, most likely, the artifact ID of the Maven project. Let's
    consider from now on that it is `quote-manager`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的端点已部署在 `/application_context/api/quote/{quoteId}` 上，其上下文为网络应用程序，`application_context`。如果你使用了之前的设置，它很可能是
    Maven 项目的 artifact ID。从现在开始，我们假设它是 `quote-manager`。
- en: 'Here is what it returns for one of the quotes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其中一个报价的返回结果：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This kind of application often needs a kind of index endpoint to be able to
    browse quotes (in a nice user interface or a command-line interface, for instance).
    In our case, it is our *find all* endpoint, which supports pagination through
    the query parameters. Here is how to use it and the kind of data it returns:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这类应用程序通常需要一个索引端点来浏览报价（例如，在良好的用户界面或命令行界面中）。在我们的案例中，它是我们的 *find all* 端点，它通过查询参数支持分页。以下是它的使用方法和返回的数据类型：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Get the price, the WebSocket way
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以 WebSocket 方式获取价格
- en: 'The WebSocket endpoint is deployed on `/<application_context>/quote`, and some
    exchanges can look like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 端点部署在 `/application_context/quote` 上，一些交换可能看起来像以下这样：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What is interesting to see in this communication dump is the fact that the connection
    lasts for more than one request, and it is based on the symbol more than the identifier
    (compared to the previous JAX-RS samples).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个通信转储中，有趣的是连接持续了多个请求，并且它基于符号而不是标识符（与之前的 JAX-RS 示例相比）。
- en: Setting up MySQL
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 MySQL
- en: All the previous parts will work transparently in Glassfish, as it can provide
    you with a default database if none is set since Java EE 7\. This default database is
    an Apache Derby one for Glassfish. Considering that we will work on the performance
    soon, we want a recent *production* database. To ensure this, we will set up MySQL.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一部分在Glassfish中都将透明地工作，因为它可以在没有设置的情况下为你提供一个默认数据库，自Java EE 7以来就是这样。这个默认数据库是Glassfish的Apache
    Derby。考虑到我们将很快开始处理性能问题，我们希望有一个最新的*生产*数据库。为了确保这一点，我们将设置MySQL。
- en: 'Assuming that you installed MySQL for your operating system and that it runs
    on `localhost:3306` (the default), we need to create a new database. Let''s call
    it `quote_manager`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经为你的操作系统安装了MySQL，并且它运行在`localhost:3306`（默认端口），我们需要创建一个新的数据库。让我们称它为`quote_manager`：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have a database, we can configure it in Glassfish and let JPA 2.2
    create the tables for us based on our model. For this, we need to create `glassfish-resources.xml`
    in the `WEB-INF` folder of the `war` package (put it in `src/main/webapp/WEB-INF`
    in the Maven project):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据库，我们可以在Glassfish中配置它，并让JPA 2.2根据我们的模型为我们创建表。为此，我们需要在`war`包的`WEB-INF`文件夹中创建`glassfish-resources.xml`（在Maven项目中，将其放在`src/main/webapp/WEB-INF`中）：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively, you can also do it through code using the `@DataSourceDefinition`
    annotation, which is more portable than the specific descriptor of GlassFish (this
    is the solution we will rely on from now on):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以通过代码使用`@DataSourceDefinition`注解来完成，这比GlassFish的具体描述符更便携（这是我们今后将依赖的解决方案）：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you recompile and restart the server, you will see that it has created the
    tables, thanks to our `persistence.xml` configuration:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新编译并重新启动服务器，你会看到它已经创建了表，这要归功于我们的`persistence.xml`配置：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you are waiting for the server to start and have kept the provisioning activated,
    you will also see some data in the `QUOTE` table:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在等待服务器启动并且保留了配置激活，你也会在`QUOTE`表中看到一些数据：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Conclusion
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Now we have our functional Quote Manager application, and we can deploy it in
    a Java EE 8 server (GlassFish here) and store our data in a *real* database (MySQL).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了功能齐全的报价管理器应用程序，我们可以将其部署在Java EE 8服务器（这里使用GlassFish）中，并将我们的数据存储在*真实*数据库（MySQL）中。
- en: Till now, we have mainly worked on making the application functional. Thanks
    to the high-level APIs of Java EE, this was not so hard, but it is important to
    understand what we used and what the performance implications of each element
    of our stack are, to be able to validate/invalidate the performance figures once
    you have them in your hands.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要致力于使应用程序功能化。多亏了Java EE的高级API，这并不那么困难，但了解我们使用了什么以及我们堆栈中每个元素的性能影响是很重要的，这样一旦你手头有了这些数据，你就能验证/无效化性能指标。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created an application responsible for managing quote prices
    and enabling clients to access them through HTTP and WebSockets. The application
    uses plain Java EE code (no external dependencies). We also saw how to link the
    application to a database. We used MySQL as the database, which is a free and
    very common choice.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个负责管理报价价格并允许客户端通过HTTP和WebSockets访问它们的程序。该应用程序使用纯Java EE代码（没有外部依赖）。我们还看到了如何将应用程序链接到数据库。我们使用了MySQL作为数据库，这是一个免费且非常常见的选项。
- en: In the next chapter, we will go deeper into the Java EE stack, and understand
    its role and what it implies for the application in terms of the application's
    performance.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨Java EE堆栈，并了解它在应用性能方面的作用及其含义。
