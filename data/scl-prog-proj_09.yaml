- en: Interactive Browser
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式浏览器
- en: In this chapter, we will introduce the actor model by extending our shopping
    project. The extension will consist of a notification, provided to anyone connected
    to the website, about who is adding/removing a product to/from the cart.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过扩展我们的购物项目来介绍 actor 模型。扩展将包括一个通知，提供给所有连接到网站的人，关于谁正在将产品添加到/从购物车中移除。
- en: Indeed, each time someone acts on the cart, a message will be broadcast to all
    of the connected browsers, and it will include the name of the user, the action
    (add or remove), and the product name.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，每当有人对购物车进行操作时，都会向所有连接的浏览器广播一条消息，其中包括用户名、操作（添加或删除）和产品名称。
- en: The workflow will be as follows. When someone is connected to the website, a
    web socket will be opened between the browser and the server; a reference to that
    web socket will be kept at the server level, inside of an Actor.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程将如下。当有人连接到网站时，浏览器和服务器之间将打开一个 WebSocket；在服务器级别，在 Actor 内部将保留对该 WebSocket
    的引用。
- en: As soon as an action is performed on the cart, a message with the username,
    action, and product name will be sent to the server through the web socket; the
    server will receive this message, transform it in to an alarm message, and broadcast
    it to all of the connected browsers. Each browser will then show the alarm as
    a notification. As soon as the browser disconnects (or the web socket timeout
    is reached), the web socket reference will be removed from the server.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对购物车执行操作，将包含用户名、操作和产品名称的消息将通过 WebSocket 发送到服务器；服务器将接收此消息，将其转换为警报消息，并广播给所有连接的浏览器。然后，每个浏览器将显示警报作为通知。一旦浏览器断开连接（或达到
    WebSocket 超时），将从服务器中移除 WebSocket 引用。
- en: As you may have noticed, the term Actor was used in the preceding workflow.
    The theory of the actor model originated in 1973 ([https://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask](https://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask)), and
    multiple implementations have been created since, in many languages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，在先前的流程中使用了 Actor 这个术语。Actor 模型的理论起源于 1973 年 ([https://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask](https://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask))，自那时起，已经创建了多个语言实现。
- en: In this book, we are going to use the Akka framework. It was written by Jonas
    Bonér in 2009 and is based on the Scala Actor implementation created by Philipp
    Haller. We will only scratch the surface of the framework by providing an introduction
    to it. This framework would require an entire book to explain all of its features
    and possible patterns.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 Akka 框架。它由 Jonas Bonér 在 2009 年编写，基于由 Philipp Haller 创建的 Scala Actor
    实现。我们将通过介绍它来仅触及框架的表面。要解释框架的所有功能和可能的模式，需要整本书。
- en: In this chapter, we will explain how to communicate between the client and the
    server using a web socket.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释如何使用 WebSocket 在客户端和服务器之间进行通信。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Actor models
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actor 模型
- en: Implementing the server side
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现服务器端
- en: Implementing the client side
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现客户端
- en: 'The objectives of this chapter are to establish asynchronous communication
    between the browser and the server using a web socket and to use Actors to handle
    the communication at the server level. You will learn the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是使用 WebSocket 在浏览器和服务器之间建立异步通信，并使用 Actor 在服务器级别处理通信。你将学习以下内容：
- en: How to create asynchronous communication between the client and the server
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在客户端和服务器之间创建异步通信
- en: How to use Actors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Actor
- en: Actors
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actor
- en: How can we define the term  Actor? In our first attempt, we considered explaining
    it technically, using a threading model, concurrency, call stacks, a mailbox,
    and so on. Then, we realized that a technical description doesn't reflect the
    essence of a solution based on Actors.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何定义 Actor 这个术语？在我们的第一次尝试中，我们考虑使用线程模型、并发、调用栈、邮箱等来技术性地解释它。然后，我们意识到技术描述并不能反映基于
    Actor 的解决方案的本质。
- en: In fact, every time we have to design a solution based on Actors, we can see
    the Actor as a human working in a company; this person has a name, and maybe an
    email address (**Actor reference**). The first important fact is that he is not
    alone; he is going to interact with others (**messaging**), receiving messages
    from his hierarchy and transmitting other messages to colleagues or subordinates
    (**supervisors**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，每次我们必须基于Actors设计解决方案时，我们都可以将Actor视为在公司工作的一个人；这个人有一个名字，也许有一个电子邮件地址（**Actor引用**）。第一个重要的事实是，他并不孤单；他将与其他人互动（**消息传递**），从他的层级接收消息，并将其他消息传递给同事或下属（**监督者**）。
- en: The imaginary company is structured using a hierarchy; a supervisor (**user
    guardian**) is looking at the health of its subordinate, and, when a problem is
    raised, if the supervisor can handle it, they will perform actions to fix it.
    If the error is unmanageable, the supervisor will escalate it to their own superior
    (**supervisor strategy**), and so on, until it reaches the director (**root guardian**).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想象中的公司使用层次结构进行组织；一个监督者（**用户守护者**）正在检查其下属的健康状况，当出现问题时，如果监督者可以处理，他们将执行操作来修复它。如果错误无法管理，监督者将将其升级到自己的上级（**监督策略**），依此类推，直到达到总监（**根守护者**）。
- en: Another similarity to communication between humans is that when you ask a colleague
    to do something and they do not answer. After a certain amount of time (a **timeout**),
    you might decide to ask again. If you still do not receive an answer, you might
    think that they are too busy and ask someone else. All of this protocol is performed
    asynchronously and is based on how long you are prepared to wait (**latency**).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与人类之间的沟通的另一个相似之处是，当你要求同事做某事而他们没有回答时。经过一段时间（一个**超时**），你可能会决定再次询问。如果你仍然没有收到回答，你可能会认为他们太忙了，然后询问其他人。所有这些协议都是异步执行的，并且基于你愿意等待多长时间（**延迟**）。
- en: Now, with these concepts in mind, technically, we could define an Actor as a
    lightweight unit of a process running on only one thread and handling messages
    one after the other; the Actor receives messages, processes them, and perhaps
    changes their internal states, based on the message. It then sends another message
    to the initial sender or any other Actor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这些概念在心中，技术上，我们可以将Actor定义为一个仅在一个线程上运行的轻量级进程单元，它依次处理消息；Actor接收消息，处理它们，并根据消息可能改变其内部状态。然后，它向初始发送者或任何其他Actor发送另一条消息。
- en: 'To perform all of this workflow, the Actor needs the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行所有这些工作流程，Actor需要以下内容：
- en: A reference, to be reached from within the same room (JVM) or remotely
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个参考，可以从同一房间（JVM）或远程访问
- en: A mailbox, to queue incoming messages
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个邮箱，用于排队等待接收的消息
- en: A state, to save its private state
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个状态，用于保存其私有状态
- en: A behavior, to act based on the received messages and current state
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个行为，根据接收到的消息和当前状态进行行动
- en: A child Actor, as each Actor could potentially be a supervisor
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个子Actor，因为每个Actor都可能是一个监督者
- en: The purpose of this book is not to make you an expert on the Akka framework;
    instead, this book should provide you with the basic knowledge to feel comfortable
    with the fundamental concepts. The concepts that you will learn will allow you
    to build an application, and, if you wish, to go deeper into other components
    of the framework.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的不是让你成为Akka框架的专家；相反，这本书应该为你提供基本知识，让你对基本概念感到舒适。你将学习到的概念将允许你构建一个应用程序，如果你愿意，还可以深入了解框架的其他组件。
- en: As a reference, the complete Akka documentation can be found directly on the
    website of the Akka project at [https://doc.akka.io/docs/akka/current/general/index.html](https://doc.akka.io/docs/akka/current/general/index.html).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，完整的Akka文档可以直接在Akka项目的网站上找到，网址为[https://doc.akka.io/docs/akka/current/general/index.html](https://doc.akka.io/docs/akka/current/general/index.html)。
- en: Let's get straight to work and look at how this can be implemented in the real
    world.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始工作，看看如何在现实世界中实现这一点。
- en: Setting up
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: To set up our project, we will need the Akka library, in order to create Actors
    on the server, and Notify.js. Notify.js is a JavaScript library used to pop up
    notifications on the browser; we picked this library because it does not have
    any dependencies on other frameworks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置我们的项目，我们需要Akka库，以便在服务器上创建Actors，以及Notify.js。Notify.js是一个用于在浏览器上弹出通知的JavaScript库；我们选择这个库是因为它没有依赖其他框架。
- en: 'To add this JavaScript library, just add the following to `build.sbt`, under `jsDependencies` in
    the `client` variable:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加这个JavaScript库，只需将以下内容添加到`build.sbt`中的`client`变量的`jsDependencies`下：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code is for the configuration of the project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是项目配置的代码。
- en: Implementing the server side
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现服务器端
- en: At the server level, we need to open a communication channel between the server
    and the browser; once the communication is open, we need to implement the message
    reception and broadcast it to all of the connected browsers using Actors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器级别，我们需要在服务器和浏览器之间打开一个通信通道；一旦通信打开，我们需要实现消息接收并将它广播给所有已连接的浏览器，使用 Actor 来完成。
- en: Creating the web socket route
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 WebSocket 路由
- en: 'To create the route, the `conf/routes` file needs to be modified by adding
    the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建路由，需要修改 `conf/routes` 文件，添加以下内容：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the route is defined in the same way as a regular web service call;
    so, the `GET` call on `/v1/cart/events` is routed to the `cartEventWS` method
    of the `controllers.WebSockets` instance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，路由的配置方式与常规的 Web 服务调用相同；因此，对 `/v1/cart/events` 的 `GET` 调用被路由到 `controllers.WebSockets`
    实例的 `cartEventWS` 方法。
- en: 'Next, we need to create the `WebSockets` class in the `controllers` package
    of the server module, and add the `cartEventsWS` method, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在服务器模块的 `controllers` 包中创建 `WebSockets` 类，并添加 `cartEventsWS` 方法，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are not many lines of code, but a lot is happening in this snippet.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 代码行数不多，但在这个片段中发生了很多事情。
- en: On the class constructor, Google Guice (the dependency injection used in Play)
    is going to inject `ActorSystem`. `ActorSystem` is the root guardian of the system;
    this is the top level in the hierarchy of Actors and is unique for every JVM.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在类构造函数中，Google Guice（Play 中使用的依赖注入）将注入 `ActorSystem`。`ActorSystem` 是系统的根守护者；这是
    Actor 层次结构中的顶级，对于每个 JVM 都是唯一的。
- en: Play uses Akka-stream underneath; a materializer is needed. First, let us explain
    these new terms. Akka-stream is an Akka component used to nicely handle streams,
    and it is exactly what we need to take care of our stream between the server and
    the browser. Akka-stream is well engineered; there is a clear separation between
    the definitions in the stream, such as where the data should be taken, how to
    process it and where to move it, and the stream runtime. To define the stream,
    a **Domain-Specific Language** (**DSL**) is available, and the materializer is
    the runtime of the stream. That is why we need to provide `Materializer` in our
    code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Play 在底层使用 Akka-stream；需要一个 materializer。首先，让我们解释这些新术语。Akka-stream 是 Akka 组件，用于优雅地处理流，这正是我们需要处理服务器和浏览器之间流的工具。Akka-stream
    设计得很好；在流定义中有一个清晰的分离，例如数据应该从哪里获取，如何处理它以及应该移动到哪里，以及流运行时。为了定义流，有一个 **领域特定语言** (**DSL**)
    可用，而 materializer 是流的运行时。这就是为什么我们需要在我们的代码中提供 `Materializer`。
- en: The upstream is created with `ActorFlow.actorRef { out => }`, where `out` is
    an Actor representing the browser. This function should return an Actor handling
    messages from the browser. We will come back to the implementation later.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上游是通过 `ActorFlow.actorRef { out => }` 创建的，其中 `out` 是代表浏览器的 Actor。这个函数应该返回一个处理来自浏览器的消息的
    Actor。我们稍后会回到实现细节。
- en: To summarize, at this point, our server opens a new route on `/v1/cart/events`.
    At that entry point, a web socket connection is expected, and for each new connection,
    a new communication stream is started.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，到目前为止，我们的服务器在 `/v1/cart/events` 上打开了一个新的路由。在那个入口点，预期会有一个 WebSocket 连接，并且对于每个新的连接，都会启动一个新的通信流。
- en: Well, it is time to code the communication handling; but what do we want to
    do?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在是时候编写通信处理代码了；但我们想做什么呢？
- en: Implementing BrowserManager
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 BrowserManager
- en: Each time a new connection is accepted (representing a new browser), we would
    like to keep a reference to that connection, so that events can be sent to it
    later. This connection container is handled by an Actor. This Actor will need
    an internal state with the list of connected browsers; we should add a new browser,
    and remove it once it is disconnected.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每次接受新的连接（代表新的浏览器）时，我们希望保留对该连接的引用，以便稍后可以向它发送事件。这个连接容器由一个 Actor 处理。这个 Actor 将需要一个包含已连接浏览器列表的内部状态；我们应该添加一个新的浏览器，并在它断开连接时移除它。
- en: 'To create an Actor, we use the `Props` class from Akka, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Actor，我们使用 Akka 的 `Props` 类，如下所示：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This Actor is created from the guardian root Actor; in our case, it is named
    `actorSystem`. From the system Actor, the `actorOf` method is called; this method
    expects `Props` as the first parameter, representing our Actor factory, and the
    name of the Actor as the second parameter. `BrowserManagerActor` is composed of
    a class and its companion object. The companion object is used to create an instance
    of the Actor, and it is a good practice to also define the messages related to
    that Actor, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Actor是从守护根Actor创建的；在我们的例子中，它被命名为`actorSystem`。从系统Actor，我们调用`actorOf`方法；这个方法期望`Props`作为第一个参数，代表我们的Actor工厂，以及Actor的名称作为第二个参数。`BrowserManagerActor`由一个类和它的伴生对象组成。伴生对象用于创建Actor的实例，并且定义与该Actor相关的消息是一个好的实践，如下所示：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We define the `props()` method used to create the Actor instance. There is nothing
    special here; the factory is defined on the companion object and is the best pattern
    to create an Actor. In this class, we also define the specific messages of this
    Actor; in this case, we only have one, named `AddBrowser`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了用于创建Actor实例的`props()`方法。这里没有什么特别的地方；工厂是在伴生对象上定义的，这是创建Actor的最佳模式。在这个类中，我们还定义了该Actor的特定消息；在这种情况下，我们只有一个，名为`AddBrowser`。
- en: 'The `BrowserManagerActor` class implementation is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrowserManagerActor`类的实现如下：'
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To become an Actor, the class needs to extend the `Actor` class; we also extend `ActorLogging`.
    This will provide a `log` object in our class, which can be used to log interesting
    information.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为Actor，该类需要扩展`Actor`类；我们同样扩展了`ActorLogging`。这将为我们提供`log`对象，该对象可以用来记录有趣的信息。
- en: As noted earlier, we would like to keep the list of browsers connected to the
    server. For that purpose, we use the `browsers` variable, with `ListBuffer[ActorRef]`
    as the type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们希望保留连接到服务器的浏览器列表。为此，我们使用`browsers`变量，其类型为`ListBuffer[ActorRef]`。
- en: Notice that we are using a mutable collection to define this list; this is completely
    fine in this context, as it is only accessible by this Actor and is guaranteed
    to be thread-safe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用一个可变集合来定义这个列表；在这个上下文中，这是完全可行的，因为这个列表只能被这个Actor访问，并且保证是线程安全的。
- en: It is possible to avoid this mutable variable by using another component from
    the Akka framework. This component is named **Final State Machine** (**FSM**).
    The full details of the FSM implementation are out of the scope of this book.
    If you are interested, the link to the full documentation can be found at [https://doc.akka.io/docs/akka/current/fsm.html](https://doc.akka.io/docs/akka/current/fsm.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用Akka框架的另一个组件来避免这个可变变量。这个组件被命名为**最终状态机**（**FSM**）。FSM实现的全部细节超出了本书的范围。如果您感兴趣，完整的文档链接可以在[https://doc.akka.io/docs/akka/current/fsm.html](https://doc.akka.io/docs/akka/current/fsm.html)找到。
- en: Earlier, we mentioned that an Actor receives messages; this is the purpose of
    the `receive` method. It is a partial function, with `Any -> Unit` as a signature. To
    implement this function, we define the cases that we would like to handle; putting
    it in a different way, we define the messages that the Actor is handling.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到过，Actor会接收消息；这就是`receive`方法的作用。它是一个部分函数，其签名是`Any -> Unit`。为了实现这个函数，我们定义了我们想要处理的案例；换句话说，我们定义了Actor要处理的消息。
- en: 'Our manager Actor handles three messages, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管理员Actor处理了三条消息，具体如下：
- en: '`case AddBrowser(b)`: Here, a new connection is created, and `b` represents
    the browser Actor. First, by performing `context.watch(b)`, we ask the Akka framework
    to watch the `b` Actor and inform us when it dies by sending a terminated message.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case AddBrowser(b)`: 在这里，创建了一个新的连接，`b`代表浏览器Actor。首先，通过执行`context.watch(b)`，我们请求Akka框架监视`b`Actor，并在它死亡时通过发送终止消息来通知我们。'
- en: '`case CartEvent(user, product, action)`: Here, a message comes from a browser,
    namely, `CartEvent`. We would like to inform all of the connected browsers about
    this event. This is done by sending an alarm message to all of the browsers in
    our browser list. Notice that we convert the message to a JSON format using Circe.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case CartEvent(user, product, action)`: 在这里，来自浏览器的消息，即`CartEvent`。我们希望通知所有连接的浏览器关于这个事件。这是通过向我们的浏览器列表中的所有浏览器发送警报消息来完成的。注意，我们使用Circe将消息转换为JSON格式。'
- en: '`case Terminate(b)`: This message is received because we are supervising the
    browser Actor. The `b` Actor dies, and the only thing to do is remove it from
    our list of browsers.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case Terminate(b)`: 接收这个消息是因为我们在监督浏览器Actor。`b`Actor死亡，我们唯一要做的就是将其从我们的浏览器列表中移除。'
- en: We are almost done. With this Actor, we keep track of the connected browsers
    and send an alarm when any of them emits an event.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。有了这个 Actor，我们跟踪连接的浏览器，并在其中任何一个发出事件时发送警报。
- en: But wait; something looks suspicious. Indeed, we never sent the `AddBrowser`
    and `CartEvent` messages to our manager. Who should send them? The answer is in
    the next section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等；有些东西看起来可疑。确实，我们从未向我们的管理者发送过 `AddBrowser` 和 `CartEvent` 消息。谁应该发送它们？答案在下一节。
- en: Handling WebSocket
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 WebSocket
- en: 'Going back to the `Websockets` class, and, more specifically, to the `cartEventWS`
    method, we can finish the implementation, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `Websockets` 类，更具体地说，到 `cartEventWS` 方法，我们可以完成实现，如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After logging, we send the `AddBrowser` message  to the manager by using the `!` command
    (pronounced bang); this is syntactic sugar, and we could also use the `.tell()`
    method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录日志后，我们通过使用 `!` 命令（发音为 bang）将 `AddBrowser` 消息发送给管理者；这是一个语法糖，我们也可以使用 `.tell()`
    方法。
- en: '`ActorFlow.actorRef` needs `ActorRef` to handle the upstream of the web socket;
    for that purpose, we create `BrowserActor` by using the `props` function of the
    `BrowserActor` companion object, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActorFlow.actorRef` 需要使用 `ActorRef` 来处理 WebSocket 的上游；为此，我们通过使用 `BrowserActor`
    伴生对象的 `props` 函数创建 `BrowserActor`，如下所示：'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`BrowserActor` references the manager; indeed, the manager has the responsibility
    of sending the message to all of the browsers. The `BrowserActor` class implementation
    is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrowserActor` 引用管理者；实际上，管理者有责任向所有浏览器发送消息。`BrowserActor` 类的实现如下：'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This implementation gets all of the messages coming from the socket in string
    format, converts them into `CartEvent` using Circe, and forwards them to the browser
    manager.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现获取来自套接字的所有消息，使用 Circe 将它们转换为 `CartEvent`，并将它们转发给浏览器管理者。
- en: Keep in mind that the message flow can become more complicated; that is why
    it is a good idea to create a diagram of the system of Actors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，消息流可能会变得更加复杂；这就是为什么创建一个 Actor 系统图表是一个好主意。
- en: A diagram of Actors
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actors 的示意图
- en: It is sometimes necessary to represent the Actor flow using a diagram. The more
    Actors there are in your system, the more difficult it is to picture the entire
    workflow, especially if you do not work on the code for a while and then come
    back to it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时有必要使用图表来表示 Actor 流程。您的系统中 Actor 越多，整个工作流程就越难以想象，尤其是如果您有一段时间没有在代码上工作，然后又回到它。
- en: 'The following is a diagram of our project, illustrating the workflow when a
    new browser is connected:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是我们项目的示意图，说明了当新的浏览器连接时的工作流程：
- en: '![](img/118a6e42-ea30-4374-b0af-39334cb6520a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/118a6e42-ea30-4374-b0af-39334cb6520a.png)'
- en: With this kind of diagram, you can clearly understand who is creating the Actors,
    and can also understand the sequences of messages between them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种图表，您可以清楚地了解谁在创建 Actors，也可以了解它们之间消息的顺序。
- en: 'The following diagram illustrates a message being sent from the browser:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了从浏览器发送的消息：
- en: '![](img/efd7d5c8-f33b-475d-8733-db94eeae5bee.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/efd7d5c8-f33b-475d-8733-db94eeae5bee.png)'
- en: Notice that the start of the third message indicates that the alarm is sent
    to multiple instances of the web socket.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第三条消息的开始表明警报被发送到多个 WebSocket 实例。
- en: For OmniGraffle users, you can find a stencil to create these diagrams at Diagramming
    Reactive Systems | Graffletopia ([https://www.graffletopia.com/stencils/1540](https://www.graffletopia.com/stencils/1540)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OmniGraffle 用户，您可以在 Diagramming Reactive Systems | Graffletopia ([https://www.graffletopia.com/stencils/1540](https://www.graffletopia.com/stencils/1540))
    找到创建这些图表的模板。
- en: We have now finished looking at Actors; we are missing many features, but the
    aim was to provide you with enough knowledge to understand the basics of this
    beautiful framework.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对 Actors 的查看；我们缺少许多功能，但目标是提供足够的知识，让您了解这个美丽框架的基本知识。
- en: The server is now completely implemented, and we can safely move to the client
    side.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器现在已完全实现，我们可以安全地移动到客户端。
- en: Implementing the client side
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现客户端
- en: In the following sections, we will look at the client side. On the client side,
    we have to initiate the web socket connection with the server, send a `CartEvent`
    when a product is added or removed from the cart, and show alerts when other browsers
    make changes to the cart.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将查看客户端。在客户端，我们必须与服务器初始化 WebSocket 连接，当产品被添加或从购物车中移除时发送 `CartEvent`，并在其他浏览器更改购物车时显示警报。
- en: First, let's create the connection with the server using a web socket.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 WebSocket 与服务器建立连接。
- en: Adding the web socket
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 WebSocket
- en: 'To add the web socket to the client, we are going to use the `UIManager` object,
    which is the entry point of the client. In Scala.js, `WebSocket` is part of the
    framework; edit the `UIManager` and add the web socket property to it, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 WebSocket 添加到客户端，我们将使用 `UIManager` 对象，它是客户端的入口点。在 Scala.js 中，`WebSocket`
    是框架的一部分；编辑 `UIManager` 并将其添加到其中，如下所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Some configuration is needed to create the `WebSocket`. We encapsulate all
    of the initializations into a function named `getWebSocket`, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `WebSocket` 需要一些配置。我们将所有初始化封装到一个名为 `getWebSocket` 的函数中，如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To create a `WebSocket`, we first need to give the URL of the server and then
    handle all of the events happening in the socket. To get the URL of the server,
    we use a utility function named `getWebsocketUri`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `WebSocket`，我们首先需要给出服务器的 URL，然后处理套接字中发生的所有事件。要获取服务器的 URL，我们使用一个名为 `getWebsocketUri`
    的实用函数：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function just checks the protocol and defines the `WebSocket` protocol
    as `wss` if encrypted or `ws` if not encrypted. Then, the full URL is built by
    using string interpolation. In production, we usually use SSL, but when developing,
    we do not use encryption.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只是检查协议，如果加密则将 `WebSocket` 协议定义为 `wss`，如果不加密则定义为 `ws`。然后，通过字符串插值构建完整的 URL。在生产环境中，我们通常使用
    SSL，但在开发时我们不需要加密。
- en: 'Once the URL is defined, we define all of the socket event handlers as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了 URL，我们就定义所有套接字事件处理程序，如下所示：
- en: '`onopen`: When a new connection is created, we just log it and mark the event
    as canceled, so it will not be taken into consideration if another handler receives
    it.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onopen`：当创建新的连接时，我们只是记录它并将事件标记为已取消，这样如果另一个处理程序收到它，它就不会被考虑。'
- en: '`onerror`: Just log the error in the error pipe.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onerror`：只需在错误管道中记录错误。'
- en: '`onmessage`: When a message is received, we use Circe to decode it and check
    whether it is an alarm message. If that is the case, we call `notify(alarm)`,
    otherwise, we just log the fact that we received an unknown message. The `notify(alarm)`
    will be explained later.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onmessage`：当接收到消息时，我们使用 Circe 对其进行解码并检查它是否是警报消息。如果是这种情况，我们调用 `notify(alarm)`，否则，我们只是记录我们收到了一个未知消息的事实。`notify(alarm)`
    将在后面解释。'
- en: '`onclose`: Again, we just log this event.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onclose`：再次，我们只是记录此事件。'
- en: Now, we have defined the socket and it is ready to be used; if this code is
    run, a connection to the server will be created as soon as the page is browsed.
    But before that, we need to define the notification system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了套接字，并且它已经准备好使用；如果运行此代码，当页面被浏览时，将立即创建与服务器的连接。但在那之前，我们需要定义通知系统。
- en: Notifying the user
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知用户
- en: To notify the user, we picked a JavaScript library called Notify.js. Notify.js
    is a jQuery plugin without any dependencies, and it has a simple interface. We
    will implement only one method: `$.notify(string, options)`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知用户，我们选择了一个名为 Notify.js 的 JavaScript 库。Notify.js 是一个没有依赖项的 jQuery 插件，它有一个简单的接口。我们将只实现一个方法：`$.notify(string,
    options)`。
- en: As Notify.js is a jQuery plugin, we need to extend jQuery with this function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Notify.js 是一个 jQuery 插件，我们需要使用此函数扩展 jQuery。
- en: Extending jQuery
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 jQuery
- en: Extending jQuery using Scala.js is done by extending the famous jQuery `$` symbol.
    We can create a file named `Notify.scala` in the `io.fscala.shopping.client` package,
    in the client project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Scala.js 扩展 jQuery 是通过扩展著名的 jQuery `$` 符号来完成的。我们可以在 `io.fscala.shopping.client`
    包中创建一个名为 `Notify.scala` 的文件，在客户端项目中。
- en: 'In this file, we can first define the extension with the following piece of
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们可以首先使用以下代码定义扩展：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: An object named `NotifyJS` is defined, extending the Scala.js object named `js.Object`.
    It is necessary to inform the compiler that we are creating a facade of an existing
    JavaScript library.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个名为 `NotifyJS` 的对象，它扩展了名为 `js.Object` 的 Scala.js 对象。有必要通知编译器我们正在创建现有 JavaScript
    库的包装器。
- en: The first annotation is `@js.native`; this annotation tells the compiler that
    the implementation is completely done in JavaScript. The second annotation is
    `@JSGlobal("$") `; this is to express the fact that the API we are extending is
    a JavaScript class, and this class is named `$`. The last thing is to define the
    signature of the function that we would like to call and to use `js.native` as
    implementation; again, the compiler is going to make the bridge between our code
    and the JavaScript implementation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个注解是`@js.native`；这个注解告诉编译器实现完全是在JavaScript中完成的。第二个注解是`@JSGlobal("$")`；这是为了表达我们扩展的API是一个JavaScript类，并且这个类被命名为`$`。最后，我们需要定义我们想要调用的函数的签名，并使用`js.native`作为实现；编译器将再次在我们的代码和JavaScript实现之间建立桥梁。
- en: The parameters of the function are `String` (for the first one) and `Options`
    (for the second). `Options` need to be defined, as this is part of the facade.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数是`String`（对于第一个）和`Options`（对于第二个）。`Options`需要被定义，因为这是门面的一部分。
- en: By reading the Notify.js documentation ([https://notifyjs.jpillora.com/](https://notifyjs.jpillora.com/)),
    you can see that there are a lot of options available, such as the positioning
    of the notification and the animation of the notification.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读Notify.js文档([https://notifyjs.jpillora.com/](https://notifyjs.jpillora.com/))，你可以看到有很多可用的选项，例如通知的位置和通知的动画。
- en: 'From the Notify.js documentation, we can get the definitions of all of the
    options, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从Notify.js文档中，我们可以获取所有选项的定义，如下所示：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can create an `Options` class in Scala, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Scala中创建一个`Options`类，如下所示：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `@ScalaJSDefined` annotation tells the compiler that this is a type defined
    in Scala, and not in JavaScript.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ScalaJSDefined`注解告诉编译器这是一个在Scala中定义的类型，而不是在JavaScript中定义的。'
- en: Then, for each property, we check the type candidate in the documentation and
    define it using `js.UndefOr[Int]`; this type acts like a bridge between the `undefinedJavaScript`
    and `Options` types in Scala.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个属性，我们在文档中检查类型候选者，并使用`js.UndefOr[Int]`来定义它；这种类型在`undefinedJavaScript`和Scala中的`Options`类型之间起到桥梁的作用。
- en: 'Everything is now defined for our facade; we can use this facade and implement
    the missing `notify(alarm)` function of the `UIManager` class, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的门面定义了一切；我们可以使用这个门面并实现`UIManager`类中缺失的`notify(alarm)`函数，如下所示：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we check the type of action to set the class name of the notification,
    and then we use the `notify` native call by passing the message and the notification's
    options.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查动作的类型以设置通知的类名，然后我们通过传递消息和通知的选项来使用`notify`原生调用。
- en: 'We are all done. Now, if the server is running, each time you add or remove
    a product in the cart, a notification will be sent to all of the connected browsers,
    as shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了所有工作。现在，如果服务器正在运行，每次你在购物车中添加或删除产品时，都会向所有已连接的浏览器发送通知，如下面的截图所示：
- en: '![](img/24ff428f-867b-498e-a8d4-908fa9102bb8.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24ff428f-867b-498e-a8d4-908fa9102bb8.png)'
- en: The shopping page with the notification for cart updates
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 带有购物车更新通知的购物页面
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create a WebSocket communication between
    the server and the browser. At the server level, we kept a reference to all the
    browsers connected, so that events could be dispatched to all the browsers. An
    important piece of the system is the actor model, defined at the server level.
    We learned that the actor model programming paradigm is adequate as soon as we
    have an interaction between asynchronous systems.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在服务器和浏览器之间创建WebSocket通信。在服务器层面，我们保持了对所有已连接浏览器的引用，以便可以将事件分发给所有浏览器。系统的一个重要部分是在服务器层面定义的actor模型。我们了解到，一旦在异步系统之间有交互，actor模型编程范式就足够了。
- en: You learned that a diagram of the interactions between Actors can be helpful
    as your system is growing. It is particularly useful when someone needs to go
    back to the code after being away for a while. As we are not calling methods but
    sending messages to `ActorRef`, the navigation in the IDE is not easy, so it is
    difficult to understand the flow just by reading the code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到，当你的系统不断增长时，一个展示Actors之间交互的图示可能非常有用。当有人从一段时间后返回代码时，这一点尤其有用。由于我们不是调用方法，而是向`ActorRef`发送消息，所以在IDE中的导航并不容易，因此仅通过阅读代码很难理解流程。
- en: Once the first steps in this framework are made, development is natural and
    close to real-world interaction.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在这个框架中迈出了第一步，开发过程就会变得自然，并且接近现实世界的交互。
- en: We also introduced Akka. Akka is a complete framework, separated into different
    modules. We strongly encourage you to take a spin in the Akka website at [https://akka.io/](https://akka.io/).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了Akka。Akka是一个完整的框架，分为不同的模块。我们强烈建议您访问Akka网站[https://akka.io/](https://akka.io/)进行一番探索。
- en: On the client side, thanks to Scala.js, the integration of a framework is completed
    with only a few lines of code; once defined in Scala, we can use all of the knowledge
    learned from a backend system and apply it to the front. This is especially true
    when we are sharing the code between the backend and frontend.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，得益于Scala.js，框架的集成只需几行代码即可完成；一旦在Scala中定义，我们就可以将后端系统中学到的所有知识应用到前端。这一点在我们需要在后端和前端之间共享代码时尤其正确。
- en: This ends the chapter. At this point, you should have the necessary information
    to build your own client-server program. In the next chapters, we will introduce
    you to how to use Scala to process and analyze large amounts of data, using Apache
    Spark, Kafka and Zeppelin.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章。到目前为止，你应该已经拥有了构建自己的客户端-服务器程序所需的所有信息。在接下来的章节中，我们将向您介绍如何使用Scala通过Apache
    Spark、Kafka和Zeppelin来处理和分析大量数据。
