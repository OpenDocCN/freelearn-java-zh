- en: Testing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和调试
- en: Throughout this book, we have covered Reactor in great detail, working with
    its various operators and building examples using them. However, writing code
    is only half of the job. All production code must also be verified with adequate
    unit tests. These tests not only validate our code, but they also enable us to
    make changes faster. If we refactor code, the tests ensure that our change has
    not broken any existing functionality. In this chapter, we will cover the testing
    support offered by Reactor. Testing business code will catch most of the issues,
    but the code will fail in production. In such scenarios, the code needs to be
    debugged in order to find the root cause of the failure. In this chapter, we will
    also cover some basic techniques to debug Reactor pipelines.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经详细介绍了Reactor，使用其各种操作符并使用它们构建示例。然而，编写代码只是工作的一半。所有生产代码都必须通过足够的单元测试进行验证。这些测试不仅验证我们的代码，而且使我们能够更快地进行更改。如果我们重构代码，测试将确保我们的更改没有破坏任何现有功能。在本章中，我们将介绍Reactor提供的测试支持。测试业务代码将捕获大多数问题，但代码将在生产中失败。在这种情况下，需要调试代码以找到失败的根本原因。在本章中，我们还将介绍一些调试Reactor管道的基本技术。
- en: 'In this final chapter, we will learn how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将学习如何：
- en: Test Reactor pipelines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Reactor管道
- en: Debug Reactor streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Reactor流
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Java Standard Edition, JDK 8 or above
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java标准版，JDK 8或更高版本
- en: IntelliJ IDEA IDE 2018.1 or above
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA IDE 2018.1或更高版本
- en: The GitHub link for this chapter is [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter10).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub链接为 [https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Reactive-Programming-with-Reactor/tree/master/Chapter10)。
- en: Testing Reactor pipelines
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Reactor管道
- en: 'Unit testing Reactor pipelines is quite hard. This is because Reactor declares
    behaviors rather than states that can be validated. Fortunately, Reactor comes
    with utility classes that can assist in unit testing. The testing utilities are
    bundled in the `reactor-test` component. `reactor-test` provides us with the following
    three components:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试Reactor管道相当困难。这是因为Reactor声明的是行为而不是可以验证的状态。幸运的是，Reactor附带了一些辅助类，可以帮助进行单元测试。测试实用工具包含在`reactor-test`组件中。`reactor-test`为我们提供了以下三个组件：
- en: '`StepVerifier`: Allows us to validate a pipeline configuration and operators'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StepVerifier`：允许我们验证管道配置和操作符'
- en: '`TestPublisher`: Allows us to produce test data to enable testing operators'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestPublisher`：允许我们产生测试数据以启用操作符的测试'
- en: '`PublisherProbe`: Enables us to validate an existing publisher'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherProbe`：使我们能够验证现有的发布者'
- en: 'Before we proceed, let''s first add `reactor-test` to our `build.gradle`. We
    do not need to specify the version of this as that is defined by the `org.springframework.boot`
    plugin:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们首先将`reactor-test`添加到我们的`build.gradle`中。我们不需要指定这个版本的版本，因为这个版本由`org.springframework.boot`插件定义：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's run `./gradlew clean deploy`. After doing this, we should find that
    we have a successful build.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `./gradlew clean deploy`。完成这个步骤后，我们应该会发现我们有一个成功的构建。
- en: StepVerifier
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StepVerifier
- en: 'Before now, we have tested final outcomes for each Reactive Stream as the complete
    pipeline was created in the test case. This approach is not a good unit test as
    it does not validate the components in isolation. In Reactor, pipelines are declared
    in code. These pipelines are then lazily instantiated and verified. Since a complete
    pipeline is instantiated, it is quite difficult to unit test components in isolation.
    For unit testing, we must have the ability to stub the components of a pipeline,
    leaving behind the component being tested. But in this case, how can we validate
    an existing pipeline for the sequence of operations? Reactor provides the `StepVerifier`
    component to validate the required operations in isolation. This API not only
    defines stubs, but also provides assertions to validate each step. In this section,
    we will work with various examples of validating different Reactor scenarios.
    Let''s start with the simplest use case where, given a publisher, we may want
    to assert the `next` and `completion` events published by it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们已经测试了每个响应式流的最终结果，因为完整的管道是在测试用例中创建的。这种方法不是一个好的单元测试，因为它没有单独验证组件。在Reactor中，管道是在代码中声明的。然后这些管道被延迟实例化和验证。由于完整的管道被实例化，因此单独对组件进行单元测试相当困难。对于单元测试，我们必须有能力模拟管道的组件，留下正在测试的组件。但是在这种情况下，我们如何验证操作序列的现有管道？Reactor提供了`StepVerifier`组件来单独验证所需操作。此API不仅定义了存根，还提供了断言来验证每个步骤。在本节中，我们将使用验证不同Reactor场景的各种示例。让我们从一个最简单的用例开始，其中给定一个发布者，我们可能想要断言它发布的`next`和`completion`事件：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we are validating Fibonacci series operations as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们按照以下方式验证斐波那契数列操作：
- en: We have configured the `take` operator to consume only 10 events.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已将`take`操作符配置为仅消费10个事件。
- en: Next, we used the `StepVerifier.Create` API to build an instance of a verfier.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用了`StepVerifier.Create` API来构建一个验证器的实例。
- en: The `expectNext` API is used to validate published values in the published order.
    This takes a single value or an array of values; we are validating the `0`, `1`,
    and `1` values.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`expectNext` API来验证已发布的值，并按照发布顺序进行验证。它接受单个值或值的数组；我们正在验证`0`、`1`和`1`值。
- en: '`expectNextCount` is used to validate the number of published values. Since
    we validate three values, we are left with seven more.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`expectNextCount`来验证已发布值的数量。由于我们验证了三个值，所以我们还剩下七个。
- en: The `expectComplete` API is used to validate a completion event.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`expectComplete` API来验证完成事件。
- en: At the end, the `verify` API is used to validate the behavior.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用`verify` API来验证行为。
- en: 'Now, let''s run the test case. When doing this, we should see a green bar:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行测试用例。在这样做的时候，我们应该看到一个绿色的条形图：
- en: '![](img/4974ddc7-cb65-41a3-8ecb-2c7105cedbaa.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4974ddc7-cb65-41a3-8ecb-2c7105cedbaa.png)'
- en: 'If `expectNext` does not match the published values, the test fails with `java.lang.AssertionError`
    and detailed error text. If the published count differs, then it does not fail
    with `expectNextCount`, but `expectComplete`. In all assertion failures, `StepVerifier`
    throws a `java.lang.AssertionError` with the following detailed message:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`expectNext`不匹配已发布的值，测试将因`java.lang.AssertionError`和详细错误文本而失败。如果已发布的计数不同，则不会因`expectNextCount`而失败，而是`expectComplete`。在所有断言失败中，`StepVerifier`会抛出一个带有以下详细信息的`java.lang.AssertionError`：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the following sections, we will discuss the most commonly used methods available
    in `StepVerfier`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论`StepVerfier`中可用的一些最常用的方法。
- en: expectError
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: expectError
- en: 'As discussed throughout this book, a Reactive Stream terminates with a completion
    or error event. Similarly to `expectComplete`, for a completion event, there is
    the `expectError` API to validate error events. The `expectError` API offers the
    following convenient methods to validate an error message or the exception class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书中所述，响应式流以完成或错误事件终止。同样地，对于完成事件，有`expectError` API来验证错误事件。`expectError` API提供了以下方便的方法来验证错误消息或异常类：
- en: '| **Error name** | **Description** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **错误名称** | **描述** |'
- en: '| `expectError()` | The API only validates the occurrence of an error event.
    It does not validate any details about the error. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `expectError()` | 该API仅验证错误事件的 occurrence。它不验证任何关于错误的详细信息。|'
- en: '| `expectError(exceptionClass)` | The API validates the underlying exception
    class wrapped in the error event. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `expectError(exceptionClass)` | 该API验证错误事件中包装的底层异常类。|'
- en: '| `expectErrorMessage(errorMessage)` | The API validates the underlying exception
    message wrapped in the error event. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `expectErrorMessage(errorMessage)` | 此API验证错误事件中包装的底层异常消息。|'
- en: '| `expectError(Predicate)` | The API validates the underlying exception using
    the configured predicate. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `expectError(Predicate)` | 此API使用配置的谓词验证底层异常。|'
- en: 'In all preceding cases, `StepVerifier` asserts the exception wrapped in the
    error event. If the error does not match, an `assertionError` is thrown by `StepVerifier`.
    `StepVerifier` also provides an `expectErrorSatisfies` API, which can be used
    to configure customs assertions. This API takes a `Consumer` to assert an exception
    underlying the error event:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的案例中，`StepVerifier`断言错误事件中包装的异常。如果错误不匹配，`StepVerifier`会抛出`assertionError`。`StepVerifier`还提供了一个`expectErrorSatisfies`
    API，可以用来配置自定义断言。此API接受一个`Consumer`来断言错误事件下的异常：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we are throwing an exception when the value goes above
    `30`. `expectErrorSatisfies` asserts that the exception thrown is an `IllegalStateException`
    type. Let''s execute the preceding test case to get a green bar for a successful
    test case. This is shown with the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当值超过`30`时，我们会抛出异常。`expectErrorSatisfies`断言抛出的异常是`IllegalStateException`类型。让我们执行前面的测试案例以获得成功的绿色条。这在上面的屏幕截图中有展示：
- en: '![](img/65704bfa-2b8f-48f9-b5ee-0c563835ff9f.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65704bfa-2b8f-48f9-b5ee-0c563835ff9f.png)'
- en: expectNext
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: expectNext
- en: 'Reactor provides multiple methods to assert next values. In the preceding code,
    we matched values using the `expectNext()` overloaded operator. This operator
    is offered in the following variants:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor提供了多个方法来断言下一个值。在前面代码中，我们使用`expectNext()`重载操作符来匹配值。此操作符提供了以下变体：
- en: '| **Operator**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '| **操作符**'
- en: '&#124; **Description** &#124;'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '| **描述** | '
- en: '&#124; `expectNext(value1,value2.. value6)` &#124; This method verifies the
    published values against the supplied values. The values must be matched in the
    order specified. &#124;'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| `expectNext(value1,value2.. value6)` | 此方法验证发布的值与提供的值是否匹配。值必须按照指定的顺序匹配。| '
- en: '&#124; `expectNext(value[])` &#124; This method verifies the published values
    against the supplied value array. All values must be matched in the order specified.
    &#124;'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '| `expectNext(value[])` | 此方法验证发布的值与提供的值数组是否匹配。所有值必须按照指定的顺序匹配。| '
- en: '&#124; `expectNextSequence(Iterator)` &#124; This method verifies the published
    values against values from the configured iterator. All values must be matched
    in the order specified. &#124;'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '| `expectNextSequence(Iterator)` | 此方法验证发布的值与配置的迭代器中的值是否匹配。所有值必须按照指定的顺序匹配。| '
- en: '&#124; `expectNextCount(count)` &#124; This method matches the number of values
    published. &#124;'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '| `expectNextCount(count)` | 此方法匹配发布的值的数量。| '
- en: '&#124; `expectNextMatches(predicate)` &#124; This method validates whether
    or not the next values satisfy the configured predicate. &#124;'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '| `expectNextMatches(predicate)` | 此方法验证下一个值是否满足配置的谓词。| '
- en: 'All of the preceding methods validate the next published value against a matching
    expectation. This is good for small datasets, but when we are publishing large
    ranges such as the Fibonacci series, we cannot match all values. Sometimes, we
    are just interested in consuming all (or some) next values. This can be accomplished
    by using the `thenConsumeWhile` API. The methods take a predicate and then consume
    all sequenced values matching the predicate. Once the first value mismatches,
    the test case tries to validate the following configured expectation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前面方法都验证下一个发布的值与匹配的期望值。这对于小数据集来说很好，但是当我们发布像斐波那契数列这样的大范围时，我们无法匹配所有值。有时，我们只是对消费所有（或某些）下一个值感兴趣。这可以通过使用`thenConsumeWhile`
    API来实现。这些方法接受一个谓词，然后消费所有与谓词匹配的序列值。一旦第一个值不匹配，测试案例将尝试验证以下配置的期望值：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding test case, the following has occurred:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试案例中，以下情况发生了：
- en: '`thenConsumeWhile` has been configured with the `x >= 0` predicate. This should
    match all values except the first negative value.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenConsumeWhile`已配置为`x >= 0`谓词。这应该匹配所有值，除了第一个负值。'
- en: 'Next, we expect a complete event and then verify it using the `verify` API.
    This is shown in the following screenshot:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们期望一个完整的事件，然后使用`verify` API进行验证。这在上面的屏幕截图中有展示：
- en: '![](img/28fb0557-cd81-4d16-912e-cda50dafe8e7.png)We have looked at the `expect`
    methods to validate events generated in a Reactive Stream. If the expectation
    does not match, `StepVerifier` builds a generic message to indicate the failure.
    `StepVerifier` also provides support to build failure-specific and descriptive
    messages. `StepVerifier` provides the `as` method, which can be invoked after
    the `expect` method. The `as` method takes a string, which is displayed when the
    exception does not match:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/28fb0557-cd81-4d16-912e-cda50dafe8e7.png)我们已经探讨了`expect`方法来验证在响应式流中生成的事件。如果期望不匹配，`StepVerifier`构建一个通用消息来指示失败。`StepVerifier`还提供了构建特定失败和描述性消息的支持。`StepVerifier`提供了`as`方法，该方法可以在`expect`方法之后调用。`as`方法接受一个字符串，当异常不匹配时显示：'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this code, we have provided descriptive messages for each expectation. If
    the expectation does not match, the test fails with a specific error message,
    as shown in the following trace. This helps in debugging test failures:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们为每个期望提供了描述性消息。如果期望不匹配，测试将因特定错误消息而失败，如以下跟踪所示。这有助于调试测试失败：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Capture values
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获值
- en: 'There are times when we are unable to assert values directly. In such test
    scenarios, we usually capture the invoked values and then assert them separately.
    Reactor provides a `recordWith` API to capture values generated by the publisher
    under test. This method takes a `Supplier` function, which is invoked in order
    to instantiate a Collection for storing values. The recorder collection can then
    be asserted using the `expectRecordedMatches` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们无法直接断言值。在这种情况下，我们通常会捕获调用的值，然后分别断言它们。Reactor提供了一个`recordWith` API来捕获测试中的发布者生成的值。该方法接受一个`Supplier`函数，该函数被调用以实例化一个用于存储值的集合。然后可以使用`expectRecordedMatches`方法断言记录集合：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Configured `recordWith` to use an `ArrayList` for recording all values.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`recordWith`使用`ArrayList`来记录所有值。
- en: Configured `thenConsumeWhile` with the predicate `x >= 0`. This should match
    all values except the first negative value. All matching values are added to the
    record collection.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置了`thenConsumeWhile`使用谓词`x >= 0`。这应该匹配所有值，除了第一个负值。所有匹配的值都添加到记录集合中。
- en: Next, we configured `expectRecordedMatches` to assert the record collection
    to have values.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们配置了`expectRecordedMatches`来断言记录集合具有值。
- en: 'Finally, we expect a completion event and then verify it using the `verify`
    API as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们期望一个完成事件，然后使用`verify` API进行验证，如下所示：
- en: When running the preceding test case, we should get a green bar for passing
    tests. This is shown in the following screenshot:![](img/8c428c11-7f97-46c9-b734-c8e7ac7d3328.png)As
    well as the `expectRecordWith` method, Reactor also provides a `consumeRecordWith`
    API, which can be invoked for custom assertions. The `consumeRecordWith` method
    takes a Consumer function for the recorded collection. It is important to note
    that a recorded session can only be matched with the next `consumeRecordWith`
    or `expectRecordWith` invocation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前面的测试用例时，我们应该得到一个绿色的条形表示通过测试。这在上面的屏幕截图（![](img/8c428c11-7f97-46c9-b734-c8e7ac7d3328.png)）中显示。同样，除了`expectRecordWith`方法外，Reactor还提供了一个`consumeRecordWith`
    API，可以用于自定义断言。`consumeRecordWith`方法接受一个用于记录集合的Consumer函数。需要注意的是，记录会话只能与下一个`consumeRecordWith`或`expectRecordWith`调用相匹配。
- en: Verify
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: 'As discussed previously, the `verify` operator is used to assert the configured
    behavior. The termination event for a publisher must be validated before the `verify`
    call. Alternatively, Reactor provides convenient verify methods to validate the
    termination event and assert the complete configured chain. Similar to `expectError`,
    the API is offered in the following methods:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`verify`操作符用于断言配置的行为。在调用`verify`之前，必须验证发布者的终止事件。或者，Reactor提供了方便的验证方法来验证终止事件并断言完整的配置链。与`expectError`类似，该API在以下方法中提供：
- en: '&#124; **Method name** &#124; **Description** &#124;'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; **方法名称** &#124; **描述** &#124;'
- en: '&#124; `verifyComplete()` &#124; This method only validates the occurrence
    of a completion event. &#124;'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; `verifyComplete()` &#124; 此方法仅验证完成事件的发生。 &#124;'
- en: '&#124; `verifyError()` &#124; This method only validates the occurrence of
    an error event. &#124;'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; `verifyError()` &#124; 此方法仅验证错误事件的发生。 &#124;'
- en: '&#124; `verifyError(exceptionClass)` &#124; This method validates an error
    event and matches an underlying exception class wrapped in the error event. &#124;'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyError(exceptionClass)`；此方法验证错误事件并匹配错误事件中包装的底层异常类。'
- en: '&#124; `verifyError(exceptionMsg)` &#124; This method validates an error event
    and matches an underlying exception message wrapped in the error event. &#124;'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyError(exceptionMsg)`；此方法验证错误事件并匹配错误事件中包装的底层异常消息。'
- en: '&#124; `verifyError(predicate)` &#124; This method validates an error event
    and matches it against the supplied predicate. &#124;'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyError(predicate)`；此方法验证错误事件并将其与提供的谓词匹配。'
- en: '&#124; `verfiyErrorSatisfies(assertConsumer)` &#124; This method validates
    an error event and matches the underlying exception for supplied custom assertions.
    &#124;'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`verfiyErrorSatisfies(assertConsumer)`；此方法验证错误事件并匹配提供的自定义断言的底层异常。'
- en: 'In the preceding test, we can replace `expectComplete` and verify invocations
    with the following snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们可以用以下片段替换`expectComplete`和验证调用：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will leave the test execution to the reader. Again, a passed test should
    show a green bar. It is important to note that `verify` (and related methods)
    return `Duration`. The duration specifies the actual time the test took to execute.
    This also brings us to discussing the blocking behavior of verify methods. By
    default, the invocation of verify methods is synchronous and blocking. It can
    make the test wait infinitely. The behavior can be changed by specifying a `Duration`
    in the `verify` method call. Alternatively, we can set a default timeout by using
    the `StepVerifier.setDefaultTimeout` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试执行留给读者。再次强调，通过测试应显示绿色条。重要的是要注意，`verify`（及相关方法）返回`Duration`。该持续时间指定测试实际执行的时间。这也引出了关于验证方法阻塞行为的讨论。默认情况下，验证方法的调用是同步和阻塞的，可能会导致测试无限期等待。可以通过在`verify`方法调用中指定`Duration`来更改此行为。或者，我们可以使用`StepVerifier.setDefaultTimeout`方法设置默认超时：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this code, we have made the following changes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们做了以下更改：
- en: Delayed event generation for 1 second by using the `delaySequence` operator.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`delaySequence`操作符延迟1秒生成事件。
- en: Removed the `verifyComplete` call, as we cannot specify a duration. Instead,
    we added the `expectComplete` method call.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了`verifyComplete`调用，因为我们不能指定持续时间。相反，我们添加了`expectComplete`方法调用。
- en: Lastly, we used the verify call with a timeout duration. The timeout is set
    to 100 milliseconds.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用带有超时时间的验证调用。超时设置为100毫秒。
- en: 'This test case times out and fails with the following exception:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试用例超时并失败，以下为异常信息：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous sections, we looked at methods that enable us to validate most
    of the operators for a Reactive Stream. We will cover some specific Reactor scenarios
    next.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们查看了一些方法，这些方法使我们能够验证大多数响应式流操作符。接下来，我们将讨论一些特定的Reactor场景。
- en: Validating backpressure
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证背压
- en: 'As discussed previously in [Chapter 7](a7dd0f00-77de-4c2b-8b48-72b30d6a6184.xhtml),
    *Flow Control and Backpressure*, backpressure allows a subscriber to control event
    flow. This mechanism is aimed at controlling a fast generating producer. There
    are different configurations for backpressure. These configurations have already
    been discussed in [Chapter 7](a7dd0f00-77de-4c2b-8b48-72b30d6a6184.xhtml), *Flow
    Control and Backpressure*, and we will not cover them here. Fundamentally, backpressure
    skips delivering values to the Subscriber. Consequently, validating it means that
    we must look for values that have not been delivered to the Subscriber. Reactor
    provides the `verifyThenAssertThat` API for the same reason. This method exposes
    assertions that can validate the end state of a publisher. Let''s now work with
    a test case:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文在[第7章](a7dd0f00-77de-4c2b-8b48-72b30d6a6184.xhtml)中所述，*流量控制与背压*，背压允许订阅者控制事件流。此机制旨在控制快速生成生产者。背压有不同的配置。这些配置已在[第7章](a7dd0f00-77de-4c2b-8b48-72b30d6a6184.xhtml)中讨论过，*流量控制与背压*，此处不再赘述。从根本上讲，背压跳过向订阅者传递值。因此，验证它意味着我们必须寻找尚未传递给订阅者的值。Reactor提供了`verifyThenAssertThat`
    API出于同样的原因。此方法公开了可以验证发布者最终状态的断言。现在让我们来处理一个测试用例：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, the following occurred:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，发生了以下情况：
- en: We configured a Publisher with `OverflowStrategy.ERROR` using the `Flux.create`
    API. Our Publisher generates 100 events without looking for more requests from
    the Subscriber.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Flux.create` API配置了一个带有`OverflowStrategy.ERROR`的发布者。我们的发布者生成100个事件，而不寻找订阅者的更多请求。
- en: Next, our `StepVerifier` is configured for only one event, limiting the request
    rate from the Subscriber. This is achieved using the `StepVerifier.create` API.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们的 `StepVerifier` 被配置为仅处理一个事件，限制订阅者的请求速率。这是通过使用 `StepVerifier.create` API
    实现的。
- en: Since the subscriber is asking for one event and the Publisher is raising 100
    events, this should lead to a backpressure error. In the test case, we configured
    `expectError()` to validate the error raised.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于订阅者请求一个事件，而发布者引发 100 个事件，这应该导致背压错误。在测试用例中，我们配置了 `expectError()` 来验证引发的错误。
- en: Lastly, we configured `verfiyThenAssertThat()` to check for dropped elements.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们配置了 `verfiyThenAssertThat()` 来检查丢失的元素。
- en: 'The preceding test case validates the complete scenario of backpressure, which
    is shown in the following screenshot:![](img/cf16a934-7ab9-4ad2-85f1-af867e9cbb27.png)In
    the preceding test case, we have validated whether or not elements have been dropped.
    Reactor also provides the following assertions to validate various other scenarios:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试用例验证了完整的背压场景，如下面的截图所示:![](img/cf16a934-7ab9-4ad2-85f1-af867e9cbb27.png)在前面的测试用例中，我们验证了元素是否丢失。Reactor
    还提供了以下断言来验证各种其他场景：
- en: '&#124; **Method name** &#124; **Description** &#124;'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; **方法名称** &#124; **描述** &#124;'
- en: '&#124; `hasDroppedElements` &#124; This method verifies whether or not elements
    have been dropped by a Publisher due to overflow. &#124;'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; `hasDroppedElements` &#124; 此方法验证发布者是否由于溢出而丢失了元素。 &#124;'
- en: '&#124; `hasNotDroppedElements` &#124; This method verifies whether or not any
    elements have been dropped by a Publisher due to overflow. &#124;'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; `hasNotDroppedElements` &#124; 此方法验证发布者是否由于溢出而丢失了任何元素。 &#124;'
- en: '&#124; `hasDroppedExactly` &#124; This method validates the dropped values
    against the ones supplied in the method invocation. &#124;'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; `hasDroppedExactly` &#124; 此方法验证丢失的值与在方法调用中提供的值是否一致。 &#124;'
- en: '&#124; `hasDroppedErrors` &#124; This method verifies whether or not errors
    have been dropped by a Publisher. &#124;'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; `hasDroppedErrors` &#124; 此方法验证发布者是否丢失了错误。 &#124;'
- en: '&#124; `hasOperatorErrors` &#124; This method verifies whether or not operator
    errors have been raised by stream processing. &#124;'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; `hasOperatorErrors` &#124; 此方法验证流处理是否引发了操作符错误。 &#124;'
- en: Validating time operations
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证时间操作
- en: 'Validating time-based operations is a complex task. Traditionally, we used
    `Thread.sleep` or `wait-notify` blocks to simulate the delay in the test case.
    Reactor also provides rich support to validate such operations. This allows us
    to build a virtual clock by using the `Stepverifier.withVirtualTime` method for
    Reactive Streams. The virtual clock can then be manipulated using any of the following
    operations to simulate time drift for the required operation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 验证基于时间的操作是一项复杂的任务。传统上，我们使用 `Thread.sleep` 或 `wait-notify` 块来模拟测试用例中的延迟。Reactor
    也提供了丰富的支持来验证此类操作。这允许我们通过使用 Reactive Streams 的 `Stepverifier.withVirtualTime` 方法来构建一个虚拟时钟。然后可以使用以下任何操作来操作虚拟时钟，以模拟所需操作的时间漂移：
- en: '&#124; **Operations** &#124; **Description** &#124;'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; **操作** &#124; **描述** &#124;'
- en: '&#124; `thenAwait` &#124; This only pauses the execution for the configured
    time. &#124;'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; `thenAwait` &#124; 这只会暂停执行到配置的时间。 &#124;'
- en: '&#124; `expectNoEvent` &#124; This pauses the execution and validates that
    no event has happened during the configured delay. &#124;'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; `expectNoEvent` &#124; 此操作暂停执行，并在配置的延迟期间验证没有发生事件。 &#124;'
- en: 'It is important to note that operators must be invoked after injecting the
    virtual clock. Also, the `expectNoEvent` API recognizes subscription as an event.
    If it is used as the first step after injecting the virtual clock, then it will
    fail due to the Subscription event. Let''s now work with the following test case:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，必须在注入虚拟时钟之后调用操作符。此外，`expectNoEvent` API 将订阅视为一个事件。如果它在注入虚拟时钟后的第一步使用，那么它将由于订阅事件而失败。现在让我们处理以下测试用例：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we achieved the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实现了以下内容：
- en: Created a Flux with the virtual clock using `StepVerifier.withVirtualTime`
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `StepVerifier.withVirtualTime` 创建了一个带有虚拟时钟的 Flux
- en: Configured a `delaySequence` operation on the Reactive Stream
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在反应流上配置了 `delaySequence` 操作
- en: Invoked `thenAwait` to hold the virtual clock for the configured time
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `thenAwait` 以保持虚拟时钟在配置的时间内
- en: Expected nine values to be published, followed by a completion event
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期发布九个值，然后是一个完成事件
- en: Let's now run the test case and verify it as follows:![](img/edb91374-ab59-405c-a7a4-e7ba4139100c.png)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行测试用例并验证如下！![图片](img/edb91374-ab59-405c-a7a4-e7ba4139100c.png)
- en: Publisher probe
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Publisher探针
- en: 'In the preceding section, we used `StepVerifier` to assert the steps executed
    in a reactive chain. However, these are often simple chains that can be validated
    end-to-end in a single test case. There may be scenarios where we need to inject
    a Publisher into a service or a method and verify the published signals. In such
    cases, we can instrument an existing Publisher using the `PublisherProbe` utility.
    The probe keeps track of signals published by the Publisher. In the end, we can
    assert and verify the final state of the probe. The utility helps to unit test
    a service or method executing some specific logic on a Reactive Publisher.A `PublisherProbe`
    can be constructed using either of the following methods:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了`StepVerifier`来断言在反应链中执行的步骤。然而，这些通常是简单的链，可以在单个测试用例中端到端验证。可能存在我们需要将Publisher注入到服务或方法中并验证发布信号的情景。在这种情况下，我们可以使用`PublisherProbe`实用工具对现有的Publisher进行仪器化。探针跟踪Publisher发布的信号。最后，我们可以断言并验证探针的最终状态。该实用工具有助于单元测试执行特定逻辑在反应Publisher上的服务或方法。`PublisherProbe`可以使用以下任一方法构建：
- en: '`PublisherProbe.Of(ExisitingPublisher)`: Instruments an existing Publisher
    and generates a probe from it. The probe sends out signals as generated by the
    original Publisher.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherProbe.Of(ExistingPublisher)`: 对现有的Publisher进行仪器化，并从中生成一个探针。探针发送出由原始Publisher生成的信号。'
- en: '`PublisherProbe.empty()`: Creates an empty sequence probe. This probe does
    not emit any signals.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherProbe.empty()`: 创建一个空的序列探针。此探针不会发出任何信号。'
- en: 'We can get back a Mono or Flux from the `PublisherProbe` by invoking respective
    methods. The Flux/Mono can then be passed to the method/service under test. After
    the invocation, the final state can be verified using the following assertions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用相应的方法从`PublisherProbe`获取Mono或Flux。然后，可以将Flux/Mono传递给正在测试的方法/服务。调用后，可以使用以下断言验证最终状态：
- en: '&#124; **Method name** &#124; **Description** &#124;'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`| **方法名** | **描述** |`'
- en: '&#124; `assertWasSubscribed` &#124; This method validates that the Publisher
    was subscribed to in the invocation. &#124;'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`| assertWasSubscribed |` 这个方法验证在调用中Publisher是否被订阅。`|`'
- en: '&#124; `assertWasRequested` &#124; This method validates that the Publisher
    was requested in the invocation. &#124;'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`| assertWasRequested |` 这个方法验证在调用中是否请求了Publisher。`|`'
- en: '&#124; `assertWasCancelled` &#124; This method validates that the Publisher
    was cancelled in the invocation. &#124;'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`| assertWasCancelled |` 这个方法验证在调用中Publisher是否被取消。`|`'
- en: 'The following code depicts this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了这一点：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Created a `PublisherProbe` using `fibonacciGenerator`
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fibonacciGenerator`创建了一个`PublisherProbe`
- en: Next we subscribed to the Flux generated by the probe
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们订阅了探针生成的Flux
- en: In the end we validate that the Flux was subscribed, flowed by the request event
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们验证Flux被订阅，随后是请求事件
- en: Let's run the test case and verify it as follows:![](img/cfda1f2c-2f9e-48a1-9748-6e1ca8d58860.png)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试用例并验证如下！![图片](img/cfda1f2c-2f9e-48a1-9748-6e1ca8d58860.png)
- en: Publisher stubs
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Publisher存根
- en: 'So far, we have been creating a `Publisher` along with the operators. As a
    result, we could build end-to-end validations. However, in most business services,
    a `Publisher` will be created in some part of the code and operations will be
    performed in another. In order to unit test the operation service code, we would
    need to generate a dummy `Publisher`. Reactor also provides `TestPublisher` for
    this purpose. We can create a `TestPublisher` using the `create factory` method.
    The generated `TestPublisher` can be converted into a Flux or a Mono. `TestPublisher`
    makes it possible to emit events using any of the following methods:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在创建操作符的同时创建一个`Publisher`。因此，我们可以构建端到端的有效性验证。然而，在大多数业务服务中，`Publisher`将在代码的某个部分创建，而操作将在另一个部分执行。为了单元测试操作服务代码，我们需要生成一个虚拟的`Publisher`。Reactor也为此提供了`TestPublisher`。我们可以使用`create
    factory`方法创建一个`TestPublisher`。生成的`TestPublisher`可以被转换成Flux或Mono。`TestPublisher`使得使用以下任何一种方法发射事件成为可能：
- en: '&#124; **Method name** &#124; **Description** &#124;'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`| **方法名** | **描述** |`'
- en: '&#124; `next(T) / next(T,T...)` &#124; Invokes Publisher `OnNext` with the
    supplied values. &#124;'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`| next(T) / next(T,T...) |` 调用Publisher的`OnNext`方法，并使用提供的值。`|`'
- en: '&#124; `complete()` &#124; Terminates the Publisher stream with the `OnComplete`
    event. &#124;'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`| complete() |` 使用`OnComplete`事件终止发布者流。`|`'
- en: '&#124; `error()` &#124; Terminates the Publisher stream with the `OnError`
    event. &#124;'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`| error() |` 使用`OnError`事件终止发布者流。`|`'
- en: '&#124; `emit(T,T,T .....)` &#124; Invokes Publisher `OnNext` with the supplied
    values, followed by `OnComplete` termination. &#124;'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`| emit(T,T,T .....) |` 调用发布者的`OnNext`方法，使用提供的值，然后是`OnComplete`终止。`|`'
- en: 'Let''s work with sample code. We have the following `PrintService`, which prints
    even numbers to the console as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用示例代码。我们有以下`PrintService`，它将偶数打印到控制台，如下所示：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s build a simple test case. In the test case, we will inject a few
    values and a `StringWriter`. At the end, we will validate whether or not `StringWriter`
    contains all the required values, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个简单的测试用例。在测试用例中，我们将注入一些值和一个`StringWriter`。最后，我们将验证`StringWriter`是否包含所有必需的值，如下所示：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Generated a `TestPublisher` using the `create` method
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`create`方法生成了一个`TestPublisher`
- en: Instantiated a `StringWriter` to capture printed values
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化了一个`StringWriter`以捕获打印的值
- en: Next, we generated `onNext` using some values
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用一些值生成了`onNext`
- en: Finally, we generated `onComplete` and validated the printed values
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们生成了`onComplete`并验证了打印的值
- en: 'Now, run the test case. This should show a green bar for a test that has passed:![](img/0244c6dc-0de7-4753-ba1b-41964609c36d.png)`TestPublisher`
    also keeps track of the final state of the `Publisher` stub. The final state can
    be verified using the following assertions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试用例。这应该会显示一个绿色的条形图，表示测试已经通过！![测试通过](img/0244c6dc-0de7-4753-ba1b-41964609c36d.png)`TestPublisher`还跟踪`Publisher`存根的最终状态。最终状态可以使用以下断言进行验证：
- en: '&#124; `assertSubscribers` &#124; This method validates that the Publisher
    was subscribed to by the number of subscribers supplied in the invocation. &#124;'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`| assertSubscribers |` 此方法验证发布者被提供的调用中指定的订阅者数量订阅。`|`'
- en: '&#124; `assertCancelled` &#124; This method validates that the Publisher was
    canceled multiple times, as specified by the number supplied in the invocation.
    &#124;'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`| assertCancelled |` 此方法验证发布者被取消多次，如调用中提供的数字所指定。`|`'
- en: '&#124; `assertRequestOverflow` &#124; This method validates that the Publisher
    raised Overflow conditions by generating more events than asked for by the subscriber.  &#124;'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`| assertRequestOverflow |` 此方法验证发布者通过生成比订阅者请求的更多事件来引发溢出条件。`|`'
- en: 'In the preceding test case, we built a well-behaved `Publisher` stub. This
    did not send null events or raise more events than requested. The `TestPublisher`
    utility also enables us to instantiate Publisher, which violates the preceding
    conditions. Such a Publisher can be used to validate service/operator behaviors.
    An inconsistent Publisher can be generated using the `createNonCompliant` method.
    This method uses a violation type and generates configured errors:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试用例中，我们构建了一个表现良好的`Publisher`存根。它没有发送空事件或发送比请求更多的事件。`TestPublisher`实用程序还使我们能够实例化违反先前条件的发布者。可以使用`createNonCompliant`方法生成不一致的发布者。此方法使用违规类型并生成配置的错误：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we have done the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们做了以下操作：
- en: Generated a `TestPublisher` using the `createNonCompliant` method. Publisher
    has been configured to produce more than the requested events.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`createNonCompliant`方法生成了一个`TestPublisher`。发布者已被配置为生成比请求更多的事件。
- en: Subscribed to the publisher with an initial demand of one element.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅了具有一个初始元素需求的发布者。
- en: Validated the produced element followed by an error termination.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证了生成的元素后跟错误终止。
- en: Debugging Reactor streams
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Reactor流
- en: 'Debugging Rector streams is not straightforward. This is due to the fact that
    all stream processing in Reactor is asynchronous and non-blocking. In a synchronous
    and blocking system, an error stacktrace points to the root cause of the issue.
    However, in an asynchronous reactor stream, the error is logged in the `Subscriber`
    but has been raised in an operator in stream processing. The error stacktrace
    does not mention the operator. Let''s take a look at the following Reactor stacktrace:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 调试Rector流不是一件简单的事情。这是因为Reactor中的所有流处理都是异步和非阻塞的。在一个同步和阻塞系统中，错误堆栈跟踪指向问题的根本原因。然而，在异步Reactor流中，错误被记录在`Subscriber`中，但在流处理中的操作员中被引发。错误堆栈跟踪没有提到操作员。让我们看一下以下Reactor堆栈跟踪：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding stacktrace, we can observe the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的堆栈跟踪中，我们可以观察到以下情况：
- en: '`IllegalStateException` has reached our subscriber'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IllegalStateException` 已到达我们的订阅者'
- en: Reactor also raises an `ErrorCallbackNotImpletemented`, since the Subscriber
    does not handle the error event
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于订阅者没有处理错误事件，Reactor 还抛出了 `ErrorCallbackNotImpletemented`
- en: The error is captured while performing `PrintService.printEventNumbers`
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误发生在执行 `PrintService.printEventNumbers` 时
- en: The preceding error is raised in our `ReactorDebug.testPublisherStub` test case
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的错误是在我们的 `ReactorDebug.testPublisherStub` 测试用例中抛出的
- en: 'This does not help much, but we can clean up the stack trace by first implementing
    an error handler. The simplest approach here is to use the `printstackTrace` method
    of throwable:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有太大帮助，但我们可以通过首先实现一个错误处理器来清理堆栈跟踪。这里最简单的方法是使用可抛出对象的 `printstackTrace` 方法：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding change to the `subscribe` method sanitizes the stacktrace of
    the error raised. However, the error operator is still not explained in the trace,
    as shown in the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `subscribe` 方法中进行的先前更改清理了抛出错误的堆栈跟踪。然而，错误操作符在跟踪中仍未解释，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Debug hook
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试钩子
- en: 'Reactor provides assembly-time instrumentation capability to debug a stacktrace.
    This capability enables us to intercept all invocations of Flux/Mono operations.
    Each interception then keeps a record of the error thrown with the operation invoked.
    The resultant mapping is then appended to the stacktrace. This record can then
    be used to find the root cause of the issue. Since this is an additional interception,
    which keeps a record mapping, it should only be invoked to debug errors and must
    not be enabled in production systems. Reactor provides a `Hooks.OnOperatorDebug`
    API, which must be invoked before instantiating the Flux/Mono. Let''s invoke `Hooks.OnOperatorDebug`
    in our test case, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Reactor 提供了编译时仪器功能来调试堆栈跟踪。此功能使我们能够拦截所有 Flux/Mono 操作的调用。然后，每次拦截都会记录与操作一起抛出的错误。然后，将此映射附加到堆栈跟踪中。然后，可以使用此记录来找到问题的根本原因。由于这是一个额外的拦截，它保留记录映射，因此它应该仅用于调试错误，并且不应在生产系统中启用。Reactor
    提供了一个 `Hooks.OnOperatorDebug` API，必须在实例化 Flux/Mono 之前调用。让我们在我们的测试用例中调用 `Hooks.OnOperatorDebug`，如下所示：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s run our test case and look at the generated stacktrace, which is as
    follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的测试用例并查看生成的堆栈跟踪，如下所示：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, if we look at the bottom of the trace, it clearly states that an error
    has been thrown in the `Flux.generate` invocation. To solve this, we can fix this
    bug and rerun our test case.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看跟踪的底部，它清楚地表明在 `Flux.generate` 调用中抛出了一个错误。为了解决这个问题，我们可以修复这个错误并重新运行我们的测试用例。
- en: Checkpoint operator
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点操作符
- en: 'The Debug hook discussed in the previous section has a global impact, instrumenting
    all Flux/Mono instances. Consequently, the impact of the debug hook is application-wide.
    Alternatively, Reactor also provides a `checkpoint` operator, which can only alter
    a particular Flux stream. The `checkpoint` operator instruments a Reactor Streams
    after the operator invocation. We can alter our previous test case as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中讨论的调试钩子具有全局影响，为所有 Flux/Mono 实例提供仪器。因此，调试钩子的影响是应用范围的。或者，Reactor 还提供了一个 `checkpoint`
    操作符，它只能更改特定的 Flux 流。`checkpoint` 操作符在操作符调用后为 Reactor Streams 提供仪器。我们可以将我们的先前测试用例修改如下：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we have invoked the `checkpoint()` operator after creating
    the Flux. The modified test case generates the following stacktrace. Since the
    `checkpoint` operator is invoked after `Flux.generate`, the record mapping refers
    to `FluxGenerate` as the point of error. This is shown with the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在创建 Flux 后调用了 `checkpoint()` 操作符。修改后的测试用例生成了以下堆栈跟踪。由于 `checkpoint`
    操作符是在 `Flux.generate` 之后调用的，因此记录映射引用 `FluxGenerate` 作为错误点。以下代码显示了这一点：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `checkpoint` and the `debug` operators discussed previously have an impact
    on the memory footprint of the application. Both these operators try to save stacktraces,
    which leads to higher memory consumption. Due to this, these operators cannot
    be enabled in production applications without paying an additional cost. But the
    `checkpoint` operator also offers a trimmed down version, which does not save
    any stacktraces. The `checkpoint` operator, when configured with a description
    message, disables stacktrace accumulation. The following stacktrace is generated
    when using checkpoint with a description in our preceding code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的`checkpoint`和`debug`操作符会影响应用程序的内存占用。这两个操作符都试图保存堆栈跟踪，这导致更高的内存消耗。因此，在没有额外成本的情况下，这些操作符不能在生产应用程序中启用。但`checkpoint`操作符还提供了一个精简版，它不会保存任何堆栈跟踪。当`checkpoint`操作符配置了描述信息时，它会禁用堆栈跟踪累积。以下是在我们前面的代码中使用带有描述信息的checkpoint时生成的堆栈跟踪：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding stacktrace, Reactor used the description and prefixed the `identified
    by light checkpoint` message to it. It no longer tries to build a stacktrace of
    operator invocations. The `identified by light checkpoint` message can be in searched
    in application logs. But if the description message is not good enough, Reactor
    allows us to enable stacktrace capturing in order to build informative failure
    traces. This can be accomplished by using the `checkpoint(description,enableStackTrace)`
    operator.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的堆栈跟踪中，Reactor使用了描述并将其作为`identified by light checkpoint`消息的前缀。它不再尝试构建操作符调用的堆栈跟踪。`identified
    by light checkpoint`消息可以在应用程序日志中搜索。但如果描述信息不够好，Reactor允许我们启用堆栈跟踪捕获以构建信息性的失败跟踪。这可以通过使用`checkpoint(description,enableStackTrace)`操作符来实现。
- en: Stream logging
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流日志
- en: 'Logging is one of the most common ways to know what is happening underneath
    method invocations. Reactor uses SLF4J for logging, but it does not log stream
    operations out-of-the-box. Instead, Reactor provides the `log` operator, which
    can be used to selectively enable logging for a particular stream. Let''s modify
    our test case using the log operator as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是了解方法调用下发生情况的最常见方式之一。Reactor使用SLF4J进行日志记录，但它默认不记录流操作。相反，Reactor提供了`log`操作符，它可以用来选择性地为特定流启用日志记录。让我们使用以下方式修改我们的测试用例，使用日志操作符：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `log()` operator is offered in many variants. By default, the operator
    logs at the `INFO` level. We can configure this to log at the `DEBUG` or other
    levels as well. Furthermore, we can also place a `logback.xml` file to format
    the logged message, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`log()`操作符提供了许多变体。默认情况下，操作符在`INFO`级别记录。我们可以将其配置为在`DEBUG`或其他级别记录。此外，我们还可以放置一个`logback.xml`文件来格式化记录的消息，如下所示：'
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding `logback.xml` file, we have configured a `stdout` appender.
    The appender will be invoked in a synchronous and blocking manner. Reactor also
    provides a `reactor-logback` library, which can be used to log messages in an
    asynchronous manner. The preceding test case now generates the following log message:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`logback.xml`文件中，我们配置了一个`stdout`附加器。附加器将以同步和阻塞的方式被调用。Reactor还提供了一个`reactor-logback`库，它可以用来以异步方式记录消息。前面的测试用例现在生成了以下日志消息：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding logging output clearly shows what events are happening in stream
    processing. We can interpret the log and build the following analysis:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的日志输出清楚地显示了在流处理中发生的事件。我们可以解释日志并构建以下分析：
- en: Each log line outputs the operator invoked. Consequently, we can see that the
    first subscription was raised.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每条日志行输出调用的操作符。因此，我们可以看到第一个订阅已被提出。
- en: Next, there was an unbounded request, which started generating events.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，出现了一个无界请求，这开始生成事件。
- en: After that, the Subscriber raised a request for one element.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，订阅者提出了一个元素请求。
- en: Finally, there was an `ERROR` event invoked in the generate operator due to
    `IllegalStateException`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，由于`IllegalStateException`，生成操作符中引发了一个`ERROR`事件。
- en: Consequently, we can see that logging is a powerful mechanism for debugging
    and learning more about application stream processing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到日志是调试和了解应用程序流处理的有力机制。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on testing and debugging Reactor Streams. Testing Reactor
    Flux/Mono streams is complex, as each stream is evaluated lazily in an async manner.
    We also looked at `StepVerifier`, which can validate individual steps in isolation.
    Next, we looked at a virtual clock to validate time-sensitive operations, such
    as delays. We also looked at the `PublisherProbe` utility used to validate a Publisher's
    end state. Then, in order to unit test Reactive operators and stream business
    logic, we performed stubbing using `TestPublisher`. The next section was about
    debugging Reactor Streams to gain further knowledge about under-the-covers processing.
    Debugging Reactor streams is complex, since the operators are evaluated in an
    asynchronous manner. We looked at the Debug hook and checkpoint operator to generate
    an operator mapped error stacktrace. Finally, we looked at the log operator used
    to generate logs for stream processing.We have also come to the end of our book.
    On this journey, we learned about Reactor, an implementation of the Reactive Streams
    specification. We worked with Flux and Mono Publishers. We built simple applications
    to find out more about the available operators. We came to the conclusion that
    Reactor is a library that can be used in any Java application.On this journey,
    we also discussed SpringWebFlux, a complete web framework using Rector. We developed
    simple web services using it and explored the backpressure behavior offered by
    Reactor. We concluded the journey by looking at various advanced features of Reactor.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了Reactor Streams的测试和调试。测试Reactor Flux/Mono流是复杂的，因为每个流都是以异步方式懒加载评估的。我们还研究了`StepVerifier`，它可以单独验证单个步骤。接下来，我们研究了虚拟时钟来验证时间敏感的操作，例如延迟。我们还研究了用于验证发布者最终状态的`PublisherProbe`实用工具。然后，为了对反应式操作符和流业务逻辑进行单元测试，我们使用了`TestPublisher`进行存根。下一节是关于调试Reactor
    Streams以获取更多关于底层处理的了解。调试Reactor流是复杂的，因为操作符是以异步方式评估的。我们研究了用于生成操作符映射错误堆栈跟踪的Debug钩子和检查点操作符。最后，我们研究了用于生成流处理日志的日志操作符。我们的书也即将结束。在这段旅程中，我们学习了Reactor，这是Reactive
    Streams规范的实现。我们与Flux和Mono发布者一起工作。我们构建了简单的应用程序来了解更多关于可用操作符的信息。我们得出结论，Reactor是一个可以用于任何Java应用程序的库。在这段旅程中，我们还讨论了SpringWebFlux，这是一个使用Reactor的完整Web框架。我们使用它开发了简单的Web服务，并探索了Reactor提供的背压行为。我们通过查看Reactor的各种高级功能来结束这次旅程。
- en: Questions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which test utility class is available in Reactor to validate the invoked operations
    on a stream?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reactor中哪个测试实用工具类可用于验证流上调用的操作？
- en: What is the difference between `PublisherProbe` and `TestPublisher`?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PublisherProbe`和`TestPublisher`之间有什么区别？'
- en: How should the virtual clock be configured to validate time-bound operations?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应如何配置虚拟时钟以验证时间限制操作？
- en: What is the difference between the `onOperatorDebug` hook and the checkpoint
    operator?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onOperatorDebug`钩子和检查点操作符之间的区别是什么？'
- en: How can we turn on logging for stream processing?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何开启流处理的日志记录？
- en: '|'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
