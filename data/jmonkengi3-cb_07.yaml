- en: Chapter 7. Networking with SpiderMonkey
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用SpiderMonkey进行网络编程
- en: This chapter will be all about using the networking engine of jMonkeyEngine,
    SpiderMonkey, to take our games beyond the isolation of our own computers to the
    Internet. Don't worry if you're not well versed in networking, we'll take it from
    the very beginning.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将全部关于使用jMonkeyEngine的网络引擎SpiderMonkey，将我们的游戏从我们自己的计算机的孤立状态带到互联网上。如果你对网络不太熟悉，不用担心，我们会从最基本的地方开始。
- en: 'This chapter contains the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下食谱：
- en: Setting up a server and client
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置服务器和客户端
- en: Handling basic messaging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理基本消息
- en: Making a networked game – Battleships
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个联网游戏 – 舰队大战
- en: Implementing a network code for FPS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为FPS实现网络代码
- en: Loading a level
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载关卡
- en: Interpolating between player positions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在玩家位置之间进行插值
- en: Firing over a network
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上发射
- en: Optimizing the bandwidth and avoiding cheating
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化带宽并避免作弊
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Data sent over the network is organized in packets, and protocols handle them
    differently. Packets can look different depending on protocols, but they contain
    the data itself along with control information, such as addresses and formatting
    information.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上发送的数据组织在数据包中，协议以不同的方式处理它们。根据协议，数据包可能看起来不同，但它们包含数据本身以及控制信息，如地址和格式化信息。
- en: SpiderMonkey supports both TCP and UDP. In SpiderMonkey, TCP is referred to
    as reliable. TCP is reliable because it verifies each network packet sent, minimizing
    problems due to packet loss and other errors. TCP guarantees that everything arrives
    safely (if at all possible). Why ever use anything else then? For speed. Reliability
    means that TCP can be slow. In some cases, we're not dependent on every packet
    reaching the destination. UDP is more suitable for streaming and low-latency applications,
    but the application will have to be prepared to compensate for the unreliability.
    This means that when a packet is lost in FPS, the game needs to know what to do.
    Will it just stop in its tracks, or stutter along? If a character is moving and
    the game can predict the movement between the messages that arrive, it will create
    a smoother experience.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SpiderMonkey支持TCP和UDP。在SpiderMonkey中，TCP被称为可靠的。TCP是可靠的，因为它验证发送的每个网络数据包，最小化由于数据包丢失和其他错误引起的问题。TCP保证所有内容都能安全到达（如果可能的话）。为什么还要使用其他东西呢？因为速度。可靠性意味着TCP可能会慢。在某些情况下，我们并不依赖于每个数据包都到达目的地。UDP更适合流媒体和低延迟应用，但应用程序必须准备好补偿不可靠性。这意味着当FPS中的数据包丢失时，游戏需要知道该怎么做。它会突然停止，还是会卡住？如果一个角色在移动，而游戏可以预测消息到达之间的移动，它将创建一个更平滑的体验。
- en: Learning how to use the API is fairly easy, but we will also see that networking
    is not something you add to a game; the game needs to be adapted for it from the
    planning stage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用API相对简单，但我们也会看到，网络不是你添加到游戏中的东西；游戏需要从规划阶段开始就适应它。
- en: Setting up a server and client
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置服务器和客户端
- en: In this recipe, we'll look at the absolute minimum in order to get a server
    and client up and running and be able to talk to each other.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将查看绝对最小化，以便让服务器和客户端启动并运行，并能相互通信。
- en: This is accomplished in just a few lines of code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这只需几行代码就能完成。
- en: The server and client will share some common data that we'll store inside a
    `properties` file for easy access and external modification. First and foremost,
    the client must know the address of the server, and both server and client need
    to know which port to listen on and connect to. These would most likely be editable
    from within a game.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端将共享一些共同的数据，我们将将其存储在一个`properties`文件中，以便于访问和外部修改。首先，客户端必须知道服务器的地址，而服务器和客户端都需要知道要监听和连接的端口号。这些很可能会在游戏中进行编辑。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to set up a server and client:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来设置服务器和客户端：
- en: 'In the constructor of the server class, we start by loading the properties
    file. Once done, we can initialize the server with the following lines of code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器类的构造函数中，我们首先加载属性文件。一旦完成，我们可以使用以下代码初始化服务器：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the static block, we must also make sure that the server doesn't shut down
    immediately.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在静态块中，我们还需要确保服务器不会立即关闭。
- en: 'The client is set up in a similar way, shown as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端以类似的方式设置，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To verify that a connection has taken place, we can add `ConnectionListener`
    to the server, as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证连接是否已经建立，我们可以在服务器中添加`ConnectionListener`，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we connect to the server again, we should see the message printed in the
    server's output window.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们再次连接到服务器，我们应该在服务器的输出窗口中看到打印的消息。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Network` class is the main class used when setting up and connecting our
    components. This particular method is the simplest way to create a server, simply
    stating a port to listen to. Let's set different ports for TCP and UDP and supply
    the name and version of the server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Network` 类是在设置和连接我们的组件时使用的主体类。这个特定的方法是以最简单的方式创建服务器，只需指定要监听的端口。让我们为 TCP 和 UDP
    设置不同的端口，并供应服务器的名称和版本。'
- en: The `connectToServer` method creates a client and connects it to the specified
    address and port. Like in the server case, there are other convenient methods
    in `Network` that let us specify more parameters if we want.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectToServer` 方法创建一个客户端并将其连接到指定的地址和端口。就像在服务器的情况下，`Network` 中还有其他方便的方法，允许我们指定更多参数，如果我们想的话。'
- en: 'That''s actually all that''s needed. When running the two programs in parallel,
    we should see the client connected to the server. There is no verification, however,
    that anything has happened. That''s why we added `ConnectionListener` at the end.
    It''s an interface with two methods: `connectionAdded` and `connectionRemoved`.
    These methods will be called whenever a client connects or disconnects. These
    methods gave the server a way to communicate to us that a connection has happened.
    These methods will be sources for a chain of events in more advanced recipes.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这就是所有需要的东西。当并行运行两个程序时，我们应该看到客户端连接到服务器。然而，并没有验证任何事情已经发生。这就是为什么我们在最后添加了 `ConnectionListener`。它是一个具有两个方法的接口：`connectionAdded`
    和 `connectionRemoved`。每当客户端连接或断开连接时，这些方法都会被调用。这些方法给了服务器一种与我们通信的方式，表明已经发生了连接。这些方法将成为更高级食谱中事件链的来源。
- en: Once the server is started, it begins to listen for incoming connections on
    the specified port. If the network address is considered the street name, the
    port will be the door that will be opened and made passable. So far, a mere handshake
    between the server and client has been made at the doorstep.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，它就开始在指定的端口上监听传入的连接。如果网络地址被认为是街道名称，端口将是打开并通行的门。到目前为止，服务器和客户端之间只在门口进行了简单的握手。
- en: Handling basic messaging
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理基本消息
- en: So far, we've learned the basics to set up a server and connecting a client.
    However, they don't do much, so let's look into what it takes to get them to communicate
    with each other.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了设置服务器和连接客户端的基础知识。然而，它们并没有做很多事情，所以让我们看看它们相互通信需要什么。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In SpiderMonkey, communication is handled via messaging and the message interface.
    When a server sends a message, it uses the `broadcast()` method, while a client
    uses `send()`. The side that is supposed to receive the message has to have a
    suitable `MessageListener` class. To try all these things out, let's have our
    server greet the connecting player by sending them a message, which will be displayed
    once received.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SpiderMonkey 中，通信是通过消息和消息接口处理的。当服务器发送消息时，它使用 `broadcast()` 方法，而客户端使用 `send()`。应该接收消息的一方必须有一个合适的
    `MessageListener` 类。为了尝试所有这些，让我们让我们的服务器通过发送消息来问候连接的玩家，该消息在收到后将显示出来。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to connect and handle basic messaging:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以连接和处理基本消息：
- en: 'We begin by defining our message. It''s a simple serializable bean with just
    one field, as shown in the following code snippet:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义我们的消息。它是一个简单的可序列化豆类，只有一个字段，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we create a class that implements `MessageListener`. It''s a very simple
    class that will print the message to the console when received, as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个实现 `MessageListener` 的类。这是一个非常简单的类，当收到消息时会在控制台打印出来，如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We instantiate `ServerMessageHandler` and add it to the client, telling it
    to only listen for `ServerMessages`, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实例化 `ServerMessageHandler` 并将其添加到客户端，告诉它只监听 `ServerMessages`，如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is also possible to let `ServerMessageHandler` handle all incoming messages
    by using the following line of code:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也可以使用以下代码行让 `ServerMessageHandler` 处理所有传入的消息：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now tell the server to create a message and send it to all the players when
    someone connects:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在告诉服务器在有人连接时创建一个消息并发送给所有玩家：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is one more thing we need to do. All the message classes used need to
    be registered before being used. We do this before the application starts, as
    follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要做一件事。所有使用的消息类在使用之前都需要注册。我们在应用程序启动之前做这件事，如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Spending time and defining what messages should contain is a good way to get
    a grip of the project as a lot of the architecture will revolve around them. The
    message we created in this recipe is called `ServerMessage`, because it is used
    to send a lot of information from the server to the client.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间定义消息应包含的内容是掌握项目的好方法，因为很多架构都将围绕它们展开。在这个食谱中创建的消息被称为 `ServerMessage`，因为它用于从服务器向客户端发送大量信息。
- en: The next class we created was `MessageListener`. The only thing it does upon
    receiving the message is print it to the console. We added it to the client, and
    also stated that it should specifically listen for `ServerMessages`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的下一个类是 `MessageListener`。它在接收到消息时所做的唯一事情是将它打印到控制台。我们将其添加到客户端，并指出它应该专门监听
    `ServerMessages`。
- en: By default, calling `broadcast` will send the message to all the connected clients.
    In this case, we just want to send a message to a specific client or a group of
    clients (like a team). Broadcast can also be called with `Filter`. It can also
    send messages to a specific channel, to which a team or group of players might
    be assigned.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，调用 `broadcast` 将会将消息发送给所有已连接的客户端。在这种情况下，我们只想向特定的客户端或一组客户端（如一个团队）发送消息。使用
    `Filter` 也可以调用广播。它还可以向特定的频道发送消息，该频道可能分配给一个团队或一组玩家。
- en: Making a networked game – Battleships
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作网络游戏 – 舰队大战
- en: In the previous recipes, we looked at how to set up a server, and connect and
    handle basic messaging. In this recipe, we'll reinforce this knowledge and expand
    it by adding server verification and applying it to a real game.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们探讨了如何设置服务器，连接和处理基本消息。在这个食谱中，我们将通过添加服务器验证并将其应用于实际游戏来加强和扩展这些知识。
- en: A turn-based board game is perhaps not what you would normally develop using
    a 3D game SDK, but it's a very good game to learn networking. The Battleships
    game is a good example not only because the rules are simple and known to many
    but also because it has a hidden element, which will help us understand the concept
    of server verification.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基于回合制的棋盘游戏可能不是你通常使用3D游戏SDK开发的，但它是一个很好的学习网络的好游戏。舰队大战游戏是一个很好的例子，不仅因为规则简单且众所周知，而且还因为它有一个隐藏元素，这将帮助我们理解服务器验证的概念。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're unfamiliar with the Battleships game, visit [http://www.wikipedia.org/wiki/Batt](http://www.wikipedia.org/wiki/Batt).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉舰队大战游戏，请访问 [http://www.wikipedia.org/wiki/Batt](http://www.wikipedia.org/wiki/Batt)。
- en: Since we're mainly interested in the networking aspects of the game, we'll skip
    some of the verification normally needed such as looking for overlapping ships.
    We also won't write any graphical interface and use the command prompt to obtain
    input. Again, to focus on the networking API, some of the plain Java logic for
    game rules won't be explained.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们主要对游戏的网络方面感兴趣，我们将跳过一些通常需要的验证，例如查找重叠的船只。我们也不会编写任何图形界面，并使用命令提示符来获取输入。再次强调，为了专注于网络API，一些游戏规则的简单Java逻辑将不会解释。
- en: The game will have a client and server class. Each class will have a `MessageListener`
    implementation and share messages and game objects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将有一个客户端和服务器类。每个类都将有一个 `MessageListener` 实现，并共享消息和游戏对象。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is highly recommended to familiarize yourself with the content of the previous
    recipes in the chapter, if you haven't already.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有熟悉该章节中前面的食谱内容，强烈建议你熟悉一下。
- en: 'The amount of messages will increase greatly compared to the previous recipes.
    Since both the server and client need to keep a track of the same messages and
    they need to be registered in the same order, we can create a `GameUtil` class.
    It has a static method called `initialize()`. For every new message type we create,
    we add a line like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的食谱相比，消息的数量将大大增加。由于服务器和客户端都需要跟踪相同的消息，并且它们需要按相同的顺序注册，我们可以创建一个 `GameUtil` 类。它有一个名为
    `initialize()` 的静态方法。对于每个新创建的消息类型，我们添加一行如下：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The game revolves around a couple of objects that we'll define before getting
    into the networking aspect.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏围绕着我们将在进入网络方面之前定义的一些对象。
- en: We need a `Ship` class. For this implementation, it only needs the `name` and
    `segments` fields. We add methods so that once a tile containing `Ship` is hit,
    we can decrease the segments. When segments reach zero, it's sunk. Likewise, `Player`
    can be a simple class, with only an ID necessary for identification with the server,
    and the number of ships still alive. If the number of ships reaches zero, the
    player loses.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`Ship`类。对于这个实现，它只需要`name`和`segments`字段。我们添加方法，以便一旦击中包含`Ship`的瓷砖，我们可以减少段数。当段数达到零时，它就沉没了。同样，`Player`也可以是一个简单的类，只需要一个ID，用于与服务器进行识别，以及仍然存活的船只数量。如果船只数量达到零，玩家就输了。
- en: Many of the message types extend a class called `GameMessage`. This class in
    turn extends `AbstractMessage` and needs to contain the ID of the game, and state
    that the message should be reliable, thus using the TCP protocol.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 许多消息类型扩展了一个名为`GameMessage`的类。这个类反过来扩展`AbstractMessage`，需要包含游戏的ID，以及消息应该可靠的状态，因此使用TCP协议。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We start by setting up a `Game` class. This will consist of the following six
    steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一个`Game`类。这将由以下六个步骤组成：
- en: First of all, the `Game` class needs an ID. This is used by the server to keep
    track of which game messages to relate to (since it supports many games at the
    same time), and will also be used as a reference for other things.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`Game`类需要一个ID。这被服务器用来跟踪哪些游戏消息与之相关（因为它同时支持多个游戏），也将被用作其他事物的参考。
- en: The `Game` class needs the two `Player` objects, `player1` and `player2`, as
    well as the ID of the player whose turn it currently is. We can call that `currentPlayerId`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Game`类需要两个`Player`对象，`player1`和`player2`，以及当前轮到哪个玩家的ID。我们可以称之为`currentPlayerId`。'
- en: The `Game` class needs two boards; one for each player. The boards will be made
    of 2D `Ship` arrays. Each tile where there is a segment of a ship has a reference
    to the `Ship` object; the others are null.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Game`类需要两个板；一个用于每个玩家。这些板将由2D `Ship`数组组成。每个有船段所在的瓷砖都有一个指向`Ship`对象的引用；其他都是null。'
- en: 'An integer `status` field lets us know what state the game currently is in,
    which is useful for message filtering. We can also add constants for the different
    statuses and set a default status, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个整数`status`字段让我们知道游戏当前处于什么状态，这对于消息过滤很有用。我们还可以添加不同的状态常量，并设置一个默认状态，如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we add a `placeShip` method. The method in this implementation is simplified
    and only contains verification that the ship is inside the board, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加一个`placeShip`方法。在这个实现中，方法被简化了，只包含验证船是否在板内的验证，如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The other method that does some work in the `Game` class is `applyMove`. This
    takes `FireActionMessage` as input, checking the supplied tile to see whether
    there is a ship in that spot. It then checks whether the supposed ship is sunk,
    and whether the player has any ships left. If a ship is hit, it returns the `Ship`
    object to the calling method, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Game`类中执行一些工作的另一个方法是`applyMove`。这个方法接受`FireActionMessage`作为输入，检查提供的瓷砖是否在该位置有船。然后检查假设的船是否沉没，以及玩家是否还有船只。如果击中船只，它将返回`Ship`对象，如下所示：
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s have a look at the server side of things. In the previous chapters,
    we had a look at connecting the clients, but a full game requires a bit more communication
    to set things up as we will see. This section will have the following eight steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看服务器端的事情。在前几章中，我们探讨了如何连接客户端，但一个完整的游戏需要更多的通信来设置一切，正如我们将看到的。本节将包含以下八个步骤：
- en: 'Since the server is meant to handle several instances of a game at once, we''ll
    define a couple of `HashMaps` to keep a track of the game objects. For each game
    we create, we put the `Game` object in the `games` map with the ID as a key:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于服务器旨在同时处理多个游戏实例，我们将定义几个`HashMaps`来跟踪游戏对象。对于每个我们创建的游戏，我们将`Game`对象放入`games`映射中，ID作为键：
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll also use `Filters` to only send messages to players in a related game.
    To do this, we store a list of `HostedConnections`, with each being an address
    to a client, with the game ID as a key:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将使用`Filters`仅向相关游戏中的玩家发送消息。为此，我们存储一个`HostedConnections`列表，其中每个都是一个指向客户端的地址，游戏ID作为键：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since we''re continuously giving out a new player ID and increasing the value
    of the game ID, we''ll have two fields for that as well: `nextGameId` and `nextPlayerId`.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不断地分配新的玩家ID并增加游戏ID的值，因此我们也将为此设置两个字段：`nextGameId`和`nextPlayerId`。
- en: 'Everything starts with a connecting client. Like in the *Setting up a server
    and client* recipe, we use `ConnectionListener` to handle this. The method either
    adds the player to an existing game, or creates a new one if none are available.
    Regardless of whether a new game is created or not, the `addPlayer` method is
    called afterwards, as shown in the following code snippet:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切从连接的客户端开始。就像在*设置服务器和客户端*食谱中一样，我们使用`ConnectionListener`来处理这个问题。该方法要么将玩家添加到现有的游戏中，要么如果没有可用，则创建一个新的游戏。无论是否创建了新游戏，之后都会调用`addPlayer`方法，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `createGame` method creates a new `game` object and sets the correct ID.
    After placing it in the `games` map, it creates a new `List<HostedConnection>`
    called `connsForGame` and adds it to the `connectionFilters` map. The `connsForGame`
    list is empty for now, but will be populated as players connect:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createGame`方法创建一个新的`game`对象并设置正确的ID。将其放入`games`映射后，它创建一个新的`List<HostedConnection>`，称为`connsForGame`，并将其添加到`connectionFilters`映射中。`connsForGame`列表目前为空，但将在玩家连接时被填充：'
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first thing the `addPlayer` method does is create a new `Player` object
    and then set the ID of it. We use `WelcomeMessage` to send the ID back to the
    player:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addPlayer`方法首先创建一个新的`Player`对象，然后设置其ID。我们使用`WelcomeMessage`将ID发送回玩家：'
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The server broadcasts this message using the client''s connection as a filter,
    ensuring it''s the only recipient of the message, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器使用客户端的连接作为过滤器广播这条消息，确保它是唯一的接收者，如下所示：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It then decides whether the player is the first or second to connect to the
    game, and adds the player''s `HostedConnection` instance to the list of connections
    associated with this game, as shown in the following code snippet:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，它决定玩家是第一个还是第二个连接到游戏的，并将玩家的`HostedConnection`实例添加到与该游戏关联的连接列表中，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It then creates a `GameStatusMessage` object, letting all players in the game
    know the current status (which is `WAITING`) and any player information it might
    have, as shown in the following code snippet:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个`GameStatusMessage`对象，让所有游戏中的玩家知道当前的状态（即`WAITING`）以及可能拥有的任何玩家信息，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''re going to take a look at message handling on the client side and see
    how its `MessageListener` interface will handle incoming `WelcomeMessages` and
    game updates:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨客户端的消息处理，并查看其`MessageListener`接口如何处理传入的`WelcomeMessages`和游戏更新：
- en: We create a class called `ClientMessageHandler`, which implements `MessageListener`.
    First, we will walk through the part handling the start of a game.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`ClientMessageHandler`的类，该类实现了`MessageListener`接口。首先，我们将遍历处理游戏开始的部分。
- en: 'The `thisPlayer` object has already been instanced in the client, so all we
    need to do when receiving `WelcomeMessage` is set the player''s ID. Additionally,
    we can display something to the player letting it know the connection is set up:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`thisPlayer`对象已经在客户端实例化了，所以当接收到`WelcomeMessage`时，我们只需要设置玩家的ID。此外，我们可以向玩家显示一些信息，让他们知道连接已经建立：'
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When a `GameStatusMessage` is received, we need to accomplish three things.
    First, set the ID of the game. Knowing the ID of the game is not necessary for
    the client in this implementation, but can be useful for communication with the
    server:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到`GameStatusMessage`时，我们需要完成三件事情。首先，设置游戏的ID。在这个实现中，客户端知道游戏的ID不是必需的，但与服务器通信时可能很有用：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we set the `playerOne` and `playerTwo` fields by simply checking whether
    they have been set before or not. We also need to identify the player by comparing
    the IDs of the players in the message with the ID associated with this client.
    Once found, we let him or her start placing ships, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过简单地检查它们是否之前已经设置来设置`playerOne`和`playerTwo`字段。我们还需要通过比较消息中玩家的ID与与此客户端关联的ID来识别玩家。一旦找到，我们让他或她开始放置船只，如下所示：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When `TurnMessage` is received, we should extract `activePlayer` from it and
    set it on the game. If `activePlayer` is the same as `thisPlayer` of `gameClient`,
    set `myTurn` to `true` on `gameClient`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到`TurnMessage`时，我们应该从其中提取`activePlayer`并将其设置在游戏上。如果`activePlayer`与`gameClient`的`thisPlayer`相同，则在`gameClient`上设置`myTurn`为`true`。
- en: The last message to be handled by the class is the `FiringResult` message. This
    calls `applyMove` on the `game` object. Some kind of output should be tied to
    this message telling the player what happened. This example game uses `System.out.println`
    to convey this.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类最后要处理的消息是`FiringResult`消息。这将在`game`对象上调用`applyMove`。应该将某种输出与这条消息关联起来，告诉玩家发生了什么。这个示例游戏使用`System.out.println`来传达这一点。
- en: 'Finally, initialize our `ClientMessageHandler` object in the constructor of
    the client class, as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在客户端类的构造函数中初始化我们的`ClientMessageHandler`对象，如下所示：
- en: '[PRE24]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With the received messages handled, we can look at the logic on the client side
    and the messages it sends. This is very limited as most of the game functionality
    is handled by the server.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完接收到的消息后，我们可以查看客户端的逻辑以及它发送的消息。这非常有限，因为大多数游戏功能都是由服务器处理的。
- en: 'The following steps show how to implement the client-side game logic:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何实现客户端游戏逻辑：
- en: The `placeShip` method can be written in many different ways. Normally, you
    will have a graphical interface. For this recipe though, we use a command prompt,
    which breaks down the input to *x* and *y* coordinates and whether the ship is
    placed horizontally or vertically. At the end, it should send five instances of
    `PlaceShipMessages` to the server. For each added ship, we also call `thisPlayer.increaseShips()`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`placeShip`方法可以以多种不同的方式编写。通常，你会有一个图形界面。然而，对于这个食谱，我们使用命令提示符，它将输入分解为 *x* 和 *y*
    坐标以及船只是否水平或垂直放置。最后，它应该向服务器发送五个`PlaceShipMessages`实例。对于每增加的船只，我们还调用`thisPlayer.increaseShips()`。'
- en: We also need a method called `setMyTurn`. This uses the command prompt to receive
    *x* and *y* coordinates to shoot at. After this, it populates `FireActionMessage`,
    which is sent to the server.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个名为`setMyTurn`的方法。这个方法使用命令提示符接收要射击的 *x* 和 *y* 坐标。之后，它填充`FireActionMessage`，并将其发送到服务器。
- en: For `PlaceShipMessage`, create a new class and have it extend `GameMessage`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`PlaceShipMessage`，创建一个新的类，并让它扩展`GameMessage`。
- en: 'The class needs to contain the ID of the player placing the ship, coordinates,
    and orientation of the ship. The ID of the ship refers to the position in the
    following array:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类需要包含放置船只的玩家的ID、坐标和船只的方向。船只的ID指的是以下数组中的位置：
- en: '[PRE25]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We create another class called `FireActionMessage`, which also extends `GameMessage`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建另一个名为`FireActionMessage`的类，它也扩展`GameMessage`。
- en: This has a reference to the player firing and an *x* and *y* coordinate.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这有一个指向开火的玩家的引用，以及 *x* 和 *y* 坐标。
- en: Message handling on the server is similar to the one on the client. We have
    a `ServerMessageHandler` class implementing the `MessageListener` interface. This
    has to handle receiving messages from the player placing ships, and firing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器上的消息处理与客户端类似。我们有一个实现`MessageListener`接口的`ServerMessageHandler`类。这个类必须处理接收来自放置船只和开火的玩家的消息。
- en: 'Inside the `messageReceived` method, catch all `PlaceShipMessages`. Using the
    supplied `gameId`, we get the game instance from the server''s `getGame` method
    and call the `placeShip` method. Once this is done, we check to see whether both
    players have placed all their ships. If that is the case, it''s time to start
    the game:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`messageReceived`方法内部，捕获所有`PlaceShipMessages`。使用提供的`gameId`，我们从服务器的`getGame`方法获取游戏实例并调用`placeShip`方法。一旦完成，我们检查是否两个玩家都已经放置了所有他们的船只。如果是这样，是时候开始游戏了：
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `startGame` method, the first thing we need to do is send a message
    to let the players know the game is now started. We know what clients to send
    the message to by getting the list of connections from the `connectionFilters`
    map as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`startGame`方法中，我们首先需要发送一条消息，让玩家知道游戏现在已经开始。我们知道要向哪些客户端发送消息，如下从`connectionFilters`映射中获取连接列表：
- en: '[PRE27]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After this, we decide which player will have the first move and send `TurnMessage`
    to the players, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们决定哪个玩家将先走一步，并将`TurnMessage`发送给玩家，如下所示：
- en: '[PRE28]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we need to define `TurnMessage`. It is another simple message, only containing
    the ID of the player whose turn it currently is and extending `GameMessage`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义`TurnMessage`。这是一个简单的消息，只包含当前轮到哪个玩家的ID，并扩展`GameMessage`。
- en: 'Back in `ServerMessageListener`, we make it ready to receive `FireActionMessage`
    from a player. We begin by verifying that the `playerId` of the incoming message
    matches with the current player on the server side. It can be implemented as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`ServerMessageListener`，我们使其准备好接收来自玩家的`FireActionMessage`。我们首先验证传入消息的`playerId`是否与服务器端的当前玩家匹配。它可以如下实现：
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we call `applyMove` on the game, letting it decide whether it''s a hit
    or not. If it''s a hit, the ship will be returned. It can be implemented by typing
    the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在游戏上调用`applyMove`，让它决定是否命中。如果是命中，船只将被返回。这可以通过输入以下代码实现：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We go on and create a `FiringResult` message. This is an extension of `FireActionMessage`
    with additional fields for the (possible) ship being hit. It should be broadcasted
    to both the players letting them know whether the action was a hit or not.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续创建一个`FiringResult`消息。这是`FireActionMessage`的扩展，包含关于（可能的）被击中的船只的额外字段。它应该广播给两位玩家，让他们知道该动作是否击中。
- en: 'Finally, we switch the active player and send another `TurnMessage` to both
    the players as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们切换活动玩家，并向两位玩家发送另一个`TurnMessage`，如下所示：
- en: '[PRE31]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This flow will continue until one of the players has run out of ships. Then,
    we should simply send `GameStatusMessage` with the `END` status to the players
    and disconnect them.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种流程将持续进行，直到其中一位玩家用完船只。然后，我们应该简单地发送包含`END`状态的`GameStatusMessage`给玩家，并将他们断开连接。
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a player launches the client, it will automatically connect to the server
    defined in the properties file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家启动客户端时，它将自动连接到在属性文件中定义的服务器。
- en: The server will acknowledge this, assign a user ID to the player, and send back
    `WelcomeMessage` containing the ID. The job of `WelcomeMessage` is to confirm
    the connection to the client, and let the client know its given ID. In this implementation,
    it is used for future communication from the client. Another way of filtering
    incoming messages would be possible using the `HostedConnection` instance, as
    it holds a unique address to the client.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将确认这一点，为玩家分配一个用户ID，并发送包含ID的`WelcomeMessage`。`WelcomeMessage`的职责是确认与客户端的连接，并让客户端知道其分配的ID。在此实现中，它用于客户端未来的通信。另一种过滤传入消息的方法是使用`HostedConnection`实例，因为它持有客户端的唯一地址。
- en: When the first player connects, a new game will be created. The game is put
    in the `WAITING` status until two players have connected, and both have placed
    their ships. For each player connecting, it creates a `GameStatusMessage` letting
    all players in the game know the current status (which is `WAITING`) and any player
    information it might have. The first player, `PlayerOne`, will receive the message
    twice (again when `PlayerTwo` connects), but it doesn't matter as the game will
    be in the `WAITING` status until both players have placed their ships.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一位玩家连接时，将创建一个新的游戏。游戏处于`WAITING`状态，直到两位玩家都连接，并且都放置了他们的船只。对于每个连接的玩家，它创建一个`GameStatusMessage`，让所有游戏中的玩家知道当前状态（即`WAITING`）以及任何可能拥有的玩家信息。第一位玩家`PlayerOne`将收到两次消息（再次当`PlayerTwo`连接时），但这没关系，因为游戏将在两位玩家都放置了船只之前保持`WAITING`状态。
- en: The `placeShip` method is simplified and doesn't contain all the verification
    that you will normally have in a full game. Make sure that the the server checks
    whether a ship is outside the board, or overlapping, and make sure it's of the
    right type, length, and so on and send a message back if it is wrong. This method
    simply checks that the ship is inside bounds and skips it if it isn't. Verification
    can also be done on the client, but to limit exploitation, it has to be done on
    the server as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`placeShip`方法被简化了，它不包含在完整游戏中通常所拥有的所有验证。确保服务器检查船只是否在棋盘外，或者重叠，并确保它是正确的类型、长度等，如果错误则发送回消息。此方法仅检查船只是否在边界内，如果不在此范围内则跳过。验证也可以在客户端进行，但为了限制滥用，它也必须在服务器上进行。'
- en: The starting player will be selected randomly and sent in a `TurnMessage` to
    both players stating who begins. The player is asked to enter a set of coordinates
    to fire at and `FireActionMessage` is sent to the server.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 起始玩家将被随机选择，并在`TurnMessage`中发送给两位玩家，说明谁开始。玩家被要求输入一组坐标进行射击，并发送`FireActionMessage`到服务器。
- en: The server verifies the player and applies it to the board. It then broadcasts
    a `FireResult` message to all players with information about the action, and whether
    any ships are hit. If the attacked player still has ships left, it becomes his
    or her turn to fire.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器验证玩家并将其应用于棋盘。然后，它向所有玩家广播一个包含关于动作信息以及是否有船只被击中的`FireResult`消息。如果被攻击的玩家仍有船只剩余，那么轮到该玩家进行射击。
- en: Once a player has run out of ships, the game ends. The server broadcasts a message
    to all the clients and disconnects them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一位玩家用完船只，游戏结束。服务器向所有客户端广播消息，并将他们断开连接。
- en: The clients have very little information about the other player. The benefit
    of this is that it makes cheating much more difficult.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端对其他玩家的信息非常有限。这种做法的好处是它使得作弊变得更加困难。
- en: Implementing a network code for FPS
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现FPS的网络代码
- en: Networked FPS games are a genre of games that never seem to lose popularity.
    In this recipe, we'll look at the basics to get a server and multiple clients
    up and running. We will emulate a server with a persistent environment, where
    players can connect and disconnect at any time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 网络FPS游戏是一种永远不会失去人气的游戏类型。在本菜谱中，我们将查看基本设置，以启动服务器和多个客户端。我们将模拟一个具有持久环境的服务器，玩家可以随时连接和断开连接。
- en: We have the benefit of using some of the code generated in earlier chapters.
    The code we'll use requires some changes to be adapted to a networked game, but
    it will again show the benefit of using jMonkeyEngine's `Control` and `AppState`
    classes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用之前章节中生成的一些代码。我们将使用的代码需要对网络游戏进行一些修改以适应，但它将再次展示使用 jMonkeyEngine 的 `Control`
    和 `AppState` 类的好处。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Good recipes to read up on before this are the previous recipes in this chapter
    (especially *Making a networked game – Battleships*, on which the architecture
    relies heavily) and also the *Creating a reusable character control* recipe from
    [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras and Game
    Controls*, as we will use a similar pattern here for our `NetworkedPlayerControl`
    implementations. To avoid repetition, this recipe will not show or explain all
    of the regular gameplay code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，阅读本章中之前的菜谱（特别是 *制作网络游戏 – 舰队战斗*，该架构高度依赖于它）以及第2章中的 *创建可重用角色控制* 菜谱（[第2章](ch02.html
    "第2章。相机和游戏控制")，*相机和游戏控制*），因为我们将在这里为我们的 `NetworkedPlayerControl` 实现使用类似的模式。为了避免重复，本菜谱将不会展示或解释所有常规游戏代码。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We begin by defining a few classes that will be used commonly across both server
    and client:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一些将在服务器和客户端之间共同使用的类：
- en: First off, we define a class called `NetworkedPlayerControl` extending `AbstractControl`.
    We will use this both as an identifier for a player object and as a control for
    the spatial representation of the player.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个名为 `NetworkedPlayerControl` 的类，它扩展了 `AbstractControl`。我们将使用这个类作为玩家对象的标识符，以及作为玩家空间表示的控制。
- en: The class will be extended in further recipes, but for now it should keep track
    of an integer called `ID`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类将在后续的菜谱中扩展，但到目前为止，它应该跟踪一个名为 `ID` 的整数。
- en: It also needs an abstract method called `onMessageReceived`, taking `PlayerMessage`
    as input. This is the method that our message handlers will call to apply changes.
    In `ServerPlayerControl`, the message will contain the actual input from the player,
    whereas `ClientPlayerControl` simply replicates what has happened on the server.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还需要一个名为 `onMessageReceived` 的抽象方法，该方法接受 `PlayerMessage` 作为输入。这是我们消息处理器将调用来应用更改的方法。在
    `ServerPlayerControl` 中，消息将包含玩家的实际输入，而 `ClientPlayerControl` 简单地复制服务器上发生的事情。
- en: Now, we define a class called `Game`, which will be shared by both the client
    and server.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个名为 `Game` 的类，它将由客户端和服务器共享。
- en: We add a `HashMap` object called `players`, where `playerId` is the key and
    `NetworkedPlayerControl` is the value. It keeps track of the players.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加一个名为 `players` 的 `HashMap` 对象，其中 `playerId` 是键，`NetworkedPlayerControl`
    是值。它跟踪玩家。
- en: 'We will need a couple of new messages for this example. All messages are assumed
    to be in a bean pattern with getters and setters. We define the messages with
    the following steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个例子添加一些新的消息。所有消息都假设是按照bean模式编写的，具有getter和setter方法。我们按照以下步骤定义消息：
- en: We create a base message to be used for player-related information and call
    it `PlayerMessage`, extending `AbstractMessage`. This only needs an integer called
    `playerId`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个用于玩家相关信息的基消息，并将其命名为 `PlayerMessage`，它扩展了 `AbstractMessage`。这个消息只需要一个名为
    `playerId` 的整数。
- en: We create the first message that extends `PlayerMessage`. It is called `PlayerActionMessage`
    and handles player input. This should be set to be reliable as we don't want to
    ever miss a player's input.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建第一个扩展 `PlayerMessage` 的消息，它被称为 `PlayerActionMessage`，用于处理玩家输入。这个消息应该设置为可靠的，因为我们不希望错过任何玩家的输入。
- en: Since player input can either be a key press or mouse click, it needs to have
    both a Boolean value called `pressed` and a float value called `floatValue`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于玩家输入可以是按键或鼠标点击，因此它需要有一个名为 `pressed` 的布尔值和一个名为 `floatValue` 的浮点值。
- en: In addition, we also have to add a String value called `action`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还需要添加一个名为 `action` 的字符串值。
- en: We extend `PlayerMessage` in another class called `PlayerUpdateMessage`. This
    will be used to distribute player location information from the server to the
    clients. This should not be reliable to avoid unnecessary delays.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在另一个名为`PlayerUpdateMessage`的类中扩展了`PlayerMessage`。这将用于从服务器向客户端分发玩家位置信息。这不应该太可靠，以避免不必要的延迟。
- en: It has a `Vector3f` field called `position` and a `Quaternion` field called
    `lookDirection`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它有一个名为`position`的`Vector3f`字段和一个名为`lookDirection`的`Quaternion`字段。
- en: 'With the messages defined, let''s see what the server code looks like:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了消息后，让我们看看服务器代码的样子：
- en: We define a new class called `FPSServer`, which extends `SimpleApplication`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`FPSServer`的新类，它扩展了`SimpleApplication`。
- en: 'It needs to keep track of the following fields. Apart from the `Server` field,
    it also keeps track of the next ID to give to a connecting player, a Game, and
    a Map of all the currently connected players, with their connection as the key:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要跟踪以下字段。除了`Server`字段外，它还跟踪要分配给连接玩家的下一个ID、一个游戏和一个所有当前连接玩家的映射，其中连接作为键：
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Like in the previous recipe, we use a class called `GameUtil` to register all
    our message classes. We also set `frameRate` to `30 fps`. This might be different
    depending on the game type. Finally, we start the application in the headless
    mode, to save resources as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在先前的配方中一样，我们使用一个名为`GameUtil`的类来注册我们所有的消息类。我们还设置`frameRate`为`30 fps`。这可能会根据游戏类型而有所不同。最后，我们以无头模式启动应用程序，以节省资源，如下所示：
- en: '[PRE33]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We initialize the server as in the *Making a networked game ‑ Battleships* recipe
    and create a `ConnectionListener` instance to look for connecting and disconnecting
    players. This will call `addPlayer` and `removePlayer` respectively, when players
    connect or disconnect.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化服务器，就像在*制作网络游戏 - 舰队大战*配方中一样，并创建一个`ConnectionListener`实例来寻找连接和断开连接的玩家。当玩家连接或断开时，它将分别调用`addPlayer`和`removePlayer`。
- en: 'In the `addPlayer` method, we create a new `ServerPlayerControl` instance,
    which is the server-side implementation of `NetworkedPlayerControl`, and assign
    an ID to it for easier reference, as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`addPlayer`方法中，我们创建一个新的`ServerPlayerControl`实例，这是`NetworkedPlayerControl`的服务器端实现，并为其分配一个ID以便更容易引用，如下所示：
- en: '[PRE34]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we create a spatial for it so that it has a reference in the scene graph
    (and thus, it will be automatically updated). This is not only for visual representation,
    but we are dependent on it to update our method, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为它创建一个空间，以便它在场景图中有一个引用（因此，它将自动更新）。这不仅是为了视觉表示，我们还依赖于它来更新我们的方法，如下所示：
- en: '[PRE35]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For any future communication with the server, the client will supply its `playerId`
    in all messages, so the server sends the assigned ID back to the client in `WelcomeMessage`.
    It broadcasts the message using the client''s connection as a filter, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于与服务器未来的任何通信，客户端将在所有消息中提供其`playerId`，因此服务器在`WelcomeMessage`中将分配的ID发送回客户端。它使用客户端的连接作为过滤器广播消息，如下所示：
- en: '[PRE36]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we send information about all the other players to the player that joins,
    as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们向加入的玩家发送关于所有其他玩家的信息，如下所示：
- en: '[PRE37]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Lastly, the server sends a message to all the other players about the new player,
    as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，服务器向所有其他玩家发送关于新玩家的消息，如下所示：
- en: '[PRE38]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `removePlayer` method works similarly, but it only has to send a message
    to each player currently connected about the disconnected player. It also uses
    `PlayerJoinMessage` but it sets the `leaving` Boolean to `true` to indicate the
    player is leaving, not joining the game.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`removePlayer`方法的工作方式类似，但它只需向当前连接的每个玩家发送关于断开连接玩家的消息。它也使用`PlayerJoinMessage`，但将`leaving`布尔值设置为`true`，以指示玩家正在离开，而不是加入游戏。'
- en: 'Then, the server will continuously send location and rotation (direction) updates
    to all players. Since we set `fps` to `30`, it will try to do this every 33 ms
    as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，服务器将连续向所有玩家发送位置和旋转（方向）更新。由于我们将`fps`设置为`30`，它将尝试每33毫秒这样做，如下所示：
- en: '[PRE39]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also create a `ServerMessageHandler` class that implements `MessageListener`.
    It''s a short class in this case, which will only listen to messages extending
    `PlayerMessage` and pass it on to the correct `NetworkedPlayerControl` class to
    update it. In this recipe, this will mean the input coming from the player, as
    follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还创建了一个`ServerMessageHandler`类，它实现了`MessageListener`。在这个例子中，这是一个简短的类，它将只监听扩展`PlayerMessage`的消息，并将其传递给正确的`NetworkedPlayerControl`类以更新它。在这个配方中，这意味着来自玩家的输入，如下所示：
- en: '[PRE40]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For the server-side implementation of the `NetworkedPlayerControl` class, we
    extend it to a new class called `ServerPlayerControl`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`NetworkedPlayerControl`类的服务器端实现，我们将其扩展到一个新的类，称为`ServerPlayerControl`。
- en: 'Similar to the `GameCharacterControl` class from [Chapter 2](ch02.html "Chapter 2. Cameras
    and Game Controls"), *Cameras and Game Controls*, we will use a set of Booleans
    to keep track of the input, as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与[第2章](ch02.html "第2章。相机和游戏控制")中的`GameCharacterControl`类类似，我们将使用一组布尔值来跟踪输入，如下所示：
- en: '[PRE41]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the implemented `onMessageReceived` method, listen for `PlayerMessages`.
    We don''t know if it will contain Boolean or float values, so we look for both,
    as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现的`onMessageReceived`方法中，监听`PlayerMessages`。我们不知道它将包含布尔值还是浮点值，所以我们寻找两者，如下所示：
- en: '[PRE42]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we apply the values as shown in the following code snippet:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们应用以下代码片段中的值：
- en: '[PRE43]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the overridden `controlUpdate` method, we then modify the position and rotation
    of the spatial based on the input, just like we did in the *Creating a reusable
    character control* recipe of [Chapter 2](ch02.html "Chapter 2. Cameras and Game
    Controls"), *Cameras and Game Controls*.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重写的`controlUpdate`方法中，我们根据输入修改空间的位置和旋转，就像我们在[第2章](ch02.html "第2章。相机和游戏控制")中*创建可重用的角色控制*食谱中所做的那样。
- en: 'The client is simple in many ways, since it basically only does two things.
    It takes a player''s input, sends it to the server, receives updates from the
    server, and applies them as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在很多方面都很简单，因为它基本上只做两件事。它接收玩家的输入，将其发送到服务器，接收来自服务器的更新，并按以下方式应用它们：
- en: We begin by creating a new class called `FPSClient` extending `SimpleApplication`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`FPSClient`的新类，它扩展了`SimpleApplication`。
- en: 'In the constructor, we read the network properties file and connect to the
    server, as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们读取网络属性文件并连接到服务器，如下所示：
- en: '[PRE44]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Just as with the server, we register all the message classes before launching
    the application.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像服务器一样，在启动应用程序之前，我们注册所有消息类。
- en: The application should have a reference to a `Node` class called `playerModel`,
    which will be the visual representation of the players in the game. There should
    also be a `ClientPlayerControl` class called `thisPlayer`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序应该有一个指向名为`playerModel`的`Node`类的引用，它将是游戏中玩家的视觉表示。还应该有一个名为`thisPlayer`的`ClientPlayerControl`类。
- en: 'In the `simpleInitApp` method, we attach `InputAppState`. This has the same
    functionality as the one in the *Creating an input AppState object* recipe of
    [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras and Game
    Controls*. The only difference is it will benefit from having a direct way of
    reaching the client to send messages:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`simpleInitApp`方法中，我们附加了`InputAppState`。这与[第2章](ch02.html "第2章。相机和游戏控制")中*创建一个输入AppState对象*食谱中的功能相同，即*相机和游戏控制*。唯一的区别是它将受益于有一个直接的方式到达客户端发送消息：
- en: '[PRE45]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we create `playerGeometry` to be used for all the players in this example,
    as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`playerGeometry`，用于本例中的所有玩家，如下所示：
- en: '[PRE46]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also turn off the application''s `flyByCamera` instance and create a new
    `game` object, which we will populate when we receive information from the server,
    as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还关闭了应用程序的`flyByCamera`实例并创建了一个新的`game`对象，当从服务器接收到信息时，我们将填充它，如下所示：
- en: '[PRE47]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Lastly, we create a new `ClientMessageListener` object and add it to the client,
    as shown in the following code snippet:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个新的`ClientMessageListener`对象并将其添加到客户端，如下所示：
- en: '[PRE48]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `createPlayer` method, we create a new `ClientPlayerControl` instance
    and also a `Node` instance, which we attach to the scene graph, as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`createPlayer`方法中，我们创建一个新的`ClientPlayerControl`实例，还创建了一个`Node`实例，并将其附加到场景图中，如下所示：
- en: '[PRE49]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since we don''t know when this method will be called, we make sure that we
    attach the spatial in a thread-safe way. This can be implemented as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不知道这个方法将在何时被调用，我们确保以线程安全的方式附加空间。这可以如下实现：
- en: '[PRE50]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Finally, we return the created `ClientPlayerControl` instance to the calling
    method.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建的`ClientPlayerControl`实例返回给调用方法。
- en: 'We add a new method called `setThisPlayer`. This method will be called when
    the player''s `WelcomeMessage` is received. Inside this, we create `CameraNode`,
    which will be attached to the player, as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`setThisPlayer`的新方法。当接收到玩家的`WelcomeMessage`时，将调用此方法。在这个方法内部，我们创建`CameraNode`，它将被附加到玩家，如下所示：
- en: '[PRE51]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We also have to override the `destroy` method to make sure we close the connection
    to the server when the client is shutdown. This can be implemented as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须重写 `destroy` 方法，以确保在客户端关闭时关闭与服务器的连接。这可以按以下方式实现：
- en: '[PRE52]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, we need to create the client representation of `NetworkedPlayerControl`
    and extend it in a class called `ClientPlayerControl`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建 `NetworkedPlayerControl` 的客户端表示，并在一个名为 `ClientPlayerControl` 的类中扩展它。
- en: It has a `Vector3f` field called `tempLocation` and a `Quaternion` field called
    `tempRotation`. These are used to hold received updates from the server. It can
    also have a `float` field called `yaw` for head movement.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它有一个名为 `tempLocation` 的 `Vector3f` 字段和一个名为 `tempRotation` 的 `Quaternion` 字段。这些用于存储从服务器接收到的更新。它还可以有一个名为
    `yaw` 的 `float` 字段，用于头部移动。
- en: 'In the `onMessageReceived` method, we only look for `PlayerUpdateMessages`
    and set `tempLocation` and `tempRotation` with the values received in the message,
    as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onMessageReceived` 方法中，我们只查找 `PlayerUpdateMessages` 并使用消息中接收到的值设置 `tempLocation`
    和 `tempRotation`，如下所示：
- en: '[PRE53]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We will then apply the `temp` variable values in the `controlUpdate` method:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 `temp` 变量的值应用于 `controlUpdate` 方法：
- en: '[PRE54]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Just like on the server side, we need a message handler listening for incoming
    messages. To do this, perform the following steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在服务器端一样，我们需要一个消息处理程序来监听传入的消息。为此，执行以下步骤：
- en: We create a new class called `ClientMessageHandler`, which implements `MessageListener<Client>`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `ClientMessageHandler` 的新类，该类实现了 `MessageListener<Client>`。
- en: The `ClientMessageHandler` class should have a reference to `FPSClient` in a
    field called `gameClient` and `Game` itself in another field called `game`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ClientMessageHandler` 类应该在名为 `gameClient` 的字段中有一个对 `FPSClient` 的引用，在另一个名为
    `game` 的字段中有一个对 `Game` 的引用。'
- en: 'In the `messageReceived` method, we need to handle a number of messages. The
    `WelcomeMessage` is most likely to arrive first. When this happens, we create
    a player object and spatial and assign it to be this client''s player, as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `messageReceived` 方法中，我们需要处理许多消息。`WelcomeMessage` 最有可能首先到达。当这种情况发生时，我们创建一个玩家对象和空间，并将其分配给这个客户端的玩家，如下所示：
- en: '[PRE55]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `PlayerJoinMessage` is received both when player joins and leaves a game.
    What sets it apart is the `leaving` Boolean. We call both the `game` and `gameClient`
    methods based on whether the player is joining or leaving, as shown in the following
    code snippet:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家加入或离开游戏时都会接收到 `PlayerJoinMessage`。使其与众不同的因素是 `leaving` 布尔值。根据玩家是加入还是离开，我们调用
    `game` 和 `gameClient` 方法，如下面的代码片段所示：
- en: '[PRE56]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When the `PlayerUpdateMessage` is received, we first find the corresponding
    `ClientPlayerControl` class and pass on the message to it, as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到 `PlayerUpdateMessage` 时，我们首先找到相应的 `ClientPlayerControl` 类，并将消息传递给它，如下所示：
- en: '[PRE57]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The server is running in the headless mode, which means it won't do any rendering
    and there will be no graphical output, but we still have access to the full jMonkeyEngine
    application. In this recipe, one server instance will only have one game active
    at a time.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器以无头模式运行，这意味着它不会进行任何渲染，也不会有图形输出，但我们仍然可以访问完整的 jMonkeyEngine 应用程序。在这个菜谱中，一个服务器实例一次只能有一个游戏活动。
- en: We instantiate all network messages inside a class called `GameUtil`, since
    they have to be the same (and serialized in the same order) on the client and
    server.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名为 `GameUtil` 的类中实例化所有网络消息，因为它们在客户端和服务器上必须相同（并且以相同的顺序序列化）。
- en: The client will try to connect to the server as soon as it launches. Once connected,
    it will receive `playerId` from the server via `WelcomeMessage`, as well as `PlayerJoinMessages`
    for all other players that are already connected. Likewise, all other players
    will receive `PlayerJoinMessage` with the new player's ID.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将在启动时立即尝试连接到服务器。一旦连接，它将通过 `WelcomeMessage` 从服务器接收 `playerId`，以及所有已连接的其他玩家的
    `PlayerJoinMessages`。同样，所有其他玩家都将收到包含新玩家 ID 的 `PlayerJoinMessage`。
- en: The client sends any actions the players perform to the server using `PlayerActionMessage`,
    which applies them to its instance of the game. The server, which runs at 30 fps,
    will send positions and directions of each player to all the other players, using
    `PlayerUpdateMessages`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用 `PlayerActionMessage` 将玩家执行的所有操作发送到服务器，并将其应用于其游戏实例。运行在 30 fps 的服务器将使用
    `PlayerUpdateMessages` 将每个玩家的位置和方向发送给所有其他玩家。
- en: 'The `InputAppState` class on the client is very similar to the one in [Chapter
    2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras and Game Controls*.
    The only difference is that instead of directly updating a `Control` instance,
    it creates a message and sends it to the server. In the `onAction` class, we set
    the Boolean value of the message, whereas in `onAnalog` (to look and rotate),
    `floatValue` will be used instead, as shown in the following code snippet:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的`InputAppState`类与[第2章](ch02.html "第2章。相机和游戏控制")中的类似，*相机和游戏控制*。唯一的区别是，它不是直接更新一个`Control`实例，而是创建一个消息并发送到服务器。在`onAction`类中，我们设置消息的布尔值，而在`onAnalog`（用于查看和旋转）中，将使用`floatValue`，如下面的代码片段所示：
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the event of a player leaving the game, `PlayerJoinMessages` will be sent
    to the other players, with `leaving` set to `true`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家离开游戏的情况下，`PlayerJoinMessages`将被发送给其他玩家，并将`leaving`设置为`true`。
- en: The `NetworkedPlayerControl` class is an abstract class, and doesn't do much
    on its own. You might recognize the implementation of `ServerPlayerControl` from
    `GameCharacterControl`, and they function similarly, but rather than receiving
    the input directly from the user, `ServerPlayerControl` gets it via a networked
    message instead.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkedPlayerControl`类是一个抽象类，它本身并不做很多事情。您可能已经认识到了`GameCharacterControl`中`ServerPlayerControl`的实现，并且它们的功能相似，但`ServerPlayerControl`不是直接从用户那里接收输入，而是通过网络消息接收。'
- en: Both the client and server implementation of `NetworkedPlayerControl` use the
    `tempRotation` and `tempLocation` fields to which they apply any incoming changes.
    This is so we don't modify the actual spatial transforms outside the main loop.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器对`NetworkedPlayerControl`的实现都使用`tempRotation`和`tempLocation`字段，并将任何传入的更改应用于这些字段。这样做是为了我们不在主循环之外修改实际的空间变换。
- en: We shouldn't be fooled by the relative simplicity of this recipe. It merely
    shows the basics of a real-time networked environment. Making a full game creates
    much more complexity.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该被这个配方的相对简单性所迷惑。它仅仅展示了实时网络化环境的基础。制作一个完整的游戏会带来更多的复杂性。
- en: See also
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: If you'd like to see an example of a full real-time game, have a look at the
    full source of MonkeyZone at [http://hub.jmonkeyengine.org/wiki/doku.php/jme3:advanced:monkey_zone](http://hub.jmonkeyengine.org/wiki/doku.php/jme3:advanced:monkey_zone).
    It features not only human players, but also networked AI.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想看到一个完整实时游戏的示例，请查看MonkeyZone的完整源代码，网址为[http://hub.jmonkeyengine.org/wiki/doku.php/jme3:advanced:monkey_zone](http://hub.jmonkeyengine.org/wiki/doku.php/jme3:advanced:monkey_zone)。它不仅有人类玩家，还有网络化AI。
- en: Loading a level
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载一个级别
- en: No matter if it's an FPS, RTS, or driving game we're making, we'll want to be
    able to load different kinds of environments for the players to roam around in.
    How can we do that easily?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们制作的是FPS、RTS还是驾驶游戏，我们都希望能够为玩家加载不同类型的游戏环境，让他们在其中漫游。我们如何轻松地做到这一点？
- en: In this recipe, we'll add functionalities to the networked FPS game we outlined
    previously in this chapter. The principle will work for any kind of already networked
    game, although it might differ depending on how the game implements the level.
    Here, we'll assume it uses jMonkeyEngine scenes or `.j3o` scenes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将向本章先前概述的网络化FPS游戏添加功能。这个原则适用于任何类型的已经网络化的游戏，尽管它可能取决于游戏如何实现级别。在这里，我们假设它使用jMonkeyEngine场景或`.j3o`场景。
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following set of steps to load a level:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以加载一个级别：
- en: 'We start by defining a new message class: `LoadLevelMessage`. It extends `GameMessage`
    since it might be useful to know the `gameId`. Apart from that, it has one field
    `levelName`.'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的消息类：`LoadLevelMessage`。它扩展了`GameMessage`，因为可能需要知道`gameId`。除此之外，它还有一个字段`levelName`。
- en: We'll add the same field to our `Game` class so that it can keep track of which
    level it's running.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在我们的`Game`类中添加相同的字段，以便它可以跟踪它正在运行哪个级别。
- en: 'Next, let''s create a `levelNode` field on our server, which we can load our
    level into, as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的服务器上创建一个`levelNode`字段，我们可以将级别加载到其中，如下所示：
- en: '[PRE59]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, we create a small method that will load the level from a predefined path,
    as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个小的方法，从预定义的路径加载级别，如下所示：
- en: '[PRE60]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Inside the `simpleInitApp` method, we''ll tell the application to load `TestScene`
    from [Chapter 1](ch01.html "Chapter 1. SDK Game Development Hub"), *SDK Game Development
    Hub*:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`simpleInitApp`方法内部，我们将告诉应用程序从[第1章](ch01.html "第1章。SDK游戏开发中心")，*SDK游戏开发中心*加载`TestScene`：
- en: '[PRE61]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Finally, inside the `addPlayer` method, we need to create and send the message
    to the connecting client. That's all for the server side of things.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`addPlayer`方法内部，我们需要创建并发送消息给连接的客户端。这就是服务器端的所有事情。
- en: 'In the client, we create a `levelNode` field and a `loadLevel` method, but
    it''s a little bit different:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端，我们创建一个`levelNode`字段和一个`loadLevel`方法，但略有不同：
- en: '[PRE62]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We need to make sure we manipulate the scene graph at the correct moment in
    time so that we can detach and attach the node inside an `enqueue` block.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保我们在正确的时间点操纵场景图，以便我们可以在`enqueue`块内分离和附加节点。
- en: 'Finally, we make sure `MessageListener` picks up `LoadLevelMessage` as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们确保`MessageListener`能够接收到`LoadLevelMessage`，如下所示：
- en: '[PRE63]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: That's it! When we connect to the server again, we should see a familiar scene.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！当我们再次连接到服务器时，我们应该看到一个熟悉的场景。
- en: How it works...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a client joins, the server creates a `LoadLevelMessage` class and populates
    it with the name of the level currently loaded. The server doesn't supply the
    level itself, but the client must have the levels supplied previously. The `LoadLevelMessage`
    class only provides a name in this case, which is probably enough in many cases.
    For some games, it's a good idea to support a custom path when loading levels,
    since it allows for greater customization options.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端加入时，服务器创建一个`LoadLevelMessage`类，并用当前加载的关卡名称填充它。服务器不提供关卡本身，但客户端必须之前提供这些关卡。《LoadLevelMessage`类在这种情况下只提供一个名称，这在许多情况下可能已经足够。对于某些游戏，在加载关卡时支持自定义路径是一个好主意，因为它允许有更多的定制选项。
- en: Interpolating between player positions
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在玩家位置之间进行插值
- en: If we were to only run our game in a LAN environment, we would probably never
    expect low latency or any significant packet loss. While many are blessed even
    with good Internet connections nowadays, from time to time, problems still happen.
    One of the tricks to try to mitigate these problems is to use interpolation for
    entities on the client side.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只在一个局域网环境中运行我们的游戏，我们可能永远不会期望低延迟或任何显著的丢包。虽然现在许多人都有良好的互联网连接，但时不时地，问题仍然会发生。尝试减轻这些问题的技巧之一是在客户端使用插值来处理实体。
- en: This means that rather than just applying the position and rotation the client
    gets from the server, the client will move towards the target position and rotation
    in steps.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着客户端将不会只是应用从服务器获取的位置和旋转，而是会逐步移动到目标位置和旋转。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to interpolate between the player positions:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在玩家位置之间进行插值：
- en: To simulate some network problems, set `framerate` on the server to `10`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了模拟一些网络问题，将服务器的`framerate`设置为`10`。
- en: If you connect to the server now, the movement will be noticeably jerky.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在连接到服务器，移动将会显得明显地跳跃。
- en: 'We replace the contents of the `controlUpdate` method of `ClientPlayerControl`
    with the following lines to apply the interpolation:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用以下行替换了`ClientPlayerControl`的`controlUpdate`方法的内 容，以应用插值：
- en: '[PRE64]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When we connect again and compare the experience, it will be much smoother.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们再次连接并比较体验时，它将会更加平滑。
- en: How it works...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To simulate an environment with problems such as packet loss, we changed the
    FPS on the server to 10\. Instead of sending out the 30 updates per second it
    did before, it will only send one every tenth of a second. This is not the same
    as 100 ms of latency, since it says nothing about the turnaround time. It's more
    as if two out of three updates were lost on the way, a 66 percent packet loss.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟存在如丢包等问题的情况，我们将服务器的FPS更改为10。它不会像之前每秒发送30个更新那样，而是每十分之一秒发送一个更新。这并不等同于100毫秒的延迟，因为它没有说明往返时间。这更像是每三个更新中有两个在途中丢失，即66%的丢包率。
- en: Previously, the client simply took the values it got from the server and applied
    them to the local players. Using interpolation, the player's position and rotation
    will move towards the latest actual position and rotation in steps every update.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，客户端只是简单地将其从服务器获取的值应用到本地玩家上。使用插值，玩家的位置和旋转将每更新一次逐步移动到最新的实际位置和旋转。
- en: We implemented the interpolation by first determining the interpolation factor.
    This was done by dividing `tpf` by the amount of time (roughly, in seconds) we
    would like the interpolation to take. The actual time will be longer since the
    steps become shorter with each update.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过首先确定插值因子来实现插值。这是通过将`tpf`除以我们希望插值所花费的时间（大致上，以秒为单位）来完成的。实际时间会更长，因为每次更新步骤会变得更短。
- en: We then input this value and use the interpolation method of `Vector3f` and
    the `slerp` method of `Quaternion` to move them towards the actual values.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们输入这个值，并使用`Vector3f`的插值方法和`Quaternion`的`slerp`方法将它们移动到实际值。
- en: This is done by using a factor based on the `tpf` value provided in the `update`
    method. By doing so, the interpolation time will be roughly the same regardless
    of the frame rate. We should be aware that this in reality becomes latency, a
    delay between the action and appearance, as we have added a slight delay to when
    the player reaches the actual position.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用`update`方法中提供的`tpf`值作为系数来实现的。通过这样做，插值时间将与帧率无关。我们应该意识到，在现实中这变成了延迟，即动作和外观之间的延迟，因为我们已经稍微延迟了玩家到达实际位置的时间。
- en: Firing over a network
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上射击
- en: An FPS wouldn't be a shooter unless there's actually some shooting possible.
    We'll look at an example with visible, non-instant bullets. For this, we'll be
    able to reuse some code from [Chapter 2](ch02.html "Chapter 2. Cameras and Game
    Controls"), *Cameras and Game Controls*. The recipe won't describe the actual
    collision as this is already described in that chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一个FPS游戏如果没有实际射击功能，那就不能算作射击游戏。我们将通过一个带有可见、非瞬间子弹的例子来看一下。为此，我们将能够重用[第2章](ch02.html
    "第2章。相机和游戏控制")中的代码，*相机和游戏控制*。配方不会描述实际的碰撞，因为这已经在那一章中描述过了。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to fire over a network:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上射击的步骤如下：
- en: 'To start off, we create a new message, called `BulletUpdateMessage` to send
    updates on bullet positions. It only needs two fields: a `Vector3f` field for
    position and a Boolean field for whether it''s alive or not.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的消息，称为`BulletUpdateMessage`，用于发送子弹位置更新。它只需要两个字段：一个用于位置的`Vector3f`字段和一个表示是否存活的双精度布尔字段。
- en: 'We''ll add a check in the `messageReceived` method of `ServerMessageHandler`
    to see whether a player is firing. Any action verification we want to do should
    happen prior to this:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`ServerMessageHandler`的`messageReceived`方法中添加一个检查，以查看是否有玩家在射击。我们想要进行的任何动作验证都应该在这个之前发生：
- en: '[PRE65]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We find out the direction the player is facing and create a new `ServerBullet`
    instance. It''s assigned the next available object ID and added to the `bullets`
    list, as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找出玩家面向的方向并创建一个新的`ServerBullet`实例。它被分配了下一个可用的对象ID，并添加到`bullets`列表中，如下所示：
- en: '[PRE66]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we need to add another code block to the `simpleUpdate` method to maintain
    the bullets and send out messages, as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在`simpleUpdate`方法中添加另一个代码块来维护子弹并发送消息，如下所示：
- en: '[PRE67]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In a `for` loop, we first update the bullet, and then create a new `BulletUpdateMessage`,
    which is sent to all players. If the bullet is out of range, it is removed from
    the list. This is implemented as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个`for`循环中，我们首先更新子弹，然后创建一个新的`BulletUpdateMessage`，将其发送给所有玩家。如果子弹超出范围，它将从列表中移除。这如下实现：
- en: '[PRE68]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'On the client side, we write a new method that creates a new bullet, once it
    receives information from the server:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端，我们编写一个新的方法，一旦从服务器接收到信息，就创建一个新的子弹：
- en: '[PRE69]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Then, we need a `removeBullet` method once we receive the information from the
    server.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一旦我们从服务器接收到信息，我们需要一个`removeBullet`方法。
- en: How it works...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Like in the previous recipes, it's the server that is in control of things.
    The client merely says it wants to fire and any checks happen on the server side
    (although it's fine to mimick verification on the client side to save bandwidth).
    The recipe doesn't contain any specific verifications (a player can fire at any
    time), but this is explained more in [Chapter 2](ch02.html "Chapter 2. Cameras
    and Game Controls"), *Cameras and Game Controls*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方一样，控制权在服务器手中。客户端只是表示想要射击，任何检查都在服务器端进行（尽管在客户端模拟验证以节省带宽是可以的）。配方中不包含任何特定的验证（玩家可以随时射击），但这在[第2章](ch02.html
    "第2章。相机和游戏控制")，*相机和游戏控制*中有更详细的解释。
- en: Unlike in [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"), *Cameras
    and Game Controls*, we can't use the camera as input; instead, we use the direction
    of the firing player and apply the yaw for up and down tilt.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第2章](ch02.html "第2章。相机和游戏控制")，*相机和游戏控制*不同，我们不能使用相机作为输入；相反，我们使用射击玩家的方向，并应用偏航来调整上下倾斜。
- en: Bullets are different on the server and client side. On the server, they are
    merely logical objects. Like the non-instant bullets from the *Firing non-instant
    bullets* recipe of [Chapter 2](ch02.html "Chapter 2. Cameras and Game Controls"),
    *Cameras and Game Controls*, they work like slow rays, moving through the world
    until they hit something or move out of range.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端上的子弹是不同的。在服务器上，它们仅仅是逻辑对象。就像[第2章](ch02.html "第2章。摄像头和游戏控制")中“发射非即时子弹”菜谱的非即时子弹一样，它们像慢射线一样穿过世界，直到击中某个物体或超出范围。
- en: On the client, the bullet is a bit different from the server side, and is based
    on the control pattern. The client finds out about the bullet in `ClientMessageHandler`,
    as the first update is received. It sees if `ClientBullet` exists already, and
    if not, it will create a new one. All `ClientBullet` does then is update the position
    in the `controlUpdate` method.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，子弹与服务器端略有不同，并基于控制模式。客户端在接收到第一条更新时通过`ClientMessageHandler`了解子弹。它检查`ClientBullet`是否存在，如果不存在，它将创建一个新的子弹。然后`ClientBullet`所做的只是更新`controlUpdate`方法中的位置。
- en: It's not the actual fire message that creates the bullets, but the first time
    a `BulletUpdateMessage` is received on the client. The client will keep updating
    the Bullet's position, much like the player positions, until a message says it's
    no longer alive. At this point, it will be removed.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 不是实际的射击消息创建了子弹，而是在客户端接收到第一条`BulletUpdateMessage`时。客户端将像玩家位置一样持续更新子弹的位置，直到收到一条消息表示它不再存活。此时，它将被移除。
- en: The recipe currently sends all bullets to all players. As with players, this
    could (and probably should) be based on a need-to-know basis to avoid cheating
    (and excessive bandwidth usage).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当前菜谱向所有玩家发送所有子弹。与玩家一样，这可能（并且可能应该）基于需要知道的基础来避免欺骗（和过度使用带宽）。
- en: Optimizing the bandwidth and avoiding cheating
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化带宽和避免欺骗
- en: 'It can be summarized as follows: the less information a client has, the less
    opportunity there is of exploiting said information for cheating. Also, the less
    information a client needs, the less bandwidth is required.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 可以总结如下：客户拥有的信息越少，利用这些信息进行欺骗的机会就越小。同样，客户需要的信息越少，所需的带宽就越少。
- en: Previously, we've generously sent information about every player, every update
    cycle. In this recipe, we'll change that so that the server checks what players
    can be seen by others, and only send that information.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们慷慨地发送了关于每个玩家、每个更新周期的信息。在这个菜谱中，我们将改变这一点，让服务器检查哪些玩家可以被其他人看到，并且只发送这些信息。
- en: We'll build this on top of the *Implementing a network code for FPS* recipe.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“实现FPS网络代码”菜谱的基础上构建这个功能。
- en: We need to add some complexity to the `simpleUpdate` method of the server application.
    So, instead of sending information about all players to everybody, we need to
    check who should receive what.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在服务器应用程序的`simpleUpdate`方法中添加一些复杂性。因此，我们不需要向每个人发送所有玩家的信息，而需要检查谁应该接收什么。
- en: How to do it...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to optimize a bandwidth:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以优化带宽：
- en: First of all, we'll add a visible field to our `PlayerUpdateMessage`. This is
    so that a client knows when a player has disappeared from the view.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将向我们的`PlayerUpdateMessage`添加一个可见字段。这样做是为了让客户端知道何时有玩家从视图中消失。
- en: On the server side, we need to change two classes. First, our `ServerPlayerControl`
    needs to maintain a list of player IDs it currently sees.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器端，我们需要更改两个类。首先，我们的`ServerPlayerControl`需要维护一个当前看到的玩家ID列表。
- en: 'Before we do our checks, we need to make sure all the players are updated:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们进行检查之前，我们需要确保所有玩家都已更新：
- en: '[PRE70]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we iterate through our `playerMap` object. Here, we add a simple range
    check to see whether a player is visible or not, and lastly broadcast the information
    to the relevant players, as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历我们的`playerMap`对象。在这里，我们添加一个简单的范围检查，以查看玩家是否可见，最后将信息广播给相关玩家，如下所示：
- en: '[PRE71]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: That's all for the server side. On the client side, we need to add a visible
    field to `ClientPlayerControl`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器端的操作到此结束。在客户端，我们需要向`ClientPlayerControl`添加一个可见字段。
- en: 'The second change we make is in `ClientMessageHandler`. We check whether the
    player is supposed to be visible, and whether it''s attached to the scene graph
    or not:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们做的第二个更改是在`ClientMessageHandler`中。我们检查玩家是否应该被看到，以及它是否连接到场景图：
- en: '[PRE72]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By using this principle, each client will only receive updates on other relevant
    players. We can't, however, just stop sending updates about certain players without
    also letting the client know why, or they would just freeze in their last known
    position. That's why the last message the server sends about a player is with
    `visible` set to `false`. However, to do so, the server must keep track of when
    a player has disappeared, and not just when it's not visible. That's why each
    `ServerPlayerControl` class needs to keep track of which players it saw the last
    update in its `visibleList`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个原则，每个客户端将只接收其他相关玩家的更新。然而，我们不能仅仅停止发送某些玩家的更新，而不让客户端知道原因，否则他们就会停留在最后已知的位置。这就是为什么服务器发送给玩家的最后一条消息是`visible`设置为`false`。然而，为了做到这一点，服务器必须跟踪玩家何时消失，而不仅仅是他们何时不可见。这就是为什么每个`ServerPlayerControl`类都需要跟踪它在`visibleList`中最后一次更新的玩家。
- en: This recipe focused on the networking aspects of visibility and how and when
    to send updates. A proper game (at least an FPS) will need to keep track of obscured
    players as well, not only how far away they are.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方专注于可见性的网络方面，以及何时以及如何发送更新。一个合适的游戏（至少是一个第一人称射击游戏）还需要跟踪被遮挡的玩家，而不仅仅是他们距离有多远。
- en: Optimization can be done in different ways, and it all comes down to the application.
    An MMO may for example not be as dependent on frequent updates. In a game like
    that, network updates can be done with less frequency, if a player is further
    away, and instead rely on good interpolation to avoid jerkiness.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 优化可以通过不同的方式进行，这都取决于应用。例如，一个大型多人在线游戏可能并不像其他游戏那样依赖于频繁的更新。在这样的游戏中，如果玩家距离较远，网络更新可以不那么频繁，而是依靠良好的插值来避免跳跃感。
- en: If we're using interpolation, and not absolute updates, we should also turn
    off interpolation when visible switches from false to true, to avoid players possibly
    gliding to the new position. We can also turn off updates when visible is false.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用插值而不是绝对更新，那么当可见性从假变为真时，我们也应该关闭插值，以避免玩家可能滑到新位置。我们也可以在可见性为假时关闭更新。
- en: See also
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Sensing – vision* recipe in [Chapter 5](ch05.html "Chapter 5. Artificial
    Intelligence"), *Artificial Intelligence*, which provides an idea on how to implement
    sight on the server
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。人工智能")中的 *感知-视觉* 配方，在《人工智能》一书中，它提供了一个在服务器上实现视觉的方法的想法'
