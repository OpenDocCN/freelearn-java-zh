- en: Airline Ticket System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 航空票务系统
- en: Our last projects—Twitter Consumers, Twitter Gathering, and Twitter Dispatcher—were
    excellent. We learned several exciting features, and they were implemented using
    the new features present in Spring 5.0\. All of them are implemented in Reactive
    Streams and use Kotlin as the programming language. They are the hottest features
    in Spring 5.0; it was an impressive progression.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的几个项目——Twitter消费者、Twitter收集器和Twitter分发器——非常出色。我们学习了几个令人兴奋的功能，它们都是使用Spring
    5.0中的新功能实现的。所有这些都是在响应式流中使用Kotlin作为编程语言实现的；它们是Spring 5.0中最热门的功能；这是一个令人印象深刻的进步。
- en: However, there are notably missing parts on these projects; we have microservice
    needs in mind. There are no infrastructure services such as service discovery,
    distributed configurations, API Gateway, distributed tracing, and monitoring.
    These kinds of services are mandatory in distributed systems such as microservice
    architectures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这些项目中明显缺少一些部分；我们考虑到了微服务需求。没有像服务发现、分布式配置、API网关、分布式跟踪和监控这样的基础设施服务。这些服务在微服务架构等分布式系统中是必需的。
- en: 'There are several reasons for that. Firstly, we can think of the configuration
    management. Let''s imagine the following scenario – in the development cycle,
    we have three environments: DEV, TST, and PROD. This is a pretty simple standard
    found in companies. Also, we have an application decoupled in 4 microservices,
    then with the minimum infrastructure, we have 12 instances of services; remember,
    this is a good scenario because in a real situation, we will probably have several
    instances of microservice applications.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因。首先，我们可以考虑配置管理。让我们想象以下场景——在开发周期中，我们有三个环境：开发（DEV）、测试（TST）和生产（PROD）。这是公司在标准中找到的相当简单的标准。此外，我们将应用程序解耦为4个微服务，然后使用最少的基础设施，我们有12个服务实例；记住，这是一个好场景，因为在实际情况中，我们可能会有几个微服务应用程序的实例。
- en: In the earlier scenario, we will maintain at least three configuration files
    per microservice, remember there are three environments for which we need to keep
    the configurations. Then, we will have 12 *versions* of settings. It is a hard
    task to maintain the configurations, to keep the files synchronized and updated.
    These files probably contain sensitive information, such as database passwords
    and message brokers' configurations, and it is not recommended that you put these
    files on the host machines.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期场景中，我们将为每个微服务维护至少三个配置文件，记住我们需要为三个环境保留配置。然后，我们将有12个*版本*的设置。维护配置是一项艰巨的任务，要保持文件同步和更新。这些文件可能包含敏感信息，如数据库密码和消息代理的配置，而且不建议将这些文件放在主机机器上。
- en: In this case, the distributed configuration can solve our problems easily. We
    will learn about configuration servers in this chapter, and other infrastructure
    services as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，分布式配置可以轻松解决我们的问题。在本章中，我们将学习配置服务器以及其他基础设施服务。
- en: 'Let''s summarize what we will learn in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章我们将学习的内容：
- en: How to create a Config Server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建配置服务器
- en: Implementing a service discovery with Eureka
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eureka实现服务发现
- en: Monitoring applications with Spring Cloud Zipkin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Zipkin监控应用程序
- en: Exposing the applications with the Spring Cloud Gateway
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Gateway暴露应用程序
- en: The Airline Ticket System
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 航空票务系统
- en: In these last few chapters, we will work on the Airline Ticket System. The solution
    is quite complex and involves a lot of HTTP integrations and message-based solutions.
    We will explore what we have learned from the book journey.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些最后几章中，我们将致力于航空票务系统。解决方案相当复杂，涉及大量的HTTP集成和基于消息的解决方案。我们将探索从本书旅程中学到的内容。
- en: We will use Spring Messaging, Spring WebFlux, and Spring Data components to
    create the solution. The application will split up into several microservices
    to guarantee the scalability, elasticity, and fault tolerance for the system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Spring Messaging、Spring WebFlux和Spring Data组件来创建解决方案。应用程序将拆分为几个微服务，以确保系统的可伸缩性、弹性和容错性。
- en: Also, we will have some infrastructure services to help us deliver an efficient
    system. Some new patterns will be introduced, such as circuit breakers and OAuth.
    In the infrastructure layer, we will use the Netflix OSS components integrated
    with the Spring Framework ecosystem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将有一些基础设施服务来帮助我们交付一个高效的系统。将引入一些新的模式，例如断路器和OAuth。在基础设施层，我们将使用与Spring框架生态系统集成的Netflix
    OSS组件。
- en: The main purpose of our application is to sell airline tickets, but to achieve
    this task, we need to build an entire ecosystem. We will build a microservice
    which will manage the seats and planes' characteristics. There will also be a
    microservice to manage available company flights; the basic idea is to manage
    flight dates and routes. Of course, we will have a microservice to manage passengers,
    fares, bookings, and payments. Finally, we will have an `e-commerce` API with
    which end users will buy airline tickets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的主要目的是销售机票，但为了完成这个任务，我们需要构建一个完整的生态系统。我们将构建一个微服务来管理座位和飞机的特性。还将有一个微服务来管理可用的公司航班；基本想法是管理航班日期和路线。当然，我们还将有一个微服务来管理乘客、票价、预订和支付。最后，我们将有一个`电子商务`API，用户可以通过它购买机票。
- en: Airline functionalities
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 航空公司功能
- en: We will create some microservices to compose the solution and then we will decompose
    the solution into small pieces, that is, microservices. For that, we will use
    the Bounded Context pattern which is an essential part of the **Domain-Driven
    Design** (**DDD**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一些微服务来构建解决方案，然后我们将解决方案分解成小块，即微服务。为此，我们将使用边界上下文模式，这是**领域驱动设计**（**DDD**）的一个基本组成部分。
- en: 'Let''s look at the following diagram to have an idea about what we will build:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的图表，以便了解我们将要构建的内容：
- en: '![](img/753b73dc-b3dc-42f9-9a97-d71218b84d8c.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/753b73dc-b3dc-42f9-9a97-d71218b84d8c.png)'
- en: It is a summary of what we will do in these few chapters; we have defined the
    basic functionalities for each microservice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章将要做什么的总结；我们已经为每个微服务定义了基本功能。
- en: Now, we will take a look at components; let's go to the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看组件；让我们进入下一节。
- en: Solution diagram
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案图表
- en: 'The following diagram illustrates the whole solution, which we will implement
    in the following chapters:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了整个解决方案，我们将在接下来的章节中实现它：
- en: '![](img/4fa12d95-91e4-4a04-a321-d9520ed6e208.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fa12d95-91e4-4a04-a321-d9520ed6e208.png)'
- en: As we can see, there are different kinds of components. Some components will
    be exposed through the **Gateway** for end users, in our case, our customers.
    There is a category which the company users will use to register flights, for
    instance, where these microservices will be exposed on **Gateway** as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有不同的组件。一些组件将通过**网关**向最终用户（在我们的案例中，是我们的客户）公开。还有一个类别，公司用户将使用它来注册航班，例如，这些微服务也将通过**网关**公开。
- en: The infrastructure category will not be exposed over the internet, except the
    **Gateway** service. These services help the solution infrastructure and should
    be not exposed because there is sensitive data in there.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施类别不会通过互联网公开，除了**网关**服务。这些服务帮助解决方案的基础设施，不应该公开，因为其中包含敏感数据。
- en: There a lot of things to do; let's get on with the show.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事情要做；让我们开始吧。
- en: DDD enables us to deal easily with microservices. Some DDD patterns fit well
    for the microservices architectural style. There are many interesting books in
    the Packt catalog.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: DDD使我们能够轻松地处理微服务。一些DDD模式非常适合微服务架构风格。Packt目录中有很多有趣的书籍。
- en: Spring Cloud Config Server
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server
- en: When we adopt the microservices architectural style, there are some challenges
    to solve. One of the first problems to solve is how to manage the microservices
    configurations in the cluster, and how to make them easy and distributed, as well?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们采用微服务架构风格时，有一些挑战需要解决。首先要解决的问题之一是如何在集群中管理微服务配置，以及如何使它们易于分布式？
- en: Spring Cloud Config provides a Spring way, based on annotations and Spring beans.
    It is an easy way to solve this problem in a production-ready module. There are
    three main components in this module, the Configuration Repository, that is, version
    control system, the Config Server, which will provide the configurations, and
    finally, the Configuration Client, which will consume the configuration from the
    Config Server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config提供了一个基于注解和Spring bean的Spring方式。这是一个在可生产模块中轻松解决这个问题的好方法。此模块有三个主要组件，即配置存储库，也就是版本控制系统，配置服务器，它将提供配置，最后是配置客户端，它将从配置服务器消费配置。
- en: This module supplies the configuration files over an HTTP interface. It is the
    main feature provided by this project and it acts as a central repository for
    configuration in our architecture.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块通过HTTP接口提供配置文件。这是本项目提供的主要功能，它作为我们架构中配置的中心存储库。
- en: We want to remove the `application.yaml` file from our classpath; we do not
    need this file in classpath anymore, and so we will use the Config Server to serve
    this file for our application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从我们的类路径中移除`application.yaml`文件；我们不再需要在类路径中此文件，因此我们将使用配置服务器为我们应用程序提供此文件。
- en: Now, our microservices will not have the configuration file, that is, `application.yaml`. 
    During the application bootstrap, the application will look at the Config Server
    to get the correct configuration, and after that, the application will finish
    the bootstrap to get them up and into running status.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的微服务将没有配置文件，即`application.yaml`。在应用程序引导过程中，应用程序将查看配置服务器以获取正确的配置，然后应用程序将完成引导以将它们启动并运行。
- en: 'The following diagram explains the **Config Server** and Config Client:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了**配置服务器**和配置客户端：
- en: '![](img/0a9eadf3-88e3-4a7c-af0b-f445593eb38f.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a9eadf3-88e3-4a7c-af0b-f445593eb38f.png)'
- en: As we can see, the basic idea here is to try to distribute the configuration
    through the **Config Server**. There are some advantages to using this approach.
    The first one keeps the configuration in the central repository. It makes the
    configuration easy to maintain. The second one is that the configurations are
    served with a standard protocol, such as HTTP. Most of the developers know the
    protocol and make the interaction easy to understand. Finally, and most importantly,
    when the properties change, it can reflect immediately in other microservices.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这里的基思想是尝试通过**配置服务器**分发配置。使用这种方法有一些优点。第一个优点是将配置保存在中央仓库中。这使得配置易于维护。第二个优点是配置通过标准协议（如
    HTTP）提供服务。大多数开发者都知道这个协议，这使得交互易于理解。最后，也是最重要的，当属性更改时，它可以在其他微服务中立即反映。
- en: Time to implement it. Let's go there.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候实现它了。让我们开始吧。
- en: The Config Server is usually maintained on private networks, if we are deploying
    in cloud environments, although the Spring Cloud Config supports encrypt and decrypt
    based on symmetric or asymmetric keys. Keep in the mind that the microservices
    configurations should not be published on public networks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器通常在私有网络上维护，如果我们是在云环境中部署，尽管 Spring Cloud 配置支持基于对称密钥或非对称密钥的加密和解密。记住，微服务配置不应该发布在公共网络上。
- en: Creating the Config Server project
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建配置服务器项目
- en: 'Let''s create our project with Spring Initializr. Go to Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    and follow the image instructions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Spring Initializr 创建我们的项目。转到 Spring Initializr ([https://start.spring.io/](https://start.spring.io/))
    并遵循图片说明：
- en: '![](img/6d2e86ae-ec42-42fe-98c6-7b783b332925.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d2e86ae-ec42-42fe-98c6-7b783b332925.png)'
- en: Click on Generate Project and then we can open the project on the IDE.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 点击生成项目，然后我们可以在 IDE 中打开项目。
- en: Enabling Spring Cloud Config Server
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 Spring Cloud 配置服务器
- en: 'We will use the Git repository as a property source, and then we need to create
    a repository to keep these files. However, before that, let''s navigate to the `pom.xml` file
    and see some interesting stuff. We can find the following dependency:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Git 仓库作为属性源，然后我们需要创建一个仓库来保存这些文件。然而，在此之前，让我们导航到`pom.xml`文件，看看一些有趣的内容。我们可以找到以下依赖项：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is a Config Server dependency. It enables us to use the Config Server in
    our application. Remember, we need to put this into the `pom.xml` file to achieve
    the required Config Server.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个配置服务器的依赖项。它使我们能够在我们的应用程序中使用配置服务器。记住，我们需要将此放入`pom.xml`文件中才能达到所需的配置服务器。
- en: Using GitHub as a repository
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub 作为仓库
- en: The Spring Cloud Config Server enables us to use different datastore technologies
    to work as a properties repository. There are some options such as Git repository,
    filesystem, or SVN and others, provided by the community.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud 配置服务器使我们能够使用不同的数据存储技术作为属性存储库。社区提供了一些选项，例如 Git 仓库、文件系统或 SVN 等。
- en: We will choose the Git repository, and use GitHub as a host.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择 Git 仓库，并使用 GitHub 作为托管平台。
- en: We will use the Git repository that has the source code of the book. The repository
    is located at: [https://GitHub.com/PacktPublishing/Spring-5.0-By-Example/tree/master/config-files](https://Github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/config-files).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用包含书籍源代码的 Git 仓库。仓库位于：[https://GitHub.com/PacktPublishing/Spring-5.0-By-Example/tree/master/config-files](https://Github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/config-files)。
- en: The Spring Cloud Config Server also supports private repositories. For that
    purpose, we need to supply the private/public keys.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server也支持私有仓库。为此，我们需要提供私有/公开密钥。
- en: Configuring the Spring Boot application
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Spring Boot 应用程序
- en: 'It''s a piece of cake to enable and run the Config Server and provide our configuration
    HTTP protocol. To achieve it, we need to put the following annotation in our Spring
    Boot starter class. The implementation is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 启用和运行配置服务器以及提供我们的配置HTTP协议是一件轻而易举的事情。为了实现它，我们需要在我们的Spring Boot启动类中放置以下注解。实现如下：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Awesome. `@EnableConfigServer` does the magic for us. It will stand up the Config
    Server and make the application ready to connect.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。`@EnableConfigServer`为我们做了魔法。它会启动配置服务器并使应用程序准备好连接。
- en: Configuring the Git repository as a properties source
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Git 仓库配置为属性源
- en: 'Our Config Server needs to be configured. For that purpose, we will use the
    `application.yaml` file. This file should be simple and with minimal configurations
    as well. The configuration file should look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置服务器需要被配置。为此，我们将使用`application.yaml`文件。这个文件应该简单，并且配置最少。配置文件应该看起来像这样：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have configured the application port, which is a common task. We named our
    Config Server, and the most important part is the `server.git.uri` configuration
    property which instructs the Spring Framework to get the configurations files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了应用程序端口，这是一个常见任务。我们命名了我们的配置服务器，最重要的是`server.git.uri`配置属性，它指示Spring框架获取配置文件。
- en: Another configuration is `search-paths`; it allows us to search the configuration
    in `git` repository folders, instead of a root address in the repository.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个配置是`search-paths`；它允许我们在`git`仓库文件夹中搜索配置，而不是在仓库的根地址中。
- en: Running the Config Server
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行配置服务器
- en: Awesome job; our configuration server is ready to use. Then let's run it. We
    can use the JAR file, or through IDE as well, it is up to you to choose the desired
    way.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好；我们的配置服务器已经准备好使用。然后让我们运行它。我们可以使用JAR文件，或者通过IDE也可以，这取决于你选择哪种方式。
- en: We can use the Java command line or IDE to run it. I prefer to use IDE because
    it enables us to debug and make some code changes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Java命令行或IDE来运行它。我更喜欢使用IDE，因为它使我们能够调试并进行一些代码更改。
- en: Run it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它。
- en: 'The output should look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '![](img/3d7333e2-00cb-45fe-9240-725b872db110.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d7333e2-00cb-45fe-9240-725b872db110.png)'
- en: Tomcat started successfully; our Config Server is up and running. We can find
    some different endpoints in our Config Server. These endpoints are exposed to
    serve the configuration file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat启动成功；我们的配置服务器已启动并运行。我们可以在配置服务器中找到一些不同的端点。这些端点被暴露出来以提供配置文件。
- en: The Spring Cloud Config Server supports profiles as well, providing different
    configurations for different environments is important.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Config Server也支持配置文件，为不同的环境提供不同的配置是很重要的。
- en: 'The pattern supported by the Config Server is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器支持的模式如下：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is really important to keep this in mind. Also, it makes it mandatory to
    declare the `application.name` property in our microservices, to identify the
    application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这点非常重要，同时，这也使得在微服务中声明`application.name`属性成为强制性的，以识别应用程序。
- en: 'We can find the endpoints provided by the Spring Cloud Config Server on the
    application bootstrap. Take a look at the log:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在应用程序引导中找到Spring Cloud Config Server提供的端点。看看日志：
- en: '![](img/3fab23f7-200e-46ed-916d-431284f56b91.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3fab23f7-200e-46ed-916d-431284f56b91.png)'
- en: Remember the Config Server supports environments; because of this, there is
    a kind of regex on endpoints. Look at the `"/{name}-{profiles}.yml"` endpoint.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 记住配置服务器支持环境；正因为如此，端点上有一种正则表达式。看看`"/{name}-{profiles}.yml"`端点。
- en: Testing our Config Server
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的配置服务器
- en: We are able to test our Config Server over the REST API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够通过REST API测试我们的配置服务器。
- en: 'Let''s create a simple `yaml` file to create the test; the file should be called
    `dummy.yaml`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的`yaml`文件来创建测试；文件应该命名为`dummy.yaml`：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Push it to GitHub – if you are using the GitHub book, this step is unnecessary.
    Then, we can call the Config Server API using the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 推送到GitHub – 如果你使用的是GitHub书籍，这一步是不必要的。然后，我们可以使用以下命令调用配置服务器API：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The command looks for the `dummy` configuration in the profile `default`; the
    URL is self-explanatory. The following output should be displayed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 命令会在`default`配置文件中寻找名为`dummy`的配置；URL是自解释的。以下输出应该被显示：
- en: '![](img/37d49791-5ca9-4f9e-a4ba-42fe9928c9bf.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37d49791-5ca9-4f9e-a4ba-42fe9928c9bf.png)'
- en: Our Config Server is fully operational. Now, we will configure our service discovery
    using Netflix Eureka.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置服务器已完全运行。现在，我们将使用Netflix Eureka配置我们的服务发现。
- en: Spring Cloud service discovery
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud服务发现
- en: The service discovery is one of the key points of the microservices architecture.
    The basis of the microservices architecture is to decouple the monolithic application
    into smaller pieces of software which have well-defined boundaries.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现是微服务架构的关键点之一。微服务架构的基础是将单体应用程序解耦成更小的软件块，这些块具有明确的边界。
- en: This impacts our system design in the monolithic application. In general, the
    application logic stays in a single place with regards to the code. It means the
    procedure or methods calls are invoked in the same context when the application
    is running.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这影响了我们的单体应用程序的系统设计。一般来说，应用程序逻辑在代码方面保持在一个地方。这意味着当应用程序运行时，过程或方法调用是在相同的上下文中调用的。
- en: When we adopt the microservices architectural style, these invocations are typically
    external, in other words, they will invoke the service through HTTP calls, for
    example, in another application context or web server.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们采用微服务架构风格时，这些调用通常是外部的，换句话说，它们将通过HTTP调用调用服务，例如，在另一个应用程序上下文或Web服务器中。
- en: Then, the services need to call other services through HTTP, for instance, but
    how do the services call the others if the instances of these services change
    with a considerable frequency? Remember, we are creating distributed and scalable
    systems, where the instances of services can be increased according to the system
    usage.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务需要通过HTTP调用其他服务，例如，但如果这些服务的实例以相当高的频率变化，服务又是如何调用其他服务的呢？记住，我们正在创建分布式和可扩展的系统，其中服务的实例可以根据系统使用情况进行增加。
- en: The services need to know where the other services are running to be able to
    call them. Let's imagine that we are considering putting the services IPs in the
    configuration; it will be hard to manage and impossible to track the machine changes
    during that time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 服务需要知道其他服务在哪里运行，才能调用它们。让我们想象一下，如果我们考虑将服务的IP地址放入配置中；这将很难管理，并且在那段时间内无法跟踪机器的变化。
- en: The service discovery pattern addresses this challenge. In general, the solution
    involves a Service Registry, which knows the locations of all the running services.
    The client then needs to have a kind of Service Registry Client to be able to
    query this Service Registry to obtain the valid address for the desired service;
    the Service Registry will then return a healthy address, and finally, the client
    can invoke the desired service.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现模式解决了这个挑战。一般来说，解决方案涉及服务注册表，它知道所有运行服务的位置。然后，客户端需要有一种服务注册表客户端，以便能够查询这个服务注册表以获取所需服务的有效地址；然后服务注册表将返回一个健康的地址，最后，客户端可以调用所需的服务。
- en: 'Let''s look at the following diagram:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表：
- en: '![](img/c59a3075-c289-48e0-93db-f68ce5d32989.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c59a3075-c289-48e0-93db-f68ce5d32989.png)'
- en: The full documentation of this pattern can be found at [http://microservices.io/patterns/client-side-discovery.html](http://microservices.io/patterns/client-side-discovery.html)
    and [https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/](https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/).
    There are so many implementations for that pattern.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的完整文档可以在[http://microservices.io/patterns/client-side-discovery.html](http://microservices.io/patterns/client-side-discovery.html)和[https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/](https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/)找到。针对该模式有如此多的实现。
- en: The Spring Cloud service discovery supports some service discovery implementations,
    such as Hashicorp Consul provided by the Spring Cloud Consul, and Apache Zookeeper
    provided by the Spring Cloud Zookeeper.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud服务发现支持一些服务发现实现，例如由Spring Cloud Consul提供的Hashicorp Consul和由Spring
    Cloud Zookeeper提供的Apache Zookeeper。
- en: We are using the Netflix OSS stack where we will use the Eureka server, which
    was provided by the Spring Netflix OSS. It enables us to use the Eureka server
    as a managed Spring bean.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Netflix OSS堆栈，我们将使用由Spring Netflix OSS提供的Eureka服务器。它使我们能够将Eureka服务器用作管理的Spring
    Bean。
- en: The Spring Eureka Client provides a client aware of the Service Registry, and
    it can be done with a couple of annotations and some configurations – we will
    do that soon.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Eureka客户端提供了一个了解服务注册表的客户端，这可以通过几个注解和一些配置来实现——我们很快就会这么做。
- en: We will start to create and configure the Eureka server in the following sections.
    Let's do that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将开始创建和配置Eureka服务器。让我们这么做。
- en: The full documentation for the Spring Cloud Consul can be found at: [https://cloud.spring.io/spring-cloud-consul](https://cloud.spring.io/spring-cloud-consul),
    and the Spring Cloud Zookeeper can be found at: [https://cloud.spring.io/spring-cloud-zookeeper.](https://cloud.spring.io/spring-cloud-zookeeper)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Consul的完整文档可以在[https://cloud.spring.io/spring-cloud-consul](https://cloud.spring.io/spring-cloud-consul)找到，Spring
    Cloud Zookeeper的文档可以在[https://cloud.spring.io/spring-cloud-zookeeper](https://cloud.spring.io/spring-cloud-zookeeper)找到。
- en: Creating Spring Cloud Eureka
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Spring Cloud Eureka
- en: 'To enable service discovery in our infrastructure, we need to create an instance
    of a service which will act as a service discovery. The Spring Cloud Eureka server
    enables us to achieve this task. Let''s create our project. Go to Spring Initializr
    and fill in the information, as shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的基础设施中启用服务发现，我们需要创建一个实例，该实例将作为服务发现。Spring Cloud Eureka服务器使我们能够完成这项任务。让我们创建我们的项目。前往Spring
    Initializr并填写信息，如下面的截图所示：
- en: '![](img/0f428b3d-b577-4360-987f-f4a4106206dd.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f428b3d-b577-4360-987f-f4a4106206dd.png)'
- en: Take a look at the required dependencies. The Eureka server is the dependency
    which allows us to spin up a service discovery server.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下所需的依赖项。Eureka服务器是允许我们启动服务发现服务器的依赖项。
- en: Let's open the project on IDE and start to configure it. We will do this in
    the following section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在IDE中打开项目并开始配置它。我们将在下一节中这么做。
- en: Creating the Eureka server main class
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Eureka服务器主类
- en: Before we start the configuration, we will create the `main` class. This class
    will start the Spring Boot application. The Eureka server is embedded in the application.
    It is a pretty standard Spring Boot application with a single annotation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始配置之前，我们将创建`main`类。这个类将启动Spring Boot应用程序。Eureka服务器嵌入在应用程序中。这是一个相当标准的带有单个注解的Spring
    Boot应用程序。
- en: 'The `main` application class should look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`应用程序类应该看起来像这样：'
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `@EnableEurekaServer` annotation will start the embedded Eureka server in
    our application and make it ready to use. It will enable the service registry
    in our application as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableEurekaServer`注解将在我们的应用程序中启动内嵌的Eureka服务器，并使其准备好使用。它还将启用我们应用程序中的服务注册。'
- en: Configuring the Spring Cloud Eureka server
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Spring Cloud Eureka服务器
- en: Our Eureka server needs to be configured using the Spring Cloud Server configured
    in the previous sections. Then, we need to keep the `application.yaml` off our
    project, to use the Config Server properly. Instead of the `application.yaml,`
    we need to put the `bootstrap.yaml` and put the Config Server address on it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Eureka服务器需要使用之前章节中配置的Spring Cloud Server进行配置。然后，我们需要在我们的项目中保留`application.yaml`，以正确使用配置服务器。而不是`application.yaml`，我们需要放置`bootstrap.yaml`并将配置服务器地址放在它上面。
- en: 'Then, we need to:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要：
- en: Create `discovery.yaml` on GitHub
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GitHub上创建`discovery.yaml`
- en: Create `bootstrap.yaml` file in the classpath project
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在classpath项目中创建`bootstrap.yaml`文件
- en: 'Let''s start with the `discovery.yaml` file. The file should look like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`discovery.yaml`文件开始。文件应该看起来像这样：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are some interesting things to explore. We are using the localhost as
    `hostname` because we are running on the developer machine. There are a couple
    of configurations about the URLs health check and status page – pay attention
    to the configurations that are related to the server. They are placed below the
    `eureka.instance` YAML node. The configurations are `health-check-url-path` and
    `status-page-url-path`. We can use the default values as well, but the new Spring
    Boot Actuator changes the URL for those two features, so we need to configure
    them properly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有趣的事情可以探索。我们使用localhost作为`hostname`，因为我们是在开发机器上运行。有一些关于URL健康检查和状态页面的配置——请注意与服务器相关的配置。它们位于`eureka.instance`
    YAML节点下方。配置是`health-check-url-path`和`status-page-url-path`。我们也可以使用默认值，但新的Spring
    Boot Actuator改变了这两个功能的URL，因此我们需要正确配置它们。
- en: The `eureka.client` YAML node is about the client configuration; in our case,
    we set `registerWithEureka` to false. We do not want the Eureka server to act
    as a client as well. The same is true for the `fetchRegistry` configuration, it
    is a client configuration and it will cache the Eureka registry's information.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`eureka.client` YAML节点是关于客户端配置的；在我们的情况下，我们将`registerWithEureka`设置为false。我们不希望Eureka服务器同时作为客户端。对于`fetchRegistry`配置也是如此，它是一个客户端配置，它将缓存Eureka注册表的信息。'
- en: The `logging` node is about logging configuration.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging` 节点涉及日志配置。'
- en: Awesome – our `gateway.yaml` is ready.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——我们的 `gateway.yaml` 已经准备好了。
- en: 'Let''s create our `bootstrap.yaml` file in the Eureka server project classpath.
    The file should look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Eureka 服务器项目的类路径中创建我们的 `bootstrap.yaml` 文件。文件应该看起来像这样：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Easy peasy – we have configured `spring.cloud.config`. It instructs Spring of
    the Config Server address. Also, we have configured the `label`, which is the
    branch when we are using the **version control system** (**VCS**) as a repository.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 简单易行——我们已经配置了 `spring.cloud.config`。它指导 Spring 配置服务器的地址。此外，我们还配置了 `label`，这是我们使用
    **版本控制系统**（**VCS**）作为仓库时的分支。
- en: Well done. The configuration is ready. Time to run it. Let's do it in the following
    section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 做得很好。配置已经准备好了。现在是时候运行它了。让我们在下一节中这样做。
- en: Running the Spring Cloud Eureka server
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Spring Cloud Eureka 服务器
- en: The Eureka server is ready to use. We will start the Spring Boot application
    and put our Eureka server online. We can use the Java command line or IDE to run
    it. I prefer to use IDE because it enables us to debug and make some code changes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka 服务器已经准备好使用。我们将启动 Spring Boot 应用程序并将我们的 Eureka 服务器上线。我们可以使用 Java 命令行或
    IDE 来运行它。我更喜欢使用 IDE，因为它使我们能够调试并进行一些代码更改。
- en: The Config Server needs to be running because the discovery will find the configuration
    file to bootstrap the server properly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器需要运行，因为发现将找到配置文件以正确引导服务器。
- en: Run it!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它！
- en: 'We should see the following lines in the application bootstrap logs:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在应用程序启动日志中看到以下行：
- en: '![](img/989fa49b-7e17-477a-9e57-8afa3d9434d0.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/989fa49b-7e17-477a-9e57-8afa3d9434d0.png)'
- en: 'Awesome. Look at the following line of the log:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。看看日志的下一行：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It means our Eureka server is ready to use. To check the solution, we can go
    to the Eureka server home page. Go to `http://localhost:8761/` and the following
    page will be displayed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的 Eureka 服务器已经准备好使用。为了检查解决方案，我们可以访问 Eureka 服务器的首页。访问 `http://localhost:8761/`，以下页面将会显示：
- en: '![](img/7be8d8e4-c0c9-46b9-8686-8dac3141d1fe.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7be8d8e4-c0c9-46b9-8686-8dac3141d1fe.png)'
- en: As we can see, there is no instance of service available yet. We can find some
    relevant information such as the server Uptime, the current Data center, and the Current
    time. There is some information in the General Info section, information regarding
    the server where the Eureka server is running.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，还没有任何服务实例可用。我们可以找到一些相关信息，例如服务器 Uptime、当前数据中心和当前时间。在“常规信息”部分有一些信息，关于运行
    Eureka 服务器的服务器。
- en: Good job. Our service discovery service is running. We will use this infrastructure
    soon.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。我们的服务发现服务正在运行。我们很快将使用这个基础设施。
- en: Spring Cloud Zipkin server and Sleuth
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Zipkin 服务器和 Sleuth
- en: Our solution involves some microservices; it makes our solution easy to deploy
    and easy to write code. Each solution has a particular repository and codebase.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决方案涉及一些微服务；这使得我们的解决方案易于部署和编写代码。每个解决方案都有一个特定的仓库和代码库。
- en: In the monolith solution, the whole problem is solved in the same artifact to
    be deployed. Usually, in Java, these artifacts are `.jar`, `.war`, or `.ear,` if
    the application was written in the Java EE 5/6 specifications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体解决方案中，整个问题都在要部署的同一工件中解决。通常，在 Java 中，这些工件是 `.jar`、`.war` 或 `.ear`，如果应用程序是根据
    Java EE 5/6 规范编写的。
- en: The logging strategies for these kinds of applications is quite easy to work
    with (hence problems can be solved easily) because everything happens in the same
    context; the requests are received from the same application server or web server,
    which have the business components. Now, if we go to the logs, we will probably
    find the log entries we want. It makes the trace application easier to find errors
    and debug.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型应用程序的日志策略相当容易处理（因此问题可以轻松解决），因为所有事情都发生在同一个上下文中；请求来自同一个应用程序服务器或网络服务器，它们具有业务组件。现在，如果我们查看日志，我们可能会找到我们想要的日志条目。这使得跟踪应用程序更容易找到错误和调试。
- en: In the microservices solution, the application behaviors are split in the distributed
    systems; it increases the trace tasks substantially because the request probably
    arrives in the API Gateway and comes into microservices. They log the information
    in different sources. In this scenario, we need a kind of log aggregator and a
    way to identify the whole transaction between services.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务解决方案中，应用程序行为在分布式系统中被分割；这大大增加了跟踪任务，因为请求可能到达 API 网关并进入微服务。它们在不同的源中记录信息。在这种情况下，我们需要一种日志聚合器和一种识别服务之间整个事务的方法。
- en: For this purpose, the Spring Cloud Sleuth and Spring Cloud Zipkin can help us
    and make the trace features more comfortable for developers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，Spring Cloud Sleuth 和 Spring Cloud Zipkin 可以帮助我们，使跟踪功能对开发者来说更加舒适。
- en: In this section, we will look at and understand how it works under the hood.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看和理解它的工作原理。
- en: Infrastructure for the Zipkin server
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zipkin 服务器的基础设施
- en: Before we start to work, we need to configure a service which the Zipkin server
    needs. By default, the Zipkin server uses in-memory databases, but it is not recommended
    for production; usually, developers use this feature to demonstrate Zipkin features.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始工作之前，我们需要配置一个 Zipkin 服务器需要的服务。默认情况下，Zipkin 服务器使用内存数据库，但生产环境中不建议使用；通常，开发者使用此功能来演示
    Zipkin 功能。
- en: We will use MySQL as a data store. The Zipkin server also supports different
    sources, such as Cassandra and Elasticsearch.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 MySQL 作为数据存储。Zipkin 服务器也支持不同的来源，例如 Cassandra 和 Elasticsearch。
- en: Spring Cloud Sleuth supports synchronous and asynchronous operations. The synchronous
    operations are over the HTTP protocol and asynchronous can be done by RabbitMQ
    or Apache Kafka.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Sleuth 支持同步和异步操作。同步操作是通过 HTTP 协议进行的，异步可以通过 RabbitMQ 或 Apache Kafka
    完成。
- en: To use the HTTP, that is, REST API, we should use `@EnableZipkinServer,` it
    will delegate the persistence for REST tier through the `SpanStore` interface.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 HTTP，即 REST API，我们应该使用 `@EnableZipkinServer`，它将通过 `SpanStore` 接口代理 REST
    层的持久化。
- en: We will choose the asynchronous solution, since it fits well for our project,
    and we do not want the trace collector to cause some performance issues. The asynchronous
    solution uses the Spring Cloud Stream binder to store the `Spans`. We choose the
    RabbitMQ message broker to do that. It can be achieved using the `@EnableZipkinStreamServer`
    annotations which configure Spring Sleuth to use streams for store `Spans`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择异步解决方案，因为它非常适合我们的项目，我们也不想跟踪收集器引起一些性能问题。异步解决方案使用 Spring Cloud Stream binder
    来存储 `Spans`。我们选择 RabbitMQ 消息代理来完成这项工作。这可以通过使用 `@EnableZipkinStreamServer` 注解来实现，这些注解配置
    Spring Sleuth 使用流来存储 `Spans`。
- en: 'Let''s create our `docker-compose-min.yaml` to bootstrap our RabbitMQ and MySQL
    containers. The file should look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的 `docker-compose-min.yaml` 文件来启动 RabbitMQ 和 MySQL 容器。该文件应如下所示：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `docker-compose-min.yaml` file can be found at [GitHub](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-min.yaml),
    there is a MongoDB and Redis – they will be used in the next chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose-min.yaml` 文件可以在 [GitHub](https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter07/docker/docker-compose-min.yaml)
    找到，其中包含 MongoDB 和 Redis - 它们将在下一章中使用。'
- en: There is nothing special here. We have declared two containers—RabbitMQ and
    MySQL— and exposed the ports on the host machine. Also, we have created the `airline`
    network; we will use this network to attach our infrastructure microservices.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的。我们已经声明了两个容器 - RabbitMQ 和 MySQL - 并且在主机机器上公开了端口。此外，我们还创建了 `airline`
    网络；我们将使用这个网络来附加我们的基础设施微服务。
- en: Now, we can create our Zipkin server, which we will do in the next section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的 Zipkin 服务器，我们将在下一节中完成。
- en: Creating the Spring Cloud Zipkin server
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Spring Cloud Zipkin 服务器
- en: 'We will create our Zipkin panel structure in Spring Initializr, and then we
    need to follow the instructions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Spring Initializr 中创建我们的 Zipkin 控制面板结构，然后我们需要遵循以下说明：
- en: '![](img/3a1de65e-052f-4dd6-be13-97f188a67b43.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a1de65e-052f-4dd6-be13-97f188a67b43.png)'
- en: Awesome – take a look at the Selected Dependencies section, all of them are
    required. Pay attention to the Spring Boot version. We choose `1.5.9`, because
    there is no support for Zipkin server in Spring Boot 2\. It is not a problem because
    we do not need specific features from Spring Boot 2.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了 - 查看所选依赖项部分，所有这些依赖项都是必需的。请注意 Spring Boot 版本。我们选择 `1.5.9`，因为在 Spring Boot
    2 中没有对 Zipkin 服务器提供支持。这不是问题，因为我们不需要 Spring Boot 2 的特定功能。
- en: Click on the Generate Project button and wait for the download to finish. Afterwards,
    open the project in IDE.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“生成项目”按钮，等待下载完成。之后，在 IDE 中打开项目。
- en: 'In order to enable service discovery and store `Spans` on a database, we need
    to put the following dependencies in our `pom.xml`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用服务发现并在数据库中存储 `Spans`，我们需要在我们的 `pom.xml` 中添加以下依赖项：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first dependency is for the service discovery client and the others are
    to JDBC connections to MySQL. It makes our project dependencies fully configured.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个依赖项是为服务发现客户端，其余的是到 MySQL 的 JDBC 连接。这使得我们的项目依赖项完全配置。
- en: 'Let''s create our `main` class to start our Zipkin server. The class is pretty
    standard but with some new annotations:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的 `main` 类来启动 Zipkin 服务器。这个类相当标准，但有一些新的注解：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@EnableEurekaClient` annotation enables the application to connect to the
    Eureka server. The new annotation, `@EnableZipkinStreamServer`, instructs the
    framework to connect with the configured broker to receive the `Spans`. Remember,
    it can be done using the Spring Cloud Stream Binder.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableEurekaClient` 注解使应用程序能够连接到 Eureka 服务器。新的注解 `@EnableZipkinStreamServer`
    指示框架连接到配置的代理以接收 `Spans`。记住，这可以通过 Spring Cloud Stream Binder 完成。'
- en: Configuring boostrap.yaml and application.yaml
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 boostrap.yaml 和 application.yaml
- en: In the section, we created our `main` class. Before we run it, we should create
    our two configuration files. The `bootstrap.yaml` inside the `src/main/resources`
    directory and the `application.yaml` on our GitHub repository. They will be downloaded
    via Config Server and provided by the Zipkin server project.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在该部分，我们创建了我们的 `main` 类。在我们运行它之前，我们应该创建我们的两个配置文件。位于 `src/main/resources` 目录中的
    `bootstrap.yaml` 和位于我们的 GitHub 仓库上的 `application.yaml`。它们将通过 Config Server 下载并由
    Zipkin 服务器项目提供。
- en: 'Let''s start with `bootstrap.yaml`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `bootstrap.yaml` 开始：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Nothing special, we have configured our Config Server address.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么特别的，我们已配置了我们的 Config Server 地址。
- en: 'Let''s jump to our `application.yaml`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到我们的 `application.yaml`：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are some interesting things here. In the `spring.rabbitmq` node, we have
    configured our RabbitMQ broker connection. It will be used to receive `Spans`.
    In the `spring.datasource`, we have configured the MySQL connection. The Zipkin
    server will use it to store data. Also, we have configured how to execute the
    DDL script to create the `zipkin` database.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的事情。在 `spring.rabbitmq` 节点中，我们已配置了我们的 RabbitMQ 代理连接。它将被用来接收 `Spans`。在
    `spring.datasource` 中，我们已配置了 MySQL 连接。Zipkin 服务器将使用它来存储数据。此外，我们还配置了如何执行 DDL 脚本来创建
    `zipkin` 数据库。
- en: The `spring.sleuth` node was configured to not produce any `Span` because it
    is a server, not a client application, and we will not perform a trace on the
    Zipkin server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring.sleuth` 节点被配置为不产生任何 `Span`，因为它是一个服务器，而不是客户端应用程序，并且我们不会在 Zipkin 服务器上执行跟踪。'
- en: The `zipkin` node had been used to configure the Zipkin server storage type,
    MySQL, in our case.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`zipkin` 节点曾用来配置 Zipkin 服务器存储类型，在我们的例子中是 MySQL。'
- en: Let's run it!!!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它！！！
- en: Running the Zipkin server
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Zipkin 服务器
- en: We have configured the Zipkin server properly, so now we will be able to run
    it properly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已正确配置了 Zipkin 服务器，因此现在我们可以正常运行它。
- en: 'We can run the main class `ZipkinServerApplication`. We can use the IDE or
    Java command line, after running the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行主类 `ZipkinServerApplication`。我们可以使用 IDE 或 Java 命令行，运行以下输出后：
- en: '![](img/50e1605b-4111-45f1-b8aa-93de1ab85ee4.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50e1605b-4111-45f1-b8aa-93de1ab85ee4.png)'
- en: Good job – the Zipkin server is running now. We can take a look at the index
    page to see what it looks like.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好——Zipkin 服务器现在正在运行。我们可以查看索引页面来查看它的样子。
- en: 'Go to Zipkin page; the page should look like the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 Zipkin 页面；页面应该看起来如下截图：
- en: '![](img/1778b765-0f54-4c69-98f8-056a77cb4052.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1778b765-0f54-4c69-98f8-056a77cb4052.png)'
- en: 'Also, we can check the RabbitMQ panel to find the queue created by the Zipkin
    server. Go to the RabbitMQ Queues (`http://localhost:15672/#/queues`) section,
    the page should look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以检查 RabbitMQ 面板以找到 Zipkin 服务器创建的队列。转到 RabbitMQ 队列（`http://localhost:15672/#/queues`）部分，页面应该看起来像这样：
- en: '![](img/0df399b7-3aba-4bfc-ba86-d1c685e08c1d.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0df399b7-3aba-4bfc-ba86-d1c685e08c1d.png)'
- en: Looking at the queues, the project has created the `sleuth.sleuth` queue, well
    done.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 查看队列，项目已创建了 `sleuth.sleuth` 队列，做得好。
- en: The Zipkin server is ready. For now, we will not have any `Span`, because there
    is no application sending data to Zipkin. We will do that in the next chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin 服务器已准备就绪。目前，我们不会有任何 `Span`，因为没有应用程序向 Zipkin 发送数据。我们将在下一章中这样做。
- en: Spring Cloud Gateway
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway
- en: The API Gateway pattern helps us to expose our microservices through a single
    known entrypoint. Usually, it acts as an entrypoint to external access and redirects
    the call to internal microservices.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关模式帮助我们通过单个已知的入口点公开我们的微服务。通常，它充当外部访问的入口点并将调用重定向到内部微服务。
- en: There are many benefits when we adopt the API Gateway in our application. The
    first one can be recognized easily, it makes the API consumption easy for the
    clients, which means the clients do not need to know the different microservices
    endpoints.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中采用 API 网关有许多好处。第一个好处很容易识别，它使 API 消费对客户端来说变得容易，这意味着客户端不需要知道不同的微服务端点。
- en: Other benefits are a consequence of the first one. When we have a unique entrypoint,
    we can address some cross-application concerns such as filtering, authentication,
    throttling, and rate limit, as well.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其他好处是第一个好处的结果。当我们有一个唯一的入口点时，我们可以处理一些跨应用的问题，例如过滤、认证、节流和速率限制等。
- en: It is an essential part when we adopt the microservices architecture.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们采用微服务架构时的一个基本部分。
- en: The Spring Cloud Gateway enables us to have these features in a Spring-managed
    bean, in a Spring way using Dependency Injection and other features provided by
    the Spring Framework.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Gateway 允许我们在 Spring 管理的 bean 中使用这些功能，以 Spring 的方式使用依赖注入和其他 Spring
    框架提供的功能。
- en: The project was built on the Spring Framework 5, which uses the Project Reactor
    as a basis. There are some interesting features provided, such as Hystrix Circuit
    Breaker integration and with the Spring Cloud Discovery client, as well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目基于 Spring Framework 5，它以 Project Reactor 为基础。提供了一些有趣的功能，例如 Hystrix 断路器集成以及与
    Spring Cloud Discovery 客户端的集成。
- en: 'Look at the diagram to understand the benefits of the API Gateway:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下图表，了解 API 网关的好处：
- en: '![](img/065a670f-fcd5-4050-b27b-f01aaaf076fd.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/065a670f-fcd5-4050-b27b-f01aaaf076fd.png)'
- en: The full documentation of the API Gateway Pattern can be found at: [http://microservices.io/patterns/apigateway.html](http://microservices.io/patterns/apigateway.html).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关模式的完整文档可以在以下网址找到：[http://microservices.io/patterns/apigateway.html](http://microservices.io/patterns/apigateway.html)。
- en: Creating the Spring Cloud Gateway project
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Spring Cloud Gateway 项目
- en: 'We will use the Spring Initializr to create our Spring Cloud Gateway project;
    we will need to add some dependencies manually. Let''s go to the Spring Initializr
    page and create our project:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring Initializr 创建我们的 Spring Cloud Gateway 项目；我们需要手动添加一些依赖项。让我们转到 Spring
    Initializr 页面并创建我们的项目：
- en: '![](img/e2b1db6d-1650-42cc-a0c1-c3dd8626220e.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2b1db6d-1650-42cc-a0c1-c3dd8626220e.png)'
- en: There is a brand new dependency Gateway, it enables us to work with Spring Cloud
    Gateway. Then click on Generate Project and wait for the download to complete.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个新的依赖项 Gateway，它使我们能够与 Spring Cloud Gateway 一起工作。然后点击“生成项目”并等待下载完成。
- en: 'After that, we need to add a missing dependency. The missing dependency is
    required by the Gateway to interact with the Eureka server; the name of the dependency
    is `spring-cloud-starter-netflix-eureka-client`. Then, let''s add the dependency
    on our `pom.xml`, we will need to add the following snippet:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要添加一个缺失的依赖项。这个缺失的依赖项是 Gateway 与 Eureka 服务器交互所必需的；依赖项的名称是 `spring-cloud-starter-netflix-eureka-client`。然后，让我们在我们的
    `pom.xml` 中添加这个依赖项，我们需要添加以下片段：
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Excellent, our project is configured correctly to work with the Eureka server.
    In the following section, we will configure the project to work with the Config
    Server as well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们的项目已经正确配置，可以与 Eureka 服务器一起工作。在下一节中，我们将配置项目以与 Config Server 一起工作。
- en: Creating the Spring Cloud Gateway main class
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Spring Cloud Gateway 的主类
- en: There is no secret to this part. The Spring Cloud Gateway works in the same
    way as the common Spring Boot applications. There is a `main` class which will
    start the embedded server and starts the whole application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分没有秘密。Spring Cloud Gateway 与常见的 Spring Boot 应用程序以相同的方式工作。有一个 `main` 类，它将启动嵌入式服务器并启动整个应用程序。
- en: 'Our `main` class should look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `main` 类应该看起来像这样：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we can see, it is a pretty standard Spring Boot application, configured with
    `@EnableEurekaClient` to work with the Eureka server as a service discovery implementation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是一个相当标准的 Spring Boot 应用程序，配置了 `@EnableEurekaClient` 以作为服务发现实现与 Eureka
    服务器一起工作。
- en: Configuring the Spring Cloud Gateway project
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Spring Cloud Gateway 项目
- en: 'The primary project structure is ready. We will create the project configurations
    in this section. To achieve this, we need to carry out the following steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 主要项目结构已经准备好。在本节中，我们将创建项目配置。为了实现这一点，我们需要执行以下步骤：
- en: Add a `gateway.yaml` file to GitHub
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `gateway.yaml` 文件添加到 GitHub
- en: Create the `bootstrap.yaml` in the Gateway project
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Gateway 项目中创建 `bootstrap.yaml`
- en: We are using the Spring Cloud Config Server, so it is necessary to create the
    new file in GitHub because the Config Server will try to find the file on the
    repository. In our case, we are using GitHub as a repository.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Spring Cloud Config Server，因此有必要在GitHub上创建新文件，因为配置服务器将尝试在存储库中查找文件。在我们的例子中，我们使用GitHub作为存储库。
- en: The second task is necessary because the `bootstrap.yaml` file is processed
    before the application is fully ready to run. Then, during this phase, the application
    needs to look up the configuration file and to achieve this, the application needs
    to know the `repository`, in our case, the Config Server. Remember the address
    of the Config Server always needs to be placed on the `bootstrap.yaml`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务是必要的，因为`bootstrap.yaml`文件在应用程序完全准备好运行之前被处理。然后，在这个阶段，应用程序需要查找配置文件，为了实现这一点，应用程序需要知道`repository`，在我们的例子中，是配置服务器。记住配置服务器的地址始终需要放在`bootstrap.yaml`上。
- en: 'Let''s create our `gateway.yaml` file – the file should look like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的`gateway.yaml`文件——文件应该看起来像这样：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `eureka.client` node in the YAML file is responsible for configuring the
    Eureka Client configurations. We need to configure our Eureka server address instance.
    It should be pointed to the correct address.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件中的`eureka.client`节点负责配置Eureka客户端配置。我们需要配置我们的Eureka服务器地址实例。它应该指向正确的地址。
- en: There are more options for the Eureka Configuration Client properties. The full
    documentation can be found in [https://github.com/Netflix/eureka/wiki/Configuring-Eureka](https://github.com/Netflix/eureka/wiki/Configuring-Eureka);
    the Netflix team maintains Eureka.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka配置客户端属性有更多选项。完整的文档可以在[https://github.com/Netflix/eureka/wiki/Configuring-Eureka](https://github.com/Netflix/eureka/wiki/Configuring-Eureka)找到；Netflix团队维护Eureka。
- en: 'Then, we need to create our `bootstrap.yaml` file on the Gateway project. This
    file will instruct the Spring Framework to look up the configuration file on the
    Config Server and then download the required file to finish the application bootstrap.
    Our file should look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在网关项目中创建我们的`bootstrap.yaml`文件。此文件将指导Spring框架在配置服务器上查找配置文件，然后下载所需的文件以完成应用程序启动。我们的文件应该看起来像这样：
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Pretty simple. The `application.name` is required to instruct the framework
    to look up the correct file. Usually, there are many configuration files for different
    applications and environments as well.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单。`application.name`是必需的，用于指导框架查找正确的文件。通常，不同应用程序和环境都有许多配置文件。
- en: On the `cloud.config` node, we need to put in the Spring Cloud Config Server
    address, which we configured in the previous sections.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cloud.config`节点上，我们需要输入我们之前配置的Spring Cloud Config Server地址。
- en: 'The project final structure should look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的最终结构应该看起来像这样：
- en: '![](img/da5891f8-5e3f-4cce-bc08-ecf657d48c3c.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da5891f8-5e3f-4cce-bc08-ecf657d48c3c.png)'
- en: Look at the screenshot. There is no `application.yaml` in the classpath. This
    gives us several advantages; there is no configuration file in classpath projects,
    which helps us a great deal in managing the microservices configurations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下截图。类路径中没有`application.yaml`。这给我们带来了几个优点；类路径项目中没有配置文件，这在管理微服务配置方面对我们帮助很大。
- en: In the next section, we will run it and explain the whole application bootstrap
    process. Let's do it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将运行它并解释整个应用程序启动过程。让我们开始吧。
- en: Running the Spring Cloud Gateway
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Spring Cloud Gateway
- en: The project is well-configured, so now it is time to run it. We can use the
    Java command line or IDE. There is no difference either way.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 项目配置良好，现在是时候运行它了。我们可以使用Java命令行或IDE。两种方式没有区别。
- en: The Config Server and Eureka server need to stay up; it is mandatory that the
    Gateway project works correctly. Then, we can run the project.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务器和Eureka服务器需要保持运行状态；网关项目正确运行是强制性的。然后，我们可以运行项目。
- en: 'Run the project and look at the logs. We can see some interesting stuff, such
    as the project connecting to the Config Server and download the configuration
    and after this, it connects to the Eureka server and self-registers. The following
    diagram explains the application bootstrap flow:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目并查看日志。我们可以看到一些有趣的内容，例如项目连接到配置服务器并下载配置，然后连接到Eureka服务器并自我注册。以下图表解释了应用程序启动流程：
- en: '![](img/ba4406fe-ea05-49d0-b4e8-f229ce72a25b.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba4406fe-ea05-49d0-b4e8-f229ce72a25b.png)'
- en: 'Let''s look at what the different flows are and understand them:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同的流程是什么，并理解它们：
- en: The Gateway application requests the configuration file
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网关应用程序请求配置文件
- en: The Config Server serves the config file
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置服务器提供配置文件
- en: The Gateway application registers to the Eureka server
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网关应用注册到Eureka服务器
- en: Awesome, our Gateway application is connected to our infrastructure services.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，我们的网关应用已连接到我们的基础设施服务。
- en: Checking the Eureka server
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Eureka服务器
- en: Our Gateway is running. Now, we can check the Eureka server page to confirm
    this information.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网关正在运行。现在，我们可以检查Eureka服务器页面以确认此信息。
- en: 'Go to `http://localhost:8761/`, and check the Instances currently registered
    with Eureka section. We should see the Gateway application, as shown in the following
    screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`http://localhost:8761/`，并检查Eureka当前注册的实例部分。我们应该看到网关应用，如下面的截图所示：
- en: '![](img/82aeb332-a6e7-4c16-b009-4145d35785d2.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82aeb332-a6e7-4c16-b009-4145d35785d2.png)'
- en: Excellent. It worked well. The Gateway application is successfully registered,
    and it can be looked up via the service discovery. Our Gateway will connect to
    the Eureka server to get the service available and distribute the requested calls
    to the correct services.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 极好。它运行得很好。网关应用已成功注册，并且可以通过服务发现来查找。我们的网关将连接到Eureka服务器以获取可用的服务并将请求调用分发到正确的服务。
- en: Well done. Now, we can create our routes in the Gateway. We will do this in
    the next chapter when we create our airline microservices.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好。现在，我们可以在网关中创建我们的路由。我们将在下一章创建我们的航空公司微服务时进行此操作。
- en: Creating our first route with Spring Cloud Gateway
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Gateway创建我们的第一个路由
- en: Our Gateway is running. Before we start the real routes for our Airline application,
    let's try to use some fake routes to test the Spring Cloud Gateway behaviors.
    We will use the [https://httpbin.org/](https://httpbin.org/) site, which helps
    us to test some routes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网关正在运行。在我们开始为我们的航空公司应用程序设置真实路由之前，让我们尝试使用一些假路由来测试Spring Cloud Gateway的行为。我们将使用[https://httpbin.org/](https://httpbin.org/)网站，它帮助我们测试一些路由。
- en: 'Let''s create a class with the `@Configuration` annotation to provide the routes
    for the Spring Container. Let''s create a package called `springfive.airline.gateway.infra.route`,
    then create the following class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个带有`@Configuration`注解的类，为Spring容器提供路由。让我们创建一个名为`springfive.airline.gateway.infra.route`的包，然后创建以下类：
- en: '[PRE19]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are some different types to configure routes; the first one we extracted
    is the function to a private attribute called `addCustomHeader,` which will be
    used in the `custom-request-header` route. We will use **curl** to test some routes
    created previously.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些不同类型的配置路由；我们提取的第一个是到名为`addCustomHeader`的私有属性的函数，该函数将用于`custom-request-header`路由。我们将使用**curl**测试之前创建的一些路由。
- en: 'The first one we will test is the `custom-request-header,` the route was configured
    to route to: [http://httpbin.org:80](http://httpbin.org:80) and the path will
    be `/headers`. This service will return the Request Headers sent to the server.
    Take a look at `addCustomHeader`, we have configured it to add a custom header
    to the Request. It will be Book as the key and Spring 5.0 By Example, as the value.
    Let''s call the gateway URL, using curl:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试的第一个是`custom-request-header`，路由已配置为路由到：[http://httpbin.org:80](http://httpbin.org:80)并且路径将是`/headers`。此服务将返回发送到服务器的请求头。看看`addCustomHeader`，我们已配置它向请求添加自定义头。它将以`Book`作为键，以`Spring
    5.0 By Example`作为值。让我们使用curl调用网关URL：
- en: '[PRE20]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output should look like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '![](img/5a229878-be00-48f8-b602-2408154f73f4.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a229878-be00-48f8-b602-2408154f73f4.png)'
- en: Let's analyze the output. The first thing to look at is we have called the localhost
    address. The `Host` key in the Request shows `httpbin.org`, it means the Spring
    Cloud Gateway has changed the address. Awesome, but we expected it. The second
    one is where we have added the `Book` key, and bingo, there it is in the Request
    Headers. The Gateway worked as expected, and with a few lines of code, we did
    some interesting stuff.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析输出。首先要注意的是我们调用了localhost地址。请求中的`Host`键显示为`httpbin.org`，这意味着Spring Cloud
    Gateway已更改了地址。太棒了，但我们预料到了。第二点是添加了`Book`键的地方，bingo，它就在请求头中。网关按预期工作，我们用几行代码做了些有趣的事情。
- en: 'Let''s do one more test. We will test the `combine-and-change`, this route
    is configured to answer the `/anything` with the Request `Header access-key: AAA`,
    so the command line should be:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们再进行一次测试。我们将测试`combine-and-change`，此路由配置为用请求`Header access-key: AAA`回答`/anything`，所以命令行应该是：'
- en: '[PRE21]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see, the `-v` argument makes the call in verbose mode, it is useful
    for debugging purposes and the `-H` indicates the Request Headers. Let''s look
    at the output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`-v`参数使调用以详细模式进行，这对于调试目的很有用，而`-H`表示请求头。让我们看看输出：
- en: '![](img/d56c40a7-0a13-4f87-ac89-69bf9f651202.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d56c40a7-0a13-4f87-ac89-69bf9f651202.png)'
- en: Awesome. If you look at the `access-key` value, the Gateway changed to a requested
    value `BBB`. Good job guys. There are some endpoints to test, feel free to test
    as you want.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。如果你看`access-key`的值，网关已更改为请求的值`BBB`。干得好，大家。有一些端点要测试，请随意测试。
- en: You can find the httpbin documentation at: [https://httpbin.org/](https://httpbin.org/).
    There are some interesting other methods to test HTTP.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下位置找到httpbin文档：[https://httpbin.org/](https://httpbin.org/)。还有一些有趣的HTTP测试方法。
- en: Putting the infrastructure on Docker
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将基础设施放在Docker上
- en: Our infrastructure is ready and it enables us to develop the application. We
    can create a Docker compose file to spin up the infrastructure services; during
    the development life cycle, components such as Eureka, Config Server, Trace Server,
    and API Gateway do not suffer changes because they interact as an infrastructure.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基础设施已经准备好，并使我们能够开发应用程序。我们可以创建一个Docker compose文件来启动基础设施服务；在开发生命周期中，Eureka、配置服务器、跟踪服务器和API网关等组件不会发生变化，因为它们作为基础设施进行交互。
- en: 'Then, it enables us to create component images and use them in the `docker-compose.yaml`
    file. Let''s list our components:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它使我们能够创建组件镜像并在`docker-compose.yaml`文件中使用它们。让我们列出我们的组件：
- en: Config Server
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务器
- en: Eureka
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eureka
- en: Zipkin
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipkin
- en: RabbitMQ
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ
- en: Redis
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: We know how to create Docker images using the Fabric8 Maven plugin, we have
    done this several times in the previous chapters – let's do it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何使用Fabric8 Maven插件创建Docker镜像，我们在前面的章节中已经这样做了几次——让我们来做吧。
- en: 'Let''s configure one as an example, keep in mind we need do the same configuration
    for all projects, Eureka, Gateway, Config Server, and Gateway. The following snippet
    configures the `docker-maven-plugin` to generate a Docker image:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个为例进行配置，记住我们需要对所有项目进行相同的配置，包括Eureka、网关、配置服务器和网关。以下代码片段配置了`docker-maven-plugin`以生成Docker镜像：
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It is a pretty simple configuration. A simple Maven plugin with a couple of
    configurations. Then, after the plugin configuration, we are able to generate
    the Docker image. The command to generate Docker images is:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的配置。一个简单的Maven插件，带有几个配置。然后，在插件配置之后，我们能够生成Docker镜像。生成Docker镜像的命令是：
- en: '[PRE23]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It will generate a Docker image for us.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 它将为我们生成一个Docker镜像。
- en: The projects configured can be found on GitHub; there are so many configurations
    to do as in the previous chapters. We need to configure the `docker-maven-plugin`
    and generate the Docker images.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的项目可以在GitHub上找到；与前面的章节一样，这里有很多配置要做。我们需要配置`docker-maven-plugin`并生成Docker镜像。
- en: Fully configured projects can be found in the chapter seven folder. The GitHub
    repository is: [https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter07.](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter07)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 完全配置的项目可以在第七章文件夹中找到。GitHub仓库是：[https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter07.](https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter07)
- en: 'After the images have been created, we are able to create a Docker compose
    file defining the whole thing. The `docker-compose-infra-full.yaml` file should
    look like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建镜像之后，我们能够创建一个定义整个系统的Docker compose文件。`docker-compose-infra-full.yaml`文件应该看起来像这样：
- en: '[PRE24]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are some interesting things to pay attention to here. It is very important
    that all container instances are attached to the same Docker network called `airline`.
    Pay attention to the ports exposed by the containers, it is important to enable
    service discovery features in Docker.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的有趣事情。非常重要的一点是，所有容器实例都连接到同一个名为`airline`的Docker网络。注意容器暴露的端口，在Docker中启用服务发现功能很重要。
- en: 'Then, we can execute the instruction to spin up the whole infrastructure; it
    can be done using the following command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以执行指令来启动整个基础设施；可以使用以下命令完成：
- en: '[PRE25]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following output should appear:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出应该出现：
- en: '![](img/09f31f0c-c06b-4f64-a449-958fd0af2308.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09f31f0c-c06b-4f64-a449-958fd0af2308.png)'
- en: 'Also, we can execute the following instruction to check the container''s execution:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以执行以下指令来检查容器的执行：
- en: '[PRE26]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It will list the running containers, as shown in the following screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 它将列出正在运行的容器，如下面的截图所示：
- en: '![](img/bdedb2b7-8516-4db5-8d80-9677cb87ca6c.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bdedb2b7-8516-4db5-8d80-9677cb87ca6c.png)'
- en: All applications are up and running. Well done.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序都已启动并运行。做得好。
- en: 'To remove the containers, we can use:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除容器，我们可以使用：
- en: '[PRE27]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It will remove the containers from the stack.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 它将从堆栈中移除容器。
- en: Excellent job, our infrastructure is fully operational in Docker containers.
    It is a base for starting to create our microservices.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好，我们的基础设施在Docker容器中完全运行。它是开始创建我们的微服务的基础。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have built the essential infrastructures services adopting
    the microservices architectural style.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们采用了微服务架构风格构建了基本的基础设施服务。
- en: We have learned how Spring Framework eliminates the infrastructure code from
    our microservices and enables us to create these services, using a couple of annotations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了Spring框架如何从我们的微服务中消除基础设施代码，并使我们能够使用几个注解来创建这些服务。
- en: We understand how it works under the hood; it is extremely important to debug
    and troubleshoot when the application gets some errors in the production stage.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解了其内部的工作原理；当应用程序在生产阶段出现错误时，进行调试和故障排除至关重要。
- en: Now, we are ready to create scalable, fault tolerant, and responsive systems.
    We have built the foundations of our system.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建可扩展、容错和响应式的系统。我们已经为我们系统建立了基础。
- en: In the next chapter, we will start to build our Airline Ticket System, understand
    how to connect the new microservices with the whole infrastructure, and enable
    service discovery and other amazing features.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始构建我们的航空公司票务系统，了解如何将新的微服务与整个基础设施连接起来，并启用服务发现和其他令人惊叹的功能。
- en: See you there.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 那里见。
