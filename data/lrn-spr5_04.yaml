- en: Chapter 4. Aspect Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章。面向切面编程
- en: 'The previous chapter on Spring DAO gives good hands on practice about how Spring
    handles JDBC API with loose coupling. But, we neither talked about JDBC Transactions
    nor about how Spring handles Transactions. If you already handled transactions
    you know the steps for it and more over, you are well aware of these steps which
    are repetitive and spread all over the code. On one hand, we are saying use Spring
    to stop duplication of code and on other hand we are writing such code. Java insist
    to write modules which are highly cohesive. But writing transaction management
    in our code won''t allow us to write cohesive modules. Also the transaction is
    not the motive of writing the code. It just provides support so that the business
    logic of application will not carry out any undesired effect. We haven''t discussed
    about how to handle such supportive functionalities along with the main motive
    of application development. Apart from transaction what else functionalities does
    the work of providing support to application? This chapter will help us in writing
    the highly cohesive modules without repetition of the code to handle such supportive
    functionalities. In this chapter we will discuss the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章关于Spring DAO的内容为我们提供了很好的实践，了解了Spring如何通过松耦合方式处理JDBC API。但是，我们既没有讨论JDBC事务，也没有探讨Spring如何处理事务。如果你已经处理过事务，你了解其步骤，而且更加清楚这些步骤是重复的，并且分散在代码各处。一方面，我们提倡使用Spring来避免代码重复，另一方面，我们却在编写这样的代码。Java强调编写高内聚的模块。但是在我们的代码中编写事务管理将不允许我们编写内聚的模块。此外，编写代码的目的并非是为了事务。它只是提供支持，以确保应用程序的业务逻辑不会产生任何不期望的效果。我们还没有讨论过如何处理这种支持功能以及应用程序开发的主要目的。除了事务之外，还有哪些功能支持应用程序的工作？本章将帮助我们编写没有代码重复的高度内聚的模块，以处理这些支持功能。在本章中，我们将讨论以下几点：
- en: What are cross cutting technologies?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉技术是什么？
- en: What role do the cross cutting technologies play in application development?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉技术在应用程序开发中扮演什么角色？
- en: We will discuss about AOP and how AOP plays an important role in handling cross
    cutting technologies.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将讨论关于面向切面编程（AOP）以及AOP在处理交叉技术中的重要作用。
- en: We will explore in depth what are Aspects, Advices, PointCut in AOP.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将深入探讨AOP中的方面、建议和切点是什么。
- en: The software application provides a reliable solution to a client's problem.
    Though we say reliable, always there is a chance of getting some runtime problems.
    So along with development, the maintenance of the software is also equally important.
    Whenever a problem occurs in application the client gets back to the developers
    for the solution. Unless and until the client is not able to state the accurate
    reason of the problem the developers are helpless. The developers have to recreate
    the same situation in order to prevent it's next occurrence. In enterprise application,
    due to huge number of modules the recreation of the same problem becomes complex.
    It will be great to have someone who keeps on tracking what the user is doing.
    The trace of this tracker helps the developers to know why and what went wrong
    or even using the trace so that they can recreate it easily. Yes, I am talking
    about logging mechanism.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用程序为客户的问题提供了一个可靠的解决方案。尽管我们说它是可靠的，但总是有可能出现一些运行时问题。因此，在开发过程中，软件的维护同样重要。每当应用程序中出现问题时，客户都会回来找开发者寻求解决方案。除非客户能够准确地说明问题的原因，否则开发者是无能为力的。为了防止问题的再次发生，开发者必须重新创建相同的情况。在企业应用程序中，由于模块数量众多，重新创建相同的问题变得复杂。如果有一个人能够持续跟踪用户在做什么，那就太好了。这个跟踪器的跟踪帮助开发者了解出了什么问题，以及如何轻松地重新创建它。是的，我在谈论日志记录机制。
- en: Let's take another very common situation of Railway ticket reservation. At the
    time of ticket reservation we select the available seat from the chart and proceed
    for money transfer. Sometimes money gets transferred successfully as well as the
    ticket gets booked. But unfortunately, sometime due to the time for money transaction,
    delay in form filling or some server side issues may cause problems to transfer
    of money without booking the ticket. The money gets deducted without issue of
    the ticket. The customer will be unhappy and moreover tense for the refund. Such
    situations need to be handled carefully with the help of transaction management
    so that if the ticket is not issued the money should get deposited back into the
    customer's account. Doing it manually will be tedious task instead transaction
    management handles it elegantly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个非常常见的铁路票务预订情况。在票务预订时，我们从图表中选择可用的座位并继续进行资金转账。有时资金成功转账，票也预订了。但不幸的是，有时由于资金交易时间过长，填写表格延迟或一些服务器端问题可能会导致资金转账失败而无法预订票。资金被扣除而没有发行票。客户将不高兴，而且对于退款来说会更加紧张。这种情况需要借助事务管理谨慎处理，以便如果未发行票，资金应退还到客户账户中。手动操作将是繁琐的任务，而事务管理则优雅地处理了这个问题。
- en: We can write the workable code without logging or transaction management, as
    both of these are not part of your business logic. The Java application revolves
    around providing a customized, easy solution for an enterprise problem. The business
    logic is at the centre to provide primary functionality of the application may
    sometime referred as 'primary concern'. But it also has to be supported for some
    other functionalities or services and it can't be neglected. These services play
    vital role in the application. Either the migration of application becomes time
    consuming or backtracking the problem occurred at run time will be difficult.
    These concerns are scattered throughout the application mostly with repetitive
    code. Such secondary concerns are called as 'cross cutting concerns' or sometimes
    also called as 'horizontal concerns'. Logging, transaction management, security
    mechanism are some of the cross cutting concerns which developers use in the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写不包含日志记录或事务管理的可运行代码，因为这两者都不属于您的业务逻辑。Java应用程序的核心是提供一种定制化的、简单的解决方案来解决企业问题。业务逻辑位于中心，提供应用程序的主要功能，有时被称为“主要关注点”。但它还必须支持其他一些功能或服务，这一点不容忽视。这些服务在应用程序中扮演着重要的角色。要么应用程序的迁移会耗时，要么在运行时回溯问题将变得困难。这些关注点大多伴随着重复的代码散布在应用程序中。这些次要关注点被称为“横切关注点”，有时也称为“水平关注点”。日志记录、事务管理和安全机制是开发者在应用程序中使用的横切关注点。
- en: 'The below diagram shows the way cross cutting concerns as logging and transaction
    management are scattered in the application code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了横切关注点（如日志记录和事务管理）如何在应用程序代码中散布：
- en: '![](img/image_04_001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_001.png)'
- en: Aspect Oriented Programming (AOP)
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向切面编程（AOP）
- en: '* * *'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '****'
- en: Similar to Object Oriented Programming, the Aspect Oriented Programming is also
    a style of programming which allows developers to write cohesive code by separating
    cross cutting concern from the business logic code. The AOP concepts have been
    developed by Gregor KicZales and his colleagues. It provides different ways or
    tools to write cross cutting concerns.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向对象编程类似，面向切面编程也是一种编程风格，它允许开发者通过将横切关注点与业务逻辑代码分离来编写连贯的代码。AOP概念是由Gregor KicZales及其同事开发的。它提供了编写横切关注点的不同方法或工具。
- en: AOP to handle Cross cutting concern is written at one place which helps in achieving
    the following benefits,
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在AOP中处理横切关注点，可以在一个地方编写，从而实现以下好处：
- en: Reduction in the duplication of the code to achieve writing clean code.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少代码重复以实现编写整洁的代码。
- en: Helps in writing the loosely coupled modules.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于编写松耦合的模块。
- en: Helps in achieving highly cohesive modules.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于实现高度凝聚的模块。
- en: The developer can concentrate on writing the business logic
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可以专注于编写业务逻辑。
- en: Easy to change or modify the code for new functionalities without touching the
    exiting code.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不更改现有代码的情况下，轻松更改或修改代码以添加新功能。
- en: To understand AOP we must be aware of the following common terminologies without
    which we cannot imagine AOP.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解AOP，我们必须了解以下常见术语，没有它们我们无法想象AOP。
- en: Join Point
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接点
- en: The join points are the points in the application where an aspect can be plugged
    in for some miscellaneous functionality without being the part of the actual business
    logic. Each code has numerous opportunities, which can be treated as join point.
    The class which is the smallest unit in an application has data members, constructors,
    setters and getters, other functional classes. Each of them can be an opportunity
    where the aspect can be applied. Spring supports only methods as join points.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 连接点是应用程序中可以插入方面以执行一些杂项功能的位置，而不会成为实际业务逻辑的一部分。每段代码都有无数的机会，可以被视为连接点。在应用程序中最小的单元类有数据成员、构造函数、设置器和获取器，以及其他功能类。每个都可以是应用方面的机会。Spring只支持方法作为连接点。
- en: Pointcut
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切点（Pointcut）
- en: The join points are the opportunities, but all of them are not considered where
    the aspects can be applied. A pointcut is where the developers decide to apply
    the aspect to perform a specific action for the cross cutting concern. The pointcut
    will be written using the method names, class names, regular expressions to define
    the matching packages, classes, methods where aspects can be applied.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 连接点是应用方面的机会，但并非所有机会都被考虑在内。切点是开发者决定应用方面以对横切关注执行特定动作的地方。切点将使用方法名、类名、正则表达式来定义匹配的包、类、方法，在这些地方可以应用方面。
- en: Advice
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建议
- en: The action taken by the aspect at pointcuts is called as 'advice'. The advice
    has the code which gets executed for the respective cross cutting concern. If
    we consider the method as the join point, the aspect can be applied before or
    after the method gets executed. It is also possible that method has exception
    handling code where the aspect can be plugged. Following are the available advices
    in the Spring framework.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在切点处方面所采取的动作称为“建议”（advice）。建议包含为相应的横切关注点执行的代码。如果我们把方法作为连接点，方面可以在方法执行之前或之后应用，也可能是方法有异常处理代码，方面可以插入其中。以下是Spring框架中可用的建议。
- en: Before
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 前置（Before）
- en: The Before advice contains the implementation which will be applied before the
    business logic method which matches the pointcut expression. It will continue
    with the execution of the method unless the exception is not thrown. The @Before
    annotation or<aop:before> configuration can be applied to a method to support
    Before advice.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前置（Before）建议包含在匹配切点表达式的业务逻辑方法执行之前应用的实现。除非抛出异常，否则将继续执行该方法。可以使用@Before注解或<aop:before>配置来支持前置建议。
- en: After
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 后抛出（After）
- en: In After advice the implementation will be applied after the business logic
    method irrespective of whether the method executed successfully or exception is
    thrown. The @After annotation or<aop:after> configuration can be used to support
    Before advice by applying it to a method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在后置（After）建议中，实现将在业务逻辑方法执行之后应用，无论方法执行成功还是抛出异常。可以使用@After注解或<aop:after>配置来支持后置建议，将其应用于一个方法。
- en: After returning
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 后返回（After returning）
- en: The After Returning advice has the implementation which is applied only after
    the successful execution of the business logic method takes place. The @AfterReturning
    annotation or <aop:after-returning> configuration can be applied to a method to
    support after returning advice. The after returning advice method can use the
    value returned by the business logic method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 后返回（After Returning）建议的实现仅在业务逻辑方法成功执行后应用。可以使用@AfterReturning注解或<aop:after-returning>配置来支持后返回建议。后返回建议方法可以使用业务逻辑方法返回的值。
- en: After throwing
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 后抛出（After throwing）
- en: The After Throwng advice has the implementation which is applied after the execution
    of the business logic method which has thrown an exception. The @AfterThrowing
    annotation or<aop:throwing> configuration can be used to support After throwing
    advice by applying it to a method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 后抛出（After Throwning）建议的实现应用于业务逻辑方法抛出异常之后。可以使用@AfterThrowing注解或<aop:throwing>配置来支持后抛出建议，将其应用于一个方法。
- en: Around
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 环绕（Around）
- en: The Around advice is the most important among all the advices and the only one
    which is applied on a method both before and after the execution of the business
    logic method. It can be used to choose whether to proceed for the next join point
    or not using the invocation of proceed() method of ProceedingJoinPoint. The proceed()
    helps in choosing whether to proceed to the join point or not by returning its
    own returned value. It can be used in scenarios where developers needs to perform
    pre processing, post processing or both. The calculation of how much time taken
    by the method for its execution is one of such scenario. The @Around annotation
    or<aop:around> configuration can be used to support around advice by applying
    it to a method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 环绕通知是所有通知中最重要的一种，也是唯一一种在业务逻辑方法执行前后都会应用的通知。它可用于通过调用ProceedingJoinPoint的proceed()方法来选择是否继续下一个连接点。proceed()通过返回其自身的返回值来帮助选择是否继续到连接点。它可用于开发人员需要执行预处理、后处理或两者的场景。计算方法执行所需时间就是一个这样的场景。可以使用@Around注解或<aop:around>配置通过将其应用于一个方法来支持环绕通知。
- en: Aspect
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Aspect（方面）
- en: An aspect defines the opportunities by the pointcuts expressions and the advices
    to specify when and where the action will be taken. @Aspect annotation or<aop:aspect>
    configuration is applied to a class to declare it as an aspect.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 方面通过切入点表达式和通知来定义机会，以指定动作何时何地被执行。使用@Aspect注解或<aop:aspect>配置将一个类声明为方面。
- en: Introduction
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Introduction（介绍）
- en: The Introduction helps in the declaration of additional methods, fields in the
    existing class without changing the existing code. Spring AOP allows developers
    to introduce a new interface to any class which has been advised by the aspect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍可以帮助在不需要更改现有代码的情况下，在现有类中声明额外的方法和字段。Spring AOP允许开发人员向任何被方面通知的类引入新的接口。
- en: Target object
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Target object（目标对象）
- en: The target objects are the objects of the classes on whom the aspects are applied.
    Spring AOP creates proxy of target object at runtime. The method from the class
    is overridden and the advice will be included to it to get the desired result.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目标对象是被应用了方面的类的对象。Spring AOP在运行时创建目标对象的代理。从类中覆盖方法并将通知包含进去以获得所需结果。
- en: AOP proxy
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AOP proxy（AOP代理）
- en: By default the Spring AOP uses JDK's dynamic proxy to get the proxy of the target
    classes. The use of CGLIB for the proxy creation is also very common. The target
    object is always proxied using Spring AOP proxy mechanism.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring AOP使用JDK的动态代理来获取目标类的代理。使用CGLIB进行代理创建也非常常见。目标对象始终使用Spring AOP代理机制进行代理。
- en: Weaving
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Weaving（编织）
- en: We as developers write business logic and the aspect code in two separate modules.
    Then these two has to be combined as proxied target class. The process of plugging
    the aspect in the business logic code is known as 'weaving'. The weaving can happen
    at compile time, load time or at runtime. Spring AOP does weaving at runtime.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为开发者将业务逻辑和方面代码写在两个分开的模块中。然后这两个模块必须合并为一个被代理的目标类。将方面插入业务逻辑代码的过程称为“编织”。编织可以在编译时、加载时或运行时发生。Spring
    AOP在运行时进行编织。
- en: Let's take a very simple example to understand the discussed terminologies.
    My son loves watching drama. So we had gone to watch one. As we all aware we cannot
    enter unless and until we have entry passes or tickets. Obviously we need to collect
    them first. Once we have the ticket my son dragged me to the seat and showed me
    the seat in excitement. The show started. It was a funny drama for kids. All kids
    were laughing on the jokes, clapping on dialogues, getting excited on the dramatic
    scenes. At interval most of the audience went to take pop corn, snacks and cold
    drinks. Everyone enjoyed the drama and left happily from the exit. Now, we might
    be thinking that we all know this. Why we are discussing this and what is its
    relation to the aspect. Are we not going off the way from the discussion? No,
    we are on the right track. Just wait for a while and you all also will be agreed.
    Here watching the drama was our main task, let's say it's our business logic or
    core concern. Purchasing the tickets, paying the money, entering in the theatre,
    leaving it once the drama is over are the functionalities are the part of the
    core concern. But we cannot just sit quietly, we react on what is going on? We
    clap, laugh and sometimes even cry. But are these main concerns? No! But without
    them we cannot imagine audience watching drama. These will be supportive functionalities
    which each audience does spontaneously. Correct !!! These are the cross cutting
    concerns. The audience won't get instructions for cross cutting concerns individually.
    These reactions are the part of aspects having advices. Some will clap before
    the drama and few after the drama and the most excited whenever they feel. These
    are nothing but before, after or around advices of the aspect. If the audience
    doesn't enjoy the drama they may leave in between similar to after throwing exception.
    On very unfortunate day, the show may get cancelled or even stopped in between
    which needs to be introduced by the organizers as an emergency. Hope you now know
    the concepts as well as their practical approach. We will cover this and many
    more in the demo shortly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个非常简单的例子来理解所讨论的术语。我的儿子喜欢看戏剧。所以我们去看了一场。我们都知道，除非我们有入场券，否则我们不能进入。显然，我们首先需要收集它们。一旦我们有了票，我的儿子把我拉到座位上，兴奋地指给我看。演出开始了。这是一场给孩子们看的有趣戏剧。所有孩子们都在笑笑话，为对话鼓掌，在戏剧场景中感到兴奋。休息时，观众中的大多数人去拿爆米花、小吃和冷饮。每个人都喜欢戏剧，并快乐地从出口离开。现在，我们可能认为我们都知道这些。我们为什么要讨论这个，它与方面有什么关系。我们是不是偏离了讨论的主题？不，我们正在正确的轨道上。再等一会儿，你们所有人也会同意。这里看戏剧是我们的主要任务，让我们说这是我们的业务逻辑或核心关注。购买门票，支付钱，进入剧院，戏剧结束后离开是核心关注的一部分功能。但我们不能安静地坐着，我们对正在发生的事情做出反应？我们鼓掌，笑，有时甚至哭。但这些是主要关注点吗？不！但没有它们，我们无法想象观众看戏剧。这些将是每个观众自发执行的支持功能。正确！！！这些是交叉关注点。观众不会为交叉关注点单独收到指示。这些反应是方面建议的一部分。有些人会在戏剧开始前鼓掌，少数人在戏剧结束后鼓掌，最兴奋的是当他们感到的时候。这只是方面的前置、后置或周围建议。如果观众不喜欢戏剧，他们可能会在中间离开，类似于抛出异常。在非常不幸的日子里，演出可能会被取消，甚至可能在中间停止，需要组织者作为紧急情况介绍。希望现在你知道了这些概念以及它们的实际方法。我们将在演示中简要介绍这些以及更多内容。
- en: Before moving on with the demonstration, let's first off all discuss about some
    of the AOP frameworks in the market as follows.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续演示之前，让我们首先讨论市场上的一些 AOP 框架如下。
- en: AspectJ
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AspectJ
- en: AspectJ is the easy to use and to learn Java compatible framework for integrating
    cross cutting implementations. The AspectJ has been developed at PARC. Now a day,
    it is one of the famous AOP framework due to its simplicity yet has power to support
    component modularization. It can be used to apply AOP on fields which are static
    or non static, constructors, methods which are private, public or protected.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: AspectJ 是一个易于使用和学习的 Java 兼容框架，用于集成跨切实现的交叉。AspectJ 是在 PARC 开发的。如今，由于其简单性，它已成为一个著名的
    AOP 框架，同时具有支持组件模块化的强大功能。它可用于对静态或非静态字段、构造函数、私有、公共或受保护的方法应用 AOP。
- en: AspectWertz
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AspectWertz
- en: AspectWertz is another Java compatible light weight powerful framework. It can
    be used easily to integrate in new as well as existing application. The AspectWertz
    supports both by XML as well as annotation based aspect writing and configuration.
    It supports compile time, load time and runtime weaving. Since AspectJ5, it has
    been merged in AspectJ.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: AspectWertz是另一个与Java兼容的轻量级强大框架。它很容易集成到新旧应用程序中。AspectWertz支持基于XML和注解的方面编写和配置。它支持编译时、加载时和运行时编织。自AspectJ5以来，它已被合并到AspectJ中。
- en: JBoss AOP
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JBoss AOP
- en: The JBoss AOP supports writing of aspects and dynamic proxy target objects.
    It can be used to apply AOP on fields which are static or non static, constructors,
    methods which are private, public or protected using interceptors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JBoss AOP支持编写方面以及动态代理目标对象。它可以用于静态或非静态字段、构造函数、私有、公共或受保护的方法上使用拦截器。
- en: Dynaop
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Dynaop
- en: The Dynaop framework is proxy based AOP framework. The framework helps in reducing
    the dependencies and code reusability.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Dynaop框架是一个基于代理的AOP框架。该框架有助于减少依赖性和代码的可重用性。
- en: CAESAR
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CAESAR
- en: CASER is Java compatible AOP framework. It supports implementation of abstract
    component as well as their integration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CASER是一个与Java兼容的AOP框架。它支持实现抽象组件以及它们的集成。
- en: Spring AOP
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Spring AOP
- en: It is Java compatible easy to use framework which is used to integrate AOP in
    Spring framework. It provides a close integration of AOP implementation in components
    taking advantages of Spring IoC. It is proxy based framework which can be used
    on method execution.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个与Java兼容、易于使用的框架，用于将AOP集成到Spring框架中。它提供了与Spring IoC紧密集成的AOP实现，是基于代理的框架，可用于方法执行。
- en: The Spring AOP fulfills maximum requirements for applying cross cutting concerns.
    But following are few limitations where Spring AOP cannot be applied,
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Spring AOP满足了大部分应用交叉关注点的需求。但以下是一些Spring AOP无法应用的限制，
- en: Spring AOP cannot be applied on fields
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring AOP不能应用于字段。
- en: We cannot apply any other Aspect on one aspect
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法在一个方面上应用任何其他方面。
- en: Private and protected methods can't be advised
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有和受保护的方法不能被建议。
- en: Constructors cannot be advised
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数不能被建议。
- en: 'Spring supports AspectJ and Spring AOP integration to use cross cutting concerns
    with less coding. Both Spring AOP and AspectJ are used for implementation of cross
    cutting technology but following are few points which helps the developers to
    make the best choice to be used in implementation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Spring支持AspectJ和Spring AOP的集成，以减少编码实现交叉关注点。Spring AOP和AspectJ都用于实现交叉技术，但以下几点有助于开发者在实现时做出最佳选择：
- en: Spring AOP is based on dynamic proxy which supports only method join points
    but AspectJ can be applied on fields, constructors even they are private, public
    or protected supporting a fine grained advise.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring AOP基于动态代理，支持方法连接点，但AspectJ可以应用于字段、构造函数，甚至是私有、公共或受保护的，支持细粒度的建议。
- en: Spring AOP cannot be used on method which calls methods of the same class or
    which is static or final but AspectJ can.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring AOP不能用于调用同一类方法的方法、静态方法或最终方法，但AspectJ可以。
- en: AspectJ doesn't need Spring container to manage component while Spring AOP can
    be used only with the components which are managed by Spring container.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AspectJ不需要Spring容器来管理组件，而Spring AOP只能用于由Spring容器管理的组件。
- en: Spring AOP supports runtime weaving based on proxy pattern and AspectJ supports
    compile time weaving which does not required proxy creation. The proxy of the
    objects will be created once the bean is asked by the application.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring AOP支持基于代理模式的运行时编织，而AspectJ支持编译时编织，不需要创建代理。对象的代理将在应用程序请求bean时创建一次。
- en: Aspects written by Spring AOP are Java based components but those written in
    AspectJ are with language which is extension of Java, so the developers need to
    learn it before use.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Spring AOP编写的方面是基于Java的组件，而用AspectJ编写的方面是扩展Java的语言，所以开发者在使用之前需要学习它。
- en: Spring AOP is easy to implement by annotating a class with @Aspect annotation
    or by simple configuration. But to use AspectJ one need to create *.aj files.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring AOP 通过使用@Aspect注解标注类或简单的配置来实现非常简单。但是，要使用AspectJ，则需要创建*.aj文件。
- en: Spring AOP doesn't required any special container but aspects needs as aspects
    created using AspectJ needs to compile using AspectJ compiler.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring AOP不需要任何特殊的容器，但方面需要使用AspectJ编译。
- en: AspectJ is a best choice for the applications which already exists.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AspectJ是现有应用程序的最佳选择。
- en: Note
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A simple class without final, static methods simply use Spring AOP otherwise
    choose AspectJ to write the aspects.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有final，静态方法的简单类，则可以直接使用Spring AOP，否则选择AspectJ来编写切面。
- en: Let's discuss in depth about Spring AOP and its ways of implementations. The
    Spring AOP can be implemented using either XML based aspect configuration or AspectJ
    style annotation based implementation. The XML based configuration can be split
    up at several point making it bit complex. In XML we cannot define named pointcuts.
    But the aspect written by annotations is within the single module which supports
    writing named pointcuts. So, without wasting time let's start the XML based aspect
    development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入讨论Spring AOP及其实现方式。Spring AOP可以通过基于XML的切面配置或AspectJ风格的注解实现。基于XML的配置可以分成几个点，使其变得稍微复杂。在XML中，我们无法定义命名切点。但由注解编写的切面位于单个模块中，支持编写命名切点。所以，不要浪费时间，让我们开始基于XML的切面开发。
- en: XML based aspect configuration
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于XML的切面配置
- en: Following are the steps need to be followed for developing XML based aspect,
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在开发基于XML的切面时需要遵循的步骤，
- en: Select the cross cutting concern to be implemented
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要实现的重叠关注点
- en: Write the aspect to fulfill the requirement of cross cutting concern.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写切面以满足实现重叠关注点的需求。
- en: Register the aspect as a bean in Spring context.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Spring上下文中注册切面作为bean。
- en: 'Write the aspect configuration as:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切面配置写为：
- en: '* Add AOP namespace in XML.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '* 在XML中添加AOP命名空间。'
- en: '* Add aspect configuration which will have pointcut expressions and advises.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '* 添加切面配置，其中将包含切点表达式和建议。'
- en: '* Register the bean on whom the aspect can be applied.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '* 注册可以应用切面的bean。'
- en: From the available join points the developers need to decide which to track
    and then need to write pointcut using expression to target them. To write such
    pointcuts the Spring framework uses AspectJ's pointcut expression language. We
    can write point cuts with the help of following designators in the expression.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员需要从可用的连接点中决定跟踪哪些连接点，然后需要使用表达式编写切点以针对它们。为了编写这样的切点，Spring框架使用AspectJ的切点表达式语言。我们可以在表达式中使用以下设计器来编写切点。
- en: Using method signatures
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用方法签名
- en: 'The method signature can be used to define the pointcuts from the available
    join points. The expression can be written using the following syntax:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用方法签名从可用连接点定义切点。表达式可以使用以下语法编写：
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Java supports private, public, protected and default as method scope but Spring
    AOP supports only public methods while writing the pointcut expressions. The parameter
    list is use to specify what data types will be considered when the method signature
    is matched. Two dots(..) can be used by the developers, if they don't want to
    specify wither number of arguments or their data types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Java支持private，public，protected和default作为方法范围，但Spring AOP只支持公共方法，在编写切点表达式时。参数列表用于指定在匹配方法签名时要考虑的数据类型。如果开发人员不想指定参数数量或其数据类型，可以使用两个点(..)。
- en: 'Let''s consider the following expressions to understand writing of expressions
    in depth to decide which join points will be advised:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下表达式，以深入理解表达式的编写，从而决定哪些连接点将受到建议：
- en: '`expression(* com.packt.ch04.MyClass.*(..)` - specifies all the methods with
    any signature from MyClass within com.packt.cho3 package.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expression(* com.packt.ch04.MyClass.*(..))` - 指定com.packt.cho3包内MyClass的具有任何签名的所有方法。'
- en: '`expression(public int com.packt.ch04.MyClass.*(..)` - specifies all the methods
    returning integer value from MyClass within com.packt.cho3 package.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expression(public int com.packt.ch04.MyClass.*(..))` - 指定com.packt.cho3包内MyClass中返回整数值的所有方法。'
- en: '`expression(public int com.packt.ch04.MyClass.*(int,..)` - specifies all the
    methods returning integer and its first argument of integer type from MyClass
    within com.packt.cho3 package.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expression(public int com.packt.ch04.MyClass.*(int,..))` - 指定返回整数及其第一个整数类型参数的MyClass中所有方法，该类位于com.packt.cho3包内。'
- en: '`expression(* MyClass.*(..)` - specifies all the methods with any signature
    from MyClass will be advised. It''s a very special kind of expression which can
    be used only if the advise and the class belongs to the same package.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expression(* MyClass.*(..))` - 指定所有来自MyClass的具有任何签名的方法都将受到建议。这是一个非常特殊的表达式，只能在与建议的类在同一包中使用。'
- en: Using type
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用类型
- en: 'The type signature is used to match the join point having the specified types.
    We can use the following syntax to specify type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名用于匹配具有指定类型的连接点。我们可以使用以下语法来指定类型：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here the type will be either the package or class name. Following are some
    of the expressions which can be written to specify the join points:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里类型将是包或类名。以下是一些可以编写以指定连接点的表达式：
- en: '`within(com.packt.ch04.*)` - specifies all the methods from all the classes
    belonging to com.packt.ch04 package'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`within(com.packt.ch04.*)` - 指定属于com.packt.ch04包的所有类的所有方法'
- en: '`within(com.packt.ch04..*)` - specifies all the methods from all the classes
    belonging to com.packt.ch04 package and its sub packages. We specified two dots
    instead of one to track the sub packages as well.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`within(com.packt.ch04..*)` - 指定属于com.packt.ch04包及其子包的所有类的所有方法。我们使用了两个点而不是一个点，以便同时跟踪子包。'
- en: '`within(com.packt.ch04.MyClass)` - specifies all the methods from the MyClass
    belonging to com.packt.ch04 package'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`within(com.packt.ch04.MyClass)` - 指定属于com.packt.ch04包的MyClass的所有方法'
- en: '`within(MyInterface+)` - specifies all the methods from all the classes which
    are implementing MyInterface.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`within(MyInterface+)` - 指定实现MyInterface的所有类的所有方法。'
- en: Using Bean name
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Bean名称
- en: 'Spring 2.5 onwards all versions supports use of bean name to be used in expression
    to match the join point. We can use the following syntax:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 2.5及以后的所有版本都支持在表达式中使用bean名称来匹配连接点。我们可以使用以下语法：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Consider the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '`bean(*Component)` - the expression specifies the join points to be match which
    belongs to the bean whose name ends with Component. The expression can''t be used
    with AspectJ annotations.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`bean(*Component)` - 这个表达式指定要匹配的连接点属于名称以Component结尾的bean。这个表达式不能与AspectJ注解一起使用。'
- en: Using this
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用this
- en: '''this'' is used to match the join points where the bean reference is instance
    of the specified type. It is used when the expression specifies name of class
    instead of interface. It used when Spring AOP uses CGLIB for proxy creation.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '''this''用于匹配目标点的bean引用是指定类型的实例。当表达式指定类名而不是接口时使用。当Spring AOP使用CGLIB进行代理创建时使用。'
- en: 5.sing target
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.sing target
- en: The target is used to match the join points where the target object is an interface
    of the specified type. It is used when Spring AOP uses JDK based proxy creation.
    The target is used only if the target object is implementing an interface. The
    developers even can configure property 'proxy target class' set to true.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 目标用于匹配目标对象是指定类型的接口的连接点。当Spring AOP使用基于JDK的代理创建时使用。仅当目标对象实现接口时才使用目标。开发者甚至可以配置属性'proxy
    target class'设置为true。
- en: 'Let''s consider the following example to understand use of this and target
    in expression:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例以了解表达式中使用this和target：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can write the expression to target the methods as:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写表达式来针对方法：
- en: '`target( com.packt.ch04.MyInterface)` or'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`target( com.packt.ch04.MyInterface)` 或'
- en: '`this(com.packt.ch04.MyClass)`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`this(com.packt.ch04.MyClass)`'
- en: For annotation tracking
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用于注解跟踪
- en: The developers can write pointcut expressions which are not tracking the methods
    but to track the annotations applied. Let's take following examples to understand
    how to monitor annotations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以编写不跟踪方法而是跟踪应用于注解的连接点表达式。让我们以下示例了解如何监控注解。
- en: '**Using with execution:**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用with execution:**'
- en: execution(@com.packt.ch03.MyAnnotation) - specifies to target the method or
    class which has been annotated with MyAnnotation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: execution(@com.packt.ch03.MyAnnotation) - 指定被MyAnnotation注解标记的方法或类。
- en: execution(@org.springframework.transaction.annotation.Transactional) - specifies
    to target the method or class which has been annotated with Transactional.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: execution(@org.springframework.transaction.annotation.Transactional) - 指定被Transactional注解标记的方法或类。
- en: '**Using with @target:**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用with @target:**'
- en: It is used to consider the join points where the class has been annotated with
    specified annotation. The following example makes it clear,
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于考虑被特定注解标记的类的连接点。以下示例解释得很清楚，
- en: '@target(com.packt.ch03.MyService) - used to consider the join point which has
    been annotated by MyService annotation.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '@target(com.packt.ch03.MyService) - 用于考虑被MyService注解标记的连接点。'
- en: '**Using @args:**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用@args:**'
- en: The expression is used to specify the join points where the arguments have been
    annotated with the given type.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式用于指定参数被给定类型注解的连接点。
- en: '@args(com.packt.ch04.annotations.MyAnnotation)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '@args(com.packt.ch04.annotations.MyAnnotation)'
- en: The above expression is used to consider the join points whose accepts objects
    annotated by @Myannotation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式用于考虑其接受的对象被@Myannotation注解标记的连接点。
- en: '**Using @within:**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用@within:**'
- en: The expression is used to specify the join points within types which have been
    specified by the given annotation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式用于指定由给定注解指定的类型的连接点。
- en: '@within(org.springframework.stereotype.Repository)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '@within(org.springframework.stereotype.Repository)'
- en: The above expression helps in providing advise to the join points which has
    been annotated by @Repository.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式有助于为被@Repository标记的连接点提供通知。
- en: '**Using @annotation:**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用@annotation:**'
- en: '@annotation is used to match the join points which have been annotated by the
    respective annotation.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '@annotation用于匹配被相应注解标记的连接点。'
- en: '@annotation(com.packt.ch04.annotations.Annotation1)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '@annotation(com.packt.ch04.annotations.Annotation1)'
- en: The expression matches all the join points annotated by Annotation1.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式匹配所有由Annotation1标记的连接点。
- en: Let's use pointcut expressions, advises to implement logging aspect to understand
    the real time implementation. We will use application Ch03_JdbcTemplates developed
    in previous chapter to integrate Log4j in it as a base. In first part we will
    create a copy of the main application and part two integrate it with log4J and
    in third part we will apply the customized logging aspect.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用切点表达式、通知来实现日志方面，以理解实时实现。我们将使用上一章开发的Ch03_JdbcTemplates应用程序作为基础，将其与Log4j集成。第一部分我们将创建一个主应用程序的副本，第二部分将其与log4j集成，第三部分将应用自定义日志方面。
- en: 'Part I : Creating application for the core concern(JDBC)'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分：创建核心关注点（JDBC）的应用程序
- en: '* * *'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '****'
- en: 'Follow the steps to create the base application:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建基础应用程序：
- en: Create a Java applicationCh04_JdbcTemplate_LoggingAspect and add to it jars
    for Spring core, Spring JDBC, spring-aop, aspectjrt-1.5.3 and aspectjweaver-1.5.3.jar
    files.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为Ch04_JdbcTemplate_LoggingAspect的Java应用程序，并添加Spring核心、Spring JDBC、spring-aop、aspectjrt-1.5.3和aspectjweaver-1.5.3.jar文件所需的jar。
- en: 'Copy the required source code files and configuration files in respective packages.
    The final outline of the application is as shown below:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需源代码文件和配置文件复制到相应的包中。应用程序的最终结构如下所示：
- en: '![](img/image_04_002.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_002.png)'
- en: Copy connection_new.xml from Ch03_JdbcTemplates in classpath of the application
    and edit it to remove bean with id as 'namedTemplate'.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Ch03_JdbcTemplates复制connection_new.xml到应用程序的类路径中，并编辑它以删除id为'namedTemplate'的bean。
- en: 'PartII: Integration of Log4J'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分：Log4J的集成
- en: '* * *'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '****'
- en: 'Log4j is the most simple thing to do. Let''s use following steps for the integration:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Log4j是最简单的事情。让我们按照以下步骤进行集成：
- en: To integrate Log4J we first of all have to add log4j-1.2.9.jar in the application.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要集成Log4J，我们首先必须将log4j-1.2.9.jar添加到应用程序中。
- en: 'Add log4j.xml in classpath with the following configuration to add Console
    and File appenders:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类路径下添加以下配置的log4j.xml以添加控制台和文件监听器：
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can modify the configuration as per your requirement.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要修改配置。
- en: 'Now to log the messages we will add the code for getting logger and then logging
    mechanism. We can add the code to BookDAO_JdbcTemplate.java as shown below:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了记录消息，我们将添加获取日志记录器和记录机制的代码。我们可以将代码添加到BookDAO_JdbcTemplate.java，如下所示：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Don't worry we will not add it in our application in each class and then in
    methods as we already discuss the complexity and repetitive code let's move on
    to write aspect for logging mechanism with the help of following steps to get
    the same result as that of the code written above.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，我们不会在每个类和每个方法中添加它，因为我们已经讨论了复杂性和重复代码，让我们继续按照以下步骤编写日志机制方面，以获得与上面编写的代码相同的结果。
- en: 'Part III: Writing Logging aspect.'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三部分：编写日志方面。
- en: '* * *'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '****'
- en: Create MyLoggingAspect as Java class in com.packt.ch04.aspects package which
    will have method for before advise.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch04.aspects包中创建一个名为MyLoggingAspect的Java类，该类将包含一个用于前置通知的方法。
- en: Add a data member of type org.apache.log4j.Logger in it.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加一个类型为org.apache.log4j.Logger的数据成员。
- en: 'Add a method beforeAdvise( )in it. The signature of method can be anything,
    Here we are adding JoinPoint as argument. Using this argument we can get the information
    about the class where aspect is getting applied. The code will be as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加一个beforeAdvise()方法。方法的签名可以是任何东西，我们在这里添加了一个JoinPoint作为参数。使用这个参数，我们可以获取有关方面应用的类的信息。代码如下：
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The aspect now has to be configured in the XML in three steps:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在必须在XML中分三步配置方面：
- en: '*Add namespace for AOP:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*****为AOP添加命名空间：'
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can use AOP''s tags by using ''aop'' namespace:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用AOP的标签，通过使用'aop'命名空间：
- en: '*Add a bean for aspect.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*****添加一个方面bean。'
- en: 'Add the bean for aspect which we want to use in application in connection_new.xml
    as shown below:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在connection_new.xml中添加我们想在应用程序中使用的方面的bean，如下所示：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Configure the Aspect.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 配置切面。
- en: Each <aop:aspect> enables us writing aspect inside <aop:config> tag.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个<aop:aspect>允许我们在<aop:config>标签内编写切面。
- en: Each aspect will have id and ref as attributes. The 'ref' which refers to the
    bean whose methods will be invoked for providing advises.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个切面都将有id和ref属性。'ref'指的是将调用提供建议的方法的bean。
- en: Configure the advise for a pointcut expression and which method to be invoked
    for the advise. The before advise can be configured inside<aop:aspect> using <aop:before>tag.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为切点表达式配置建议，以及要调用的方法。可以在<aop:aspect>内使用<aop:before>标签配置前置建议。
- en: 'Let''s write before advise to apply for ''myLogger'' aspect which will be invoked
    before the addBook() method of BookDAO. The configuration will be as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个适用于'myLogger'切面的前置建议，该建议将在BookDAO的addBook()方法之前调用。配置如下：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Execute MainBookDAO_operation.java to get the following output on console:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行MainBookDAO_operation.java以在控制台获得以下输出：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here BookDAO_JdbTemplate is working as target object whose proxy will be created
    at runtime by weaving the code of addBook() and beforeAdvise() methods. Now once
    we know the process let's add different pointcuts and the advises one by one in
    the application with the help of following steps.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: BookDAO_JdbTemplate作为目标对象运行，其代理将在运行时通过编织addBook()和beforeAdvise()方法代码来创建。现在既然我们知道了过程，让我们逐一在应用程序中添加不同的切点和建议，并按照以下步骤操作。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More than one advises can be applied on the same joinpoint but for simplicity
    to understand the pointcuts and advises, we will keep single advise each time
    and comment already written.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在同一个连接点上应用多个建议，但为了简单地理解切点和建议，我们将每次保留一个建议，并注释掉已经写入的内容。
- en: Adding after advise.
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加返回建议。
- en: Let's add after advise for all the methods from BookDAO.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为BookDAO中的所有方法添加后置建议。
- en: 'Add a method afterAdvise()in MyLoggingAspect for after advise as shown below:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MyLoggingAspect中添加一个后置建议的方法afterAdvise()，如下所示：
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Configure the pointcut expression to target all the methods inside BookDAO
    class and after advise in the connection_new.xml inside ''myLogger'' aspect as
    shown below:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置切点表达式，以目标BookDAO类中的所有方法以及在'myLogger'切面中的connection_new.xml中的后置建议。
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Execute MainBookDAO_operations.java to get following output:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行MainBookDAO_operations.java以获得以下输出：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The underlined statements makes it clear that the advise got invoked after all
    the methods.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线的语句清楚地表明建议在所有方法之后被调用。
- en: Adding after returning advise.
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在返回后添加建议。
- en: Though we written the after advise but we are not able to get the value returned
    from the business logic method. After-returning will help us to get the returned
    value with the help of following steps.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们编写了后置建议，但我们无法得到业务逻辑方法返回的值。后返回将帮助我们在以下步骤中获取返回值。
- en: 'Add a method returnAdvise()in MyLoggingAspect which will get invoked for after
    returning. The code is as shown below:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MyLoggingAspect中添加一个返回建议的方法returnAdvise()，该方法将在返回后调用。代码如下：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The argument 'val' will hold the returned value.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 参数'val'将持有返回值。
- en: 'Configure the advise under ''myLogger''. We don''t have to configure the pointcut
    as we will be reusing alredy configured. In case if you want to use different
    set of join point, first you need to configure a different pointcut expression.
    Our configuration will be as shown below:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在'myLogger'下配置建议。我们不需要配置切点，因为我们将会重用已经配置的。如果你想要使用不同的连接点集，首先你需要配置一个不同的切点表达式。我们的配置如下所示：
- en: '[PRE15]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: where,
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，
- en: '* returning - represents the attribute to specify the name of the parameter
    to which the return value will be passes. In our case this name is ''val'' which
    has bound in advice arguments .'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 返回-表示要指定返回值传递到的参数的名称。在我们这个案例中，这个名称是'val'，它已在建议参数中绑定。
- en: 'To make the output easy to understand comment before and after advise configuration
    and then execute MainBookDAO_operations.java to get following lines on console
    output:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使输出更容易理解，注释掉前置和后置建议配置，然后执行MainBookDAO_operations.java以在控制台输出获得以下行：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Each of the statements shows the value returned from the joinpoint.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语句显示了连接点的返回值。
- en: Adding Around advise.
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加环绕建议。
- en: 'As we already discuss around advise is invoked both before and after the business
    logic method, only if the execution is successful. Let''s add around advise in
    application as:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，环绕建议在业务逻辑方法前后调用，只有当执行成功时。让我们在应用程序中添加环绕建议：
- en: 'Add a method aroundAdvise () in MyLoggingAspect. This method must have one
    of its argument as ProceedingJoinPoint to facilitate the flow of application to
    join point. The code will be as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyLoggingAspect`中添加一个`aroundAdvise()`方法。该方法必须有一个参数是`ProceedingJoinPoint`，以方便应用程序流程到达连接点。代码如下：
- en: '![](img/image_04_003.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_04_003.png)'
- en: The part before proceed() will get invoked before B.L. method which we are referring
    as 'Pre processing'. The ProceedJoinPoint's proceed() method take the flow to
    the respective join point. If the join point executes successfully the part after
    proceed will be executed which we are referring as 'Post processing'. Here we
    are finding time taken to complete the process by taking the difference of time
    at pre processing and post processing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`proceed()`之前的部分将在我们称为'Pre processing'的B.L.方法之前被调用。`ProceedingJoinPoint`的`proceed()`方法将流程导向相应的连接点。如果连接点成功执行，将执行`proceed()`之后的部分，我们称之为'Post
    processing'。在这里，我们通过在'Pre processing'和'Post processing'之间取时间差来计算完成过程所需的时间。
- en: 'The join point where we want to weave the aspect returns int so the aroundAdvise()
    method is also returning value of the same type. If in case we add void instead
    of int we will get the following exception:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要编织切面的连接点返回int，因此aroundAdvise()方法也返回相同类型的值。如果万一我们使用void而不是int，我们将得到以下异常：
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's now add around advise in 'myLogger' as shown below,
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在'myLogger'中添加around advice，如下所示：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Execute the MainBookDAO to the following log on console while commenting the
    advises configured previously,
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注释掉之前配置的advice的同时，在控制台执行`MainBookDAO`以下日志，
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adding after throwing advise
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加after throwing advice
- en: As we know the after throwing advise will be triggered once the matching join
    point will throw an exception. While performing JDBC operation if we try to add
    the duplicate entry in the book table the DuplicateKeyException will be thrown
    we just want to log it with the help of after throwing advise with the help of
    following steps,
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，一旦匹配的连接点抛出异常，after throwing advice将被触发。在执行JDBC操作时，如果我们尝试在book表中添加重复的条目，将抛出DuplicateKeyException，我们只需要使用以下步骤，借助after
    throwing advice进行日志记录：
- en: 'Add the method throwingAdvise() in MyLoggingAspect as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyLoggingAspect`中添加`throwingAdvise()`方法，如下所示：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The developers are free to choose the signature but as the join point method
    is going to throw exception the method written for the advise will have one of
    its argument of type Exception so that we can log it. We also are adding argument
    of type JoinPoint as we want to deal with method signatures
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以自由选择签名，但由于连接点方法将抛出异常，为advice编写的方法将有一个参数是Exception类型，这样我们就可以记录它。我们还在参数中添加了JoinPoint类型，因为我们想要处理方法签名。
- en: 'Add the configuration in the connection_new.xml in ''myLogger'' configuration.
    The configuration to add is:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在'myLogger'配置中的`connection_new.xml`中添加配置。要添加的配置是：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The <aop:after- throwing> will take:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <aop:after-throwing> 将采取：
- en: '* **pointcut-ref** - name of pointcut-ref where we wamt to weave the joinpoints'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '* **pointcut-ref** - 我们想要编织连接点的pointcut-ref的名称。'
- en: '* **method** - name of method which will invoke if the exception is thrown'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '* **method** - 如果抛出异常，将调用的方法名称。'
- en: '* **throwing** - name of the argument to be bound from the advise method signature
    to which the exception will be passes. The name of argument in the method signature
    used by us is ''exception''.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '* **throwing** - 从advise方法签名绑定到的参数名称，异常将被传递给它。我们使用的签名中的参数名称是''exception''。'
- en: 'Execute the MainBookDAO_operations and purposely add the book whose ISBN already
    exists in the Book table. Before execution comment the previous configurations
    added for other advises. We will get the following output:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`MainBookDAO_operations`，并故意添加一个ISBN已存在于Book表中的书籍。在执行前，注释掉为其他advice添加的先前配置。我们将得到以下输出：
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you add book with different ISBN which is not already in book table the above
    log for ERROR will not be displayed as no exception no advise will be triggered.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用不同的ISBN添加书籍，该ISBN不在book表中，上述ERROR日志将不会显示，因为没有异常，也没有advice会被触发。
- en: The above demonstration gives clear picture about how the aspect will be written
    and configured using XML. Let's move on to writing annotation based aspect.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例清楚地展示了如何使用XML编写和配置切面。接下来，让我们来编写基于注解的切面。
- en: Annotation based aspect.
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于注解的切面。
- en: '* * *'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'The aspect can be declared as a Java class annotated with AspectJ annotations
    to support writing of pointcuts and advises. Spring AspectJ OP implementations
    provide following annotations for writing aspect:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 方面可以声明为用AspectJ注解支持的Java类，以支持编写切点和建议。Spring AspectJ OP实现提供了以下注解，用于编写方面：
- en: '**@Aspect** - used to declare a Java class as an Aspect.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Aspect** - 用于将Java类声明为方面。'
- en: '**@Pointcut** - used to declare point cut expression using AspectJ expression
    language.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Pointcut** - 使用AspectJ表达式语言声明切点表达式。'
- en: '**@Before** - used to declare the before advise which is applied before the
    business logic (B.L.) method. @Before supports following attribute,'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Before** - 用于声明在业务逻辑（B.L.）方法之前应用的前置建议。@Before支持以下属性，'
- en: '**value** - name of the method annotated by @Pointcut'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value** - 被@Pointcut注解的方法名称'
- en: '**argNames** - to specify the name of parameters at join point'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**argNames** - 指定连接点处的参数名称'
- en: '**@After** - used to declare the after advise which is applied after the B.L.
    method before returning the result. @After also support same attributes as that
    of @Before advise.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@After** - 用于声明在B.L.方法返回结果之前应用的后建议。@After也支持与@Before建议相同的属性。'
- en: '**@ AfterThrowing** - used to declare the after throwing advise which is applied
    after the exception is thrown by the B.L. method. @ AfterThrowing supports following
    attribute:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@AfterThrowing** - 用于声明在B.L.方法抛出异常之后应用的后抛出建议。@AfterThrowing支持以下属性：'
- en: '**pointcut**- the pointcut expression to select the join point'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pointcut**- 选择连接点的切点表达式'
- en: '**throwing**- the name of the argument which will be bound with exception thrown
    by B.L. method.'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**throwing**- 与B.L.方法抛出的异常绑定在一起的参数名称。'
- en: '**@AfterReturning** - used to declare the after returning advise which is applied
    after the B.L. method but before the result is returned. The advise helps in getting
    the value of the result from B.L method. @AfterReturning supports following attribute,'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@AfterReturning** - 用于声明在B.L.方法返回结果之前但返回结果之后应用的后返回建议。该建议有助于从B.L.方法获取返回结果的值。@AfterReturning支持以下属性，'
- en: '**pointcut**- the pointcut expression to select the join point'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pointcut**- 选择连接点的切点表达式'
- en: '**returning**- the name of the argument bounded with the value returned from
    B.L. method.'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**returning**- 与B.L.方法返回的值绑定的参数名称。'
- en: '**@Around** - used to declare the around advise which is applied before as
    well as after the B.L. method. @Around support same attribute as that of @Before
    or @After advise.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Around** - 用于声明在B.L.方法之前和之后应用的环绕建议。@Around支持与@Before或@After建议相同的属性。'
- en: 'We must declare the configuration in the Spring context to unable proxy creation
    of the bean. The AnnotationAwareAspectJAutoproxyCreatorclass helps in this. We
    can register the class in simple way for @AspectJ support by including the following
    configuration in the XML file:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在Spring上下文中声明配置，以禁用bean的代理创建。AnnotationAwareAspectJAutoproxyCreator类在这方面有帮助。我们可以通过在XML文件中包含以下配置来简单地为@AspectJ支持注册类：
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Adding the namespace 'aop' in XML which already had discussed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML中添加命名空间'aop'，该命名空间已经讨论过。
- en: 'We can follow the following steps to declare and use Annotation based aspect:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下步骤声明和使用基于注解的方面：
- en: Declare a java class and annotate it by @Aspect.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个Java类，并用@Aspect注解它。
- en: Add the method annotated by @Poincut to declare pointcut expression.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加被@Pointcut注解的方法以声明切点表达式。
- en: Add the methods for advises and annotate them by @Before, @After, @Around etc
    as per the requirements.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需求添加建议的方法，并用@Before、@After、@Around等注解它们。
- en: Add the configuration for namespace 'aop'.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为命名空间'aop'添加配置。
- en: Add the aspect in the configuration as a bean.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置中作为bean添加方面。
- en: Unable the auto proxy support in the configuration.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置中禁用自动代理支持。
- en: 'Let''s add the annotation based aspect in the JdbcTemplate application. Follow
    steps of part I and II to create base application named Ch04_JdbcTemplate_LoggingAspect_Annotation.
    You can refer to the Ch04_JdbcTemplate_LoggingAspect application. Now use the
    following steps to develop annotation based logging aspect:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在JdbcTemplate应用程序中添加基于注解的方面。按照第一部分和第二部分步骤创建名为Ch04_JdbcTemplate_LoggingAspect_Annotation的基础应用程序。您可以参考Ch04_JdbcTemplate_LoggingAspect应用程序。现在使用以下步骤开发基于注解的日志方面：
- en: Create class MyLoggingAspect in com.packt.ch04.aspects package.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch04.aspects包中创建MyLoggingAspect类。
- en: Annotate it with @Aspect.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用@Aspect注解它。
- en: Add a data member of type org.apache.log4j.Logger in it.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加类型为org.apache.log4j.Logger的数据成员。
- en: 'Add the method beforeAdvise() for applying advise before the business logic
    method addBook().Annotate it with @Before. The code will be as shown below:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用建议之前的业务逻辑方法addBook()添加beforeAdvise()方法。用@Before注解它。代码如下所示：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Edit connection_new.xml to add 'aop' namespace if you already have not done
    that.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有做过，编辑connection_new.xml以添加'aop'命名空间。
- en: 'Add bean for MyLoggingAspect as shown below:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下的示例中添加MyLoggingAspect的bean：
- en: '[PRE25]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Alternative to the above configuration will annotating the MyLoggingAspect by
    @Component annotation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置的替代方案是通过使用@Component注解来注释MyLoggingAspect。
- en: 'Unable the AspectJ autoproxy by adding the configuration in connection_new.xml
    as:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在connection_new.xml中添加配置来禁用AspectJ自动代理，如下所示：
- en: '[PRE26]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Execute the MainBookDAO-operation.java to get the log on console as:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行MainBookDAO-operation.java以在控制台获取日志：
- en: '[PRE27]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To write the pointcut expression for each advise may be a tedious and unnecessarily
    repetitive task. We can declare the pointcut seperatly in a marker method as shown
    below:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个建议编写切点表达式可能是一个繁琐且不必要的重复任务。我们可以在标记方法中单独声明切点，如下所示：
- en: '[PRE28]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And then refer the above from the advise method. We can update the beforeAdvise
    () method as:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从建议方法中引用上述内容。我们可以将beforeAdvise()方法更新为：
- en: '[PRE29]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we know the basis of Aspect declaration let''s now add the methods for
    other aspect and pointcut as already discussed in aspect declaration using XML.
    The aspect will be as shown below:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们了解了方面声明的基础，接下来让我们为其他方面和切点添加方法，这些已经在方面声明中使用XML讨论过了。方面将如下所示：
- en: '[PRE30]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Execute MainBookDAO.java to get logging messages on console.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行MainBookDAO.java以在控制台获取日志消息。
- en: 'The class is implementing the interface by default JDK''s dynamic proxy mechanism
    will be used for proxy creation. But sometime the target object will not implement
    the interface then JDK''s proxy mechanism will fail. In such cases CGLIB can be
    used to for proxy creation. To unable CGLIB proxies we can write the following
    configuration:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JDK的动态代理机制将用于创建代理。但是有时目标对象没有实现接口，JDK的代理机制将失败。在这种情况下，可以使用CGLIB来创建代理。为了启用CGLIB代理，我们可以编写以下配置：
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also, to force the AspectJ and auto proxy support we can write the following
    configuration:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了强制使用AspectJ和自动代理支持，我们可以编写以下配置：
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Introduction
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入
- en: '* * *'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In enterprise application sometimes the developers come across the situations
    where they need to introduce set of new functionalities but without changing the
    existing code. Using introduction not necessarily all the interface implementations
    needs to be changed as it becomes very complex. Sometimes developers work with
    third party implementations where the source code is unavailable introduction
    plays very important role. The developers may have an option to use decorator
    or adapter design pattern so that the new functionalities can be introduced. But
    method level AOP helps in achieving the introduction of new functionalities without
    writing decorators or adapters.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，有时开发者会遇到需要引入一组新功能，但又不改变现有代码的情况。使用引入不一定需要改变所有的接口实现，因为这会变得非常复杂。有时开发者会与第三方实现合作，而源代码不可用，引入起到了非常重要的作用。开发者可能有使用装饰器或适配器设计模式的选项，以便引入新功能。但是，方法级AOP可以帮助在不编写装饰器或适配器的情况下实现新功能的引入。
- en: The Introduction is an advisor which allows introducing new functionalities
    while handling the cross cutting concerns. Introduce the new implementation the
    developers have to either use <aop:declare-partents> for schema based configuration
    or @DeclareParents if using annotation based implementations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 引入是一种顾问，它允许在处理交叉关注点的同时引入新的功能。开发者必须使用基于架构的配置的<aop:declare-partents>，或者如果使用基于注解的实现，则使用@DeclareParents。
- en: 'Using schema to add introduction the <aop:declare-parent> declares a new parent
    for the bean which is being advised. The configuration will be as:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用架构添加引入时，<aop:declare-parent>为被建议的bean声明一个新的父级。配置如下：
- en: '[PRE33]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Where,
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，
- en: '**types-matching**- specifies the matching type of the been getting advised'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型匹配** - 指定被建议的been的匹配类型'
- en: '**implement** - interface - the newly introduced interface'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现** - 接口 -  newly introduced interface'
- en: '**default-impl** - the class implementing newly introduced interface'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认实现** - 实现新引入接口的类'
- en: 'In case of using annotations the developers can use @DeclareParents which is
    equivalent to the <aop:declare-parents> configuration. @DecalreParents will be
    applied to the property which is the new interface introduced. The syntax of @DeclarePrents
    is as shown below:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用注解的情况下，开发者可以使用@DeclareParents，它相当于<aop:declare-parents>配置。@DeclareParents将应用于新引入的接口的属性。@DeclareParents的语法如下所示：
- en: '[PRE34]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Where,
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里，
- en: '**value**- specifies the bean to be introduced with interface'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value** - 指定要与接口引入的bean'
- en: '**defaultImpl** - is equivalent to default-impl of the <aop:declare-parent>''s
    attribute which specifies the class that provides implementation of the interface'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**defaultImpl** - 与<aop:declare-parent>属性中的default-impl等效，它指定了提供接口实现的类。'
- en: 'Let''s use Introduction in the JdbcTemplate application. The BookDAO doesn''t
    have the method to get description of the book so let''s add it. We will use Ch03_JdbcTemplate
    as the base application. Follow the steps to use introduction:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在JdbcTemplate应用程序中使用介绍。BookDAO没有获取书籍描述的方法，所以让我们添加一个。我们将使用Ch03_JdbcTemplate作为基础应用程序。按照以下步骤使用介绍：
- en: Create a new Java application and name it as Ch04_Introduction.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Java应用程序，并将其命名为Ch04_Introduction。
- en: Add all the jar required for Spring core, Spring -jdbc, Spring AOP as we did
    in earlier applications.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所有Spring核心、Spring -jdbc、Spring AOP所需的jar，正如早期应用程序中所做的那样。
- en: Copy com.packt.ch03.beans package.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制com.packt.ch03.beans包。
- en: Create or copy com.packt.ch03.dao with BookDAO.java and BookDAO_JdbcTemplate.java
    classes.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或复制com.packt.ch03.dao，带有BookDAO.java和BookDAO_JdbcTemplate.java类。
- en: Copy connection_new.xml in classpath and delete the bean having id as 'namedTemplate'.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将connection_new.xml复制到类路径中，并删除id为'namedTemplate'的bean。
- en: 'Create new interface BookDAO_new in com.packt.ch03.dao package as shown below
    to declare getDescription() method:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch03.dao包中创建新的接口BookDAO_new，如下所示，以声明getDescription()方法：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create class BookDAO_new_Impl implementing BookDAO_new interface which will
    deal with JDBC using JdbcTemplate. The code will be as shown below:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建实现BookDAO_new接口的类BookDAO_new_Impl，它将使用JdbcTemplate处理JDBC。代码如下所示：
- en: '[PRE36]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create an aspect class MyIntroductionAspect in com.packt.ch04.aspects package
    which will introduce the new interface to use getDescription() method. The code
    is as shown below:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在com.packt.ch04.aspects包中创建一个方面类MyIntroductionAspect，它将向使用getDescription()方法的新接口介绍。代码如下所示：
- en: '[PRE37]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The annotation provides introduction of BookDAO_new which has additional methods
    than those available in BookDAO interface. The default implementation to be used
    for introduction is BookDAO-new_Impl.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注解提供了BookDAO_new的介绍，它比BookDAO接口中可用的方法多。要用于介绍的默认实现是BookDAO-new_Impl。
- en: 'Register the aspect in connection_new.xml as:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在connection_new.xml中注册方面，如下：
- en: '[PRE38]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Add the following configuration to enable autoproxy,
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下配置以启用自动代理，
- en: '[PRE39]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The proxy-target-class is used to force the proxy to be subclass of our class.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 代理目标类用于强制代理成为我们类的子类。
- en: 'Copy or create MainBookDAO_operation.java to test the code. Use getDescription()
    method to find description of the code. The underline statements in the following
    code are the additional statements to add:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制或创建MainBookDAO_operation.java以测试代码。使用getDescription()方法查找代码描述。以下代码中的下划线语句是需要添加的额外语句：
- en: '[PRE40]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As the BookDAO doesn't have getDescription() in order to use it, we need to
    cast the obtained object to BookDAO_new.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于BookDAO没有getDescription()方法，为了使用它，我们需要将获得的对象转换为BookDAO_new。
- en: 'On execution we will get the output on console as:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行后，我们将在控制台获得以下输出：
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The output clearly show though we are able to introduce the getDescription()
    method without changing BookDAO and its implementations.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示，尽管我们没有改变BookDAO及其实现，就能引入getDescription()方法。
