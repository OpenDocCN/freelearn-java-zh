- en: Chapter 7. Macros in Clojure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。Clojure中的宏
- en: 'In this chapter, we will get to know one of Clojure''s most complicated facilities:
    macros. We will learn what they are for, how to write them, and how to use them.
    It can be a little challenging, but there is good news too. You should be aware
    of some tools from your knowledge of the Java language that can help you understand
    macros better. We will progress little by little with comparisons to other JVM
    languages, and in the end, we will write some macros and understand that we have
    been using them for a while.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解Clojure最复杂的设施之一：宏。我们将学习它们的作用、如何编写它们以及如何使用它们。这可能会有些挑战，但也有一些好消息。你应该意识到一些来自你对Java语言知识的工具，这些工具可以帮助你更好地理解宏。我们将通过与其他JVM语言的比较逐步进行，最终，我们将编写一些宏并理解我们已经使用它们一段时间了。
- en: 'We will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习以下主题：
- en: Understanding Lisp's foundational ideas
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Lisp的基础理念
- en: Macros as code modification tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏作为代码修改工具
- en: Modifying code in Groovy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Groovy中修改代码
- en: Writing your first macro
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的第一个宏
- en: Debugging your first macro
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试你的第一个宏
- en: Macros in the real world
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏在现实世界中的应用
- en: Lisp's foundational ideas
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lisp的基础理念
- en: 'Lisp is a very different beast from what you used to know. According to Paul
    Graham, there are nine ideas that make Lisp different (these ideas have existed
    since the late 1950s), and they are:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp与你以前所知的东西非常不同。根据Paul Graham的说法，有九个想法使Lisp与众不同（这些想法自1950年代末以来一直存在），它们是：
- en: Conditionals (remember, we are talking 1950s–1960s)
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 条件语句（记住，我们谈论的是1950年代至1960年代）
- en: Functions as first-class citizens
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数作为一等公民
- en: Recursion
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归
- en: Dynamic typing
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态类型
- en: Garbage collection
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Programs as sequences of expressions
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序作为表达式序列
- en: The symbol type
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 符号类型
- en: Lisp's syntax
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lisp的语法
- en: 'The whole language is there all the time: at compilation, runtime—always!'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个语言始终都在那里：在编译时，在运行时——始终如此！
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you can, read Paul Graham's essay *Revenge of the Nerds* ([http://www.paulgraham.com/icad.html](http://www.paulgraham.com/icad.html)),
    where he talks about Lisp, what makes it different, and why the language is important.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，阅读Paul Graham的论文《Geeks的复仇》(*Revenge of the Nerds*) ([http://www.paulgraham.com/icad.html](http://www.paulgraham.com/icad.html))，其中他谈论了Lisp，它有什么不同之处，以及为什么这种语言很重要。
- en: These ideas have thrived even after the Lisp age; most of them are common nowadays
    (can you imagine a language without conditionals?). But the last couple of ideas
    are what makes us Lisp lovers love the syntax (we will fully understand what they
    mean through this chapter).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法甚至在Lisp时代之后仍然繁荣发展；其中大多数现在都很常见（你能想象一个没有条件语句的语言吗？）。但最后几个想法正是我们Lisp爱好者喜欢语法的原因（我们将在本章中完全理解它们的含义）。
- en: Common languages are trying to achieve the very same things now with a slightly
    different approach, and you, as a Java developer, have probably seen this.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 常见语言现在正试图以略有不同的方式实现相同的目标，而你作为一个Java开发者，可能已经见过这种情况。
- en: Macros as code modification tools
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏作为代码修改工具
- en: One of the first and most common uses of macros is to be able to modify code;
    they work on the code level, as you will see. Why should we do that? Let's try
    to understand the problem with something that you are more familiar with—Java.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的第一个和最常见的用途之一是能够修改代码；它们在代码级别上工作，正如你将看到的。我们为什么要这样做呢？让我们通过一些你更熟悉的东西来理解这个问题——Java。
- en: Modifying code in Java
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java中修改代码
- en: Have you ever used AspectJ or Spring AOP? Have you ever had problems with tools
    such as ASM or Javassist?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你曾经使用过AspectJ或Spring AOP吗？你曾经遇到过像ASM或Javassist这样的工具的问题吗？
- en: You have probably used code modification in Java. It is common in Java EE applications,
    just not explicit. (Have you ever thought about what the `@Transactional` annotation
    does in Java EE or Spring applications?)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在Java中使用了代码修改。这在Java EE应用程序中很常见，只是不是显式的。（你有没有想过`@Transactional`注解在Java
    EE或Spring应用程序中做什么？）
- en: As developers, we try to automate everything we can, so how could we leave out
    our own devtools?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们试图自动化我们能做的一切，所以我们怎么能忽略我们自己的开发工具呢？
- en: We have tried to create ways to modify the bytecode at runtime so that we don't
    have to remember to open and close resources, or so that we can decouple dependencies
    and get dependency injection.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试创建在运行时修改字节码的方法，这样我们就不必记得打开和关闭资源，或者我们可以解耦依赖关系并获得依赖注入。
- en: 'If you use Spring, you probably know about the following use cases:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Spring，你可能知道以下用例：
- en: The `@Transactional` annotation modifies the annotated method to ensure that
    your code is wrapped in a database transaction
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Transactional`注解修改了被注解的方法，以确保你的代码被数据库事务包裹。'
- en: The `@Autowired` annotation looks for the required bean and injects it into
    the annotated property or method
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Autowired`注解查找所需的bean并将其注入到被注解的属性或方法中'
- en: The `@Value` annotation looks for a configuration value and then injects it
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Value`注解查找配置值并将其注入'
- en: You could probably think of several other annotations that modify the way your
    classes work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想到其他几个修改类工作方式的注解。
- en: The important thing here is that you understand why we want to modify code,
    and you probably already know a few mechanisms for doing it, including AspectJ
    and Spring AOP.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是你要理解我们为什么要修改代码，你可能已经知道一些修改代码的机制，包括AspectJ和Spring AOP。
- en: 'Let''s take a look at how it is done in the Java world; this is what an aspect
    in Java looks like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在Java世界中是如何做到的；这是一个Java中方面（aspect）的样子：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Aspects have the advantage that you can modify any code you like without having
    to touch it. This also has its drawbacks since you could modify the code in ways
    the original author didn't expect and thus cause bugs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 面积（aspect）的优点是你可以修改任何你喜欢的代码，而不必触及它。这也存在一些缺点，因为你可以以原始作者没有预料到的方式修改代码，从而引发错误。
- en: Another drawback is that you have an extremely limited field of action; you
    can wrap your modifications around some code or execute something before or after.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是你有一个极其有限的行动范围；你可以在某些代码周围包装你的修改或在之前或之后执行某些操作。
- en: The libraries that generate this code are extremely complex and they can either
    create a proxy around your objects or modify the bytecode, at runtime or compile
    time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 生成这种代码的库非常复杂，它们可以在运行时或编译时创建围绕你的对象的代理或修改字节码。
- en: As you can imagine, there are lots of things that you must be aware of, and
    anything could go wrong. Hence, debugging could prove complicated.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，有许多你必须注意的事情，任何事都可能出错。因此，调试可能会变得复杂。
- en: Modifying code in Groovy
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Groovy中修改代码
- en: Groovy has gone further down the road and it provides us with more solutions
    and more macro-like features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy已经走得更远，它为我们提供了更多解决方案和更多宏（macro）功能。
- en: Since Groovy 1.8, we have got a lot of AST transformations. What does AST stand
    for? It stands for **abstract syntax tree**—sounds complicated, right?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Groovy 1.8以来，我们得到了很多AST转换。AST代表什么？它代表**抽象语法树**——听起来很复杂，对吧？
- en: Before explaining it all, let's check what some of them do.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释这一切之前，让我们看看它们中的一些功能。
- en: The @ToString annotation
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@ToString注解'
- en: The `@ToString` annotation generates a simple `toString` method that includes
    information about the class of the object and the value of its properties.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ToString`注解生成一个简单的`toString`方法，其中包含关于对象类及其属性值的信息。'
- en: The @TupleConstructor annotation
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@TupleConstructor注解'
- en: 'The `@TupleConstructor` creates a constructor that is able to take all of the
    values of your class at once. Here is an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`@TupleConstructor`创建了一个构造函数，能够一次性接受你类中的所有值。以下是一个示例：'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The @Slf4j annotation
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Slf4j注解'
- en: 'The `@Slf4j` annotation adds an instance of a logger, called log by default,
    to your class, so you can do this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Slf4j`注解将一个名为log的logger实例添加到你的类中，因此你可以这样做：'
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This can be done without having to manually declare the log instance, the class
    name, and so on. There are lots of other things that you can do with this type
    of annotation, but how do they work?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以做到而不需要手动声明日志实例、类名等。你可以用这种类型的注解做很多事情，但它们是如何工作的呢？
- en: Now, what is AST and what does it have to do with Clojure macros? Come to think
    of it, it actually has a lot to do with them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，什么是AST，它与Clojure宏有什么关系？想想看，它实际上与它们有很大关系。
- en: To answer that last question, you'll have to understand a little bit about how
    compilers work.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答最后一个问题，你必须稍微了解一些编译器的工作原理。
- en: We all know that machines (your machine, the JVM, the Erlang BEAM machine) are
    not capable of understanding human code, so we need a process to convert whatever
    developers write into what machines understand.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道机器（你的机器、JVM、Erlang BEAM机器）无法理解人类代码，因此我们需要一个过程将开发者编写的内容转换为机器能理解的内容。
- en: 'One of the most important steps of the process is to create a syntax tree,
    something similar to the following figure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 过程中最重要的步骤之一是创建一个语法树，类似于以下图示：
- en: '![The @Slf4j annotation](img/00025.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![@Slf4j注解](img/00025.jpeg)'
- en: 'This is a very simple example of the following expression:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个以下表达式的非常简单的例子：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This tree is what we call the abstract syntax tree. Let''s see the tree of
    something that''s a bit more complicated, such as this piece of code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这棵树就是我们所说的抽象语法树。让我们看看比这更复杂的代码片段的树，如下所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Thus, the tree will look like the following figure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，树将看起来如下所示：
- en: '![The @Slf4j annotation](img/00026.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![The @Slf4j annotation](img/00026.jpeg)'
- en: As you can see, the figure is still pretty straightforward, and you can probably
    understand how someone would execute code from a structure like this one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个图示仍然相当直观，您可能已经理解了如何从这样的结构中执行代码。
- en: Groovy's AST transformation is a way to meddle with such generated code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy的AST转换是一种干预这种生成代码的方法。
- en: As you can imagine, this is a much more powerful approach, but you are now messing
    with what the compiler generated; the probable downside to this is the complexity
    of the code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，这是一个更强大的方法，但现在您正在干预编译器生成的代码；这种方法的可能缺点是代码的复杂性。
- en: 'Let''s check, for instance, the code of the `@Slf4j` AST. It should be pretty
    simple, right? It just adds a log property:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们检查`@Slf4j` AST的代码。它应该相当简单，对吧？它只是添加了一个日志属性：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can check the complete code at [https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java](https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java),
    and it's also included with the code bundle of this chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java](https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/LogASTTransformation.java)查看完整的代码，它也包含在本章的代码包中。
- en: This doesn't look simple at all. It is just a fragment and still looks very
    complicated. What happens here is that you have to deal with the Java bytecode
    format and with compiler complications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来一点也不简单。它只是一个片段，看起来仍然非常复杂。这里发生的事情是，您必须处理Java字节码格式和编译器复杂性。
- en: Here, we should remember point number 8that Paul Graham made about the syntax
    of Lisp.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们应该记住保罗·格雷厄姆关于Lisp语法的第8点。
- en: 'Let''s write our last code example in Clojure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Clojure中编写最后一个代码示例：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s something peculiar about this piece of code: it feels very similar
    to the AST! This is not a coincidence. Actually, in Clojure and Lisp, you are
    directly writing the AST. This is one of the features that make Lisp a very simple
    language; you directly write what the computer understands. This might help you
    understand a little more about why code is data and data is code.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有点特别：它感觉非常类似于AST！这不是巧合。实际上，在Clojure和Lisp中，您直接编写AST。这是使Lisp成为非常简单语言的一个特性；您直接编写计算机能理解的内容。这可能会帮助您更好地理解为什么代码是数据，数据是代码。
- en: Imagine if you could modify the AST the same way that you modify any other data
    structure in your programs. But you can, and that's what macros are for!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您能够像修改程序中的任何其他数据结构一样修改AST。但是您可以，这正是宏的作用！
- en: Writing your first macro
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个宏
- en: Now that you have a clear understanding of how macros work and what they are
    for, let's start working with Clojure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经清楚地理解了宏的工作原理及其用途，让我们开始使用Clojure。
- en: 'Let me present you with a challenge: write an `unless` function in Clojure,
    something that works like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给您出一个挑战：在Clojure中编写一个`unless`函数，它的工作方式如下：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s give it a first try; maybe with something like the following syntax:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试；也许可以用以下语法：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Do you know what would happen if you wrote this code and then ran it? If you
    test it, you will get the following result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道如果您编写了这段代码然后运行它会发生什么吗？如果您测试它，您将得到以下结果：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What''s happening here? Let''s modify it a bit so that we get a value and we
    can understand what''s happening. Let''s define it a bit differently, and let''s
    return a value so that we see something different:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？让我们稍作修改，以便我们得到一个值并理解正在发生的事情。让我们以不同的方式定义它，并让它返回一个值，以便我们看到一些不同：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will get the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What's going on here?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？
- en: When you pass parameters to a function, everything is evaluated before the actual
    code of the function runs, so over here, before the body of your function runs,
    you execute both of the `println` methods. After that, the `if` runs correctly
    and you get `:bigger`, but we still got an output for the positive and negative
    cases of our `if`. It looks like our code is not working!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向函数传递参数时，在函数的实际代码运行之前，所有内容都会被评估，所以在这里，在你函数的主体运行之前，你执行了两个`println`方法。之后，`if`运行正确，你得到了`:bigger`，但我们仍然得到了`if`的正负情况输出。看起来我们的代码没有工作！
- en: 'How can we fix this? With our current tools, we probably need to write closures
    and change the `my-if` code to accept functions as parameters:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？用我们当前的工具，我们可能需要编写闭包并将`my-if`代码更改为接受函数作为参数：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This works, but there are several disadvantages:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效，但有几个缺点：
- en: There are a lot of constraints now for the code (both clauses should now be
    functions)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在代码有很多限制（两个子句现在都应该作为函数）
- en: It doesn't work for every single case
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这并不适用于每个单独的情况
- en: It is very complicated
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这非常复杂
- en: 'In order to solve this problem, Clojure gives us macros. Let''s have a look
    at how they work:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Clojure给了我们宏。让我们看看它们是如何工作的：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output will be this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是这样的：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is great! It works, but what just happened? Why did we just use a macro
    and why did it work?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！它有效，但发生了什么？为什么我们使用了宏，为什么它有效？
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Macros are not normal Clojure functions; they are supposed to generate code
    and should return a Clojure form. This means that they should return a list that
    we can use as normal Clojure code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 宏不是正常的Clojure函数；它们应该生成代码，并应该返回一个Clojure形式。这意味着它们应该返回一个我们可以用作正常Clojure代码的列表。
- en: 'Macros return code that will be executed later. And here is where point number
    nine of Paul Graham''s list comes into play: you have all of the language all
    the time.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 宏返回将在以后执行的代码。这就是保罗·格雷厄姆列表中的第九点发挥作用的地方：你始终拥有整个语言。
- en: In C++, you have a mechanism called a macro; when you use it, you have a very
    limited set of things that you can do compared to actual C++ code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，你有一个称为宏的机制；当你使用它时，与实际的C++代码相比，你可以做的操作非常有限。
- en: In Clojure, you can manipulate the Clojure code any way you want, and you can
    use the full language here too! Since Clojure code is data, manipulating the code
    is as easy as manipulating any other data structure.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，你可以按任何你想要的方式操作Clojure代码，你在这里也可以使用完整的语言！由于Clojure代码是数据，操作代码就像操作任何其他数据结构一样简单。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Macros are run at compile time, which means that at the time of running the
    code, there is no trace of macros; every macro call is replaced with the generated
    code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 宏在编译时运行，这意味着在运行代码时，宏的痕迹已经消失；每个宏调用都被替换为生成的代码。
- en: Debugging your first macro
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试你的第一个宏
- en: 'Now, as you can imagine, since things can get complicated when using macros,
    there should be some way to debug them. We have two functions to accomplish that:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你可以想象的那样，由于使用宏时事情可能会变得复杂，应该有一种方法可以调试它们。我们有两个函数来完成这个任务：
- en: '`macroexpand`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`macroexpand`'
- en: '`macroexpand-1`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`macroexpand-1`'
- en: The difference between them has to do with recursive macros. There is no rule
    telling you that you can't use a macro from a macro (the whole language is there
    all the time, remember?). If you wish to go all the way through any macro, you
    can use `macroexpand`; if you wish to go a single step forward, you can use `macroexpand-1`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的区别与递归宏有关。没有规则告诉你你不能在宏中使用宏（整个语言始终都在那里，记得？）。如果你想完全遍历任何宏，你可以使用`macroexpand`；如果你想向前迈出一小步，你可以使用`macroexpand-1`。
- en: Both of them show you the code generated by a macro call; this is what happens
    when you compile your Clojure code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都显示了宏调用生成的代码；这就是当你编译Clojure代码时发生的事情。
- en: 'Give this a try:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这个：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is not much more to macros than this; you now understand them to a good
    level of detail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 宏没有比这更多的内容；你现在对它们有了很好的理解。
- en: There are, however, many common problems that you will come across and tools
    for solving them that you should know about. Let's have a look.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你将遇到许多常见问题，以及解决这些问题的工具，你应该了解。让我们看看。
- en: Quote, syntax quote, and unquoting
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用、语法引用和非引用
- en: 'As you can see, the `my-if` macro uses a quote in it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`my-if`宏中使用了引用：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This happens because you need the `if` symbol as the first element in the resulting
    form.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为你需要`if`符号作为结果形式的第一个元素。
- en: Quoting is very common in macros, since we need to build code instead of evaluating
    it on the fly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 引号在宏中非常常见，因为我们需要构建代码而不是即时评估它。
- en: 'There is another type of quoting very common in macros—syntax quoting—that
    makes it easier to write code similar to the final code you want to generate.
    Let''s change the implementation of our macro to this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏中非常常见的一种引号类型——语法引号——使得编写与最终生成的代码类似的代码变得更加容易。让我们将我们的宏实现改为如下：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's see what happens here. For one,`(if test positive negative)` looks much
    more beautiful than the `list` function we had before, but the code generated
    with `macroexpand-1` looks pretty strange. What happened?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里会发生什么。首先，`(if test positive negative)`看起来比我们之前的`list`函数更美观，但使用`macroexpand-1`生成的代码看起来相当奇怪。发生了什么？
- en: We just used a different form of quoting that allows us to quote full expressions.
    It does some interesting things. As you can see, it changes the parameters to
    fully qualified `var` names (`clojure.core/test`, `user/positive`, `user/negative`).
    This is something that you'll be grateful for in the future, but you don't need
    this for now.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用了一种不同的引号形式，允许我们引用完整的表达式。它做了一些有趣的事情。正如你所见，它将参数更改为完全限定的`var`名称（`clojure.core/test`，`user/positive`，`user/negative`）。这是你将来会感激的事情，但现在你不需要它。
- en: What you need are the values of test, positive, and negative. How can you get
    them in this macro?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的是test、positive和negative的值。你如何在宏中获取它们？
- en: 'Using syntax quotes, you can ask for something to be evaluated inline with
    the unquote operator, like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法引号，你可以使用unquote操作符来请求对某些内容进行内联评估，如下所示：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s try our macro expansion again and see what we get:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试宏展开，看看我们会得到什么：
- en: '![Quote, syntax quote, and unquoting](img/00027.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Quote, syntax quote, and unquoting](img/00027.jpeg)'
- en: Unquote splicing
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unquote splicing
- en: There are some other cases that become common in macros. Let's imagine we want
    to reimplement the `>` function as a macro and retain the ability to compare several
    numbers; what would that look like?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏中还有一些其他情况变得很常见。让我们想象一下，我们想要重新实现`>`函数作为宏，并保留比较多个数字的能力；那会是什么样子？
- en: 'Maybe a first attempt could be something like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的第一次尝试可能是这样的：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![Unquote splicing](img/00028.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Unquote splicing](img/00028.jpeg)'
- en: Do you see the problem here?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到问题了吗？
- en: The problem is that we are trying to pass a list of values to `clojure.core/>`
    instead of passing the values themselves.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们试图将一个值列表传递给`clojure.core/>`，而不是传递这些值本身。
- en: This is easily solved with something called **unquote splicing**. Unquote splicing
    takes a vector or list of parameters and expands it as if you had used the `as`
    parameter on a function or macro.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一种叫做**unquote splicing**的方法轻松解决。Unquote splicing接受一个向量或参数列表，并像使用函数或宏上的`as`参数一样展开它。
- en: 'It works like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这样工作的：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![Unquote splicing](img/00029.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Unquote splicing](img/00029.jpeg)'
- en: You will use unquote splicing almost every time you have a variable number of
    arguments to a macro.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎每次在宏的参数数量可变时都会使用unquote splicing。
- en: gensym
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gensym
- en: Generating code can be troublesome, and we end up discovering common issues.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 生成代码可能会有麻烦，我们最终会发现一些常见问题。
- en: 'See if you can find the issue in the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能在以下代码中找到问题：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is a common issue when generating code. You overwrite another value, Clojure
    doesn''t even let you run this, and it displays something like the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在生成代码时常见的问题。你覆盖了另一个值，Clojure甚至不允许你运行这个，并显示如下截图：
- en: '![gensym](img/00030.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![gensym](img/00030.jpeg)'
- en: 'But don''t worry; there''s another way in which you can make sure you are not
    messing with your environment, which is the `gensym` function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心；还有另一种确保你没有破坏你的环境的方法，那就是`gensym`函数：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `gensym` function creates a new `var-name` each time the macro is run,
    which guarantees that there is no other `var-name` that it obscures. If you try
    the macro expansion now, you will get this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`gensym`函数在宏每次运行时都会创建一个新的`var-name`，这保证了没有其他`var-name`会被它遮蔽。如果你现在尝试宏展开，你会得到如下结果：'
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot is the result of the preceding code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是前面代码的结果：
- en: '![gensym](img/00031.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![gensym](img/00031.jpeg)'
- en: Macros in the real world
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际世界的宏
- en: 'Do you want to know when it is that macros are used extensively? Think about
    `defn`; what''s more, do this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道宏被广泛使用的时候吗？想想`defn`；更重要的是，这样做：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Did you know that `defn` is a macro in `clojure.core` that creates a function
    and binds it to a `var` in the current namespace?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗，`defn` 是 `clojure.core` 中的一个宏，它创建一个函数并将其绑定到当前命名空间中的 `var` 吗？
- en: Clojure is filled with macros; if you want some samples, you can look at Clojure
    core, but what else can you do with macros?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 中充满了宏；如果你想看看一些示例，你可以查看 Clojure 核心库，但宏还能做什么呢？
- en: 'Let''s have a look at some interesting libraries:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些有趣的库：
- en: '`yesql`: The `yesql` library is a very interesting sample of code generation.
    It reads SQL code from a SQL file and generates the Clojure functions accordingly.
    Look for the `defquery` and `defqueries` macros in the `yesql` project on GitHub;
    it can be very enlightening.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yesql`：`yesql` 库是代码生成的一个非常有趣的示例。它从 SQL 文件中读取 SQL 代码并相应地生成 Clojure 函数。在 GitHub
    上的 `yesql` 项目中寻找 `defquery` 和 `defqueries` 宏；这可能会非常有启发性。'
- en: '`core.async`: If you are familiar with the `go` language and `goroutines`,
    you would probably like to have that same functionality in the Clojure language.
    This isn''t necessary since you could have provided them yourself! The `core.async`
    library is just `goroutines` for Clojure, and it is provided as a library (no
    obscure language change is needed). This shows a great example of the power of
    macros.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core.async`：如果你熟悉 `go` 语言和 `goroutines`，你可能希望在 Clojure 语言中也有相同的功能。这并不是必要的，因为你完全可以自己提供它们！`core.async`
    库就是 Clojure 中的 `goroutines`，它作为一个库提供（不需要进行神秘的语言更改）。这是一个宏强大功能的绝佳示例。'
- en: '`core.typed`: With macros, you can even change the dynamic nature of Lisp.
    The `core.typed` library is an effort that allows you to define type constraints
    for your Clojure code; macros are extensively used here to generate boilerplate
    code and checks. This is probably much more complex.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core.typed`：使用宏，你甚至可以改变 Lisp 的动态特性。`core.typed` 库是一个允许你为 Clojure 代码定义类型约束的努力；在这里宏被广泛使用以生成样板代码和检查。这可能是更复杂的。'
- en: References
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'If you need further references, you can look at the following list. There are
    entire books committed to the topic of macros. I recommend two in particular:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要进一步参考，你可以查看以下列表。有整本书致力于宏这个主题。我特别推荐两本：
- en: Mastering Clojure Macros ([https://pragprog.com/book/cjclojure/](https://pragprog.com/book/cjclojure/)).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 Clojure 宏 ([https://pragprog.com/book/cjclojure/](https://pragprog.com/book/cjclojure/))。
- en: Let over Lambda ([http://letoverlambda.com/](http://letoverlambda.com/)).It
    talks about common Lisp, but the knowledge is very valuable.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Let over Lambda ([http://letoverlambda.com/](http://letoverlambda.com/)). 它讨论了
    Common Lisp，但知识非常宝贵。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You now understand the power of macros and have a very strong grasp of how they
    work, but we just touched the tip of the iceberg when it comes to macros.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经理解了宏的强大功能，并且对它们的工作方式有了非常强的掌握，但当我们谈到宏时，我们只是触及了冰山一角。
- en: 'In this chapter, we learned about the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了以下内容：
- en: Fundamentals of how macros work
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏的工作原理基础
- en: Modifying your code in Groovy
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Groovy中修改你的代码
- en: The relation of macros to other tools in the Java world
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏与 Java 世界中其他工具的关系
- en: Writing your own macros
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的宏
- en: I am sure you've enjoyed working with Clojure so far, and moving forward, I'd
    recommend you to keep reading and exploring this amazing language.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你到目前为止已经享受了与 Clojure 一起工作的过程，并且向前看，我建议你继续阅读和探索这个令人惊叹的语言。
