- en: Introduction to the Actor Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actor模型简介
- en: In the previous chapter, we the discussed patterns and techniques of advanced
    functional programming in modern programming languages. However, you may have
    noticed that we were always dealing with cases of sequential programming. The
    closest that we have ever gotten to real parallelism was when we discussed the
    Applicative type class.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了现代编程语言中高级函数式编程的模式和技术。然而，你可能已经注意到，我们总是处理顺序编程的情况。我们离真正的并行性最近的一次是在讨论Applicative类型类时。
- en: 'In this chapter, we will go deeper into the topic of modern functional solutions
    for parallelism. The following are the topics that we will be covering in this
    chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨现代并行性的功能性解决方案。以下是我们将在本章中涉及的主题：
- en: Overview of parallelism solutions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行性解决方案概述
- en: Traditional model synchronization on monitors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统模型在监视器上的同步
- en: The actor model as a replacement for the traditional model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为传统模型的替代的actor模型
- en: Overview of parallelism solutions
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行性解决方案概述
- en: If you remember, the Applicative type class gives us an abstraction to define
    parallel computations. It was set against the `Monad` class, which is an abstraction
    to define sequential computational.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，Applicative类型类为我们提供了一个定义并行计算的抽象。它与`Monad`类相对立，后者是定义顺序计算的抽象。
- en: In the *Type Classes* section in [Chapter 8](baec5eab-0c98-4407-8f73-9a1a2b9726c4.xhtml),
    *Basic Type Classes and Their Usage*, we reasoned that Applicatives are needed
    to provide you with a primitive to define independent computational. Parallelism
    can also be modeled by the Applicative. However, it is precisely the idea of independence
    for motivating force behind this type class.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](baec5eab-0c98-4407-8f73-9a1a2b9726c4.xhtml)的*类型类*部分，*基本类型类及其用法*中，我们推理出需要Applicatives来提供一个原始定义独立计算的机制。并行性也可以通过Applicative来建模。然而，正是这种独立性的理念是这个类型类背后的推动力。
- en: Parallelism and concurrency require a different approach. They give rise to
    problems that are not normally encountered in sequential programming, and these
    problems have their own techniques so that they can be solved in object-oriented
    programming. However, these techniques are even more error-prone and hard to reason
    about than regular object-oriented and imperative programming. Hence, a bunch
    of other techniques were devised in order to simplify the process of developing
    concurrent software.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 并行性和并发性需要不同的方法。它们引发了在顺序编程中通常不会遇到的问题，并且这些问题有它们自己的技术，以便可以在面向对象编程中解决。然而，这些技术比常规的面向对象和命令式编程更容易出错，也更难以推理。因此，设计了一系列其他技术来简化并发软件的开发过程。
- en: So far, we still cannot say that we have an ideal approach to parallel and concurrent
    programming. Whenever concurrency is involved, programming gets much more difficult
    than in a single-threaded case, even in the case of the use of the most modern
    techniques and approaches. Modern systems tend to be distributed, and there is
    a high demand on the scalability of such systems. This means that in the modern
    world, it is often the case that a single application must run on several machines
    that can be located in different parts of the world. Also, there is a requirement
    on the scalability of such systems. Scalability means that whenever you add extra
    processing power, such as extra machines to the cluster, the existing program
    must run seamlessly on these new machines without you needing to write extra programming
    code. Basically, scalability means that software must run on any number of machines
    as well as it does on a single machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仍然不能说我们已经找到了并行和并发编程的理想方法。每当涉及到并发时，编程比单线程情况下的编程要困难得多，即使在使用最现代的技术和方法的情况下。现代系统往往是分布式的，对这类系统的可扩展性有很高的要求。这意味着在现代世界中，一个应用程序通常必须在多个机器上运行，这些机器可能位于世界的不同部分。此外，对这类系统的可扩展性也有要求。可扩展性意味着，无论何时添加额外的处理能力，例如将额外的机器添加到集群中，现有的程序都必须在这些新机器上无缝运行，而无需你编写额外的编程代码。基本上，可扩展性意味着软件必须在任何数量的机器上运行得和单台机器上一样好。
- en: Obviously, in such scenarios, chaos is inevitable. So far, we do not have a
    single solution to the issues that arise in the context of distributed fault-tolerant
    and highly available systems. Attempts were made to create approaches and mathematical
    theories that address this issue in the 20^(th) century. Here, we are talking
    primarily about a class of mathematical theories called process calculi. Process
    calculi is a set of mathematical theories that are precisely aimed to describe
    processes that happen concurrently with the help of mathematical logic and mathematical
    laws. Some notable examples of process calculi include **Algebra of Communicating
    Processes** (**ACP**), which has an implementation in Scala called SubScript (see
    [subscript-lang.org](http://subscript-lang.org/)), pi-calculus, **Calculus of
    Communicating Systems** (**CCS**). Attempts were made to implement these theories
    in practice. However, today, we cannot say that any given theory addresses the
    entire range of problems faced by modern programmers in-depth and with convenience.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在这种情况下，混乱是不可避免的。到目前为止，我们还没有一个单一的解决方案来解决分布式容错和高可用系统上下文中出现的问题。在20世纪，人们试图创造方法和数学理论来解决这一问题。在这里，我们主要谈论的是一类称为进程演算的数学理论。进程演算是精确针对使用数学逻辑和数学定律描述并发发生的进程的一组数学理论。进程演算的一些著名例子包括**通信进程代数**（**ACP**），它在Scala中有SubScript的实现（见[subscript-lang.org](http://subscript-lang.org/)），pi-演算，**通信系统演算**（**CCS**）。人们试图将这些理论付诸实践。然而，今天，我们无法说任何给定的理论都能深入且方便地解决现代程序员面临的整个问题范围。
- en: Also, in recent years, a range of engineering approaches have been developed
    specifically for the development of concurrent and parallel applications. One
    such approach is reactive programming. This approach is mostly based on engineering
    your application in terms of streams, data sources, and sinks. This kind of approach
    can be very useful in the context of an application that is heavy on data flow,
    which means that there is a large volume of data that is constantly moving from
    one part of an application to another.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，近年来，已经开发了一系列专门针对并发和并行应用程序开发的工程方法。其中一种方法就是响应式编程。这种方法主要基于以流、数据源和汇的形式构建你的应用程序。这种类型的在数据流密集型应用程序的上下文中非常有用，这意味着有大量数据不断从一个应用程序的部分移动到另一个部分。
- en: A practical application of such reactive programming is applications that are
    heavy on events. For example, many mobile applications rely on event propagation
    and reacting to events. This means that a good strategy to describe this kind
    of application would be to reason about data streams and data sources, as well
    as reactions to data as first-class citizens of the application. Normally, these
    kinds of application would be described in terms of callbacks and reactions to
    events. However, reasoning in terms of streams gets you a toolset of proper abstractions.
    In the previous chapter, we saw that when we frequently encounter errors and side
    effects, then making them first-class citizens of your programs and reasoning
    about them explicitly can be very beneficial to troubleshoot your application
    and to reduce the chance of an error.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种响应式编程的一个实际应用是事件密集型应用程序。例如，许多移动应用程序依赖于事件传播和对事件的响应。这意味着描述这类应用程序的好策略是关于数据流和数据源进行推理，以及将数据作为应用程序的一等公民进行反应。通常，这类应用程序会用回调和事件响应来描述。然而，以流的形式进行推理为你提供了一套适当的抽象工具。在上一章中，我们看到了当我们频繁遇到错误和副作用时，将它们作为程序的一等公民并明确地推理它们，对于调试应用程序和减少错误发生的可能性非常有帮助。
- en: It's the same thing here—when we have an application that is heavy on data and
    events, then reasoning in terms of streams can be pretty beneficial. There is
    an entire range of implementations of this approach for a wide range of programming
    languages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里也是同样的情况——当我们有一个数据事件密集型的应用程序时，以流的形式进行推理可以非常有益。针对广泛的编程语言，已经实现了一系列这种方法的实现。
- en: However, programming in terms of event streams and reactive programming is not
    always what you want. It's true that certain applications that are heavy on events
    and data processing may be reasonable to describe in terms of data streams. However,
    this is not always the case.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以事件流和响应式编程的方式进行编程并不总是你所希望的。确实，某些事件和数据处理密集型的应用程序可以用数据流来描述是合理的。但这并不总是如此。
- en: As we have discussed previously, a wide range of theories and approaches have
    been developed to address the difficulties of parallel programming. Some of them
    can be regarded as more functional. For example, some libraries for functional
    programming for Scala, such as `Cats` or `ScalaZ`, provide certain primitives
    to allow for concurrent and parallel programming. Some of these approaches have
    a more object-oriented flavor. For example, some of the process calculi mentioned
    previously tend to have a deal of object-oriented spirit in them, which means
    that they introduce certain kinds of primitives that are very much comparable
    to objects in object-oriented programming. Some theories and approaches reside
    on the edge between functional programming and object-oriented programming and
    cannot be clearly classified as members of any of these approaches. For example,
    this can be the reactive approach to programming. Although it is heavy on functions
    and uses Lambda calculus to compose these functions, the trade-off is often type
    safety.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，已经开发出各种理论和方法来解决并行编程的困难。其中一些可以被视为更功能性的。例如，一些Scala函数式编程库，如`Cats`或`ScalaZ`，提供了一些原语以允许并发和并行编程。其中一些方法具有更面向对象的特点。例如，之前提到的一些进程演算往往具有相当多的面向对象精神，这意味着它们引入了一些与面向对象编程中的对象非常相似的原语。一些理论和方法位于函数式编程和面向对象编程的边缘，无法明确归类为任何这些方法的成员。例如，这可以是编程的响应式方法。尽管它在函数上投入很大，并使用Lambda演算来组合这些函数，但权衡通常是类型安全。
- en: The presence of the amount of theories and approaches for concurrent programming
    means that this topic is highly speculative. It is often the case that techniques
    and theories that work well for one application will not show themselves as being
    well for another. Therefore, it is necessary to remark this book's stance on the
    topic. In this book, we take a pragmatic approach to functional programming, which
    means that the aim of this book is to give you a toolset to solve practical problems
    in a functional manner. So far, one of the most pragmatic and best approaches
    toward parallel programming is the actors model. While it is possibly not the
    most elegant modal from a functional programming perspective, since it still lacks
    a satisfactory type safety, it is something that is highly scalable and works
    well in practice. In this chapter of this book, we will be studying the actor
    approach to the functional programming of parallel applications, and we will see
    how to use modern actor-based technology to write real-world parallel and scalable
    applications with the help of the actor model.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程理论和方法的数量意味着这个主题非常具有推测性。通常情况下，对某个应用程序有效的技术和理论可能不会对另一个应用程序表现出同样的效果。因此，有必要指出本书对这个话题的立场。在这本书中，我们采取了一种实用主义的方法来处理函数式编程，这意味着本书的目的是为你提供一个工具集，以函数式的方式解决实际问题。到目前为止，最实用且最好的并行编程方法之一是演员模型。虽然从函数式编程的角度来看，它可能不是最优雅的模式，因为它仍然缺乏令人满意的类型安全，但它是一种高度可扩展且在实际中表现良好的方法。在本章中，我们将研究并行应用程序的演员方法，并了解如何使用基于演员的现代技术，借助演员模型来编写实际的并行和可扩展的应用程序。
- en: However, before we jump into discussing the actor model and its practical applications,
    it is necessary to understand all of the challenges that are faced by parallel
    programming, and how they are solved in the traditional model of object-oriented
    programming with the traditional approach. So, first of all, let's take a look
    at the traditional approach to parallel programming, that is, multi-threading
    with synchronization and monitors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们深入讨论演员模型及其实际应用之前，有必要了解并行编程所面临的全部挑战，以及它们如何在传统的面向对象编程模型和传统方法中得到解决。因此，首先，让我们来看看传统的并行编程方法，即带有同步和监视器的多线程。
- en: Traditional model synchronization on monitors
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统模型在监视器上的同步
- en: 'Concurrency scenarios occur when you have two or more operations that are executed
    in parallel one with another. This parallelism can be either true parallelism
    or simulated parallelism. True parallelism is when your application is executed
    in parallel on two different CPU cores, like so:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 并发场景发生在你有两个或更多操作并行执行时，这种并行性可以是真正的并行或模拟的并行。真正的并行是指你的应用程序在两个不同的CPU核心上并行执行，如下所示：
- en: '![](img/30f64707-8d2c-486e-bacc-3e4c681c1c41.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30f64707-8d2c-486e-bacc-3e4c681c1c41.png)'
- en: 'Simulated parallelism is when all of your parallel tasks are executed on the
    same processor core, however the processor switches from one task to another from
    time to time. Every task is composed of so-called atomic actions—smallest tasks
    that cannot be interrupted until they complete. The processor can take a certain
    amount of atomic actions from one task, and then execute a certain number of atomic
    tasks from another task:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟并行性是指所有并行任务都在同一处理器核心上执行，但是处理器会不时地在任务之间切换。每个任务都由所谓的原子操作组成——最小的任务，直到完成不能被中断。处理器可以从一个任务中获取一定数量的原子操作，然后执行来自另一个任务的一定数量的原子任务：
- en: '![](img/8fa70dc4-0ab7-4b51-9b64-5e79ff76ef13.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fa70dc4-0ab7-4b51-9b64-5e79ff76ef13.png)'
- en: When you are writing a parallel application, you will often come across a situation
    where your tasks need to communicate one with another. One such situation when
    this may happen is when your concurrent tasks need to access some kind of resource
    that can be external or internal to the application, which is not thread-safe.
    In this situation, they will need to coordinate their access to this resource.
    Here, we have stumbled upon a very important concept to parallel programming,
    that is thread safety. Thread-safe resources can be accessed from any number of
    threads in parallel without worrying about whether something can go wrong. However,
    resources that are not thread-safe must be accessed from one side at a time. A
    typical example of a thread-safe resource is an immutable data structure. A typical
    example of a non-thread-safe resource is a shared mutable state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个并行应用程序时，你经常会遇到需要任务之间相互通信的情况。这种情况可能发生的一种情况是，你的并发任务需要访问某种资源，这种资源可以是应用程序的外部或内部资源，它不是线程安全的。在这种情况下，他们需要协调对这种资源的访问。在这里，我们遇到了并行编程中的一个非常重要的概念，那就是线程安全。线程安全的资源可以从任何数量的线程并行访问，而不必担心是否会出现错误。然而，非线程安全的资源必须一次从一侧访问。一个典型的线程安全资源是不可变数据结构。一个典型的非线程安全资源是共享可变状态。
- en: 'What can possibly go wrong if you access a resource that is not thread-safe
    from more than one thread? Consider the example of writing to a file. Consider
    that you are writing an application for an online shop that is intended to generate
    a list of goods in some format. Consider that you need to read from a file listing
    goods in CSV and then transform them in some way:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从多个线程访问非线程安全的资源，可能会发生什么问题？考虑写入文件的例子。假设你正在为在线商店编写一个应用程序，该应用程序旨在以某种格式生成商品列表。假设你需要从CSV格式的文件中读取商品列表，然后以某种方式转换它们：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Consider that you need to output the same goods in JSON using the `Circe` library
    that we have already learned about:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你需要使用我们已学过的`Circe`库以JSON格式输出相同的商品：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Also consider that you want to perform this operation in parallel. What you
    need to do here is take every row of the CSV file and convert it into some JSON
    output. Then, we need to write this output into the output file. Here, we have
    a bunch of operations that are not dependent one on another. Every transformation
    of every row is independent on any other transformation of any other row. So,
    what we might want to do is take these tasks in parallel from two threads. Therefore,
    one thread will process the first half of the list, and the other thread will
    process the second half of the list.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑你想要并行执行此操作。你需要做的是将CSV文件的每一行转换为某种JSON输出。然后，我们需要将此输出写入输出文件。在这里，我们有一系列相互依赖的操作。每一行的转换都是独立于任何其他行的任何其他转换的。因此，我们可能想要从两个线程并行执行这些任务。因此，一个线程将处理列表的前半部分，而另一个线程将处理列表的后半部分。
- en: 'The output to a file can be modeled as a certain transaction, like so:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出到文件的过程可以模拟为一种特定的交易，如下所示：
- en: '![](img/08cc1a4b-4dde-481f-9cdb-451dea9a2075.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/08cc1a4b-4dde-481f-9cdb-451dea9a2075.png)'
- en: 'In the preceding diagram, you can see that we have the operation of opening
    the file for writing, then executing certain atomic actions that write the data
    into the file, and then closing the file. For simplicity, the process of writing
    a string called `Hello` into a file may not look like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到我们执行了打开文件以供写入的操作，然后执行某些原子操作将数据写入文件，最后关闭文件。为了简单起见，将字符串`Hello`写入文件的过程可能看起来不像以下这样：
- en: '![](img/2492799d-0719-4cc3-b93f-f7eb9c1ca60f.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2492799d-0719-4cc3-b93f-f7eb9c1ca60f.png)'
- en: In the preceding diagram, we can see that the entire transaction is not atomic.
    It is composed of atomic operations, and is writing individual characters in our
    case. A note should be made here that the preceding example is only an example.
    Different implementations of writing logic might implement the transaction process
    differently so that the preceding atomic operations might not hold true for all
    environments. However, the preceding example illustrates this point very well,
    since most implementations still write to a file in a non-thread-safe manner using
    atomic actions. The entire writing transaction is not atomic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到整个事务不是原子的。它由原子操作组成，在我们的例子中是写入单个字符。这里应该注意的是，前面的例子只是一个例子。不同的写入逻辑实现可能会以不同的方式实现事务过程，因此前面的原子操作可能并不适用于所有环境。然而，前面的例子很好地说明了这一点，因为大多数实现仍然使用原子操作以非线程安全的方式将数据写入文件。整个写入事务不是原子的。
- en: 'Let''s consider what happens if we try and write into the same file from two
    different threads:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如果我们尝试从两个不同的线程向同一个文件写入会发生什么：
- en: '![](img/3c384403-3929-4b1e-a4f3-ea767b24f61a.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c384403-3929-4b1e-a4f3-ea767b24f61a.png)'
- en: 'So, as you can see, we do not have any guarantee regarding the order in which
    the atomic tasks of every transaction get executed. So, as the preceding scenario
    comes through, you will end up with the following output to a file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你所看到的，我们没有关于每个事务的原子任务执行顺序的任何保证。因此，当前面的场景发生时，你最终会在文件中得到以下输出：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That is what we mean when we say that an operation or a resource is not thread-safe.
    This means that it is only permitted to work with the source from a single thread.
    Working from two threads with the same resource can be done as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的操作或资源不是线程安全的含义。这意味着它只能由单个线程与源一起工作。使用相同资源从两个线程中工作可以按照以下方式实现：
- en: '![](img/5c7086ef-0671-44c5-a82f-bc1234e68670.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c7086ef-0671-44c5-a82f-bc1234e68670.png)'
- en: So, obviously, the preceding two threads must be aware of one another and of
    the order in which they should be executed. More precisely, we should somehow
    impose a guarantee that only one thread at a time will have access to the shared
    resource. In other words, we need to synchronize the threads somehow.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显，前面的两个线程必须意识到彼此以及它们应该执行的顺序。更确切地说，我们应该以某种方式确保一次只有一个线程可以访问共享资源。换句话说，我们需要以某种方式同步线程。
- en: Synchronization
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步
- en: The simplest approach that can be used to synchronize the threads is called
    synchronization. It is implemented on the language level and is a standard construct
    in most programming languages.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来同步线程的最简单方法被称为同步。它在语言级别上实现，并且是大多数编程语言中的标准构造。
- en: The idea is as follows. Certain chunks of your programming code can be made
    guarded, which means they cannot be executed by the thread unless a certain condition
    is true. The condition in question is ownership of a so-called monitor. Therefore,
    a thread can own certain monitors. In a JVM setting, a monitor can be any object.
    So, on the JVM level, we can declare that a thread owns a monitor. Threads can
    take ownership and release the ownership of monitors at their own discretion.
    Another rule is that a monitor can only be held by one thread at a time. When
    a thread wants to take a monitor that is already held by another thread, then
    this thread must wait until this monitor is released and becomes available to
    it once more.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是这样的。你的某些编程代码块可以被设置为受保护的，这意味着除非满足某个条件，否则线程无法执行这些代码。这个条件就是所谓的监视器的所有权。因此，一个线程可以拥有某些监视器。在JVM环境中，监视器可以是任何对象。因此，在JVM级别上，我们可以声明一个线程拥有一个监视器。线程可以自行决定是否获取和释放监视器的所有权。另一个规则是，监视器一次只能被一个线程持有。当一个线程想要获取已被另一个线程持有的监视器时，那么这个线程必须等待直到监视器被释放并再次可用。
- en: 'The preceding framework can be used in order to synchronize threads with one
    with another. You can do so as follows. Whenever we have a resource that is not
    thread-safe and needs to be accessed from more than one thread, we guard the code
    by accessing it with the `synchronized` keyword, that is, in the case of Java
    or Scala. This can be done as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的框架可以用来同步线程之间的交互。你可以按照以下方式操作。每当有一个资源不是线程安全的，并且需要从多个线程中访问时，我们可以通过使用`synchronized`关键字来保护代码，即在Java或Scala的情况下。这可以按照以下方式实现：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code is executed in the context of some thread. Every instruction
    is executed in the thread in sequence. When the thread reaches the `synchronized`
    keyword, it attempts to take the object in question as a monitor. If this object
    is owned by some other thread, this thread goes into sleep mode. This means it
    does nothing until notified that the monitor is released and available for it
    to acquire. Once the monitor is available, it is acquired by this thread. This
    thread now has a guarantee that no other threat will take the same monitor until
    it is held by itself. Then, this thread executes the code in a `synchronized`
    block.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是在某个线程的上下文中执行的。每个指令都是按顺序在线程中执行的。当线程遇到`synchronized`关键字时，它会尝试获取相关的对象作为监视器。如果这个对象被其他线程拥有，那么这个线程就会进入睡眠模式。这意味着它什么也不做，直到被通知监视器被释放并且可以由它获取。一旦监视器可用，它就会被这个线程获取。现在，这个线程有保证，在它自己持有之前，不会有其他线程获取相同的监视器。然后，这个线程在`synchronized`块中执行代码。
- en: 'After the code is executed, the monitor is released by the current thread.
    The semantics of the execution will be as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行后，当前线程会释放监视器。执行语义如下：
- en: '![](img/b1368add-9d93-4536-979d-1e26e759982a.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1368add-9d93-4536-979d-1e26e759982a.png)'
- en: The preceding approach might look good in theory. However, there are a bunch
    of serious problems that can be encountered in such a scenario. These problems
    are pretty hard to debug, and they cannot be spotted by modern compilers. The
    existence of such problems demands a better framework for reasoning and defining
    concurrent and parallel applications. Next, let's take a look at what these problems
    are.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，上述方法看起来不错。然而，在这种场景下可能会遇到一些严重的问题。这些问题非常难以调试，并且现代编译器无法检测到这些问题。这类问题的存在要求有一个更好的推理和定义并发及并行应用的框架。接下来，让我们看看这些问题是什么。
- en: Problems with the traditional model – race conditions and deadlocks
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统模型的难题——竞态条件和死锁
- en: The problems start to appear when more than one resource gets involved. Consider,
    for example, a slightly modified version of the preceding program. In the previous
    example, we had to write the result of the computation into a file. Consider that,
    at the same time as doing the computations themselves, we need to keep track of
    what they're doing in a log file. This kind of practice can be useful in a real-world
    scenario for debugging purposes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及多个资源时，问题开始出现。例如，考虑对上述程序进行轻微修改的版本。在先前的例子中，我们必须将计算结果写入文件。考虑在执行计算的同时，我们还需要在日志文件中跟踪它们所做的工作。这种做法在现实世界的场景中对于调试目的可能是有用的。
- en: So, the plan is as follows. First, the entire input file is read into the program
    memory. In our current scenario, threads are heterogeneous, which means that they
    have different tasks to accomplish. Homogeneous threads are generally easier to
    work with because they behave similarly and are controlled from one place. However,
    this is not always the case in the real world. So, let's consider threads with
    the following tasks. The first thread will be tasked with the conversion from
    CSV to JSON, as in the previous example. Also, it must report about how the conversion
    goes into the log file. The other thread will perform a different task. Let it
    compute some statistics over the file in question, for example, an average price
    of all the goods that the online shop is trading.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，计划如下。首先，整个输入文件被读入程序内存。在我们的当前场景中，线程是异构的，这意味着它们有不同的任务要完成。同构线程通常更容易处理，因为它们的行为相似，并且从同一个地方控制。然而，在现实世界中并不总是这样。所以，让我们考虑具有以下任务的线程。第一个线程将负责将CSV转换为JSON，就像先前的例子一样。此外，它必须将转换过程报告到日志文件中。另一个线程将执行不同的任务。让它计算有关文件的某些统计数据，例如，在线商店所交易的所有商品的平均价格。
- en: 'Let''s see how such a program might be implemented in a traditional synchronization
    scenario. Before diving into this example, let''s define some convenience methods
    and values that we will use in the example. You will need the following imports:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这样一个程序如何在传统的同步场景中实现。在深入这个例子之前，让我们定义一些在例子中会使用的方便方法和值。你需要以下导入：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For file operations, we will use the Apache Commons IO library. The dependency
    on it must be declared in `build.sbt`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件操作，我们将使用Apache Commons IO库。必须在`build.sbt`中声明对这个库的依赖：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The convenience methods are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的方法如下：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the stage set, let''s proceed to the example. First of all, let''s take
    a look at the first thread tasked with the conversion from CSV to JSON. The first
    thing you might want to do in this thread is open the file we''re going to work
    on and read it to a list:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段设置完毕后，让我们继续到示例。首先，让我们看看负责将CSV转换为JSON的第一个线程。在这个线程中，你可能想要做的第一件事是打开我们将要工作的文件并将其读取到列表中：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since files are not thread-safe resources, the first thing that we need to
    do is take a monitor on the file. Immediately after reading this file, we might
    want to report to the log that the operation was performed successfully. So, we
    might want to take a monitor on the log file and report the operation as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件不是线程安全的资源，我们首先需要做的事情是对文件进行监控。在读取此文件后，我们可能想要向日志报告操作已成功执行。因此，我们可能想要对日志文件进行监控并报告操作如下：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that the monitor of the log file is released immediately after we are
    done with that reporting. So, `inputListcode` looks as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在完成报告后，日志文件的监控会立即释放。所以，`inputListcode`看起来如下所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we are done with reading the file, we perform the operation of conversion
    on every row of the input file, and then we write the result into the output file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件完成后，我们对输入文件的每一行执行转换操作，然后将结果写入输出文件：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, the entire code for the first thread looks as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个线程的整个代码如下所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s take a look at the other thread. It is tasked by the objective
    of computing certain statistics to our input file. More precisely, what we can
    do is compute some sort of aggregate function on all of the prices of the goods.
    For example, we might consider computing the average, the maximum value, and the
    minimum value of the set. However, we might also want to configure this thread
    with the exact metrics we want to compute:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一条线程。它的任务是计算我们输入文件中的某些统计数据。更确切地说，我们可以对商品的所有价格进行某种聚合函数的计算。例如，我们可能考虑计算集合的平均值、最大值和最小值。然而，我们也可能想要配置这条线程以计算我们想要的精确指标：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, we were able to specify which exact metrics we need to compute.
    A reasonable step would be to report this information to a log file before doing
    anything else:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们能够指定需要计算的确切指标。一个合理的步骤是在做任何事情之前将此信息报告到日志文件中：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first thing that we do here is take a monitor on the log file and report
    the metrics. The next thing we need to do is actually read the file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们首先做的事情是对日志文件进行监控并报告指标。接下来我们需要做的事情是实际上读取文件：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since we also need to report the fact that the file was read successfully to
    the log, we decide to release the log monitor, but only after the file is successfully
    read. Notice how the snippet that reports the metrics gets incorporated into the `inputList` code,
    so that both the statistics and the `Read the input file` reporting can be done
    under the same `synchronized` code block.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还需要向日志报告文件已成功读取的事实，我们决定在文件成功读取后释放日志监控。注意，报告指标的片段是如何被整合到`inputList`代码中的，这样统计和“读取输入文件”报告都可以在同一个`synchronized`代码块下完成。
- en: 'After reading the input file, we are able to compute the required metrics on
    this input file based on the parameters specified by the user as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 读取输入文件后，我们能够根据用户指定的参数在此输入文件上计算所需的指标如下：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Therefore, the entire code for the `statistics` thread will look like the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`statistics`线程的整个代码将如下所示：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What happens if you run this thread in parallel with the first thread?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与第一个线程并行运行此线程会发生什么？
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You may notice that, sometimes, the program hangs and becomes non-responsive.
    This situation is called a **deadlock**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，有时程序会挂起并且变得无响应。这种情况被称为**死锁**。
- en: 'Basically, the problem here is that the two threads are racing for the resources.
    It is a race condition of who takes which monitor first. The first thread takes
    the monitor on the input file, and then it takes the monitor on the log. Then,
    it releases the monitor on the lock, and then it releases the monitor on the input
    file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这里的问题是两个线程正在争夺资源。这是一个关于哪个线程先获取哪个监控器的竞争条件。第一个线程获取输入文件的监控器，然后获取日志的监控器。然后，它释放锁的监控器，然后释放输入文件的监控器：
- en: '![](img/b26dab53-8f3e-485f-890a-3b94cb6a6a30.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b26dab53-8f3e-485f-890a-3b94cb6a6a30.png)'
- en: In the preceding diagram, the orange bar represents the code that is executed
    under the input monitor. The blue bar is the code under the log monitor. In this
    particular case, the blue code also owns the input monitor, since it has not been
    released from the time of its execution yet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，橙色条表示在输入监视器下执行的代码。蓝色条表示在日志监视器下的代码。在这个特定案例中，蓝色代码也拥有输入监视器，因为它在执行期间尚未释放。
- en: 'The second thread, in contrast, does these operations in a different order.
    First, it takes a lock on the log file. Then, it takes the lock on the input file,
    and then it releases the lock on the input file, before releasing the lock on
    the log file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，第二个线程以不同的顺序执行这些操作。首先，它锁定日志文件。然后，它锁定输入文件，接着释放输入文件的锁，最后才释放日志文件的锁：
- en: '![](img/442b21f4-7289-4e13-9845-4448e6ae9a2b.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/442b21f4-7289-4e13-9845-4448e6ae9a2b.png)'
- en: The two threads depend on the same set of resources, and the order in which
    they acquire them is not defined. This means that they will be competing for these
    resources, and when you run the program several times, the order of resources
    in acquisition will be different from run to run.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 两个线程依赖于相同的一组资源，它们获取这些资源的顺序没有定义。这意味着它们将竞争这些资源，当你多次运行程序时，资源获取的顺序将在每次运行中不同。
- en: 'Let''s take a look at a case where an application works well:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个应用程序运行良好的案例：
- en: '![](img/2880eb78-a06a-4b26-ad8a-767350d766b7.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2880eb78-a06a-4b26-ad8a-767350d766b7.png)'
- en: In the preceding diagram, the first thread takes the monitor on input and then
    it takes a monitor on the log, but after that, the second thread attempts to take
    the lock on the log, but it is late to do that. Therefore, it is forced to wait
    until the other thread finishes. The first thread has acquired all of the locks
    it is dependent on, and so it finishes successfully. After it finishes, it releases
    all of monitors it owns, and the second thread is capable of taking them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第一个线程首先锁定输入监视器，然后锁定日志监视器，但之后，第二个线程试图锁定日志，但为时已晚。因此，它被迫等待其他线程完成。第一个线程已经获得了它所依赖的所有锁，因此它成功完成。完成之后，它释放了它拥有的所有监视器，第二个线程就可以获取它们。
- en: 'Now, let''s take a look at how and why exactly the application gets a deadlock:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看应用程序如何以及为什么会出现死锁：
- en: '![](img/c0787699-8448-43c1-b377-9070fe798a24.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0787699-8448-43c1-b377-9070fe798a24.png)'
- en: So, in the example above, the first thread takes the monitor on the input file.
    Together with it, the second thread takes the monitor on the log file. After that,
    in order to proceed, the first thread needs a monitor on the log file, but it
    cannot take it because the second thread has already taken it, and so it is forced
    to wait.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上面的例子中，第一个线程锁定输入文件的监视器。与之相伴，第二个线程锁定日志文件的监视器。之后，为了继续执行，第一个线程需要日志文件的监视器，但它无法获取它，因为第二个线程已经锁定了它，因此它被迫等待。
- en: The second thread needs the monitor on the input file in order to proceed. However,
    it cannot take it because it is owned by the first thread, and so it is also forced
    to wait. This means we have ended up in a situation where neither of the threads
    can proceed until the other thread finishes, and so neither of the threads ever
    finishes. This kind of situation is called a deadlock.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个线程需要输入文件的监视器才能继续执行。然而，它无法获取它，因为它被第一个线程拥有，因此它也必须等待。这意味着我们最终陷入了一个状态，其中两个线程都无法继续执行，直到另一个线程完成，因此两个线程都不会完成。这种情况被称为死锁。
- en: 'A quick fix may be to make the threads and take the monitor in the same order.
    For example, if the first thread takes the monitor on the input file and then
    a monitor on the log file, we might want to enforce the same order on the second
    thread as well. So, the second thread will look as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的解决方案可能是让线程以相同的顺序获取监视器。例如，如果第一个线程先锁定输入文件监视器，然后锁定日志文件监视器，我们可能希望对第二个线程也强制执行相同的顺序。因此，第二个线程将如下所示：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding chunk of code in bold is what was changed compared to the `statistics` thread
    definition. Now, whoever takes the monitor on the input file first is guaranteed
    to finish the execution. This is because, in the preceding application, it is
    impossible to take the monitor on the log file unless you already own the monitor
    on the input file. So, whoever takes the monitor on the input file is guaranteed
    to be able to take the same monitor on the log file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体中的代码块与`statistics`线程定义相比所做的更改。现在，第一个获取输入文件监视器的人将保证完成执行。这是因为，在先前的应用中，除非你已经拥有了输入文件的监视器，否则不可能获取日志文件的监视器。所以，第一个获取输入文件监视器的人将保证能够获取相同的日志文件监视器。
- en: The fix might work in the short term. However, you might have already noticed
    that it is suboptimal. In the previous example, we had a pretty simple situation.
    We only had two threads and two resources they depend on. That kind of simple
    setting is not likely to happen in the real world. Real-world applications are
    likely to have dozens of threads in them and depend on dozens of resources. Also,
    debugging the preceding complexity was tricky. If only two threats were capable
    of producing such complexity and required a lot of our brain power to do the analysis
    and find the problem, imagine how this complexity can grow in magnitude in a real-world
    setting.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 短期内这个修复可能有效。然而，你可能已经注意到它并不是最优的。在先前的例子中，我们有一个相当简单的情况。我们只有两个线程和它们依赖的两个资源。这种简单的设置在现实世界中不太可能发生。现实世界中的应用可能包含数十个线程，并依赖于数十个资源。此外，调试先前的复杂性也很棘手。如果只有两个线程能够产生这种复杂性并且需要大量的脑力去分析和找出问题，想象一下这种复杂性在现实世界设置中会如何增长。
- en: This is precisely why the standard synchronization approach to parallel programming
    is not practical in the long run. It's fine as a low-level model of programming
    so that people build some high-level primitives on top of it. However, we cannot
    use it in practice efficiently. These kinds of problems with threads and concurrent
    applications provided a motivation to create newer, more robust approaches to
    reasoning about concurrent programming. We already discussed some of them briefly
    at the beginning of this chapter. Now, let's talk about the actor model in more
    detail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是为什么标准同步方法在长期内对并行编程来说并不实用的原因。它作为编程的低级模型是不错的，这样人们可以在其之上构建一些高级原语。然而，我们在实践中无法有效地使用它。这些问题与线程和并发应用程序提供了创造更新、更稳健的推理并发编程方法动机。我们在本章开头简要讨论了一些这些方法。现在，让我们更详细地谈谈actor模型。
- en: The actor model as a replacement for the traditional model
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将actor模型作为传统模型的替代
- en: One of the most popular approaches to dealing with the complexity discussed
    previously is the actor approach to concurrent programming. If you look at the
    preceding examples in detail, you will notice one thing about them, that is, global
    reasoning. Whenever we have several threads that need to communicate in one with
    another, we are forced to reason about them together. So, we cannot take one thread
    and reason about it independently from other threads.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 处理先前讨论的复杂性的最流行方法之一是并发编程的actor方法。如果你仔细查看先前的例子，你会注意到它们的一个特点，那就是全局推理。每当有多个线程需要相互通信时，我们就被迫一起对它们进行推理。因此，我们不能单独考虑一个线程，而忽略其他线程。
- en: As we saw previously, the solution to the deadlock problem was to change the
    order in which the monitors were taken in the second thread so that the order
    matched the one in the first thread. Basically, when we are working in the scope
    of the second thread, we are forced to take into account the operations done in
    the first thread.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，解决死锁问题的方法是改变第二个线程中获取监视器的顺序，使其与第一个线程中的顺序相匹配。基本上，当我们处于第二个线程的作用域内时，我们被迫考虑到第一个线程中进行的操作。
- en: Global reasoning produces mental load on the programmer's mind. One of the central
    points of this book is that purely functional programming aims to reduce the mental
    load on the programmer's mind by reducing the scope of reasoning about the programs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 全局推理给程序员的思维带来了心理负担。本书的一个核心观点是，纯函数式编程旨在通过减少对程序推理的范围来减轻程序员的思维负担。
- en: How can we tackle the problem of the global scope and shared mutable state as
    the means of communication between threads in the context of concurrent programming?
    The response of the actors model would be to provide a set of abstractions to
    ensure that whenever you are programming a parallel application, you are able
    to forget that you are working in a concurrent environment. The central point
    behind the actors model, the central idea of why it is created, and why it exists,
    is to make your program within a concurrent environment as if you were dealing
    with a single threaded application, which means you no longer need to think about
    taking monitors or accessing resources in a thread-safe manner.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发编程的背景下，我们如何处理全局作用域和共享可变状态作为线程间通信手段的问题？演员模型会提供一组抽象来确保，无论何时你在编写并行应用程序，你都能忘记你正在一个并发环境中工作。演员模型背后的核心点，它被创造出来的中心思想，以及它存在的原因，就是让你的程序在并发环境中就像你正在处理一个单线程应用程序一样，这意味着你不再需要考虑以线程安全的方式获取监视器或访问资源。
- en: The actor model does this by providing you with a set of abstractions and a
    set of conventions that you must follow as part of the model. A central abstraction
    of the actor model is, not surprisingly, an actor. An actor can be roughly thought
    of as a thread. It is not necessarily mapped one-to-one on threads; in fact, it
    is a more lightweight primitive, and you might have thousands upon thousands of
    actors. The way their concurrency is managed is in abstracted away. However, the
    right way to think about actors is that they are the concurrency primitives of
    the actor model.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 演员模型通过提供一组抽象和一组必须遵循的约定来实现这一点，作为模型的一部分。演员模型的核心抽象，不出所料，是一个演员。可以大致将演员视为一个线程。它不一定是一对一映射到线程上；实际上，它是一个更轻量级的原语，你可能会有成千上万的演员。它们并发性的管理是通过抽象来实现的。然而，正确思考演员的方式是，它们是演员模型中的并发原语。
- en: An actor can own certain resources, and if it does, it is guaranteed that no
    other actor owns or has access to these sources. For example, if an actor has
    a reference to a file, it is guaranteed that no other actor has the same reference
    to the same file, so it is not able to write or read from the file. If it does
    need to access a resource owned by another actor, it needs to ask the owner actor
    to perform the required operation on behalf of this actor. Since all of the operations
    over a non-thread-safe or resource are done by one and only one actor, and actors
    are sequential and single threaded entities, there is no danger that some non-thread-safe
    behavior will emerge in this context.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个演员可以拥有某些资源，如果它确实拥有，则保证没有其他演员拥有或访问这些资源。例如，如果一个演员有一个文件的引用，则保证没有其他演员有相同引用的同一文件，因此它无法写入或读取该文件。如果它需要访问另一个演员拥有的资源，它需要请求拥有该资源的演员代表这个演员执行所需的操作。由于所有非线程安全或资源上的操作都是由一个且仅有一个演员完成的，并且演员是顺序和单线程实体，因此在这种情况下不会出现任何非线程安全的行为。
- en: How exactly does one actor ask another actor to perform an action? This is done
    by messaging. Every actor has a so-called **mailbox**. A mailbox is a place where
    all of the incoming communications to this actor are stored. A single unit of
    communication in the actor model is a message. A message can be anything as long
    as it complies with the constraints of the actor model, which we will be discussing
    later. A mailbox is a queue. Therefore, the messages from many actors that run
    and send messages in parallel may arrive to the single actor, and they will get
    sorted into a single sequential queue. An actor is guaranteed to process only
    one message at a time. So, the way it works is that the actor waits on its mailbox
    for mail. Then, it takes one letter at a time and processes it sequentially.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个演员如何向另一个演员请求执行一个动作？这是通过消息来完成的。每个演员都有一个所谓的**邮箱**。邮箱是一个存储所有发送给这个演员的通信的地方。在演员模型中，一个通信单元就是一个消息。只要消息符合演员模型的约束条件，它可以包含任何内容，我们将在后面讨论这些约束条件。邮箱是一个队列。因此，许多并行运行并发送消息的演员的消息可能会到达单个演员，并且它们将被排序到一个单一的顺序队列中。演员保证一次只处理一个消息。所以，它的工作方式是演员在其邮箱上等待邮件。然后，它一次处理一封信，并按顺序处理。
- en: One way regarding how exactly to process the incoming mail is defined in the
    body of an actor in terms of reactions to different kinds of incoming mail. So,
    for every type of mail the actor is capable of handling, it defines a certain
    function that is supposed to be executed whenever this letter arrives to the actor.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何具体处理收到的邮件，一种方法是在演员的体内通过对其不同类型收到的邮件的反应来定义。因此，对于演员能够处理的每种邮件类型，它定义了一个函数，这个函数应该在信件到达演员时执行。
- en: Deadlock example revisited
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视死锁示例
- en: So far, we have looked at the actors model at a glance. We have not learned
    any practical implementations of the actor model just yet. However, it can be
    instructive to take a look at how our previous example can be implemented so that
    we are rid of the complexity that we have faced with it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是粗略地看了演员模型。我们还没有学习任何关于演员模型的实际实现。然而，看看我们之前的例子是如何实现的，以便我们摆脱所面临的复杂性，可能会有所帮助。
- en: First of all, we have discussed that actors are primitives of concurrency of
    the actors model. In the preceding example, the primitives of concurrency were
    two threads that performed some operations. So, it is reasonable to map the operations
    that we need to perform from the two threads onto two actors of the actor model.
    So now, instead of two threads, we have two actors. One actor is supposed to generate
    JSON from CSV, and the other actor is supposed to compute some statistics on the
    CSV file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们讨论了演员模型中的并发原语。在前面的例子中，并发原语是执行某些操作的两个线程。因此，将我们需要执行的从两个线程映射到演员模型中的两个演员是合理的。所以现在，我们有了两个演员。一个演员应该从CSV生成JSON，另一个演员应该对CSV文件进行一些统计分析。
- en: In the preceding example, we had two files that we were supposed to work with
    and two threads that needed to get access to both of the files. The actors model
    requires that only one actor must own a given resource. So, if the first actor
    needs a resource, the second actor cannot have it. In our situation, the first
    and second actors need to work with the input file and the log file. How should
    we tackle this situation? How should we make it compliant with the actor model?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有两个需要处理的文件和两个需要访问这两个文件线程。演员模型要求只有一个演员必须拥有一个给定的资源。所以，如果第一个演员需要资源，第二个演员就不能拥有它。在我们的情况下，第一个和第二个演员需要处理输入文件和日志文件。我们应该如何处理这种情况？我们应该如何使其符合演员模型？
- en: The solution is that none of the two actors should own this resource. Instead,
    we should create a third actor that is responsible for running operations that
    involve these resources. Then, whenever we need to do something with a result,
    we send a message to that actor asking to perform the required operation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是两个演员都不应该拥有这个资源。相反，我们应该创建一个第三演员，该演员负责运行涉及这些资源的操作。然后，每当我们需要对结果进行操作时，我们向该演员发送消息，要求执行所需的操作。
- en: 'Since our actor, let''s call it process manager, controls access to the input
    file and the log file, we must expect the request from other actors to perform
    operations relevant to this resource. In other words, we also need to define the
    reactions to all the possible messages that it might receive. Hence, we need to
    think about what kind of operations request we might get from other actors. We
    can consider the following requests:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的演员，让我们称其为进程管理器，控制着对输入文件和日志文件的访问，我们必须期待其他演员提出的相关于这个资源的操作请求。换句话说，我们还需要定义对它可能收到的所有可能消息的反应。因此，我们需要考虑其他演员可能提出的哪种操作请求。我们可以考虑以下请求：
- en: First, we get the input file. This message is a request to read the input file
    and send it back to the requesting actor as an immutable collection. Sharing an
    immutable resource between two actors is perfectly fine since immutable resources
    are thread-safe.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们获取输入文件。这条消息是请求读取输入文件并将其作为不可变集合发送回请求的演员。在两个演员之间共享不可变资源是完全可以接受的，因为不可变资源是线程安全的。
- en: Secondly, we may be expecting a request to write into the log file. Upon receiving
    this request, the resource manager actor will perform a write operation into the
    log file with the message that was sent to it.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们可能期待一个写入日志文件的请求。在收到这个请求后，资源管理器演员将对日志文件执行写入操作，写入的信息是发送给它的消息。
- en: 'Once we have the resource manager actor, we can express the example like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了资源管理器演员，我们可以像这样表达示例：
- en: '![](img/6ae66c87-28e7-47de-9a01-74a53ebd18d0.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ae66c87-28e7-47de-9a01-74a53ebd18d0.png)'
- en: Now, the first two actors that do the actual job are defined in terms of messages
    and communication with the resource manager. The first actor asks the process
    manager to send it an input file. Upon receiving a response from the resource
    manager, it starts its operations, and whenever it performs a significant action
    that requires logging, it sends the log message to the resource manager. No monitors
    are taken in this situation since all of the resources are owned by a single actor.
    All of the other actors are not calling them directly—they are just asking the
    resource actor to perform the operations on their behalf.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行实际工作的前两个演员是根据消息和与资源管理器的通信来定义的。第一个演员要求进程管理器发送一个输入文件给它。在收到资源管理器的响应后，它开始其操作，并且每当它执行需要记录日志的重大操作时，它将日志消息发送给资源管理器。在这种情况下没有采取监控，因为所有资源都由单个演员拥有。所有其他演员并没有直接调用它们——它们只是要求资源演员代表它们执行操作。
- en: The second actor has a similar situation to itself. First of all, it sends a
    log message to the resource manager with the statistics it is going to compute.
    Secondly, it requests the input file from the resource manager. Finally, upon
    receiving the input file as a separate message, it performs the computation and
    also contacts our resource manager whenever it needs logging.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个演员与其自身有相似的情况。首先，它向资源管理器发送一条包含它将要计算的统计信息的日志消息。其次，它从资源管理器请求输入文件。最后，在作为单独的消息收到输入文件后，它执行计算，并在需要记录日志时联系我们的资源管理器。
- en: None of the actors need to take monitors or synchronize one with another in
    order to ensure that the non-thread-safe resources are safe to work with. They
    are all owned by a single actor, and this single actor works with them sequentially
    from its own single thread. The messages that the other actors send to it may
    arrive in parallel, but they will be aggregated in a single mailbox, and they
    will not be processed right away. The resource actor processes messages at its
    own pace, at its own time, whenever it has the resources and the processing time
    allocated to the underlying system. It is guaranteed that this actor will process
    the messages one at a time, and no two messages will be processed in parallel.
    Hence, we have a greatly increased level of thread safety.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 没有演员需要采取监控或与其他演员同步以确保非线程安全资源可以安全使用。它们都由单个演员拥有，并且这个单个演员从它自己的单个线程中依次与它们一起工作。其他演员发送给它的消息可能并行到达，但它们将在单个邮箱中汇总，并且不会立即处理。资源演员根据自己的节奏、自己的时间处理消息，只要底层系统分配了资源和处理时间。保证这个演员一次处理一条消息，并且不会并行处理两条消息。因此，我们大大提高了线程安全性。
- en: Also, noticed that in the preceding diagram, we have a scenario that would cause
    a deadlock in the standard synchronization model. The first actor needs to access
    the file, and then it needs to access the log, and the second actor needs to access
    the log and then the file. Previously in this chapter, we discussed how this kind
    of situation yields the possibility of a deadlock. Here, the deadlock is no longer
    possible, since the resources are controlled by a single actor.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的图中，我们有一个会导致标准同步模型中死锁的场景。第一个演员需要访问文件，然后需要访问日志，第二个演员需要访问日志然后是文件。在本章之前，我们讨论了这种情况下产生死锁的可能性。在这里，死锁不再可能，因为资源由单个演员控制。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a brief overview of the motivation and the idea behind
    the actor model. We saw how the architecture of applications can be expressed
    in terms of what the actor model might look like. In the next chapter, we will
    dive deeper into the model and see how to use it in practice. We will learn some
    practical implementations and frameworks of the models that we can use in our
    projects right away.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对演员模型的动机和背后的想法进行了简要概述。我们看到了如何用演员模型可能的样子来表示应用程序的架构。在下一章中，我们将更深入地探讨模型，并了解如何在实践中使用它。我们将学习一些我们可以立即在我们的项目中使用的模型的实际实现和框架。
- en: Questions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does the synchronization model work in synchronizing parallel computations?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步模型是如何在同步并行计算中工作的？
- en: How does a deadlock occur? Describe a scenario in which a deadlock can occur.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 死锁是如何发生的？描述一个可能导致死锁的场景。
- en: What are the main abstractions and constraints of the actor model?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 演员模型的主要抽象和约束是什么？
- en: How does the actor model help prevent the problems that usually arise under
    the synchronization model?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行为模型是如何帮助防止在同步模型下通常出现的问题的？
