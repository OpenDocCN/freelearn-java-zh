- en: Chapter 4. RESTEasy Skeleton Key
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。RESTEasy Skeleton Key
- en: Welcome to the fourth chapter! We hope you are enjoying the book, and even more
    important, learning and understanding what we are transmitting and teaching you.
    It is time to move forward and immerse yourself in a new chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到第四章！我们希望您喜欢这本书，更重要的是，学习和理解我们所传达和教授的内容。现在是时候向前迈进，沉浸在新的章节中了。
- en: Once you read this chapter, you will have the knowledge to design, implement,
    and aggregate additional security levels to your RESTEasy applications, all of
    this using OAuth and RESTEasy Skeleton Key and some other specific requirements
    of these technologies, such as setting up an OAuth server. You will learn through
    practical and descriptive examples of applications, just as we did in previous
    chapters; we won't get stuck in theory only, and we'll implement applications
    and explain specific methods and classes to implement OAuth.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您将具备设计、实施和聚合额外安全级别到您的RESTEasy应用程序的知识，所有这些都使用OAuth和RESTEasy Skeleton Key以及这些技术的一些其他特定要求，比如设置一个OAuth服务器。您将通过应用程序的实际和描述性示例进行学习，就像我们在之前的章节中所做的那样；我们不会只停留在理论上，而是会实施应用程序并解释实现OAuth的特定方法和类。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: OAuth and RESTEasy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth和RESTEasy
- en: SSO configuration for security management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于安全管理的SSO配置
- en: Access tokens
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问令牌
- en: Custom filters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义过滤器
- en: Web services clients for test
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试的Web服务客户端
- en: As you have probably experienced, if you have an account on one or several social
    networks, a lot of these social networks allow you to share information between
    them or post something in all of them. This is a sign that applications need to
    share information and also use resources that are in other applications. In this
    example, it can be your account or your contact list. This involves sensitive
    information, so it needs to be protected. Also, limited permissions over resources
    means that a third-party application can only read your contacts list. This opens
    the door to a very important, attractive, and useful feature among applications,
    which is the capacity to use resources on behalf of the user. Of course, you may
    ask how the latter authorizes the use? Well, this chapter will show you. So, let's
    go!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经经历过的那样，如果您在一个或多个社交网络上有账户，许多这些社交网络允许您在它们之间共享信息或在所有社交网络上发布内容。这表明应用程序需要共享信息，还需要使用其他应用程序中的资源。在这个例子中，可能是您的账户或联系人列表。这涉及到敏感信息，因此需要进行保护。此外，对资源的有限权限意味着第三方应用程序只能读取您的联系人列表。这为应用程序之间提供了一个非常重要、有吸引力和有用的功能，即代表用户使用资源的能力。当然，您可能会问后者如何授权使用？好吧，本章将向您展示。所以，让我们开始吧！
- en: OAuth protocol
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth协议
- en: This is an open protocol that allows you to grant safe authorization to your
    private resources from one site (service provider) to another (consumer) without
    sharing your identity.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开放协议，允许您从一个站点（服务提供者）向另一个站点（消费者）授予对您的私人资源的安全授权，而无需共享您的身份。
- en: A practical example is when you grant authorization to a website or an application
    to use the contact list in your phone or social network.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际的例子是当您授权一个网站或应用程序使用您手机或社交网络中的联系人列表。
- en: OAuth and RESTEasy Skeleton Key
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth和RESTEasy Skeleton Key
- en: In this section, we will review some concepts related to OAuth as an authentication
    framework, RESTEasy Skeleton Key, and how they work together. You will check out
    some features of these technologies and get your hands dirty with some code as
    a practical example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些与OAuth作为身份验证框架、RESTEasy Skeleton Key以及它们如何一起工作相关的概念。您将了解这些技术的一些特性，并通过一些代码实际示例来动手实践。
- en: What is RESTEasy Skeleton Key?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTEasy Skeleton Key是什么？
- en: RESTEasy Skeleton Key provides a unified way for browser and JAX-RS clients
    to be secured. This allows executing and forwarding requests in a network of applications
    and services in a secure and scalable way, without interacting with a central
    authentication server every time a request appears.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RESTEasy Skeleton Key为浏览器和JAX-RS客户端提供了一种统一的方式来进行安全保护。这允许在应用程序和服务网络中以安全和可扩展的方式执行和转发请求，而无需在每次出现请求时与中央身份验证服务器进行交互。
- en: OAuth 2.0 authentication framework
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth 2.0身份验证框架
- en: This enables third-party applications or services access to an HTTP resource
    on behalf of the resource owner. It also prevents the third-party application
    or service from getting in contact with the owner's credentials. This is possible
    through issuing access tokens via browsers and using a direct grant.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这使第三方应用程序或服务能够代表资源所有者访问HTTP资源。它还防止第三方应用程序或服务与所有者的凭据联系。这是通过通过浏览器发放访问令牌并使用直接授权来实现的。
- en: With the two concepts explained in a nutshell, it is time to describe how they
    are related. RESTEasy Skeleton Key is an OAuth 2.0 implementation that uses the
    JBoss AS 7 security infrastructure in order to secure web applications and RESTful
    services.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，通过这两个概念的解释，现在是时候描述它们之间的关系了。RESTEasy Skeleton Key是一个OAuth 2.0实现，它使用JBoss
    AS 7安全基础设施来保护Web应用程序和RESTful服务。
- en: This means that you can transform a web application into an OAuth 2.0 access
    token provider, and you can also transform the JBoss AS 7 security domain into
    a central authentication and authorization server, where applications and services
    can interact with each other.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以将Web应用程序转换为OAuth 2.0访问令牌提供程序，并且还可以将JBoss AS 7安全域转换为中央身份验证和授权服务器，应用程序和服务可以相互交互。
- en: 'The following diagram describes this process in a better way:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表更好地描述了这个过程：
- en: '![OAuth 2.0 authentication framework](img/0109OS_04_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![OAuth 2.0身份验证框架](img/0109OS_04_01.jpg)'
- en: Main features
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要特点
- en: 'We want to help you understand these technologies and clarify what they are
    used for; this is why we will name some of their main features. With OAuth 2.0
    and RESTEasy Skeleton Key, you can perform the following functions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望帮助您了解这些技术并澄清它们的用途；这就是为什么我们将列出它们的一些主要特点。使用OAuth 2.0和RESTEasy Skeleton Key，您可以执行以下功能：
- en: Transform a servlet-form-auth-based web application into an OAuth 2.0 provider.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基于servlet-form-auth的Web应用程序转换为OAuth 2.0提供程序。
- en: Provide distributed **Single Sign-On** (**SSO**) throughout a central authentication
    server in order to log in once and access any browser-based application configured
    in the domain in a secure way.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过中央身份验证服务器提供分布式**单点登录**（**SSO**），以便一次登录并以安全方式访问在域中配置的任何基于浏览器的应用程序。
- en: Use just one link and log out from all the distributed applications that were
    configured with SSO.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只使用一个链接并注销所有已配置SSO的分布式应用程序。
- en: Make a web application interact with a remote RESTful service using access tokens.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使Web应用程序使用访问令牌与远程RESTful服务进行交互。
- en: Sign access tokens with OAuth 2.0 and use the tokens later to access any service
    configured in the domain. The token has Identity and Role Mapping, and there is
    no need to overload the central authentication server with every request that
    appears because tokens are digitally signed.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0签署访问令牌，并稍后使用这些令牌访问域中配置的任何服务。令牌具有身份和角色映射，因为令牌是数字签名的，所以没有必要在每次出现请求时过载中央身份验证服务器。
- en: You can find more information about these topics at [http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html](http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html](http://docs.jboss.org/resteasy/docs/3.0-beta-2/userguide/html/oauth2.html)找到有关这些主题的更多信息。
- en: We will discuss the most important parts, but it might be useful for you.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论最重要的部分，但这对您可能有用。
- en: OAuth2 implementation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth2实施
- en: We have just reviewed some of the main concepts that we will deal with in this
    chapter, but this is not enough. We must implement a descriptive example so that
    we can completely understand these topics.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚回顾了本章中将要处理的一些主要概念，但这还不够。我们必须实施一个描述性示例，以便完全理解这些主题。
- en: Updating RESTEasy modules in JBoss
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在JBoss中更新RESTEasy模块
- en: In order not to mess with your JBoss configuration or anything else, we will
    use another brand new instance of JBoss. We have to update some modules that are
    related to RESTEasy. We can do this very easily. Let's visit the link [http://resteasy.jboss.org/](http://resteasy.jboss.org/);
    at your right, you will find a panel with the title **Useful Links**, which has
    a download link. Click on it to visit another page that has a bunch of download
    links. In this example, we use the 3.0.7.Final Version. Download this version
    in order to go forward.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不干扰您的JBoss配置或其他任何东西，我们将使用另一个全新的JBoss实例。我们必须更新一些与RESTEasy相关的模块。我们可以很容易地做到这一点。让我们访问链接[http://resteasy.jboss.org/](http://resteasy.jboss.org/)；在右侧，您会找到一个标题为**Useful
    Links**的面板，其中包含一个下载链接。单击它访问另一个页面，该页面上有一堆下载链接。在本例中，我们使用3.0.7.Final版本。下载这个版本以继续。
- en: 'Once you have downloaded and unzipped it, you will find another `.zip` file
    named `resteasy-jboss-modules-3.0.7.Final`; this file contains some JARs that
    will update your JBoss modules. So, unzip it, copy all folders into `JBOSS_HOME/modules/`,
    and replace all coincidences. There is one last step: we have to update the JAR
    files'' version and modify the module XML in JBoss in order to set `org.apache.httpcomponents`
    to use `httpclient-4.2.1.jar`, `httpcore-4.2.1.jar` and `httpmime-4.2.1.jar` because
    the current latest Version is 4.3.4, which works fine too. So, copy these JARs
    and update the version in the `module.xml` file in `JBOSS_HOME/modules/org/apache`
    folder. Now, we have updated our modules for RESTEasy.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并解压缩后，您会找到另一个名为`resteasy-jboss-modules-3.0.7.Final`的`.zip`文件；该文件包含一些将更新您的JBoss模块的JAR文件。因此，请解压缩它，将所有文件夹复制到`JBOSS_HOME/modules/`，并替换所有匹配项。还有最后一步：我们必须更新JBoss中JAR文件的版本，并修改模块XML，以将`org.apache.httpcomponents`设置为使用`httpclient-4.2.1.jar`、`httpcore-4.2.1.jar`和`httpmime-4.2.1.jar`，因为当前最新版本是4.3.4，这也可以正常工作。因此，请复制这些JAR文件，并在`JBOSS_HOME/modules/org/apache`文件夹中的`module.xml`文件中更新版本。现在，我们已经更新了RESTEasy的模块。
- en: Setting up the configuration in JBoss
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在JBoss中设置配置
- en: For the next step in getting our JBoss ready for our example, we must go to
    [https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)
    and download the `chapter04` examples zip file. Unzip and you will find a folder
    named `configuration`. This folder contains the files necessary for setting up
    our JBoss configuration. So, copy the files and replace the configuration folder
    in your JBoss located at `JBOSS_HOME/standalone/configuration`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的JBoss为示例做好下一步准备，我们必须转到[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)并下载`chapter04`示例zip文件。解压缩后，您会找到一个名为`configuration`的文件夹。该文件夹包含设置我们的JBoss配置所需的文件。因此，请复制这些文件并替换位于`JBOSS_HOME/standalone/configuration`的JBoss中的配置文件夹。
- en: Implementing an OAuth client
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施OAuth客户端
- en: 'In order to develop this example, we investigate a very useful example and
    apply it to a new project. This example is composed of several projects; each
    project will produce a WAR file. The purpose of this example is to demonstrate
    how OAuth works and explain the way you can implement this technology at a technical
    level. So, we will simulate several things in order to create the environment
    where we can apply this implementation. The complete code can be downloaded from
    the following link:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发这个示例，我们调查了一个非常有用的示例并将其应用到一个新项目中。这个示例由几个项目组成；每个项目将生成一个WAR文件。这个示例的目的是演示OAuth的工作原理，并解释您可以在技术层面上实现这项技术的方式。因此，我们将模拟几件事情，以创建我们可以应用这个实现的环境。完整的代码可以从以下链接下载：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04/oauth2-as7-example)'
- en: The oauth-client project
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: oauth-client项目
- en: First we are going to create the `oauth-client` webapp project. You can use
    the Maven command we have used before in previous chapters or you can use Eclipse
    IDE in order to perform this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建`oauth-client` webapp项目。您可以使用我们在之前章节中使用过的Maven命令，也可以使用Eclipse IDE来执行此操作。
- en: 'After that, let''s add some dependencies in order to implement our client.
    These dependencies are for all the projects. Go to the `pom.xml` file and make
    sure to add the following dependencies inside the `<dependencies>` tag:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们添加一些依赖项以实现我们的客户端。这些依赖项适用于所有项目。转到`pom.xml`文件，并确保在`<dependencies>`标签内添加以下依赖项：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's start by creating the package `com.packtpub.resteasy.example.oauth`. Then,
    create the class `public class Loader implements ServletContextListener`, which
    implements `ServletContextListener`, because we will load a key store and initialize
    a context.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建包`com.packtpub.resteasy.example.oauth`。然后，创建类`public class Loader implements
    ServletContextListener`，它实现`ServletContextListener`，因为我们将加载密钥库并初始化上下文。
- en: Let's add a field into our class `private ServletOAuthClient oauthClient`, which
    will represent our OAuth client object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的类中添加一个字段`private ServletOAuthClient oauthClient`，它将代表我们的OAuth客户端对象。
- en: 'Then, let''s create the method shown in the following piece of code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建以下代码片段中显示的方法：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method receives two parameters, the filename and the password, and creates
    the object `KeyStore`. It also creates a `FileInputStream` object from the filename
    received so that it can use it to load the `KeyStore` object, and it uses the
    password received in the form of a char array.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收两个参数，文件名和密码，并创建`KeyStore`对象。它还从接收的文件名创建一个`FileInputStream`对象，以便可以使用它来加载`KeyStore`对象，并使用以char数组形式接收的密码。
- en: 'After this, as our class implements the `ServletContextListener` interface,
    we have to override some methods. The first method to override is `contextInitialized`.
    Let''s do it as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，由于我们的类实现了`ServletContextListener`接口，我们必须重写一些方法。要重写的第一个方法是`contextInitialized`。让我们按照以下方式进行：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Through this method, we will accomplish several things. As you can see, we set
    two internal variables; one is set with the path to our `client-truststore.ts`
    file and the other is set to the password. Make sure to paste the file in the
    path we specified in the variable (`JBOSS_HOME/standalone/configuration`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们将实现几件事情。正如您所看到的，我们设置了两个内部变量；一个设置为我们`client-truststore.ts`文件的路径，另一个设置为密码。确保将文件粘贴到我们在变量中指定的路径中（`JBOSS_HOME/standalone/configuration`）。
- en: After this, we load the `KeyStore` object using the path and password we specified
    in the variables, obtaining another `KeyStore` object through this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用在变量中指定的路径和密码加载`KeyStore`对象，通过这样获得另一个`KeyStore`对象。
- en: 'Now, it''s time to instantiate and set the properties of our OAuth client object.
    In the previous code, we set the following properties: `trustStore`, `clientId`,
    `password`, `authUrl`, and `codeUrl`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实例化和设置我们的OAuth客户端对象的属性了。在前面的代码中，我们设置了以下属性：`trustStore`、`clientId`、`password`、`authUrl`和`codeUrl`。
- en: Finally, we create the client to obtain an access token from the code. In order
    to accomplish this, we use the `start()` method. Also, we set the attribute servlet
    OAuth client with the OAuth client object we just created.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建客户端以从代码中获取访问令牌。为了实现这一点，我们使用`start()`方法。同时，我们使用刚刚创建的OAuth客户端对象设置servlet
    OAuth客户端属性。
- en: 'In order to finish our OAuth client, we need to override a second method named
    `public void contextDestroyed(ServletContextEvent sce)`, as shown in the following
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的OAuth客户端，我们需要重写第二个名为`public void contextDestroyed(ServletContextEvent
    sce)`的方法，如下所示：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method will be executed when the servlet context is about to shut down,
    our application is redeploying, and so on. The method closes the client instance
    and all its associated resources.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当servlet上下文即将关闭、我们的应用程序重新部署等情况时，将执行此方法。该方法关闭客户端实例及其所有关联资源。
- en: 'We implemented our OAuth client for our example. We need another resource.
    This time, we will create a class that works as a database client for our compact
    discs store. So, let''s name it `CompactDiscsDatabaseClient`, and we will get
    the two following methods:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为示例实现了我们的OAuth客户端。我们需要另一个资源。这一次，我们将创建一个作为我们紧凑光盘商店数据库客户端的类。因此，让我们命名为`CompactDiscsDatabaseClient`，并编写以下两个方法：
- en: '`public static void redirect(HttpServletRequest request, HttpServletResponse
    response)`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void redirect(HttpServletRequest request, HttpServletResponse
    response)`'
- en: '`public static List<String> getCompactDiscs(HttpServletRequest request)`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static List<String> getCompactDiscs(HttpServletRequest request)`'
- en: 'So, let''s begin implementing the first method. This method is explained as
    follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始实现第一个方法。该方法的说明如下：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding method, we obtain the `ServletOAuthClient` object from the
    `ServletContext` obtained from the request; the servlet OAuth client is in the
    servlet context as an attribute named `ServletOAuthClient`. Remember that in the
    first class we created, we set this attribute in the servlet context.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们从请求中获取的`ServletContext`中获取了`ServletOAuthClient`对象；servlet OAuth客户端作为名为`ServletOAuthClient`的属性存在于servlet上下文中。请记住，在我们创建的第一个类中，我们在servlet上下文中设置了此属性。
- en: Finally, we start the process of getting an access token by redirecting the
    browser to the authentication server through `redirectRelative (String relativePath,
    HttpServletRequest request, HttpServletResponse response)`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过`redirectRelative (String relativePath, HttpServletRequest request, HttpServletResponse
    response)`方法开始获取访问令牌，将浏览器重定向到认证服务器。
- en: 'Now, let''s move on with the next method that loads the discs. The following
    code represents the method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个加载光盘的方法。以下代码表示该方法：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's check what we have up here. In the preceding `getCompactDiscs ()` method,
    we create a `ServletOAuthClient` object that is in charge of starting the process
    of obtaining an access token by redirecting the browser to the authentication
    server. Once again, we obtain the attribute from the `ServletContext` object from
    the request. Then, we create a `ResteasyClient` object using a new instance of
    `ResteasyClientBuilder()`; this class is an abstraction to create clients and
    allows SSL configuration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们在这里有什么。在前面的`getCompactDiscs()`方法中，我们创建了一个`ServletOAuthClient`对象，负责启动通过将浏览器重定向到认证服务器来获取访问令牌的过程。再次，我们从请求中获取`ServletContext`对象的属性。然后，我们使用`ResteasyClientBuilder()`的新实例创建一个`ResteasyClient`对象；这个类是创建客户端的抽象，并允许SSL配置。
- en: We then set the client-side trust store with the `trustStore()` method. This
    invocation will return a `KeyStore` object and set the client-side trust store.
    After this, we invoke the `hostnameVerification()` method, which sets an SSL policy
    used to verify hostnames. Finally, using the `build()` method, we build a new
    client instance with the entire configuration previously specified in this client
    builder. This will return an instance of `ResteasyClient`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`trustStore()`方法设置客户端信任库。这个调用将返回一个`KeyStore`对象并设置客户端信任库。之后，我们调用`hostnameVerification()`方法，该方法设置用于验证主机名的SSL策略。最后，使用`build()`方法，我们使用先前在此客户端构建器中指定的整个配置构建一个新的客户端实例。这将返回一个`ResteasyClient`实例。
- en: Let's move on to create an internal variable which will hold the URL of the
    resource that we will set as our target resource. Also, we will create another
    internal variable to hold the bearer token as a string. This string will comprise
    the word `Bearer` followed by the bearer token from the servlet OAuth client and
    request.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个内部变量，用于保存我们将设置为目标资源的资源的URL。此外，我们将创建另一个内部变量来保存作为字符串的持有者令牌。这个字符串将由来自servlet
    OAuth客户端和请求的持有者令牌后面跟着的单词`Bearer`组成。
- en: Now, in order to create the response, we will use the servlet OAuth client we
    just created. Let's use the variable `urlDiscs` as a parameter and create a new
    web resource target through the `target()` method. After this, using the `request()`
    method, we set up a request to the targeted web resource we just set.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了创建响应，我们将使用刚刚创建的servlet OAuth客户端。让我们使用变量`urlDiscs`作为参数，并通过`target()`方法创建一个新的web资源目标。之后，使用`request()`方法，我们设置一个请求到刚刚设置的目标web资源。
- en: 'Finally, we add a header by invoking the `header()` method, which will receive
    two parameters: the first parameter represents the header''s name and the second
    parameter is the header''s value. After this, we invoke the `HTTP GET` method
    for the current request.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`header()`方法添加一个头，该方法将接收两个参数：第一个参数表示头的名称，第二个参数是头的值。之后，我们调用`HTTP GET`方法进行当前请求。
- en: Just to clarify, the `HttpHeaders.AUTHORIZATION` constant represents the header
    field in the specific case when a user wants to authenticate themselves with a
    server. It does so by adding an authorization request-header field along with
    the request. On the other hand, the authorization field value is composed of credentials
    that contain the authentication information of the user for the realm of the resource
    being requested.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了澄清，`HttpHeaders.AUTHORIZATION`常量代表特定情况下用户想要与服务器进行身份验证时的头字段。它通过在请求中添加授权请求头字段来实现。另一方面，授权字段值由包含用户在请求的资源领域中的身份验证信息的凭据组成。
- en: Once the response object is created, we use the `readEntity()` method to read
    the message entity input stream as an instance of the specified Java type. With
    this, we fill the list with our compact discs example list so that we can present
    it in the web page. This means that we accessed the resource.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建响应对象后，我们使用`readEntity()`方法将消息实体输入流读取为指定Java类型的实例。通过这样做，我们用我们的紧凑光盘示例列表填充列表，以便在网页上呈现。这意味着我们访问了资源。
- en: 'If you want to explore more about what we just used in the block of code we
    described, here are some links as references. You can check them out, expand your
    knowledge, and get more details on `RestEasyClient` and `RestEasyClientBuilder`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想探索一下我们刚刚在描述的代码块中使用的内容，这里有一些链接作为参考。您可以查看它们，扩展您的知识，并获取有关`RestEasyClient`和`RestEasyClientBuilder`的更多详细信息：
- en: '[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)'
- en: '[http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html](http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html](http://docs.jboss.org/resteasy/docs/3.0.2.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClient.html)'
- en: '[http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore](http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore](http://docs.jboss.org/resteasy/docs/3.0.1.Final/javadocs/org/jboss/resteasy/client/jaxrs/ResteasyClientBuilder.html#truststore)'
- en: The discstore project
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: discstore项目
- en: The next project we are going to create is the `discstore` project; the steps
    to create the project are the same as the previous one, and you can use the Maven
    command or Eclipse IDE.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要创建的项目是`discstore`项目；创建项目的步骤与上一个相同，您可以使用Maven命令或Eclipse IDE。
- en: 'In this project, we will create a class that will create the list of compact
    discs. This class is pretty simple, and it uses some annotations that have already
    been discussed in previous chapters. The name of this class will be `CompactDiscService`,
    and it will have only one method with several annotations. Let''s start with the
    code, and we will add a short description about it after the code block:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将创建一个类来创建紧凑光盘的列表。这个类非常简单，它使用了一些在前几章中已经讨论过的注解。这个类的名称将是`CompactDiscService`，它只有一个带有几个注解的方法。让我们从代码开始，然后在代码块后面添加一个简短的描述：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the method `getCompactDiscs()` is in charge of creating a list
    of strings, which each item will represent as a compact disc as this is an example
    in which we will add three items.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`getCompactDiscs()`方法负责创建一个字符串列表，其中每个项目将表示为一个紧凑光盘，因为这是一个我们将添加三个项目的示例。
- en: The `@Produces` annotations are used to specify the MIME media types, and if
    applied at the method level, the annotations override any `@Produces` annotation
    applied at the class level. The `@GET` annotation, as you already know, will represent
    the HTTP method `GET`. Meanwhile, the `@Path` annotation will help us to set the
    class as a resource, and its name will be `discs`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Produces`注解用于指定MIME媒体类型，如果应用在方法级别，这些注解将覆盖类级别的`@Produces`注解。`@GET`注解，正如你已经知道的，代表HTTP方法`GET`。同时，`@Path`注解将帮助我们将类设置为资源，它的名称将是`discs`。'
- en: All the backend has been implemented; we now need to develop some other resources
    in order to let our example function. Remember we specified some web pages in
    the classes up there? Well, that is what we will implement now.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有后端都已经实现；现在我们需要开发一些其他资源，以便让我们的示例运行。记得我们在上面的类中指定了一些网页吗？那就是我们现在要实现的。
- en: The oauth-server project
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: oauth-server项目
- en: As before, in order to create this project, you can use Maven commands or Eclipse
    IDE.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，为了创建这个项目，你可以使用Maven命令或Eclipse IDE。
- en: 'In order to turn this application, we must create the `jboss-web.xml` file
    with the following content:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动这个应用程序，我们必须创建`jboss-web.xml`文件，内容如下：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One last thing: we have to create a JSON file with the purpose of having our
    certificates and security configuration in this server. We are going to name it
    `resteasy-oauth`. And as you can see, there is not a big deal with this file;
    it is a set of properties and values. Through this file, we specify the KeyStores
    and passwords, the truststore path, and so on. This file will be located in the
    `WEBINF` folder of this project.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事：我们必须创建一个JSON文件，目的是在这个服务器上拥有我们的证书和安全配置。我们将把它命名为`resteasy-oauth`。正如你所看到的，这个文件并不复杂；它是一组属性和值。通过这个文件，我们指定了密钥库和密码，信任库路径等。这个文件将位于这个项目的`WEBINF`文件夹中。
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: webapp/WEB-INF/ jboss-deployment-structure.xml
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: webapp/WEB-INF/ jboss-deployment-structure.xml
- en: 'We must configure this file in all the projects because we updated some modules
    from the instance of JBoss AS. In this file, we must specify the dependencies
    our application has with some modules of JBoss. Then, we need to clearly set them
    using the `<module>` tag inside the `<dependencies>` tag, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在所有项目中配置这个文件，因为我们更新了JBoss AS实例的一些模块。在这个文件中，我们必须指定我们的应用程序与JBoss的一些模块的依赖关系。然后，我们需要使用`<dependencies>`标签内的`<module>`标签清楚地设置它们，如下所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running the application
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: We have explained the main parts of each project, so in order to run and test
    the application, you can download the examples folder of this chapter from [https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04).
    After you download the ZIP file, unzip it and you will find there is a folder
    named `OAuthExample`. Inside this folder, there are our three projects. You can
    copy them and paste them in your workspace and import the projects using Eclipse.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了每个项目的主要部分，为了运行和测试应用程序，你可以从[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)下载本章的示例文件夹。下载ZIP文件后，解压缩，你会发现一个名为`OAuthExample`的文件夹。在这个文件夹中，有我们的三个项目。你可以复制它们并粘贴到你的工作区，并使用Eclipse导入这些项目。
- en: We have provided you the keystores, and certification and truststore files inside
    the `configuration` folder you just pasted while setting up the JBoss `configuration`.
    In order to make sure the application runs correctly, you may update these files,
    by following the instructions in the `.txt` file named `keystoreCommands` located
    inside the `configuration` folder.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`configuration`文件夹中提供了密钥库、证书和信任库文件，你在设置JBoss`configuration`时刚刚粘贴了进去。为了确保应用程序正常运行，你可以按照`configuration`文件夹中名为`keystoreCommands`的`.txt`文件中的说明更新这些文件。
- en: 'In order to launch our application, we have to deploy it. So, open a terminal.
    Let''s go to `JBOSS_HOME/bin` and start JBoss in standalone mode; this means executing
    `standalone.bat` if you are in Windows or `./standalone.sh` if you are in Linux.
    Then, open a terminal and go inside the folder of our application in the workspace.
    We have to execute the following commands: `mvn clean install` followed by `mvn`
    `jboss-as:deploy` on each one of the three projects that we have created: `discstore`,
    `oauth-client`, and `oauth-server`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动我们的应用程序，我们必须部署它。所以，打开一个终端。让我们进入`JBOSS_HOME/bin`并以独立模式启动JBoss；这意味着如果你在Windows上执行`standalone.bat`，如果你在Linux上执行`./standalone.sh`。然后，打开一个终端并进入工作区中我们应用程序的文件夹。我们必须执行以下命令：在我们创建的三个项目`discstore`、`oauth-client`和`oauth-server`中，分别执行`mvn
    clean install`和`mvn jboss-as:deploy`。
- en: 'We have created a special class in the `discstore` project. This class contains
    a `void main` method, and we test our application through this class. We have
    named it `OAuthClientTest`. The code of this class is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`discstore`项目中创建了一个特殊的类。这个类包含一个`void main`方法，我们通过这个类测试我们的应用程序。我们把它命名为`OAuthClientTest`。这个类的代码如下：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are going to explain the preceding code, first, we have two variables, `truststorePath`
    and `truststorePassword`. The first one is referencing the path of our `client-truststore.ts`
    file located in the configuration folder of our JBoss. You should change the value
    of this variable in order to make this test work, so place the path of your configuration
    folder. After this, with a method we already explained, `loadKeyStore ()`, we
    load the KeyStore using the previous variables and we assign this value to a `KeyStore`
    object named `truststore`. From `truststore`, we create the `RestEasyClient` object
    named `client`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解释前面的代码，首先，我们有两个变量，`truststorePath`和`truststorePassword`。第一个引用了我们的JBoss配置文件夹中`client-truststore.ts`文件的路径。您应该更改这个变量的值，以使此测试工作，因此请放置您的配置文件夹的路径。之后，通过我们已经解释的方法`loadKeyStore()`，我们使用前面的变量加载KeyStore，并将这个值分配给一个名为`truststore`的`KeyStore`对象。从`truststore`，我们创建了名为`client`的`RestEasyClient`对象。
- en: Now, we will obtain an access token programmatically, so we can request an access
    token from the auth-server simply by using HTTPS invocation. Then we have to use
    basic authentication to identify our user; as a result, we will get back a signed
    access token for that user.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将以编程方式获取访问令牌，因此我们可以通过使用HTTPS调用简单地从auth-server请求访问令牌。然后我们必须使用基本身份验证来识别我们的用户；结果，我们将获得该用户的签名访问令牌。
- en: So, we perform a simple `POST` to the context root of the auth-server with `j_oauth_token_grant`
    at the end of the target URL, because when we use that URL and a `POST` with basic
    authentication, we will obtain an access token for a specific user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们对auth-server的上下文根执行简单的`POST`，在目标URL的末尾加上`j_oauth_token_grant`，因为当我们使用该URL和基本身份验证时，我们将为特定用户获取访问令牌。
- en: 'After that, we obtained the access token, which is a simple string. In order
    to invoke on a service protected by bearer token authentication, we have to build
    a string made up of the authorization header of your `HTTPS` request plus the
    string `Bearer` and finally the access token string. This will get back the response
    object, so we can read it and print it as we did in the test. In the console,
    you will see the list of compact discs as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们获得了访问令牌，这是一个简单的字符串。为了调用受持有者令牌身份验证保护的服务，我们必须构建一个字符串，由您的`HTTPS`请求的授权标头加上字符串`Bearer`和最后的访问令牌字符串组成。这将返回响应对象，因此我们可以读取它并像在测试中那样打印它。在控制台中，您将看到如下截图中显示的紧凑光盘列表：
- en: '![Running the application](img/0109OS_04_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: 运行应用程序
- en: SSO configuration for security management
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全管理的SSO配置
- en: SSO is a mechanism for authentication. It allows a user to access several systems
    or applications entering credentials just once. We think you experience this more
    often these days because we are living in a social network era, and most of these
    services let us use each other's credentials to access several services.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SSO是一种身份验证机制。它允许用户只需输入一次凭据即可访问多个系统或应用程序。我们认为您这些天更经常经历这种情况，因为我们生活在一个社交网络时代，大多数这些服务都让我们使用彼此的凭据来访问多个服务。
- en: After discussing some concepts of SSO, let's try and implement this mechanism.
    In order to achieve this, we will use JBoss 7 Application Server and our earlier
    project `secure-demo`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了SSO的一些概念之后，让我们尝试并实现这种机制。为了实现这一点，我们将使用JBoss 7应用服务器和我们之前的项目`secure-demo`。
- en: As a brief introduction to this implementation, we want to tell you that we
    will work with two files; one file belongs to JBoss and the other belongs to our
    application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对这个实现的简要介绍，我们想告诉您，我们将使用两个文件；一个文件属于JBoss，另一个文件属于我们的应用程序。
- en: 'The file that belongs to JBoss is `standalone.xml`. We will add some lines
    to this file. In the following lines of code, let''s add the SSO element in the
    `virtual-server` definition:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 属于JBoss的文件是`standalone.xml`。我们将向该文件添加一些行。在以下代码行中，让我们在`virtual-server`定义中添加SSO元素：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `reauthenticate` attribute allows us to establish whether each request needs
    to be reauthenticated to `securityReal`. The default value is `false`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`reauthenticate`属性允许我们确定每个请求是否需要重新对`securityReal`进行重新身份验证。默认值为`false`。'
- en: 'The next file we must edit is in our application, and its name is `jboss-web.xml`.
    Also, we need to add some lines of code to this file. These lines of code will
    declare the valve that will manage the SSO. In other words, every request will
    go through this valve, as shown in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编辑的下一个文件是我们的应用程序中的`jboss-web.xml`。此外，我们需要向该文件添加一些代码行。这些代码行将声明将管理SSO的阀门。换句话说，每个请求都将通过此阀门，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just in case you forgot it or deleted it, we set a security domain in the previous
    chapters. The following block of code must exist in the `standalone.xml` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以防您忘记或删除它，我们在前几章中设置了一个安全域。以下代码块必须存在于`standalone.xml`文件中：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since we are using the `secure-demo` example, this is all we must modify in
    order to configure SSO.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用`secure-demo`示例，这是我们必须修改的所有内容，以配置SSO。
- en: In order to test this mechanism, we need another application. We must replicate
    the configuration we just did in our `secure-demo` example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这种机制，我们需要另一个应用程序。我们必须复制我们刚刚在`secure-demo`示例中进行的配置。
- en: When we enter the credentials in one of them, we no longer need to enter the
    credentials in the others, since we have applied SSO. We will authenticate in
    both applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在其中一个中输入凭据时，我们不再需要在其他中输入凭据，因为我们已经应用了SSO。我们将在两个应用程序中进行身份验证。
- en: OAuth token via Basic Auth
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过基本身份验证获取OAuth令牌
- en: Now, let's explore and implement a short example of using tokens. In order to
    build this example, we will create a class. This class, as in the previous example,
    will simulate a database client. It will have the same method, `getCompactDiscs()`,
    but we will modify the internal function in this example. Also, it won't receive
    any parameter this time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索并实现一个使用令牌的简短示例。为了构建这个示例，我们将创建一个类。这个类，就像前面的示例一样，将模拟一个数据库客户端。它将具有相同的方法`getCompactDiscs()`，但是这次我们将修改这个示例中的内部函数。此外，这次它不会接收任何参数。
- en: 'Alright, let''s do it! First, create two static string fields in the class.
    The first field will hold the URL for authentication in the auth-server. The other
    field will have the URL showing the compact discs list; you can reuse the same
    web page from the previous example. Then, you should have your variables as shown:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们开始吧！首先，在类中创建两个静态字符串字段。第一个字段将保存auth-server中的认证URL。另一个字段将有显示紧凑光盘列表的URL；您可以重用之前示例中相同的网页。然后，您的变量应该如下所示：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After this, let''s create our method to obtain the compact discs list. The
    following piece of code shows you exactly how the method is executed:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们创建获取紧凑光盘列表的方法。以下代码片段向您展示了方法的执行方式：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is time to check what we have just done. As a first step, we created a `ResteasyClient`
    object. If you noticed, we used something to disable trust management and hostname
    verification. The result of this invocation is that it turns off server-certificate
    verification allowing MITM (man-in-the-middle) attacks. So, use this feature with
    caution.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候检查我们刚刚做了什么。首先，我们创建了一个`ResteasyClient`对象。如果您注意到了，我们使用了一些东西来禁用信任管理和主机名验证。这个调用的结果是关闭服务器证书验证，允许中间人攻击。因此，请谨慎使用此功能。
- en: After this, we create a `form` object and pass in some parameters. These parameters
    are passed in through the `param()` method, representing the parameter name and
    parameter value, respectively. This means we specify the type of grant being requested
    by the application, which will be `client_credentials`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了一个`form`对象并传入一些参数。这些参数通过`param()`方法传入，分别表示参数名和参数值。这意味着我们指定了应用程序请求的授权类型，这将是`client_credentials`。
- en: Then, as we did before in the previous example, let's create a RESTEasy web
    target that will target our URL showing the compact discs list. Remember that
    this URL was set in a static field we created earlier. This web target will be
    the `resourceTarget` object that we will access.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像我们之前在之前的示例中所做的那样，让我们创建一个RESTEasy web目标，将目标对准显示紧凑光盘列表的URL。请记住，这个URL是我们之前创建的一个静态字段中设置的。这个web目标将是我们将要访问的`resourceTarget`对象。
- en: When we use the `register()` method and pass in a `BasicAuthentication` object,
    we register an instance of a custom JAX-RS component to be instantiated and used
    in the scope of this configurable context.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`register()`方法并传入一个`BasicAuthentication`对象时，我们注册了一个自定义的JAX-RS组件实例，以在可配置的上下文范围内被实例化和使用。
- en: Moving forward, we create the `AccessTokenResponse` class by executing a request
    to our web target. Then, in the same line, we execute a post in order to send
    the entity and the response type we want to obtain for the current request synchronously.
    The `Entity.form()` method creates the `application/x-www-form-urlencoded` entity
    from the `form` object we created before. Now, this will return an `AccessTokenResponse`
    object; we use this object to build the bearer token by adding the word `Bearer`
    at the beginning of the token.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过对我们的web目标执行请求，创建`AccessTokenResponse`类。然后，在同一行中，我们执行一个post请求，以便同步发送实体和我们想要获取的响应类型。`Entity.form()`方法从我们之前创建的`form`对象中创建`application/x-www-form-urlencoded`实体。现在，这将返回一个`AccessTokenResponse`对象；我们使用这个对象通过在令牌的开头添加`Bearer`一词来构建令牌。
- en: Finally, let's create the response object by executing a request to the URL
    that is set in the `urlDiscs` variable. We should use the `ResteasyClient` object
    to target this resource, and then execute the request and set the headers field
    with `HttpHeaders.AUTHORIZATION` using the `bearer` token set in the variable
    `bearerToken`. In this way, we gain access to the target resource; in this case,
    we can see the information.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过执行对`urlDiscs`变量中设置的URL的请求，让我们创建响应对象。我们应该使用`ResteasyClient`对象来对准这个资源，然后执行请求，并使用`HttpHeaders.AUTHORIZATION`将头字段设置为使用变量`bearerToken`中设置的`bearer`令牌。这样，我们就可以访问目标资源；在这种情况下，我们可以看到信息。
- en: As we keep using the same application business, we can reuse the web pages of
    the previous example. Make sure to incorporate in to your example, in the same
    path as in the previous example, the web pages `index.html` and `discsList.jsp`.
    We will also use the configuration set in the `jboss-deployment-structure.xml`
    file since we are using the same module dependencies.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们继续使用相同的应用业务，我们可以重用之前示例中的网页。确保在您的示例中，与之前示例中相同的路径中，包含网页`index.html`和`discsList.jsp`。我们还将使用`jboss-deployment-structure.xml`文件中设置的配置，因为我们使用相同的模块依赖关系。
- en: 'Our `web.xml` file should look simpler than the previous example, so it might
    be something like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`web.xml`文件应该比之前的示例看起来更简单，可能是这样的：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running the application
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: You can download the complete code and configuration from [https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04).
    Unzip the file, and inside you will find a folder named `token-grant`. You have
    to deploy this project using the same commands. As a requirement, you have to
    deploy the projects `oauth-server`, `oauth-client`, and `discstore`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)下载完整的代码和配置。解压文件，里面会有一个名为`token-grant`的文件夹。您必须使用相同的命令部署这个项目。作为要求，您必须部署`oauth-server`、`oauth-client`和`discstore`这些项目。
- en: 'It is time to run our application. Let''s execute the steps we did in the previous
    example, the OAuth example. After this, we have to open our favorite browser and
    type the URL `https://localhost:8443/token-grant/`. This will lead us to the following
    web page:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是运行我们的应用程序的时候了。让我们执行在之前示例中OAuth示例中所做的步骤。之后，我们必须打开我们喜欢的浏览器，输入URL`https://localhost:8443/token-grant/`。这将引导我们到以下网页：
- en: '![Running the application](img/0109OS_04_03.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/0109OS_04_03.jpg)'
- en: 'Well, as you notice, we reused the same web page, just for the purpose of these
    examples. There is, however, a little difference; when calling a different web
    page, you can look in the core we just explained. This will execute a token, where
    we will perform a request to the data we want to access through this token. As
    a result, we will read the list of our compact discs in the web page, as shown
    in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，正如你所注意到的，我们重复使用了同一个网页，只是为了这些例子的目的。然而，有一个小区别；当调用不同的网页时，你可以查看我们刚刚解释的核心。这将执行一个令牌，通过这个令牌，我们将执行一个请求，以访问我们想要访问的数据。结果，我们将在网页中读取我们的紧凑光盘列表，如下面的屏幕截图所示：
- en: '![Running the application](img/0109OS_04_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/0109OS_04_04.jpg)'
- en: The final result is the capability to present the discs list in the web page.
    However, don't forget what happened; we just obtained an access token response
    using the request, the basic authentication with our credentials, and a form.
    With the access token response, we can create the response and present the data
    with the respective authorization.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是能够在网页中呈现光盘列表。然而，不要忘记发生了什么；我们只是使用请求、基本身份验证和一个表单获得了访问令牌响应。有了访问令牌响应，我们可以创建响应并呈现具有相应授权的数据。
- en: Custom filters
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义过滤器
- en: 'As a brief introduction, JAX-RS 2.0 has two different concepts for interceptions:
    filters and interceptors.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 简要介绍一下，JAX-RS 2.0有两种不同的拦截概念：过滤器和拦截器。
- en: 'Interceptors are components that intercept EJB method invocations. They can
    be used to audit and log as and when EJBs are accessed. This is a topic that won''t
    be included in this book, but if you feel curious and want to find out some more
    about it, we give you the following links as references so you can look it up:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截器是拦截EJB方法调用的组件。它们可以用于审计和记录EJB被访问的时间。这是本书不包括的一个主题，但如果你感到好奇，想要了解更多，我们给你以下链接作为参考，这样你就可以查找：
- en: '[http://docs.oracle.com/javaee/6/tutorial/doc/gkigq.html](http://docs.oracle.com/javaee/6/tutorial/doc/gkigq.html)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.oracle.com/javaee/6/tutorial/doc/gkigq.html](http://docs.oracle.com/javaee/6/tutorial/doc/gkigq.html)'
- en: '[http://www.javacodegeeks.com/2013/07/java-ee-ejb-interceptors-tutorial-and-example.html](http://www.javacodegeeks.com/2013/07/java-ee-ejb-interceptors-tutorial-and-example.html)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.javacodegeeks.com/2013/07/java-ee-ejb-interceptors-tutorial-and-example.html](http://www.javacodegeeks.com/2013/07/java-ee-ejb-interceptors-tutorial-and-example.html)'
- en: Filters are mainly used to alter or process incoming and outgoing request or
    response headers. They can be executed before and after request and response processing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器主要用于更改或处理传入和传出的请求或响应头。它们可以在请求和响应处理之前和之后执行。
- en: 'Also, JAX-RS 2.0 offers us two categories of filters: server-side filters and
    client-side filters. The following diagram shows us a better classification of
    this concept:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JAX-RS 2.0为我们提供了两类过滤器：服务器端过滤器和客户端端过滤器。以下图表向我们展示了这个概念的更好分类：
- en: '![Custom filters](img/0109OS_04_05.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![自定义过滤器](img/0109OS_04_05.jpg)'
- en: Server-side filters
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端过滤器
- en: 'When we are on the server side, we have another classification for these filters;
    container request filters are executed before the JAX-RS resource method is invoked.
    Also, we have the container response filters; you''ve probably guessed, they are
    executed after the JAX-RS resource method is invoked. However, this doesn''t end
    here; there is another classification of container request filters: pre-matching
    and post-matching.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在服务器端时，这些过滤器有另一种分类；容器请求过滤器在调用JAX-RS资源方法之前执行。此外，我们还有容器响应过滤器；你可能已经猜到，它们在调用JAX-RS资源方法之后执行。然而，这并不是结束；容器请求过滤器还有另一种分类：预匹配和后匹配。
- en: You can specify a pre-matching container request filter through the `@PreMatching`
    annotation, and this means that the filter will be executed before the JAX-RS
    resource method is matched with the incoming HTTP request.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`@PreMatching`注解指定一个预匹配容器请求过滤器，这意味着过滤器将在与传入的HTTP请求匹配JAX-RS资源方法之前执行。
- en: Container request filters can abort the request by executing the `abortWith
    (Response)` method. A filter might want to abort if it implements a custom authentication
    protocol.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 容器请求过滤器可以通过执行`abortWith (Response)`方法来中止请求。如果过滤器实现了自定义身份验证协议，它可能希望中止请求。
- en: Once the resource class method has been executed, JAX-RS will run all container
    response filters. These filters let you modify the outgoing response before it
    is marshalled and is sent to the client.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦资源类方法被执行，JAX-RS将运行所有容器响应过滤器。这些过滤器允许您在它被编组并发送到客户端之前修改传出响应。
- en: Client-side filters
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端过滤器
- en: 'As we already told you, there are filters on the client side too, and similar
    to the server-side filters, they also have two types of filters: client request
    filters and client response filters. Client request filters are executed before
    your HTTP request is sent over the wire to the server. On the other hand, client
    response filters run after a response is received from the server, but before
    the response body is assembled.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经告诉过你的，客户端端也有过滤器，与服务器端过滤器类似，它们也有两种类型的过滤器：客户端请求过滤器和客户端响应过滤器。客户端请求过滤器在将HTTP请求发送到服务器之前执行。另一方面，客户端响应过滤器在从服务器接收响应后执行，但在组装响应主体之前执行。
- en: Client request filters are also capable of aborting the request and providing
    a response without going over the wire to the server. Client response filters
    are capable of altering the response object before it is handed back to the application
    code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端请求过滤器也能够中止请求，并在不经过服务器的情况下提供响应。客户端响应过滤器能够在将响应主体组装之前修改响应对象。
- en: Example usage of filters
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器的示例用法
- en: After looking at some of the necessary theory around this topic, it is time
    to get your feet wet. Now, we will implement an example in order to support our
    new theoretical knowledge. So, let's start!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在看了一些关于这个主题的必要理论之后，现在是时候让你亲自动手了。现在，我们将实现一个例子，以支持我们的新理论知识。所以，让我们开始吧！
- en: 'We will implement an interceptor that will verify the access permissions for
    a user, based on the username and password sent in the request. You can download
    the complete code of this example from the following link:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个拦截器，它将根据请求中发送的用户名和密码验证用户的访问权限。您可以从以下链接下载这个示例的完整代码：
- en: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04](https://github.com/restful-java-web-services-security/source-code/tree/master/chapter04)'
- en: 'We have the topic of our compact discs store. So, the following class will
    represent our service, and it will have the functions to find the compact discs
    by name and update the compact disc information. The annotations used here have
    already been studied in the previous chapter, so you will probably find the following
    code understandable:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的紧凑碟商店的主题。因此，以下类将代表我们的服务，并且它将具有按名称查找紧凑碟和更新紧凑碟信息的功能。这里使用的注解已经在前一章中学习过，所以您可能会发现以下代码易于理解：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we have created only two methods, one to retrieve compact discs
    by name and the other to update the compact discs' price. The annotations let
    us know that the method `getCompactDiscByName()` can be accessed and executed
    by all; meanwhile, the method `updatePriceByDiscName()` can be accessed and executed
    by users with the role `ADMIN`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只创建了两个方法，一个用于按名称检索紧凑碟，另一个用于更新紧凑碟的价格。注解让我们知道方法`getCompactDiscByName()`可以被所有人访问和执行；与此同时，方法`updatePriceByDiscName()`只能被具有`ADMIN`角色的用户访问和执行。
- en: 'If you noticed in the preceding code, we used the class `CompactDiscDatabase`,
    which simulates a database. We applied the same technique in the previous examples.
    As it worked very well, let''s do it again. This class doesn''t have any special
    code. You can get an idea about this from the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到前面的代码中，我们使用了类`CompactDiscDatabase`，它模拟了一个数据库。我们在之前的示例中应用了相同的技术。由于它运行得非常好，让我们再做一次。这个类没有任何特殊的代码。您可以从以下代码中了解到这一点：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is nothing complex here; we just created a map and put one entry there.
    This entry is a compact disc object, as you can tell. We have two static methods
    that will simulate queries—a SELECT statement and an UPDATE statement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么复杂的；我们只是创建了一个映射并放置了一个条目。这个条目是一个紧凑碟对象，正如您所看到的。我们有两个静态方法，将模拟查询——一个SELECT语句和一个UPDATE语句。
- en: 'Now, let''s check our `CompactDisc` class, as shown in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们的`CompactDisc`类，如下所示的代码：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this class, we just set the fields that represent a common compact disc attribute.
    The annotation `@XmlElement` is used to map a property to an XML element derived
    from a property name.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们只设置了代表常见紧凑碟属性的字段。注解`@XmlElement`用于将属性映射到从属性名称派生的XML元素。
- en: Now, it is time to implement the filter. We will show you the code after this
    short introduction, explain what we have done, and explain some technical concepts
    used in the implementation. Ready? Here we go!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现过滤器了。我们将在这个简短的介绍之后展示代码，解释我们所做的事情，并解释实现中使用的一些技术概念。准备好了吗？我们开始吧！
- en: 'Since the code of this class is a little bit long, we will split it and include
    a short description after each block of code, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类的代码有点长，我们将把它分开，并在每个代码块后包含一个简短的描述，如下所示：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's check out this code. The first step, in order to implement a filter, is
    the annotation `@Provider`. When we place this annotation at class level, we set
    the class as a filter. Our class name is `SecurityFilter`, and as you can see,
    it implements the interface `ContainerRequestFilter`. If you remember, this filter
    will execute on the server side and before the resource method is invoked.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码。为了实现一个过滤器，第一步是注解`@Provider`。当我们在类级别放置这个注解时，我们将该类设置为过滤器。我们的类名是`SecurityFilter`，正如您所看到的，它实现了接口`ContainerRequestFilter`。如果您记得的话，这个过滤器将在服务器端执行，并在资源方法被调用之前执行。
- en: At the start of our class's body, we set some constants that we will use later.
    The `AUTHORIZATION_PROPERTY` constant represents just the name of a property,
    as does the `RESOURCE_METHOD_INVOKER` constant. The `AUTHENTICATION_SCHEME` constant
    represents just a string. Both `ACCESS_DENIED` and `ACCESS_FORBIDDEN` constants
    represent two different server response objects in order to notify the user of
    the result of their request when it is denied or the user doesn't have enough
    permission.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类主体开始时，我们设置了一些稍后将使用的常量。`AUTHORIZATION_PROPERTY`常量只代表一个属性的名称，`RESOURCE_METHOD_INVOKER`常量也是如此。`AUTHENTICATION_SCHEME`常量只代表一个字符串。`ACCESS_DENIED`和`ACCESS_FORBIDDEN`常量代表两种不同的服务器响应对象，以便在请求被拒绝或用户没有足够权限时通知用户其请求的结果。
- en: As we implemented the interface `ContainerRequestFilter`, we must override the
    `filter()` method. It is inside this method that we will put our logic for the
    purpose of filtering the request based on the user that executed the request.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实现了接口`ContainerRequestFilter`，我们必须重写`filter()`方法。就是在这个方法中，我们将根据执行请求的用户来放置我们的逻辑，以便过滤请求。
- en: 'Let''s start. As a first step, we obtain the method of the request using the
    constant `RESOURCE_METHOD_INVOKER`. After this, we will have a `ResourceMethodInvoker`
    object, and then the `Method` object, as shown in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始。作为第一步，我们使用常量`RESOURCE_METHOD_INVOKER`获取请求的方法。之后，我们将拥有一个`ResourceMethodInvoker`对象，然后是`Method`对象，如下所示：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will perform some simple validations over `method`. We will check
    whether the method is annotated with `@PermitAll`. If it isn''t, then the method
    continues, and we check whether it is annotated with `@DenyAll`. If the method
    is annotated with `DenyAll`, then we abort the request, including the constant
    `ACCESS_FORBIDDEN`, as shown in the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对`method`执行一些简单的验证。我们将检查方法是否带有`@PermitAll`注解。如果没有，那么方法继续执行，我们将检查它是否带有`@DenyAll`注解。如果方法带有`DenyAll`注解，那么我们将中止请求，包括常量`ACCESS_FORBIDDEN`，如下所示的代码：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we have to obtain the username and password. We must first obtain the
    headers of the request and put it in a map. Then, we obtain the authorization
    string list using `constant AUTHORIZATION_PROPERTY` as a key. This list will let
    us know whether the user has enough permission or not. So, we check if the list
    is empty or null; if it enters the `if()` block, we abort the request, including
    the constant `ACCESS_DENIED`, as shown in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须获取用户名和密码。我们必须首先获取请求的头，并将其放入一个映射中。然后，我们使用`常量AUTHORIZATION_PROPERTY`作为键获取授权字符串列表。这个列表将告诉我们用户是否有足够的权限。因此，我们检查列表是否为空或为null；如果进入`if()`块，我们将中止请求，包括常量`ACCESS_DENIED`，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This list has the encoded username and password as a string in the first element.
    So, we execute a replacement and eliminate the string contained in the constant
    `AUTHENTICATION_SCHEME`. Then, we decode it using the `Base64.decodeBase64` decoder,
    and through `StringTokenizer`, we obtain the username and password separated.
    Let''s look at the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表的第一个元素是编码后的用户名和密码字符串。因此，我们执行替换并消除常量`AUTHENTICATION_SCHEME`中包含的字符串。然后，我们使用`Base64.decodeBase64`解码器对其进行解码，并通过`StringTokenizer`获取分开的用户名和密码。让我们看一下下面的代码：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now is the time to evaluate and check whether the user has enough permission.
    First, let''s check whether `method` has the `@RolesAllowed` annotation; if it
    does, we obtain the set of roles allowed using the object `method`. Finally, we
    check whether the constant `ADMIN` is included in this list. If it is not, the
    request is aborted and `ACCESS_DENIED` is once again included, as shown in the
    following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候评估和检查用户是否有足够的权限了。首先，让我们检查`method`是否具有`@RolesAllowed`注解；如果有，我们使用`method`对象获取允许的角色集合。最后，我们检查常量`ADMIN`是否包含在此列表中。如果没有，请求将被中止，并且`ACCESS_DENIED`将再次包含在其中，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we studied and implemented one of the most useful and necessary
    techniques with the purpose of sharing and protecting our information. Nowadays,
    applications have dramatically increased their interaction with each other because
    they want to meet and satisfy the requirements of clients, users, and so on, compromising
    neither the security nor the integrity of the data while doing this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们研究并实施了一种最有用和必要的技术，目的是共享和保护我们的信息。如今，应用程序之间的相互作用大大增加，因为它们希望满足客户、用户等的要求，而在此过程中既不损害数据的安全性也不损害数据的完整性。
- en: In this chapter, we studied several technologies to secure, limit, and authorize
    the use of our resources to a third-party application, starting with brief but
    descriptive concepts about OAuth 2.0 authentication, Single Sign-On, filters,
    and tokens.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们研究了几种技术，用于保护、限制和授权第三方应用程序使用我们的资源，从OAuth 2.0认证、单点登录、过滤器和令牌的简要但描述性概念开始。
- en: Through a practical example and real code, you witnessed how you can grant permission
    over specific resources to a third-party application in order to share the information
    and maintain control over it. Also, we checked and worked with specific code to
    implement one of the most used technologies in recent times, especially in the
    world of social networks, Single Sign-On. Now, you can put in to practice these
    concepts and technologies in order to build applications to interact with each
    other, selecting which resource you want to be shared, which applications you
    want to use as Single Sign-On, and filtering the use of certain resources based
    on the user and role.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个实际的例子和真实的代码，您可以看到如何授予第三方应用程序对特定资源的权限，以便共享信息并保持对其的控制。此外，我们检查并使用特定代码来实现最近使用的技术之一，特别是在社交网络世界中使用的单点登录。现在，您可以将这些概念和技术付诸实践，以便构建应用程序相互交互，选择要共享的资源，要用作单点登录的应用程序以及基于用户和角色的资源使用进行过滤。
