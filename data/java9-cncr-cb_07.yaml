- en: Concurrent Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发集合
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using non-blocking thread-safe deques
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非阻塞线程安全的双端队列
- en: Using blocking thread-safe deques
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程安全的阻塞双端队列
- en: Using blocking thread-safe queue ordered by priority
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用按优先级排序的线程安全队列
- en: Using thread-safe lists with delayed elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有延迟元素的线程安全列表
- en: Using thread-safe navigable maps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程安全的可导航映射
- en: Using thread-safe HashMaps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程安全的HashMap
- en: Using atomic variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子变量
- en: Using atomic arrays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子数组
- en: Using the volatile keyword
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`volatile`关键字
- en: Using variable handles
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量句柄
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Data structure** is a basic element of programming. Almost every program
    uses one or more types of data structure to store and manage data. The Java API
    provides the **Java Collections framework**. It contains interfaces, classes,
    and algorithms that implement a lot of different data structures that you can
    use in your programs.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据结构**是编程的基本元素。几乎每个程序都使用一种或多种数据结构来存储和管理数据。Java API提供了**Java 集合框架**。它包含接口、类和算法，实现了许多不同的数据结构，您可以在程序中使用。'
- en: When you need to work with data collections in a concurrent program, you must
    be very careful with the implementation you choose. Most collection classes do
    not work with concurrent applications because they can't control concurrent access
    to their data. If a concurrent task shares a data structure that is unable to
    work with another concurrent task, you might have data inconsistency errors that
    will affect the operation of the program. One example of this kind of data structure
    is the `ArrayList` class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在并发程序中处理数据集合时，您必须非常小心地选择实现方式。大多数集合类不适用于并发应用程序，因为它们无法控制对它们数据的并发访问。如果一个并发任务共享一个无法与其他并发任务一起工作的数据结构，您可能会遇到数据不一致错误，这将影响程序的操作。这类数据结构的一个例子是`ArrayList`类。
- en: 'Java provides data collection processes that you can use in your concurrent
    programs without any problems or inconsistency. Basically, Java provides two kinds
    of collections to use in concurrent applications:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了数据收集过程，您可以在并发程序中使用而不会出现任何问题或不一致。基本上，Java提供了两种类型的集合用于并发应用程序：
- en: '**Blocking collections**: This kind of collection includes operations to add
    and remove data. If the operation can''t be done immediately, because the collection
    is either full or empty, the thread that makes the call will be blocked until
    the operation could be carried out.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻塞集合**：这类集合包括添加和删除数据操作。如果操作不能立即完成，因为集合已满或为空，发起调用的线程将阻塞，直到操作可以执行。'
- en: '**Non-blocking collections**: This kind of collection also includes operations
    to add and remove data. But in this case, if the operation can''t be done immediately,
    it returns a `null` value or throws an exception; the thread that makes the call
    won''t be blocked here.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞集合**：这类集合也包括添加和删除数据操作。但在此情况下，如果操作不能立即完成，它将返回一个`null`值或抛出异常；发起调用的线程将不会在此处阻塞。'
- en: 'Through the recipes in this chapter, you will learn how to use some Java collections
    in your concurrent applications. These include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章中的食谱，您将学习如何在并发应用程序中使用一些Java集合。这些包括：
- en: Non-blocking deques, using the `ConcurrentLinkedDeque` class
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ConcurrentLinkedDeque`类的非阻塞双端队列
- en: Blocking deques, using the `LinkedBlockingDeque` class
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`LinkedBlockingDeque`类的阻塞双端队列
- en: Blocking queues to be used with producers and consumers of data, using the `LinkedTransferQueue`
    class
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于数据生产者和消费者的阻塞队列，使用`LinkedTransferQueue`类
- en: Blocking queues that order elements by priority, using the `PriorityBlockingQueue`
    class
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PriorityBlockingQueue`类按优先级排序的阻塞队列
- en: Blocking queues with delayed elements, using the `DelayQueue` class
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有延迟元素的阻塞队列，使用`DelayQueue`类
- en: Non-blocking navigable maps, using the `ConcurrentSkipListMap` class
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ConcurrentSkipListMap`类的非阻塞可导航映射
- en: Non-blocking hash tables, using the `ConcurrentHashMap` class
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ConcurrentHashMap`类的非阻塞哈希表
- en: Atomic variables, using the `AtomicLong` and `AtomicIntegerArray` classes
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AtomicLong`和`AtomicIntegerArray`类进行原子变量
- en: Variables stored in fields marked with the `volatile` keyword
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`volatile`关键字标记的字段存储的变量
- en: Atomic operations on the fields of individual classes, using variable handles.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个类的字段上执行原子操作，使用变量句柄。
- en: Using non-blocking thread-safe deques
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非阻塞线程安全的双端队列
- en: '"List" is referred to as the most basic collection. It has an undetermined
    number of elements, and you can add, read, or remove an element from any position.
    Concurrent lists allow various threads to add or remove elements from the list
    at a time, without producing any data inconsistency errors. Similar to lists,
    we have deques. A deque is a data structure similar to a queue, but in a deque,
    you can add or remove elements from either the front (head) or back (tail).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “列表”被称为最基本的数据集合。它包含不确定数量的元素，你可以从任何位置添加、读取或移除一个元素。并发列表允许各种线程同时向列表添加或移除元素，而不会产生任何数据不一致错误。类似于列表，我们还有双端队列。双端队列是一种类似于队列的数据结构，但在双端队列中，你可以从前面（头部）或后面（尾部）添加或移除元素。
- en: In this recipe, you will learn how to use a non-blocking deque in a concurrent
    program. Non-blocking deques provide operations that, if not done immediately
    (for example, you want to get an element from a list but the list is empty), throw
    an exception or return a `null` value, depending on the operation. Java 7 introduced
    the `ConcurrentLinkedDeque` class that implements a non-blocking concurrent deque.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何在并发程序中使用非阻塞双端队列。非阻塞双端队列提供操作，如果立即不执行（例如，你想从列表中获取一个元素，但列表为空），则抛出异常或返回`null`值，具体取决于操作。Java
    7引入了`ConcurrentLinkedDeque`类，该类实现了一个非阻塞的并发双端队列。
- en: 'We are going to implement an example with the following two different tasks:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现以下两个不同任务的示例：
- en: One that adds thousands of elements to the deque
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向双端队列添加数千个元素
- en: One that removes data from the deque
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从双端队列中移除数据
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement the example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `AddTask` and specify that it implements the `Runnable`
    interface:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AddTask`的类并指定它实现`Runnable`接口：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a private `ConcurrentLinkedDeque` attribute parameterized by the `String`
    class named `list`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`list`的私有`ConcurrentLinkedDeque`属性，由`String`类参数化：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Implement the `run()` method of the class. This method will have a loop with
    5000 cycles. In each cycle, we will take the first and last elements of the deque
    so we will take a total of 10,000 elements:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的`run()`方法。该方法将有一个5000次的循环。在每个循环中，我们将从双端队列中取出第一个和最后一个元素，因此我们将取出总共10,000个元素：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a class named `PollTask` and specify that it implements the `Runnable`
    interface:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PollTask`的类并指定它实现`Runnable`接口：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare a private `ConcurrentLinkedDeque` attribute parameterized by the `String`
    class named `list`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`list`的私有`ConcurrentLinkedDeque`属性，由`String`类参数化：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the `run()` method of the class. It takes out 10,000 elements of
    the deque in a loop with 5,000 steps, taking off two elements in each step:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的`run()`方法。它通过循环以5,000步取出双端队列中的10,000个元素，每步移除两个元素：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a `ConcurrentLinkedDeque` object parameterized by the `String` class
    named `list`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个由`String`类参数化的名为`list`的`ConcurrentLinkedDeque`对象：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create an array of 100 `Thread` objects named `threads`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`threads`的100个`Thread`对象数组：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create 100 `AddTask` objects and threads to run each one of them. Store every
    thread in the array created earlier and start them:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建100个`AddTask`对象和线程来运行它们中的每一个。将每个线程存储在之前创建的数组中并启动它们：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wait for the completion of the threads using the `join()` method:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待线程的完成：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Write the size of the list in the console:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出列表的大小：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create 100 `PollTask` objects and threads to run each one of them. Store every
    thread in the array created earlier and start them:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建100个`PollTask`对象和线程来运行它们中的每一个。将每个线程存储在之前创建的数组中并启动它们：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Wait for the finalization of the threads using the `join()` method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待线程的最终化：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Write the size of the list in the console:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出列表的大小：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we used the `ConcurrentLinkedDeque` object parameterized by
    the `String` class to work with a non-blocking concurrent deque of data. The following
    screenshot shows the output of an execution of this example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了由 `String` 类参数化的 `ConcurrentLinkedDeque` 对象来处理非阻塞的并发数据双端队列。以下截图显示了此示例的执行输出：
- en: '![](img/00043.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00043.jpeg)'
- en: First, you executed 100 `AddTask` tasks to add elements to the list. Each one
    of these tasks inserts 10,000 elements to the list using the `add()` method. This
    method adds new elements at the end of the deque. When all the tasks had finished,
    you wrote the number of elements of the deque in the console. At that moment,
    the deque had 1,000,000 elements.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你执行了100个 `AddTask` 任务向列表中添加元素。每个任务使用 `add()` 方法向列表中插入10,000个元素。此方法将新元素添加到双端队列的末尾。当所有任务完成后，你在控制台输出了双端队列的元素数量。那时，双端队列有1,000,000个元素。
- en: Then, you executed 100 `PollTask` tasks to remove elements from the deque. Each
    one of these tasks removes 10,000 elements from the deque using the `pollFirst()`
    and `pollLast()` methods. The `pollFirst()` method returns and removes the first
    element of the deque, and the `pollLast()` method returns and removes the last
    element of the deque. If the deque is empty, they return a `null` value. When
    all the tasks had finished, you wrote the number of elements of the deque in the
    console. At that moment, the list had zero elements. Take into account that the
    `ConcurrentLinkedDeque` data structure doesn't allow you to add `null` values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你执行了100个 `PollTask` 任务从双端队列中移除元素。每个任务使用 `pollFirst()` 和 `pollLast()` 方法从双端队列中移除10,000个元素。`pollFirst()`
    方法返回并移除双端队列的第一个元素，而 `pollLast()` 方法返回并移除双端队列的最后一个元素。如果双端队列为空，它们返回一个 `null` 值。当所有任务完成后，你在控制台输出了双端队列的元素数量。那时，列表中的元素数量为零。请注意，`ConcurrentLinkedDeque`
    数据结构不允许你添加 `null` 值。
- en: To write the number of elements in the deque, you used the `size()` method.
    You have to take into account that this method can return a value that is not
    real, especially if you use it when there are threads adding to or deleting data
    from the list. The method has to traverse the entire deque to count the elements,
    and the contents of the list can change with this operation. Only if you use them
    when there aren't any threads modifying the deque, you will have the guarantee
    that the returned result would be correct.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入双端队列中的元素数量，你使用了 `size()` 方法。你必须考虑到，此方法可能返回一个非实际值，特别是当你使用它在有线程向列表添加或从列表删除数据时。该方法必须遍历整个双端队列来计数元素，并且列表的内容可能会因为此操作而改变。只有在你使用它们而没有线程修改双端队列时，你才能保证返回的结果是正确的。
- en: There's more...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The `ConcurrentLinkedDeque` class provides more methods to get elements from
    the deque:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedDeque` 类提供了更多方法来从双端队列中获取元素：'
- en: '`getFirst()` and `getLast()`: These methods return the first and last element
    from the deque, respectively. They don''t remove the returned element from the
    deque. If the deque is empty, they throw a `NoSuchElementExcpetion` exception.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFirst()` 和 `getLast()`: 这些方法分别从双端队列中返回第一个和最后一个元素。它们不会从双端队列中移除返回的元素。如果双端队列为空，它们会抛出
    `NoSuchElementExcpetion` 异常。'
- en: '`peek()`, `peekFirst()`, and `peekLast()`: These methods return the first and
    the last element of the deque, respectively. They don''t remove the returned element
    from the deque. If the deque is empty, they return a `null` value.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`, `peekFirst()`, 和 `peekLast()`: 这些方法分别返回双端队列的第一个和最后一个元素。它们不会从双端队列中移除返回的元素。如果双端队列为空，它们返回一个
    `null` 值。'
- en: '`remove()`, `removeFirst()`, and `removeLast()`: These methods return the first
    and last element of the deque, respectively. They remove the returned element
    as well. If the deque is empty, they throw a `NoSuchElementException` exception.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`, `removeFirst()`, 和 `removeLast()`: 这些方法分别返回双端队列的第一个和最后一个元素。它们也会移除返回的元素。如果双端队列为空，它们会抛出
    `NoSuchElementException` 异常。'
- en: Using blocking thread-safe deques
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阻塞线程安全的双端队列
- en: The most basic collection is referred to as a list. A list has an unlimited
    number of elements, and you can add, read, or remove an element from any position.
    A concurrent list allows various threads to add or remove elements from the list
    at a time without producing any data inconsistency. Similar to lists, we have
    deques. A deque is a data structure similar to a queue, but in a deque, you can
    add or remove elements from either the front (head) or back (tail).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的集合被称为列表。列表具有无限数量的元素，你可以从任何位置添加、读取或删除一个元素。并发列表允许各种线程同时向列表添加或删除元素，而不会产生任何数据不一致性。与列表类似，我们还有双端队列。双端队列是一种类似于队列的数据结构，但在双端队列中，你可以从前面（头部）或后面（尾部）添加或删除元素。
- en: In this recipe, you will learn how to use blocking deques in your concurrent
    programs. The main difference between blocking deques and non-blocking deques
    is that blocking deques have methods to insert and delete elements that, if not
    done immediately because the list is either full or empty, block the thread that
    make the call until the operation could be carried out. Java includes the `LinkedBlockingDeque`
    class that implements a blocking deque.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，你将学习如何在你的并发程序中使用阻塞双端队列。阻塞双端队列与非阻塞双端队列之间的主要区别在于，阻塞双端队列具有插入和删除元素的方法，如果由于列表已满或为空而无法立即执行，则这些方法将阻塞调用线程，直到操作可以执行。Java包括实现了阻塞双端队列的`LinkedBlockingDeque`类。
- en: 'You are going to implement an example with the following two tasks:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你将实现以下两个任务的示例：
- en: One that adds thousands of elements to the deque
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个向双端队列添加数千个元素的操作
- en: One that massively removes data from the same list
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从同一列表大量删除数据的操作
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse
- en: or a different IDE, such as NetBeans, open it and create a new Java project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用不同的IDE，例如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow the steps described next to implement the example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤描述实现示例：
- en: 'Create a class named `Client` and specify that it implements the `Runnable`
    interface:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Client`的类并指定它实现`Runnable`接口：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Declare a private `LinkedBlockingDeque` attribute parameterized by the `String`
    class named `requestList`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`requestList`的私有`LinkedBlockingDeque`属性，该属性由`String`类参数化：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the `run()` method. Insert five `String` objects into the deque per
    second using the `put()` method of the `requestList` object. Repeat this cycle
    three times:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现该`run()`方法。每秒使用`requestList`对象的`put()`方法将五个`String`对象插入到双端队列中。重复此循环三次：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the main class of the example by creating a class named `Main` and adding
    the `main()` method to it:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来创建示例的主类：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Declare and create `LinkedBlockingDeque` parameterized by the `String` class
    named list specifying a fixed size of three:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并创建一个名为`list`的`LinkedBlockingDeque`，该双端队列由`String`类参数化，并指定固定大小为三：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create and start a `Thread` object to execute a client task:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动一个`Thread`对象以执行客户端任务：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Get three `String` objects from the list every 300 milliseconds using the `take()`
    method of the list object. Repeat this cycle five times. Write the strings in
    the console:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每300毫秒使用列表对象的`take()`方法从列表中获取三个`String`对象。重复此循环五次。将字符串写入控制台：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Write a message to indicate the end of the program:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一条消息以指示程序结束：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, you used `LinkedBlockingDeque`, parameterized by the `String`
    class, to work with a non-blocking concurrent deque of data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，你使用了由`String`类参数化的`LinkedBlockingDeque`，以处理非阻塞的并发数据双端队列。
- en: The `Client` class uses the `put()` method to insert strings into the deque.
    If the deque is full (because you have created it with fixed capacity), the method
    will block the execution of its thread until there is empty space in the list.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client`类使用`put()`方法将字符串插入到双端队列中。如果双端队列已满（因为你已使用固定容量创建它），则该方法将阻塞其线程的执行，直到列表中有空余空间。'
- en: The `Main` class uses the `take()` method to get strings from the deque. If
    the deque is empty, the method blocks the execution of its thread until there
    are elements in the deque.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`类使用`take()`方法从双端队列中获取字符串。如果双端队列为空，则该方法将阻塞其线程的执行，直到双端队列中有元素。'
- en: Both the methods of the `LinkedBlockingDeque` class used in this example can
    throw an `InterruptedException` exception if they are interrupted while they are
    being blocked. So, you have to include the necessary code to catch this exception.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中使用的 `LinkedBlockingDeque` 类的这两种方法如果在被阻塞时被中断，可能会抛出一个 `InterruptedException`
    异常。因此，你必须包含必要的代码来捕获这个异常。
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The `LinkedBlockingDeque` class also provides methods to insert and get elements
    from the deque that, instead of being blocked, throws an exception or returns
    the `null` value. These methods are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedBlockingDeque` 类还提供了插入和从双端队列获取元素的方法，这些方法不是阻塞的，而是抛出异常或返回 `null` 值。这些方法如下：'
- en: '`takeFirst()` and `takeLast()`: These return the first and last element of
    the deque, respectively. They remove the returned element from the deque. If the
    deque is empty, they block the thread until there are elements in the deque.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeFirst()` 和 `takeLast()`：这些方法分别返回双端队列的第一个和最后一个元素。它们会从双端队列中移除返回的元素。如果双端队列为空，它们会阻塞线程，直到双端队列中有元素为止。'
- en: '`getFirst()` and `getLast()`: These return the first and last element of the
    deque, respectively. They don''t remove the returned element from the deque. If
    the deque is empty, they throw a `NoSuchElementExcpetion` exception.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFirst()` 和 `getLast()`：这些方法分别返回双端队列的第一个和最后一个元素。它们不会从双端队列中移除返回的元素。如果双端队列为空，它们抛出一个
    `NoSuchElementException` 异常。'
- en: '`peek()`, `peekFirst()`, and `peekLast()`: The `peekFirst()` and `peekLast()`
    methods return the first and last element of the deque, respectively. They don''t
    remove the returned element from the deque. If the deque is empty, they return
    a `null` value.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`、`peekFirst()` 和 `peekLast()`：`peekFirst()` 和 `peekLast()` 方法分别返回双端队列的第一个和最后一个元素。它们不会从双端队列中移除返回的元素。如果双端队列为空，它们返回一个
    `null` 值。'
- en: '`poll()`, `pollFirst()`, and `pollLast()`: The `pollFirst()` and `pollLast()`
    methods return the first and last element of the deque, respectively. They remove
    the returned element from the deque. If the list is empty, they return a `null`
    value.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll()`、`pollFirst()` 和 `pollLast()`：`pollFirst()` 和 `pollLast()` 方法分别返回双端队列的第一个和最后一个元素。它们会从双端队列中移除返回的元素。如果列表为空，它们返回一个
    `null` 值。'
- en: '`add()`, `addFirst()`, and `addLast()`: The `addFirst()` and `addLast()` methods
    add an element to the first and last position, respectively. If the deque is full
    (created with fixed capacity), they throw an `IllegalStateException` exception.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`、`addFirst()` 和 `addLast()`：`addFirst()` 和 `addLast()` 方法分别将元素添加到第一个和最后一个位置。如果双端队列已满（使用固定容量创建），它们会抛出一个
    `IllegalStateException` 异常。'
- en: See also
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using non-blocking thread-safe deques* recipe in this chapter
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中使用的 *使用非阻塞线程安全的双端队列* 烹饪配方
- en: Using blocking thread-safe queue ordered by priority
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按优先级排序的阻塞线程安全队列
- en: When you work with data structures, you may typically feel the need to have
    an ordered queue. Java provides `PriorityBlockingQueue` that has this functionality.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与数据结构一起工作时，你可能通常会感到需要有一个有序队列。Java 提供了具有此功能的 `PriorityBlockingQueue`。
- en: 'All the elements you want to add to `PriorityBlockingQueue` have to implement
    the `Comparable` interface; alternatively, you can include `Comparator` in the
    queue''s constructor. This interface has a method called `compareTo()` that receives
    an object of the same type. So you have two objects to compare: the one that is
    executing the method and the one that is received as a parameter. The method must
    return a number less than zero if the local object is less than the parameter.
    It should return a number bigger than zero if the local object is greater than
    the parameter. The number must be zero if both the objects are equal.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要添加到 `PriorityBlockingQueue` 中的所有元素都必须实现 `Comparable` 接口；或者，你可以在队列的构造函数中包含
    `Comparator`。此接口有一个名为 `compareTo()` 的方法，它接收相同类型的对象。因此，你有两个对象要比较：一个是执行方法的对象，另一个是作为参数接收的对象。如果本地对象小于参数，该方法必须返回一个小于零的数字。如果本地对象大于参数，它应该返回一个大于零的数字。如果两个对象都相等，数字必须为零。
- en: '`PriorityBlockingQueue` uses the `compareTo()` method when you insert an element
    in it to determine the position of the element inserted. Bigger elements will
    either be the tail or head of the queue, depending on the `compareTo()` method.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 `PriorityBlockingQueue` 中插入一个元素时，`PriorityBlockingQueue` 使用 `compareTo()`
    方法来确定插入元素的位置。较大的元素将根据 `compareTo()` 方法是队列的尾部还是头部。
- en: Another important characteristic of `PriorityBlockingQueue` is that it's a **blocking
    data structure**. It has methods that, if unable to perform the operation immediately,
    will block the thread until they are able to do it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue` 的另一个重要特性是它是一个 **阻塞数据结构**。它具有方法，如果无法立即执行操作，将阻塞线程，直到它们能够执行。'
- en: In this recipe, you will learn how to use the `PriorityBlockingQueue` class
    by implementing an example, where you are going to store a lot of events with
    different priorities in the same list, to check that the queue will be ordered
    as you want.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将通过实现一个示例来学习如何使用 `PriorityBlockingQueue` 类，在该示例中，您将在同一个列表中存储具有不同优先级的大量事件，以检查队列是否按您希望的方式排序。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他不同的 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: or a different IDE, such as NetBeans, open it and create a new Java project.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或打开不同的 IDE，例如 NetBeans，创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Event` and specify that it implements the `Comparable`
    interface parameterized by the `Event` class:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Event` 的类，并指定它实现由 `Event` 类参数化的 `Comparable` 接口：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Declare a private `int` attribute named `thread` to store the number of threads
    that have created the event:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `thread` 的私有 `int` 属性，用于存储创建事件的线程数：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Declare a private `int` attribute named `priority` to store the priority of
    the event:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `priority` 的私有 `int` 属性，用于存储事件的优先级：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement the `getThread()` method to return the value of the thread attribute:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现返回线程属性值的 `getThread()` 方法：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Implement the `getPriority()` method to return the value of the priority attribute:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现返回优先级属性值的 `getPriority()` 方法：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the `compareTo()` method. It receives `Event` as a parameter and
    compares the priority of the current event and the one received as a parameter.
    It returns `-1` if the priority of the current event is bigger, `0` if both the
    priorities are equal, and `1` if the priority of the current event is smaller.
    Note that this is the opposite of most `Comparator.compareTo()` implementations:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现比较方法 `compareTo()`。它接收 `Event` 作为参数，比较当前事件和接收到的参数的优先级。如果当前事件的优先级更高，则返回 `-1`；如果两个优先级相等，则返回
    `0`；如果当前事件的优先级更低，则返回 `1`。注意，这与大多数 `Comparator.compareTo()` 实现相反：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Declare a private `int` attribute named `id` to store the number that identifies
    the task:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `id` 的私有 `int` 属性，用于存储标识任务的数字：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Declare a private `PriorityBlockingQueue` attribute parameterized by the `Event`
    class named `queue` to store the events generated by the task:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `queue` 的私有 `PriorityBlockingQueue` 属性，参数化为 `Event` 类，用于存储任务生成的事件：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Implement the `run()` method. It stores 1,000 events in the queue, using its
    ID, to identify the task that creates the event and we assign to each event a
    different priority from 1 to 1000\. Use the `add()` method to store the events
    in the queue:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。在队列中存储 1,000 个事件，使用其 ID 来标识创建事件的任务，并为每个事件分配一个从 1 到 1000 的不同优先级。使用
    `add()` 方法将事件存储在队列中：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a `PriorityBlockingQueue` object parameterized by the `Event` class
    named `queue`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `queue` 的 `PriorityBlockingQueue` 对象，参数化为 `Event` 类：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create an array of five `Thread` objects to store the threads that will execute
    the five tasks:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含五个 `Thread` 对象的数组以存储将执行五个任务的线程：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create five `Task` objects. Store the threads in the array created earlier:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建五个 `Task` 对象。将线程存储在之前创建的数组中：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Start the five threads created earlier:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动之前创建的五个线程：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Wait for the finalization of the five threads using the `join()` method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `join()` 方法等待五个线程的最终化：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Write the actual size of the queue in the console and the events stored in
    it. Use the `poll()` method to take off the events from the queue:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写入队列的实际大小和存储在其中的事件。使用 `poll()` 方法从队列中取出事件：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Write a message to the console with the final size of the queue:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台写入队列的最终大小信息：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, you implemented a priority queue of `Event` objects using `PriorityBlockingQueue`.
    As mentioned in the introduction, all the elements stored in `PriorityBlockingQueue`
    have to implement the `Comparable` interface or provide a `Comparator` object
    to the constructor of the queue. In this case, you used the first approach, so
    you implemented the `compareTo()` method in the `Event` class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用`PriorityBlockingQueue`实现了`Event`对象的优先队列。如介绍中所述，存储在`PriorityBlockingQueue`中的所有元素都必须实现`Comparable`接口或向队列的构造函数提供`Comparator`对象。在这种情况下，你采用了第一种方法，因此在`Event`类中实现了`compareTo()`方法。
- en: All the events have a priority attribute. The elements that have a higher value
    of priority will be the first elements in the queue. When you implement the `compareTo()`
    method, if the event executing the method has a priority higher than the priority
    of the event passed as a parameter, it returns `-1` as the result. In another
    case, if the event executing the method has a priority lower than the priority
    of the event passed as a parameter, it returns `1` as the result. If both objects
    have the same priority, the `compareTo()` method returns `0`. In this case, the
    `PriorityBlockingQueue` class doesn't guarantee the order of the elements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事件都有一个优先级属性。优先级值较高的元素将是队列中的第一个元素。当你实现`compareTo()`方法时，如果执行此方法的事件的优先级高于作为参数传递的事件的优先级，它返回`-1`作为结果。在另一种情况下，如果执行此方法的事件的优先级低于作为参数传递的事件的优先级，它返回`1`作为结果。如果两个对象具有相同的优先级，`compareTo()`方法返回`0`。在这种情况下，`PriorityBlockingQueue`类不保证元素的顺序。
- en: We implemented the `Task` class to add the `Event` objects to the priority queue.
    Each task object adds 1,000 events to the queue, with priorities between `0` and
    `999`, using the `add()` method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了`Task`类，以便将`Event`对象添加到优先队列中。每个任务对象使用`add()`方法将1,000个事件添加到队列中，优先级在`0`到`999`之间。
- en: The `main()` method of the `Main` class creates five `Task` objects and executes
    them in the corresponding threads. When all the threads had finished their execution,
    you wrote all the elements to the console. To get the elements from the queue,
    we used the `poll()` method. This method returns and removes the first element
    from the queue.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`类的`main()`方法创建了五个`Task`对象，并在相应的线程中执行它们。当所有线程完成执行后，你将所有元素写入控制台。要从队列中获取元素，我们使用了`poll()`方法。此方法返回并移除队列中的第一个元素。'
- en: 'The following screenshot shows part of the output of an execution of the program:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序执行输出的一部分：
- en: '![](img/00044.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00044.jpeg)'
- en: You can see how the queue has a size of 5,000 elements and how the first elements
    have the biggest priority value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到队列有5,000个元素，以及第一个元素具有最大的优先级值。
- en: There's more...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `PriorityBlockingQueue` class has other interesting methods. The following
    is a description of some of them:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue`类还有其他一些有趣的方法。以下是一些方法的描述：'
- en: '`clear()`: This method removes all the elements of the queue.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 此方法移除队列中的所有元素。'
- en: '`take()`: This method returns and removes the first element of the queue. If
    the queue is empty, it blocks its thread until the queue has elements.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take()`: 此方法返回并移除队列的第一个元素。如果队列是空的，它将阻塞其线程，直到队列有元素。'
- en: '`put(E e)`: This is the class used to parameterize the `PriorityBlockingQueue`
    class. It inserts the element that is passed as a parameter into the queue.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put(E e)`: 这是用于参数化`PriorityBlockingQueue`类的类。它将作为参数传递的元素插入到队列中。'
- en: '`peek()`: This method returns the first element of the queue but doesn''t remove
    it.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 此方法返回队列的第一个元素，但不移除它。'
- en: See also
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using blocking thread-safe deques* recipe in this chapter
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用阻塞线程安全的双端队列*配方
- en: Using thread-safe lists with delayed elements
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有延迟元素的线程安全列表
- en: 'An interesting data structure provided by the Java API, which you can use in
    concurrent applications, is implemented in the `DelayQueue` class. In this class,
    you can store elements with an activation date. The methods that return or extract
    elements from the queue will ignore these elements whose data will appear in the
    future. They are invisible to these methods.To obtain this behavior, the elements
    you want to store in the `DelayQueue` class need to have the `Delayed` interface
    implemented. This interface allows you to work with delayed objects. This interface
    has the `getDelay()` method that returns the time until the activation of the
    element. This interface forces you to implement the following two methods:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Java API 提供的一个有趣的数据结构，你可以在并发应用程序中使用，是在 `DelayQueue` 类中实现的。在这个类中，你可以存储具有激活日期的元素。返回或从队列中提取元素的方法将忽略这些元素，其数据将在未来出现。它们对这些方法不可见。为了获得这种行为，你想要存储在
    `DelayQueue` 类中的元素需要实现 `Delayed` 接口。此接口允许你处理延迟对象。此接口有一个 `getDelay()` 方法，它返回元素激活的时间。此接口强制你实现以下两个方法：
- en: '`compareTo(Delayed o)`: The `Delayed` interface extends the `Comparable` interface.
    This method will return a value less than zero if the object that is executing
    the method has a delay smaller than the object passed as a parameter. It will
    return a value greater than zero if the object that is executing the method has
    a delay bigger than the object passed as a parameter. It will return zero if both
    the objects have the same delay.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compareTo(Delayed o)`: `Delayed` 接口扩展了 `Comparable` 接口。如果执行此方法的对象具有比作为参数传递的对象更小的延迟，则此方法将返回一个小于零的值。如果执行此方法的对象具有比作为参数传递的对象更大的延迟，则返回一个大于零的值。如果两个对象具有相同的延迟，则返回零。'
- en: '`getDelay(TimeUnit unit)`: This method has to return the time remaining until
    the activation date in units, as specified by the unit parameter. The `TimeUnit`
    class is an enumeration with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`,
    `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDelay(TimeUnit unit)`: 此方法必须返回直到激活日期剩余的时间，以单位为单位，由单位参数指定。`TimeUnit` 类是一个枚举，具有以下常量：`DAYS`、`HOURS`、`MICROSECONDS`、`MILLISECONDS`、`MINUTES`、`NANOSECONDS`
    和 `SECONDS`。'
- en: In this example, you will learn how to use the `DelaydQueue` class by storing
    in it some events with different activation dates.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，你将学习如何通过在其中存储具有不同激活日期的一些事件来使用 `DelaydQueue` 类。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse
- en: or a different IDE, such as NetBeans, open it and create a new Java project.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用不同的 IDE，例如 NetBeans，打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Event` and specify that it implements the `Delayed` interface:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Event` 的类，并指定它实现 `Delayed` 接口：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Declare a private `Date` attribute named `startDate`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `startDate` 的私有 `Date` 属性：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the `compareTo()` method. It receives a `Delayed` object as its parameter.
    Return the difference between the delay of the current object and the one passed
    as a parameter:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `compareTo()` 方法。它接收一个 `Delayed` 对象作为其参数。返回当前对象延迟与作为参数传递的对象之间的差值：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement the `getDelay()` method. Return the difference between the start
    date of the object and the actual date in `TimeUnit`, which is received as a parameter:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `getDelay()` 方法。返回对象开始日期与实际日期在 `TimeUnit` 中的差值，该值作为参数接收：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Task` 的类，并指定它实现 `Runnable` 接口：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Declare a private `int` attribute named `id` to store a number that identifies
    this task:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `id` 的私有 `int` 属性，用于存储一个标识此任务的数字：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Declare a private `DelayQueue` attribute parameterized by the `Event` class
    named `queue`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `queue` 的私有 `DelayQueue` 属性，该属性由 `Event` 类参数化：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Implement the `run()` method. First, calculate the activation date of the events
    that this task is going to create. Then, add the number of seconds equal to the
    ID of the object to the actual date:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。首先，计算此任务将要创建的事件的激活日期。然后，将对象的 ID 等于的秒数加到实际日期上：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Store 100 events in the queue using the `add()` method:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `add()` 方法在队列中存储 100 个事件：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create a `DelayQueue` object parameterized by the `Event` class:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个由 `Event` 类参数化的 `DelayQueue` 对象：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create an array of five `Thread` objects to store the tasks you''re going to
    execute:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含五个 `Thread` 对象的数组以存储你将要执行的任务：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create five `Task` objects with different IDs:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有不同 ID 的五个 `Task` 对象：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Launch all the five tasks created earlier:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动之前创建的所有五个任务：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Wait for the finalization of the threads using the `join()` method:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `join()` 方法等待线程的最终化：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Write to the console the events stored in the queue. When the size of the queue
    is bigger than zero, use the `poll()` method to obtain an `Event` class. If it
    returns `null`, put the main thread to sleep for 500 milliseconds for the activation
    of more events:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将队列中存储的事件写入控制台。当队列的大小大于零时，使用 `poll()` 方法获取一个 `Event` 类。如果它返回 `null`，则将主线程休眠
    500 毫秒以等待更多事件的激活：
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we implemented the `Event` class. This class has a unique attribute,
    the activation date of the events, and it implements the `Delayed` interface.
    You can store `Event` objects in the `DelayQueue` class.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们实现了 `Event` 类。这个类有一个独特的属性，即事件的激活日期，并且它实现了 `Delayed` 接口。你可以将 `Event`
    对象存储在 `DelayQueue` 类中。
- en: The `getDelay()` method returns the number of nanoseconds between the activation
    date and the actual date. Both dates are objects of the `Date` class. You used
    the `getTime()` method that returns a date converted into milliseconds. Then,
    you converted this value into `TimeUnit`, which was received as a parameter. The
    `DelayQueue` class works in nanoseconds, but at this point, it's transparent to
    you.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDelay()` 方法返回激活日期和实际日期之间的纳秒数。这两个日期都是 `Date` 类的对象。你使用了 `getTime()` 方法，它返回一个转换为毫秒的日期。然后，你将此值转换为
    `TimeUnit`，它作为参数接收。`DelayQueue` 类在纳秒级别工作，但此时对你来说是透明的。'
- en: The `compareTo()` method returns a value less than zero if the delay of the
    object executing the method is smaller than the delay of the object passed as
    a parameter. It returns a value greater than zero if the delay of the object executing
    the method is bigger than the delay of the object passed as a parameter. It returns
    `0` if both the delays are equal.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行该方法的对象的延迟小于作为参数传递的对象的延迟，则 `compareTo()` 方法返回一个小于零的值。如果执行该方法的对象的延迟大于作为参数传递的对象的延迟，则返回一个大于零的值。如果两个延迟都相等，则返回
    `0`。
- en: You also implemented the `Task` class. This class has an `integer` attribute
    named `id`. When a `Task` object is executed, it adds the number of seconds that
    is equal to the ID of the task to the actual date, and this refers to the activation
    date of the events stored by this task in the `DelayQueue` class. Each `Task`
    object stores 100 events in the queue using the `add()` method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你还实现了 `Task` 类。这个类有一个名为 `id` 的 `integer` 属性。当 `Task` 对象被执行时，它将等于任务 ID 的秒数添加到实际日期，这指的是
    `DelayQueue` 类中由该任务存储的事件的激活日期。每个 `Task` 对象使用 `add()` 方法在队列中存储 100 个事件。
- en: Finally, in the `main()` method of the `Main` class, you created five `Task`
    objects and executed them in their corresponding threads. When these threads finished
    their execution, you wrote all the events using the `poll()` method in the console.
    This method retrieves and removes the first element of the queue. If the queue
    does not have any active element, it returns the `null` value. You call the `poll()`
    method, and if it returns an `Event` class, you increment a counter. When it returns
    the `null` value, you write the value of the counter in the console and put the
    thread to sleep for half a second to wait for more active events. When you obtained
    the 500 events stored in the queue, the execution of the program finished.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `Main` 类的 `main()` 方法中，你创建了五个 `Task` 对象，并在相应的线程中执行它们。当这些线程完成执行后，你使用控制台中的
    `poll()` 方法写入所有事件。此方法检索并移除队列中的第一个元素。如果没有活动元素，则返回 `null` 值。你调用 `poll()` 方法，如果它返回
    `Event` 类，则增加一个计数器。当它返回 `null` 值时，你在控制台中写入计数器的值，并将线程休眠半秒钟以等待更多活动事件。当你获得了队列中存储的
    500 个事件后，程序执行结束。
- en: 'The following screenshot shows part of the output of an execution of the program:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序执行的部分输出：
- en: '![](img/00045.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: You can see how the program only gets 100 events when it is activated.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到当程序被激活时，它只获得了 100 个事件。
- en: You must be very careful with the `size()` method. It returns the total number
    of elements in the list that includes both active and non-active elements.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须非常小心地使用`size()`方法。它返回列表中包括活动和非活动元素的总元素数。
- en: There's more...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The `DelayQueue` class has other interesting methods, which are as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelayQueue`类还有其他有趣的方法，如下所示：'
- en: '`clear()`: This method removes all the elements of the queue.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 此方法移除队列中的所有元素。'
- en: '`offer(E e)`: Here, `E` represents the class used to parameterize the `DelayQueue`
    class. This method inserts the element that is passed as a parameter into the
    queue.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offer(E e)`: 在这里，`E`代表用于参数化`DelayQueue`类的类。此方法将作为参数传递的元素插入到队列中。'
- en: '`peek()`: This method retrieves but doesn''t remove the first element of the
    queue.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 此方法检索但不移除队列的第一个元素。'
- en: '`take()`: This method retrieves and removes the first element of the queue.
    If there aren''t any active elements, the thread that is executing the method
    will be blocked until the thread gets some active elements.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take()`: 此方法检索并移除队列的第一个元素。如果没有活动元素，执行此方法的线程将被阻塞，直到线程获得一些活动元素。'
- en: See also
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using blocking thread-safe deques* recipe in this chapter
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用阻塞线程安全的队列*配方
- en: Using thread-safe navigable maps
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程安全的可导航映射
- en: 'The `ConcurrentNavigableMap` is an interface that defines interesting data
    structures provided by the Java API that you can use in your concurrent programs.
    The classes that implement the `ConcurrentNavigableMap` interface stores elements
    in two parts:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentNavigableMap`是一个接口，它定义了Java API提供的有趣的数据结构，你可以在你的并发程序中使用这些数据结构。实现`ConcurrentNavigableMap`接口的类将元素存储在两部分：'
- en: A **key** that uniquely identifies an element
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**键**，用于唯一标识一个元素
- en: The rest of the data that defines the element, called **value**
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义元素的其余数据，称为**值**
- en: The Java API also provides a class that implements `ConcurrentSkipListMap`,
    which is the interface that implements a non-blocking list with the behavior of
    the `ConcurrentNavigableMap` interface. Internally, it uses a **Skip List** to
    store data. A Skip List is a data structure based on parallel lists that allow
    us to get the kind of efficiency that is associated with a binary tree. You can
    get more information about Skip Lists at [https://en.wikipedia.org/wiki/Skip_list](https://en.wikipedia.org/wiki/Skip_list).
    With it, you can get a sorted data structure, instead of a sorted list, with better
    access time to insert, search, or delete elements.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Java API还提供了一个实现`ConcurrentSkipListMap`的类，这是一个实现具有`ConcurrentNavigableMap`接口行为的非阻塞列表的接口。内部，它使用**跳表**来存储数据。跳表是一种基于并行列表的数据结构，它允许我们获得与二叉树相关的效率。你可以在[https://en.wikipedia.org/wiki/Skip_list](https://en.wikipedia.org/wiki/Skip_list)上获取更多关于跳表的信息。有了它，你可以获得一个排序的数据结构，而不是一个排序的列表，并且具有更好的插入、搜索或删除元素的访问时间。
- en: Skip List was introduced by William Pugh in 1990.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 跳表（Skip List）是由威廉·普（William Pugh）在1990年提出的。
- en: When you insert an element to a map, the map uses a key to order them; therefore,
    all the elements will be ordered. The keys have to implement the `Comparable`
    interface, or you have to supply a `Comparator` class to the constructor of the
    map. The class also provides methods to obtain a submap of the map, in addition
    to the ones that return a concrete element.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向映射中插入一个元素时，映射使用键来排序它们；因此，所有元素都将排序。键必须实现`Comparable`接口，或者你必须向映射的构造函数提供一个`Comparator`类。该类还提供了获取映射子映射的方法，以及返回具体元素的方法。
- en: In this recipe, you will learn how to use the `ConcurrentSkipListMap` class
    to implement a map of contacts.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将学习如何使用`ConcurrentSkipListMap`类来实现联系人映射。
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等不同的IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Contact`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Contact`的类：
- en: '[PRE64]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Declare two private `String` attributes named `name` and `phone`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个名为`name`和`phone`的私有`String`属性：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Implement the constructor of the class to initialize its attributes:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Implement the methods to return the values of the `name` and `phone` attributes:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现返回`name`和`phone`属性值的方法：
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类并指定它实现`Runnable`接口：
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Declare a private `ConcurrentSkipListMap` attribute, parameterized by the `String`
    and `Contact` classes, named `map`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `map` 的私有 `ConcurrentSkipListMap` 属性，由 `String` 和 `Contact` 类参数化：
- en: '[PRE69]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Declare a private `String` attribute named `id` to store the ID of the current
    task:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `id` 的私有 `String` 属性来存储当前任务的 ID：
- en: '[PRE70]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the constructor of the class to store its attributes:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以存储其属性：
- en: '[PRE71]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Implement the `run()` method. It stores 1,000 different contacts in the map
    using the ID of the task and an incremental number to create `Contact` objects.
    Use the `put()` method to store the contacts in the map:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `run()` 方法。它使用任务的 ID 和递增的数字来创建 `Contact` 对象，并将 1,000 个不同的联系人存储在地图中。使用 `put()`
    方法将联系人存储在地图中：
- en: '[PRE72]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并将 `main()` 方法添加到其中来实现示例的主类：
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a `ConcurrentSkipListMap` object, parameterized by the `String` and
    `Conctact` classes, named `map`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个由 `String` 和 `Conctact` 类参数化的名为 `map` 的 `ConcurrentSkipListMap` 对象：
- en: '[PRE74]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Create an array for 26 `Thread` objects to store all the `Task` objects that
    you''re going to execute:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于存储所有即将执行的 `Task` 对象的 26 个 `Thread` 对象数组：
- en: '[PRE75]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create and launch 26 `task` objects and assign a capital letter to the ID of
    each task:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动 26 个 `task` 对象，并将一个大写字母分配给每个任务的 ID：
- en: '[PRE76]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Wait for the finalization of the threads using the `join()` method:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `join()` 方法等待线程的最终化：
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Get the first entry of the map using the `firstEntry()` method. Write its data
    to the console:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `firstEntry()` 方法获取地图的第一个条目。将其数据写入控制台：
- en: '[PRE78]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Get the last entry of the map using the `lastEntry()` method. Write its data
    to the console:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `lastEntry()` 方法获取地图的最后一个条目。将其数据写入控制台：
- en: '[PRE79]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Obtain a submap of the map using the `subMap()` method. Write its data to the
    console:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `subMap()` 方法获取地图的子映射。将其数据写入控制台：
- en: '[PRE80]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we implemented a `Task` class to store `Contact` objects in
    a navigable map. Each contact has a name, which is the ID of the task that creates
    it, and a phone number, which is a number between 1,000 and 2,000\. We concatenated
    these values as keys for the contacts. Each `Task` object creates 1,000 contacts;
    these contacts are stored in the navigable map using the `put()` method.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们实现了一个 `Task` 类来在可导航的地图中存储 `Contact` 对象。每个联系人都有一个名字，它是创建它的任务的 ID，还有一个电话号码，它是介于
    1,000 到 2,000 之间的数字。我们将这些值连接起来作为联系人的键。每个 `Task` 对象创建 1,000 个联系人；这些联系人使用 `put()`
    方法存储在可导航的地图中。
- en: If you insert an element with a key that exists in the map, the element associated
    with that key will be replaced by the new element.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你插入一个具有在地图中存在的键的元素，则与该键关联的元素将被新元素替换。
- en: The `main()` method of the `Main` class creates 26 `Task` objects, using the
    letters between A and Z as IDs. Then, you used some methods to obtain data from
    the map. The `firstEntry()` method returns a `Map.Entry` object with the first
    element of the map. This method doesn't remove the element from the map. The object
    contains the key and the element. To obtain the element, you called the `getValue()`
    method. You can use the `getKey()` method to obtain the key of that element.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 类的 `main()` 方法创建了 26 个 `Task` 对象，使用 A 到 Z 之间的字母作为 ID。然后，你使用了一些方法从地图中获取数据。`firstEntry()`
    方法返回一个包含地图第一个元素的 `Map.Entry` 对象。此方法不会从地图中删除元素。该对象包含键和元素。要获取元素，你调用了 `getValue()`
    方法。你可以使用 `getKey()` 方法来获取该元素的键。'
- en: The `lastEntry()` method returns a `Map.Entry` object with the last element
    of the map. The `subMap()` method returns the `ConcurrentNavigableMap` object
    with part of the elements of the map, in this case, the elements that had keys
    between `A1996` and `B1002`. You used the `pollFirst()` method to process the
    elements of the `subMap()` method. This method returns and removes the first `Map.Entry`
    object of the submap.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastEntry()` 方法返回一个包含地图最后一个元素的 `Map.Entry` 对象。`subMap()` 方法返回包含地图部分元素的 `ConcurrentNavigableMap`
    对象，在这种情况下，键在 `A1996` 和 `B1002` 之间的元素。你使用了 `pollFirst()` 方法来处理 `subMap()` 方法中的元素。此方法返回并移除子映射的第一个
    `Map.Entry` 对象。'
- en: 'The following screenshot shows the output of an execution of the program:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了程序执行的结果：
- en: '![](img/00046.jpeg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: There's more...
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ConcurrentSkipListMap` class has other interesting methods. Some of them
    are as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListMap` 类有其他一些有趣的方法。其中一些如下：'
- en: '`headMap(K toKey)`: Here, `K` is the class of the key values used in the parameterization
    of the `ConcurrentSkipListMap` object. This method returns a submap of the first
    elements of the map with the elements that have a key smaller than the one passed
    as a parameter.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headMap(K toKey)`: 在这里，`K`是用于`ConcurrentSkipListMap`对象参数化的键值类的类。此方法返回一个子映射，其中包含具有小于传递的参数的键的第一个元素。'
- en: '`tailMap(K fromKey)`: Here, `K` is the class of the key values used in the
    parameterization of the `ConcurrentSkipListMap` object. This method returns a
    submap of the last elements of the map with the elements that have a key greater
    than the one passed as a parameter.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tailMap(K fromKey)`: 在这里，`K`是用于`ConcurrentSkipListMap`对象参数化的键值类的类。此方法返回一个子映射，其中包含具有大于传递的参数的键的最后一个元素。'
- en: '`putIfAbsent(K key, V Value)`: This method inserts the value specified as a
    parameter and also the key specified as a parameter if it doesn''t exist in the
    map.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`putIfAbsent(K key, V Value)`: 如果指定的键不存在于映射中，此方法将插入指定的值和键。'
- en: '`pollLastEntry()`: This method returns and removes a `Map.Entry` object with
    the last element of the map.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pollLastEntry()`: 此方法返回并移除具有映射中最后一个元素的`Map.Entry`对象。'
- en: '`replace(K key, V Value)`: This method replaces the value associated with the
    key specified as a parameter if this key exists in the map.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace(K key, V Value)`: 如果指定的键存在于映射中，此方法将替换与该键关联的值。'
- en: See also
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using non-blocking thread-safe deques* recipe in this chapter
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用非阻塞线程安全的队列*菜谱
- en: Using thread-safe HashMaps
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程安全的HashMap
- en: A hash table is a data structure that allows you to map a key to a value. Internally,
    it usually uses an array to store the elements and a hash function to calculate
    the position of the element in the array, using its key. The main advantage of
    this data structure is that the insert, delete, and search operations are very
    fast here, so it's very useful in situations when you have to carry out a lot
    of search operations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是一种数据结构，允许你将键映射到值。内部通常使用数组来存储元素，并使用哈希函数来计算元素在数组中的位置，使用其键。这种数据结构的主要优点是，插入、删除和搜索操作在这里都非常快，因此在需要执行大量搜索操作的情况下非常有用。
- en: 'The Java API provides different hash table implementations through the `Map`
    and `ConcurrentMap` interfaces. The `ConcurrentMap` interface provides thread-safety
    and atomic guarantees to all the operations, so you can use them in concurrent
    applications. The `ConcurrentHashMap` class implements the `ConcurrentMap` interface
    and adds some more methods to the ones defined in the interface. This class supports
    the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Java API通过`Map`和`ConcurrentMap`接口提供了不同的哈希表实现。`ConcurrentMap`接口为所有操作提供了线程安全和原子保证，因此你可以在并发应用程序中使用它们。`ConcurrentHashMap`类实现了`ConcurrentMap`接口，并添加了一些接口中定义的方法。此类支持以下功能：
- en: Full concurrency of read operations
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取操作的全并发性
- en: High expected concurrency for insert and delete operations
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入和删除操作的高预期并发性
- en: Both the elements (class and interface) were introduced in Java version 5, but
    in version 8, a lot of new methods similar to the ones provided by the stream
    API were developed.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个元素（类和接口）都是在Java版本5中引入的，但在版本8中，开发了许多类似于流API提供的方法。
- en: In this recipe, you will learn how to use the `ConcurrentHashMap` class in your
    application and the most important methods it provides.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何在你的应用程序中使用`ConcurrentHashMap`类以及它提供的重要方法。
- en: Getting ready
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Operation` with three attributes: a `String` attribute
    named `user`, a `String` attribute named `operation`, and a `Date` attribute named
    `time`. Add the methods to get and set the values of the attributes. The code
    of this class is very simple, so it won''t be included here.'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Operation`的类，具有三个属性：一个名为`user`的`String`属性，一个名为`operation`的`String`属性，以及一个名为`time`的`Date`属性。添加获取和设置属性值的
    方法。这个类的代码非常简单，所以不会在这里展示。
- en: 'Create a class named `HashFiller`. Specify that it implements the `Runnable`
    interface:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HashFiller`的类。指定它实现`Runnable`接口：
- en: '[PRE81]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Declare a private `ConsurrentHashMap` attribute named `userHash`. The key of
    the hash will be a `String` type and its value will be a `ConcurrentLinkedDeque`
    object of `Operation` objects. Implement the constructor of the class to initialize
    the attribute:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`userHash`的私有`ConcurrentHashMap`属性。哈希表的键将是一个`String`类型，其值将是`Operation`对象的`ConcurrentLinkedDeque`对象。实现类的构造函数以初始化属性：
- en: '[PRE82]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Implement the `run()` method. We''re going to fill `ConcurrentHashMap` with
    100 random `Operation` objects. First, generate random data and then use the `addOperationToHash()`
    method to insert the object in the hash:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。我们将用100个随机的`Operation`对象填充`ConcurrentHashMap`。首先，生成随机数据，然后使用`addOperationToHash()`方法将对象插入到哈希表中：
- en: '[PRE83]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Implement the `addOperationToHash()` method. It receives the hash and the operation
    you want to add as parameters. The key in the map will be the user assigned to
    the operation. We use the `computeIfAbsent()` method to obtain the `ConcurrentLinkedDeque`
    object associated with the key. If the key exists, this method returns the value
    associated with it. If it doesn''t, it executes the lambda expression passed as
    a parameter to this method to generate the value and associate it with the key.
    In this case, we generate a new `ConcurrentLinkedDeque` object. Finally, insert
    the operation to the deque:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`addOperationToHash()`方法。它接收哈希表和要添加的操作作为参数。映射中的键将是分配给操作的用户。我们使用`computeIfAbsent()`方法来获取与键关联的`ConcurrentLinkedDeque`对象。如果键存在，此方法返回与它关联的值。如果不存在，它执行传递给此方法的lambda表达式来生成值并将其与键关联。在这种情况下，我们生成一个新的`ConcurrentLinkedDeque`对象。最后，将操作插入到队列中：
- en: '[PRE84]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now implement the `Main` class and include the `main()` method. First, declare
    a `ConcurrentHashMap` object and a `HashFiller` task:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现`Main`类并包含`main()`方法。首先，声明一个`ConcurrentHashMap`对象和一个`HashFiller`任务：
- en: '[PRE85]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Execute 10 threads with the `HashFiller` class and wait for their finalization
    using the `join()` method:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`HashFiller`类执行10个线程，并使用`join()`方法等待它们的最终化：
- en: '[PRE86]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, extract the information of `ConcurrentHashMap`. First, extract the number
    of elements stored in it with the `size()` method. Then, use the `forEach()` method
    to apply an action to all the elements stored in the hash. The first parameter
    is the parallelism threshold. This is the minimum number of elements required
    to make the operation execute in a concurrent way. We have specified the value
    10 and the hash has 100 elements, so the operation will be executed in a parallel
    way. The lambda expression receives two parameters: key and value. Print the key
    and size of `ConcurrentLinkedDeque` stored as a value:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，提取`ConcurrentHashMap`的信息。首先，使用`size()`方法提取其中存储的元素数量。然后，使用`forEach()`方法对存储在哈希表中的所有元素应用一个操作。第一个参数是并行度阈值。这是使操作以并发方式执行所需的最小元素数量。我们指定了值10，哈希表有100个元素，因此操作将以并行方式执行。Lambda表达式接收两个参数：键和值。打印存储为值的`ConcurrentLinkedDeque`的键和大小：
- en: '[PRE87]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, use the `forEachEntry()` method. This is similar to the previous one,
    but the lambda expression receives an `Entry` object as a parameter instead of
    receiving two parameters. You can use this entry object to obtain the key and
    value:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`forEachEntry()`方法。这与前面的方法类似，但lambda表达式接收一个`Entry`对象作为参数，而不是接收两个参数。您可以使用此条目对象来获取键和值：
- en: '[PRE88]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, use the `search()` method to find the first element that satisfies the
    search function specified. In our case, we search for an operation whose operation
    code ends in 1\. As occurs with the `forEach()` method, we specify a parallelism
    threshold:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`search()`方法来查找满足指定搜索函数的第一个元素。在我们的例子中，我们搜索操作码以1结尾的操作。与`forEach()`方法类似，我们指定一个并行度阈值：
- en: '[PRE89]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Use the `search()` method again, but this time, use it to find a user with
    more than 10 operations:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`search()`方法，但这次，使用它来查找拥有超过10个操作的用戶：
- en: '[PRE90]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Finally, use the `reduce()` method to calculate the total number of operations
    stored in the hash:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`reduce()`方法计算存储在哈希表中的操作总数：
- en: '[PRE91]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: How it works...
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we implemented an application that uses `ConcurrentHashMap`
    to store information about operations made by users. Internally, the hash table
    uses the user attribute of the `Operation` class as a key and `ConcurrentLinkedDeque`
    (a non-blocking concurrent list) as its value to store all the operations associated
    with that user.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们实现了一个使用`ConcurrentHashMap`来存储用户执行的操作信息的应用程序。内部，哈希表使用`Operation`类的用户属性作为键，使用`ConcurrentLinkedDeque`（一个非阻塞的并发列表）作为其值来存储与该用户关联的所有操作。
- en: First, we filled the hash with some random data using 10 different threads.
    We implemented the `HashFiller` task for this purpose. The biggest problem with
    these tasks is what happens when you have to insert a key in the hash table. If
    two threads want to add the same key at the same time, you can lose the data inserted
    by one of the threads and have a data-race condition. To solve this problem, we
    used the `computeIfAbsent()` method.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用10个不同的线程使用一些随机数据填充了哈希。为此，我们实现了`HashFiller`任务。这些任务的最大问题是当你需要在哈希表中插入一个键时会发生什么。如果有两个线程同时想要添加相同的键，你可能会丢失一个线程插入的数据，并出现数据竞争条件。为了解决这个问题，我们使用了`computeIfAbsent()`方法。
- en: This method receives a key and an implementation of the `Function` interface
    that can be expressed as a lambda expression; the key and implementation are received
    as parameters. If the key exists, the method returns the value associated with
    the key. If it doesn't, the method executes the `Function` object specified and
    adds the key and value returned by `Function` to the HashMap. In our case, the
    key didn't exist, so we created a new instance of the `ConcurrentLinkedDeque`
    class. The main advantage of this method is that it's executed atomically; so,
    if another thread tries to do the same operation, it will be blocked until this
    operation is finished.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收一个键和一个可以表示为lambda表达式的`Function`接口实现；键和实现作为参数接收。如果键存在，该方法返回与键关联的值。如果不存在，该方法将执行指定的`Function`对象，并将`Function`返回的键和值添加到HashMap中。在我们的情况下，键不存在，因此我们创建了一个新的`ConcurrentLinkedDeque`类实例。此方法的主要优势是它是原子执行的；因此，如果另一个线程尝试执行相同的操作，它将被阻塞，直到此操作完成。
- en: 'Then, in the `main()` method, we used other methods of `ConcurrentHashMap`
    to process the information stored in the hash. We used the following methods:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`main()`方法中，我们使用了`ConcurrentHashMap`的其他方法来处理存储在哈希中的信息。我们使用了以下方法：
- en: '`forEach()`: This method receives an implementation of the `BiConsumer` interface
    that can be expressed as a lambda expression; it is received as a parameter. The
    other two parameters of this expression represent the key and value of the element
    we''re processing. This method applies the expression to all the elements stored
    in `ConcurrentHashMap`.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach()`：此方法接收一个可以表示为lambda表达式的`BiConsumer`接口实现；它作为参数接收。此表达式的其他两个参数代表我们正在处理的元素的键和值。此方法将表达式应用于存储在`ConcurrentHashMap`中的所有元素。'
- en: '`forEachEntry()`: This method is equivalent to the previous one, but here the
    expression is an implementation of the `Consumer` interface. It receives an `Entry`
    object that stores the key and value of the entry we''re processing as a parameter.
    This is another way to express the same functionality.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachEntry()`：此方法与上一个方法等效，但这里的表达式是`Consumer`接口的实现。它接收一个`Entry`对象作为参数，该对象存储我们正在处理的条目的键和值。这是表达相同功能的一种方式。'
- en: '`search()`: This method receives the implementation of the `BiFunction` interface
    that can be expressed as a lambda expression; it is received as a parameter. This
    function also receives the key and value of the entry of the `ConcurrentHashMap`
    object we''re processing as parameters. It returns the first non-null value returned
    by `BiFunction`.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()`：此方法接收可以表示为lambda表达式的`BiFunction`接口实现；它作为参数接收。此函数还接收我们正在处理的`ConcurrentHashMap`对象的条目的键和值作为参数。它返回`BiFunction`返回的第一个非空值。'
- en: '`reduce()`: This method receives two `BiFunction` interfaces to reduce the
    elements of `ConcurrentHashMap` to a unique value. This allows you to implement
    a `MapReduce` operation with the elements of `ConcurrentHashMap`. The first `BiFunction`
    interface allows you to transform the key and value of the elements into a unique
    value, and the second `BiFunction` interface allows you to aggregate the values
    of two different elements.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce()`：此方法接收两个`BiFunction`接口，以将`ConcurrentHashMap`的元素减少到唯一值。这允许您使用`ConcurrentHashMap`的元素实现`MapReduce`操作。第一个`BiFunction`接口允许您将元素的键和值转换为唯一值，第二个`BiFunction`接口允许您聚合两个不同元素的值。'
- en: All the methods described so far have a first parameter named `parallelismThreshold`.
    This parameter is described as *...the (estimated) number of elements needed for
    this operation to be executed in parallel...,* that is to say, if `ConcurrentHashMap`
    has fewer elements than the value specified in the parameter, the method is executed
    in a sequential way. On the contrary (as in our case), the method is executed
    in a parallel way.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止所描述的所有方法都有一个名为 `parallelismThreshold` 的第一个参数。此参数被描述为 *...执行此操作所需的（估计）元素数量...*，也就是说，如果
    `ConcurrentHashMap` 的元素少于参数中指定的值，则方法以顺序方式执行。相反（如在我们的情况下），方法以并行方式执行。
- en: There's more...
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`ConcurrentHashMap` has more methods than what''s specified in the previous
    section. We enumerate some of them in the following list:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap` 包含比上一节中指定的更多方法。以下列表中我们列举了一些：'
- en: '`forEachKey()` and `forEachValue()`: These methods are similar to the `forEach()`
    methods, but in this case, the expression processes the keys and values stored
    in `ConcurrentHashMap`, respectively.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachKey()` 和 `forEachValue()`: 这些方法与 `forEach()` 方法类似，但在此情况下，表达式分别处理存储在
    `ConcurrentHashMap` 中的键和值。'
- en: '`searchEntries()`, `searchKeys()`, and `searchValues()`: These methods are
    similar to the `search()` method explained before. However, in this case, the
    expression passed as a parameter receives an `Entry` object, a key, or a value
    of the elements stored in `ConcurrentHashMap`.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchEntries()`, `searchKeys()`, 和 `searchValues()`: 这些方法与之前解释的 `search()`
    方法类似。然而，在这种情况下，作为参数传递的表达式接收一个 `Entry` 对象、一个键或存储在 `ConcurrentHashMap` 中的元素的值。'
- en: '`reduceEntries()`, `reduceKeys()`, and `reduceValues()`: These methods are
    similar to the `reduce()` method explained before. However, in this case, the
    expression passed as a parameter receives an `Entry` object, a key, or a value
    of the elements stored in `ConcurrentHashMap`.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduceEntries()`, `reduceKeys()`, 和 `reduceValues()`: 这些方法与之前解释的 `reduce()`
    方法类似。然而，在这种情况下，作为参数传递的表达式接收一个 `Entry` 对象、一个键或存储在 `ConcurrentHashMap` 中的元素的值。'
- en: '`reduceXXXToDouble()`, `reduceXXXToLong()`, and `reduceXXXToInt()`: These methods
    allow you to make a reduction of the elements of `ConcurrentHashMap` by generating
    a `double`, `long`, or `int` value, respectively.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduceXXXToDouble()`, `reduceXXXToLong()`, 和 `reduceXXXToInt()`: 这些方法允许您通过生成
    `double`、`long` 或 `int` 值来对 `ConcurrentHashMap` 的元素进行归约。'
- en: '`computeIfPresent()`: This method complements the `computeIfAbsent()` method.
    In this case, it receives a key and an implementation of the `BiFunction` interface
    that can be expressed as a lambda expression. If the key exists in the `HashMap`,
    the method applies the expression to calculate the new value of the key. The `BiFunction`
    interface receives the key and the actual value of that key as parameters, and
    it returns the new value.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`computeIfPresent()`: 此方法补充了 `computeIfAbsent()` 方法。在这种情况下，它接收一个键和一个 `BiFunction`
    接口的实现，该接口可以用 lambda 表达式表示。如果键存在于 `HashMap` 中，该方法将表达式应用于计算键的新值。`BiFunction` 接口接收键和该键的实际值作为参数，并返回新值。'
- en: '`merge()`: This method receives a key, value, and implementation of the `BiFunction`
    interface that can be expressed as a lambda expression; they are received as parameters.
    If the key doesn''t exist in `ConcurrentHashMap`, it inserts it there and associates
    the value parameter with it. If it exists, execute `BiFunction` to calculate the
    new value associated with the key. The `BiFunction` interface receives the key
    and its actual value as parameters and returns the new value associated with the
    key.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge()`: 此方法接收一个键、值和 `BiFunction` 接口的实现，该接口可以用 lambda 表达式表示；它们作为参数接收。如果键不存在于
    `ConcurrentHashMap` 中，则将其插入并关联值参数。如果它存在，则执行 `BiFunction` 来计算与键关联的新值。`BiFunction`
    接口接收键及其实际值作为参数，并返回与键关联的新值。'
- en: '`getOrDefault()`: This method receives a key and a default value as parameters.
    If the key exists in `ConcurrentHashMap`, it returns its associated value. Otherwise,
    it returns the default value.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOrDefault()`: 此方法接收一个键和一个默认值作为参数。如果键存在于 `ConcurrentHashMap` 中，它返回其关联的值。否则，它返回默认值。'
- en: See also
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using thread-safe navigable maps *recipe in this chapter
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *使用线程安全的可导航映射* 的食谱
- en: The *Reducing the elements of a stream* recipe in [Chapter 6](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736),
    *Parallel and Reactive Streams*
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 6 章 [“减少流元素”的食谱](part0249.html#7DES20-69b77957c9a14e36a0bec5f5a1363736)，*并行和响应式流*
- en: Using atomic variables
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子变量
- en: '**Atomic variables** were introduced in Java version 5 to provide atomic operations
    on single variables. When you work with a normal variable, each operation that
    you implement in Java is transformed into several instructions of Java byte code
    that is understandable by the JVM when you compile the program. For example, when
    you assign a value to a variable, you only use one instruction in Java; however,
    when you compile this program, it is transformed into various instructions in
    the JVM language. This can lead to data inconsistency errors when you work with
    multiple threads that share a variable.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**原子变量**是在 Java 5 版本中引入的，以提供对单个变量的原子操作。当您使用普通变量时，您在 Java 中实现的每个操作都会转换为 JVM
    可理解的 Java 字节码的多个指令。例如，当您将值赋给变量时，您在 Java 中只使用一个指令；然而，当您编译此程序时，它被转换为 JVM 语言的多种指令。当您与多个线程共享变量时，这可能导致数据不一致错误。'
- en: 'To avoid these problems, Java introduced atomic variables. When a thread is
    doing an operation with an atomic variable and if other threads want to do an
    operation with the same variable, the implementation of the class includes a mechanism
    to check that the operation is done atomically. Basically, the operation gets
    the value of the variable, changes the value to a local variable, and then tries
    to change the old value with the new one. If the old value is still the same,
    it is substituted; if not, the method begins the operation again. This operation
    is called **Compare and Set**. It implements the modification of the value of
    a variable in the following three steps:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，Java 引入了原子变量。当一个线程正在使用原子变量执行操作，并且如果有其他线程想要对同一个变量执行操作，类的实现包括一个机制来检查操作是否是原子执行的。基本上，操作获取变量的值，即变量的旧值。
- en: You get the value of the variable, which is the old value of the variable.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您获取变量的值，即变量的旧值。
- en: You change the value of the variable in a temporal variable, which is the new
    value of the variable.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在一个时间变量中更改变量的值，这是变量的新值。
- en: You substitute the old value with the new value if the old value is equal to
    the actual value of the variable. The old value may be different from the actual
    value if another thread changes the value of the variable.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果旧值等于变量的实际值，则用新值替换旧值。如果另一个线程改变了变量的值，旧值可能与实际值不同。
- en: Some of these variables, for example, the `LongAccumulator` class, receive an
    operation as a parameter that could be executed inside some of its methods. These
    operations must be free from any side effects, as they might be executed multiple
    times in every value update.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些变量，例如`LongAccumulator`类，接收一个作为参数的操作，该操作可以在其某些方法内部执行。这些操作必须没有副作用，因为它们可能在每次值更新时多次执行。
- en: Atomic variables don't use locks or other synchronization mechanisms to protect
    access to their values. All their operations are based on Compare and Set. It's
    guaranteed that several threads can work with an atomic variable at a time without
    generating data inconsistency errors; plus, they simplify the implementation.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 原子变量不使用锁或其他同步机制来保护对其值的访问。它们的所有操作都基于比较和设置。保证几个线程可以同时使用一个原子变量，而不会产生数据不一致错误；此外，它们简化了实现。
- en: 'Java 8 has added four new atomic classes. First we have the `LongAdder` and
    `DoubleAdder` classes; they store `long` and `double` values that are updated
    frequently by different threads. You can obtain the same functionality as that
    of the `LongAdder` class with the `AtomicLong` class, but the former provides
    better performance. The other two classes are `LongAccumulator` and `DoubleAccumulator`.
    These classes are similar to the previous one, but here, you have to specify two
    parameters in the constructor:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 添加了四个新的原子类。首先我们有`LongAdder`和`DoubleAdder`类；它们存储频繁由不同线程更新的`long`和`double`值。您可以使用`AtomicLong`类获得与`LongAdder`类相同的功能，但前者提供了更好的性能。其他两个类是`LongAccumulator`和`DoubleAccumulator`。这些类与前面的类类似，但在这里，您必须在构造函数中指定两个参数：
- en: The initial value of the counter.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数器的初始值。
- en: A `LongBinaryOperator` or `DoubleBinaryOperator` that can be indicated as a
    lambda expression. This expression receives the old value of the variable and
    the increment you want to apply and returns the new value of the variable.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `LongBinaryOperator` 或 `DoubleBinaryOperator`，可以表示为 lambda 表达式。这个表达式接收变量的旧值和要应用的增量，并返回变量的新值。
- en: 'In this recipe, you will learn how to use atomic variables implementing a bank
    account and two different tasks: one that adds money to the account and one that
    subtracts money from it. You will use the `AtomicLong` class in the implementation
    of the example.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何使用实现银行账户和两个不同任务的原子变量：一个向账户添加资金，另一个从账户中减去资金。您将在示例实现中使用 `AtomicLong`
    类。
- en: Getting ready
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    are using Eclipse or a different IDE, such as NetBeans, open it and create a new
    Java project.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用 Eclipse IDE 实现。如果您使用 Eclipse 或其他 IDE，例如 NetBeans，请打开它并创建一个新的 Java
    项目。
- en: How to do it...
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement the example:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Account` to simulate a bank account:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Account` 的类来模拟银行账户：
- en: '[PRE92]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Declare a private `AtomicLong` attribute named `balance` to store the balance
    of the account. In addition, declare a private `LongAdder` attribute named operations
    and a private `DoubleAccumulator` attribute named commission:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `balance` 的私有 `AtomicLong` 属性来存储账户的余额。此外，声明一个名为 `operations` 的私有 `LongAdder`
    属性和一个名为 `commission` 的私有 `DoubleAccumulator` 属性：
- en: '[PRE93]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Implement the constructor of the class to initialize its attributes. For the
    `DoubleAccumulator` class, the identity value is `0` and we update the actual
    value with the result of multiply `0.2` to the increment passed as parameter:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性。对于 `DoubleAccumulator` 类，身份值是 `0`，我们通过将参数传递的增量乘以 `0.2` 来更新实际值：
- en: '[PRE94]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Implement the method to get the value of the three attributes:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现获取三个属性值的方法：
- en: '[PRE95]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Implement a method named `setBalance()` to establish the value of the balance
    attribute. We also have to initialize the operations and commission attributes
    using the `reset()` method:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `setBalance()` 的方法来设置余额属性值。我们还需要使用 `reset()` 方法来初始化操作和佣金属性：
- en: '[PRE96]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Implement a method named `addAmount()` to increment the value of the `balance`
    attribute. In addition, use the `increment()` method of the `LongAdder` class
    to increment the value of the `operations` attribute and the `accumulate()` method
    by one unit to add 20 percent of the amount value to the `commission` object:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `addAmount()` 的方法来增加 `balance` 属性的值。此外，使用 `LongAdder` 类的 `increment()`
    方法增加 `operations` 属性的值，并通过 `accumulate()` 方法增加一个单位来将金额值的20%添加到 `commission` 对象：
- en: '[PRE97]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Implement a method named `substractAmount()` to decrement the value of the
    `balance` attribute. As it occurs with the `addAmount()` method, we modify the
    values of the `operations` and `commission` attributes:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `substractAmount()` 的方法来减少 `balance` 属性的值。与 `addAmount()` 方法类似，我们修改 `operations`
    和 `commission` 属性的值：
- en: '[PRE98]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Create a class named `Company` and specify that it implements the `Runnable`
    interface. This class will simulate the payments made by a company:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Company` 的类并指定它实现 `Runnable` 接口。这个类将模拟公司所做的支付：
- en: '[PRE99]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Declare a private `Account` attribute named `account`:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `account` 的私有 `Account` 属性：
- en: '[PRE100]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE101]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Implement the `run()` method of the task. Use the `addAmount()` method of the
    account to make 10 increments of 1,000 each in its balance:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现任务的 `run()` 方法。使用账户的 `addAmount()` 方法在其余额中增加10次，每次增加1,000：
- en: '[PRE102]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create a class named `Bank` and specify that it implements the `Runnable` interface.
    This class will simulate the withdrawal of money from the account:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Bank` 的类并指定它实现 `Runnable` 接口。这个类将模拟从账户中取款：
- en: '[PRE103]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Declare a private `Account` attribute named `account`:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `account` 的私有 `Account` 属性：
- en: '[PRE104]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE105]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Implement the `run()` method of the task. Use the `subtractAmount()` method
    of the account to make 10 decrements of 1,000 each from its balance:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现任务的 `run()` 方法。使用账户的 `subtractAmount()` 方法从其余额中减少10次，每次减少1,000：
- en: '[PRE106]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为 `Main` 的类并添加 `main()` 方法来实现示例的主类：
- en: '[PRE107]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create an `Account` object and set its balance to `1000`:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Account` 对象并将其余额设置为 `1000`：
- en: '[PRE108]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Create a new `Company` task and a thread to execute it:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Company` 任务和一个线程来执行它：
- en: '[PRE109]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Create a new `Bank` task and a thread to execute it:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Bank` 任务和一个线程来执行它：
- en: '[PRE110]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Write the initial balance of the account in the console:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台写入账户的初始余额：
- en: '[PRE111]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Start the threads:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动线程：
- en: '[PRE112]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Wait for the finalization of the threads using the `join()` method and write
    the final balance in the console, the number of operations, and the accumulated
    commission of the account:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `join()` 方法等待线程最终化，并在控制台写入最终余额、操作次数和账户的累计佣金：
- en: '[PRE113]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: How it works...
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key to this example is in the `Account` class. In this class, we declared
    an `AtomicLong` variable named `balance` to store the balance of the account,
    a `LongAdder` variable named `operations` to store the number of operations we
    made with the account, and a `DoubleAccumulator` variable named `commission` to
    store the value of the commissions of the operations. In the constructor of the
    `commission` object, we specified that the value will be incremented with the
    expression `0.2*y`. With this, we wanted to specify that we will increment the
    actual value of the variable with the result of its multiplication by `0.2` and
    the value of the parameter we pass to the `accumulate()` method.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的关键是 `Account` 类。在这个类中，我们声明了一个名为 `balance` 的 `AtomicLong` 变量来存储账户的余额，一个名为
    `operations` 的 `LongAdder` 变量来存储我们对账户进行的操作次数，以及一个名为 `commission` 的 `DoubleAccumulator`
    变量来存储操作的佣金值。在 `commission` 对象的构造函数中，我们指定了值将按表达式 `0.2*y` 增加的。通过这种方式，我们想要指定我们将变量的实际值增加其与
    `0.2` 的乘积以及传递给 `accumulate()` 方法的参数值。
- en: To implement the `getBalance()` method that returns the value of the `balance`
    attribute, we used the `get()` method of the `AtomicLong` class. To implement
    the `getOperations()` method that returns a `long` value with the number of operations,
    we used the `longValue()` method. To implement the `getCommission()` method, we
    used the `get()` method of the `DoubleAccumulator` class. To implement the `setBalance()`
    method that establishes the value of the balance attribute, we used the `set()`
    method of the `AtomicLong` class.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现返回 `balance` 属性值的 `getBalance()` 方法，我们使用了 `AtomicLong` 类的 `get()` 方法。为了实现返回操作次数的
    `getOperations()` 方法，我们使用了 `longValue()` 方法。为了实现设置 `balance` 属性值的 `setBalance()`
    方法，我们使用了 `AtomicLong` 类的 `set()` 方法。
- en: To implement the `addAmount()` method that adds an import to the balance of
    the account, we used the `getAndAdd()` method of the `AtomicLong` class that returns
    the value and increments it by the value specified as a parameter. We also used
    the `increment()` method of the `LongAdder` class that increments the value of
    the variable by one and the `accumulate()` method of the `DoubleAccumulator` class
    to increment the value of the `commission` attribute following the specified expression.
    Take into account that the `addAmount()` method is not atomic as a whole although
    it calls three atomic operations.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现向账户余额添加金额的 `addAmount()` 方法，我们使用了 `AtomicLong` 类的 `getAndAdd()` 方法，该方法返回值并按参数指定的值增加它。我们还使用了
    `LongAdder` 类的 `increment()` 方法，该方法将变量的值增加1，以及 `DoubleAccumulator` 类的 `accumulate()`
    方法来按指定表达式增加 `commission` 属性的值。请注意，尽管 `addAmount()` 方法调用了三个原子操作，但它作为一个整体不是原子的。
- en: Finally, to implement the `subtractAmount()` method that decrements the value
    of the `balance` attribute, we used the `getAndAdd()` method. We also included
    calls to the `increment()` and `accumulate()` methods of the `LongAdder` and `DoubleAccumulator`
    classes.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了实现减少 `balance` 属性值的 `subtractAmount()` 方法，我们使用了 `getAndAdd()` 方法。我们还包含了调用
    `LongAdder` 和 `DoubleAccumulator` 类的 `increment()` 和 `accumulate()` 方法。
- en: 'Then, we implemented two different tasks:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了两个不同的任务：
- en: The `Company` class simulates a company that increments the balance of the account.
    Each task of this class makes 10 increments of 1,000 each.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Company` 类模拟了一个公司，它会增加账户的余额。这个类的每个任务都会进行10次每次增加1,000的操作。'
- en: The `Bank` class simulates a bank where the proprietary of the bank account
    takes out its money. Each task of this class makes 10 decrements of 1,000 each.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bank` 类模拟了一个银行，其中银行账户的所有者可以取出其资金。这个类的每个任务都会进行10次每次减去1,000的操作。'
- en: In the `Main` class, you created an `Account` object with a balance of 1,000\.
    Then, you executed a bank task and a company task so the final balance of the
    account is the same as the initial one.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Main` 类中，您创建了一个具有 1,000 元余额的 `Account` 对象。然后，您执行了银行任务和公司任务，因此账户的最终余额与初始余额相同。
- en: 'When you execute the program, you will see how the final balance is the same
    as the initial one. The following screenshot shows the output of an execution
    of this example:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行程序时，您将看到最终余额与初始余额相同。以下截图显示了此示例的执行输出：
- en: '![](img/00047.jpeg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00047.jpeg)'
- en: There's more...
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: As mentioned in the introduction, there are other atomic classes in Java. `AtomicBoolean`,
    `AtomicInteger`, and `AtomicReference` are other examples of atomic classes.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，Java 中还有其他原子类。`AtomicBoolean`、`AtomicInteger` 和 `AtomicReference` 是原子类的其他示例。
- en: 'The `LongAdder` class provides other interesting methods as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`LongAdder` 类提供了以下其他有趣的方法：'
- en: '`add()`: To increment the value of the internal counter by the value specified
    as a parameter'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`: 通过指定为参数的值增加内部计数器的值'
- en: '`decrement()`: To decrement the internal counter by one'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decrement()`: 通过一个减少内部计数器'
- en: '`reset()`: To return the internal value to zero'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset()`: 将内部值重置为零'
- en: You can also use the `DoubleAdder` class that is similar to `LongAdder`, but
    it doesn't have the `increment()` and `decrement()` methods and the internal counter
    is a `double` value.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用类似于 `LongAdder` 的 `DoubleAdder` 类，但它没有 `increment()` 和 `decrement()` 方法，内部计数器是一个
    `double` 值。
- en: You can also use the `LongAccumulator` class that is similar to `DoubleAccumulator`
    but with an internal `long` counter.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用类似于 `DoubleAccumulator` 的 `LongAccumulator` 类，但内部计数器是一个 `long` 值。
- en: See also
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Synchronizing a method* recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 [第 2 章](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736) 中同步方法*，*基本线程同步*'
- en: Using atomic arrays
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子数组
- en: Consider that you need to implement a concurrent application that has one or
    more objects shared by several threads. In such a scenario, you have to protect
    access to their attributes using a synchronization mechanism, such as locks or
    the `synchronized` keyword, to avoid data inconsistency errors.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要实现一个由多个线程共享一个或多个对象的并发应用程序。在这种情况下，您必须使用同步机制（如锁或 `synchronized` 关键字）来保护对其属性的访问，以避免数据不一致错误。
- en: 'These mechanisms have the following problems:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制存在以下问题：
- en: 'Deadlock: This situation occurs when a thread is blocked waiting for a lock
    that is locked by other threads that will never free it. This situation blocks
    the program, so it will never finish.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁：当线程阻塞等待其他线程锁定的锁时，该线程永远不会释放它，这种情况发生。这种情况会阻塞程序，因此它永远不会完成。
- en: If only one thread is accessing the shared object, it has to execute the code
    necessary to get and release the lock.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只有一个线程访问共享对象，它必须执行获取和释放锁所需的代码。
- en: 'To provide better performance in this situation, the **compare-and-swap operation**
    was developed. This operation implements the modification of the value of a variable
    in the following three steps:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在此情况下提供更好的性能，开发了 **比较并交换操作**。此操作通过以下三个步骤实现变量的值修改：
- en: You get the value of the variable, which is the old value of the variable.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您获取变量的值，即变量的旧值。
- en: You change the value of the variable in a temporal variable, which is the new
    value of the variable.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在一个临时变量中更改变量的值，该临时变量是变量的新值。
- en: You substitute the old value with the new value if the old value is equal to
    the actual value of the variable. The old value may be different from the actual
    value if another thread has changed it.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果旧值等于变量的实际值，则用新值替换旧值。如果另一个线程已更改它，则旧值可能不同于实际值。
- en: With this mechanism, you don't need to use a synchronization mechanism, so you
    avoid deadlocks and you obtain better performance. This mechanism also has its
    drawbacks. Operations must be free from any side effects as they might be retried
    using livelocks with highly contended resources; they are also harder to monitor
    for performance when compared with standard locks.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此机制，您不需要使用同步机制，因此可以避免死锁并获得更好的性能。此机制也有其缺点。操作必须没有任何副作用，因为它们可能会在具有高度竞争资源的 livelocks
    中重试；与标准锁相比，它们也难以监控性能。
- en: Java implements this mechanism in **atomic variables**. These variables provide
    the `compareAndSet()` method, which is an implementation of the compare-and-swap
    operation and other methods based on it.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Java在**原子变量**中实现了这种机制。这些变量提供了`compareAndSet()`方法，这是比较并交换操作的实现，以及基于它的其他方法。
- en: Java also introduced **atomic arrays** that provide atomic operations for arrays
    of `integer` or `long` numbers. In this recipe, you will learn how to use the
    `AtomicIntegerArray` class to work with atomic arrays. Take into account that
    if you use `AtomicInteger[]`, it's not a thread-safe object. The individual `AtomicInteger`
    objects are thread-safe, but the array as a data structure is not.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Java还引入了**原子数组**，它为`integer`或`long`数字的数组提供了原子操作。在本例中，你将学习如何使用`AtomicIntegerArray`类来处理原子数组。请注意，如果你使用`AtomicInteger[]`，它不是一个线程安全的对象。单个`AtomicInteger`对象是线程安全的，但数组作为数据结构不是。
- en: Getting ready
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等其他IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Incrementer` and specify that it implements the `Runnable`
    interface:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Incrementer`的类并指定它实现`Runnable`接口：
- en: '[PRE114]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Declare a private `AtomicIntegerArray` attribute named `vector` to store an
    array of `integer` numbers:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`vector`的私有`AtomicIntegerArray`属性，用于存储`integer`数字数组：
- en: '[PRE115]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE116]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Implement the `run()` method. Increment all the elements of the array using
    the `getAndIncrement()` method:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现该`run()`方法。使用`getAndIncrement()`方法增加数组中所有元素的值：
- en: '[PRE117]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Create a class named `Decrementer` and specify that it implements the `Runnable`
    interface:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Decrementer`的类并指定它实现`Runnable`接口：
- en: '[PRE118]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Declare a private `AtomicIntegerArray` attribute named `vector` to store an
    array of `integer` numbers:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`vector`的私有`AtomicIntegerArray`属性，用于存储`integer`数字数组：
- en: '[PRE119]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Implement the constructor of the class to initialize its attribute:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现类的构造函数以初始化其属性：
- en: '[PRE120]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Implement the `run()` method. Decrement all the elements of the array using
    the `getAndDecrement()` method:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现该`run()`方法。使用`getAndDecrement()`方法减少数组中所有元素的值：
- en: '[PRE121]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`Main`的类并添加`main()`方法来实现示例的主类：
- en: '[PRE122]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Declare a constant named `THREADS` and assign the value `100` to it. Create
    an `AtomicIntegerArray` object with 1,000 elements:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`THREADS`的常量并将值`100`分配给它。创建一个包含1,000个元素的`AtomicIntegerArray`对象：
- en: '[PRE123]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Create an `Incrementer` task to work with the atomic array created earlier:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Incrementer`的任务来处理之前创建的原子数组：
- en: '[PRE124]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Create a `Decrementer` task to work with the atomic array created earlier:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Decrementer`任务来处理之前创建的原子数组：
- en: '[PRE125]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Create two arrays to store 100 `Thread` objects:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个数组来存储100个`Thread`对象：
- en: '[PRE126]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Create and launch 100 threads to execute the `Incrementer` task and another
    100 threads to execute the `Decrementer` task. Store the threads in the arrays
    created earlier:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动100个线程来执行`Incrementer`任务，并启动另外100个线程来执行`Decrementer`任务。将线程存储在之前创建的数组中：
- en: '[PRE127]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Wait for the finalization of the threads using the `join()` method:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join()`方法等待线程的最终化：
- en: '[PRE128]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'In the console, write the elements of the atomic array distinct from zero.
    Use the `get()` method to obtain the elements of the atomic array:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台，输出与零不同的原子数组元素。使用`get()`方法获取原子数组的元素：
- en: '[PRE130]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Write a message in the console indicating the finalization of the example:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台输出一条消息，指示示例的最终化：
- en: '[PRE131]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: How it works...
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'In this example, you implemented two different tasks to work with an `AtomicIntegerArray`
    object:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，你实现了两个不同的任务来处理`AtomicIntegerArray`对象：
- en: '`Incrementer`: This class increments all the elements of the array using the
    `getAndIncrement()` method'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Incrementer`：此类使用`getAndIncrement()`方法增加数组中所有元素的值'
- en: '`Decrementer`: This class decrements all the elements of the array using the
    `getAndDecrement()` method'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decrementer`：此类使用`getAndDecrement()`方法减少数组中所有元素的值'
- en: In the `Main` class, you created `AtomicIntegerArray` with 1,000 elements, then
    you executed 100 incrementer and 100 decrementer tasks. At the end of these tasks,
    if there were no inconsistency errors, all the elements of the array must have
    the value `0`. If you execute the program, you will see how the program only writes
    the final message to the console because all the elements are zero.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`类中，你创建了包含1,000个元素的`AtomicIntegerArray`，然后执行了100个增加任务和100个减少任务。在这些任务结束时，如果没有不一致的错误，数组中的所有元素必须具有值`0`。如果你运行程序，你会看到程序只将最终消息写入控制台，因为所有元素都是零。
- en: There's more...
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Nowadays, Java provides another atomic array class. It's called the `AtomicLongArray`
    class and it provides the same methods as the `IntegerAtomicArray` class.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Java提供了另一个原子数组类。它被称为`AtomicLongArray`类，它提供了与`IntegerAtomicArray`类相同的方法。
- en: 'Other interesting methods provided by these classes are:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类提供的其他有趣的方法包括：
- en: '`get(int i)`: Returns the value of the array position specified by the parameter'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(int i)`: 返回由参数指定的数组位置的值'
- en: '`set(int I, int newValue)`: Establishes the value of the array position specified
    by the parameter.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(int I, int newValue)`: 建立由参数指定的数组位置的值。'
- en: See also
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using atomic variables* recipe in this chapter
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中 *使用原子变量* 的配方
- en: Using the volatile keyword
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用volatile关键字
- en: Almost every application reads and writes data to the main memory of the computer.
    For performance reasons, these operations aren't performed directly in the memory.
    CPUs have a system of cache memory, so applications write data in the cache and
    then the data is moved from the cache to the main memory.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都会读取和写入计算机的主内存中的数据。出于性能原因，这些操作不是直接在内存中执行的。CPU有一个缓存内存系统，因此应用程序将数据写入缓存，然后数据从缓存移动到主内存。
- en: In multithread applications, concurrent threads run in different CPUs or cores
    inside a CPU. When a thread modifies a variable stored in the memory, the modification
    is made in the cache or the CPU or core where it's running. However, there's no
    guarantee about when that modification would reach the main memory. If another
    thread wants to read the value of the data, it's possible that it would not read
    the modified value because it's not in the main memory of the computer.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，并发线程在不同的CPU或CPU内部的内核中运行。当一个线程修改存储在内存中的变量时，修改是在它运行的缓存或CPU或内核中进行的。然而，没有保证这种修改何时会达到主内存。如果另一个线程想要读取数据的值，它可能无法读取修改后的值，因为它不在计算机的主内存中。
- en: To solve this problem (there are other solutions, such as the `synchronized`
    keyword), the Java language includes the `volatile` keyword. It's a modifier that
    allows you to specify that a variable must always be read from and stored in the
    main memory, not the cache of your CPU. You should use the volatile keyword when
    it's important that other threads have visibility of the actual value of the variable;
    however, order of access to that variable is not important. In this scenario,
    the `volatile` keyword will give you better performance because it doesn't need
    to get any monitor or lock to access the variable. On the contrary, if the order
    of access to the variable is important, you must use another synchronization mechanism.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题（还有其他解决方案，例如`synchronized`关键字），Java语言包括`volatile`关键字。这是一个修饰符，允许你指定变量必须始终从主内存中读取和存储，而不是你的CPU缓存。当其他线程需要看到变量的实际值时，你应该使用volatile关键字；然而，访问该变量的顺序并不重要。在这种情况下，volatile关键字将为你提供更好的性能，因为它不需要获取任何监视器或锁来访问变量。相反，如果访问变量的顺序很重要，你必须使用另一种同步机制。
- en: In this recipe, you will learn how to use the volatile keyword and the effects
    of its use.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将学习如何使用volatile关键字及其使用效果。
- en: Getting ready
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方示例已使用Eclipse IDE实现。如果你使用Eclipse或不同的IDE，例如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Flag` with a public `Boolean` attribute named `flag`
    initialized to the `true` value:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Flag`的类，其中有一个名为`flag`的公共`Boolean`属性，初始化为`true`值：
- en: '[PRE132]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Create a class named `VolatileFlag` with a public Boolean attribute named `flag`
    initialized to the `true` value. We add the `volatile` modifier to the declaration
    of this attribute:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`VolatileFlag`的类，并有一个名为`flag`的公共布尔属性，初始化为`true`值。我们在这个属性的声明中添加了`volatile`修饰符：
- en: '[PRE133]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Create a class named `Task` and specify that it implements the `Runnable` interface.
    It has a private `Flag` attribute and a constructor to initialize it:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，并指定它实现`Runnable`接口。它有一个私有的`Flag`属性和一个用于初始化它的构造函数：
- en: '[PRE134]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Implement the `run()` method of this task. It will increment an `int` variable
    when the value of the `flag` attribute is `true`. Then, write the final value
    of the variable:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这个任务的`run()`方法。当`flag`属性的值为`true`时，它将增加一个`int`变量的值。然后，写入变量的最终值：
- en: '[PRE135]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Create a class named `VolatileTask` and specify that it implements the `Runnable`
    interface. It has a private `VolatileFlag` attribute and a constructor to initialize
    it:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`VolatileTask`的类，并指定它实现`Runnable`接口。它有一个私有的`VolatileFlag`属性和一个用于初始化它的构造函数：
- en: '[PRE137]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Implement the `run()` method of this task. It''s equal to the one in the `Task`
    class, so it won''t be included here:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这个任务的`run()`方法。它与`Task`类中的方法相同，所以这里不会包括它：
- en: 'Implement the `Main` class with the `main()` method. First, create four objects
    of the `VolatileFlag`, `Flag`, `VolatileTask`, and `Task` classes:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现带有`main()`方法的`Main`类。首先，创建四个`VolatileFlag`、`Flag`、`VolatileTask`和`Task`类的对象：
- en: '[PRE138]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Then, create two threads to execute the tasks, start them, and sleep the main
    thread for a second:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建两个线程来执行任务，启动它们，并让主线程休眠一秒钟：
- en: '[PRE139]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Then, change the value of the `volatileFlag` variable to stop the execution
    of `volatileTask` and sleep the main thread for a second:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`volatileFlag`变量的值更改以停止`volatileTask`的执行，并让主线程休眠一秒钟：
- en: '[PRE140]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Finally, change the value of the `task` object to stop the execution of the
    task and sleep the main thread for a second:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`task`对象的值更改以停止任务的执行，并让主线程休眠一秒钟：
- en: '[PRE141]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: How it works...
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the output of the example:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了示例的输出：
- en: '![](img/00048.jpeg)'
  id: totrans-551
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00048.jpeg)'
- en: The application doesn't finish its execution because the `task` thread has not
    finished. When we change the value of `volatileFlag`-as its `flag` attribute is
    marked as `volatile`--the new value is written in the main memory and `VolatileTask`
    accesses the value immediately and finishes its execution. On the contrary, when
    you change the value of the `flag` object--as its `flag` attribute is not marked
    as volatile-the new value is stored in the cache of the main thread and the task
    object doesn't see the new value and never ends its execution. The `volatile`
    keyword is important not only because it requires that the writes are flushed,
    but also because it ensures that reads are not cached and they fetch the up-to-date
    value from the main memory. It's very important and very often neglected.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序没有完成其执行，因为`task`线程还没有完成。当我们更改`volatileFlag`的值——因为它的`flag`属性被标记为`volatile`——新的值会被写入主内存，并且`VolatileTask`会立即访问这个值并完成其执行。相反，当你更改`flag`对象的值——因为它的`flag`属性没有被标记为volatile——新的值会被存储在主线程的缓存中，任务对象看不到这个新值并且永远不会结束其执行。`volatile`关键字之所以重要，不仅是因为它要求写入被刷新，而且还因为它确保读取不会被缓存，并且它们从主内存中获取最新的值。这非常重要，而且经常被忽视。
- en: Take into account that the `volatile` keyword guarantees that modifications
    are written in the main memory, but its contrary is not always true. For example,
    if you work with a non-volatile integer value shared by more than one thread and
    make a lot of modifications, you may be able to see the modifications made by
    other threads because they were written in the main memory. However, there's no
    guarantee that these changes were passed from the cache to the main memory.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`volatile`关键字保证了修改会被写入主内存，但它的相反情况并不总是成立。例如，如果你与一个由多个线程共享的非volatile整数值工作，并且进行了很多修改，你可能能够看到其他线程所做的修改，因为它们被写入主内存。然而，没有保证这些更改从缓存传递到主内存。
- en: There's more...
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: The `volatile` keyword only works well when the value of the shared variable
    is only modified by one thread. If the variable is modified by multiple threads,
    the `volatile` keyword doesn't protect you from possible data-race conditions.
    It also doesn't make operations, such as `+` or `-`, atomic. For example, the
    `++` operator over a volatile variable is not thread-safe.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 当共享变量的值只被一个线程修改时，`volatile`关键字才能很好地工作。如果变量被多个线程修改，`volatile`关键字不能保护你免受可能的数据竞争条件的影响。它也不使操作，如`+`或`-`，原子化。例如，对volatile变量的`++`操作不是线程安全的。
- en: 'Since Java 5, **Java Memory Model** has a happens--before guarantee established
    with the `volatile` keyword. This fact has two implications:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 5以来，**Java内存模型**通过`volatile`关键字建立了happens-before保证。这一事实有两个影响：
- en: When you modify a volatile variable, its value is sent to the main memory. The
    value of all the variables modified previously by the same thread are sent too.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你修改一个volatile变量时，它的值会被发送到主内存。同一线程之前修改的所有变量的值也会被发送。
- en: Compilers can't reorder sentences that modify a volatile variable for an optimization
    purpose. It can reorder the previous operations and the later ones, but not the
    modifications of a volatile variable. The changes that happen before these modifications
    will be visible to those instructions.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器不能为了优化目的重新排序修改volatile变量的句子。它可以重新排序之前的操作和之后的操作，但不能重新排序volatile变量的修改。这些修改之前发生的变化将对这些指令可见。
- en: See also
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using atomic variables* and *Using atomic arrays* recipe in this chapter
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用原子变量*和*使用原子数组*菜谱
- en: Using variable handles
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量句柄
- en: Variable handles are a new feature of Java 9 that allow you to get a typed reference
    to a variable (attribute, static field, or array element) in order to access it
    in different modes. You can, for example, protect access to this variable in a
    concurrent application by allowing atomic access to the variable. Until now, you
    could only obtain this behavior with atomic variables, but now, you can use variable
    handles to obtain the same functionality without using any synchronization mechanism.
    A variable handle also allows you to get additional access modes to a variable.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 可变句柄是Java 9的一个新特性，它允许你获取一个变量的类型化引用（属性、静态字段或数组元素），以便以不同的模式访问它。例如，你可以通过允许对变量的原子访问来保护在并发应用程序中对这个变量的访问。到目前为止，你只能通过原子变量获得这种行为，但现在，你可以使用可变句柄来获得相同的功能，而不需要使用任何同步机制。可变句柄还允许你获取变量的附加访问模式。
- en: In this recipe, you will learn how to obtain and use a variable handle and the
    benefits you obtain using it.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何获取和使用可变句柄，以及使用它所获得的益处。
- en: Getting ready
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例已使用Eclipse IDE实现。如果你使用Eclipse或NetBeans等不同的IDE，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to implement the example:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'Create a class named `Account` with two double public attributes named `amount`
    and `unsafeAmount`. Implement the constructor to initialize its values:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Account`的类，有两个名为`amount`和`unsafeAmount`的公共double属性。实现构造函数以初始化其值：
- en: '[PRE142]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Create a class named `Decrementer` and specify that it implements the `Runnable`
    interface. It has a private `Account` attribute initialized in the constructor
    of the class:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Decrementer`的类，并指定它实现`Runnable`接口。它有一个名为`Account`的私有属性，在类的构造函数中初始化：
- en: '[PRE143]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Implement the `run()` method. This method will make 10,000 decrement operations
    in the `amount` and `unsafeAmount` attributes. To modify the value of the amount
    attribute, use `VarHandle`. Obtain it using the `lookup()` method of the `MethodHandles`
    class, then use the `getAndAdd()` method to modify the value of the attribute.
    To modify the `unsafeAmount` attribute, use the `=` operator:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现方法`run()`。这个方法将在`amount`和`unsafeAmount`属性上执行10,000次递减操作。要修改`amount`属性的值，使用`VarHandle`。通过使用`MethodHandles`类的`lookup()`方法获取它，然后使用`getAndAdd()`方法修改属性的值。要修改`unsafeAmount`属性，使用`=`运算符：
- en: '[PRE144]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Implement a class named `Incrementer`. This will be equivalent to the `Drementer`
    class, but it will increase the value of the account. The source code of this
    class won't be included here.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`Incrementer`的类。这将与`Decrementer`类等效，但它会增加账户的值。这个类的源代码将不会在这里包括。
- en: 'Finally, implement the `Main` class with the `main()` method. First, create
    an `account` object:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`Main`类中的`main()`方法。首先，创建一个`account`对象：
- en: '[PRE145]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Then, create a thread to execute an `Incrementer` task and a thread to execute
    a `Decrementer` task. Start them and wait for their finalization using the `join()`
    method:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个线程来执行`Incrementer`任务，并创建一个线程来执行`Decrementer`任务。启动它们并使用`join()`方法等待它们的最终化：
- en: '[PRE146]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Finally, write the value of the amount and `unsafeAmount` attributes in the
    console:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在控制台中写入`amount`和`unsafeAmount`属性的值：
- en: '[PRE147]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: How it works...
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the output of an execution of the application:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了应用程序执行的结果：
- en: '![](img/00049.jpeg)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00049.jpeg)'
- en: As you make the same number of increment and decrement operations, the expected
    result in both cases is `0`. We obtain this result with the amount attribute because
    as we access it using the `VarHandle`, we guarantee atomic access to its modifications.
    On the other hand, the `unsafeAmount` doesn't have the expected value. Access
    to this value is not protected and we have a data-race condition.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行相同数量的增加和减少操作时，两种情况下的预期结果都是`0`。我们通过`amount`属性获得这个结果，因为我们使用`VarHandle`访问它时，我们保证了对其修改的原子访问。另一方面，`unsafeAmount`没有预期的值。对这个值的访问没有得到保护，我们有一个数据竞争条件。
- en: To use a variable handle, first we have to obtain it using the `lookup()` method
    of the `MethodHandles` class, followed by the `in()` method and then the `findVarHandle()`
    method. The `lookup()` method returns a `Lookup` object, the `in()` method returns
    a `Lookup` object of the specified class—in our case, the `Account` class—and
    `findVarHandle()` generates `VarHandle` for the attribute we want to access.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用变量句柄，首先我们必须使用`MethodHandles`类的`lookup()`方法来获取它，然后是`in()`方法，然后是`findVarHandle()`方法。`lookup()`方法返回一个`Lookup`对象，`in()`方法返回指定类的`Lookup`对象——在我们的例子中是`Account`类，而`findVarHandle()`生成我们想要访问的属性的`VarHandle`。
- en: Once we have the `VarHandle` object, we can use different methods to use different
    access modes. In this example, we used the `getAndAdd()` method. This method guarantees
    atomic access to increment the value of the attribute. We pass to them the object
    we want to access and the value of the increment.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`VarHandle`对象，我们就可以使用不同的方法来使用不同的访问模式。在这个例子中，我们使用了`getAndAdd()`方法。这个方法保证了增加属性值的原子访问。我们向它们传递我们想要访问的对象和增加的值。
- en: The next section provides more information about the different access modes
    and the methods you can use in each case.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节提供了有关不同访问模式和每种情况下可以使用的方法的更多信息。
- en: There's more...
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You have four different access types to a variable with a variable handle:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 你有四种不同的访问类型来访问带有变量句柄的变量：
- en: '**Read mode**: This is used to get read mode access to a variable. You can
    use the following methods:'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取模式**：这是用来获取变量的读取访问模式。你可以使用以下方法：'
- en: '`get()`: Read the value of the variable as if it was declared non-volatile'
  id: totrans-591
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 以声明为非`volatile`的方式读取变量的值'
- en: '`getVolatile()`: Read the value of the variable as if it was declared volatile'
  id: totrans-592
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getVolatile()`: 以声明为`volatile`的方式读取变量的值'
- en: '`getAcquire()`: Read the value of the variable and guarantee that the following
    instructions that modify or access this variable are not reordered before the
    instructions for optimization purposes'
  id: totrans-593
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAcquire()`: 读取变量的值并保证在优化目的的指令之前，不会对修改或访问此变量的指令进行重排'
- en: '`getOpaque()`: Read the value of variable and guarantee that the instructions
    of the current thread are not reordered; no guarantee is provided for other threads'
  id: totrans-594
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOpaque()`: 读取变量的值并保证当前线程的指令不会被重排；不对其他线程提供保证'
- en: '**Write mode**: This is used to get write access mode to a variable. You can
    use the `set()`, `setVolatile()`, `setRelease()`, and `setOpaque()` methods. They
    are equivalent to the previous ones but with write access.'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入模式**：这是用来获取变量的写入访问模式。你可以使用`set()`、`setVolatile()`、`setRelease()`和`setOpaque()`方法。它们与之前的方法等效，但具有写入访问。'
- en: '**Atomic access mode**: This is used to get a functionality that is similar
    to the one provided by the atomic variables with operations to, for example, compare
    and get the value of the variable. You can use the following methods:'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子访问模式**：这是用来获取与原子变量提供的功能类似的功能，例如比较和获取变量的值。你可以使用以下方法：'
- en: '`compareAndSet()`: Change the value of the variable as it was declared as a
    volatile variable if the expected value passed as parameter is equal to the current
    value of the variable'
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compareAndSet()`: 如果传递给参数的预期值等于变量的当前值，则将变量的值更改为易失性变量声明的值'
- en: '`weakCompareAndSet()` and `weakCompareAndSetVolatile()`: Possibly atomically''
    changes the value of the variable as it was declared as non-volatile or volatile
    variables respectively if the expected value passed as parameter is equals to
    the current value of the variable'
  id: totrans-598
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weakCompareAndSet()`和`weakCompareAndSetVolatile()`: 如果传递给参数的预期值等于变量的当前值，则可能以原子方式更改变量的值，分别作为非易失性或易失性变量声明'
- en: '**Numerical update access mode**: This is to modify numerical values in an
    atomic way.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数值更新访问模式**：这是以原子方式修改数值。'
- en: See also
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using atomic variables* and *Using atomic arrays* recipe in this chapter
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用原子变量*和*使用原子数组*配方
