- en: Chapter 3. Multithreading and Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。多线程和响应式编程
- en: In this lesson, we will look at an approach to support a high performance of
    an application by programmatically splitting the task between several workers.
    That was how the pyramids were built 4,500 years ago, and this method has not
    failed to deliver since then. But there is a limitation on how many laborers can
    be brought to work on the same project. The shared resources provide a ceiling
    to how much the workforce can be increased, whether the resources are counted
    in square feet and gallons (as the living quarters and water in the time of the
    pyramids) or in gigabytes and gigahertz (as the memory and processing power of
    a computer).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们将探讨一种通过编程方式在几个工作者之间分割任务以支持应用程序高性能的方法。这就是4500年前建造金字塔的方式，这种方法自那时以来一直有效。但是，对可以召集到同一项目上的劳工数量有一个限制。共享资源为劳动力增加的上限提供了一个天花板，无论是按平方英尺和加仑（如金字塔时代的居住区和水源）计算，还是按千兆字节和千兆赫兹（如计算机的内存和处理能力）计算。
- en: Allocation, usage, and limitations of a living space and computer memory are
    very similar. However, we perceive the processing power of the human workforce
    and CPU quite differently. Historians tell us that thousands of ancient Egyptians
    worked on cutting and moving massive stone blocks at the same time. We do not
    have any problem understanding what they mean even if we know that these workers
    rotated all the time, some of them resting or attending to other matters temporarily
    and then coming back to replace the ones who have finished their annual assignment,
    others died or got injured and were replaced by the new recruits.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 生活空间和计算机内存的分配、使用和限制非常相似。然而，我们对人力和CPU的处理能力有不同的感知。历史学家告诉我们，成千上万的古埃及人在同一时间从事切割和移动巨大的石块。即使我们知道这些工人一直在轮换，其中一些人暂时休息或处理其他事务，然后回来替换完成年度任务的人，其他人死亡或受伤并被新招募的工人替换，我们也不会对他们的意思有任何疑问。
- en: But in case of computer data processing, when we hear about working threads
    executing at the same time, we automatically assume that they literally do what
    they are programmed to do in parallel. Only after we look under the hood of such
    a system we realize that such parallel processing is possible only when the threads
    are executed each by a different CPU. Otherwise, they time share the same processing
    power, and we perceive them working at the same time only because the time slots
    they use are very short--a fraction of the time units we have used in our everyday
    life. When the threads share the same resource, in computer science we say they
    do it concurrently.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但在计算机数据处理的情况下，当我们听到关于同时执行的工作线程时，我们自然会假设它们确实按照编程的方式并行执行。只有当我们揭开这样的系统的盖子后，我们才意识到这种并行处理只有在每个线程由不同的CPU执行时才可能。否则，它们共享相同的处理能力，我们之所以认为它们同时工作，仅仅是因为它们使用的时隙非常短——只是我们日常生活中所用时间单位的一小部分。当线程共享相同的资源时，在计算机科学中我们说它们是并发执行的。
- en: In this lesson, we will discuss the ways to increase Java application performance
    by using the workers (threads) that process data concurrently. We will show how
    to use threads effectively by pooling them, how to synchronize the concurrently
    accessed data, how to monitor and tune worker threads at runtime, and how to take
    advantage of the reactive programming concept.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们将讨论通过使用并发处理数据的工作者（线程）来提高Java应用程序性能的方法。我们将展示如何通过池化线程来有效地使用线程，如何同步访问的数据，如何在运行时监控和调整工作者线程，以及如何利用响应式编程的概念。
- en: But before doing that, let's revisit the basics of creating and running multiple
    threads in the same Java process.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这样做之前，让我们回顾一下在同一个Java进程中创建和运行多个线程的基本知识。
- en: Prerequisites
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'There are principally two ways to create worker threads--by extending the `java.lang.Thread`
    class and by implementing the `java.lang.Runnable` interface. While extending
    the `java.lang.Thread` class, we are not required to implement anything:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建工作者线程主要有两种方式——通过扩展`java.lang.Thread`类和通过实现`java.lang.Runnable`接口。当我们扩展`java.lang.Thread`类时，我们不需要实现任何内容：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `MyThread` class inherits the `name` property with an automatically generated
    value and the `start()` method. We can run this method and check the `name`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MyThread`类继承了具有自动生成值的`name`属性和`start()`方法。我们可以运行这个方法并检查`name`：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we run this code, the result will be as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，结果将如下所示：
- en: '![Prerequisites](img/03_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_01.jpg)'
- en: As you can see, the generated `name` is `Thread-0`. If we created another thread
    in the same Java process, the `name` would be `Thread-1` and so on. The `start()`
    method does nothing. The source code shows that it calls the `run()` method if
    such a method is implemented.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，生成的`name`是`Thread-0`。如果我们在这个Java进程中创建另一个线程，`name`将是`Thread-1`，依此类推。`start()`方法什么都不做。源代码显示，如果实现了`run()`方法，它会调用这个方法。
- en: 'We can add any other method to the `MyThread` class as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样向`MyThread`类添加任何其他方法：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `calculateAverageSqrt()` method calculates the average square root of the
    first 99,999 integers and assigns the result to a property that can be accessed
    anytime. The following code demonstrates how we can use it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateAverageSqrt()`方法计算前99999个整数的平均平方根，并将结果分配给一个可以在任何时候访问的属性。以下代码演示了我们可以如何使用它：'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running this brings up the following result:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会得到以下结果：
- en: '![Prerequisites](img/03_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_02.jpg)'
- en: 'As you would expect, the `calculateAverageSqrt()` method blocks until the calculations
    are completed. It was executed in the main thread without it taking advantage
    of multithreading. To do this, we move the functionality in the `run()` method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的那样，`calculateAverageSqrt()`方法会阻塞，直到计算完成。它在主线程中执行，没有利用多线程的优势。为了做到这一点，我们将`run()`方法中的功能移动：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we call the `start()` method again, as in the first example and expect
    the result to be calculated:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次调用`start()`方法，就像第一个例子一样，并期望得到计算结果：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, the output of this code may surprise you:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码的输出可能会让你感到惊讶：
- en: '![Prerequisites](img/03_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_03.jpg)'
- en: 'This means that the main thread accessed (and printed) the `t1.getResult()`
    function before the new `t1` thread finished its calculations. We can experiment
    and change the implementation of the `run()` method to see if the `t1.getResult()`
    function can get a partial result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着主线程在新的`t1`线程完成计算之前就访问（并打印）了`t1.getResult()`函数。我们可以通过实验和修改`run()`方法的实现来查看`t1.getResult()`函数是否可以得到部分结果：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, if we run the `demo_thread_03()` method again, the result remains
    the same:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们再次运行`demo_thread_03()`方法，结果仍然是相同的：
- en: '![Prerequisites](img/03_04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_04.jpg)'
- en: It takes time to create a new thread and get it going. Meanwhile, the `main`
    thread calls the `t1.getResult()` function immediately, thus getting no results
    yet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的线程并让它开始运行需要时间。同时，`main`线程立即调用`t1.getResult()`函数，因此还没有得到任何结果。
- en: 'To give the new (child) thread time to complete the calculations, we add the
    following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给新的（子）线程足够的时间来完成计算，我们添加以下代码：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You have noticed that we have paused the main thread by 100 ms and added printing
    of the current thread name, to illustrate what we mean by `main` thread, the name
    that is assigned automatically to the thread that executes the `main()` method.
    The output of the previous code is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经注意到我们暂停了主线程100毫秒，并添加了打印当前线程名称，以说明我们所说的“主线程”，即自动分配给执行`main()`方法的线程的名称。前一段代码的输出如下：
- en: '![Prerequisites](img/03_05.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_05.jpg)'
- en: 'The delay of 100 ms was enough for the `t1` thread to finish the calculations.
    That was the first of two ways of creating threads for multithreaded calculation.
    The second way is to implement the `Runnable` interface. It may be the only way
    possible if the class that does calculations already extends some other class
    and you cannot or don''t want to use composition for some reasons. The `Runnable`
    interface is a functional interface (has only one abstract method) with the `run()`
    method that has to be implemented:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 100毫秒的延迟足以让`t1`线程完成计算。这是创建多线程计算线程的两种方法中的第一种。第二种方法是实现`Runnable`接口。如果执行计算的类已经扩展了其他某个类，并且由于某些原因不能或不想使用组合，这可能就是唯一可行的方法。`Runnable`接口是一个功能接口（只有一个抽象方法），其中包含必须实现的`run()`方法：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We implement this interface in the `MyRunnable` class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`MyRunnable`类中实现这个接口：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It has the same functionality as the `Thread01` class earlier plus we have added
    id that allows identifying the thread if necessary since the `Runnable` interface
    does not have the built-in `getName()` method like the `Thread` class has.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有与之前`Thread01`类相同的功能，我们还添加了一个id，如果需要的话可以用来识别线程，因为`Runnable`接口没有像`Thread`类那样的内置`getName()`方法。
- en: 'Similarly, if we execute this class without pausing the `main` thread, like
    this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们像这样执行这个类而不暂停`main`线程：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output will be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Prerequisites](img/03_06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_06.jpg)'
- en: 'We will now add the pause as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加暂停，如下所示：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result is exactly the same as the one produced by the `Thread01` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与`Thread01`类产生的结果完全相同：
- en: '![Prerequisites](img/3_07.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/3_07.jpg)'
- en: 'All the previous examples stored the generated result in the class property.
    But it is not always the case. Typically, the worker thread either passes its
    value to another thread or stores it in a database or somewhere else externally.
    In such a case, one can take advantage of the `Runnable` interface being a functional
    interface and pass the necessary processing function into a new thread as a lambda
    expression:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前例都将生成的结果存储在类属性中。但情况并不总是如此。通常，工作线程要么将其值传递给另一个线程，要么将其存储在数据库或其他外部位置。在这种情况下，可以利用`Runnable`接口作为函数式接口，并将必要的处理函数作为lambda表达式传递给新线程：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result is going to be exactly the same, as shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将完全相同，如下所示：
- en: '![Prerequisites](img/03_08.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_08.jpg)'
- en: 'Depending on the preferred style, you can re-arrange the code and isolate the
    lambda expression in a variable, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据首选风格，你可以重新排列代码并将lambda表达式隔离在变量中，如下所示：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you can put the lambda expression in a separate method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以将lambda表达式放在一个单独的方法中：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result is going to be the same, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将和这里显示的一样：
- en: '![Prerequisites](img/03_09.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_09.jpg)'
- en: With the basic understanding of threads creation in place, we can now return
    to the discussion about using the multithreading for building a high-performance
    application. In other words, after we understand the abilities and resources needed
    for each worker, we can now talk about logistics of bringing in many of them for
    such a big-scale project as the Great Pyramid of Giza.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在对线程创建的基本理解到位之后，我们现在可以回到关于使用多线程构建高性能应用的讨论。换句话说，在了解每个工作线程所需的能力和资源之后，我们现在可以讨论将众多线程引入如此大规模项目（如吉萨金字塔）的物流问题。
- en: To write code that manages the life cycle of worker threads and their access
    to the shared resources is possible, but it is quite the same from one application
    to another. That's why, after several releases of Java, the thread management
    plumbing became part of the standard JDK library as the `java.util.concurrent`
    package. This package has a wealth of interfaces and classes that support multithreading
    and concurrency. We will discuss how to use most of this functionality in the
    subsequent sections, while talking about thread pools, threads monitoring, thread
    synchronization, and the related subjects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编写管理工作线程生命周期及其对共享资源访问的代码是可能的，但这在不同的应用中是相同的。这就是为什么在Java的几个版本之后，线程管理的基础设施成为了标准JDK库的一部分，即`java.util.concurrent`包。这个包包含大量支持多线程和并发的接口和类。我们将在后续章节中讨论如何使用这些功能的大部分，同时讨论线程池、线程监控、线程同步及相关主题。
- en: Thread Pools
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池
- en: In this section, we will look into the `Executor` interfaces and their implementations
    provided in the `java.util.concurrent` package. They encapsulate thread management
    and minimize the time an application developer spends on the writing code related
    to threads' life cycles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨`java.util.concurrent`包中定义的`Executor`接口及其实现。它们封装了线程管理，并最小化了应用开发者编写与线程生命周期相关的代码所需的时间。
- en: 'There are three `Executor` interfaces defined in the `java.util.concurrent`
    package. The first is the base `Executor` interface has only one `void execute(Runnable
    r)` method in it. It basically replaces the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`java.util.concurrent`包中定义了三个`Executor`接口。第一个是基本的`Executor`接口，其中只有一个`void execute(Runnable
    r)`方法。它基本上替换了以下内容：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, we can also avoid a new thread creation by getting it from a pool.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以通过从池中获取它来避免创建新线程。
- en: 'The second is the `ExecutorService` interface extends `Executor` and adds the
    following groups of methods that manage the life cycle of the worker threads and
    of the executor itself:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`ExecutorService`接口，它扩展了`Executor`并添加了以下一组方法，用于管理工作线程和执行器本身的生命周期：
- en: '`submit()`: Place in the queue for the execution of an object of the interface
    `Runnable` or interface `Callable` (allows the worker thread to return a value);
    return object of `Future` interface, which can be used to access the value returned
    by the `Callable` and to manage the status of the worker thread'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit()`: 将`Runnable`接口或`Callable`接口的对象放入队列以执行（允许工作线程返回一个值）；返回`Future`接口的对象，可以用来访问`Callable`返回的值以及管理工作线程的状态'
- en: '`invokeAll()`: Place in the queue for the execution of a collection of interface
    `Callable` objects return, list of `Future` objects when all the worker threads
    are complete (there is also an overloaded `invokeAll()` method with timeout)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAll()`: 将一组接口 `Callable` 对象放入执行队列，当所有工作线程完成时返回 `Future` 对象列表（也有带超时的重载
    `invokeAll()` 方法）'
- en: '`invokeAny()`: Place in the queue for the execution of a collection of interface
    `Callable` objects; return one `Future` object of any of the worker threads, which
    has completed (there is also an overloaded `invokeAny()` method with timeout)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAny()`: 将一组接口 `Callable` 对象放入执行队列；返回任意一个工作线程完成的 `Future` 对象（也有带超时的重载
    `invokeAny()` 方法）'
- en: 'Methods that manage the worker threads status and the service itself:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 管理工作线程状态和服务的相关方法：
- en: '`shutdown()`: This prevents new worker threads from being submitted to the
    service'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown()`: 防止将新工作线程提交到服务中'
- en: '`isShutdown()`: This checks whether the shutdown of the executor was initiated'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShutdown()`: 检查执行器的关闭是否被启动'
- en: '`awaitTermination(long timeout, TimeUnit timeUnit)`: This waits until all worker
    threads have completed execution after a shutdown request, or the timeout occurs,
    or the current thread is interrupted, whichever happens first'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitTermination(long timeout, TimeUnit timeUnit)`: 在发出关闭请求后等待所有工作线程完成执行，或者超时发生，或者当前线程被中断，以先发生者为准'
- en: '`isTerminated()`: This checks whether all the worker threads have completed
    after the shutdown was initiated; it never returns `true` unless either `shutdown()`
    or `shutdownNow()` was called first'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`: 检查在启动关闭后所有工作线程是否已完成；除非首先调用 `shutdown()` 或 `shutdownNow()`，否则它永远不会返回
    `true`'
- en: '`shutdownNow()`: This interrupts each worker thread that is not completed;
    a worker thread should be written so that it checks its own status (using `Thread.currentThread().isInterrupted()`,
    for example) periodically and gracefully shuts down on its own; otherwise, it
    will continue running even after `shutdownNow()` was called'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdownNow()`: 中断所有未完成的工作线程；工作线程应该被编写成定期检查自己的状态（例如使用 `Thread.currentThread().isInterrupted()`），并优雅地自行关闭；否则，即使在调用
    `shutdownNow()` 之后，它也会继续运行'
- en: The third interface is `ScheduledExecutorService` that extends `ExecutorService`
    and adds methods that allow scheduling of the execution (one-time and periodic
    one) of the worker threads.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个接口是 `ScheduledExecutorService`，它扩展了 `ExecutorService` 并添加了允许调度工作线程执行（一次性或周期性）的方法。
- en: 'A pool-based implementation of `ExecutorService` can be created using the `java.util.concurrent.ThreadPoolExecutor`
    or `java.util.concurrent.ScheduledThreadPoolExecutor` class. There is also a `java.util.concurrent.Executors`
    factory class that covers most of the practical cases. So, before writing a custom
    code for worker threads pool creation, we highly recommend looking into using
    the following factory methods of the `java.util.concurrent.Executors` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `java.util.concurrent.ThreadPoolExecutor` 或 `java.util.concurrent.ScheduledThreadPoolExecutor`
    类创建基于池的 `ExecutorService` 实现。还有一个 `java.util.concurrent.Executors` 工厂类，涵盖了大多数实际案例。因此，在为工作线程池编写自定义代码之前，我们强烈建议查看
    `java.util.concurrent.Executors` 类的以下工厂方法：
- en: '`newSingleThreadExecutor()`: This creates an `ExecutorService` (pool) instance
    that executes worker threads sequentially'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadExecutor()`: 创建一个 `ExecutorService`（池）实例，按顺序执行工作线程'
- en: '`newFixedThreadPool()`: This creates a thread pool that reuses a fixed number
    of worker threads; if a new task is submitted when all the worker threads are
    still executing, it will be set into the queue until a worker thread is available'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newFixedThreadPool()`: 创建一个线程池，重用固定数量的工作线程；如果所有工作线程仍在执行时提交新任务，它将被放入队列中，直到有工作线程可用'
- en: '`newCachedThreadPool()`: This creates a thread pool that adds a new thread
    as needed, unless there is an idle thread created before; threads that have been
    idle for sixty seconds are removed from the cache'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCachedThreadPool()`: 创建一个线程池，根据需要添加新线程，除非在之前创建了空闲线程；空闲六十秒的线程将从缓存中移除'
- en: '`newScheduledThreadPool()`: This creates a thread pool of a fixed size that
    can schedule commands to run after a given delay, or to execute periodically'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newScheduledThreadPool()`: 创建一个固定大小的线程池，可以调度在给定延迟后运行或周期性执行的命令'
- en: '`newSingleThreadScheduledExecutor()`: This creates a single-threaded executor
    that can schedule commands to run after a given delay, or to execute periodically'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadScheduledExecutor()`: 创建一个单线程执行器，可以调度在给定延迟后运行或周期性执行的命令'
- en: '`newWorkStealingThreadPool()`: This creates a thread pool that uses the same
    work-stealing mechanism used by `ForkJoinPool`, which is particularly useful in
    case the worker threads generate other threads, such as in recursive algorithms'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newWorkStealingThreadPool()`：这创建了一个使用与`ForkJoinPool`相同的窃取工作机制的线程池，这对于工作线程生成其他线程的情况特别有用，例如在递归算法中。'
- en: Each of these methods has an overloaded version that allows passing in a `ThreadFactory`
    that is used to create a new thread when needed. Let's see how it all works in
    a code sample.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都有重载版本，允许传入一个`ThreadFactory`，当需要时用于创建新线程。让我们通过代码示例看看这一切是如何工作的。
- en: 'First, we create a `MyRunnable02` class that implements `Runnable`—our future
    worker threads:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个实现`Runnable`的`MyRunnable02`类——我们未来的工作线程：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the important difference of this implementation from the previous examples--the
    `takeWhile(i -> !Thread.currentThread().isInterrupted())` operation allows the
    stream flowing as long as the thread worker status is not set to interrupted,
    which happens when the `shutdownNow()` method is called. As soon as the predicate
    of the `takeWhile()` returns `false` (the worker thread is interrupted), the thread
    stops producing the result (just ignores the current `result` value). In a real
    system, it would equate to skipping storing `result` value in the database, for
    example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个实现与之前示例的重要区别——`takeWhile(i -> !Thread.currentThread().isInterrupted())`操作允许只要工作线程的状态没有被设置为中断（在调用`shutdownNow()`方法时发生），流就可以继续流动。一旦`takeWhile()`的谓词返回`false`（工作线程被中断），线程就会停止产生结果（仅忽略当前的`result`值）。在真实系统中，这相当于跳过将`result`值存储到数据库，例如。
- en: It is worth noting here that using the `interrupted()` status method for checking
    the thread status in the preceding code may lead to inconsistent results. Since
    the `interrupted()` method returns the correct state value and then clears the
    thread state, the second call to this method (or the call to the method `isInterrupted()`
    after the call to the method `interrupted()`) always returns `false`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在前面的代码中使用`interrupted()`状态方法来检查线程状态可能会导致结果不一致。由于`interrupted()`方法返回正确的状态值然后清除线程状态，因此对该方法的第二次调用（或者在调用`interrupted()`方法之后的`isInterrupted()`方法的调用）总是返回`false`。
- en: 'Although it is not the case in this code, we would like to mention here a mistake
    some developers make while implementing `try/catch` block in a worker thread.
    For example, if the worker needs to pause and wait for an interrupt signal, the
    code often looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个代码中不是这种情况，但我们想在这里提到一些开发者在实现工作线程中的`try/catch`块时可能会犯的错误。例如，如果工作线程需要暂停并等待中断信号，代码通常看起来像这样：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can show how to execute the earlier `MyRunnable02` class with a cached
    pool implementation of the `ExecutiveService` pool (other types of thread pool
    are used similarly). First, we create the pool, submit three instances of the
    `MyRunnable02` class for execution and shut down the pool:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以展示如何使用`ExecutiveService`池的缓存池实现来执行之前的`MyRunnable02`类（其他类型的线程池以类似方式使用）。首先，我们创建池，提交三个`MyRunnable02`类的实例以供执行，然后关闭池：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run these lines, we will see the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这些行，我们将看到以下输出：
- en: '![Thread Pools](img/03_10.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![线程池](img/03_10.jpg)'
- en: No surprises here! The `isShutdown()` method returns a `false` value before
    the `shutdown()` method is called and a `true` value afterward. The `isTerminated()`
    method returns a `false` value, because none of the worker threads has completed
    yet.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惊喜！在调用`shutdown()`方法之前，`isShutdown()`方法返回`false`值，之后返回`true`值。`isTerminated()`方法返回`false`值，因为还没有任何工作线程完成。
- en: 'Let''s test the `shutdown()` method by adding the following code after it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`shutdown()`方法之后添加以下代码来测试它：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output will now have the following message (the screenshot would be either
    too big for this page or not readable when fitting):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出将包含以下消息（截图可能太大，无法适应这个页面，或者当适应页面时无法阅读）：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As expected, after the `shutdown()` method is called, no more worker threads
    can be added to the pool.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，在调用`shutdown()`方法之后，不能再向池中添加更多的工作线程。
- en: 'Now, let''s see what we can do after the shutdown was initiated:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在启动关闭之后我们能做什么：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `printRunningThreadIds()` method looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`printRunningThreadIds()`方法看起来像这样：'
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '![Thread Pools](img/03_11.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![线程池](img/03_11.jpg)'
- en: This means that 100 ms was enough for each worker thread to complete the calculations.
    (Notice, if you try to reproduce this data on your computer, the results might
    be slightly different because of the difference in performance, so you would need
    to adjust the timeout.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个工作线程有足够的时间完成计算。（注意，如果您尝试在您的计算机上重现这些数据，结果可能会有所不同，因为性能的差异，因此您需要调整超时时间。）
- en: 'When we have decreased the wait time to 75 ms, the output became as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将等待时间减少到75毫秒时，输出如下所示：
- en: '![Thread Pools](img/03_12.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![线程池](img/03_12.jpg)'
- en: The 75 ms on our computer was not enough to let all the threads complete, so
    they were interrupted by `shutdownNow()` and their partial results were ignored.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的计算机上，75毫秒不足以让所有线程完成，因此它们被`shutdownNow()`中断，并且它们的部分结果被忽略。
- en: 'Let''s now remove the check of the interrupted status in the `MyRunnable01`
    class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从`MyRunnable01`类中移除对中断状态的检查：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Without the check, even if we decrease the timeout to 1 ms, the result will
    be as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 没有检查，即使我们将超时时间减少到1毫秒，结果也会如下所示：
- en: '![Thread Pools](img/03_13.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![线程池](img/03_13.jpg)'
- en: That is because the worker threads have never noticed that somebody tried to
    interrupt them and completed their assigned calculations. This last test demonstrates
    the importance of watching for the interrupted state in a work thread in order
    to avoid many possible problems, namely, data corruption and memory leak.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为工作线程从未注意到有人试图中断它们，并且已经完成了分配的计算。这个最后的测试展示了在工作线程中监视中断状态的重要性，以避免许多可能的问题，即数据损坏和内存泄漏。
- en: The demonstrated cached pool works fine and poses no problem if the worker threads
    perform short tasks and their number cannot grow excessively large. If you need
    to have more control over the max number of worker threads running at any time,
    use the fixed size thread pool. We will discuss how to choose the pool size in
    one of the following sections of this lesson.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的缓存池在工作线程执行短期任务且数量不会过大时运行良好，不会出现任何问题。如果您需要更严格控制任何时刻运行的最多工作线程数，请使用固定大小的线程池。我们将在本课的后续部分讨论如何选择池大小。
- en: The single-thread pool is a good fit for executing tasks in a certain order
    or in the case when each of them requires so many resources that cannot be executed
    in parallel with another. Yet another case for using a single-thread execution
    would be for workers that modify the same data, but the data cannot be protected
    from the parallel access another way. The thread synchronization will be discussed
    in more detail in one of the following sections of this lesson, too.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程池非常适合按特定顺序执行任务，或者当每个任务都需要如此多的资源，以至于不能与其他任务并行执行时。使用单线程执行的其他情况可能是，当工作线程修改相同的数据，但数据无法通过其他方式保护免受并行访问时。线程同步将在本课的后续部分更详细地讨论。
- en: In our sample code, so far we have only included the `execute()` method of the
    `Executor` interface. We will demonstrate the other methods of the `ExecutorService`
    pool in the following section while discussing threads monitoring.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，到目前为止，我们只包括了`Executor`接口的`execute()`方法。我们将在本课的后续部分讨论线程监控时演示`ExecutorService`池的其他方法。
- en: And the last remark in this section. The worker threads are not required to
    be objects of the same class. They may represent completely different functionality
    and still be managed by one pool.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最后一点。工作线程不一定是同一类的对象。它们可能代表完全不同的功能，但仍可由一个池管理。
- en: Monitoring Threads
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视线程
- en: 'There are two ways to monitor threads, programmatically and using the external
    tools. We have already seen how the result of a worker calculation could be checked.
    Let''s revisit that code. We will also slightly modify our worker implementation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 监视线程有两种方式，一种是程序化方式，另一种是使用外部工具。我们已经看到了如何检查工作计算的结果。让我们回顾一下那段代码。我们还将稍微修改我们的工作实现：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For the worker thread identification, instead of custom ID, we now use the
    thread name assigned automatically at the time of the execution (that is why we
    assign the `name` property in the `run()` method that is called in the context
    of the execution when the thread acquires its name). The new class `MyRunnable03`
    can be used like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作线程的标识，我们不再使用自定义ID，而是现在使用在执行时自动分配的线程名（这就是为什么我们在`run()`方法中分配`name`属性，该方法在执行上下文中被调用，当线程获得其名称时）。新的类`MyRunnable03`可以这样使用：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `shutdown()` method contains the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutdown()`方法包含以下代码：'
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we run the preceding code, the output will be as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，输出将如下所示：
- en: '![Monitoring Threads](img/03_14.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_14.jpg)'
- en: If the result on your computer is different, try to increase the input value
    to the `sleepMs()` method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计算机上的结果不同，请尝试增加 `sleepMs()` 方法的输入值。
- en: 'Another way to get information about the application worker threads is by using
    the `Future` interface. We can access this interface using the `submit()` method
    of the `ExecutorService` pool, instead of the `execute()`, `invokeAll()`, or `invokeAny()`
    methods. This code shows how to use the `submit()` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取应用程序工作线程信息的方法是使用 `Future` 接口。我们可以通过 `ExecutorService` 池的 `submit()` 方法访问此接口，而不是使用
    `execute()`、`invokeAll()` 或 `invokeAny()` 方法。以下代码展示了如何使用 `submit()` 方法：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `printFuture()` method has the following implementation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`printFuture()` 方法具有以下实现：'
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `sleepMs()` method contains the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleepMs()` 方法包含以下代码：'
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We prefer this implementation instead of the traditional `Thread.sleep()` because
    it is explicit about the time units used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢这种实现方式而不是传统的 `Thread.sleep()`，因为它明确指出了使用的时间单位。
- en: 'If we execute the previous code, the result will be similar to the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面的代码，结果将类似于以下内容：
- en: '![Monitoring Threads](img/03_15.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_15.jpg)'
- en: 'The `printFuture()` method has blocked the main thread execution until the
    first thread has completed. Meanwhile, the second thread has completed too. If
    we call the `printFuture()` method after the `shutdown()` method, both the threads
    would complete by that time already because we have set a wait time of 1 second
    (see the `pool.awaitTermination()` method), which is enough for them to finish
    their job:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`printFuture()` 方法阻塞了主线程的执行，直到第一个线程完成。同时，第二个线程也已经完成。如果我们调用 `printFuture()`
    方法在 `shutdown()` 方法之后，到那时两个线程都已经完成了，因为我们已经设置了1秒的等待时间（见 `pool.awaitTermination()`
    方法），这对于它们完成工作来说是足够的：'
- en: '![Monitoring Threads](img/03_16.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_16.jpg)'
- en: 'If you think it is not much information from a threads monitoring point of
    view, the `java.util.concurrent` package provides more capabilities via the `Callable`
    interface. It is a functional interface that allows returning any object (containing
    results of the worker thread calculations) via the `Future` object using `ExecutiveService`
    methods--`submit()`, `invokeAll()`, and `invokeAny()`. For example, we can create
    a class that contains the result of a worker thread:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为从线程监控的角度来看信息不多，`java.util.concurrent` 包通过 `Callable` 接口提供了更多功能。它是一个函数式接口，允许通过
    `ExecutiveService` 方法（`submit()`、`invokeAll()` 和 `invokeAny()`）使用 `Future` 对象返回任何对象（包含工作线程计算的结果）。例如，我们可以创建一个包含工作线程结果的类：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have included the name of the worker thread too for monitoring which thread
    generated the result that is presented. The class that implements the `Callable`
    interface may look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了工作线程的名称，以便监控哪个线程生成了展示的结果。实现 `Callable` 接口的类可能看起来像这样：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And here is the code that uses the `MyCallable01` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 `MyCallable01` 类的代码：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `printResult()` method contains the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`printResult()` 方法包含以下代码：'
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of this code may look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出可能如下所示：
- en: '![Monitoring Threads](img/03_17.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_17.jpg)'
- en: The earlier output shows, as in the previous examples, that the `printResult()`
    method waits until the first of the worker threads finishes, so the second thread
    manages to finish its job at the same time. The advantage of using `Callable`,
    as you can see, is that we can retrieve the actual result from a `Future` object,
    if we need it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 早期输出显示，与前面的示例一样，`printResult()` 方法等待第一个工作线程完成，因此第二个线程设法同时完成其工作。如您所见，使用 `Callable`
    的优点是，如果我们需要，我们可以从 `Future` 对象中检索实际结果。
- en: 'The usage of the `invokeAll()` and `invokeAny()` methods looks similar:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeAll()` 和 `invokeAny()` 方法的用法看起来相似：'
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `printResults()` method is using the `printResult()` method, which you
    already know:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`printResults()` 方法正在使用您已经知道的 `printResult()` 方法：'
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we run the preceding code, the output will be as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，输出将如下所示：
- en: '![Monitoring Threads](img/03_18.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_18.jpg)'
- en: As you can see, there is no more waiting for the worker thread completing the
    job. That is so because the `invokeAll()` method returns the collection of the
    `Future` object after all the jobs have completed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，不再需要等待工作线程完成工作。这是因为 `invokeAll()` 方法在所有工作完成后返回 `Future` 对象的集合。
- en: 'The `invokeAny()` method behaves similarly. If we run the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeAny()`方法的行为类似。如果我们运行以下代码：'
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following will be the output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的将是输出：
- en: '![Monitoring Threads](img/03_19.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_19.jpg)'
- en: These are the basic techniques for monitoring the threads programmatically,
    but one can easily extend our examples to cover more complicated cases tailored
    to the needs of a specific application. In [Lesson 5](ch05.xhtml "Chapter 5. Making
    Use of New APIs to Improve Your Code"), *Making Use of New APIs to Improve Your
    Code*, we will also discuss another way to programmatically monitor worker threads
    using the `java.util.concurrent.CompletableFuture` class introduced in JDK 8 and
    extended in JDK 9.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是程序化监控线程的基本技术，但可以轻松扩展我们的示例以涵盖更复杂的案例，这些案例针对特定应用程序的需求。在[第5课](ch05.xhtml "第5章.
    利用新API改进代码")，*利用新API改进代码*中，我们还将讨论使用在JDK 8中引入并在JDK 9中扩展的`java.util.concurrent.CompletableFuture`类以程序化方式监控工作线程的另一种方法。
- en: 'If necessary, it is possible to get information not only about the application
    worker threads, but also about all other threads in the JVM process using the
    `java.lang.Thread` class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以使用`java.lang.Thread`类获取有关应用程序工作线程的信息，以及JVM进程中的所有其他线程：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s call this method as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按如下方式调用此方法：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The result looks like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像这样：
- en: '![Monitoring Threads](img/03_20.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_20.jpg)'
- en: 'We took advantage of the `toString()` method of the `Thread` class that prints
    only the thread name, priority, and the thread group it belongs to. And we see
    the two application threads we have created explicitly (in addition to the `main`
    thread) in the list under the names `pool-1-thread-1` and `pool-1-thread-2`. But
    if we call the `printAllThreads()` method after calling the `shutdown()` method,
    the output will be as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用了`Thread`类的`toString()`方法，该方法只打印线程名称、优先级以及它所属的线程组。我们看到在名称为`pool-1-thread-1`和`pool-1-thread-2`的列表下，我们明确创建的两个应用程序线程（除了`main`线程）。但是，如果我们调用`shutdown()`方法之后的`printAllThreads()`方法，输出将如下所示：
- en: '![Monitoring Threads](img/03_21.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_21.jpg)'
- en: We do not see the `pool-1-thread-1` and `pool-1-thread-2` threads in the list
    anymore because the `ExecutorService` pool has been shut down.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列表中不再看到`pool-1-thread-1`和`pool-1-thread-2`线程，因为`ExecutorService`池已被关闭。
- en: 'We could easily add the stack trace information pulled from the same map:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地添加从同一映射中提取的堆栈跟踪信息：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: However, that would take too much space on the book page. In [Lesson 5](ch05.xhtml
    "Chapter 5. Making Use of New APIs to Improve Your Code"), *Making Use of New
    APIs to Improve Your Code*, while presenting new Java capabilities that came with
    JDK 9, we will also discuss a better way to access a stack trace via the `java.lang.StackWalker`
    class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将在书页上占用太多空间。在[第5课](ch05.xhtml "第5章. 利用新API改进代码")中，当我们介绍JDK 9带来的新Java功能时，我们还将讨论通过`java.lang.StackWalker`类访问堆栈跟踪的更好方法。
- en: 'The `Thread` class object has several other methods that provide information
    about the thread, which are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类对象有几个其他方法，可以提供有关线程的信息，如下所示：'
- en: '`dumpStack()`: This prints a stack trace to the standard error stream'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dumpStack()`: 这将堆栈跟踪打印到标准错误流'
- en: '`enumerate(Thread[] arr)`: This copies active threads in the current thread''s
    thread group and its subgroups into the specified array `arr`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate(Thread[] arr)`: 这将当前线程的线程组及其子组中的活动线程复制到指定的数组`arr`'
- en: '`getId()`: This provides the thread''s ID'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getId()`: 这提供了线程的ID'
- en: '`getState()`: This reads the state of the thread; the possible values from
    `enum Thread.State` can be one of the following:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState()`: 这读取线程的状态；`enum Thread.State`的可能值可以是以下之一：'
- en: '`NEW`: This is the thread that has not yet started'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEW`: 这是尚未启动的线程'
- en: '`RUNNABLE`: This is the thread that is currently being executed'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNABLE`: 这是当前正在执行的线程'
- en: '`BLOCKED`: This is the thread that is blocked waiting for a monitor lock to
    be released'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOCKED`: 这是等待监视器锁释放而被阻塞的线程'
- en: '`WAITING`: This is the thread that is waiting for an interrupt signal'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAITING`: 这是等待中断信号的线程'
- en: '`TIMED_WAITING`: This is the thread that is waiting for an interrupt signal
    up to a specified waiting time'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMED_WAITING`: 这是等待指定等待时间中断信号的线程'
- en: '`TERMINATED`: This is the thread that has exited'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERMINATED`: 这是已经退出的线程'
- en: '`holdsLock(Object obj)`: This indicates whether the thread holds the monitor
    lock on the specified object'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holdsLock(Object obj)`: 这表示线程是否持有指定对象的监视器锁'
- en: '`interrupted()` or `isInterrupted()`: This indicates whether the thread has
    been interrupted (received an interrupt signal, meaning that the flag interrupted
    was set to `true`)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupted()` 或 `isInterrupted()`: 这表示线程是否被中断（收到中断信号，意味着中断标志被设置为 `true`）'
- en: '`isAlive()`: This indicates whether the thread is alive'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAlive()`: 这表示线程是否存活'
- en: '`isDaemon()`: This indicates whether the thread is a daemon thread.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDaemon()`: 这表示线程是否是守护线程。'
- en: 'The `java.lang.management` package provides similar capabilities for monitoring
    threads. Let''s run this code snippet, for example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.management` 包为监控线程提供了类似的功能。让我们运行这个代码片段，例如：'
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For better presentation, we took advantage of having thread IDs listed and,
    as you could see previously, have sorted the output by ID. If we call the `printThreadsInfo()`
    method before the `shutdown()` method the output will be as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好的展示，我们利用了线程 ID 的列表，并且，如你之前所见，我们按 ID 对输出进行了排序。如果我们调用 `shutdown()` 方法之前的 `printThreadsInfo()`
    方法，输出将如下所示：
- en: '![Monitoring Threads](img/03_22.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_22.jpg)'
- en: 'However, if we call the `printThreadsInfo()` method after the `shutdown()`
    method, the output will not include our worker threads anymore, exactly as in
    the case of using the `Thread` class API:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们调用 `shutdown()` 方法之后的 `printThreadsInfo()` 方法，输出将不再包括我们的工作线程，这与使用 `Thread`
    类 API 的情况完全相同：
- en: '![Monitoring Threads](img/03_23.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_23.jpg)'
- en: 'The `java.lang.management.ThreadMXBean` interface provides a lot of other useful
    data about threads. You can refer to the official API on the Oracle website about
    this interface for more information check this link: [https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/ThreadMXBean.html](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/ThreadMXBean.html).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.management.ThreadMXBean` 接口提供了许多关于线程的其他有用数据。你可以参考 Oracle 网站上关于此接口的官方
    API 获取更多信息，请查看此链接：[https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/ThreadMXBean.html](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/ThreadMXBean.html)。'
- en: In the list of threads mentioned earlier, you may have noticed the `Monitor
    Ctrl-Break` thread. This thread provides another way to monitor the threads in
    the JVM process. Pressing the *Ctrl* and *Break* keys on Windows causes the JVM
    to print a thread dump to the application's standard output. On Oracle Solaris
    or Linux operating systems, the same effect has the combination of the *Ctrl*
    key and the backslash *\*. This brings us to the external tools for thread monitoring.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的线程列表中，你可能已经注意到了 `Monitor Ctrl-Break` 线程。这个线程为在 JVM 进程中监控线程提供了另一种方式。在 Windows
    上按下 *Ctrl* 和 *Break* 键会导致 JVM 将线程转储打印到应用程序的标准输出。在 Oracle Solaris 或 Linux 操作系统上，同样的效果可以通过
    *Ctrl* 键和反斜杠 *\* 组合实现。这使我们来到了用于线程监控的外部工具。
- en: 'In case you don''t have access to the source code or prefer to use the external
    tools for the threads monitoring, there are several diagnostic utilities available
    with the JDK installation. In the following list, we mention only the tools that
    allow for thread monitoring and describe only this capability of the listed tools
    (although they have other extensive functionality too):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法访问源代码或更喜欢使用外部工具进行线程监控，JDK 安装中提供了几个诊断工具。在以下列表中，我们只提到了允许进行线程监控的工具，并且只描述了这些工具的这一功能（尽管它们还有其他广泛的功能）：
- en: 'The `jcmd` utility sends diagnostic command requests to the JVM on the same
    machine using the JVM process ID or the name of the main class: `jcmd <process
    id/main class> <command> [options]`, where the `Thread.print` option prints the
    stack traces of all the threads in the process.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jcmd` 工具通过 JVM 进程 ID 或主类名向同一台机器上的 JVM 发送诊断命令请求：`jcmd <process id/main class>
    <command> [options]`，其中 `Thread.print` 选项打印进程中所有线程的堆栈跟踪。'
- en: The JConsole monitoring tool uses the built-in JMX instrumentation in the JVM
    to provide information about the performance and resource consumption of running
    applications. It has a thread tab pane that shows thread usage over time, the
    current number of live threads, the highest number of live threads since the JVM
    started. It is possible to select the thread and its name, state, and stack trace,
    as well as, for a blocked thread, the synchronizer that the thread is waiting
    to acquire, and the thread owning the lock. Use the **Deadlock Detection** button
    to identify the deadlock. The command to run the tool is `jconsole <process id>`
    or (for remote application) `jconsole <hostname>:<port>` , where `port` is the
    port number specified with the JVM start command that enabled the JMX agent.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JConsole 监控工具使用 JVM 内置的 JMX 仪器来提供有关运行应用程序的性能和资源消耗的信息。它有一个线程选项卡，显示了随时间变化的线程使用情况、当前活动线程数以及自
    JVM 启动以来最高活动线程数。可以选择线程及其名称、状态和堆栈跟踪，以及对于阻塞线程，线程等待获取的同步器以及拥有锁的线程。使用 **死锁检测** 按钮来识别死锁。运行此工具的命令是
    `jconsole <进程 ID>` 或（对于远程应用程序）`jconsole <主机名>:<端口号>`，其中 `端口号` 是 JVM 启动命令中指定的启用
    JMX 代理的端口号。
- en: The `jdb` utility is an example command line debugger. It can be attached to
    the JVM process and allows you to examine threads.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdb` 实用程序是一个示例命令行调试器。它可以附加到 JVM 进程，并允许您检查线程。'
- en: The `jstack` command line utility can be attached to the JVM process and print
    the stack traces of all threads, including JVM internal threads, and optionally
    native stack frames. It allows you to detect deadlocks too.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jstack` 命令行实用程序可以附加到 JVM 进程，并打印所有线程的堆栈跟踪，包括 JVM 内部线程，以及可选的本地堆栈帧。它还允许检测死锁。'
- en: '**Java Flight Recorder** (**JFR**) provides information about the Java process,
    including threads waiting for locks, garbage collections, and so on. It also allows
    getting thread dumps, which are similar to the one generated by the `Thread.print`
    diagnostic command or by using the jstack tool. It is possible to set up **Java
    Mission Control** (**JMC**) to dump a flight recording if a condition is met.
    JMC UI contains information about threads, lock contention, and other latencies.
    Although JFR is a commercial feature, it is free for developer desktops/laptops,
    and for evaluation purposes in test, development, and production environments.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 飞行记录器**（**JFR**）提供了有关 Java 进程的信息，包括等待锁的线程、垃圾回收等。它还允许获取线程转储，这些转储类似于由
    `Thread.print` 诊断命令或使用 jstack 工具生成的转储。如果满足条件，可以设置 **Java 任务控制**（**JMC**）以转储飞行记录。JMC
    UI 包含有关线程、锁竞争和其他延迟的信息。尽管 JFR 是一个商业功能，但在开发人员桌面/笔记本电脑以及测试、开发和生产环境中的评估目的上是免费的。'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more details about these and other diagnostic tools in the official
    Oracle documentation at [https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm](https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方 Oracle 文档中找到有关这些和其他诊断工具的更多详细信息，网址为 [https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm](https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm)。
- en: Sizing Thread Pool Executors
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池执行器大小
- en: In our examples, we have used a cached thread pool that creates a new thread
    as needed or, if available, reuses the thread already used, but which completed
    its job and returned to the pool for a new assignment. We did not worry about
    too many threads created because our demo application had two worker threads at
    the most and they were quite short lived.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了一个缓存线程池，根据需要创建新线程，或者如果可用，则重用已经使用但已完成任务的线程，并将其返回到池中以进行新的分配。我们不必担心创建过多的线程，因为我们的演示应用程序最多只有两个工作线程，而且它们的生命周期相当短。
- en: 'But in the case where an application does not have a fixed limit of the worker
    threads it might need or there is no good way to predict how much memory a thread
    may take or how long it can execute, setting a ceiling on the worker thread count
    prevents an unexpected degradation of the application performance, running out
    of memory or depletion of any other resources the worker threads use. If the thread
    behavior is extremely unpredictable, a single thread pool might be the only solution,
    with an option of using a custom thread pool executor (more about this last option
    is explained later). But in most of the cases, a fixed-size thread pool executor
    is a good practical compromise between the application needs and the code complexity.
    Depending on the specific requirements, such an executor might be one of these
    three flavors:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但在应用没有固定的工作线程数量限制，或者没有好的方法来预测线程可能占用的内存量或执行时间的情况下，对工作线程数量设置上限可以防止应用性能意外下降、内存耗尽或任何其他工作线程使用的资源耗尽。如果线程行为极不可预测，单个线程池可能是唯一的解决方案，可以选择使用自定义线程池执行器（关于这个选项的更多内容将在后面解释）。但在大多数情况下，固定大小的线程池执行器是在应用需求和代码复杂度之间的一种良好的实用折衷方案。根据具体要求，这样的执行器可能是以下三种类型之一：
- en: A straightforward, fixed-sized `ExecutorService.newFixedThreadPool(int nThreads)`
    pool that does not grow beyond the specified size, but does not adopt either
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单、固定大小的`ExecutorService.newFixedThreadPool(int nThreads)`线程池，它不会超过指定的大小，但也不会采用其他方式
- en: Several `ExecutorService.newScheduledThreadPool(int nThreads)` pools that allow
    scheduling different groups of threads with a different delay or cycle of execution
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个允许使用不同延迟或执行周期调度不同线程组的`ExecutorService.newScheduledThreadPool(int nThreads)`线程池
- en: '`ExecutorService.newWorkStealingPool(int parallelism)` that adapts to the specified
    number of CPUs, which you may set higher or smaller than the actual CPUs count
    on your computer'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService.newWorkStealingPool(int parallelism)`，它适应指定的CPU数量，你可以将其设置为高于或低于你电脑上实际CPU数量的值'
- en: Setting the fixed size in any of the preceding pools too low may deprive the
    application of the chance to utilize the available resources effectively. So,
    before selecting the pool size, it is advisable to spend some time on monitoring
    it and tuning JVM (see how to do it in one of the sections of this lesson) with
    the goal of the identification of the idiosyncrasy of the application behavior.
    In fact, the cycle deploy-monitor-tune-adjust has to be repeated throughout the
    application life cycle in order to accommodate and take advantage of the changes
    that happened in the code or the executing environment.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何先前的池中设置固定大小过低可能会剥夺应用有效利用可用资源的机会。因此，在选择池大小之前，建议花些时间对其进行监控和调整JVM（参见本课程的一个部分中如何操作），目标是识别应用行为的特殊性。实际上，部署-监控-调整的周期必须在应用生命周期内重复进行，以便适应并利用代码或执行环境中的变化。
- en: The first parameter you take into account is the number of CPUs in your system,
    so the thread pool size can be at least as big as the CPU's count. Then, you can
    monitor the application and see how much time each thread engages the CPU and
    how much of the time it uses other resources (such as I/O operations). If the
    time spent not using the CPU is comparable with the total executing time of the
    thread, then you can increase the pool size by **time not using CPU/total executing
    time**. But that is in the case that another resource (disk or database) is not
    a subject of contention between the threads. If the latter is the case, then you
    can use that resource instead of the CPU as the delineating factor.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先考虑的第一个参数是系统中的CPU数量，因此线程池大小至少应该与CPU的数量一样大。然后，你可以监控应用，看看每个线程占用CPU的时间以及它使用其他资源（如I/O操作）的时间。如果未使用CPU的时间与线程的总执行时间相当，那么你可以通过**未使用CPU的时间/总执行时间**来增加池大小。但这是在另一个资源（磁盘或数据库）不是线程之间的争用对象的情况下。如果后者是情况，那么你可以使用该资源而不是CPU作为划分因素。
- en: Assuming the worker threads of your application are not too big or too long
    executing and belong to the mainstream population of the typical working threads
    that complete their job in a reasonably short period of time, you can increase
    the pool size by adding the (rounded up) ratio of the desired response time and
    the time a thread uses CPU or another most contentious resource. This means that,
    with the same desired response time, the less a thread uses CPU or another concurrently
    accessed resource, the bigger the pool size should be. If the contentious resource
    has its own ability to improve concurrent access (like a connection pool in the
    database), consider utilizing that feature first.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序的工作线程不是太大或执行时间太长，属于典型工作线程的主流人群，它们在合理短的时间内完成工作，您可以通过添加（向上取整）所需响应时间与线程使用CPU或其他最具有争议性资源的时间的比率来增加池大小。这意味着，在相同的所需响应时间下，线程使用CPU或其他并发访问的资源越少，池大小应该越大。如果争议性资源具有提高并发访问能力的能力（如数据库中的连接池），首先考虑利用该功能。
- en: If the required number of threads running at the same time changes at runtime
    under the different circumstances, you can make the pool size dynamic and create
    a new pool with a new size (shutting down the old pool after all its threads have
    completed). The recalculation of the size of a new pool might be necessary also
    after you add to remove the available resources. You can use `Runtime.getRuntime().availableProcessors()`
    to programmatically adjust the pool size based on the current count of the available
    CPUs, for example.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行时由于不同情况，同时运行的线程数发生变化，您可以使池大小动态，并在所有线程完成后关闭旧池，创建一个新的具有新大小的池。在添加或删除可用资源后，可能还需要重新计算新池的大小。您可以使用`Runtime.getRuntime().availableProcessors()`根据当前可用的CPU数量程序化地调整池大小，例如。
- en: If none of the ready-to-use thread pool executor implementations that come with
    the JDK suit the needs of a particular application, before writing the thread
    managing code from scratch, try to use the `java.util.concurrent.ThreadPoolExecutor`
    class first. It has several overloaded constructors.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JDK附带的可用线程池执行器实现没有满足特定应用程序的需求，在从头编写线程管理代码之前，首先尝试使用`java.util.concurrent.ThreadPoolExecutor`类。它有几个重载的构造函数。
- en: 'To give you an idea of its capabilities, here is the constructor with the biggest
    number of options:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解其功能，以下是一个具有最多选项的构造函数：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The earlier mentioned parameters are (quoting from the JavaDoc):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的参数如下（引用自JavaDoc）：
- en: '`corePoolSize`: This is the number of threads to keep in the pool, even if
    they are idle unless `allowCoreThreadTimeOut` is set'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`corePoolSize`: 这是池中要保留的线程数，即使它们处于空闲状态，除非设置了`allowCoreThreadTimeOut`'
- en: '`maximumPoolSize`: This is the maximum number of threads to allow in the pool'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maximumPoolSize`: 这是池中允许的最大线程数'
- en: '`keepAliveTime`: When the number of threads is greater than the core, this
    is the maximum time that excess idle threads will wait for new tasks before terminating'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keepAliveTime`: 当线程数大于核心数时，这是超出空闲线程等待新任务以终止的最大时间'
- en: '`unit`: This is the time unit for the `keepAliveTime` argument'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unit`: 这是`keepAliveTime`参数的时间单位'
- en: '`workQueue`: This is the queue to use for holding tasks before they are executed,
    this queue will hold only the `Runnable` tasks submitted by the execute method'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workQueue`: 这是用于在执行之前持有任务的队列，此队列将仅保留通过`execute`方法提交的`Runnable`任务'
- en: '`threadFactory`: This is the factory to use when the executor creates a new
    thread'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threadFactory`: 这是在执行器创建新线程时使用的工厂'
- en: '`handler`: This is the handler to use when the execution is blocked because
    the thread bounds and queue capacities are reached'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler`: 当执行因为线程边界和队列容量达到而阻塞时，这是要使用的处理器'
- en: Each of the previous constructor parameters except the `workQueue` parameter
    can also be set via the corresponding setter after the object of the `ThreadPoolExecutor`
    method has been created, thus allowing more flexibility in dynamic adjustment
    of the existing pool characteristics.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`workQueue`参数之外，之前的构造函数参数也可以在创建`ThreadPoolExecutor`对象后通过相应的setter进行设置，从而使得对现有池特性的动态调整更加灵活。
- en: Thread Synchronization
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程同步
- en: We have collected enough people and resources such as food, water, and tools
    for the pyramid building. We have divided people into teams and assigned each
    team a task. A number (a pool) of people are living in the nearby village on a
    standby mode, ready to replace the ones that got sick or injured on their assignment.
    We adjusted the workforce count so that there are only a few people who will remain
    idle in the village. We rotate the teams through the work-rest cycle to keep the
    project going at maximum speed. We monitored the process and have adjusted the
    number of teams and the flow of supplies they need so that there are no visible
    delays and there is steady measurable progress in the project as a whole. Yet,
    there are many moving parts overall and various small and big unexpected incidents
    and problems happen all the time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经收集了足够的人力和资源，如食物、水和工具，用于金字塔建设。我们将人员分成团队，并为每个团队分配一项任务。有一群人（一个池）住在附近的村庄，处于待命状态，随时准备替换那些在任务中生病或受伤的人。我们调整了劳动力数量，以确保只有少数人将在村庄中闲置。我们通过工作-休息周期轮换团队，以保持项目以最大速度进行。我们监控了整个过程，并调整了团队数量和所需供应品的流动，以确保没有明显的延误，整个项目有稳定的可测量进度。然而，整体上有很多移动部件，以及各种大小不一的意外事件和问题不断发生。
- en: To make sure that the workers and teams do not step on each other and that there
    is some kind of traffic regulation so that the next technological step does not
    start until the previous one is finished, the main architect sends his representatives
    to all the critical points of the construction site. These representatives make
    sure that the tasks are executed with the expected quality and in the prescribed
    order. They have the power to stop the next team from starting their job until
    the previous team has not finished yet. They act like traffic cops or the locks
    that can shut down the access to the workplace or allow it, if/when necessary.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保工人和团队不会相互干扰，并且存在某种交通规则，以便在上一阶段完成之前不会开始下一技术阶段，主要建筑师派遣他的代表到建筑工地的所有关键点。这些代表确保任务以预期的质量按规定的顺序执行。他们有权在上一团队未完成之前阻止下一团队开始工作。他们就像交通警察或可以关闭或允许进入工作场所的锁，如果/当必要时。
- en: The job these representatives are doing can be defined in the modern language
    as a coordination or synchronization of actions of the executing units. Without
    it, the results of the efforts of the thousands of workers would be unpredictable.
    The big picture from ten thousand feet would look smooth and harmonious, as the
    farmers' fields from the windows of an airplane. But without closer inspection
    and attention to the critical details, this perfect looking picture may bring
    a poor harvest, if any.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代表所做的工作可以用现代语言定义为执行单元动作的协调或同步。没有它，成千上万工人努力的成果将是不可预测的。从万米高空看的大局将看起来平稳和谐，就像从飞机窗户看到的农民田地。但如果没有更仔细的检查和对关键细节的关注，这个看似完美的画面可能会带来微薄的收成，如果有的话。
- en: 'Similarly, in the quiet electronic space of the multithreaded execution environment,
    the working threads have to be synchronized if they share access to the same working
    place. For example, let''s create the following class-worker for a thread:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在多线程执行环境的安静电子空间中，如果工作线程共享对同一工作场所的访问，它们必须进行同步。例如，让我们为线程创建以下类-工作者：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see, it sequentially adds 1, 2, 3, 4, 5 (so, that the resulting
    total is expected to be 15) to the static property of the `Demo04Synchronization`
    class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它按顺序将1、2、3、4、5（因此，预期的结果是15）添加到`Demo04Synchronization`类的静态属性中：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the earlier code, while the main thread pauses for 100 ms the first time,
    the thread `t1` brings the value of the variable result to 15, then the thread
    `t2` adds another 15 to get the total of 30\. Here is the output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的代码中，当主线程第一次暂停100毫秒时，线程`t1`将变量的值增加到15，然后线程`t2`再增加15，得到总和30。以下是输出：
- en: '![Thread Synchronization](img/03_24.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_24.jpg)'
- en: 'If we remove the first pause of 100 ms, the threads will work concurrently:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除第一次100毫秒的暂停，线程将并发工作：
- en: '![Thread Synchronization](img/03_25.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_25.jpg)'
- en: 'The final result is still 30\. We feel good about this code and deploy it to
    production as a well-tested code. However, if we increase the number of additions
    from 5 to 250, for example, the result becomes unstable and changes from run to
    run. Here is the first run (we commented out the printout in each thread in order
    to save space):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果仍然是30。我们对这段代码感到满意，并将其作为经过良好测试的代码部署到生产环境中。然而，如果我们将加数的数量从5增加到250，例如，结果就会变得不稳定，并且每次运行的结果都不同。以下是第一次运行（我们为了节省空间，在每个线程中注释掉了打印输出）：
- en: '![Thread Synchronization](img/03_26.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_26.jpg)'
- en: 'And here is the output of another run:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一次运行的输出：
- en: '![Thread Synchronization](img/03_27.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_27.jpg)'
- en: 'It demonstrates the fact that the `Demo04Synchronization.result += i` operation
    is not atomic. This means it consists of several steps, reading the value from
    the `result` property, adding a value to it, assigning the resulting sum back
    to the `result` property. This allows the following scenario, for example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了`Demo04Synchronization.result += i`操作不是原子的。这意味着它由几个步骤组成，从`result`属性中读取值，向其添加一个值，然后将结果和赋值回`result`属性。这允许以下场景，例如：
- en: Both the threads have read the current value of `result` (so each of the threads
    has a copy of the same original `result` value)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个线程都读取了`result`的当前值（因此每个线程都有一个相同的原始`result`值的副本）
- en: Each thread adds another integer to the same original one
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线程都向同一个原始整数添加另一个整数
- en: The first thread assigns the sum to the `result` property
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个线程将和赋值给`result`属性
- en: The second thread assigns its sum to the `result` property
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个线程将其和赋值给`result`属性
- en: As you can see, the second thread did not know about the addition the first
    thread made and has overwritten the value assigned to the `result` property by
    the first thread. But such thread interleaving does not happen every time. It
    is just a game of chance. That's why we did not see such an effect with five numbers
    only. But the probability of this happening increases with the growth of the number
    of concurrent actions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，第二个线程并不知道第一个线程所做的加法，并覆盖了第一个线程分配给`result`属性的值。但这样的线程交错并不总是发生。这只是一种机会游戏。这就是为什么我们只使用五个数字时没有看到这样的效果。但随着并发动作数量的增加，这种情况发生的概率会增加。
- en: 'A similar thing could happen during the pyramid building too. The second team
    could start doing something before the first team has finished their task. We
    definitely need a **synchronizer** and it comes with a `synchronized` keyword.
    Using it, we can create a method (an architect representative) in the `Demo04Synchronization`
    class that will control access to the `result` property and add to it this keyword:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔构建过程中也可能发生类似的情况。第二个团队可能在第一个团队完成他们的任务之前开始做某事。我们肯定需要一个**同步器**，它由`synchronized`关键字提供。使用它，我们可以在`Demo04Synchronization`类中创建一个方法（一个建筑师代表），该方法将控制对`result`属性的访问，并添加这个关键字：
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we have to modify the `run()` method in the worker thread too:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还必须在工作线程的`run()`方法中进行修改：
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output now shows the same final number for every run:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出显示每次运行都有相同的最终数字：
- en: '![Thread Synchronization](img/03_28.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_28.jpg)'
- en: The `synchronized` keyword tells JVM that only one thread at a time is allowed
    to enter this method. All the other threads will wait until the current visitor
    of the method exits from it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`关键字告诉JVM一次只允许一个线程进入这个方法。所有其他线程都将等待，直到当前访问者从该方法退出。'
- en: 'The same effect could be achieved by adding the `synchronized` keyword to a
    block of code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在代码块中添加`synchronized`关键字也可以达到相同的效果：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The difference is that the block synchronization requires an object--a class
    object in the case of static property synchronization (as in our case) or any
    other object in the case of an instance property synchronization. Each object
    has an intrinsic lock or monitor lock, often referred to simply as a monitor.
    Once a thread acquires a lock on an object, no other thread can acquire it on
    the same object until the first thread releases the lock after normal exit from
    the locked code or if the code throws an exception.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于块同步需要一个对象——在静态属性同步的情况下（如我们的例子），这是一个类对象；在实例属性同步的情况下，可以是任何其他对象。每个对象都有一个内在的锁或监视器锁，通常简单地称为监视器。一旦一个线程获取了对一个对象的锁，其他线程就不能在同一个对象上获取锁，直到第一个线程在从锁定代码的正常退出后释放锁，或者如果代码抛出异常。
- en: In fact, in the case of a synchronized method, an object (the one to which the
    method belongs) is used for locking, too. It just happens behind the scene automatically
    and does not require the programmer to use an object's lock explicitly.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在同步方法的情况下，一个对象（方法所属的对象）也用于锁定。这只是在幕后自动发生，不需要程序员显式使用对象的锁。
- en: 'In case you do not have access to the `main` class code (as in the example
    earlier) you can keep the `result` property public and add a synchronized method
    to the worker thread (instead of the class as we have done):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法访问`main`类代码（如前面的示例所示），您可以保持`result`属性为公共的，并为工作线程添加一个同步方法（而不是像我们之前所做的那样添加到类中）：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this case, the object of the `MyRunnable05` worker class provides its intrinsic
    lock by default. This means, you need to use the same object of the `MyRunnable05`
    class for all the threads:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`MyRunnable05`工作类的对象默认提供其内锁。这意味着，您需要为所有线程使用`MyRunnable05`类的相同对象：
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output of the preceding code is the same as before:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出与之前相同：
- en: '![Thread Synchronization](img/03_29.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_29.jpg)'
- en: One can argue that this last implementation is preferable because it allocates
    the responsibility of the synchronization with the thread (and the author of its
    code) and not with the shared resource. This way the need for synchronization
    changes along with the thread implementation evolution, provided that the client
    code (that uses the same or different objects for the threads) can be changed
    as needed as well.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 可以争论说，这种最后的实现更可取，因为它将同步的责任分配给了线程（及其代码的作者），而不是共享资源。这样，同步的需要会随着线程实现的发展而变化，前提是客户端代码（使用相同或不同对象进行线程的）也可以根据需要更改。
- en: There is another possible concurrency issue that may happen in some operating
    systems. Depending on how the thread caching is implemented, a thread might preserve
    a local copy of the property `result` and not update it after another thread has
    changed its value. By adding the `volatile` keyword to the shared (between threads)
    property guarantees that its current value will be always read from the main memory,
    so each thread will see the updates done by the other threads. In our previous
    examples, we just set the `Demo04Synchronization` class property as `private static
    volatile int result`, add a synchronized `incrementResult()` method to the same
    class or to the thread and do not worry anymore about threads stepping on each
    other.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些操作系统中可能还存在另一个可能的并发问题。根据线程缓存如何实现，一个线程可能会保留属性`result`的本地副本，并且在另一个线程更改其值后不更新它。通过在共享（线程间的）属性上添加`volatile`关键字，可以保证其当前值始终从主内存中读取，因此每个线程都将看到其他线程所做的更新。在我们的前一个示例中，我们只是将`Demo04Synchronization`类属性设置为`private
    static volatile int result`，向同一类或线程添加一个同步的`incrementResult()`方法，就不再需要担心线程相互干扰了。
- en: The described thread synchronization is usually sufficient for the mainstream
    application. But the higher performance and highly concurrent processing often
    require looking closer into the thread dump, which typically shows that method
    synchronization is more efficient than block synchronization. Naturally, it also
    depends on the size of the method and the block. Since all the other threads that
    try to access the synchronized method or block are going to stop execution until
    the current visitor of the method or block exits it, it is possible that despite
    the overhead a small synchronized block yields better performance than the big
    synchronized method.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的线程同步通常对于主流应用程序来说是足够的。但是，更高的性能和高度并发的处理通常需要更仔细地查看线程转储，这通常表明方法同步比块同步更有效。当然，这也取决于方法的大小和块的大小。由于所有尝试访问同步方法或块的线程都将停止执行，直到当前访问方法或块的访问者退出它，因此，尽管存在开销，一个小同步块可能比大同步方法提供更好的性能。
- en: 'For some applications, the behavior of the default intrinsic lock, which just
    blocks until the lock is released, maybe not well suited. If that is the case,
    consider using locks from the `java.util.concurrent.locks` package. The access
    control based on locks from that package has several differences if compared with
    using the default intrinsic lock. These differences may be advantageous for your
    application or provide the unnecessary complication, but it''s important to know
    them, so you can make an informed decision:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用程序，默认的内置锁的行为，即仅阻塞直到锁被释放，可能不适合。如果是这种情况，请考虑使用 `java.util.concurrent.locks`
    包中的锁。与使用默认内置锁相比，基于该包中锁的访问控制有几个不同之处。这些差异可能对您的应用程序有利或提供不必要的复杂性，但了解它们很重要，这样您就可以做出明智的决定：
- en: The synchronized fragment of code does not need to belong to one method; it
    can span several methods, delineated by the calls to the `lock()` and `unlock()`
    methods (invoked on the object that implements the `Lock` interface)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步代码块不需要属于一个方法；它可以跨越多个方法，由对实现 `Lock` 接口的对象调用 `lock()` 和 `unlock()` 方法（调用）界定
- en: While creating an object of the `Lock` interface called `ReentrantLock`, it
    is possible to pass into the constructor a `fair` flag that makes the lock able
    to grant an access to the longest-waiting thread first, which helps to avoid starvation
    (when the low priority thread never can get access to the lock)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建一个名为 `ReentrantLock` 的 `Lock` 接口对象时，可以将一个 `fair` 标志传递给构造函数，这使得锁能够首先授予等待时间最长的线程访问权限，这有助于避免饥饿（当低优先级线程永远无法获得锁时）
- en: Allows a thread to test whether the lock is accessible before committing to
    be blocked
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许线程在承诺被阻塞之前测试锁是否可访问
- en: Allows interrupting a thread waiting for the lock, so it does not remain blocked
    indefinitely
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许中断等待锁的线程，使其不会无限期地保持阻塞状态
- en: You can implement the `Lock` interface yourself with whatever features you need
    for your application
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用您应用程序需要的任何功能自行实现 `Lock` 接口
- en: 'A typical pattern of usage of the `Lock` interface looks like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock` 接口的使用典型模式如下：'
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice the `finally` block. It is the way to guarantee that the `lock` is released
    eventually. Otherwise, the code inside the `try-catch` block can throw an exception
    and the lock is never released.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `finally` 块。这是保证最终释放 `lock` 的方式。否则，`try-catch` 块内的代码可能会抛出异常，而锁永远不会被释放。
- en: 'In addition to the `lock()` and `unlock()` methods, the `Lock` interface has
    the following methods:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `lock()` 和 `unlock()` 方法之外，`Lock` 接口还有以下方法：
- en: '`lockInterruptibly()`: This acquires the lock unless the current thread is
    interrupted. Similar to the `lock()` method, this method blocks while waiting
    until the lock is acquired, in difference to the `lock()` method, if another thread
    interrupts the waiting thread, this method throws the `InterruptedException` exception'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lockInterruptibly()`: 如果当前线程没有被中断，则获取锁。类似于 `lock()` 方法，该方法在等待直到获取锁时阻塞，与 `lock()`
    方法不同的是，如果另一个线程中断了等待线程，则此方法会抛出 `InterruptedException` 异常'
- en: '`tryLock()`: This acquires the lock immediately if it is free at the time of
    invocation'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryLock()`: 如果在调用时锁是空闲的，则立即获取锁'
- en: '`tryLock(long time, TimeUnit unit)`: This acquires the lock if it is free within
    the given waiting time and the current thread has not been interrupted'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryLock(long time, TimeUnit unit)`: 如果在给定的等待时间内锁是空闲的，并且当前线程没有被中断，则获取锁'
- en: '`newCondition()`: This returns a new `Condition` instance that is bound to
    this `Lock` instance, after acquiring the lock, the thread can release it (calling
    the `await()` method on the `Condition` object) until some other thread calls
    `signal()` or `signalAll()` on the same `Condition` object, it is also possible
    to specify the timeout period (by using an overloaded `await()` method), so the
    thread will resume after the timeout if there was no signal received, see the
    `Condition` API for more details'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCondition()`: 这将返回一个与该 `Lock` 实例绑定的新 `Condition` 实例，在获取锁之后，线程可以释放它（在 `Condition`
    对象上调用 `await()` 方法）直到其他线程在同一个 `Condition` 对象上调用 `signal()` 或 `signalAll()`，也可以通过使用重载的
    `await()` 方法指定超时时间，如果在此期间没有收到信号，线程将在超时后恢复，有关更多详细信息，请参阅 `Condition` API'
- en: The scope of this book does not allow us to show all the possibilities for thread
    synchronization provided in the `java.util.concurrent.locks` package. It would
    take several lessons to describe all of them. But even from this short description,
    you can see that one would be hard pressed to find a synchronization problem that
    cannot be solved using the `java.util.concurrent.locks` package.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本书范围不允许我们展示 `java.util.concurrent.locks` 包中提供的所有线程同步的可能性。描述所有这些功能需要几节课。但即使从这简短的描述中，你也可以看出，很难找到一个无法使用
    `java.util.concurrent.locks` 包解决的同步问题。
- en: The synchronization of a method or block of code makes sense when several lines
    of code have to be isolated as an atomic (all or nothing) operation. But in the
    case of a simple assignment to a variable or increment/decrement of a number (as
    in our earlier examples), there is a much better way to synchronize this operation
    by using classes from the `java.util.concurrent.atomic` package that support lock-free
    thread-safe programming on a single variable. The variety of classes covers all
    the numbers and even arrays and reference types such as `AtomicBoolean`, `AtomicInteger`,
    `AtomicIntegerArray`, `AtomicReference`, and `AtomicReferenceArray`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将几行代码作为一个原子（全部或无）操作隔离时，方法或代码块的同步才有意义。但在简单赋值给变量或数字的增减（如我们之前的例子所示）的情况下，使用 `java.util.concurrent.atomic`
    包中的类来同步此操作是一个更好的方法，这些类支持对单个变量的无锁线程安全编程。这些类的多样性涵盖了所有数字，甚至包括数组以及如 `AtomicBoolean`、`AtomicInteger`、`AtomicIntegerArray`、`AtomicReference`
    和 `AtomicReferenceArray` 这样的引用类型。
- en: There are 16 classes in total. Depending on the value type, each of them allows
    a full imaginable range of operations, that is, `set()`, `get()`, `addAndGet()`,
    `compareAndSet()`, `incrementAndGet()`, `decrementAndGet()`, and many others.
    Each operation is implemented much more efficiently than the same operations implemented
    with the `synchronized` keyword. And there is no need for the `volatile` keyword
    because it uses it under the hood.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有 16 个类。根据值类型，每个类都允许一个完整的可想象的操作范围，即 `set()`、`get()`、`addAndGet()`、`compareAndSet()`、`incrementAndGet()`、`decrementAndGet()`
    以及许多其他操作。每个操作都比使用 `synchronized` 关键字实现的相同操作更高效。而且不需要 `volatile` 关键字，因为它在底层使用它。
- en: If the concurrently accessed resource is a collection, the `java.util.concurrent`
    package offers a variety of thread-safe implementations that perform better than
    synchronized `HashMap`, `Hashtable`, `HashSet`, `Vector`, and `ArrayList` (if
    we compare the corresponding `ConcurrentHashMap`, `CopyOnWriteArrayList`, and
    `CopyOnWriteHashSet`). The traditional synchronized collections lock the whole
    collection while concurrent collections use such advanced techniques such as lock
    stripping to achieve thread safety. The concurrent collections especially shine
    with more reading and fewer updates and they are much more scalable than synchronized
    collections. But if the size of your shared collection is small and writes dominate,
    the advantage of concurrent collections is not as obvious.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果并发访问的资源是一个集合，`java.util.concurrent` 包提供了各种线程安全实现，这些实现比同步的 `HashMap`、`Hashtable`、`HashSet`、`Vector`
    和 `ArrayList`（如果我们比较相应的 `ConcurrentHashMap`、`CopyOnWriteArrayList` 和 `CopyOnWriteHashSet`）表现更好。传统的同步集合锁定整个集合，而并发集合使用诸如锁剥离等高级技术来实现线程安全。并发集合在读取更多而更新较少的情况下特别出色，并且它们比同步集合具有更高的可伸缩性。但如果共享集合的大小较小且写入占主导地位，并发集合的优势并不那么明显。
- en: Tuning JVM
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整 JVM
- en: Each pyramid building, as any big project, goes through the same life cycle
    of design, planning, execution, and delivery. And throughout each of these phases,
    a continuous tuning is going on, a complex project is called so for a reason.
    A software system is not different in this respect. We design, plan and build
    it, then change and tune continuously. If we are lucky, then the new changes do
    not go too far back to the initial stages and do not require changing the design.
    To hedge against such drastic steps, we use prototypes (if the waterfall model
    is used) or iterative delivery (if the agile process is adopted) for early detection
    of possible problems. Like young parents, we are always on alert, monitoring the
    progress of our child, day and night.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大型项目一样，每个金字塔建筑都经历了相同的设计、规划、执行和交付的生命周期。在整个这些阶段中，都在进行持续的调整，复杂项目之所以被称为复杂，是有原因的。在这一点上，软件系统并无不同。我们设计、规划并构建它，然后持续地进行更改和调整。如果我们幸运的话，新的更改不会退回到初始阶段，也不需要更改设计。为了防止这种极端的步骤，我们使用原型（如果使用瀑布模型）或迭代交付（如果采用敏捷流程）来早期发现可能的问题。就像年轻的父母一样，我们总是保持警惕，日夜监控我们孩子的进展。
- en: 'As we mentioned already in one of the previous sections, there are several
    diagnostic tools that come with each JDK 9 installation or can be used in addition
    to them for monitoring your Java application. The full list of these tools (and
    the recommendations how to create a custom tool, if needed) can be found in official
    Java SE documentation on the Oracle site: [https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm](https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的某个部分提到的，每个JDK 9安装都附带了一些诊断工具，或者可以在它们的基础上使用，以监控你的Java应用程序。这些工具的完整列表（以及如果需要如何创建自定义工具的建议）可以在Oracle网站上找到的官方Java
    SE文档中找到：[https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm](https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm)。
- en: Using these tools one identifies the bottleneck of the application and addresses
    it either programmatically or by tuning the JVM itself or both. The biggest gain
    usually comes with the good design decisions and from using certain programming
    techniques and frameworks, some of which we have described in other sections.
    In this section, we are going to look at the options available after all possible
    code changes are applied or when changing code is not an option, so all we can
    do is to tune JVM itself.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具可以识别应用程序的瓶颈，并通过编程方式或调整JVM本身或两者兼之来解决它。最大的收益通常来自于良好的设计决策和使用某些编程技术和框架，其中一些我们在其他部分已经描述过。在本节中，我们将探讨在应用了所有可能的代码更改之后或更改代码不是选项时，可用的选项，因此我们所能做的就是调整JVM本身。
- en: 'The goal of the effort depends on the results of the application profiling
    and the nonfunctional requirements for:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 努力的目标取决于应用程序配置文件的结果以及以下非功能性需求：
- en: Latency, or how responsive the application is to the input
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟，即应用程序对输入的响应速度
- en: Throughput, or how much work the application is doing in a given unit of time
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吞吐量，即应用程序在给定时间单位内完成的工作量
- en: Memory footprint, or how much memory the application requires
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存占用，即应用程序所需的内存量
- en: The improvements in one of them often are possible only at the expense of the
    one or both of the others. The decrease in the memory consumption may bring down
    the throughput and latency, while the decrease in latency typically can be achieved
    only via the increase in memory footprint unless you can bring in faster CPUs
    thus improving all three characteristics.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个方面的改进通常只能以牺牲其他一个或两个方面的代价为前提。内存消耗的减少可能会降低吞吐量和延迟，而降低延迟通常只能通过增加内存占用来实现，除非你能引入更快的CPU，从而提高所有三个特性。
- en: Application profiling may show that one particular operation keeps allocating
    a lot of memory in the loop. If you have an access to the code, you can try to
    optimize this section of the code and thus ease the pressure on JVM. Alternatively,
    it may show that there is an I/O or another interaction with a low device is involved,
    and there is nothing you can do in the code to improve it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序配置文件可能显示某个特定操作在循环中持续分配大量内存。如果你可以访问代码，你可以尝试优化这段代码，从而减轻JVM的压力。或者，它可能显示涉及I/O或其他与低设备交互的情况，而在代码中你无法做任何事情来改善它。
- en: Defining the goal of the application and JVM tuning requires establishing metrics.
    For example, it is well known already that the traditional measure of latency
    as the average response time hides more than it reveals about the performance.
    The better latency metrics would be the maximum response time in conjunction with
    99% best response time. For throughput, a good metrics would be the number of
    transactions per a unit of time. Often the inverse of this metrics (time per transaction)
    closely reflects latency. For the memory footprint, the maximum allocated memory
    (under the load) allows for the hardware planning and setting guards against the
    dreaded `OutOfMemoryError` exception. Avoiding full (stop-the-world) garbage collection
    cycle would be ideal. In practice, though, it would be good enough if **Full GC**
    happens not often, does not visibly affect the performance and ends up with approximately
    the same heap size after several cycles.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 定义应用程序和JVM调优的目标需要建立指标。例如，众所周知，将延迟的传统度量作为平均响应时间隐藏了比揭示的更多关于性能的信息。更好的延迟指标将是最大响应时间与99%最佳响应时间的结合。对于吞吐量，一个好的指标将是单位时间内的交易数量。通常，这个指标的倒数（每笔交易的时间）密切反映了延迟。对于内存占用，最大分配的内存（在负载下）允许进行硬件规划，并设置防止可怕的`OutOfMemoryError`异常的防护措施。避免完全（停止世界）垃圾回收周期将是理想的。然而，在实践中，如果**Full
    GC**不经常发生，不会明显影响性能，并在几个周期后最终达到大约相同的堆大小，那就足够好了。
- en: 'Unfortunately, such simplicity of the requirements does happen in practice.
    Real life brings more questions all the time as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种要求的简单性在实践中并不常见。现实生活总是带来更多的问题，如下所示：
- en: Can the target latency (response time) be ever exceeded?
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标延迟（响应时间）是否可能超过？
- en: If yes, how often and by how much?
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是，那么多频繁以及增加多少？
- en: How long can the period of the poor response time last?
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应时间差的周期可以持续多长时间？
- en: Who/what measures the latency in production?
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁或什么在生产中测量延迟？
- en: Is the target performance the peak performance?
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标性能是峰值性能吗？
- en: What is the expected peak load?
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的峰值负载是多少？
- en: How long is the expected peak load going to last?
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的峰值负载将持续多长时间？
- en: Only after all these and similar questions are answered and the metrics (that
    reflect the nonfunctional requirements) are established, we can start tweaking
    the code, running it and profiling again and again, then tweaking the code and
    repeating the cycle. This activity has to consume most of the efforts because
    tuning of the JVM itself can bring only the fraction of the performance improvements
    by comparison with the performance gained by the code changes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在回答了所有这些问题并建立了指标（反映非功能性要求）之后，我们才能开始调整代码，运行它，并反复进行性能分析，然后调整代码并重复循环。这项活动必须消耗大部分努力，因为与代码更改带来的性能提升相比，JVM本身的调优只能带来一小部分性能提升。
- en: Nevertheless, several passes of the JVM tuning must happen early in order to
    avoid wasting of the efforts and trying to force the code in the not well-configured
    environment. The JVM configuration has to be as generous as possible for the code
    to take advantage of all the available resources.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了防止浪费努力并尝试在配置不当的环境中强制执行代码，必须尽早进行几次JVM调优。JVM配置必须尽可能慷慨，以便代码可以利用所有可用资源。
- en: 'First of all, select garbage collector from the four that JVM 9 supports, which
    are as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从JVM 9支持的四种垃圾收集器中选择，如下所示：
- en: '**Serial collector**: This uses a single thread to perform all the garbage
    collection work'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行收集器**：这使用单个线程来执行所有的垃圾回收工作'
- en: '**Parallel collector**: This uses multiple threads to speed up garbage collection'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行收集器**：这使用多个线程来加速垃圾回收'
- en: '**Concurrent Mark Sweep (CMS) collector**: This uses shorter garbage collection
    pauses at the expense of taking more of the processor time'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发标记清除（CMS）收集器**：这以牺牲更多处理器时间为代价，使用较短的垃圾回收暂停时间'
- en: '**Garbage-First (G1) collector**: This is intended for multiprocessor machines
    with a large memory, but meets garbage collection pause-time goals with high probability,
    while achieving high throughput.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾优先（G1）收集器**：这是为具有大内存的多处理器机器设计的，但以高概率满足垃圾收集暂停时间目标，同时实现高吞吐量。'
- en: 'The official Oracle documentation ([https://docs.oracle.com/javase/9/gctuning/available-collectors.htm](https://docs.oracle.com/javase/9/gctuning/available-collectors.htm))
    provides the following initial guidelines for the garbage collection selection:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的Oracle文档（[https://docs.oracle.com/javase/9/gctuning/available-collectors.htm](https://docs.oracle.com/javase/9/gctuning/available-collectors.htm)）提供了以下垃圾收集选择的初始指南：
- en: If the application has a small dataset (up to approximately 100 MB), then select
    the serial collector with the `-XX:+UseSerialGC` option
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序的数据集很小（最多约100 MB），那么选择带有 `-XX:+UseSerialGC` 选项的串行收集器
- en: If the application will be run on a single processor and there are no pause-time
    requirements, then select the serial collector with the `-XX:+UseSerialGC` option
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序将在单个处理器上运行且没有暂停时间要求，那么选择带有 `-XX:+UseSerialGC` 选项的串行收集器
- en: If (a) peak application performance is the first priority and (b) there are
    no pause-time requirements or pauses of one second or longer are acceptable, then
    let the VM select the collector or select the parallel collector with `-XX:+UseParallelGC`
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果（a）峰值应用程序性能是首要任务，并且（b）没有暂停时间要求或一秒或更长的暂停是可以接受的，那么让虚拟机选择收集器或使用 `-XX:+UseParallelGC`
    选择并行收集器
- en: If the response time is more important than the overall throughput and garbage
    collection pauses must be kept shorter than approximately one second, then select
    a concurrent collector with `-XX:+UseG1GC or -XX:+UseConcMarkSweepGC`
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果响应时间比整体吞吐量更重要，并且垃圾收集暂停必须短于大约一秒，那么选择带有 `-XX:+UseG1GC 或 -XX:+UseConcMarkSweepGC`
    的并发收集器
- en: But if you do not have particular preferences yet, let the JVM select garbage
    collector until you learn more about your application's needs. In JDK 9, the G1
    is selected by default on certain platforms, and it is a good start if the hardware
    you use has enough resources.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您还没有特定的偏好，让JVM选择垃圾收集器，直到您更多地了解应用程序的需求。在JDK 9中，某些平台上默认选择G1，如果您使用的硬件有足够的资源，这是一个良好的开始。
- en: Oracle also recommends using G1 with its default settings, then later playing
    with a different pause-time goal using the `-XX:MaxGCPauseMillis` option and maximum
    Java heap size using the `-Xmx` option. Increasing either the pause-time goal
    or the heap size typically leads to a higher throughput. The latency is affected
    by the change of the pause-time goal too.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle还推荐使用默认设置的G1，然后使用 `-XX:MaxGCPauseMillis` 选项调整不同的暂停时间目标，并使用 `-Xmx` 选项设置最大Java堆大小。增加暂停时间目标或堆大小通常会导致更高的吞吐量。延迟也会受到暂停时间目标变化的影响。
- en: 'While tuning the GC, it is beneficial to keep the `-Xlog:gc*=debug` logging
    option. It provides many useful details about garbage collection activity. The
    first goal of JVM tuning is to decrease the number of full heap GC cycles (Full
    GC) because they are very resource consuming and thus may slow down the application.
    It is caused by too high occupancy of the old generation area. In the log, it
    is identified by the words `Pause Full (Allocation Failure)`. The following are
    the possible steps to reduce chances of Full GC:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整垃圾回收（GC）时，保持 `-Xlog:gc*=debug` 记录选项是有益的。它提供了关于垃圾回收活动的许多有用细节。JVM调整的第一个目标是减少完全堆GC周期（Full
    GC）的数量，因为它们非常消耗资源，从而可能减慢应用程序的速度。这是由于旧年代区域占用过高造成的。在日志中，它被标识为“暂停完全（分配失败）”。以下是一些减少Full
    GC发生概率的可能步骤：
- en: Bring up the size of the heap using `-Xmx`. But make sure it does not exceed
    the physical size of RAM. Better yet, leave some RAM space for other applications.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-Xmx` 增加堆的大小。但请确保它不超过物理RAM的大小。更好的是，为其他应用程序留出一些RAM空间。
- en: Increase the number of concurrent marking threads explicitly using `-XX:ConcGCThreads`.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确使用 `-XX:ConcGCThreads` 增加并发标记线程的数量。
- en: 'If the humongous objects take too much of the heap (watch for **gc+heap=info**
    logging that shows the number next to humongous regions) try to increase the region
    size using `-XX: G1HeapRegionSize`.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果大对象占用了太多的堆空间（注意 `gc+heap=info` 记录显示大对象区域旁边的数字），尝试使用 `-XX: G1HeapRegionSize`
    增加区域大小。'
- en: Watch the GC log and modify the code so that almost all the objects created
    by your application are not moved beyond the young generation (dying young).
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察GC日志并修改代码，以确保您应用程序创建的几乎所有对象都不会移动到年轻代之外（死亡年轻）。
- en: Add or change one option at a time, so you can understand the causes of the
    change in the JVM's behavior clearly.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次添加或更改一个选项，这样您可以清楚地了解JVM行为变化的原因。
- en: These few steps will help you go and create a trial-and-error cycle that will
    bring you a better understanding of the platform you are using, the needs of your
    application, and the sensitivity of the JVM and the selected GC to different options.
    Equipped with this knowledge, you will then be able to meet the nonfunctional
    performance requirements whether by changing the code, tuning the JVM, or reconfiguring
    the hardware.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这几个步骤将帮助你创建一个试错循环，这将使你对所使用的平台、应用程序的需求以及JVM和所选GC对不同选项的敏感性有更深入的理解。具备这些知识后，你将能够通过更改代码、调整JVM或重新配置硬件来满足非功能性性能要求。
- en: Reactive Programming
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: After several false starts and a few disastrous disruptions, followed by heroic
    recoveries, the process of pyramid building took shape and ancient builders were
    able to complete a few projects. The final shape sometimes did not look exactly
    as envisioned (the first pyramids have ended up bent), but, nevertheless, the
    pyramids still decorate the desert today. The experience was passed from generation
    to generation, and the design and the process were tuned well enough to produce
    something magnificent and pleasant to look at more than 4,000 years later.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了几次失败尝试和几次灾难性的中断，以及英雄般的恢复之后，金字塔建造的过程逐渐成形，古代建造者能够完成几个项目。最终形状有时并不完全符合预期（最初的金字塔最终变成了弯曲的），但无论如何，金字塔至今仍在沙漠中装饰着。这种经验代代相传，设计和过程经过足够的调整，能够在4000多年后仍然产生令人惊叹且令人愉悦的景象。
- en: The software practices also change over time, albeit we have had only some 70
    years since Mr. Turing wrote the first modern program. In the beginning, when
    there were only a handful of programmers in the world, a computer program used
    to be a continuous list of instructions. Functional programming (pushing a function
    around like a first-class citizen) was introduced very early too but has not become
    a mainstream. Instead, the **GOTO** instruction allowed you to roll code in a
    spaghetti bowl. Structural programming followed, then object-oriented programming,
    with functional programming moving along and even thriving in certain areas. Asynchronous
    processing of the events generated by the pressed keys became routine for many
    programmers. JavaScript tried to use all of the best practices and gained a lot
    of power, even if at the expense of programmers' frustration during the debugging
    (fun) phase. Finally, with thread pools and lambda expressions being part of JDK
    SE, adding reactive streams API to JDK 9 made Java part of the family that allows
    reactive programming with asynchronous data streams.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 软件实践也随着时间的推移而改变，尽管自图灵先生编写第一个现代程序以来，我们只有大约70年的时间。起初，当世界上只有少数程序员时，计算机程序通常是一系列连续的指令。函数式编程（将函数当作一等公民来推动）也引入得很早，但并没有成为主流。相反，**GOTO**指令允许你在意大利面般的代码中滚动。随后是结构化编程，然后是面向对象编程，函数式编程在某个领域甚至蓬勃发展。异步处理由按下的按键生成的事件成为许多程序员的常规操作。JavaScript试图使用所有最佳实践，获得了大量力量，尽管这牺牲了程序员在调试（有趣）阶段的挫败感。最后，随着线程池和lambda表达式成为JDK
    SE的一部分，将响应式流API添加到JDK 9使Java成为允许使用异步数据流的响应式编程家族的一员。
- en: 'To be fair, we were able to process data asynchronously even without this new
    API--by spinning worker threads and using thread pools and callables (as we described
    in the previous sections) or by passing the callbacks (even if lost once in a
    while in the maze of the one who-calls-whom). But, after writing such a code a
    few times, one notices that most of such code is just a plumbing that can be wrapped
    inside a framework that can significantly simplify asynchronous processing. That''s
    how the Reactive Streams initiative ([http://www.reactive-streams.org](http://www.reactive-streams.org))
    came to be created and the scope of the effort is defined as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，即使没有这个新API，我们也能够异步处理数据——通过旋转工作线程和使用线程池以及可调用对象（正如我们在前面的章节中所描述的）或者通过传递回调（即使有时在“谁调用谁”的迷宫中丢失）。但是，编写了几次这样的代码之后，人们会注意到，大多数这样的代码只是管道，可以封装在一个框架中，这可以显著简化异步处理。这就是Reactive
    Streams倡议（[http://www.reactive-streams.org](http://www.reactive-streams.org)）得以创立的原因，该倡议的范围如下定义：
- en: The scope of Reactive Streams is to find a minimal set of interfaces, methods
    and protocols that will describe the necessary operations and entities to achieve
    the goal--asynchronous streams of data with non-blocking back pressure.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams 的范围是找到一个最小的接口、方法和协议集，以描述实现目标所需的必要操作和实体——具有非阻塞背压的异步数据流。
- en: The term **non-blocking back pressure** is an important one because it identifies
    one of the problems of the existed asynchronous processing--coordination of the
    speed rate of the incoming data with the ability of the system to process them
    without the need of stopping (blocking) the data input. The solution would still
    include some back pressure by informing the source that the consumer has difficulty
    in keeping up with the input, but the new framework should react to the change
    of the rate of the incoming data in a more flexible manner than just blocking
    the flow, thus the name **reactive**.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**非阻塞背压** 这个术语非常重要，因为它标识了现有异步处理中的一个问题——协调传入数据的速率与系统处理它们的能力，无需停止（阻塞）数据输入。解决方案仍然包括通过通知源消费者难以跟上输入来提供一些背压，但新的框架应该比仅仅阻塞流更灵活地响应传入数据速率的变化，因此得名
    **reactive**。'
- en: 'The Reactive Streams API consists of the five interfaces included in the class
    which are `java.util.concurrent.Flow`, `Publisher`, `Subscriber`, `Subscription`,
    and `Processor`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Reactive Streams API 包含了类中包含的五个接口，分别是 `java.util.concurrent.Flow`、`Publisher`、`Subscriber`、`Subscription`
    和 `Processor`：
- en: '[PRE53]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A `Flow.Subscriber` object becomes a subscriber of the data produced by the
    object of `Flow.Publisher` after the object of `Flow.Subscriber` is passed as
    a parameter into the `subscribe()` method. The publisher (object of `Flow.Publisher`)
    calls the subscriber's `onSubscribe()` method and passes as a parameter a `Flow.Subsctiption`
    object. Now, the subscriber can request `numberOffItems` of data from the publisher
    by calling the subscription's `request()` method. That is the way to implement
    the pull model when a subscriber decides when to request another item for processing.
    The subscriber can unsubscribe from the publisher services by calling the `cancel()`
    subscription method.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Subscriber` 对象在将 `Flow.Subscriber` 对象作为参数传递给 `subscribe()` 方法后，成为 `Flow.Publisher`
    对象产生的数据的订阅者。发布者（`Flow.Publisher` 对象）调用订阅者的 `onSubscribe()` 方法，并传递一个 `Flow.Subscription`
    对象作为参数。现在，订阅者可以通过调用订阅的 `request()` 方法从发布者请求 `numberOffItems` 的数据。这就是当订阅者决定何时请求另一个项目进行处理时实现拉模型的途径。订阅者可以通过调用
    `cancel()` 订阅方法从发布者服务中取消订阅。'
- en: In return (or without any request, if the implementer has decided to do so,
    that would be a push model), the publisher can pass to the subscriber a new item
    by calling the subscriber's `onNext()` method. The publisher can also tell the
    subscriber that the item production has encountered a problem (by calling the
    subscriber's `onError()` method) or that no more data will be coming (by calling
    the subscriber's `onComplete()` method).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回报（或者如果没有请求，如果实现者决定这样做，那将是一个推送模型），发布者可以通过调用订阅者的 `onNext()` 方法将新项目传递给订阅者。发布者还可以通过调用订阅者的
    `onError()` 方法告诉订阅者项目生产遇到了问题，或者通过调用订阅者的 `onComplete()` 方法告诉订阅者没有更多数据将到来。
- en: The `Flow.Processor` interface describes an entity that can act as both a subscriber
    and a publisher. It allows creating chains (pipelines) of such processors, so
    a subscriber can receive an item from a publisher, tweak it, and then pass the
    result to the next subscriber.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Processor` 接口描述了一个可以同时作为订阅者和发布者的实体。它允许创建这样的处理器的链（管道），因此订阅者可以从发布者那里接收一个项目，对其进行调整，然后将结果传递给下一个订阅者。'
- en: This is the minimal set of interfaces the Reactive Streams initiative has defined
    (and it is a part of JDK 9 now) in support of the asynchronous data streams with
    non-blocking back pressure. As you can see, it allows the subscriber and publisher
    to talk to each other and coordinate, if need be, the rate of incoming data, thus
    making possible a variety of solutions for the back pressure problem we discussed
    in the beginning.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Reactive Streams 初始化计划定义的最小接口集（现在它是 JDK 9 的一部分），以支持具有非阻塞背压的异步数据流。正如你所见，它允许订阅者和发布者相互通信并协调，如果需要的话，协调传入数据的速率，从而使得我们讨论开始时提到的背压问题有各种解决方案。
- en: 'There are many ways to implement these interfaces. Currently, in JDK 9, there
    is only one example of implementation of one of the interfaces--the `SubmissionPublisher`
    class implements `Flow.Publisher`. But several other libraries already exist that
    implemented Reactive Streams API: RxJava, Reactor, Akka Streams, and Vert.x are
    among the most known. We will use RxJava 2.1.3 in our examples. You can find the
    RxJava 2.x API on [http://reactivex.io](http://reactivex.io) under the name ReactiveX,
    which stands for Reactive Extension.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些接口的方法有很多。目前，在JDK 9中，只有一个接口的实现示例——`SubmissionPublisher`类实现了`Flow.Publisher`接口。但已经存在几个其他库实现了响应式流API：RxJava、Reactor、Akka
    Streams和Vert.x是最知名的。在我们的例子中，我们将使用RxJava 2.1.3。您可以在[http://reactivex.io](http://reactivex.io)下找到RxJava
    2.x API，其名称为ReactiveX，代表响应式扩展。
- en: While doing that, we would also like to address the difference between the streams
    of the `java.util.stream` package and Reactive Streams (as implemented in RxJava,
    for example). It is possible to write very similar code using any of the streams.
    Let's look at an example. Here is a program that iterates over five integers,
    selects even numbers only (2 and 4), transforms each of them (takes a square root
    of each of the selected numbers) and then calculates an average of the two square
    roots. It is based on the traditional `for` loop.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在做这件事的同时，我们还想讨论`java.util.stream`包中的流和响应式流（例如在RxJava中实现）之间的区别。使用任何流都可以编写非常相似的代码。让我们看看一个例子。这是一个遍历五个整数、只选择偶数（2和4）、将它们每个都进行转换（取所选数字的平方根）然后计算两个平方根的平均值的程序。它基于传统的`for`循环。
- en: 'Let''s start with the similarity. It is possible to implement the same functionality
    using any of the streams. For example, here is a method that iterates over five
    integers, selects even numbers only (2 and 4, in this case), transforms each of
    them (takes a square root of each of the even numbers) and then calculates an
    average of the two square roots. It is based on the traditional `for` loop:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从相似性开始。使用任何流都可以实现相同的功能。例如，这里有一个遍历五个整数的方法，只选择偶数（在这种情况下是2和4），将它们每个都进行转换（取每个偶数的平方根），然后计算两个平方根的平均值。它基于传统的`for`循环：
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we run this program, the result will be as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，结果将如下所示：
- en: '![Reactive Programming](img/03_30.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![响应式编程](img/03_30.jpg)'
- en: 'The same functionality (with the same output) can be implemented using the
    package `java.util.stream` as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用包`java.util.stream`以以下方式实现相同的功能（具有相同的输出）：
- en: '[PRE55]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The same functionality can be implemented with RxJava:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用RxJava实现相同的功能：
- en: '[PRE56]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: RxJava is based on the `Observable` object (which plays the role of `Publisher`)
    and `Observer` that subscribes to the `Observable` and waits for data to be emitted.
    Each item of the emitted data (on the way from the `Observable` to the `Observer`)
    can be processed by the operations chained in a fluent style (see the previous
    code). Each operation takes a lambda expression. The operation functionality is
    obvious from its name.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava基于`Observable`对象（充当`Publisher`的角色）和订阅`Observable`并等待数据发出的`Observer`。从`Observable`到`Observer`的每个发出数据项（在链式操作中）都可以通过流畅风格中的操作进行处理（参见前面的代码）。每个操作都接受一个lambda表达式。操作功能从其名称中显而易见。
- en: 'Despite being able to behave similarly to the streams, an `Observable` has
    significantly different capabilities. For example, a stream, once closed, cannot
    be reopened, while an `Observable` can be reused. Here is an example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以表现得与流相似，但`Observable`具有显著不同的功能。例如，一旦流关闭，就不能重新打开，而`Observable`可以被重用。以下是一个例子：
- en: '[PRE57]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the previous code, we use `Observable` twice--for average value calculation
    and for the summing all the square roots of the even numbers. The output is as
    shown in the following screenshot:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了两次`Observable`——一次用于计算平均值，一次用于求所有偶数平方根的总和。输出如下所示：
- en: '![Reactive Programming](img/03_31.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![响应式编程](img/03_31.jpg)'
- en: 'If we do not want `Observable` to run twice, we can cache its data, by adding
    the `.cache()` operation:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望`Observable`运行两次，我们可以通过添加`.cache()`操作来缓存其数据：
- en: '[PRE58]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The result of the previous code is as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的结果如下：
- en: '![Reactive Programming](img/03_32.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![响应式编程](img/03_32.jpg)'
- en: You can see that the second usage of the same `Observable` took advantage of
    the cached data, thus allowing for better performance.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，第二次使用相同的`Observable`利用了缓存的数据，从而提高了性能。
- en: 'Another `Observable` advantage is that the exception can be caught by `Observer`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 `Observable` 的优点是异常可以被 `Observer` 捕获：
- en: '[PRE59]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `subscribe()` method is overloaded and allows to pass in one, two, or three
    functions:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe()` 方法被重载，允许传入一个、两个或三个函数：'
- en: The first is to be used in case of success
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是用于成功的情况
- en: The second is to be used in case of an exception
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是在发生异常时使用
- en: The third is to be called after all the data is processed
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个是在所有数据处理完毕后调用
- en: 'The `Observable` model also allows more control over multithreaded processing.
    Using `.parallel()` in the streams does not allow you to specify the thread pool
    to be used. But, in RxJava, you can set the type of pool you prefer using the
    method `subscribeOn()` in `Observable`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 模型还允许对多线程处理有更多的控制。在流中使用 `.parallel()` 不允许你指定要使用的线程池。但在 RxJava
    中，你可以使用 `Observable` 中的 `subscribeOn()` 方法设置你喜欢的线程池类型：'
- en: '[PRE60]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `subscribeOn()` method tells `Observable` on which thread to put the data.
    The `Schedulers` class has methods that generate thread pools dealing mostly with
    I/O operations (as in our example), or heavy on computation (method `computation()`),
    or creating a new thread for each unit of work (method `newThread()`), and several
    others, including passing in a custom thread pool (method `from(Executor executor)`).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn()` 方法告诉 `Observable` 在哪个线程上放置数据。`Schedulers` 类有生成线程池的方法，这些方法主要处理
    I/O 操作（如我们的示例所示），或者计算密集型（方法 `computation()`），或者为每个工作单元创建一个新线程（方法 `newThread()`），以及其他几个，包括传入自定义线程池（方法
    `from(Executor executor)`）。'
- en: 'The format of this book does not allow us to describe all the richness of RxJava
    API and other Reactive Streams implementations. Their main thrust is reflected
    in Reactive Manifesto ([http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/))
    that describes Reactive Systems as a new generation of high performing software
    solutions. Built on asynchronous message-driven processes and Reactive Streams,
    such systems are able to demonstrate the qualities declared in the Reactive Manifesto:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 本书格式不允许我们描述 RxJava API 和其他响应式流实现的全部丰富性。它们的主要思想反映在响应式宣言（[http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/））中，该宣言描述响应式系统作为新一代高性能软件解决方案。建立在异步消息驱动过程和响应式流之上，这些系统能够展示响应式宣言中声明的特性：
- en: '**Elasticity**: This has the ability to expand and contract as needed based
    on the load'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：这可以根据需要根据负载进行扩展和收缩'
- en: '**Better responsiveness**: Here, the processing can be parallelized using asynchronous
    calls'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的响应性**：在这里，处理可以通过异步调用并行化'
- en: '**Resilience**: Here, the system is broken into multiple (loosely coupled via
    messages) components, thus facilitating flexible replication, containment, and
    isolation'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：在这里，系统被分解成多个（通过消息松散耦合）组件，从而便于灵活的复制、包含和隔离'
- en: Writing code for Reactive Systems using Reactive Streams for implementing the
    previously mentioned qualities constitutes reactive programming. The typical application
    of such systems today is microservices, which is described in the next lesson.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用响应式流来实现之前提到的特性来编写响应式系统的代码构成了响应式编程。这种系统在当今的典型应用是微服务，这将在下一课中描述。
- en: Summary
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, we have discussed the ways to improve Java application performance
    by using multithreading. We described how to decrease an overhead of creating
    the threads using thread pools and various types of such pools suited for different
    processing requirements. We also brought up the considerations used for selecting
    the pool size and how to synchronize threads so that they do not interfere with
    each other and yield the best performance results. We pointed out that every decision
    on the performance improvements has to be made and tested through direct monitoring
    of the application, and we discussed the possible options for such monitoring
    programmatically and using various external tools. The final step, the JVM tuning,
    can be done via Java tool flags that we listed and commented in the corresponding
    section. Yet more gains in Java application performance might be achieved by adopting
    the concept of reactive programming, which we presented as the strong contender
    among most effective moves toward highly scalable and highly performing Java applications.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们讨论了通过使用多线程来提高Java应用程序性能的方法。我们描述了如何通过线程池减少创建线程的开销，以及适用于不同处理需求的多种类型的线程池。我们还提出了选择池大小时考虑的因素，以及如何同步线程，以确保它们不会相互干扰并产生最佳性能结果。我们指出，每个关于性能改进的决定都必须通过直接监控应用程序来做出和测试，我们讨论了通过编程和利用各种外部工具进行此类监控的可能选项。最后一步，JVM调优，可以通过我们在相应部分列出的Java工具标志来完成。通过采用反应式编程的概念，还可以进一步提高Java应用程序的性能，我们将其作为最有效的向高度可扩展和高度性能的Java应用程序迈进的主要竞争者之一。
- en: In the next lesson, we will talk about adding more workers by splitting the
    application into several microservices, each deployed independently and each using
    multiple threads and reactive programming for better performance, response, scalability,
    and fault-tolerance.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将讨论通过将应用程序拆分为几个微服务来添加更多工作者，每个微服务独立部署，并使用多个线程和反应式编程来提高性能、响应、可扩展性和容错性。
- en: Assessments
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Name the method that calculates the average square root of the first 99,999
    integers and assigns the result to a property that can be accessed anytime.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名一个计算前99999个整数的平均平方根并将结果分配给一个可以随时访问的属性的方法。
- en: 'Which of the following methods creates a thread pool of a fixed size that can
    schedule commands to run after a given delay, or to execute periodically:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个方法创建了一个固定大小的线程池，可以安排在给定延迟后运行命令，或者定期执行：
- en: '`newscheduledThreadPool()`'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newscheduledThreadPool()`'
- en: '`newWorkStealingThreadPool()`'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newWorkStealingThreadPool()`'
- en: '`newSingleThreadScheduledExecutor()`'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newSingleThreadScheduledExecutor()`'
- en: '`newFixedThreadPool()`'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`newFixedThreadPool()`'
- en: 'State whether True or False: One can take advantage of the `Runnable` interface
    being a functional interface and pass the necessary processing function into a
    new thread as a lambda expression.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断是否为True或False：可以利用`Runnable`接口是一个函数式接口，并将必要的处理函数作为lambda表达式传递到新线程中。
- en: After the `__________` method is called, no more worker threads can be added
    to the pool.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`__________`方法后，不能再向池中添加更多工作线程。
- en: '`shutdownNow()`'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shutdownNow()`'
- en: '`shutdown()`'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shutdown()`'
- en: '`isShutdown()`'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isShutdown()`'
- en: '`isShutdownComplete()`'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isShutdownComplete()`'
- en: ________ is based on the `Observable` object, which plays the role of a Publisher.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ________基于`Observable`对象，该对象扮演发布者的角色。
