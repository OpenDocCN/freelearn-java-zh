- en: Chapter 6. Implicits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 隐式
- en: In the previous chapter, we covered the `type` system and polymorphism. We also
    covered the different types of variance which provide ways to constrain parameterized
    types. Finally, we covered some advanced `types` such as abstract type members,
    option, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了`类型`系统和多态性。我们还介绍了不同类型的变异性，它们提供了约束参数化类型的方法。最后，我们介绍了某些高级`类型`，如抽象类型成员、选项等。
- en: In this chapter, we will cover implicit parameters and implicit conversions.
    We'll be learning about how they work, how to use them, and what kind of benefits
    and perils they provide.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍隐式参数和隐式转换。我们将学习它们是如何工作的，如何使用它们，以及它们提供的哪些好处和风险。
- en: When using a third-party library in your code, you usually have to take its
    code as it is. This can make some libraries unpleasant to deal with. It can be
    either the code style that differs from the one in your code base or simply some
    functionality that the library lacks that you can't elegantly supply.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中使用第三方库时，通常必须接受其代码原样。这可能会使某些库难以处理。可能是代码风格与你的代码库不同，或者库缺少某些功能，你无法优雅地提供。
- en: Some languages have come up with solutions to alleviate this problem. Ruby has
    modules, Smalltalk allows packages to add to each other's classes, and C# 3.0
    has static extension methods.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言已经提出了缓解这个问题的解决方案。Ruby 有模块，Smalltalk 允许包向彼此的类中添加功能，而 C# 3.0 有静态扩展方法。
- en: Scala has implicit parameters and conversions. When used in a controlled manner,
    implicits can make working with external libraries more pleasant, and also enable
    some elegant patterns that you can use in your own code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 有隐式参数和转换。当以受控的方式使用时，隐式参数可以使与外部库的交互更加愉快，并允许你在自己的代码中使用一些优雅的模式。
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Describe implicits and how the Scala compiler handles them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述隐式参数以及 Scala 编译器如何处理它们
- en: Explain the design patterns that implicits enable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释隐式参数启用的设计模式
- en: Analyze the common issues that may arise by overusing implicits
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析过度使用隐式参数可能出现的常见问题
- en: Implicit Parameters and Implicit Conversions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式参数和隐式转换
- en: Scala has implicit parameters and conversions. When used in a controlled manner,
    implicit can make working with external libraries more pleasant, and also enable
    some elegant patterns that you can use in your own code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 有隐式参数和转换。当以受控的方式使用时，隐式参数可以使与外部库的交互更加愉快，并允许你在自己的代码中使用一些优雅的模式。
- en: Implicit Parameters
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式参数
- en: '**Implicit parameters** are a way to make the compiler automatically fill in
    some arguments when a method call misses them for some (or all) of the (implicit)
    parameters. The compiler will look for definitions labelled implicit of the required
    types. For example, suppose you want to write a program that prompts the user
    for some action, after displaying a message. You want to customize both the message
    and the string that appear on the prompt. We can assume that the prompt string
    will have a more default value than the message, so one way to implement it using
    implicit parameters is like the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式参数**是一种让编译器在方法调用缺少某些（或所有）隐式参数时自动填充一些参数的方法。编译器将寻找标记为隐式的所需类型的定义。例如，假设你想编写一个程序，在显示消息后提示用户进行某些操作，你希望自定义消息和提示上出现的字符串。我们可以假设提示字符串的默认值将比消息更默认，因此使用隐式参数实现它的方法之一如下：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With the previous implementation, you can call the message function, supplying
    an argument to the prompt parameter explicitly:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的实现中，你可以调用消息函数，并显式地提供一个参数给提示参数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, if we want to reuse the prompt in different message calls, we can create
    a default object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想在不同的消息调用中重用提示，我们可以创建一个默认对象。
- en: '`default`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`默认值`：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can then bring that `default` into scope when we use the message method
    and avoid having to explicitly supply the prompt parameter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在使用消息方法时引入那个`默认值`，从而避免必须显式提供提示参数：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There can be only one implicit parameter list per method, but it can have multiple
    parameters. The implicit parameter list must be the last parameter list of the
    function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法只能有一个隐式参数列表，但它可以有多个参数。隐式参数列表必须是函数的最后一个参数列表。
- en: 'The eligible arguments for an implicit parameter are identifiers that can be
    accessed at the point of the method call without a prefix and that denote an implicit
    definition or an implicit parameter, and members of companion modules of the implicit
    parameter''s type that are labelled implicit. For example, in the previous example,
    if you were to put the `defaultPrompt` implicit in the companion object of `Prompt`,
    it wouldn''t be necessary to import `Prompt` to put `defaultPrompt` into scope
    on calls to message:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式参数的有效参数是可以在方法调用点访问且不带前缀的标识符，它们表示隐式定义或隐式参数，以及隐式参数类型的伴生模块中的标记为隐式的成员。例如，在先前的例子中，如果你将
    `defaultPrompt` 隐式放入 `Prompt` 的伴生对象中，就不需要在调用消息时导入 `Prompt` 来将 `defaultPrompt`
    放入作用域。
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Implicit Conversions
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式转换
- en: '**Implicit** **conversions** provide a way to transparently convert between
    `types`. Implicit conversions are useful when you need a `type` that you don''t
    control (from an external library, for example) to adhere to a specified interface.
    For example, suppose you want to handle an integer as a traversable, so you can
    iterate through its digits. One way to do this is by supplying an implicit conversion:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式** **转换**提供了一种在 `类型` 之间透明转换的方法。当你需要一个你无法控制的 `类型`（例如来自外部库）以符合指定接口时，隐式转换非常有用。例如，假设你想将一个整数作为可遍历的来处理，以便你可以遍历其数字。完成此操作的一种方法是通过提供隐式转换：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `intToIterable` implicit conversion works as a normal method. The special
    thing is the implicit keyword at the start of the definition. You can still apply
    the conversion explicitly or leave it out and get the same behavior:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`intToIterable` 隐式转换就像一个普通方法一样工作。特别之处在于定义开头处的隐式关键字。你可以显式地应用转换，或者省略它，得到相同的行为：'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The best thing about implicit conversions is that they support conversions
    for a type that''s needed at some point in the code. For example, if you have
    the following function, which returns an ordered `Seq` from a `Traversable`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式转换的最好之处在于它们支持在代码的某个位置需要的类型的转换。例如，如果你有以下函数，它从一个 `Traversable` 返回一个有序的 `Seq`：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can pass an `Int` to `orderedSeq`, since there's an implicit conversion
    from `Int` to `Traversable[Int]`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `Int` 传递给 `orderedSeq`，因为存在从 `Int` 到 `Traversable[Int]` 的隐式转换。
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When used indiscriminately, implicits can be dangerous, as they can enable runtime
    errors in locations where we would preferably want the compiler to not compile
    the code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当不加区分地使用隐式转换时，它们可能会很危险，因为它们可以在我们更希望编译器不编译代码的位置启用运行时错误。
- en: You should avoid implicit conversions between common types. The Scala compiler
    signals implicit conversions as dangerous by warning when you define one by default.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应该避免在常见类型之间进行隐式转换。Scala 编译器在默认定义隐式转换时发出警告，将其标记为危险。
- en: As seen before, implicit conversions enable syntax-like extensions to the language.
    The pattern is common throughout the standard library and libraries in the Scala
    ecosystem. The pattern is usually called "rich wrappers", so when you see a class
    named `RichFoo`, it is likely that it is adding syntax-like extensions to the
    Foo type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，隐式转换使语言能够进行类似语法的扩展。这种模式在标准库和 Scala 生态系统中的库中很常见。这种模式通常被称为“丰富包装器”，因此当你看到名为
    `RichFoo` 的类时，它很可能是向 Foo 类型添加类似语法的扩展。
- en: 'To provide allocation-free extension methods, you can use implicit classes
    combined with value classes. For example, if you have the following `RichInt`
    definition:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供无分配的扩展方法，你可以使用隐式类与值类结合。例如，如果你有以下 `RichInt` 定义：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A call to `3.toHexString`, for example, will result in a method call in a `static`
    object ( `RichInt$.MODULE$.extension$toHexString(3)`) rather than a method call
    on a newly instantiated one.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，调用 `3.toHexString` 将会在一个 `static` 对象（`RichInt$.MODULE$.extension$toHexString(3)`）上调用方法，而不是在新生成的对象上调用方法。
- en: Implicit Resolution
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式解析
- en: It is important to know where the compiler looks for implicits and, even more
    importantly, how it decides which implicit to use in situations of apparent ambiguity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 了解编译器在哪里查找隐式转换以及它如何在看似模糊的情况下决定使用哪个隐式转换，这一点非常重要。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on implicit resolution, refer to: [https://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html](https://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有关隐式解析的更多信息，请参阅：[https://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html](https://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html)。
- en: 'For choosing the most specific implicit definition based on the rules of static
    overloading resolution, refer to: [http://scala-lang.org/files/archive/spec/2.11/06-expressions.html](http://scala-lang.org/files/archive/spec/2.11/06-expressions.html).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据静态重载解析规则选择最具体的隐式定义，请参考：[http://scala-lang.org/files/archive/spec/2.11/06-expressions.html](http://scala-lang.org/files/archive/spec/2.11/06-expressions.html)。
- en: The rules of implicit resolution are a bit challenging to remember, so experimenting
    with them can give you more intuition over the Scala compiler.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式解析的规则有点难以记住，所以通过实验它们可以给您关于Scala编译器的更多直观感受。
- en: 'The following list defines where the compiler looks for implicits:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表定义了编译器查找隐式的位置：
- en: Implicits which are defined in the current scope
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前作用域中定义的隐式
- en: Explicit Imports
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式导入
- en: Wildcard Imports
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符导入
- en: Companion Objects of Type
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类的伴随对象
- en: Implicit Scope of an Argument's Type
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型的隐式作用域
- en: Implicit Scope of Type Arguments
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型参数的隐式作用域
- en: Outer Objects for Nested Types
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套类型的外部对象
- en: 'Activity: Creation of Extension Methods'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动：扩展方法的创建
- en: In this activity, we'll be creating extension methods for the `Int` type by
    relying on implicit conversions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将通过依赖隐式转换来为`Int`类型创建扩展方法。
- en: Start by defining a new class, `RichInt`, which will implement your desired
    methods.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义一个新的类`RichInt`，它将实现您所需的方法。
- en: Create an implicit conversion from `Int` to `RichInt`. You can either create
    an implicit method or an implicit value class. Since it's important to avoid the
    runtime overhead, an implicit value class is advisable.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建从`Int`到`RichInt`的隐式转换。您可以选择创建一个隐式方法或一个隐式值类。由于避免运行时开销很重要，建议使用隐式值类。
- en: Implement the methods `square` and `plus`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现方法`square`和`plus`。
- en: Make sure the implicit conversion is in scope, and experiment with calling `square`
    and `plus` on values of type `Int`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保隐式转换在作用域内，并实验调用`square`和`plus`在类型为`Int`的值上。
- en: This section covered implicit parameters and implicit conversions. We saw how
    to enable elegant extension methods for your code. We also had a look at how the
    Scala compiler resolves implicits.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了隐式参数和隐式转换。我们看到了如何为您的代码启用优雅的扩展方法。我们还查看了一下Scala编译器如何解析隐式参数。
- en: Ad Hoc Polymorphism and Type Classes
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特设多态性和类型类
- en: In this section, we'll be exploring ad hoc polymorphism, but through the usage
    of type classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过类型类来探讨特设多态性。
- en: Types of Polymorphism
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态性的类型
- en: 'In computer science, polymorphism is the provision of a single interface to
    entities of different types. Polymorphism consists of three types: subtyping,
    parametric polymorphism, and ad hoc polymorphism.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，多态性是提供单一接口以供不同类型的实体使用。多态性由三种类型组成：子类型、参数多态性和特设多态性。
- en: Subtyping enables polymorphism by having different implementations of the same
    method (but keeping the interface) in the different subclasses. Parametric polymorphism
    enables polymorphism by allowing code to be written without the mention of a specific
    type. For example, when you operate over a generic `List`, you're applying parametric
    polymorphism. Ad hoc polymorphism enables polymorphism by allowing different and
    heterogeneous implementations depending on specified types. Method overloading
    is an example of ad hoc polymorphism.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型通过在不同的子类中具有相同方法的不同实现（但保持接口）来启用多态性。参数多态性通过允许编写不提及特定类型的代码来启用多态性。例如，当您操作泛型`List`时，您正在应用参数多态性。特设多态性通过允许根据指定的类型允许不同和异构的实现来启用多态性。方法重载是特设多态性的一个例子。
- en: Type Classes
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型类
- en: Type classes are a construct that enable ad hoc polymorphism. They originally
    appeared in Haskell, which has native support for them, but transitioned to Scala
    through the use of implicits.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类是一种使特设多态性成为可能的构造。它们最初出现在Haskell中，Haskell原生支持它们，但通过隐式参数的使用过渡到了Scala。
- en: At its core, a `type` class is a class with a `type` parameter that aims to
    bridge type hierarchies. That is, we want to provide behavior to a type hierarchy
    by parameterizing our `type` class and providing specific implementations for
    concrete types. Type classes provide an easy way to extend libraries without touching
    existing code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，`type`类是一个带有`type`参数的类，旨在连接类型层次。也就是说，我们希望通过参数化我们的`type`类并为具体类型提供特定实现来为类型层次提供行为。类型类提供了一种在不接触现有代码的情况下扩展库的简单方法。
- en: 'As a running example throughout this section, consider the following implementation
    of JSON:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的整个过程中，我们将考虑以下JSON的实现：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will be introducing a type class called `JsonWriter[A]`, whose interface
    has a single method `write`, which, given an `A`, returns a `JsValue`. Let''s
    define `JsonWriter` and provide two implementations of it, one for `Int` and another
    for `String`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引入一个名为`JsonWriter[A]`的类型类，其接口有一个单一的方法`write`，它接受一个`A`并返回一个`JsValue`。让我们定义`JsonWriter`并提供两个实现，一个用于`Int`，另一个用于`String`：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can use these specific implementations of `JsonWriter` to convert `Ints`
    and Strings to JSON. For example, we can call `IntJsonWriter.write(4)` and `StringJsonWriter.write("Hello
    World")`. However, we don't want to be calling writers explicitly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些特定的`JsonWriter`实现将`Ints`和字符串转换为JSON。例如，我们可以调用`IntJsonWriter.write(4)`和`StringJsonWriter.write("Hello
    World")`。然而，我们不想显式地调用编写器。
- en: 'Instead of calling `JsonWriters` explicitly, we introduce the `toJson` method,
    which is capable of converting a type to JSON, provided that there is a `JsonWriter`
    in the scope:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是显式地调用`JsonWriters`，而是引入了`toJson`方法，该方法可以将类型转换为JSON，前提是在作用域中有一个`JsonWriter`：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have now introduced ad hoc polymorphism in the `toJson` function. Based on
    the type of value provided to `toJson`, we have different behaviors for the `toJson`
    function, controlled by the `JsonWriters` available in scope. The matter of scope
    is important. Recall that there is precedence to the implicit resolution. As such,
    library authors can provide their own default implementations for their type classes,
    but you can always override it in your client code while keeping the same interface.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在`toJson`函数中引入了特设多态。根据提供给`toJson`的值的类型，我们为`toJson`函数提供了不同的行为，这些行为由作用域内可用的`JsonWriters`控制。作用域的问题很重要。回想一下，隐式解析有优先级。因此，库的作者可以为其类型类提供自己的默认实现，但您可以在客户端代码中覆盖它，同时保持相同的接口。
- en: Context Bounds and Implicitly
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文边界和隐式
- en: '**Context bounds** are syntactic sugar that reduce verbosity when you need
    to pass implicits around. By using a context bound, you reduce the need of an
    implicit parameter list. However, when using a context bound, you lose access
    to the implicit argument used when calling the method. To provide access to it,
    you can use the `implicitly` function. Implicitly provides access to the implicit
    of the requested type in scope. Its implementation is simply this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文边界**是一种语法糖，当您需要传递隐式值时可以减少冗余。通过使用上下文边界，您减少了隐式参数列表的需求。然而，当使用上下文边界时，您将失去调用方法时使用的隐式参数的访问权限。为了提供访问权限，您可以使用`implicitly`函数。`implicitly`提供了对作用域中请求类型的隐式的访问。它的实现很简单：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Type Classes in the Standard Library
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库中的类型类
- en: The type class pattern is heavily used in the Scala standard library. Prime
    examples of its usage are the `Ordering` type classes previously introduced and
    the `CanBuildFrom` type class, which represents builder factories for Scala collections.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类模式在Scala标准库中被广泛使用。其使用的主要例子是之前引入的`Ordering`类型类和代表Scala集合构建器工厂的`CanBuildFrom`类型类。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please take a look at the `Ordering` and `CanBuildFrom` type classes on your
    own. A good overview of the `CanBuildFrom` type class can be obtained from the
    following guide: [http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html](http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请自行查看`Ordering`和`CanBuildFrom`类型类。关于`CanBuildFrom`类型类的好概述可以从以下指南中获得：[http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html](http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html)。
- en: 'Activity: Implementing Type Classes to Support Conversion'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动：实现支持转换的类型类
- en: In this activity, we'll be implementing `type` classes to support conversions
    to `JsValue` for common Scala types. Consider the `JsValue` ADT that was introduced
    in the beginning of the section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将实现`type`类以支持将常见Scala类型转换为`JsValue`。考虑本节开头引入的`JsValue` ADT。
- en: 'Start by defining, if you haven''t already, the `toJson` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果您还没有定义，请定义`toJson`方法：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Implement `JsonWriter` for `Int`, `String,` and `Boolean`. The implementation
    for `Int` and `String` was already provided. A good place to put those implementations,
    according to the implicit resolution rules previously introduced, is in the companion
    object of `JsonWriter`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Int`、`String`和`Boolean`实现`JsonWriter`。根据之前引入的隐式解析规则，这些实现的好地方是在`JsonWriter`的伴生对象中。
- en: Implement `JsonWriter` for `List`, `Set,` and `Map`. In these generic collections,
    note that you can provide a `JsonWriter[List[A]]`, for example, if you have a
    `JsonWriter` for `A`. Not all maps are convertible to JSON, so only provide a
    `Js``onWriter[Map[String, A]]`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`JsonWriter`用于`List`、`Set`和`Map`。在这些泛型集合中，请注意，如果你有一个`JsonWriter[A]`，例如，你可以提供一个`JsonWriter[List[A]]`。并非所有映射都可以转换为JSON，因此只提供一个`JsonWriter[Map[String,
    A]]`。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered implicit parameters and implicit conversions. We
    saw how to enable elegant extension methods for your code. We also had a look
    at how the Scala compiler resolves implicits. Finally, we covered how implicits
    work, how to use them, and what kind of benefits they provide.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了隐式参数和隐式转换。我们看到了如何为你的代码启用优雅的扩展方法。我们还了解到了Scala编译器如何解析隐式参数。最后，我们讨论了隐式参数的工作原理、如何使用它们以及它们能提供什么样的好处。
- en: In the next chapter, we'll cover the core concepts of functional programming
    such as Pure functions, immutability, and higher-order functions. We'll build
    upon this understanding and introduce some of the design patterns that are prevalent
    in large functional programs that you'll no doubt run into once you start to use
    Scala libraries that focus on functional programming. Finally, we'll cover two
    popular functional programming libraries called `Cats` and `Doobie`, and use them
    to write some interesting programs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍函数式编程的核心概念，如纯函数、不可变性和高阶函数。我们将在此基础上介绍一些在大规模函数式程序中普遍存在的模式，你无疑会在开始使用专注于函数式编程的Scala库时遇到这些模式。最后，我们将介绍两个流行的函数式编程库，即`Cats`和`Doobie`，并使用它们编写一些有趣的程序。
