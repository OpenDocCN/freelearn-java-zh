- en: Chapter 9. Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。安全
- en: We will finish up our project by securing it with Java EE solutions. But first,
    we will analyze the improvements in the concerned APIs. The development of this
    chapter will be focused on JASPIC 1.1.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用Java EE解决方案来保护我们的项目来完成我们的项目。但首先，我们将分析相关API的改进。本章的开发将专注于JASPIC 1.1。
- en: JASPIC 1.1
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JASPIC 1.1
- en: The **Java Authentication SPI for Containers** (**JASPIC**) Specification was
    developed under JSR 196\. This section just gives you an overview of improvements
    in the API. For more information, the complete document specification can be downloaded
    from [http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java容器认证SPI**（**JASPIC**）规范是在JSR 196下开发的。本节仅为您概述API的改进。有关更多信息，可以下载完整的规范文档，链接为[http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr349/index.html)。'
- en: Secure access to forms
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单的安全访问
- en: Also called JASPI, the JASPIC Specification defines a set of standard interfaces
    for the development of modules for authentication, which allow secure access to
    web resources (Servlets, JSP, and so on), among others. Generally speaking, the
    JASPIC Specification was designed for message-level security; this means that
    JASPIC modules are called to be integrated into message processing containers
    and thus, offer a transparent secured mechanism for protocols such as SOAP and
    HttpServlet.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为JASPI，JASPIC规范定义了一组标准接口，用于开发认证模块，允许安全访问网络资源（Servlets、JSP等）。一般来说，JASPIC规范是为了消息级安全而设计的；这意味着JASPIC模块被要求集成到消息处理容器中，从而为SOAP和HttpServlet等协议提供透明的安全机制。
- en: Implementing an authentication module
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现认证模块
- en: 'In the case where you don''t want to use a predefined authentication module,
    the JASPIC Specification allows you to develop your own modules. This requires
    the implementation of the `javax.security.auth.message.module.ServerAuthModule`
    interface. For reasons that we will explain later, you may need to implement the
    following interfaces:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在您不想使用预定义的认证模块的情况下，JASPIC规范允许您开发自己的模块。这需要实现`javax.security.auth.message.module.ServerAuthModule`接口。由于我们将在后面解释的原因，您可能需要实现以下接口：
- en: '`javax.security.auth.message.config.ServerAuthConfig`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.security.auth.message.config.ServerAuthConfig`'
- en: '`javax.security.auth.message.config.ServerAuthContext`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.security.auth.message.config.ServerAuthContext`'
- en: '`javax.security.auth.message.config.AuthConfigProvider`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javax.security.auth.message.config.AuthConfigProvider`'
- en: Implementing the ServerAuthModule interface
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现ServerAuthModule接口
- en: 'The `ServerAuthModule` interface contains five methods that must be implemented
    by the authentication module. These methods are the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServerAuthModule`接口包含五个必须由认证模块实现的方法。这些方法如下：'
- en: '`initialize()`: This method is used to initialize the module and retrieve objects
    necessary for the validation of access to resources.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()`: 此方法用于初始化模块并检索验证资源访问所需的必要对象。'
- en: '`getSupportedMessageTypes()`: This method returns an array of objects designating
    message types supported by the module. For example, for a module that will be
    compatible with a Servlet Container profile, the returned array will contain the
    `HttpServletRequest.class` and `HttpServletResponse.class` objects.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSupportedMessageTypes()`: 此方法返回一个对象数组，指定模块支持的消息类型。例如，对于将兼容Servlet容器配置的模块，返回的数组将包含`HttpServletRequest.class`和`HttpServletResponse.class`对象。'
- en: '`validateRequest()`: This method is called by the container whenever an `HttpServletRequest`
    is received for processing of the incoming message. For this purpose, it receives
    from the container `HttpServletRequest` and `HttpServletResponse` objects in the
    `MessageInfo` parameter. At the end of request processing, this method must return
    a status that determines the sequence of operations in the container.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validateRequest()`: 当容器收到一个`HttpServletRequest`以处理传入的消息时，会调用此方法。为此，它从容器接收`HttpServletRequest`和`HttpServletResponse`对象作为`MessageInfo`参数。在请求处理结束时，此方法必须返回一个状态，以确定容器中的操作顺序。'
- en: '`secureResponse()`: This method is called by the container at the time of returning
    a response to a client. Very often, it should return the status `SEND_SUCCESS`.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secureResponse()`: 当容器在向客户端返回响应时调用此方法。通常，它应该返回状态`SEND_SUCCESS`。'
- en: '`cleanSubject()`: This method is used to remove one or several principles of
    a subject argument.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cleanSubject()`: 此方法用于从主题参数中删除一个或多个原则。'
- en: 'The following code provides an example implementation of the `ServerAuthModule`
    interface methods:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了一个`ServerAuthModule`接口方法的示例实现：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing and configuring the authentication module
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装和配置认证模块
- en: Install the authentication module by copying the JAR file of the module in the
    `install_glassfish\ glassfish\domains\domain1\lib` directory of your GlassFish
    Server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将模块的JAR文件复制到GlassFish服务器`install_glassfish\ glassfish\domains\domain1\lib`目录中来安装认证模块。
- en: 'Once the module is installed, you can configure it in the GlassFish administration
    console as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块安装完成，您可以在GlassFish管理控制台中按照以下方式配置它：
- en: Log on to the GlassFish administration console.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到GlassFish管理控制台。
- en: Expand the **server-config** menu.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**server-config**菜单。
- en: In the menu that appears, expand the **Security** menu.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的菜单中，展开**Security**菜单。
- en: In the submenu, expand the **Message security** menu.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子菜单中，展开**消息安全**菜单。
- en: Click on the **HttpServlet** menu.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**HttpServlet**菜单。
- en: On the form that appears, click on the **Providers** tab to add a new provider.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的表单中，点击**Providers**标签以添加一个新的提供者。
- en: Click on the **New** button and fill out the appropriate form. Before recording
    your entry, your form should look like the following screenshot:![Installing and
    configuring the authentication module](img/9235OT_09_01.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**New**按钮并填写适当的表单。在记录您的输入之前，您的表单应如下截图所示：![安装和配置认证模块](img/9235OT_09_01.jpg)
- en: Binding the authentication module to a web application
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将认证模块绑定到Web应用
- en: 'To bind an authentication module to an application, you have two options in
    GlassFish:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在GlassFish中，要将认证模块绑定到应用，您有两个选项：
- en: The first option (which is by far the simplest) is to configure the `httpservlet-security-provider`
    attribute of the element `glassfish-web-app` in the `glassfish-web.xml` file of
    the application. The purpose of this configuration is to make you use the `AuthConfigProvider`
    implementation provided by GlassFish to instantiate your security module. The
    following code shows the contents of the `glassfish-web.xml` file of our application.
    As you can see, we passed the ID of our provider to the `httpservlet-security-provider`
    attribute. Thus, whenever it is necessary to analyze the security of a request,
    the GlassFish server through its `AuthConfigProvider` implementation will instantiate
    our security module in order to make it operational.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个选项（到目前为止这是最简单的）是在应用的`glassfish-web.xml`文件中配置`glassfish-web-app`元素的`httpservlet-security-provider`属性。此配置的目的是让您使用GlassFish提供的`AuthConfigProvider`实现来实例化您的安全模块。以下代码显示了我们的应用`glassfish-web.xml`文件的内容。如您所见，我们将提供者的ID传递给了`httpservlet-security-provider`属性。因此，每当需要分析请求的安全性时，GlassFish服务器将通过其`AuthConfigProvider`实现来实例化我们的安全模块，以便使其可用。
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second method is to implement your own implementation of the `AuthConfigProvider`
    interface. Therefore, in this case, you need to implement `javax.security.auth.message.config.ServerAuthConfig`,
    `javax.security.auth.message.config.ServerAuthContext`, and `javax.security.auth.message.config.AuthConfigProvider`
    interfaces. For those who are thrilled about the adventure, you will find all
    the necessary information in this blog: [http://arjan-tijms.blogspot.com/2012/11/implementing-container-authentication.html](http://arjan-tijms.blogspot.com/2012/11/implementing-container-authentication.html).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是实现`AuthConfigProvider`接口的自定义实现。因此，在这种情况下，您需要实现`javax.security.auth.message.config.ServerAuthConfig`、`javax.security.auth.message.config.ServerAuthContext`和`javax.security.auth.message.config.AuthConfigProvider`接口。对于那些对这次冒险感到兴奋的人，您将在这个博客中找到所有必要的信息：[http://arjan-tijms.blogspot.com/2012/11/implementing-container-authentication.html](http://arjan-tijms.blogspot.com/2012/11/implementing-container-authentication.html)。
- en: Creating a realm
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个域
- en: We will tell the GlassFish server where all the associated users and groups
    that can access the secure sections of our application are stored. In other words,
    we will configure the realm of our application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将告诉GlassFish服务器所有可以访问我们应用安全部分的关联用户和组存储在哪里。换句话说，我们将配置我们应用的域。
- en: 'For your information, GlassFish provides the ability to define several types
    of realms. They are listed as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的信息，GlassFish提供了定义多种类型域的能力。它们如下列出：
- en: The `file` realm, for storing user information in files. This is the default
    realm.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`域，用于在文件中存储用户信息。这是默认域。'
- en: The `ldap` realm, for storage in an LDAP directory server.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldap`域，用于在LDAP目录服务器中存储。'
- en: The `jdbc` realm, for storing in a database.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdbc`域，用于在数据库中存储。'
- en: The `solaris` realm, for authentication management based on Solaris username
    and password.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`solaris` 区域，用于基于 Solaris 用户名和密码的认证管理。'
- en: The `certificate` realm, for authentication management using certificates.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`certificate` 区域，用于使用证书进行认证管理。'
- en: And if none of these realms satisfy your need, don't worry; GlassFish offers
    the possibility of creating your own realm.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这些区域中没有满足您需求的，请不要担心；GlassFish 提供了创建您自己的区域的可能性。
- en: 'In our case, we opt for the `jdbc` realm; we need a database structure to store
    the necessary information (the user name, its password, and the group to which
    it belongs). The following screenshot shows the structure of tables in which our
    information is stored:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们选择了 `jdbc` 区域；我们需要一个数据库结构来存储必要的信息（用户名、密码以及它所属的组）。以下截图显示了存储我们信息的表结构：
- en: '![Creating a realm](img/9235OT_09_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![创建区域](img/9235OT_09_02.jpg)'
- en: The `realm_users` table will store all user IDs and passwords, the `realm_groups`
    table will store all the group IDs of our application with their description,
    while the `users_groups` table will tell us what groups a user belongs to. Thus,
    a user can belong to several groups.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`realm_users` 表将存储所有用户 ID 和密码，`realm_groups` 表将存储所有应用程序的组 ID 及其描述，而 `users_groups`
    表将告诉我们用户属于哪些组。因此，一个用户可以属于多个组。'
- en: 'Once you have defined the structure of the database that will host different
    users, you must configure GlassFish so that it can connect to your database (MySQL
    5, in our case) and access authentication information. To do this, you have to
    start by copying the Java connector of your database (`mysql-connector-java-5.1.23-bin.jar`,
    in our case) into the directory: `glassfish_install_dir\glassfish\domains\domain1\lib`.
    Then, you have to connect to the GlassFish administration console and gain access
    to the realms creation form by navigating to **Configurations** | **server-config**
    | **Security** | **Realms**. By clicking on the **Realms** menu, the following
    form will be displayed; you then need to click on the **New** button and the realms
    creation form will appear:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您定义了将托管不同用户的数据库结构，您必须配置 GlassFish 以使其能够连接到您的数据库（在我们的案例中是 MySQL 5）并访问认证信息。为此，您必须首先将数据库的
    Java 连接器（在我们的案例中是 `mysql-connector-java-5.1.23-bin.jar`）复制到目录：`glassfish_install_dir\glassfish\domains\domain1\lib`。然后，您必须连接到
    GlassFish 管理控制台，通过导航到 **配置** | **服务器配置** | **安全** | **区域** 来获取创建区域的表单。通过点击 **区域**
    菜单，将显示以下表单；然后您需要点击 **新建** 按钮，区域创建表单将出现：
- en: '![Creating a realm](img/9235OT_09_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![创建区域](img/9235OT_09_03.jpg)'
- en: 'The following table shows the fields that you need to fill for a `JDBCRealm`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了您需要为 `JDBCRealm` 填写的字段：
- en: '| **Field** | **Example value** | **Description** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **示例值** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Name** | `MyJDBCRealm` | The name of the realm that will be used to configure
    security in application |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | `MyJDBCRealm` | 将用于配置应用程序安全性的区域名称 |'
- en: '| **Class Name** | `com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm`
    | The class that implements the realm to configure, in our case, `JDBCRealm` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **类名** | `com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm` | 实现要配置的区域（在我们的案例中为
    `JDBCRealm`）的类 |'
- en: '| **JAAS Context** | `jdbcRealm` | JAAS (Java Authentication and Authorization
    Service) context ID |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **JAAS 上下文** | `jdbcRealm` | JAAS（Java 认证和授权服务）上下文 ID |'
- en: '| **JNDI** | `jdbcRealmDataSource` | The JNDI name of the JDBC Resources to
    connect to the database containing the realm |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **JNDI** | `jdbcRealmDataSource` | 连接到包含区域的数据库的 JDBC 资源的 JNDI 名称 |'
- en: '| **User Table** | `realm_users` | The name of the table containing the list
    of system users with their passwords |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **用户表** | `realm_users` | 包含带有密码的系统用户列表的表名称 |'
- en: '| **User Name Column** | `USERID` | The name of the column containing the ID
    of the user in the table `realm_users` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **用户名列** | `USERID` | 包含用户在 `realm_users` 表中 ID 的列名称 |'
- en: '| **Password Column** | `PASSWORD` | The name of the column containing the
    passwords of users |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **密码列** | `PASSWORD` | 包含用户密码的列名称 |'
- en: '| **Group Table** | `users_groups` | The name of the table that associates
    groups and users |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **组表** | `users_groups` | 关联组和用户的表名称 |'
- en: '| **Group Table User Name Column** | `USERID` | The name of the column in the
    association table containing the ID of the user |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **组表用户名列** | `USERID` | 关联表中包含用户 ID 的列名称 |'
- en: '| **Group Name Column** | `GROUPID` | The name of the column in the association
    table containing the identifier of the group |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **组名列** | `GROUPID` | 关联表中包含组标识符的列的名称 |'
- en: '| **Password Encryption Algorithm** | `SHA-256` | To set the password encryption
    algorithm |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **密码加密算法** | `SHA-256` | 设置密码加密算法 |'
- en: '| **Digest Algorithm** | `SHA-256` (even if it is the default value) |   |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **摘要算法** | `SHA-256`（即使它是默认值）| |'
- en: 'After filling the form, you can save your realm. With this configuration, we
    can now use the password validation mechanisms provided by the container to validate
    incoming connections. This is what we have done in the validation method using
    the following statement:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 填写表单后，您可以保存您的领域。使用此配置，我们现在可以使用容器提供的密码验证机制来验证传入的连接。这就是我们在验证方法中使用以下语句所做的事情：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Apart from using the container validation mechanism, you can access your database
    and make this validation yourself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用容器验证机制外，您还可以访问您的数据库并自行进行此验证。
- en: Security configuration
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安全配置
- en: 'To configure the security of an application, you will need to do the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置应用程序的安全性，您需要执行以下操作：
- en: 'Determine the different roles of the application and declare them in `web.xml`.
    In our application, we only need an administrator role to perform batch processing
    and some administrative tasks. The following code demonstrates how to create a
    role named `admin` for this purpose:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定应用程序的不同角色并在 `web.xml` 中声明它们。在我们的应用程序中，我们只需要一个管理员角色来执行批量处理和一些管理任务。以下代码演示了如何为此目的创建一个名为
    `admin` 的角色：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Map URL patterns to appropriate roles in the `web.xml` file. This will define
    the forms that each role can access. Before performing this configuration, you
    must group the forms depending on the access constraints you want to define. In
    the case of our application, we have grouped the forms into two folders: a folder
    for preregistration forms in the registration folder and another folder for administration
    forms in the administration folder. Thus, to ensure that only users of the admin
    role will have access to the administration forms, we will associate the URL pattern
    `/faces/administration/*` to the `admin` role. The following code demonstrates
    how to define a constraint that associates the URL pattern `/faces/administration/*`
    to the `admin` role (the word `faces` of the previous pattern represents the pattern
    defined in the `<servlet-mapping>` element of the `web.xml` file).'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `web.xml` 文件中将 URL 模式映射到适当的角色。这将定义每个角色可以访问的表单。在执行此配置之前，您必须根据您想要定义的访问约束对表单进行分组。在我们的应用程序中，我们将表单分为两个文件夹：注册文件夹中的预注册表单文件夹和行政文件夹中的管理表单文件夹。因此，为了确保只有管理员角色的用户才能访问管理表单，我们将
    URL 模式 `/faces/administration/*` 关联到 `admin` 角色。以下代码演示了如何定义一个将 URL 模式 `/faces/administration/*`
    关联到 `admin` 角色的约束（前一个模式中的 `faces` 单词代表 `web.xml` 文件中的 `<servlet-mapping>` 元素中定义的模式）。
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Associate each role with a user group in the `glassfish-web.xml` file. In the
    realm, each user is associated with a user group. However, the URL patterns are
    associated with roles. So, you need to tell the server which group a role belongs
    to. In GlassFish, this is possible through the `<security-role-mapping>` element.
    The following code shows the complete contents of the `glassfish-web.xml` file
    with the role-group combination:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `glassfish-web.xml` 文件中将每个角色与用户组关联。在领域内，每个用户都与一个用户组关联。然而，URL 模式与角色关联。因此，您需要告诉服务器一个角色属于哪个组。在
    GlassFish 中，这可以通过 `<security-role-mapping>` 元素实现。以下代码显示了包含角色-组组合的 `glassfish-web.xml`
    文件的完整内容：
- en: '[PRE5]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Declare the realm and authentication types to be used by our application in
    `web.xml`. The following code demonstrates how to declare the MyJDBCRealm we created
    in the preceding step. The authentication type we have chosen is `DIGEST`. It
    transmits the password in an encrypted form.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `web.xml` 中声明我们的应用程序将使用的领域和认证类型。以下代码演示了如何声明我们在上一步中创建的 MyJDBCRealm。我们选择的认证类型是
    `DIGEST`。它以加密形式传输密码。
- en: '[PRE6]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once you complete these configurations, candidates can access the registration
    forms without any problem. But, if they try to connect to an admin form, a window
    similar to the following window will be displayed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些配置后，候选人可以无任何问题地访问注册表单。但是，如果他们尝试连接到管理表单，将显示类似于以下窗口的窗口：
- en: '![Security configuration](img/9235OT_09_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![安全配置](img/9235OT_09_04.jpg)'
- en: 'Before finishing up this project, you should know that it is possible to customize
    the login screen and even integrate it into your application. The tutorial at
    URL: [http://blog.eisele.net/2013/01/jdbc-realm-glassfish312-primefaces342.html](http://blog.eisele.net/2013/01/jdbc-realm-glassfish312-primefaces342.html)
    can help you.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个项目之前，你应该知道可以自定义登录屏幕，甚至将其集成到你的应用程序中。URL：[http://blog.eisele.net/2013/01/jdbc-realm-glassfish312-primefaces342.html](http://blog.eisele.net/2013/01/jdbc-realm-glassfish312-primefaces342.html)上的教程可以帮助你。
- en: The latest improvements in action
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最新改进措施
- en: 'The Maintenance Release B of JASPIC Specification has made some significant
    changes, some of which help to standardize the use of the specification regardless
    of the server; others help to enrich the user experience. Among the changes, we
    present only some relatively important changes and advise you to browse the specification
    document and blog found at: [http://arjan-tijms.blogspot.com/2013_04_01_archive.html](http://arjan-tijms.blogspot.com/2013_04_01_archive.html),
    which will provide you with more information.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: JASPIC规范维护发布B版本已经做出了一些重大更改，其中一些有助于标准化无论服务器如何使用规范；其他有助于丰富用户体验。在更改中，我们只介绍了一些相对重要的更改，并建议你浏览以下规范文档和博客：[http://arjan-tijms.blogspot.com/2013_04_01_archive.html](http://arjan-tijms.blogspot.com/2013_04_01_archive.html)，它将为你提供更多信息。
- en: Integrating the authenticate, login, and logout methods called
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成调用的认证、登录和注销方法
- en: Since Version 3.0 of the Servlet, the authenticate, login, and logout methods
    have been added to the `HttpServletRequest` interface for managing the login and
    logout programmatically. However, the behavior of JASPIC modules after calling
    one of these three methods was not clearly established. It was left under the
    care of the server vendors to provide their own method of login and logout. The
    direct consequence is the non portability of applications between Java EE-compliant
    servers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 自Servlet 3.0版本以来，认证、登录和注销方法已添加到`HttpServletRequest`接口中，用于以编程方式管理登录和注销。然而，在调用这三个方法之一后，JASPIC模块的行为并没有明确确定。它留给了服务器供应商来提供他们自己的登录和注销方法。直接后果是Java
    EE兼容服务器之间应用程序的非可移植性。
- en: 'In the recent changes, Version 1.1 of JASPIC has clearly defined the expected
    behavior of JASPIC modules after calling one of these three methods. We now know
    that:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的变化中，JASPIC 1.1版本明确定义了在调用这三个方法之一后JASPIC模块的预期行为。我们现在知道：
- en: The container implementation of the `login` method must throw a `ServletException`
    when there is an incompatibility between the `login` method and the configured
    authentication mechanism.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`方法的容器实现必须在`login`方法和配置的认证机制之间存在不兼容性时抛出`ServletException`。'
- en: Note
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Here, the behavior of the module after calling the `login` method is not clearly
    defined.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，调用`login`方法后模块的行为没有明确定义。
- en: A call to the `authenticate` method must call the `validateRequest` method.
    This is true if the `authenticate` method is not called in the context of a call
    it made to `validateRequest`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`authenticate`方法的调用必须调用`validateRequest`方法。如果`authenticate`方法不是在调用`validateRequest`的环境中调用，则这是正确的。
- en: A call to the `logout` method must call the `cleanSubject` method. This is true
    if the `logout` method is not called in the context of a call it made to the `cleanSubject`
    method.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`logout`方法的调用必须调用`cleanSubject`方法。如果`logout`方法不是在调用`cleanSubject`方法的环境中调用，则这是正确的。
- en: Standardizing access to the application context identifier
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准化访问应用上下文标识符
- en: 'The application context identifier is an ID used to identify or select `AuthConfigProvider`
    and `ServerAuthConfig` objects for a given application (it is contained in the
    `appContext` parameter). Prior to JASPIC 1.1, there was no standard way to get
    it. As usual, each server vendor proposed a method that was vendor-specific. Now
    it is possible in standard with the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应用上下文标识符是一个用于识别或选择给定应用程序中的`AuthConfigProvider`和`ServerAuthConfig`对象的ID（它包含在`appContext`参数中）。在JASPIC
    1.1之前，没有标准的方式来获取它。通常，每个服务器供应商都提出了一个特定于供应商的方法。现在，使用以下代码可以在标准中实现：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Support for forward and include mechanisms
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持前进和包含机制
- en: 'The JASPIC 1.1 Specification has insisted on the fact that authentication modules
    must be able to forward and include during the processing of the `validateRequest`
    method. Concretely, this is possible by using `request` and `response` within
    the `MessageInfo` parameter type. The following code gives an overview of a redirection
    to an error page based on the results of a condition:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JASPIC 1.1规范强调，认证模块必须在处理`validateRequest`方法的过程中能够转发和包含。具体来说，这可以通过在`MessageInfo`参数类型中使用`request`和`response`来实现。以下代码概述了基于条件结果的重定向到错误页面的过程：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Having reached the end of this chapter, which is the last chapter of the book,
    we are now able to deploy a Java EE public solution with at least some level of
    security. Indeed, through this chapter, readers become aware of a specification
    allowing them to restrict access to the forms. However, it is important to note
    that we have just dealt with one small aspect of security, given the objectives
    of this book. We ask you to complete your knowledge about security with additional
    reading. This is because the domain is made up of several aspects such as the
    transmission of data across the network, method execution, construction, and execution
    of SQL queries.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在达到本书的最后一章，也就是本章的结尾时，我们现在能够部署一个至少具备一定安全级别的Java EE公共解决方案。实际上，通过本章，读者已经了解到一个允许他们限制表单访问的规范。然而，重要的是要注意，鉴于本书的目标，我们仅仅处理了安全性的一个很小方面。我们要求您通过额外的阅读来完善您对安全性的知识。这是因为该领域由多个方面组成，例如数据在网络中的传输、方法执行、构建和执行SQL查询。
