- en: Best Practices and Common Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践和通用原则
- en: After all the hard work put in by you toward gaining the experience of developing
    a microservice sample project, you must be wondering how to avoid common mistakes
    and improve the overall process of developing microservice-based products and
    services. We can follow these principles or guidelines to simplify the process
    of developing microservices and avoid/reduce the potential limitations. We will
    focus on these key concepts in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在你为了获得开发微服务样本项目的经验而付出了艰辛努力之后，你可能会想知道如何避免常见错误并改进开发基于微服务的产品和服务的过程。我们可以遵循这些原则或指南来简化微服务开发的过程并避免/减少潜在的限制。我们将在本章重点关注这些关键概念。
- en: 'This chapter is spread across the following three sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下三个部分：
- en: Overview and mindset
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述和心态
- en: Best practices and principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践和原则
- en: Microservice frameworks and tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务框架和工具
- en: Overview and mindset
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述和心态
- en: You can implement microservice-based design on both new and existing products
    and services. Contrary to the belief that it is easier to develop and design a
    new system from scratch rather than making changes to an existing one that is
    already live, each approach has its own respective challenges and advantages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在新旧产品和服务的背景下实现微服务-based设计。与认为从头开始开发和设计新系统比修改一个已经在运行的现有系统更容易的观点相反，每种方法都有其各自的挑战和优点。
- en: For example, since there is no existing system design for a new product or service,
    you have freedom and flexibility to design the system without giving any thought
    to its impact. However, you don't have the clarity on both functional and system
    requirements for a new system, as these mature and take shape over time. On the
    other hand, for mature products and services, you have detailed knowledge and
    information of the functional and system requirements. Nevertheless, you have
    a challenge to mitigate the risk of impact that design change brings to the table.
    Therefore, when it comes to updating a production system from monolithic to microservices,
    you will need to plan better than if you were building a system
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于新产品或服务不存在现有的系统设计，你有自由和灵活性去设计系统，而不必考虑其影响。然而，你对于新系统的功能和系统要求并不清晰，因为这些随着时间成熟并逐渐成形。另一方面，对于成熟的产品和服务，你对功能和系统要求有详细的知识和信息。然而，你有一个挑战，那就是减轻设计更改带来的风险影响。因此，当涉及到将生产系统从单体应用更新为微服务时，你需要比如果你正在构建一个系统时计划得更好。
- en: from scratch.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始。
- en: Experienced and successful software design experts and architects always evaluate
    the pros and cons and take a cautious approach to making any change to existing
    live systems. One should not make changes to existing live system design simply
    because it may be cool or trendy. Therefore, if you would like to update the design
    of your existing production system to microservices, you need to evaluate all
    the pros and cons before making this call.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的成功的软件设计专家和架构师总是评估利弊，并且对现有运行系统做任何更改时都持谨慎态度。绝不应该仅仅因为某种设计可能很酷或者时髦就对其进行更改。因此，如果你想将现有生产系统的设计更新为微服务，在做出这个决定之前你需要评估所有的利弊。
- en: I believe that monolithic systems provide a great platform to upgrade to a successful
    microservice-based design. Obviously, we are not discussing cost here. You have
    ample knowledge of the existing system and functionality, which enables you to
    divide the existing system and build microservices based on functionalities and
    how those would interact with each other. Also, if your monolithic product is
    already modularized in some way, then directly transforming microservices by exposing
    an API instead of an **Application Binary Interface** (**ABI**) is possibly the
    easiest way of achieving a microservice architecture. A successful microservice-based
    system is more dependent on microservices and their interaction protocol than
    anything else.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信单体系统提供一个很好的平台升级到成功的微服务设计。显然，我们这里不讨论成本。你对现有系统和功能有足够的了解，这使你能够将现有系统分割并基于功能以及这些如何相互交互构建微服务。另外，如果你的单体产品已经以某种方式模块化，那么通过暴露API而不是**应用程序二进制接口**（**ABI**）直接转换微服务可能是实现微服务架构的最简单方式。成功的基于微服务的系统更依赖于微服务和它们之间的交互协议，而不是其他任何东西。
- en: Having said that, it does not mean that you cannot have a successful microservice-based
    system if you are starting from scratch. However, it is recommended to start a
    new project based on monolithic design that gives you perspective and understanding
    of the system and functionality. It allows you to find bottlenecks quickly and
    guides you to identify any potential feature that can be developed using microservices.
    Here, we have not discussed the size of the project, which is another important
    factor. We'll discuss this in the next section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，并不意味着如果您从头开始，就不能拥有一个成功的基于微服务的系统。然而，建议基于单体设计的新项目，这为您提供了系统的视角和理解功能。它允许您快速找到瓶颈，并指导您识别任何可以用微服务开发的有潜力的特性。在这里，我们没有讨论项目的规模，这是另一个重要的因素。我们将在下一节中讨论这一点。
- en: In today's cloud age and agile development world, it takes an hour between making
    any change and the change going live. In today's competitive environment, every
    organization would like to have the edge for quickly delivering features to the
    user. Continuous development, integration, and deployment are part of the production
    delivery process, a completely automatic process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的云计算时代和敏捷开发世界中，从任何更改到更改上线通常只需要一个小时。在当今竞争激烈的环境中，每个组织都希望拥有快速将功能交付给用户的优势。持续开发、集成和部署是生产交付过程的一部分，这是一个完全自动化的过程。
- en: It makes more sense if you are offering cloud-based products or services. Then,
    a microservice-based system enables the team to respond with agility to fix any
    issue or provide a new feature to the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您提供基于云的产品或服务，那么基于微服务的系统使团队能够敏捷地响应修复任何问题或向用户提供新功能。
- en: Therefore, you need to evaluate all the pros and cons before you make a call
    for starting a new microservice-based project from scratch or planning to upgrade
    the design of an existing monolithic system to a microservice-based system. You
    have to listen to and understand the different ideas and perspectives shared across
    your team, and you need to take a cautious approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在决定从头开始一个新的基于微服务的项目，或者计划将现有单体系统的设计升级为基于微服务的系统之前，您需要评估所有的利弊。您必须倾听并理解团队分享的不同想法和观点，并采取谨慎的方法。
- en: Finally, I would like to share the importance of having better processes and
    an efficient system in place for a successful production system. Having a microservice-based
    system does not guarantee a successful production system, and a monolithic application
    does not mean you cannot have a successful production system in today's age. Netflix,
    a microservice-based cloud video rental service, and Etsy, a monolithic e-commerce
    platform, are both examples of successful live production systems (see an interesting
    Twitter discussion link in the *References* section later in the chapter). Therefore,
    processes and agility are also key to a successful production system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想分享拥有更好的流程和高效系统对于成功生产系统的重要性。拥有基于微服务的系统并不能保证成功的生产系统，而单体应用程序并不意味着在今天这个时代你不能拥有一个成功的生产系统。Netflix，一个基于微服务的云视频租赁服务，和Etsy，一个单体电子商务平台，都是成功生产系统的例子（在章节的*参考文献*部分，您可以看到一个有趣的Twitter讨论链接）。因此，流程和敏捷也是成功生产系统的关键。
- en: Best practices and principles
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践和原则
- en: As we have learned from the first chapter, microservices are a lightweight style
    of implementing **Service Oriented Architecture** (**SOA**). On top of that, microservices
    are not strictly defined, which gives you the flexibility of developing microservices
    the way you want and according to need. At the same time, you need to make sure
    that you follow a few of the standard practices and principles to make your job
    easier and implement microservice-based architecture successfully.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章所学习到的，微服务是一种实现**面向服务架构**（**SOA**）的轻量级风格。除此之外，微服务并没有严格定义，这给了你开发微服务的灵活性，按照你想要的和需求来开发。同时，你需要确保遵循一些标准实践和原则，使你的工作更容易，并成功实施基于微服务的架构。
- en: Nanoservice, size, and monolithic
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纳米服务、规模和单体
- en: Each microservice in your project should be small in size and perform one functionality
    or feature (for example, user management), independently enough to perform the
    function on its own.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您项目中的每个微服务都应该体积小，并执行一个功能或特性（例如，用户管理），独立到足以自行执行该功能。
- en: 'The following two quotes from Mike Gancarz (a member who designed the X Window
    system), which defines one of the paramount precepts of Unix philosophy, suits
    the microservice paradigm as well:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Mike Gancarz（设计X Window系统的成员）的以下两句话，定义了Unix哲学的一个首要原则，也适用于微服务范式：
- en: '"Small is beautiful."'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “小即是美。”
- en: '"Make each program do one thing well."'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “让每个程序做好一件事。”
- en: Now, how do we define the size, in today's age, when you have a framework (for
    example, Finangle) that reduces the **lines of code** (**LOC**)? In addition,
    many modern languages, such as Python and Erlang, are less verbose. This makes
    it difficult to decide whether you want to make this code microservice or not.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何定义在今天这个时代的大小，当你有一个框架（例如Finangle）来减少**代码行数**（**LOC**）时？此外，许多现代语言，如Python和Erlang，都较为简洁。这使得决定是否要将此代码微服务化变得困难。
- en: Apparently, you may implement a microservice for a small number of LOC; that
    is actually not a microservice but a nanoservice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可能为少量的代码行实现一个微服务；这实际上不是一个微服务，而是一个纳米服务。
- en: 'Arnon Rotem-Gal-Oz defined a nanoservice as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Arnon Rotem-Gal-Oz将纳米服务定义如下：
- en: '"Nanoservice is an antipattern where a service is too fine-grained. A nanoservice
    is a service whose overhead (communications, maintenance, and so on) outweighs
    its utility."'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “纳米服务是一个反模式，其中服务过于细粒度。纳米服务是一个其开销（通信、维护等）超过其效用的服务。”
- en: Therefore, it always makes sense to design microservices based on functionality.
    Domain-driven design makes it easier to define functionality at a domain level.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于功能设计微服务总是有意义的。领域驱动设计使在领域层面定义功能变得更容易。
- en: As discussed previously, the size of your project is a key factor when deciding
    whether to implement microservices or determining the number of microservices
    you want to have for your project. In a simple and small project, it makes sense
    to use monolithic architecture. For example, based on the domain design that we
    learned in [Chapter 3](8d3fd180-4f27-4bf7-bb86-c180ac200687.xhtml), *Domain-Driven
    Design*, you would get a clear understanding of your functional requirements and
    it makes facts available to draw the boundaries between various functionalities
    or features. For example, in the sample project (online table reservation system;
    OTRS) we have implemented, it is very easy to develop the same project using monolithic
    design, provided you don't want to expose the APIs to the customer, or you don't
    want to use it as SaaS, or there are plenty of similar parameters that you want
    to evaluate before making a call.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您项目的规模是在决定是否实施微服务或确定您想要为项目拥有的微服务数量时的一个关键因素。在一个简单的小型项目中，使用单体架构是有意义的。例如，基于我们在[第3章](8d3fd180-4f27-4bf7-bb86-c180ac200687.xhtml)学到的领域设计，*领域驱动设计*，你会清楚地了解你的功能性需求，并使事实可用以绘制各种功能或特性之间的边界。例如，在我们已经实施的示例项目（在线表格预订系统；OTRS）中，只要你不希望向客户暴露API，或者你不想将其作为SaaS使用，或者在你做出决定之前有许多类似的参数需要评估，使用单体设计开发相同的项目是非常容易的。
- en: You can migrate the monolithic project to a microservices design later, when
    the need arises. Therefore, it is important that you should develop the monolithic
    project in modular fashion and have the loose coupling at every level and layer,
    and ensure there are predefined contact points and boundaries between different
    functionalities and features. In addition, your data source, such as DB, should
    be designed accordingly. Even if you are not planning to migrate to a microservice-based
    system, it would make bug fixes and enhancement easier to implement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以稍后将在单体项目中迁移到微服务设计，当时机到来时。因此，重要的是您应该以模块化方式开发单体项目，并在每个层次和层面上实现松耦合，并确保不同功能和特性之间有预定义的接触点和边界。此外，您的数据源（如数据库）应相应地设计。即使您不打算将项目迁移到基于微服务的系统，这也将使故障修复和功能改进更容易实施。
- en: Paying attention to the previous points will mitigate any possible difficulties
    you may encounter when you migrate to microservices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关注前面的点将减轻您在迁移到微服务时可能遇到的任何可能的困难。
- en: Generally, large or complex projects should be developed using microservices-based
    architecture, due to the many advantages it provides, as discussed in previous
    chapters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大型或复杂的项目应该使用基于微服务的架构进行开发，因为它提供了许多优势，如前几章所讨论的。
- en: I even recommend developing your initial project as monolithic; once you gain
    a better understanding of project functionalities and project complexity, then
    you can migrate it to microservices. Ideally, a developed initial prototype should
    give you the functional boundaries that will enable you to make the right choice.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至建议将你的初始项目开发为单块应用；一旦你更好地理解了项目的功能和项目复杂性，然后你再将其迁移到微服务。理想情况下，一个开发好的初始原型应该为你提供功能边界，这将使你能够做出正确的选择。
- en: Continuous integration and deployment
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和部署
- en: You must have a continuous integration and deployment process in place. It gives
    you the edge to deliver changes faster and detect bugs early. Therefore, each
    service should have its own integration and deployment process. In addition, it
    must be automated. There are many tools available, such as Teamcity, Jenkins,
    and so on, that are used widely. It helps you to automate the build process—which
    catches build failure early, especially when you integrate your changes with the
    mainline (like either any release branch/tag or master branch).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须有一个持续集成和部署的过程。它让你能够更快地交付更改并尽早发现错误。因此，每个服务应该有自己的集成和部署过程。此外，它必须是自动化的。有许多工具可供选择，如Teamcity、Jenkins等，这些工具被广泛使用。它帮助你自动化构建过程——这可以尽早捕获构建失败，特别是当你将你的更改与主分支（如任何发布分支/标签或主分支）集成时。
- en: You can also integrate your tests with each automated integration and deployment
    process. **Integration testing** tests the interactions of different parts of
    the system, such as between two interfaces (API provider and consumer), or between
    different components, or modules in a system, such as between DAO and database,
    and so on. Integration testing is important as it tests the interfaces between
    the modules. Individual modules are first tested in isolation. Then, integration
    testing is performed to check the combined behavior and validate that requirements
    are implemented correctly. Therefore, in microservices, integration testing is
    a key tool to validate the APIs. We will cover more about this in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将你的测试集成到每个自动化集成和部署过程中。**集成测试**测试系统的不同部分之间的交互，如两个接口（API提供者和消费者）之间，或系统中的不同组件或模块之间，如DAO和数据库之间等。集成测试很重要，因为它测试模块之间的接口。首先，在孤立状态下测试单个模块。然后，执行集成测试以检查组合行为并验证需求是否正确实现。因此，在微服务中，集成测试是验证API的关键工具。我们将在下一节中详细介绍这一点。
- en: Finally, you can see the updated mainline changes on your CD (continuous deployment)
    machine where this process deploys the build.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在CD（持续部署）机器上看到主分支的最新更改，该过程在这里部署构建。
- en: 'The process does not end here: you can make a container, such as Docker, and
    hand it over to your WebOps team, or have a separate process that delivers to
    a configured location or deploys to a WebOps stage environment. From here, it
    could be deployed directly to your production system once approved by the designated
    authority.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程并不会到此结束：你可以创建一个容器，比如Docker，然后将其交给你的WebOps团队，或者有一个单独的过程，将其送到一个配置好的位置或者部署到WebOps阶段环境。从这里，一旦得到指定权限的批准，它就可以直接部署到你的生产系统。
- en: System/end-to-end test automation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统/端到端测试自动化
- en: Testing is a very important part of any product and service delivery. You do
    not want to deliver buggy applications to customers. Earlier, at the time when
    the waterfall model was popular, an organization used to take 1 to 6 months or
    more for the testing stage before delivering to the customer. In recent years,
    after the agile process became popular, more emphasis is given to automation.
    Similar to prior point testing, automation is also mandatory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何产品和服务的交付中的一个非常重要的部分。你不希望向客户交付有缺陷的应用程序。在过去，当瀑布模型流行时，一个组织在向客户交付之前，测试阶段通常需要1到6个月或更长时间。近年来，在敏捷过程变得流行之后，更加重视自动化。与先前的点测试类似，自动化也是强制性的。
- en: Whether you follow **test-driven development** (**TDD**) or not, we must have
    system or end-to-end test automation in place. It's very important to test your
    business scenarios and that is also the case with end-to-end testing that may
    start from your REST call to database checks, or from UI app to database checks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否遵循**测试驱动开发**（**TDD**），我们必须要有系统或端到端的自动化测试。测试你的业务场景非常重要，端到端测试也同样如此，它可能从你的REST调用开始，到数据库检查，或者从UI应用程序开始，到数据库检查。
- en: Also, it is important to test your APIs if you have public APIs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有公开的API，测试你的API也很重要。
- en: Doing this makes sure that any change does not break any of the functionality
    and ensures seamless, bug-free production delivery. As discussed in the last section,
    each module is tested in isolation using unit testing to check everything is working
    as expected, then integration testing is performed between different modules to
    check the expected combined behavior and validate the requirements, whether implemented
    correctly or not. After integration tests, functional tests are executed that
    validate the functional and feature requirements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以确保任何更改都不会破坏任何功能，并确保无缝、无bug的生产交付。如上节所述，每个模块都通过单元测试进行隔离测试，以检查一切是否按预期工作，然后在不同模块之间执行集成测试，以检查预期的组合行为并验证需求是否正确实现。集成测试后，执行功能测试，以验证功能和特性需求。
- en: So, if unit testing makes sure individual modules are working fine in isolation,
    integration testing makes sure that interaction among different modules works
    as expected. If unit tests are working fine, it implies that the chances of integration
    test failure is greatly reduced. Similarly, integration testing ensures that functional
    testing is likely to be successful.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果单元测试确保孤立状态下单个模块运行良好，那么集成测试确保不同模块之间的交互按预期工作。如果单元测试正常工作，那么集成测试失败的概率大大降低。同样，集成测试确保功能测试很可能成功。
- en: It is presumed that one always keeps all types of tests updated, whether these
    are unit-level tests or end-to-end test scenarios.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们总是保持所有类型的测试更新，无论是单元级测试还是端到端的测试场景。
- en: Self-monitoring and logging
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我监控和日志记录
- en: A microservice should provide service information about itself and the state
    of the various resources it depends on. Service information represents statistics
    such as the average, minimum, and maximum time to process a request, the number
    of successful and failed requests, being able to track a request, memory usage,
    and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微服务应当提供关于自身及其所依赖的各种资源状态的服务信息。服务信息包括诸如处理请求的平均、最小和最大时间、成功和失败的请求数量、能够追踪请求、内存使用情况等统计数据。
- en: 'Adrian Cockcroft highlighted a few practices which are very important for monitoring
    microservices at Glue Conference (Glue Con) 2015\. Most of them are valid for
    any monitoring system:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年的Glue Conference（Glue Con）上，Adrian Cockcroft强调了几个对于监控微服务非常重要的实践。其中大多数对于任何监控系统都是有效的：
- en: Spend more time working on code that analyzes the meaning of metrics than code
    that collects, moves, stores, and displays metrics. This helps to not only increase
    the productivity, but also provide important parameters to fine-tune the microservices
    and increase the system efficiency. The idea is to develop more analysis tools
    rather than developing more monitoring tools.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分析指标意义的代码上花费更多时间，而不是在收集、移动、存储和显示指标的代码上。这不仅有助于提高生产力，还提供重要的参数来微调微服务并提高系统效率。想法是开发更多的分析工具，而不是开发更多的监控工具。
- en: The metric to display latency needs to be less than the human attention span.
    That means less than 10 seconds, according to Adrian.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示延迟的指标需要小于人类的注意力跨度。这意味着根据Adrian的说法，小于10秒。
- en: Validate that your measurement system has enough accuracy and precision. Collect
    histograms of response time.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证您的测量系统具有足够的准确性和精度。收集响应时间的直方图。
- en: Accurate data makes decision-making faster and allows you to fine-tune untill
    you reach precision level. He also suggests that the best graph to show the response
    time is a histogram.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准确的数据使决策更快，并允许您进行微调，直到达到精确度级别。他还建议，最好显示响应时间的图表是直方图。
- en: Monitoring systems need to be more available and scalable than the systems being
    monitored.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控系统需要比被监控的系统更具可用性和可扩展性。
- en: 'The statement says it all: you cannot rely on a system which itself is not
    stable or available 24/7.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个说法说明了一切：你不能依赖一个本身不稳定或不是24/7可用的系统。
- en: Optimize for distributed, ephemeral, cloud-native, containerized microservices.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对分布式、短暂、云原生、容器化的微服务进行优化。
- en: Fit metrics to models to understand relationships.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将指标适合模型以理解关系。
- en: Monitoring is a key component of microservice architecture. You may have a dozen
    to thousands of microservices (true for a big enterprise's large project) based
    on project size. Even for scaling and high availability, organizations create
    a clustered or load balanced pool/pod for each microservice, even separate pools
    for each microservice based on versions. Ultimately, it increases the number of
    resources you need to monitor, including each microservice instance. In addition,
    it is important that you have a process in place so that whenever something goes
    wrong, you know it immediately, or better, receive a warning notification in advance
    before something goes wrong. Therefore, effective and efficient monitoring is
    crucial for building and using the microservice architecture. Netflix uses security
    monitoring using tools such as Netflix Atlas (real-time operational monitoring
    which processes 1.2 billion metrics), Security Monkey (for monitoring security
    on AWS-based environments), Scumblr (intelligence-gathering tool) and FIDO (for
    analyzing events and automated incident reporting).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 监控是微服务架构的关键组成部分。根据项目规模，你可能会有几十个到几千个微服务（对于一个大企业的重大项目来说确实如此）。即使是为了扩展和高可用性，组织也会为每个微服务创建一个集群或负载均衡的池/容器，甚至根据版本为每个微服务创建单独的池。最终，这增加了你需要监控的资源数量，包括每个微服务实例。此外，重要的是你有一个流程，以便在任何事情出错时立即知道，或者更好的是，在事情出错之前收到警告通知。因此，构建和使用微服务架构的有效和高效的监控至关重要。Netflix使用诸如Netflix
    Atlas（处理12亿个指标的实时运营监控）、Security Monkey（用于监控基于AWS环境的网络安全）、Scumblr（情报收集工具）和FIDO（用于分析事件和自动事件报告）等工具进行安全监控。
- en: Logging is another important aspect for microservices that should not be ignored.
    Having effective logging makes all the difference. As there could be 10 or more
    microservices, managing logging is a huge task.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是微服务中不应忽视的重要方面。有效的日志记录至关重要。由于可能有10个或更多的微服务，管理日志记录是一项巨大的任务。
- en: For our sample project, we have used **Mapped Diagnostic Context** (**MDC**)
    logging, which is sufficient, in a way, for individual microservice logging. However,
    we also need logging for an entire system, or central logging. We also need aggregated
    statistics of logs. There are tools that do the job, such as Loggly or Logspout.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例项目，我们使用了**映射诊断上下文**（**MDC**）日志记录，这在某种程度上足以满足单个微服务的日志记录。然而，我们还需要整个系统或集中日志记录的日志记录。我们还需要日志的聚合统计数据。有一些工具可以完成这项工作，例如Loggly或Logspout。
- en: A request and generated correlated events gives you an overall view of the request.
    For tracing of any event and request, it is important to associate the event and
    request with service ID and request ID respectively. You can also associate the
    content of the event, such as message, severity, class name, and so on, to service
    ID.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和生成的相关事件为您提供了请求的整体视图。对于任何事件和请求的跟踪，将事件和请求与服务ID和请求ID分别关联非常重要。你还可以将事件的内容，如消息、严重性、类名等，与服务ID相关联。
- en: A separate data store for each microservice
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个微服务单独的数据存储
- en: If you remember, the most important characteristics of microservices you can
    find out about is the way microservices run in isolation from other microservices,
    most commonly as standalone applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，微服务最重要的特征之一是你可以了解微服务如何与其他微服务隔离运行，最常见的是作为独立的应用程序。
- en: Abiding by this rule, it is recommended that you do not use the same database,
    or any other data store across multiple microservices. In large projects, you
    may have different teams working on the same project, and you want the flexibility
    to choose the database for each microservice that best suits the microservice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这一规则，建议你不要在多个微服务之间使用相同的数据库或任何其他数据存储。在大型项目中，你可能有不同的团队在同一个项目中工作，你希望每个微服务都能选择最适合自己的数据库。
- en: Now, this also brings some challenges.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这也带来了一些挑战。
- en: For instance, the following is relevant to teams who may be working on different
    microservices within the same project, if that project shares the same database
    structure. There is a possibility that a change in one microservice may impact
    the other microservice models. In such cases, change in one may affect the dependent
    microservice, so you also need to change the dependent model structure.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下内容与可能在同一项目中工作在不同微服务上的团队相关，如果该项目共享相同的数据库结构。一种可能性是，一个微服务的更改可能会影响另一个微服务的模型。在这种情况下，一个更改可能会影响依赖性微服务，所以你还需要更改依赖性模型结构。
- en: To resolve this issue, microservices should be developed based on an API-driven
    platform. Each microservice would expose its APIs, which could be consumed by
    the other microservices. Therefore, you also need to develop the APIs, which is
    required for the integration of different microservices.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，微服务应该基于一个API驱动的平台进行开发。每个微服务都会暴露出自己的API，其他微服务可以消费这些API。因此，你还需要开发API，这是不同微服务集成的必要条件。
- en: Similarly, due to different data stores, actual project data is also spread
    across multiple data stores and it makes data management more complicated, because
    the separate storage systems can more easily get out of sync or become inconsistent,
    and foreign keys can change unexpectedly. To resolve such an issue, you need to
    use **master data management** (**MDM**) tools. MDM tools operate in the background
    and fix inconsistencies if they find any. For the OTRS sample example, it might
    check every database that stores booking request IDs, to verify that the same
    IDs exist in all of them (in other words, that there aren't any missing or extra
    IDs in any one database). MDM tools available in the market include Informatica,
    IBM MDM Advance Edition, Oracle Siebel UCM, Postgres (master streaming replication),
    mariadb (master/master configuration), and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于不同的数据存储，实际项目数据也分布在多个数据存储中，这使得数据管理更加复杂，因为不同的存储系统更容易失去同步或变得不一致，外键也可能意外地改变。为了解决这个问题，你需要使用**主数据管理**（**MDM**）工具。MDM工具在后台运行，如果发现任何不一致性，会进行修复。对于OTRS示例，它可能会检查存储预订请求ID的每个数据库，以验证它们中都存在相同的ID（换句话说，任何数据库中都没有缺失或额外的ID）。市场上的MDM工具包括Informatica、IBM
    MDM高级版、Oracle Siebel UCM、Postgres（主流复制）、mariadb（主/主配置）等。
- en: If none of the existing products suits your requirements, or you are not interested
    in any proprietary product, then you can write your own. Presently, API-driven
    development and platforms reduce such complexities; therefore, it is important
    that microservices should be developed along with an API platform.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现有的产品都不符合你的要求，或者你对任何专有产品都不感兴趣，那么你可以自己编写。目前，API驱动的开发和平台减少了这种复杂性；因此，微服务沿着API平台开发是非常重要的。
- en: Transaction boundaries
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交易边界
- en: We went through domain-driven design concepts in [Chapter 3](8d3fd180-4f27-4bf7-bb86-c180ac200687.xhtml),
    *Domain-Driven Design*. Please review this if you have not grasped it thoroughly,
    as it gives you an understanding of the state vertically. Since we are focusing
    on microservice-based design, the result is that we have a system of systems,
    where each microservice represents a system. In this environment, finding the
    state of a whole system at any given point in time is very challenging. If you
    are familiar with distributed applications, then you may be comfortable in such
    an environment, with respect to state.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](8d3fd180-4f27-4bf7-bb86-c180ac200687.xhtml)中讨论了领域驱动设计概念，*领域驱动设计*。如果你没有完全掌握它，请复习这一部分，因为它能让你从垂直角度理解状态。由于我们关注的是基于微服务的设计，结果是我们有一个系统系统，每个微服务代表一个系统。在这种环境中，在任何给定时间找到整个系统的状态是非常具有挑战性的。如果你熟悉分布式应用，那么你可能会在这种环境中对状态感到舒适。
- en: It is very important to have transaction boundaries in place that describe which
    microservice owns a message at any given time. You need a way or process that
    can participate in transactions, transacted routes, and error handlers, idempotent
    consumers, and compensating actions. It is not an easy task to ensure transactional
    behavior across heterogeneous systems, but there are tools available that do the
    job for you.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 确立交易边界非常重要，这些边界描述了在任何给定时间哪个微服务拥有一个消息。你需要一种或一种参与事务、交易路由、错误处理程序、幂等消费者和补偿操作的方式。确保跨异质系统的一致性行为并非易事，但市场上有一些工具可以为你完成这项工作。
- en: For example, Camel has great transactional capabilities that help developers
    easily create services with transactional behavior.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Camel具有出色的事务功能，可以帮助开发者轻松创建具有事务行为的服务。
- en: Microservices frameworks and tools
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务框架和工具
- en: It is always better not to reinvent the wheel. Therefore, we would like to explore
    what tools are already available and provide the platform, framework, and features
    that make microservice development and deployment easier.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最好还是不要重新发明轮子。因此，我们想探讨一下市场上已经有哪些工具，并提供使微服务开发和部署更简单的平台、框架和特性。
- en: 'Throughout the book, we have used Spring Cloud extensively, due to the same
    reason: it provides all of the tools and platforms required to make microservice
    development very easy. Spring Cloud uses Netflix **Open Source Software** (**OSS**).
    Let us explore Netflix OSS—a complete package.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个书籍中，我们广泛使用了 Spring Cloud，原因相同：它提供了构建微服务所需的所有工具和平台。Spring Cloud 使用 Netflix
    **开源软件**（**OSS**）。让我们来探索一下 Netflix OSS——一个完整的套餐。
- en: I have also added a brief overview about how each tool will help to build good
    microservice architecture.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了关于每个工具如何帮助构建良好的微服务架构的简要概述。
- en: Netflix Open Source Software (OSS)
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix 开源软件（OSS）
- en: Netflix OSS center is the most popular and widely used open source software
    for Java-based microservice open source projects. The world's most successful
    video renting service is dependent on it. Netflix has more than 40 million users
    and is used across the globe. Netflix is a pure cloud-based solution, developed
    on microservice-based architecture. You can say that whenever anybody talks about
    microservices, Netflix is the first name that comes to mind. Let us discuss the
    wide variety of tools it provides. We have already discussed many of them while
    developing the sample OTRS application. However, there are a few which we have
    not explored. Here, we'll cover only the overview of each tool, instead of going
    into detail. It will give you an overall idea of the practical characteristics
    of microservice architecture and its use in the cloud.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix OSS 中心是 Java 基础微服务开源项目中最受欢迎和广泛使用的开源软件。世界上最成功的视频租赁服务依赖于它。Netflix 有超过
    4000 万用户，并在全球范围内使用。Netflix 是一个纯基于云的解决方案，基于微服务架构开发。可以说，每当有人谈论微服务时，Netflix 是首先出现在脑海中的名字。让我们讨论它提供的各种工具。在开发示例
    OTRS 应用程序时，我们已经讨论了许多工具。然而，还有一些我们没有探索过。在这里，我们只对每个工具进行概述，而不是深入讨论。这将为您提供微服务架构的实用特性和在云中使用它的整体概念。
- en: Build - Nebula
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 - Nebula
- en: Netflix Nebula is a collection of Gradle plugins that makes your microservice
    builds easier using Gradle (a Maven-like build tool). For our sample project,
    we have made use of Maven, therefore we haven't had the opportunity to explore
    Nebula in this book. However, exploring it would be fun. The most significant
    Nebula feature for developers is eliminating the boilerplate code in Gradle build
    files, which allows developers to focus on coding.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Nebula 是一组使您使用 Gradle（类似 Maven 的构建工具）构建微服务变得更加容易的 Gradle 插件。对于我们的示例项目，我们使用了
    Maven，因此我们在这本书中没有机会探索 Nebula。然而，探索它是很有趣的。对于开发人员来说，Nebula 最重要的功能是消除了 Gradle 构建文件中的样板代码，这使得开发者可以专注于编码。
- en: Having a good build environment, especially CI/CD (continuous integration and
    continuous deployment) is a must for microservice development and keeping aligned
    with agile development. Netflix Nebula makes your build easier and more efficient.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个好的构建环境，特别是 CI/CD（持续集成和持续部署）对于微服务开发和与敏捷开发保持一致是必须的。Netflix Nebula 使您的构建变得更容易、更高效。
- en: Deployment and delivery - Spinnaker with Aminator
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和交付 - Spinnaker 与 Aminator
- en: Once your build is ready, you want to move that build to **Amazon Web Services**
    (**AWS**) EC2\. Aminator creates and packages images of builds in the form of
    **Amazon Machine Image** (**AMI**). Spinnaker then deploys these AMIs to AWS.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的构建准备好，您希望将该构建移动到 **亚马逊网络服务**（**AWS**）EC2。Aminator 创建并打包构建的镜像，形式为 **亚马逊机器镜像**（**AMI**）。Spinnaker
    然后将这些 AMI 部署到 AWS。
- en: Spinnaker is a continuous delivery platform for releasing code changes with
    high velocity and efficiency. Spinnaker also supports other cloud services, such
    as Google Computer Engine and Cloud Foundry.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker 是一个高速度和效率的持续交付平台，用于发布代码更改。Spinnaker 还支持其他云服务，例如 Google 计算机引擎和 Cloud
    Foundry。
- en: If you would like to deploy your latest microservice builds to cloud environments
    such as EC2, Spinnaker and Aminator help you to do that in an autonomous way.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将最新的微服务构建部署到例如 EC2 的云环境中，Spinnaker 和 Aminator 可以帮助你以自主的方式完成。
- en: Service registration and discovery - Eureka
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册和发现 - Eureka
- en: Eureka, as we have explored in this book, provides a service that is responsible
    for microservice registration and discovery. On top of that, Eureka is also used
    for load balancing the middle tier (processes hosting different microservices).
    Netflix also uses Eureka, along with other tools, such as Cassandra or memcached,
    to enhance its overall usability.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本书中所探讨的，Eureka 提供了一个负责微服务注册和发现的服务。除此之外，Eureka 还用于负载均衡中间层（托管不同微服务的进程）。Netflix
    也使用 Eureka，以及其他工具，如 Cassandra 或 memcached，以提高其整体可用性。
- en: Service registration and discovery is a must for microservice architecture.
    Eureka serves this purpose. Please refer to [Chapter 4](4561ba72-866e-45f9-88ac-761a62242e26.xhtml),
    *Implementing a Microservice*, for more information about Eureka.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构中必须要有服务注册与发现。Eureka 就是为此目的而设计的。请参阅[第4章](4561ba72-866e-45f9-88ac-761a62242e26.xhtml)，*实现微服务*，以获取有关
    Eureka 的更多信息。
- en: Service communication - Ribbon
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务通信 - Ribbon
- en: Microservice architecture is of no use if there is no interprocess or service
    communication. The Ribbon application provides this feature. Ribbon works with
    Eureka for load balancing and with Hystrix for fault tolerance or circuit breaker
    operations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程间或服务间没有通信，微服务架构就毫无用处。Ribbon 应用提供了这一特性。Ribbon 与 Eureka 一起实现负载均衡，与 Hystrix
    一起实现故障容忍或断路器操作。
- en: Ribbon also supports TCP and UDP protocols, apart from HTTP. It provides these
    protocol supports in both asynchronous and reactive models. It also provides the
    caching and batching capabilities.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Ribbon 还支持除了 HTTP 以外的 TCP 和 UDP 协议，并提供这些协议支持异步和响应式模型。它还提供了缓存和批量处理功能。
- en: Since you will have many microservices in your project, you need a way to process
    information using interprocess or service communication. Netflix provides the
    Ribbon tool for this purpose.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您将在项目中拥有许多微服务，您需要一种使用进程间或服务间通信处理信息的方法。Netflix 为这一目的提供了 Ribbon 工具。
- en: Circuit breaker - Hystrix
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器 - Hystrix
- en: Hystrix tool is for circuit breaker operations, that is, latency and fault tolerance.
    Therefore, Hystrix stops cascading failures. Hystrix performs the real-time operations
    for monitoring the services and property changes, and supports concurrency.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix 工具用于断路器操作，即延迟和故障容忍。因此，Hystrix 阻止级联失败。Hystrix 执行实时操作，监控服务和属性变化，并支持并发。
- en: Circuit breaker, or fault tolerance, is an important concept for any project,
    including microservices. Failure of one microservice should not halt your entire
    system; to prevent this, and provide meaningful information to the customer on
    failure, is the job of Netflix Hystrix.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器或故障容忍是任何项目的重要概念，包括微服务。一个微服务的失败不应该使您的整个系统停止；为了防止这种情况发生，并在失败时向客户提供有意义的信息，这是
    Netflix Hystrix 的职责。
- en: Edge (proxy) server - Zuul
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘（代理）服务器 - Zuul
- en: Zuul is an edge server or proxy server, and serves the requests of external
    applications such as UI client, Android/iOS application, or any third-party consumer
    of APIs offered by the product or service. Conceptually, it is a door to external
    applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul 是一个边缘服务器或代理服务器，为 UI 客户端、Android/iOS 应用程序或任何第三方消费者提供 API。从概念上讲，它是外部应用程序的门户。
- en: Zuul allows dynamic routing and monitoring of requests. It also performs security
    operations such as authentication. It can identify authentication requirements
    for each resource and reject any request that does not satisfy them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul 允许动态路由和监控请求。它还执行安全操作，如身份验证。它可以识别每个资源的身份验证要求，并拒绝任何不满足它们的请求。
- en: You need an edge server or API gateway for your microservices. Netflix Zuul
    provides this feature. Please refer to [Chapter 5](b1f93b4e-3475-4d8a-8c9f-697b0fd4410c.xhtml),
    *Deployment and Testing,* for more information.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个边缘服务器或API网关来处理您的微服务。Netflix Zuul 提供了这一特性。请参阅[第5章](b1f93b4e-3475-4d8a-8c9f-697b0fd4410c.xhtml)，*部署与测试*，以获取更多信息。
- en: Operational monitoring - Atlas
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作监控 - Atlas
- en: Atlas is an operational monitoring tool that provides near-real-time information
    on dimensional time-series data. It captures operational intelligence that provides
    a picture of what is currently happening within a system. It features in-memory
    data storage, allowing it to gather and report very large numbers of metrics very
    quickly. At present, it processes 1.3 billion metrics for Netflix.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Atlas 是一个操作监控工具，提供近实时的时间序列数据维度信息。它捕获操作智能，提供系统内部当前发生情况的图片。它具有内存数据存储功能，允许它快速收集和报告大量指标。目前，它为
    Netflix 处理了13亿个指标。
- en: Atlas is a scalable tool. This is why it can now process 1.3 billion metrics,
    from 1 million metrics a few years back. Atlas not only provides scalability in
    terms of reading the data, but also aggregating it as a part of graph request.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Atlas 是一个可扩展的工具。这就是为什么它现在可以处理 13 亿个指标，而几年前只有 100 万个指标。Atlas 不仅在读取数据方面提供可扩展性，而且在作为图表请求一部分进行聚合方面也提供可扩展性。
- en: Atlas uses the Netflix Spectator library for recording dimensional time-series
    data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Atlas 使用了 Netflix Spectator 库来记录维度时间序列数据。
- en: Once you deploy microservices in a cloud environment, you need to have a monitoring
    system in place to track and monitor all microservices. Netflix Atlas does this
    job for you.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在云环境中部署了微服务，你就需要有一个监控系统来跟踪和监控所有的微服务。Netflix Atlas 为你完成了这项工作。
- en: Reliability monitoring service - Simian Army
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性监控服务 - Simian Army
- en: In Cloud, no single component can guarantee 100% uptime. Therefore, it is a
    requirement for successful microservice architecture to make the entire system
    available in case a single cloud component fails. Netflix has developed a tool
    named Simian Army to avoid system failure. Simian Army keeps a cloud environment
    safe, secure, and highly available. To achieve high availability and security,
    it uses various services (Monkeys) in the cloud for generating various kinds of
    failures, detecting abnormal conditions, and testing the cloud's ability to survive
    these challenges.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，没有任何单一组件能保证 100% 的正常运行时间。因此，成功的微服务架构的要求是在一个云组件失败的情况下使整个系统可用。Netflix 开发了一个名为
    Simian Army 的工具来避免系统失败。Simian Army 保持了云环境的安全、安全和高可用性。为了实现高可用性和安全性，它使用了各种服务（猴子）在云中产生各种故障、检测异常情况，并测试云应对这些挑战的能力。
- en: 'It uses the following services (Monkeys), which are taken from the Netflix
    blog:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了以下服务（猴子），这些服务来自 Netflix 的博客：
- en: '**Chaos Monkey**: Chaos Monkey is a service which identifies groups of systems
    and randomly terminates one of the systems in a group. The service operates at
    a controlled time and interval. Chaos Monkey only runs in business hours with
    the intent that engineers will be alert and able to respond.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chaos Monkey**：Chaos Monkey 是一个服务，它识别出一组系统，并在一组中的一个系统随机终止。该服务在受控的时间和间隔内运行。Chaos
    Monkey 只在正常工作时间运行，目的是让工程师保持警觉并能够响应。'
- en: '**Janitor Monkey**: Janitor Monkey is a service which runs in the AWS cloud
    looking for unused resources to clean up. It can be extended to work with other
    cloud providers and cloud resources. The schedule of service is configurable.
    Janitor Monkey determines whether a resource should be a cleanup candidate, by
    applying a set of rules on it. If any of the rules determines that the resource
    is a cleanup candidate, Janitor Monkey marks the resource and schedules a time
    to clean it up. For exceptional cases, when you want to keep an unused resource
    longer, before Janitor Monkey deletes a resource, the owner of the resource will
    receive a notification a configurable number of days ahead of the cleanup time.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Janitor Monkey**：Janitor Monkey 是一个在 AWS 云中运行的服务，寻找未使用的资源进行清理。它可以扩展到与其他云提供商和云资源一起工作。服务的日程是可配置的。Janitor
    Monkey 通过对其应用一组规则来确定资源是否应该成为清理候选资源。如果任何规则确定资源是清理候选资源，Janitor Monkey 将标记该资源，并安排一个时间进行清理。在特殊情况下，在
    Janitor Monkey 删除资源之前，你想保留一个未使用的资源更长时间，资源所有者会在清理时间前 configurable 天收到通知。'
- en: '**Conformity Monkey**: Conformity Monkey is a service which runs in the AWS
    cloud looking for instances that are not conforming to predefined rules for the
    best practices. It can be extended to work with other cloud providers and cloud
    resources. The schedule of service is configurable. If any of the rules determines
    that the instance is not conforming, the monkey sends an email notification to
    the owner of the instance. There could be exceptional cases where you want to
    ignore warnings of a specific conformity rule for some applications.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Conformity Monkey**：Conformity Monkey 是一个在 AWS 云中运行的服务，寻找不符合最佳实践预定义规则的实例。它可以扩展到与其他云提供商和云资源一起工作。服务的日程是可配置的。如果任何规则确定该实例不符合，猴子会向实例所有者发送电子邮件通知。在某些特殊情况下，你可能想忽略特定的一致性规则的警告。'
- en: '**Security Monkey**: Security Monkey monitors policy changes and alerts on
    insecure configurations in an AWS account. The main purpose of Security Monkey
    is security, though it also proves a useful tool for tracking down potential problems,
    as it is essentially a change-tracking system.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全猴**：安全猴监控 AWS 账户中的策略更改和对不安全配置的警报。安全猴的主要目的是安全，尽管它也是一个跟踪潜在问题的有用工具，因为它本质上是一个变更跟踪系统。'
- en: Successful microservice architecture makes sure that your system is always up,
    and failure of a single cloud component should not fail the entire system. Simian
    Army uses many services to achieve high availability.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的微服务架构确保你的系统始终运行，单个云组件的故障不应该导致整个系统失败。Simian Army 使用许多服务来实现高可用性。
- en: AWS resource monitoring - Edda
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS 资源监控 - Edda
- en: In a cloud environment, nothing is static. For example, virtual host instances
    change frequently, an IP address could be reused by various applications, or a
    firewall or related changes may take place.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，一切都是动态的。例如，虚拟主机实例经常变化，IP 地址可能被各种应用程序重复使用，或者发生防火墙等相关变化。
- en: Edda is a service that keeps track of these dynamic AWS resources. Netflix named
    it Edda (meaning *a tale of Norse mythology*), as it records the tales of cloud
    management and deployments. Edda uses the AWS APIs to poll AWS resources and records
    the results. These records allow you to search and see how the cloud has changed
    over time. For instance, if any host of the API server is causing any issue, then
    you need to find out what that host is and which team is responsible for it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Edda 是一个跟踪这些动态 AWS 资源的服务的服务。Netflix 将其命名为 Edda（意为*北欧神话传说*），因为它记录了云管理和部署的传说。Edda
    使用 AWS API 轮询 AWS 资源并记录结果。这些记录允许你搜索并查看云如何随时间变化。例如，如果 API 服务器的任何主机出现问题，那么你需要找出那个主机是哪个团队负责的。
- en: 'These are the features it offers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供以下功能：
- en: '**Dynamic querying**: Edda provides the REST APIs, and it supports the matrix
    arguments and provides fields selectors that let you retrieve only the desired
    data.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态查询**：Edda 提供了 REST API，并支持矩阵参数，提供字段选择器，让你只检索所需的数据。'
- en: '**History**/c**hanges**: Edda maintains the history of all AWS resources. This
    information helps you when you analyze the causes and impact of outage. Edda can
    also provide the different view of current and historical information about resources.
    It stores the information in MongoDB at the time of writing.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史**/变更：Edda 维护了所有 AWS 资源的历史记录。这些信息有助于分析停机的原因和影响。Edda 还可以提供关于资源当前和历史信息的不同的视图。在撰写本文时，它将信息存储在
    MongoDB 中。'
- en: '**Configuration**: Edda supports many configuration options. In general, you
    can poll information from multiple accounts and multiple regions and can use the
    combination of account and regions that account points. Similarly, it provides
    different configurations for AWS, Crawler, Elector, and MongoDB.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：Edda 支持许多配置选项。通常，你可以从多个账户和多个区域轮询信息，并可以使用账户和区域的组合来指定位点。同样，它为 AWS、Crawler、Elector
    和 MongoDB 提供不同的配置。'
- en: If you are using the AWS for hosting your microservice-based product, then Edda
    serves the purpose of monitoring the AWS resources.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 AWS 来托管基于微服务的产品，那么 Edda 起到了监控 AWS 资源的作用。
- en: On-host performance monitoring - Vector
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机上性能监控 - Vector
- en: Vector is a static web application and runs inside a web browser. It allows
    it to monitor the performance of those hosts where **Performance Co-Pilot** (**PCP**)
    is installed. Vector supports PCP version 3.10+. PCP collects metrics and makes
    them available to Vector.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Vector 是一个静态的网页应用程序，在网页浏览器内运行。它允许监控安装了**性能共乘**（**PCP**）的主机的表现。Vector 支持 PCP
    3.10+ 版本。PCP 收集指标并将其提供给 Vector。
- en: It provides high-resolution right metrics available on demand. This helps engineers
    to understand how a system behaves and correctly troubleshoot performance issues.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供高分辨率的即时指标。这有助于工程师了解系统如何表现，并正确诊断性能问题。
- en: Vector is a monitoring tool that helps you to monitor the performance of a remote
    host.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Vector 是一个帮助你监控远程主机性能的工具。
- en: Distributed configuration management - Archaius
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式配置管理 - Archaius
- en: 'Archaius is a distributed configuration management tool that allows you to
    do the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Archaius 是一个分布式配置管理工具，它允许你执行以下操作：
- en: Use dynamic and typed properties.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态和类型化的属性。
- en: Perform thread-safe configuration operations.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行线程安全的配置操作。
- en: Check for property changes using a polling framework.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用轮询框架检查属性变更。
- en: Use a callback mechanism in an ordered hierarchy of configurations.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置的有序层次结构中使用回调机制。
- en: Inspect and perform operations on properties using JConsole, as Archaius provides
    the JMX MBean.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JConsole检查并操作属性，因为Archaius提供了JMX MBean。
- en: A good configuration management tool is required when you have a microservice-based
    product. Archaius helps to configure different types of properties in a distributed
    environment.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您有一个基于微服务的产品时，需要一个好的配置管理工具。Archaius帮助在分布式环境中配置不同类型的属性。
- en: Scheduler for Apache Mesos - Fenzo
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Mesos调度器 - Fenzo
- en: 'Fenzo is a scheduler library for Apache Mesos frameworks written in Java. Apache
    Mesos frameworks match and assign resources to pending tasks. The following are
    its key features:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Fenzo是Apache Mesos框架的Java编写的调度库。Apache Mesos框架匹配并分配资源给待处理任务。以下是其关键特性：
- en: It supports long-running service style tasks and for batch
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持长期运行的服务风格任务和批量任务。
- en: It can auto-scale the execution host cluster, based on resource demands
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以自动扩展执行主机集群，基于资源需求。
- en: It supports plugins that you can create based on requirements
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持插件，您可以根据需求创建。
- en: You can monitor resource-allocation failures, which allows you to debug the
    root cause
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以监控资源分配失败，这使您能够调试根本原因。
- en: Cost and cloud utilization - Ice
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成本和云利用率 - Ice
- en: Ice provides a bird's-eye view of cloud resources from a cost and usage perspective.
    It provides the latest information about provisioned cloud resource allocation
    to different teams that adds value for optimal utilization of the cloud resources.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Ice从成本和使用角度提供了云资源的鸟瞰视图。它提供了关于为不同团队提供的最新云资源配置信息，这对于优化云资源的使用非常有价值。
- en: Ice is a grail project. Users interact with the Ice UI component that displays
    the information sent via the Ice reader component. The reader fetches information
    from the data generated by the Ice processor component. The Ice processor component
    reads data information from a detailed cloud billing file and converts it into
    data that is readable by the Ice reader component.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Ice 是一个grail项目。用户与Ice UI组件交互，该组件显示通过Ice reader组件发送的信息。reader从由Ice processor组件生成的数据中获取信息。Ice
    processor组件从详细的云账单文件中读取数据信息，并将其转换为Ice reader组件可读取的数据。
- en: Other security tools - Scumblr and FIDO
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他安全工具 - Scumblr和FIDO
- en: Along with Security Monkey, Netflix OSS also makes use of Scumblr and **Fully
    Integrated Defense** **Operation** (**FIDO**) tools.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与Security Monkey一起，Netflix OSS还利用了Scumblr和完全集成的防御操作（FIDO）工具。
- en: To keep track of and protect your microservices from regular threats and attacks,
    you need an automated way to secure and monitor your microservices. Netflix Scumblr
    and FIDO do this job for you.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪并保护您的微服务免受常规威胁和攻击，您需要一种自动化的方式来确保并监控您的微服务。Netflix Scumblr和FIDO为您完成这项工作。
- en: Scumblr
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scumblr
- en: Scumblr is a Ruby on Rails based web application that allows you to perform
    periodic searches and store/take action on the identified results. Basically,
    it gathers intelligence that leverages internet-wide targeted searches to surface
    specific security issues for investigation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Scumblr是一个基于Ruby on Rails的Web应用程序，允许您执行定期搜索，并针对识别的结果存储/采取行动。基本上，它收集情报，利用互联网范围内的针对性搜索浮出具体的安全问题以供调查。
- en: 'Scumblr makes use of the Workflowable gem to allow flexible workflows to be
    set up for different types of results. Scumblr searches utilize plugins called
    **Search Providers**. It checks anomalies such as the following. Since it is extensible,
    you can add as many as you want:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Scumblr利用Workflowable宝石允许为不同类型的结果设置灵活的工作流程。Scumblr搜索使用称为“搜索提供者”的插件。它检查异常，例如以下异常。由于它是可扩展的，您可以添加尽可能多的异常：
- en: Compromised credentials
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 妥协的凭据
- en: Vulnerability/hacking discussion
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漏洞/黑客讨论
- en: Attack discussion
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击讨论
- en: Security-relevant social media discussion
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与安全相关的社交媒体讨论
- en: Fully Integrated Defence Operation (FIDO)
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全集成的防御操作（FIDO）
- en: FIDO is a security orchestration framework for analyzing events and automating
    incident responses. It automates the incident response process by evaluating,
    assessing, and responding to malware. FIDO's primary purpose is to handle the
    heavy manual effort needed to evaluate threats coming from today's security stack
    and the large number of alerts generated by them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: FIDO是一个安全编排框架，用于分析事件和自动化事件响应。它通过评估、评估和响应恶意软件来自动化事件响应过程。FIDO的主要目的是处理评估当今安全堆栈中威胁和它们生成的大量警报所需的大量手动工作。
- en: 'As an orchestration platform, FIDO can make using your existing security tools
    more efficient and accurate by heavily reducing the manual effort needed to detect,
    notify, and respond to attacks against a network. For more information, you can
    refer to the following links:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个编排平台，FIDO可以通过大幅减少检测、通知和响应网络攻击所需的手动努力，使您现有的安全工具更高效、更准确地使用。有关更多信息，您可以参考以下链接：
- en: '[https://github.com/Netflix/Fido](https://github.com/Netflix/Fido)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Netflix/Fido](https://github.com/Netflix/Fido)'
- en: '[https://github.com/Netflix](https://github.com/Netflix)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Netflix](https://github.com/Netflix)'
- en: References
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Monolithic (Etsy) versus Microservices (Netflix) Twitter discussion: [https://twitter.com/adrianco/status/441169921863860225](https://twitter.com/adrianco/status/441169921863860225)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单片式（Etsy）与微服务（Netflix）的Twitter讨论：[https://twitter.com/adrianco/status/441169921863860225](https://twitter.com/adrianco/status/441169921863860225)
- en: '*Monitoring Microservice and Containers Presentation* by Adrian Cockcroft:
    [http://www.slideshare.net/adriancockcroft/gluecon-monitoring-microservices-and-containers-a-challenge](http://www.slideshare.net/adriancockcroft/gluecon-monitoring-microservices-and-containers-a-challenge)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Adrian Cockcroft所做的《监控微服务和容器》演讲：[http://www.slideshare.net/adriancockcroft/gluecon-monitoring-microservices-and-containers-a-challenge](http://www.slideshare.net/adriancockcroft/gluecon-monitoring-microservices-and-containers-a-challenge)
- en: 'Nanoservice Antipattern: [http://arnon.me/2014/03/services-microservices-nanoservices/](http://arnon.me/2014/03/services-microservices-nanoservices/%20)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纳米服务反模式：[http://arnon.me/2014/03/services-microservices-nanoservices/](http://arnon.me/2014/03/services-microservices-nanoservices/)
- en: 'Apache Camel for Micro­service Architectures: [https://www.javacodegeeks.com/2014/09/apache-camel-for-micro%C2%ADservice-architectures.html](https://www.javacodegeeks.com/2014/09/apache-camel-for-micro%C2%ADservice-architectures.html)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Camel用于微服务架构：[https://www.javacodegeeks.com/2014/09/apache-camel-for-micro%C2%ADservice-architectures.html](https://www.javacodegeeks.com/2014/09/apache-camel-for-micro%C2%ADservice-architectures.html)
- en: 'Teamcity: [https://www.jetbrains.com/teamcity/](https://www.jetbrains.com/teamcity/)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Teamcity: [https://www.jetbrains.com/teamcity/](https://www.jetbrains.com/teamcity/)'
- en: 'Jenkins: [https://jenkins-ci.org/](https://jenkins-ci.org/)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jenkins: [https://jenkins-ci.org/](https://jenkins-ci.org/)'
- en: 'Loggly: [https://www.loggly.com/](https://www.loggly.com/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Loggly: [https://www.loggly.com/](https://www.loggly.com/)'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored various practices and principles which are
    best-suited for microservice-based products and services. Microservice architecture
    is a result of cloud environments, which are being used widely in comparison to
    on-premises-based monolithic systems. We have identified a few of the principles
    related to size, agility, and testing, that have to be in place for successful
    implementation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了各种最适合微服务基础产品和服务最佳实践和原则。微服务架构是云环境的结果，与基于本地的大型单片系统相比，其应用越来越广泛。我们已经确定了几个与大小、敏捷性和测试有关的原则，这些原则对于成功实施至关重要。
- en: We have also got an overview of different tools used by Netflix OSS for the
    various key features required for successful implementation of microservice-architecture-based
    products and services. Netflix offers a video rental service, using the same tools
    successfully.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对Netflix OSS使用的各种工具有了概述，这些工具是实现微服务架构基础产品和服务所需的各种关键特性。Netflix提供视频租赁服务，成功使用了相同的工具。
- en: In the next chapter, readers may encounter issues and they may get stuck on
    those problems. The chapter explains the common problems encountered during the
    development of microservices, and their solutions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，读者可能会遇到问题，可能会困在这些问题上。本章解释了在微服务开发过程中遇到的常见问题及其解决方案。
