# 第十四章：评估

本节包含所有章节的问题答案。

# 第一章 – Java 虚拟机的发展历程

1.  Java 代码编译成字节码。JVM 使用解释器将字节码转换为机器语言，并使用即时编译器编译最常用的代码片段（热点）。这种方法帮助 Java 实现“一次编写，到处运行”，因此程序员不需要编写特定于机器的代码。

1.  类加载器子系统负责加载类。它不仅找到类，还验证和解析类。

1.  JVM 有五个内存区域：

    a. 方法：一个共享区域，其中所有类级别的数据都存储在 JVM 级别

    b. 堆：所有实例变量和对象存储在 JVM 级别（跨线程共享）

    c. 栈：每个线程的运行时栈，用于存储方法作用域内的局部变量，以及操作数和帧数据

    d. 注册表：具有当前执行指令地址的 PC 寄存器（每个线程）

    e. 原生方法栈：用于调用原生方法的每个线程的原生方法信息

# 第二章 – JIT、Hotspot 和 GraalJIT

1.  代码缓存是 JVM 内部的一个特殊内存区域，用于存储编译后的代码。代码由即时编译器编译并存储在代码缓存中。如果一个方法被编译并发现存在于代码缓存中，JVM 将使用该代码来运行，而不是解释方法代码。有关更多详细信息，请参阅*代码缓存*部分。

1.  可以使用以下标志来更改代码缓存大小，以进行微调。有关更多详细信息，请参阅*代码缓存*部分：

    a. `-XX:InitialCodeCacheSize` – 代码缓存的初始大小。默认大小是 160 KB（大小根据 JVM 版本而变化）

    b. `-XX:ReservedCodeCacheSize` – 这是代码缓存可以增长到的最大大小。默认大小是 32/48 MB。当代码缓存达到这个限制时，JVM 将抛出一个警告，“代码缓存已满。编译器已被禁用。” JVM 提供了`UseCodeCacheFlushing`选项，当代码缓存满时可以刷新代码缓存。当编译的代码不够热（计数器小于编译器阈值）时，也会刷新代码缓存。

    c. `-XX:CodeCacheExpansionSize` – 这是扩展大小。当它扩大时，其默认值是 32/64 KB。

1.  编译器阈值是用于决定代码何时“热”的因子。当代码达到编译器阈值时，JVM 将在编译线程上启动即时编译（C1 或 C2）。有关更多详细信息，请参阅*编译器阈值*部分。

1.  有时，代码在运行长时间循环时可能会变得“热”。在这种情况下，JVM 将编译该代码并执行 OSR。有关更多详细信息以及 JVM 如何执行 OSR 的详细流程图，请参阅*栈上替换*部分。

1.  在 JVM 中，有一个解释器和两种类型的编译器——C1 和 C2。用户可以指定任何特定的编译器来优化代码。默认情况下，JVM 执行分层编译，这是基于各种编译器阈值的 C1 和 C2 的组合。共有五个层级：

    a. 解释型代码（级别 0）

    b. 简单 C1 编译代码（级别 1）

    c. 有限 C1 编译代码（级别 2）

    d. 完整 C1 编译代码（级别 3）

    e. C2 编译代码（级别 4）

    JVM 遵循三种主要模式：

    a. 正常流程

    b. C2 繁忙

    c. 简单代码

1.  请参阅*分层编译*部分以获取更多详细信息。

1.  内联是 JIT 编译器使用的关键优化技术之一。基于代码分析，JIT 识别出可以内联的方法以避免方法调用。方法调用成本较高，因为它执行跳转并创建栈帧。

1.  单态分发是另一种用于识别多态实现的具体实现的优化技术。JIT 分析代码，识别具体实现，并围绕该实现优化代码。请参阅*单态、双态和巨态分发*部分以获取更多详细信息。

1.  循环展开是 JIT 执行的最有效的优化之一，通过在循环体中内联代码、添加额外代码并减少循环必须迭代的次数来实现。请参阅*循环优化——循环展开*部分以获取更多详细信息及示例。

1.  逃逸分析是 JIT 分析器执行的一种优化技术，用于识别变量的分配和作用域，并基于变量的作用域做出避免堆分配的决定，并用栈分配替换。这是 JIT 分析器执行的最先进的分析之一。请参阅*逃逸分析*部分以获取更多详细信息。

1.  当 JIT 在优化和编译代码时所做的任何乐观假设无效时，JIT 将执行去优化。JIT 将编译代码设置为非可进入状态，并回退到解释器。

1.  JVMCI 代表*Java 虚拟机编译器接口*。此接口在 Java 9 中添加到 JDK 中。JVMCI 提供了一个 API 来扩展 JVM 并构建自定义编译器。Graal JIT 是 JVMCI 的一个实现。请参阅*Graal JIT 和 JVM 编译器接口（JVMCI）*部分以获取更多详细信息。

# 第三章 - Graal VM 架构

1.  GraalVM 有两种版本——社区版和企业版。请参阅*查看 GraalVM 版本*部分以获取更多详细信息。

1.  JVMCI 代表*Java 虚拟机编译器接口*。Java 9 及以上版本提供了一种实现自定义 JIT 编译器的方法。JVMCI 提供了一个 API 来实现这些自定义编译器，并提供了对 JVM 对象和代码缓存的访问。Graal JIT 是 JVMCI 的一个实现。请参阅*Java 虚拟机编译器接口（JVMCI）*部分以获取更多详细信息。

1.  Graal JIT 替代了 C2 JIT 编译器。Graal JIT 完全用 Java 从头编写，但使用了 C2 编译器的强化逻辑和最佳实践。Graal JIT 实现了比 C2 JIT 更好的优化策略，使其成为 Java 最好的 JIT 编译器。Graal JIT 还可以用于编译其他语言，这些语言被转换为中间表示，以便使用高级优化策略。有关详细信息，请参阅 *Graal 编译器和工具* 部分。

1.  Graal JIT 需要相当长的时间来预热、配置文件和优化代码。在某些用例中，这可能不合适（如无服务器或容器）。对于此类情况，Graal 提供了 AOT 编译，将代码直接编译成本地图像。

1.  Graal AOT 优化更相关于静态代码分析，但现在它已经有了代码的运行时配置文件来应用任何高级优化**。配置文件引导优化**（**PGO**）提供了一种方法，通过添加工具来编译代码，生成运行时配置文件，并使用该配置文件重新编译代码以生成最优化本机图像。有关详细信息，请参阅 *SubstrateVM（Graal AOT、本地图像）* 部分。

1.  Truffle 框架建立在 Graal 之上，以支持非 JVM 语言在 Graal JVM 上运行。Truffle 提供了 Truffle 语言实现 API 以及各种其他多语言 API，以提供一个非常复杂的编程环境，其中多种语言的代码可以嵌入并交互。有关详细信息，请参阅 *Truffle* 部分。

1.  SubstrateVM 是一个可嵌入的虚拟机，可以与 Graal AOT 编译器编译的本地图像一起打包。有关详细信息，请参阅 *SubstrateVM（Graal AOT 和本地图像）* 部分。

1.  客户端访问上下文是一个对象，由宿主语言（如 Java）使用，以提供对客户端语言（如 JavaScript）以及各种操作系统资源（如文件系统、I/O 和线程）的访问。有关详细信息，请参阅 *安全* 部分。

1.  GraalVM 提供了最先进的 JIT 编译，非常适合涉及高吞吐量的长时间运行过程。GraalVM AOT 编译器以及 SubstrateVM 提供了云原生微服务实现的最小和最快的运行时。结合 PGO，它生成在云上运行的优化代码。有关详细信息，请参阅 *GraalVM 微服务架构概述* 部分。

# 第四章 – Graal 即时编译器

1.  Graal JIT 编译可以分为两个阶段：前端和后端。

    前端阶段是平台无关的编译，其中代码被转换为一种平台无关的中间表示，称为 **高级中间表示**（**HIR**），通过 Graal 图表示。这种 HIR 在三个级别上进行优化：高、中、低。

    后端阶段是更依赖于平台的编译，其中在机器代码级别创建并优化了**低级中间表示法**（**LIR**）。这些优化依赖于平台。

    请参阅**Graal JIT 编译器管道和分层优化**部分以获取更多详细信息。

1.  **中间表示法**（**IRs**）是编译器设计中最重要的数据结构之一。中间表示法提供了一个图，帮助编译器理解代码的结构，识别机会，并执行优化。请参阅**Graal 中间表示法**部分以获取更多详细信息。

1.  **静态单赋值**（**SSA**）是中间表示法中使用的一种形式，其中每个变量只赋值一次，任何时间值发生变化时，都会使用一个新的变量。每个变量在使用之前都会被声明。这有助于我们跟踪变量和值，并有助于使用图更好地优化代码。请参阅**Graal 中间表示法**部分以获取更多详细信息。

1.  投机优化是一种编译器优化技术，通过投机执行各种代码优化。投机是基于对代码进行剖析所做的假设。根据这些假设在代码上执行优化。当这些假设在运行时被证明是错误的时候，会执行去优化。这有助于优化代码的焦点部分，而不是整个代码，这可能会减慢运行时。请参阅**Graal 编译器优化**部分以获取更多详细信息。

1.  逃逸分析是一种优化技术，它识别对象的作用域和用法，并决定对象在堆、栈或寄存器上的分配。这对内存使用和性能有重大影响。逃逸分析在方法级别执行，而部分逃逸分析则对代码进行更深入的分析，以跟踪不仅限于方法级别作用域的对象，还包括控制块级别的对象。这有助于进一步优化代码。请参阅**部分逃逸分析**部分以获取更多详细信息。

# 第五章 - Graal 即时编译器和原生图像

1.  GraalVM 附带一个名为 Native Image builder 的工具，即`native-image`。这可以用来编译并创建原生图像。请参阅**构建原生图像**部分以获取更多详细信息。

1.  当 Native Image builder 在编译代码之前执行时，会进行指针分析以理解应用程序代码访问的所有依赖类和方法。它使用这些信息来优化原生图像，只将所需的代码构建到图像中。这提供了更快的执行速度和更小的图像。请参阅**构建原生图像**部分以获取更多详细信息。

1.  原生图像构建器执行区域分析，以便在启动之前将类初始化到堆中，从而使原生图像的启动更快。请参阅*构建原生图像*部分以获取更多详细信息。

1.  原生图像构建器将**垃圾收集器**（**GC**）代码与原生图像一起打包。原生图像中可以启用两种类型的 GC。串行 GC 是默认的 GC，在社区和商业版中均可用。G1 执行更高级的垃圾收集，仅在商业版中可用。请参阅*原生图像内存管理配置*部分以获取更多详细信息。

1.  与 JIT 编译器不同，原生图像构建器只能执行静态代码分析，JIT 编译器可以在运行时对代码进行性能分析并在运行时优化代码。PGO 将运行时性能分析信息带到原生图像中，以进行进一步优化。请参阅*性能引导优化（PGO）*部分以获取更多详细信息。

1.  由于原生图像是在构建之前构建的，原生图像构建器需要在构建时加载所有类。因此，原生图像在支持动态功能（如反射和 JNI）方面存在限制。然而，GraalVM 的原生图像构建器提供了在构建时传递动态资源信息的方法。请参阅*原生图像配置*和*Graal AOT（原生图像）限制*部分以获取更多详细信息。

# 第六章 – 松露 – 概述

1.  专业化是一种关键优化，有助于识别变量的特定类型。在动态类型语言中，变量的类型在代码中未声明。解释器开始假设通用类型，并根据运行时性能分析推测变量的类型。请参阅*Truffle 解释器/编译器管道*部分以获取更多详细信息。

1.  当 Truffle 对节点的一个特定类型进行推测时，节点会动态重写，Truffle AST 提供了一种方法，在将节点提交给 Graal 进行进一步优化执行之前，优化 AST。请参阅*Truffle 解释器/编译器管道*部分以获取更多详细信息。

1.  当 Truffle 发现 AST 没有被重写时，它假定 AST 已经稳定。然后，在进行了激进的常量折叠、内联和逃逸分析之后，将代码编译为客语言的机器代码。这被称为部分评估。请参阅*Truffle 解释器/编译器管道*部分的*部分评估*以获取更多详细信息。

1.  松露提供了一种作为注解生成器实现的领域特定语言。这有助于客语言开发者编写更小的代码，并专注于逻辑，而不是样板代码。请参阅*Truffle DSL*部分以获取更多详细信息。

1.  框架是 Truffle 类，它提供了在当前命名空间中读取和存储数据的接口。请参阅*Truffle 框架管理和局部变量*部分以获取更多细节。

1.  Truffle 定义了一个动态对象模型，为各种客语言实现提供了一个标准接口和框架，以便以标准方式定义和交换数据。请参阅*Truffle 互操作性*部分的*动态对象模型*以获取更多细节。

# 第七章 – GraalVM 多语言 – JavaScript 和 Node.js

1.  `Polyglot`是 JavaScript 中用于运行其他语言代码的对象。我们使用`eval()`方法来运行代码。请参阅*JavaScript 互操作性*部分，了解如何使用此对象运行代码的更多细节。

1.  `Context`对象提供了多语言上下文，以便在宿主语言中运行客语言代码。多语言上下文表示所有已安装和允许的语言的全局运行时状态。请参阅*Java 中嵌入 JavaScript 代码*部分，了解如何使用此对象运行代码的更多细节。

1.  `Context`对象有助于提供细粒度的访问控制。访问控制可以通过`ContextBuilder`进行控制。请参阅*Java 中嵌入 JavaScript 代码*部分，了解如何使用此对象运行代码的更多细节。

1.  GraalVM 提供了一个原生图像构建器选项，用于构建具有多种嵌入式语言的程序的原生图像。语言标志用于让原生图像构建器知道应用程序中使用了哪些语言。此标志也可以在`native-image`属性文件中指定。请参阅本章的*多语言原生图像*部分以了解更多。有关原生图像的更多详细信息，请参阅*第五章*，*Graal 即时编译器和原生图像*。

1.  `binding`对象在 Java 和 JavaScript 之间充当中间层，用于访问两种语言之间的方法、变量和对象。请参阅*绑定*部分，了解更多关于绑定对象及其作为语言之间中间层的用法。

# 第八章 – GraalVM 多语言 – Java 在 Truffle、Python 和 R 上

1.  Java 在 Truffle 是运行 Java 程序在 Truffle 框架之上的新方法。Java 在 Truffle 提供了一个完全基于 Java 构建的解释器，并在与其他 Truffle 语言相同的内存空间中运行。这是在 GraalVM 版本 21 中引入的。更多详细信息请参阅*理解 Espresso（Java 在 Truffle 上）*部分。

1.  在 Truffle 上运行的 Java 提供了一个隔离层，有助于运行不受信任的代码和用较旧版本的 JDK 编写的代码，并提供热插拔和其他高级功能。要了解更多关于在 Truffle 上使用 Java 的优势，请参阅*为什么我们需要在 Java 上运行 Java？*部分以获取更多详细信息。

1.  在 Truffle 上，`Polyglot.cast()` 方法用于将动态语言导出或返回的数据进行类型转换。请参阅 *探索 Espresso 与其他 Truffle 语言之间的互操作性* 部分以获取更多细节和代码示例。

1.  **SST** 代表 **Simple Syntax Tree**，而 **ST** 代表 **Scope Tree**。Python 在将它们转换为 AST 中间表示之前生成这些中间表示。Python 使用 ANTLR 解析器和缓存来完成此操作，并加快了解析速度。请参阅 *理解 Graalpython 编译器和解释器管道* 部分以获取更多细节。

1.  `.pyc` 文件是 Python 在解析 Python 代码并生成 SST 和 ST 表示之后创建的缓存。这有助于加快下次加载 Python 模块时的解析速度。Python 会自动保持此缓存的有效性。请参阅 *理解 Graalpython 编译器和解释器管道* 部分以获取更多细节。

1.  `polyglot.import_value()` 用于从其他动态语言导入定义，而 `polyglot.export_value()` 用于将 Python 定义导出到其他语言。`polyglot.eval()` 用于执行其他语言代码。请参阅 *探索 Python 与其他动态语言之间的互操作性* 部分以获取更详细的解释和示例代码。

1.  在 R 中，我们使用 `import()` 函数从其他语言导入定义。请参阅 *探索 R 的互操作性* 部分以获取更多细节。

1.  我们使用 `java.type('classname')` 来加载 Java 类并与它交互。此函数提供了类，我们可以使用 `new()` 函数来创建对象的实例。请参阅 *探索 R 的互操作性* 部分以获取更多细节和示例代码。

# 第九章 – GraalVM Polyglot – LLVM、Ruby 和 WASM

1.  Sulong 是一个用 Java 编写的 LLVM 解释器，它内部使用 Truffle 语言实现框架。这使得所有可以生成 LLVM IR 的语言编译器都可以直接在 GraalVM 上运行。请参阅 *理解 LLVM – (Sulong) Truffle 接口* 部分以获取更多细节。

1.  GraalVM 企业版提供了一个管理的 LLVM 环境。执行管理的模式提供了一个安全的运行时环境，它通过额外的安全性保证能够捕获非法指针访问和访问超出边界的数组。

    TruffleRuby 解释器与 LLVM 解释器交互以实现 C 扩展。这也扩展了使用其他 LLVM 语言（如 Rust 和 Swift）作为 Ruby 扩展运行的可能性。请参阅 *理解 TruffleRuby 解释器/编译器管道* 部分以获取更多细节。

1.  WASM 是可以在现代网络浏览器上运行的二进制代码。它具有非常小的体积，并且比 JavaScript 执行速度快得多。请参阅 *理解 WASM* 部分以获取更多细节。

    Emscripten 或 `emcc` 是生成 WASM 二进制图像（`.wasm`）文件的编译器。请参阅“*安装和运行 GraalWasm*”部分以获取更多详细信息。

# 第十章 – 使用 GraalVM 的微服务架构

1.  微服务是一种将大型应用程序分解为更小、更易于管理和自包含的组件的架构模式，这些组件通过称为服务的标准接口公开其功能。请参阅“*微服务架构概述*”部分以获取更多详细信息。

1.  微服务架构模式帮助我们构建一个可扩展、可管理和松散耦合的应用程序。这对于构建云原生应用以充分利用云基础设施和服务非常重要。请参阅“*微服务架构概述*”部分以获取更多详细信息。

1.  GraalVM 提供了一个具有小内存占用的高性能运行时环境，这对于构建可扩展的云原生应用至关重要。请参阅第三章“Graal VM 架构”中的“*审查现代架构要求*”部分以及本章的“*理解 GraalVM 如何帮助构建微服务架构*”部分以获取更多详细信息。
