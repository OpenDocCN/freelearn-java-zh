# 前言

*第一章，* *类型推断*，Java 长期以来一直因冗长而受到批评，Java 10 通过使用关键字 var 引入了局部变量的类型推断。它不应与动态绑定混淆。Java 仍然有静态绑定。类型推断是从之前的 Java 版本演变而来的，从 Java 5 的泛型到 Java 7 的 try-with-resources，再到 Java 8 中推断的 lambda 参数类型。Java 编译器不是让您输入变量类型信息，而是推断它并将其添加到字节码中。

*第二章，* *应用程序类数据共享*，应用程序类数据共享（ADS）扩展了类数据共享（CDS），它允许 JVM 记录一组类并将它们处理成一个共享的归档文件。这个归档文件可以在下一次运行时映射到 JVM 进程以减少启动时间。文件可以在 JVM 之间共享，这可以在同一主机上运行多个 JVM 时减少整体内存占用。

*第三章，* *垃圾收集器优化*，Java 垃圾收集器既是一大福音，也是一大痛点。一直在持续努力优化垃圾收集过程。随着 Java 9 的发布，G1 成为默认的垃圾收集器。在 Java 10 中，G1 通过允许完全 GC 并行化而变得更加高效。通过垃圾收集器接口，应用程序可以部署使用替代的垃圾收集器。

*第四章，* *API 改进及其他变更*，这还不是全部，Java 10 还有更多要提供——它包括对现有 API 的改进，如添加创建不可修改集合的 API，线程局部握手以停止选定的线程，以及将 JDK 森林合并到一个单一仓库中。

*第五章，* lambda 参数的局部变量语法，Java 11 最受期待的特性之一，lambda 参数的局部变量语法引入了与 lambda 参数一起使用 var 的用法。本章将涵盖其语法和用法，以及面临的挑战。

*第六章，* *Epsilon 及其设计考虑因素*，Java 11 引入了 Epsilon；它减少了垃圾收集的延迟。在本章中，您将了解为什么需要它以及其设计考虑因素。

*第七章，* *HTTP 客户端及其他变更*，随着 Java 11 的发布，自从 Java EE 迁移到 Eclipse 基金会并更名为 Jakarta EE 以来，已开始移除弃用的 Java EE 和 corba 包。Java 11 重写了 Java 9 中引入的 HTTP 客户端的实现，使其完全异步。

*第八章，* *增强的枚举项目 Amber*，现有的枚举提供了有限的功能。Amber 项目将通过允许类型变量（泛型枚举）和执行对枚举常量的更精确的类型检查来增强枚举。

*第九章，*数据类及其使用*，数据类是存储对象状态的包装器。尽管 IDE 可以生成此类访问器和突变方法，但开发者仍需要扫描以确定它是否隐藏任何业务逻辑。通过定义数据类并使用关键字 data，数据类使这种语言仪式变得更加简单。本章涵盖了数据类的需求、定义和使用。

*第十章，*原始字符串字面量*，字符串连接是程序员经常使用的方法，用于返回对象的字符串表示形式、JSON 或 XML 请求或响应、SQL 查询等。到目前为止，Java 的字符串连接使用了笨拙的连接运算符组合、引号和特殊字符的否定（使用反斜杠），这使得编写和维护变得不方便。本章通过演示原始字符串字面量的创建和使用，简化了字符串连接。

*第十一章，*Lambda 剩余*，lambda 剩余包括使用下划线（_）表示未命名的方法、异常或 lambda 参数。本章涵盖了实现它的挑战、创建和使用。

*第十二章，*模式匹配和 switch 表达式*，为了入门，模式匹配将涵盖类型测试和常量模式，以增强 Java 语言结构。本章将向您介绍模式及其如何显著影响 switch 表达式的使用方式。

*第十三章，*基于值的优化*，当对象存储在数组中时，会有额外的开销，它们的直接值不会存储在数组中。对象数组存储有关数组对象的元数据和多个数据引用。这比所需的内存多得多。值类型，一种新的语言修改，允许创建数据类型；这些数据类型仅使用存储实际值所需的内存。

*第十四章，*泛型改进*，随着向 Java 添加值类型的提议，限制泛型参数为对象是有害的。本章涵盖了泛型改进，以扩展泛型类型以支持泛型类和接口在原始类型上的特殊化。

*第十五章，*过滤器与延续*，自从首次发布以来，Java 因其对线程创建的支持而变得流行。纤程和延续将使它迈出更大的步伐；通过创建超轻量级的线程，称为纤程。

*第十六章，*JVM 和本地代码*，类似于连接大西洋和太平洋的巴拿马运河，Project Panama 计划弥合 JVM 和本地代码之间的差距。本章将向您介绍如何向 Java 开发者开放本地库的思考过程，例如用 C 编写的库。
