# 前言

高度并发的应用程序，如用户界面，传统上通过全局变量的突变来管理状态。各种动作通过事件处理程序进行协调，这些处理程序本质上是程序性的。

随着时间的推移，系统的复杂性不断增加。新的功能请求不断涌入，对应用程序进行推理变得越来越困难。

函数式编程通过消除可变状态，允许以声明性和可组合的方式编写应用程序，呈现为构建可靠系统的极其强大的盟友。

这些原则催生了函数式反应式编程和组合事件系统（CES），这些编程范式在构建异步和并发应用程序方面非常有用。它们允许你以函数式风格对可变状态进行建模。

本书致力于这些理念，并介绍了一系列不同的工具和技术，以帮助管理现代系统日益增加的复杂性。

# 本书涵盖的内容

第一章，*什么是反应式编程？*，首先通过一个引人入胜的 ClojureScript 编写的反应式应用程序的例子引导你，然后带你穿越反应式编程的历史，在此期间介绍了一些重要的术语，为后续章节定下了基调。

第二章，*反应式扩展概述*，探讨了这种反应式编程框架的基础。其中介绍了其抽象概念，并讨论了错误处理和背压等重要主题。

第三章，*异步编程和网络*，引导你构建一个股票市场应用程序。它首先使用一种更传统的方法，然后切换到基于反应式扩展的实现，比较了两种方法之间的权衡。

第四章，*core.async 简介*，描述了 core.async，这是一个用于 Clojure 异步编程的库。在这里，你将了解通信顺序进程的构建块，以及如何使用 core.async 构建反应式应用程序。

第五章，*使用 core.async 创建自己的 CES 框架*，开始了构建 CES 框架的雄心勃勃的努力。它利用了前一章获得的知识，并以 core.async 作为框架的基础。

第六章，*使用 Reagi 构建简单的 ClojureScript 游戏*，展示了反应式框架在游戏开发中产生巨大效果的领域。

第七章, *UI 作为函数*，转换了方向，展示了如何通过 Om 的视角将函数式编程的原则应用于 Web UI 开发，Om 是 Facebook 的 React 的 ClojureScript 绑定。

第八章, *未来*，将未来作为某些类反应式应用的可行替代方案。它探讨了 Clojure 未来的局限性，并提出了一种替代方案：imminent，一个用于 Clojure 的可组合未来库。

第九章, *亚马逊网络服务的响应式 API*，描述了一个来自真实项目的案例研究，其中本书介绍的大多数概念都被组合起来与第三方服务进行交互。

附录 A, *图书馆设计代数*，介绍了来自范畴论的有助于构建可重用抽象的概念。附录是可选的，不会妨碍前几章的学习。它展示了设计第八章中看到的未来库所使用的原则，*未来*。

附录 B, *参考文献*，提供了书中使用的所有参考文献。

# 你需要这本书的

本书假设你有一个相当现代的台式机或笔记本电脑，以及一个配置正确的 Clojure 环境与 leiningen（见[`leiningen.org/`](http://leiningen.org/)）。

安装说明取决于你的平台，可以在 leiningen 网站上找到（见[`leiningen.org/#install`](http://leiningen.org/#install)）。

你可以自由选择任何你喜欢的文本编辑器，但流行的选择包括带有 Counterclockwise 插件的 Eclipse（见[`eclipse.org/downloads/`](https://eclipse.org/downloads/)），带有 Cursive 插件的 IntelliJ（见[`www.jetbrains.com/idea/`](https://www.jetbrains.com/idea/)），Light Table（见[`lighttable.com/`](http://lighttable.com/)），Emacs 和 Vim。

# 这本书是为谁而写的

这本书是为目前正在构建或计划构建异步和并发应用程序的 Clojure 开发者而写的，他们还对如何将响应式编程的原则和工具应用于日常工作感兴趣。

需要了解 Clojure 和 leiningen——一个流行的 Clojure 构建工具。

本书还包含几个 ClojureScript 示例，因此熟悉 ClojureScript 和通用 Web 开发将有所帮助。

尽管如此，章节已经仔细编写，只要您具备 Clojure 知识，遵循这些示例只需额外一点努力。

随着本书的进展，它将列出后续章节所需的构建块，因此我的建议是您从第一章，“什么是响应式编程？”，并按顺序阅读后续章节。

一个明显的例外是附录 A，“图书馆设计代数”，它是可选的，可以独立于其他内容阅读——尽管阅读第八章，“未来”，可能提供有用的背景。

# 规范

在这本书中，您会发现许多不同风格的文本，用于区分不同类型的信息。以下是一些这些风格的示例及其含义的解释。

文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 用户名将如下所示：“我们可以通过使用`include`指令来包含其他上下文。”

代码块应如下设置：

```java
(def numbers (atom []))

(defn adder [key ref old-state new-state]
  (print "Current sum is " (reduce + new-state)))

(add-watch numbers :adder adder)
```

当我们希望您注意代码块中的特定部分时，相关的行或项目将以粗体显示：

```java
(-> (repeat-obs 5)
    (rx/subscribe prn-to-repl))

;; 5
;; 5

```

任何命令行输入或输出都应如下编写：

```java
lein run -m sin-wave.server

```

**新术语**和**重要词汇**将以粗体显示。例如，您在屏幕上、菜单或对话框中看到的单词将以文本中的这种方式显示：“如果这是一个 Web 应用程序，我们的用户将看到一个 Web 服务器错误，例如**HTTP 代码 500 - 内部服务器错误**。”

### 注意

警告或重要注意事项将显示在这个框中。

### 小贴士

小技巧和技巧看起来像这样。

# 读者反馈

我们欢迎读者提供反馈。请告诉我们您对这本书的看法——您喜欢什么或可能不喜欢什么。读者反馈对我们开发您真正能从中获得最大收益的标题非常重要。

要向我们发送一般反馈，只需发送一封电子邮件到`<feedback@packtpub.com>`，并在邮件的主题中提及书名。

如果您在某个主题上具有专业知识，并且您对撰写或为书籍做出贡献感兴趣，请参阅我们的作者指南[www.packtpub.com/authors](http://www.packtpub.com/authors)。

# 客户支持

现在，您已经成为 Packt 书籍的骄傲所有者，我们有一些事情可以帮助您从您的购买中获得最大收益。

## 下载示例代码

您可以从您在[`www.packtpub.com`](http://www.packtpub.com)的账户中下载您购买的所有 Packt 书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。

## 错误

尽管我们已经尽一切努力确保内容的准确性，但错误仍然可能发生。如果您在我们的某本书中发现错误——可能是文本或代码中的错误——如果您能向我们报告这一点，我们将不胜感激。通过这样做，您可以节省其他读者的挫败感，并帮助我们改进本书的后续版本。如果您发现任何勘误，请通过访问 [`www.packtpub.com/submit-errata`](http://www.packtpub.com/submit-errata)，选择您的书籍，点击**勘误****提交****表单**链接，并输入您的勘误详情来报告。一旦您的勘误得到验证，您的提交将被接受，勘误将被上传到我们的网站，或添加到该标题的勘误部分下的现有勘误列表中。任何现有勘误都可以通过从 [`www.packtpub.com/support`](http://www.packtpub.com/support) 选择您的标题来查看。

## 盗版

互联网上版权材料的盗版是一个跨所有媒体的持续问题。在 Packt，我们非常重视我们版权和许可证的保护。如果您在互联网上发现我们作品的任何非法副本，无论形式如何，请立即提供位置地址或网站名称，以便我们可以寻求补救措施。

如果您发现任何疑似盗版材料，请通过 `<copyright@packtpub.com>` 联系我们，并提供链接。

我们感谢您在保护我们作者以及为我们带来有价值内容方面的帮助。

## 问题

如果您在这本书的任何方面遇到问题，可以通过 `<questions@packtpub.com>` 联系我们，我们将尽力解决。
