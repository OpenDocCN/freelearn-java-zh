# 第十六章：未来方向

在上一章中，我们关注了 Java 9 平台提供的某些激动人心的实用工具的最佳实践。具体来说，我们涵盖了 UTF-8 属性文件、Unicode 7.0.0、Linux/AArch64 端口、多分辨率图像和常见区域数据存储库。

本章概述了 Java 平台在 Java 9 之后的未来开发。我们将探讨 Java 10 的计划以及未来可能看到的进一步变化。每个对 Java 平台的潜在更改将被描述为目标、提交或草案。目标指的是已标记为 Java 10 的更改。提交指的是已提交但未针对 Java 平台特定版本的更改。草案更改仍在规划中，尚未准备好提交或指定为目标。

具体来说，本章涵盖了以下类别中组织的 Java 平台未来的更改：

+   JDK 更改

+   Java 编译器

+   Java 虚拟机

+   JavaX

+   特殊项目

# JDK 未来的更改

Java 开发工具包（Java Development Kit，简称 JDK）是 Java 平台的核心，并且随着每个版本的发布，持续更新以实现新的功能和效率。展望 Java 9 之后，我们看到了 JDK 可能发生的众多变化。其中许多变化将在 Java 10 中实现，其他一些可能被保留到以后的版本中。

Java 10 及以后的 JDK 更改在以下提案类别中呈现：

+   针对 Java 10

+   提交的提案

+   草案提案

# 针对 Java 10 的 JDK 更改

在本书出版时，以下列出的**Java 开发工具包**（**JDK**）相关更改计划包含在 Java 10 平台中：

+   存储库整合

+   原生头工具移除

# 存储库整合

Java 9 平台由以下图中所示的八个不同的存储库组成。在 Java 10 中，我们应该看到所有这些存储库合并为一个单一存储库：

![图片](img/c8b331a6-e0a4-4c43-849c-f6cfb85d0253.png)

存储库整合应有助于简化开发。此外，它应增加维护和更新 Java 平台的便利性。

您可以提前查看此存储库：[`hg.openjdk.java.net/jdk10/consol-proto/`](http://hg.openjdk.java.net/jdk10/consol-proto/)。

# 原生头工具移除

javah 工具用于从 Java 类生成 C 头文件和 C 源文件。C 程序可以引用生成的头文件和源文件。

下面是 javah 工具的诞生与消亡：

![图片](img/bb5e9476-4840-4f07-8d4c-ce659e98a143.png)

如前所述，javah 工具是在 Java 7 中引入的，其功能包含在随 JDK8 提供的 javac 中。据报道，与原始工具相比，该功能更优越。在 JDK 9 中，每次使用 javah 工具时，开发者都会收到警告，告知他们该工具将从 JDK 中移除。该工具计划在 JDK 10 中移除。

# 与 JDK 相关的提交提案

以下 Java 增强提案已经提交，但尚未承诺作为 Java 10 平台的一部分进行交付。Oracle 设定了两年发布计划，因此可以合理假设，本节及以后列出的许多（如果不是全部）提案都有可能成为 Java 10 平台的一部分：

+   在 CMS 中并行化完全 GC 阶段

+   JMX 的 REST API

+   支持堆分配

# 在 CMS 中并行化完全 GC 阶段

在第七章《利用新的默认 G1 垃圾收集器》中，我们回顾了**并发标记清除**（**CMS**）垃圾收集器的变化。CMS 垃圾收集涉及扫描堆内存，标记要删除的对象，然后进行清除以实际删除这些对象。CMS 垃圾收集方法本质上是一种升级的“标记和清除”方法；您可以参考第七章《利用新的默认 G1 垃圾收集器》，以获取更多信息。

当前 CMS 垃圾收集的缺点是，串行标记和清除使用单个线程实现。这导致不希望的暂停时间。目前，完全垃圾收集在四个阶段进行：

+   **标记阶段**：标记要收集的对象

+   **转发阶段**：确定活动对象将被重新定位的位置

+   **调整指针阶段**：根据活动对象的新位置更新指针

+   **压缩阶段**：将对象移动到指定的位置

CMS 的未来计划是实现标记和清除，以便它们可以并行执行。这种变化不是对垃圾收集算法的改变。相反，上述列出的每个阶段都将并行化。这将使 CMS 垃圾收集更加高效，并有望消除或显著减少暂停时间。

# JMX 的 REST API

**表示状态转移**（**REST**）、RESTful 编程和 RESTful API 使用客户端/服务器缓存通信协议，通常是 HTTP。REST 是开发网络应用程序的常见软件架构。

Java 平台未来的一个变化是提供 RESTful 网络接口给 MBeans。

**托管 Bean**（**MBean**）是 Java 中代表要管理的资源的对象。这些资源可能包括特定的硬件设备、应用程序、服务或其他组件。

接口将允许 MBeans 使用以下 HTTP 方法：

+   `CONNECT`

+   `DELETE`

+   `GET`

+   `HEAD`

+   `OPTIONS`

+   `POST`

+   `PUT`

+   `TRACE`

MBeans 使用 **Java 管理扩展**（**JMX**）进行管理。JMX 架构有三个级别，如下图所示：

![](img/69a5ff4d-645f-4bb4-9ca1-9016659e564c.png)

如您所见，REST 适配器是 **分布式服务** 级别的一部分。该级别包含连接器和适配器。连接器提供代理级别接口到远程客户端的镜像。另一方面，适配器使用不同的协议转换接口。未来的变化将是将 **代理** 级别的服务转换为 REST API。

# 支持堆分配

提出的未来变化是允许开发者为 Java 堆指定替代内存设备。具体来说，建议允许开发者指定非 DRAM 内存用于 Java 堆。这一变化利用了内存和内存设备的成本下降。

实现可能使用 `AllocateHeapAt` 标志。

# JDK 相关的草案提案

本节涵盖了几个与 JDK 相关的提案，在本书出版时，它们处于草案阶段。这表明它们可能没有得到充分分析，甚至可能被取消。尽管如此，这些提案中的每一个很可能从草案阶段发展到提交阶段，然后针对 Java 10 平台进行目标定位。

本节涵盖的草案提案如下：

+   最终化及时性

+   Java 内存模型

+   外部函数接口

+   隔离方法

+   减少元空间浪费

+   改善 IPv6 支持

+   方法句柄的无包装参数列表

+   使用值类型增强的 MandelblotSet 示例

+   高效的数组比较内联函数

# 最终化及时性

Java 语言包括最终化来清理垃圾收集无法到达的对象。提出的更改是使此过程更快，并将需要修改以下内容：

+   `ReferenceHandleThread`

+   `FinalizerThread`

+   `java.lang.ref.Reference`

与提高最终化及时性相关的额外变化包括创建一个新的 API。以下图形详细说明了该 API 将如何实现 GC 和运行时操作，然后通知需要进行最终化。这肯定会导致处理速度更快：

![](img/b7166659-6e03-4a2c-811f-3eae26bafe3c.png)

# Java 内存模型

持续努力以保持 **Java 的内存模型**（**JMM**）更新。当前的工作重点集中在以下几个领域，包括：

+   共享内存并发

+   JVM 并发支持

+   JDK 组件

+   工具

JMM 相关工程努力的预期结果如下：

+   改进的形式化

+   JVM 覆盖率

+   扩展范围

+   C11/C++11 兼容性

+   实施指南

+   测试支持

+   工具支持

# 外部函数接口

**外部函数接口**（**FFI**）是软件 API，允许程序调用用不同语言编写的程序中的方法/函数。在 JDK 的一个即将到来的版本中，我们可能会看到一种 FFI，允许开发人员直接从 Java 方法调用共享库和操作系统内核。据说提议的 FFI 还将使开发人员能够管理本地内存块。

新的 FFI 将类似于 **Java Native Access**（**JNA**）和 **Java Native Runtime**（**JNR**）。JNA 是一个库，允许在不使用 **Java Native Interface**（**JNI**）的情况下访问本地共享库。JNR 是一个用于调用本地代码的 Java API。提议的 FFI 将允许并优化本地方法调用以及优化的本地内存管理。

# 独立的方法

`MethodHandles.Lookup` 类是 `java.lang.invoke` 包的一部分。我们使用查找对象来创建方法句柄，并使用查找类来访问它们。以下是查找类的头文件：

```java
    public static final class MethodHandles.Lookup extends Object
```

`MethodHandles.Lookup` 类的未来更改将支持在不附加类的情况下加载方法字节码。此外，这些方法将使用方法句柄进行引用。该类将有一个新的 `loadCode` 方法。

# 减少元空间浪费

目前，当元空间块被释放时，它们不能作为不同大小的块使用。因此，如果元空间块 A 被释放且大小为 X，那么该空间不能用于大于或小于大小 X 的元空间块。这导致大量不可用的元空间浪费。这也可能导致内存不足错误。

JDK 的未来更改将通过增加元空间块的重用来解决这个问题。该更改将支持以下情况：

+   允许相邻块形成一个更大的块

+   允许较大的块被分割成较小的块

本提议的更改通过确保较小的块可以被重用，以及较大的块不会被浪费（因为它们可以被分割以支持较小块的重用）来解决这个问题。

# 改进 IPv6 支持

**互联网协议版本 6**（**IPv6**）是当前互联网协议的版本。互联网协议提供了识别和位置模式，使得互联网流量路由成为可能。IPv6 被视为一个用于分组交换网络的互联网层协议。

以下图显示了互联网协议的历史：

![图片](img/b34a14d5-d47e-4114-91f0-a22cc1873f6c.png)

IPv6 是 IPv4 的替代品，并且有几个变化，Java 平台应该支持。从 IPv4 到 IPv6 的关键变化如下分类：

+   大数据包

+   更大的地址空间

+   移动性

+   多播

+   网络层安全

+   选项可扩展性

+   隐私

+   简化路由处理

+   无状态地址自动配置

随着互联网从 IPv4 向 IPv6 的过渡，以下情况是可能的，并且都应该在 Java 10 平台上得到支持：

+   存在多个 IPv4 版本

+   存在一种 IPv6 版本

+   存在多种 IPv6 版本

+   存在多种 IPv4 版本和一种 IPv6 版本

+   存在多种 IPv4 和 IPv6 版本

# 方法句柄的无包装参数列表

目前无包装参数列表的处理方式可能导致处理效率低下。这在我们使用`Object[]`或`List<object>`作为可变长度参数列表时尤其如此。Java 使用`java.lang.invoke`来转换使用装箱的方法调用。在 Java 中，自动装箱是编译器自动将原始类型及其相应的对象包装类进行转换。以下是包装类及其对应原始类型的列表：

| **包装类** | **原始类型** |
| --- | --- |
| 布尔值 | boolean |
| 字节 | byte |
| 字符 | char |
| 双精度浮点数 | double |
| 浮点数 | float |
| 整数 | int |
| 长整型 | long |
| 短整型 | short |

如以下插图所示，当我们从原始值转换为相关包装类的对象时发生自动装箱，当我们从包装类的对象转换为原始值时称为拆箱：

![图片](img/0ce771a6-9308-4192-a19e-62412b5b7730.png)

不效率是由于参数列表的实际类型与封装它们的数组或列表之间的不匹配。在未来的 Java 版本中，这些不效率将被消除。Java 平台将添加一个新的`ArgumentList`类，该类将多态地将有效的参数列表装箱到堆节点中。

# 使用值类型的增强 MandelblotSet 演示

这个低优先级的 Java 增强提案很可能在 Java 10 中实现，因为其范围有限。计划是开发一个示例 Java 应用程序，展示使用 Valhalla 项目组件、值类型和泛型而不是原始类型在内存和性能方面的改进。

Valhalla 项目组件指的是用户定义的自定义不可变原始类型为值类型。

你可以在本章的 Java 虚拟机部分了解更多关于值类型的信息。

曼德布罗特集是混沌理论中使用的分形数学的一个具体例子。随 JDK 8 附带的 MandelbrotSet 示例提供了并行和顺序数据流的比较。在 Java 10 或更高版本中，MandelbrotSet 示例将被更新，以展示使用 Valhalla 项目组件、值类型和泛型与使用原始类型之间的性能和内存效率。

# 高效的数组比较内建函数

未来对 Java 平台的一个变化是包含一个比较数组的函数。目前，这是开发者必须自己编写的。这个变化将通过添加类似于`java.util.Arrays`中的`compareTo`方法来实现。

虽然具体细节尚不可知，但能够使用原生功能比较数组的前景令人兴奋。这将是一个能节省许多开发者时间的组件。这很可能会在 Java 10 平台版本中实现。

# Java 编译器的未来变化

有两个值得注意的 Java 平台草案变更，特别是 Java 编译器。以下列出了这些 Java 增强提案，并在本节中详细说明：

+   退役 javac `-source`和`-target`选项的政策

+   可插拔静态分析器

# 退役 javac -source 和-target 选项的政策

已提交一个正式草案提案，以定义退役`-source`和`-target`选项的政策。这项工作旨在帮助降低编译器的维护成本。`-source`和`-target`选项是为了简化开发工作而提供的，但并非任何标准所正式要求。从 Java 9 平台开始，这些目标选项不再被识别。

新政策被称为“一加三回”，这意味着当前版本将得到支持，以及之前的三个版本。这个政策将延续到 JDK 10。

# 可插拔静态分析器

2013 年夏季启动了一个持续进行的 Java 增强提案研究，作为探索性措施和未来对完整 Java 增强提案的支持，以使开发者能够定义在编译时可以执行任意静态分析的扩展。这项研究旨在了解如何为 Java 编译器实现一个可插拔的静态类型分析器框架。

研究的目标如下：

+   收集静态分析器需求

+   分析静态分析器

+   确定支持静态分析器的框架的要求

+   实施和测试

持续研究最终的结果将是提交一个功能 Java 增强提案，或者建议停止追求该功能。

# Java 虚拟机的未来变化

已提交并起草了几个针对 Java 虚拟机（JVM）和核心库的新功能和增强。这些功能和增强至少有一部分可能会在 Java 10 平台上实现，其他则可能留待后续版本。

# 与 JVM 相关的提交提案

已提交三个 Java 增强提案。虽然目前没有指定为 Java 10，但很可能在 Java 10 发布时我们会看到这些变化。以下列出了这三个提案：

+   容器感知 Java

+   在 GPU 上启用 Java 方法的执行

+   Epsilon GC：任意低开销的垃圾（非）收集器

# 容器感知 Java

正在努力使 JVM 和核心库在运行在容器中时能够感知到。此外，为了能够适应使用可用的系统资源。这个特性与云计算的普遍性特别相关。

提案的功能有两个主要组成部分：

+   检测：

    +   确定 Java 是否在容器内运行

+   容器资源暴露：

    +   暴露容器资源限制

    +   暴露容器资源配置

已初步确定了几个配置状态点：

| **通用** | **CPU 相关** | **内存相关** |
| --- | --- | --- |
| `isContainerized` | CPU 时期 | 块 I/O 设备权重 |
|  | CPU 配额 | 块 I/O 权重 |
|  | CPU 集内存节点 | 当前内存使用率 |
|  | CPU 集合 | 设备 I/O 读取速率 |
|  | CPU 使用率 | 设备 I/O 写入速率 |
|  | 每个 CPU 的 CPU 使用率 | 最大内存使用率 |
|  | CPU 数量 | 最大内核内存 |
|  |  | 内存交换率 |
|  |  | OOM 杀死启用 |
|  |  | OOM 分数调整 |
|  |  | 共享内存大小 |
|  |  | 软内存限制 |
|  |  | 总内存限制 |

初始时，此功能计划支持 Linux-64 上的 Docker。一个可能的场景是，此功能将与 Java 10 一起发布，仅支持 Linux-64 上的 Docker。然后，在 Java 平台后续版本中，将扩展功能支持。

# 在 GPU 上默认启用 Java 方法的执行

启用 Java 应用程序无缝利用 GPU 的能力是 Sumatra 项目的主题。目标是使用 Java 的 Stream API 并行和 lambda 编程模型。利用 GPU 的处理能力和效率对我们来说非常有意义。

总体目标是使此功能对开发者来说易于使用。此功能将具有以下特性：

+   不要更改 Java 并行流 API 的语法

+   硬件和软件堆栈应自动检测

+   自动检测和分析，以确定从性能标准来看使用 GPU 是否合理

+   在将处理卸载到 GPU 失败时提供 CPU 执行

+   将不会出现性能下降

+   此功能不会引入新的安全风险

+   CPU 和 GPU 之间将会有内存持久性

此 Java 增强提案的关键好处将是提高我们的 Java 应用程序的性能。

# Epsilon GC - 随意低开销的垃圾（非）收集器

在第七章中，*利用新的默认 G1 垃圾回收器*，我们详细介绍了 Java 平台发布 Java 9 时对垃圾回收的改进。为了持续改进，已经提交了一个 Java 增强提案，以开发一个专门处理内存分配的垃圾回收器。当 Java 堆上没有更多内存可用时，这个垃圾回收器将向 JVM 发送关闭信号。

目标是让这个垃圾回收器保持被动，并使用非常有限的额外开销。引入这种垃圾回收的目的是不降低性能。

此更改不会影响当前的垃圾回收器。

# JVM 相关的提案

以下 Java 增强提案已为 Java 平台的未来版本制定，并在本节中详细说明：

+   在 JVM 编译方法上提供稳定的 USDT 探测点

+   并发监视器膨胀

+   以低开销方式采样 Java 堆分配

+   诊断命令框架

+   增强类重定义

+   在适当的情况下默认启用 NUMA 模式

+   值对象

+   对齐 JVM 访问检查

# 在 JVM 编译方法上提供稳定的 USDT 探针点

**用户级统计定义跟踪**（**USDT**）用于插入探针点以标记方法的进入和退出。编译器然后允许与跟踪工具进行握手，以便这些工具可以发现探针点并对其进行操作。

常见的跟踪工具有 Dtrace 和**伯克利数据包过滤器**（**BPF**）。

即使是 JVM 9，Java 虚拟机也不支持此技术集。当前缺乏支持源于 JVM 生成编译代码的方式；它以动态方式生成，没有任何静态**可执行链接文件**（**ELFs**）。跟踪工具需要 ELFs 才能工作。另一个缓解因素是 JVM 动态地修补其生成的代码，这些代码不支持外部修补。

在未来的 Java 版本中，可能是 Java 10，**JVMTI**（**JVM 工具接口**）将被修改以支持探针工具在 JVM 的动态编译代码上执行其标准操作。暂时确定的 JVMTI API 更改包括：

+   添加补丁点或方法入口和出口

+   编译方法的枚举

+   编译方法加载时的状态变更通知

+   查询支持

+   切换跟踪点的开关

+   使编译方法的块可检查

好消息是，不需要对 Java 代码的编译方式进行任何更改。它已经可以打补丁，因此所需的功能将通过修改 USDT API 以及 JVM 的一些更改来创建。

# 并发监控降级

在我们的上下文中，监控器是一个同步机制，用于控制对对象的并发访问。监控器有助于防止多个线程同时访问被监控的对象。JVM 自动在三种监控器实现方法之间切换。以下是对三种实现方法的说明：

![图片](img/b68166a9-783d-4b9c-9ab9-d3fa74e08c06.png)

Java 对象的初始锁定使用偏向锁定。该方法确保只有锁定线程可以锁定对象。采用这种方法，JVM 在 Java 对象中安装一个线程指针。当第二个线程尝试锁定 Java 对象时，JVM 切换到基本的锁定监控器实现方法。第二种方法使用**比较和交换**（**CAS**）操作。当 CAS 操作失败时，例如当第二个线程尝试锁定 Java 对象时，JVM 切换到第三种监控器实现方法。该方法是一个完整的监控器。该方法需要本地堆存储，被称为监控器膨胀。

并发监控降级 Java 增强提案的目的是在线程运行时执行监控降级。这将减少由 JVM 引起的暂停时间。

# 提供一种低开销的方式来采样 Java 堆分配

管理不当的 Java 堆可能导致堆耗尽，以及由于内存碎片化（GC 抖动）导致的内存不足。在 Java 的未来版本中，很可能是 Java 10，我们将有一种方法来采样 Java 堆分配。这将通过增强**Java 虚拟机工具接口**（**JVMTI**）来实现。结果的功能将提供一个极低开销的解决方案。

# 诊断命令框架

Java 增强提案 137，诊断命令框架，提议创建一个框架，用于向 Java 虚拟机发送诊断命令。

该框架将包括一个**Java 管理扩展**（JMX）接口，该接口将允许通过 JMX 连接远程发送诊断命令。

JRocket 任务控制工具已经成功实现了这一功能。这证明了概念，因此这一增强功能很可能将成为 Java 10 平台的一部分。

# 增强类重定义

Java 增强提案 159，增强类重定义，要求在运行时增强 JVM 的类重定义能力。具体来说，该提案包括以下类重定义操作：

+   添加超类型

+   添加方法

+   添加静态字段

+   添加实例字段

+   移除方法

+   移除静态字段

+   移除实例字段

当前 JVM 的类重定义能力仅限于方法交换。这被视为非常限制性的。在新提议的增强功能中，开发者不需要在更改后重新启动他们的应用程序。这对于处理大型和分布式系统特别有益。

# 在适当的情况下默认启用 NUMA 模式

Java 增强提案 163，在适当的情况下默认启用 NUMA 模式。此提案仅适用于 NUMA 硬件。目的是当 JVM 检测到 NUMA 硬件时，启用以下标志：

```java
    XX:+UseNUMA
```

当前此标志可以通过手动调用。在提议的增强功能中，当 JVM 检测到它正在 NUMA 硬件上运行时，它将自动调用。

**非一致性内存访问**（**NUMA**）是计算机多处理中使用的内存模型。在这个内存模型中，访问时间取决于内存位置相对于处理器的位置。

这将是一个易于实现的增强功能，并可能成为 Java 10 平台发布的一部分。

# 值对象

Java 增强提案 169，值对象，旨在提供必要的 JVM 基础设施，以允许处理不可变对象以及无引用对象。这个新的基础设施将允许使用非原始数据类型进行高效的按值计算。

本提案的目标包括以下内容：

+   更紧密地对齐`java.lang.Integer`和`int`的语义。

+   使 Java 数据结构更便携

+   支持与 Java 原始数据类型性能相似的性能的抽象数据类型：

    +   用户定义的

    +   库定义的

+   通过启用纯数据函数式计算来优化并行计算

+   改进对以下内容的支持：

    +   复数

    +   向量值

    +   元组

+   提高安全性和安全性

+   减少“防御性复制”

声明的实现策略之一是添加一个`lockPermanently`操作。它将传递一个对象，然后将其标记为不可变且不可别名。永久锁定对象的观念规定：

+   字段不能更改

+   数组元素不能更改

+   无法进行同步

+   无法调用'等待'方法

+   无法调用'通知'方法

+   不允许进行身份哈希码查询

+   无法执行指针相等性检查

这可能是 Java 10 平台最受欢迎的添加之一。

# 对齐 JVM 访问检查

Java 增强提案 181，将嵌套类的 JVM 检查与 Java 语言规则对齐，重点关注将 JVM 访问检查规则与 Java 语言规则对齐的需求，特别是对于嵌套类中的构造函数、字段和方法。这将通过将相关类在嵌套中进行分区来实现。类文件将能够访问同一嵌套中其他类文件的私有名称。

嵌套将共享一个访问控制上下文。随着嵌套的出现，访问桥接将不再需要。大部分的变化将是对 JVM 的访问规则。

# 未来对 JavaX 的更改

`Javax.*`包是两个特定 Java 增强提案的主题，这些提案已提交给未来的 Java 平台发布。以下为这些提案：

+   JMX 特定注解用于注册管理资源

+   现代化 GTK3 外观和感觉实现

# JMX 特定注解用于注册管理资源

标题为“JMX 特定注解用于注册管理资源”的草案 Java 增强提案将提供一组用于注册和配置**MBeans**（**管理 Bean**）的注解。

MBean 是一个表示可管理资源的 Java 对象（应用程序、服务、组件或设备）。

本提案的目标是减轻开发者在注册和配置 MBeans 时的负担。此外，通过确保所有 MBean 声明组件都位于同一位置，将提高源代码的可读性。

JMX 特定注解将位于`javax.management.annotations`包中。

这个 Java 增强提案是专门为 Java 11 规划的。尽管如此，它有可能被重新设计为 Java 10。

# 现代化 GTK3 外观和感觉实现

GTK3 是一个用于创建图形用户界面的小部件工具包，正式名称为 GIMP 工具包。名为“现代化 GTK3 外观和感觉实现”的 Java 增强提案草案呼吁重写当前的 GTK2 外观和感觉，以便使用 GTK3。

GTK3 实现将不会取代 GTK2。重要的是要注意，在运行时只能使用其中一个，而不能同时使用这两个。

您可以在[`developer.gnome.org/gtk3/stable/`](https://developer.gnome.org/gtk3/stable/)访问 GTK3 参考手册。

# 进行中的特殊项目

Java 增强提案（JEP）提出了对 Java 平台的设计和实现更改。一个 JEP 被起草的标准是工作必须至少满足以下条件之一：

+   至少两周的工程工作

+   表示对 JDK 的重大更改

+   代表了开发人员或客户的高需求问题

项目，另一方面，代表了由以下某个团体资助的协作努力：

+   2D 图形

+   采用

+   AWT

+   构建

+   兼容性和规范审查

+   编译器

+   符合性

+   核心库

+   管理委员会

+   HotSpot

+   国际化

+   JMX

+   成员

+   网络

+   NetBeans 项目

+   端口

+   质量保证

+   安全

+   可服务性

+   声音

+   Swing

+   网络

小组是正式的，新的小组可以被提议。

以下列出的活跃项目代表了 Java 平台可能的未来增强领域。本节后面将提供每个项目的简要信息，并提供了对未来变化的一般领域的见解：

+   注解管道 2.0

+   音频合成引擎

+   Caciocavallo

+   Common VM 接口

+   编译器语法

+   达芬奇机器

+   设备 I/O

+   Graal

+   HarfBuzz 集成

+   科纳

+   OpenJFX

+   巴拿马

+   沙南多亚

# 注解管道 2.0

该项目探讨了如何改进 Java 编译器管道中注解的处理方式。没有意图提出更改规范；而是重点在于性能提升。

# 音频合成引擎

该项目正在研究为 JDK 创建一个新的 midi 合成器。当前的 midi 合成器属于一个授权库。工作组希望新的 midi 合成器作为一个开源 JDK 资产。

# Caciocavallo

Caciocavallo 项目旨在改进 OpenJDK 的**抽象窗口工具包**（**AWT**）内部接口。这扩展到 2D 子系统。拟议的改进旨在简化 AWT 移植到新平台的方式。

# Common VM 接口

Common VM 接口项目旨在记录 OpenJDK 的 VM 接口。这应该使 Classpath VM 和其他 VM 使用 OpenJDK 变得更加容易。

# 编译器语法

编译器语法项目正在开发一个基于 ANTLR 语法的实验性 Java 编译器。**ANTLR**（**Another Tool for Language Recognition**）是一个解析器，它读取、处理和执行结构化文本或二进制文件。项目团队希望这个 Java 编译器能够取代当前的编译器，因为它使用的是手写的解析器，**LALR**（**Look-Ahead Left to Right**）。项目小组已将 LALR 解析器识别为脆弱且难以扩展。

# 达芬奇机器

达芬奇机器项目代表了将 JVM 扩展以支持非 Java 语言的努力。当前的工作重点在于允许新语言与 Java 在 JVM 中并存。性能和效率是该努力的关键特性。

# 设备 I/O

该项目旨在通过 Java 级别的 API 提供对通用外围设备的访问。项目团队希望支持的初始外围设备列表包括：

+   **GPIO** （**通用输入/输出**）

+   **I2C** （**集成电路间总线**）

+   **SPI** （**串行外围接口**）

+   **UART** （**通用异步收发传输器**）

# Graal

Graal 项目的目标是通过 Java API 暴露 VM 功能。这种暴露将允许开发者针对特定的语言运行时用 Java 编写动态编译器。这项工作包括开发一个多语言解释器框架。

# HarfBuzz 集成

HarfBuzz 集成项目旨在将 HarfBuzz 布局引擎集成到 Java 开发工具包中。这是为了用 HarfBuzz 布局引擎替换 ICU 布局引擎。ICU 布局引擎已被弃用，这巩固了该项目未来成功的重要性。

# Kona

Kona 项目正在努力定义和实现支持 **物联网** （**IoT**） 领域的 Java API。这包括网络技术和协议。尽管没有明确说明，但安全和安全性将是该努力实施成功的关键。

# OpenJFX

关于 OpenJFX 项目没有太多细节。该项目声明的目标是创建下一代 Java 客户端工具包。根据项目标题，可以假设该小组希望创建一个 OpenJFX 版本的 JavaFX，JavaFX 是一组用于创建富互联网应用的包。

# Panama

Project Panama 专注于增强 JVM 和非 Java API 之间的连接。该项目包括以下选定的组件：

+   原生函数调用

+   从 JVM 进行原生数据访问

+   JVM 堆内的原生数据访问

+   JVM 堆中的新数据布局

+   头文件 API 提取工具

项目团队已生成一个与 JDK 9 结构相匹配的仓库树。这显著增加了项目成功的可能性。

# Shenandoah

Project Shenandoah 的目标是显著减少垃圾收集操作的中断时间。方法是让更多的垃圾收集操作与 Java 应用程序并发运行。在 第七章 中，*利用新的默认 G1 垃圾收集器*，你了解了 CMS 和 G1。Shenandoah 项目打算将并发压缩添加到可能的垃圾收集方法中。

# 摘要

在本章中，我们概述了 Java 平台未来的发展，超出了 Java 9。我们探讨了 Java 10 的计划以及我们可能看到的 Java 10 以上的进一步变化。每个可能的 Java 平台变化都被描述为有针对性的、已提交的或草案。具体来说，我们涵盖了以下类别中 Java 平台的未来变化：JDK 变更、Java 编译器、Java 虚拟机、JavaX 和特殊项目。
