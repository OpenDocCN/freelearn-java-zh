# 第十章：实现用户交互

**用户交互**构成了软件架构中的一个非常重要的层。这一层包括所有终端用户可以接近和使用我们的应用程序的方式，例如 Web 界面和移动应用程序。

因此，用户交互需要非常注重细节地实现。一个设计糟糕、性能不佳的用户界面会损害整体的用户体验，即使应用程序的其他部分编写得很好并且性能真的很出色。实际上，用户界面可以使用许多不同的技巧来隐藏软件架构其他层（即*后端*）中存在的问题（如性能问题）。

在本章中，我们将探讨 Java 应用程序最广泛使用的技术，无论是云原生应用程序还是传统应用程序。

这将包括使用**Java 企业版**平台（如**Jakarta Server Pages**和**Jakarta Server Faces**）构建的框架，以及用于单页应用程序的更现代的 JavaScript 框架（在我们的例子中是 React）。

在本章中，你将了解以下主题：

+   用户界面架构——后端与前端

+   使用 Jakarta Server Faces 和 Jakarta Server Pages 构建的 Web 用户界面

+   介绍单页应用程序

+   了解移动应用程序开发

+   探索 IVR、聊天机器人和语音助手

+   企业应用程序的多渠道策略

让我们先集中精力研究用户交互层的架构，或者更确切地说，每个组件和功能应该放在哪里。我们将涉及为我们的应用程序构建前端层的架构方面。

# 用户界面架构——后端与前端

讨论一个**用户界面**（**UI**）必须存在于何处可能看起来很荒谬。毕竟，这几乎是肯定的——UI 是软件架构的前沿，提供与最终用户的交互，因此它必须保持在最前面，这就是为什么我们使用*前端*这个术语，它被用作 UI 的同义词。毫无疑问，每个人都同意这一点。

除了它并不容易划出一条线来界定 UI 的起始和结束之处。而且，根据特定的实现方式，许多不同的组件可能提供构建我们最终希望向客户展示的体验所需的功能。UI 将由以下组件组成，或多或少：

+   **资产**，也称为静态文件：这些是必须发送到我们的客户端的 Web 应用程序的组成部分（在相关的情况下）。通常包括 HTML 文件、JavaScript 脚本、其他图形元素（图像、CSS 文件和电影剪辑），甚至完全构建的自包含应用程序（如移动应用程序的情况）。

+   **数据**：这是使用资产显示的内容。这意味着需要一种方式来检索更新（通常涉及 Web 服务或类似技术）。

+   **行为**：这指的是 UI 如何响应用户输入和其他事件。这是一个更广泛的概念，包括*交互性*（当用户做某事时，什么会改变以及如何改变），*验证*（检查用户输入的正式和实质性一致性），*导航*（如何依次显示不同的视图或页面以实现用户请求的功能），以及*安全*（如何确保每个用户都得到适当的识别和配置文件，只能做他们被允许做的事情，并且只能访问适当的数据集）。

重点是或多或少这样——不同的实现将会有不同的方式向最终用户提供资源，不同的方式提供（和收集）数据，以及不同的行为实现（例如，在客户端或服务器端实现导航或验证）。在本章中，我们将探讨安排所有这些组件以提供良好用户体验的最常见方式。我们下一节将介绍在 Java 企业版中实现这一点的最传统方式——Jakarta Server Faces 和 Jakarta Server Pages。

# 使用 Jakarta Server Pages 和 Jakarta Server Faces 的 Web 用户界面

如果你曾经与 2000 年至 2015 年间开发的 Java 企业应用程序合作过，那么你很可能已经看到了**Java Server Pages**（**JSP**）和**Java Server Faces**（**JSF**）的实际应用。现在这两个技术广泛被认为是过时的，但它们仍然在现有的 Java 部署中广泛使用，至少从历史的角度来看是值得了解的。

## 介绍基本的 Java Web 技术——Jakarta Server Pages

**Jakarta Server Pages**（以前称为 Java Server Pages）本质上是一种模板技术，允许你将用 Java 编写的动态内容与静态内容（通常用 HTML 编写）混合。通过使用 JSP，应用服务器可以构建一个网页提供给客户端（并在网页浏览器中可视化）。我们已经在*第六章*《探索 Java 关键架构模式》中讨论了 JSP，当时我们谈到服务器端的**模型-视图-控制器**（**MVC**）。如果你还记得，JSP 在 MVC 模式中扮演着*视图*的角色。在相同的情况下，我们还提到了 servlet 作为另一个核心组件，负责 MVC 的*控制器*部分。

现在是时候阐明 servlet 和 JSP 之间的关系了。假设你们大多数人已经知道什么是 servlet，我将只提供一个非常简短的描述。

当 servlet 被加载时调用的`init()`，以及在被卸载前调用的`destroy()`，而其他的是在针对 servlet 执行 HTTP 操作时调用的（例如，`doPost(...)`来处理 HTTP `POST`请求，以及`doGet(...)`来处理`GET`请求）。

到目前为止一切顺利！Servlet 是专门用于处理 HTTP 对话的组件，因此它们被用来补充视图（如 JSP 文件），以提供用户体验功能（如表单提交和页面导航）。正如我们讨论的，servlet 通常作为*控制器*，而 JSP 文件则用作*视图*，尽管已经开发出更复杂的框架来处理 JSP，如 Struts 和 Spring MVC。

但还有一个值得注意的点——JSP 文件本质上也是 servlet。

事实上，JSP 文件只是实现 servlet 的一种不同方式。在运行时，每个 JSP 文件都被运行我们代码的应用服务器转换成 servlet。正如我们在*第七章*中讨论的，*探索中间件和框架*，我们需要一个完全或部分符合 JEE 规范的应用服务器来运行每个 JEE API（包括 servlet 和 JSP API）。

因此，现在我们知道了 JSP 是一种模板技术，并且每个 JSP 文件都被转换成 servlet，它输出我们在模板中建模的内容，是时候看看 JSP 文件的样子了。

JSP 文件与`<% ... %>`有些相似，这被称为**脚本片段**，其中包含任意 Java 代码。当客户端请求页面时，脚本片段会被执行。

JSP 中使用的另一个标签是用`<%= %>`标记的，称为`<%@ ... %>`，用于配置页面元数据。一个非常基本的 JSP 页面可能看起来像这样：

```java
<%@ page contentType="text/html;charset=UTF-8" 
  language="java" %>
<%@ page import = "java.util.Date" %>
<%@ page import = "java.text.SimpleDateFormat" %>
<html>
    <head>
        <title>Simple JSP page</title>
    </head>
    <%
      SimpleDateFormat sdf = new SimpleDateFormat("dd-MM-
        yyyy HH:mm:ss");
      String date = sdf.format(new Date());
    %>
    <body>
        <h1>Hello world! Current time is <%=date%> </h1>
    </body>
</html>
```

值得注意的一些事项如下：

+   在文件顶部，使用指令。它们定义了一些元数据（页面内容类型和使用的语言）以及要在页面上导入和使用的 Java 包。

+   在脚本中穿插了一些 HTML 代码。脚本分隔符内的代码对 Java 开发者来说很容易识别，因为它只是格式化日期。

+   在第一个脚本片段中，我们定义了`date`变量。然后我们可以在`<h1>`HTML 标签内的表达式中访问它。该表达式简单地引用了变量。然后引擎将在生成的 HTML 页面中的该位置替换变量的值。

在实际应用中，我们可以想象一些使用这种语法的有用方式：

+   我们可以使用脚本片段通过调用外部服务或使用数据库连接来检索有用的数据。

+   在脚本片段中使用 Java 代码，可以轻松实现迭代（通常用于显示表格数据）并以首选方式（在脚本片段和表达式中）格式化数据。

+   脚本片段中的 Java 代码可以用来获取和验证用户提供的（通常使用 HTML 表单）数据。此外，用户会话和安全可以以不同的方式管理（通常通过利用 cookie）。

值得注意的是，JSP 指令可以用来包含其他 JSP 文件。这样，逻辑可以模块化并重用。

此外，JSP 允许定义自定义标签库。这样的库是包含个性化标签的集合，这些标签在标签被使用时执行自定义逻辑。一个广泛使用的标签库是 JSP 实现默认提供的，即**Jakarta Standard Tag Library**（**JSTL**）。为了使用标签库（在这种情况下是 JSTL 核心），我们需要使用指令来导入它，如下所示：

```java
<%@ taglib prefix="c" 
  uri="http://java.sun.com/jsp/jstl/core" %>
```

JSTL 提供了一套标签，提供了以下功能：

+   `Core`提供基本功能，如流程控制（循环和条件块）和异常处理。

+   `JSTL`主要用于字符串操作和变量访问。

+   `SQL`实现基本的数据库连接处理和数据访问。

+   `XML`用于 XML 文档操作和解析。

+   `Formatting`是一组用于根据字符编码和区域设置格式化变量（如日期和字符串）的函数。

因此，我们之前示例中使用的日期格式化可以通过适当的 JSTL 标签（从`Core`和`Formatting`集合中包含）总结如下：

```java
...
<c:set var = "now" value = "<% = new java.util.Date()%>" />
<fmt:formatDate pattern=" dd-MM-yyyy HH:mm:ss " 
  value="${now}" />
   <body> 
         <h1>Hello world! Current time is <%=date%> </h1> 
     </body>
...
```

即使 JSTL 标签旨在减少 JSP 文件中的 Java 代码量，但完全删除*所有*Java 代码仍然非常困难。将 Java 代码与展示代码混合被认为是应避免的反模式，而且这并不是唯一需要考虑的因素。在下一节中，我们将看到为什么 JSP 被认为是遗留技术，并且今天几乎每个 Java 项目都依赖于不同的前端开发选项。

## JSP – 不足之处

现在，是时候看看坏消息了。有许多原因使得 JSP 如今被广泛认为不适合现代应用程序。我可以总结其中的一些原因：

+   JSP 允许 Java 代码与 HTML 代码交织在一起。正因为如此，将展示逻辑与业务逻辑混合变得非常容易。结果通常是一个丑陋的混乱（尤其是在大型应用程序中），因为展示逻辑滑入 Java 代码（如条件格式化和复杂循环）变得很有诱惑力，最终结果是既难以阅读又难以维护的 JSP 页面。

+   由于类似的原因，不同技能团队之间的协作非常困难。前端团队（如图形设计师）应该负责处理 JSP 文件的 HTML 部分，而同一文件可能同时被后端团队修改以添加与业务逻辑相关的功能。这导致了一种难以解决的资源争用，因为每个团队都可能破坏其他团队的实现。

+   专注于前端开发，开发周期繁琐，且周转速度慢。前端开发人员和图形设计师习惯于编辑 HTML 文件，刷新浏览器，并立即看到结果。使用 JSP，这根本不可能；通常，项目必须重建为一个工件（如 `.war` 文件），并重新部署到应用程序服务器。对于这个问题可能有解决方案（例如爆炸式部署，其中 `.war` 文件作为提取的文件夹部署），但它们通常根据应用程序服务器而有所不同，并且可能有一些缺点（例如，可能无法涵盖文件的所有不同类型的修改，或者在执行次数过多时可能导致内存不足异常）。

+   这引出了另一个非常重要的观点——JSP 文件需要一个完全或部分实现 JEE 规范的应用程序服务器。**Apache Tomcat** 是这里的一个常见选择。确实，你将需要一个 **Java 虚拟机**（**JVM**）和一个运行在顶部的应用程序服务器（如 Tomcat），这意味着需要稍微更强大的机器，并且需要进行更彻底的微调和安全性测试（仅仅因为 Java 应用程序服务器比静态文件服务的 Web 服务器更复杂，并不是因为 Java 本身就不安全）。此外，前端开发人员将需要使用这个服务器（可能在他们的本地工作站上）进行开发目的（这可能不是最简单的事情来管理）。

+   JSP 缺乏在不同页面和应用程序之间共享组件的简单方法。此外，JSP 标签通常使用起来有些繁琐，尤其是在复杂的应用程序中。

+   此外，与单页应用程序相比，JSP 应用程序的整体性能较差。现代单页应用程序的 JavaScript 框架确实是为了将数据与服务器之间的交换保持在最低限度而设计的——在你第一次下载 HTML 文件和资产之后，然后才会进行数据交换。仅用 JSP 实现这一点并不容易，因为 JSP 通常是为了渲染服务器端页面并将其作为一个整体下载而设计的。

+   最后，从架构角度来看，JSP 的内在特性使得事情变得更加复杂。因为在一个 JSP 文件中，你可以使用 Java 代码，这涉及到调用后端服务和执行 SQL 查询，调用流程可能会变得复杂和混乱。*你真的需要从前端直接连接到数据库吗？* *后端暴露的服务怎么办？* 与之相反，你将拥有业务逻辑和数据操作散布在前端层，而不是一个薄薄的前端层，主要用于可视化和交互。从架构角度来看，这并不是最佳情况。

因此，现在我们已经了解了 JSP 的基础知识，JSP 是一个完整的模板引擎，用于定义 HTML 网站，并提供一些用 Java 编写的动态内容。我们也已经了解了这项技术的局限性。现在值得注意的是，JEE 提供了一个更复杂、更完整的框架来构建 Web 应用程序，这就是 Jakarta Server Faces。

## Jakarta Server Faces – 一个复杂的 JEE Web 技术

**Jakarta Server Faces** (**JSF**) 相比于 JSP 是一个更加完整（且复杂）的框架。它实现了 MVC 模式，并且更加具有指导性和观点性。这意味着诸如变量绑定、页面导航、安全和会话处理等概念是框架的核心概念。它还提供了一个以组件为中心的视图，这意味着它提供了可重用的组件，包括复杂的视图功能，如表格、表单、输入和验证。

根据 MVC 模式的 *视图* 组件，JSF 以前依赖于 JSP 模板。在更近的实现中，这已被默认切换到 **Facelets**，这是一种基于 XML 的模板技术。

JSF 的 *控制器* 部分由一个特殊的 servlet，**FacesServlet**，实现，它负责资源初始化、生命周期和请求处理等事务。

最后，JSF 的 *模型* 部分是通过所谓的 *管理 Bean* 实现的，这些管理 Bean 简单来说就是具有一组属性、获取器和设置器的 Java 类。管理 Bean 用于绑定到页面和页面中的组件，包含要显示的值、验证用户输入和处理事件。管理 Bean 可以配置为在不同的范围内存在，包括会话（附加到 HTTP 会话）、请求（与 HTTP 请求相同）和应用（在整个 Web 应用程序的生命周期内存在）。

有许多不同的 JSF 实现，其中最著名的是 **Mojarra JSF**（由 Oracle 支持）。其他项目扩展了这种实现，同时也提供了一套可重用的组件。最著名的是 **RichFaces**（由 Red Hat 支持，许多年已停止开发），**IceFaces** 和 **PrimeFaces**。

这是对 JSF 内部架构和基础的一个概述。在不深入太多细节的情况下，让我们像分析 JSP 一样，分析 JSF 的缺点。

## JSF – 缺点

首先，让我们说，虽然 JSP 目前被认为是过时的技术，但有时仍然用于一些基本任务（例如简单的内部网络界面，如管理面板），但 JSF 在今天尽可能避免使用。原因在于，除了 JSP 的缺点之外，JSF 还增加了一些。以下是我对它的看法：

+   **JSF 非常难以学习**：虽然基本任务很容易完成，但 JSF 在幕后做了很多事情，例如管理页面生命周期和构建有状态的会话，这些都非常难以掌握。因此，它通常被错误地使用，或者只利用所有提供功能的一小部分，这使得它对于大多数网络应用来说都是过度设计且难以管理的。

+   **JSF 难以测试**：可以为某些组件（如管理 Bean）编写单元测试，但自动执行所有测试非常困难，尤其是在*视图*方面（Facelets），主要是因为几乎不可能从该层中移除逻辑（而且，正如我们所知，在*视图*层中包含逻辑是一个糟糕的想法）。

+   **JSF 难以调试**：由于，正如我们所说，JSF 在幕后管理很多事情（尤其是浏览器中处理的变量与托管 Bean 中包含的值之间的绑定），很难理解出错的原因（例如变量未更新和性能问题）。

+   **JSF 缺乏一些小但非常有用的特性的适当实现**：首先想到的是 AJAX 通信（在网页上的一些值可以在不重新加载整个页面的情况下更新）和友好的 URL（当页面的 URL 可以自定义时，这很有帮助，因为它使得它易于阅读并且受到搜索引擎的青睐）。对于这两个特性，有一些解决方案，但它们是不完整的、非标准的，并且在一般情况下是在框架中较晚添加的。这些只是两个例子，但还有很多；这都归因于框架的一般僵化。

上述要点足以说明为什么，到目前为止，几乎每个人都同意 JSF 是一种过时的技术，不应该在新项目中采用。

因此，提供 JSF 的代码示例是没有意义的。

在本节中，我们探讨了使用 JEE 框架构建的两个主要网络技术。正如我们所见，这些技术，尽管它们仍然被广泛使用，但有一些很大的局限性（尤其是 JSF），主要来自它们的*单体*方法，这意味着它们与后端实现紧密耦合，并且它们的灵活性有限。

在下一节中，我们将探讨广泛使用的 JEE 原生网络技术的替代品——单页应用程序。

# 介绍单页应用程序

**单页应用程序**（或**SPA**）是一个广泛的概念，用来简单地描述一些旨在以更轻量、更现代的方式创建网络 UI 的解决方案的行为。SPA 的第一个特征就是与它的名字相关。一般来说，SPA 将启动用户交互所需的所有资产打包到一个单独的 HTML 文档中，并将其发送到客户端。

所有的客户端和服务器之间的交互，包括加载数据、发送数据回服务器以及加载其他资源（如图像或 CSS 文件），都是通过 JavaScript 在页面内完成的。因此，SPA 最小化了客户端和服务器之间的通信（提高性能），避免了整个页面的刷新，并允许更简单的架构模型。

事实上，在前端（不需要 Java 应用服务器）上，你只需要一个基本的、静态的文件服务型网络服务器（例如 **Apache HTTPD** 或 **NGINX**）。此外，客户端和服务器之间的交互几乎完全局限于对 Web 服务的调用（通常是 REST 上的 JSON），因此混合后端和前端逻辑（例如从前端层执行 SQL 查询）是高度不建议的。我认为单页应用（SPA）最显著的缺点是它们没有标准化。与 JEE 技术不同，每个框架在这里都提供自己的不同方法。

因此，存在许多不同、编写良好但不兼容的框架实现，用于构建 SPA。大多数（如果不是所有）都严重依赖 JavaScript，并且与后端使用的任何技术无关（只要后端可以公开一个兼容的服务层，如 REST 上的 JSON）。在这种情况下，我们假设提供了一个 Java 后端（JEE 或更现代的版本，公开 REST 服务）。

但是，对于更简单的项目来说，采用全栈方法（在后台也使用 JavaScript，通常在**Node.js**服务器上运行）或使用不同的后端技术（如 Python 或 PHP）并不少见。为了本章的简洁性，我们将仅探讨一个 SPA 框架，**React**，它由 Facebook 支持，广泛用于构建从小型网站到大型和流行的平台（如社交网络）的 Web 应用程序。但值得注意的是，还有许多类似强大的替代方案（如 Angular、Vue 和 Svelte），由于没有提供标准，无法保证任何此类技术的生命周期，也无法轻松地将一种实现中编写的代码移动到另一种实现中。为了开始尝试 SPA，需要先对 JavaScript 生态系统有一个概述。

## JavaScript 生态系统基础

我猜这本书的大多数读者都是初学者或经验丰富的 Java 开发人员和初级架构师，对 JavaScript 接触很少或没有接触。当然，JavaScript 是一个庞大而有趣的世界，无法在几段文字中完全描述，所以本节的目标只是给你一些基础知识，足够用于接下来的几节，这些章节将专注于 React。

JavaScript 诞生于 1995 年，主要用于在网页浏览器内编程。最初是为 Netscape 设计的，当然后来作为大多数主要网页浏览器的一部分得到实现。尽管名字看起来非常相似，但 JavaScript 与 Java 语言并没有太多相似之处，它是被解释的（而 Java 被编译成字节码）和动态类型的（所以它在运行时检查类型安全，而 Java 是静态类型的，在构建时检查类型安全）。还有许多其他差异，包括对象模型、API 和依赖管理。JavaScript 已经被标准化为一个名为**ECMAScript**的技术规范。

另一个重要的话题是 Node.js。正如之前提到的，JavaScript 最初是在嵌入到网页浏览器中的引擎中执行的，而 Node.js 是一个独立的引擎，能够在网页浏览器之外执行 JavaScript 代码。Node.js 用于服务器端开发，而 JavaScript 通过实现 Web 服务和与其他组件（如数据库）集成来开发服务器端逻辑。

我提到 Node.js 的原因并不是它作为后端服务器的用途（或者至少，在这个特定上下文中并不相关），而是因为它已经发展成为一个完整的 JavaScript 开发工具箱。确实，它包括**Node 包管理器**（**npm**），这是一个 JavaScript 依赖管理的实用工具（在 Java 世界的 Maven 概念上类似）。

此外，它经常被用作 JavaScript 开发的本地服务器，非常轻量级，支持热更新。最后但同样重要的是，许多客户端 SPA 框架（包括 React）为 Node.js 提供了实用工具，如命令行界面，这些界面对于创建新应用程序的框架、打包分发等非常有用。现在我们已经了解了当前 JavaScript 开发的基础，是时候看看本章所选的框架 React 了，下一节将详细介绍。

## 介绍 React 框架

**React**（也称为**ReactJS**）是一个用于构建单页应用（SPAs）的 JavaScript 框架。React 的一个非常有趣的特点是，它不仅可以用来构建通过网页浏览器访问的 Web 应用，还可以（通过 React Native 项目）用来构建在移动平台（Android 和 iOS）和桌面（Windows 和 macOS）上执行的原生应用。

React 在方法上非常简单，其基础是组件的概念（关于这一点很快就会详细介绍）。此外，它也非常高效，因为它使用了**虚拟 DOM**的概念。

许多 JavaScript 框架通过直接访问和修改**文档对象模型**（**DOM**）来创建网页和交互。DOM 基本上是浏览器渲染的 HTML 文档的标准对象表示，以 HTML 标签为起点，形成一个树状结构。

React 使用这种替代方法来构建一个自定义对象（称为虚拟 DOM），它是 DOM 的部分表示，模拟 DOM 本身期望的状态（因此是 Web 应用程序的外观和行为）。React 应用程序作用于这个表示。然后是框架将 DOM 与虚拟 DOM 进行比较，并只对 DOM 进行必要的更新，以有效和高效的方式改变它。

### JavaScript 语法扩展

**JavaScript 语法扩展**（**JSX**）是与 React 广泛使用的技术。它看起来类似于 HTML，并提供了将 JavaScript 代码与 HTML 标签混合的能力。考虑到这一点，它可以被视为一种模板技术，与我们在前面几节中看到的 JSP 没有太大区别。还值得注意的是，就像 JSP 将我们写的所有内容转换为 Java 代码（特别是使用 Java 代码输出 HTML 的 servlet）一样，JSX 也完全一样，将 JSX 代码转换为 JavaScript 代码，生成正确的 HTML。

值得注意的是，在 JSX 的世界里，混合 JavaScript 和 HTML 并不被视为反模式，反而被鼓励（并且经常这样做）。这是因为即使你用 JavaScript 实现复杂的逻辑，这种逻辑大多涉及前端相关的行为（例如何时显示一个组件和可选的格式化），因此你不太可能将不属于前端的东西（如业务逻辑）污染前端代码。

JSX 之所以如此受欢迎，是因为它可以使用非常紧凑和易于理解的语法来定义 React 组件。这是一个基本的 React 组件可能的样子，不使用 JSX：

```java
React.createElement('h1', {className: 'welcomeBanner'}, 
  `Welcome to our payment system, ${user.fullName} ! `);
```

这就是如何使用 JSX 实现相同组件的方法：

```java
  <h1 className="welcomeBanner">
    Welcome to our payment system, {user.fullName} !
  </h1>
```

因此，在可读性和有效性方面的优势是显而易见的。在更复杂的情况下，这种优势会更加明显，例如，在包含其他标签的标签中（如 HTML 列表或其他嵌套标签）。

可读性和易用性并不是 JSX 的唯一品质。重要的是要注意，JSX 默认情况下还会防止注入攻击。**注入攻击**是指，通过各种技术，恶意用户将自定义代码（如 JavaScript 代码或任意 HTML 内容）注入到你的页面中。JSX 默认情况下会清理输出，因此无需开发人员做出任何努力，就可以中和这种攻击。此外，JSX 是一种相当完整的语言，可以嵌入条件和循环，调用其他函数等。它是构建 React UI 的非常强大的工具。

既然我们已经提到了 React 组件，现在解释它们是什么以及它们是如何工作的是很重要的。

### 介绍 React 组件

**组件**是 React 的核心概念。它基本上是一个小型、可嵌入的 UI 片段，包括结构、外观和行为逻辑，可以重复使用。

从技术角度来看，React 组件是 JavaScript 函数或类。组件默认接受一个 `props` 参数，它基本上是一个封装了要传递给组件的（可选）属性的（可选）对象。因此，这是一个使用 `function`（和 JSX）建模的组件：

```java
function HelloWorld(props) {
  return <h1> Welcome to our payment system, 
    {props.fullName}</h1>;
}
```

这同样是使用类的一个组件：

```java
class HelloWorld extends React.Component {
  render() {
    return <h1> Welcome to our payment system, {this.props. 
      fullName}</h1>;
  }
}
```

如你所见，组件，无论是定义为函数还是类，基本上是围绕一个 JSX 模板包装的，该模板代表要渲染的 HTML 代码。无论你如何定义它，你都可以将其用作标签，在这种情况下是 `<HelloWorld/>`，它将被执行组件逻辑评估的结果所替换。值得注意的是，要传递属性，你可以简单地使用标签属性，这些属性将作为 `props` 对象的一部分传递。因此，在我们的例子中，要传递 `fullName`，只需将组件用作 `<HelloWorld fullName="Giuseppe Bonocore"/>` 即可。

你可能已经注意到，当定义为类时，我们通过 `render` 方法添加我们的展示。默认情况下，也可以使用 `constructor` 方法，它接受 `props` 作为参数。这种方法可以用来初始化组件。如果你需要在组件中管理状态（例如，当保存本地变量时），你可以通过访问 `this.state` 对象来实现。

当然，这样的对象也可以被修改，为此值得使用 `this.setState` 方法，这将通知 React 组件的状态中发生了变化（也许视图中的某些内容需要更新）。当与 UI 事件相关联时，这尤其有用，例如按钮的点击。以下代码片段表示一个带有按钮的组件。每次用户点击按钮时，计数器都会增加并保存到组件的本地状态中：

```java
class Counter extends React.Component {
  constructor(props) {
      super(props);
      this.state = {counter: 0};
    }
  render(props) {
     return (
      <div>
        <h2>You have clicked {this.state.counter} times 
          !</h2>
        <button onClick={() => this.setState({ counter: 
          this.state.counter + 1 })}>
            Click Me!
        </button>
      </div>  
    );
  }
}
```

当然，从这里开始，可以设计更复杂的事件处理和内部状态管理的组合。最后但同样重要的是，还有许多与 React 组件生命周期步骤相关的回调函数，例如在组件在网页上渲染后调用的 `componentDidMount`（但还有许多其他类似的生命周期钩子）。

### React 应用程序结构

现在，我们有一些关于如何创建组件以及在哪里放置我们的展示标记和业务逻辑的基本信息。*但是我们应该如何开始创建一个基本的 React 应用程序并应用我们刚刚学到的概念呢？*

最常见和简单的方法是使用 `npm` 工具，正如我们在前面的几个部分中看到的，它随 Node.js 服务器一起提供。为了下载和安装 Node.js 服务器，你可以参考官方网站 [`nodejs.org/it/download/`](https://nodejs.org/it/download/)。

一旦你有了 Node 的工作环境，只需运行以下命令即可：

```java
npx create-react-app myAppName
```

当然，您需要根据需要更改 `myAppName`。Node.js（和 `npm`）将下载所有必要的依赖项并创建基本 React 应用程序的结构和脚手架。

这样的结构可能如下所示（省略了一些文件）：

```java
myAppName /
       README.md
node_modules/
package.json
       public/
index.html
src/
index.js
App.js
```

最重要的文件如下：

+   `README.md` 是与您的项目关联的自动生成的 *readme* 文件，用于文档目的。

+   `node_modules` 包含 JavaScript 依赖项。

+   `package.json` 包含项目元数据，包括所需的依赖项。

+   `public/index.html` 是页面模板。

+   `src/index.js` 是作为第一个文件（入口点）执行的 JavaScript 文件。

+   `src/App.js` 是由 `create app` 工具生成的实际标准。它基本上是一个宏组件，它包括所有组件并在 `index.js` 文件中引用。

因此，这就是标准的空文件夹结构。为了添加我们自定义的组件，根据我们之前的示例，我们可以在 `src` 中创建一个 `components` 子文件夹。

包含组件的每个文件都将是一个以组件名称命名的 `.js` 文件（*首字母大写*）。对于我们之前的组件示例，那将是 `Counter.js`。

该文件应声明导入的依赖项（至少 React）：

```java
import React from "react";
```

然后，使此组件可供其他组件使用（文件中的最后一行）：

```java
export default Counter;
```

为了在我们的应用程序中使用此类组件，我们需要将它们导入到我们的 `App.js` 文件中，如下所示：

```java
import Counter from "./components/Counter";
```

然后，我们可以将它们用作标签（`<Counter/>`）在我们的 JSX 内容中。

最后，为了测试我们的 React 应用程序，您可以从项目文件夹中执行此命令：

```java
npm start
```

这将执行 `node.js` 服务器并将浏览器打开到正确的页面（`http://localhost:3000/`）以查看您的应用程序正在运行。React 应用程序的一个重要方面是如何与后端 API 交互。我们将在下一节中探讨这一点。

### 与 REST API 交互

我们到目前为止所看到的基本上是展示和行为。为了实现一个真实的应用程序，一个非常重要的特性是向后端发送请求。一个常见的方法是调用 REST API。

从 React 应用程序调用 REST API 的标准方式是使用 `axios` 库。

要在 React 中安装 `axios` 依赖项，您可以使用 `npm` 命令：

```java
npm install axios
```

然后，您需要将库导入到将要进行 REST 请求的组件中：

```java
import axios from 'axios';
```

然后，您可以使用 `axios` 进行常规的 REST 调用（`GET`、`POST` 等）。这是一个快速片段，用于从 API 读取数据并将其保存到本地状态中的 REST `get` 调用：

```java
axios.get(`http://localhost:8080/rest/payments/find/1`)
  .then(response => response.data)
        .then((data) => {
          this.setState({ data: data })
          console.log(this.state.data)
         })
```

当然，这个例子可以扩展以使用其他 REST 动词。

### React –从这里开始

前几节的目标是让您体验一下使用客户端 JavaScript 框架编写网络界面的感觉。React 在撰写本文时是最受欢迎的选择之一，因此我认为学习至少它的基础知识是一个很好的投资。然而，我们刚刚学到的内容远未完整。以下是我建议更深入探索的几个更多主题：

+   表单和事件处理，以便实现丰富的用户交互，包括验证和文件上传

+   高级可视化，如列表、表格和条件格式化

+   打包和部署到生产环境，考虑到文件大小优化、渐进式网络应用程序和最佳实践

+   React Native，或者如何针对替代平台，如 Android、iPhone 和桌面应用程序

+   路由（由 React Router 依赖项提供），它提供了一种在不同视图之间实现导航的方法

在某些情况下，React 提供了解决方案，而其他时候则需要第三方插件。网上有许多资源；我建议从官方 React 网站和 *进一步阅读* 部分列出的其他资源开始。

让我们快速回顾一下 Java 前端开发随时间的发展：

![Figure 10.1 – The evolution of frontend development in Java]

![Figure_10.1_B16354.jpg]

Figure 10.1 – The evolution of frontend development in Java

如我们所见，**Servlet** 是第一种方法，尽管有其局限性，但仍然在某些基本用例和作为更复杂框架的辅助技术中有所使用。对于在 **Servlet** 之后不久引入的 **JSP** 也是如此，它提供了一些优势（例如，拥有一种标记语言，允许在不直接使用 Java 代码的情况下进行开发）。

随着时间的推移，JSP 的使用已经放缓，但它仍然用于一些用例。**JSF** 在 **JSP** 之后开始获得关注，但很快停止了流行，现在几乎完全被遗弃，基本上只用于遗留应用程序。基于框架（如 React）的 SPAs（单页应用程序）随后出现，现在非常流行且广泛使用。

通过本节，我们完成了对网络框架的概述。在下一节中，我们将探讨移动应用程序开发。

# 了解移动应用程序开发

移动应用程序开发与网络应用程序开发共享许多概念（和挑战）。然而，也存在一些核心差异。在本节中，我们将分析一些在设计移动应用程序架构时需要记住的核心概念。

在这个背景下，我们主要是指移动应用程序作为进一步访问由更复杂的生态系统提供的功能的渠道，这个生态系统也可以通过其他方式（至少是通过 Web 前端）访问。此外，本节中提出的许多考虑因素应从企业角度来考虑。因此，当然，如果你在另一个环境中工作（如初创公司），你的体验可能会有所不同。首先，让我们先看看为什么我们应该考虑开发移动应用程序作为实现与我们的功能和功能交互的一种方式。

## 移动应用程序的重要性

在当今世界，指出移动应用程序往往是我们的第一个接触点，例如银行、购物和娱乐等服务，是一件轻而易举的事情。

世界上大约有 70 亿移动用户，越来越多的人拥有一个或多个移动设备（智能手机和平板电脑），而不是笔记本电脑或台式 PC。

移动设备通过应用程序权限设置和应用程序商店提供了一个受控的环境，虽然稍微有些限制，但大大提高了稳定性和性能标准。这通常是选择应用程序交互而不是 Web 交互的关键原因——它通常提供更标准化的用户体验和更简单的访问。

然后，当然，还有便利性——使用你口袋里的设备完成任务，无论是购买东西还是获取一些信息，都比使用笔记本电脑或台式 PC 要容易得多。

最后但同样重要的是，移动设备配备了传感器和功能，这对于提供集成体验至关重要。我可以在搜索餐厅的同时立即给他们打电话预订桌子或询问路线，在开车去那里的过程中。

考虑到所有这些，如今在开发用户交互时考虑*以移动为先*的用户体验是默认的立场。但有许多挑战需要考虑。

## 移动应用程序开发的挑战

当谈到移动应用程序的开发时，首先想到的问题就是**碎片化**。在 Web 应用程序中，现代浏览器几乎消除了设备之间的不兼容性，确实，今天无论你是在 Macintosh、Windows 还是 Linux 机器上使用 Firefox、Chrome 还是 Edge，你都会获得相同的用户体验。而且现代框架（如我们之前看到的 React）几乎可以毫不费力地创建这样的统一体验。

很不幸，这一点并不适用于移动设备：

+   首先，你需要考虑的是设备形态。不同型号的智能手机有不同的屏幕尺寸和比例。它们可以用于横屏或竖屏模式。平板电脑设备更是增加了更多的变体。

+   硬件资源可能有限。复杂动画或高度交互式功能的渲染可能会降低低端设备的速度。

+   连接性可能不稳定。你必须管理当带宽低或出现网络中断时你的应用会发生什么。

+   设备通常提供额外的硬件，例如传感器、摄像头和 GPS。然而，你必须管理当你有权限访问这些设备时会发生什么，以及当它们被拒绝时会发生什么。

最后但同样重要的是，在撰写本文时，至少有两个生态系统需要考虑，即谷歌和苹果，它们拥有不同的分发渠道、不同的支持服务（例如通知和更新），以及不同的编程语言和框架。这一点我们将在下一节中更详细地讨论。

## 移动应用程序开发选项

自从移动应用程序开发开始以来，一个常见的话题是如何管理不同的平台（至少是谷歌和苹果），以及是否有一种方法可以部分重用为其他平台（如网络）开发所付出的努力。

减少碎片化并利用网络开发努力的第一个可行选项是完全放弃移动应用程序开发，转而开发针对移动设备的优化网页应用。这是一个明智的选择，因为随着现代网络开发框架和语言（如 HTML5 和 CSS3）的出现，针对移动设备的目标变得容易实现。

这些技术除了使创建适合移动优化布局的响应式设计变得容易之外，还建立了一个标准，用于访问最常见的移动功能，例如位置跟踪（通过 GPS）、摄像头和麦克风。

这种方法的最重要的好处是我们可以管理单一的代码库。即使我们想要区分移动和网页版本的用户界面（这是我们的选择——我们甚至可以只有一个版本），至少我们可以在所有移动设备上拥有一个单一版本，无论其底层技术如何。第二个好处是我们可以将发布过程保持在应用商店之外，因此我们不受通常由这些分发渠道实施的时机和规定的约束。

然而，当然也有一些局限性，其中最显著的是性能。移动网页应用通常比其本地版本表现更差。这对于高度交互式的体验尤其如此，例如游戏或非常视觉化的用户界面。此外，移动网页应用在离线或有限连接场景下的运行选项更有限（如果有的话）。

此外，移动网页应用通常不太**符合人体工程学**，这意味着用户需要访问浏览器并加载应用。即使可以使用快捷方式，这仍然比直接在应用列表中找到应用图标（这也从品牌的角度来看更好）更不舒服。最后但同样重要的是，移动网页应用无法从应用商店带来的可见性中受益。

移动网页应用程序的一个可能的替代方案是混合应用程序。在这种方法中，移动网页应用程序被封装在一个本地的*外壳*中，这基本上是一个精简的、全屏的浏览器，用于作为移动网页应用程序和设备之间的桥梁。在这种配置中，我们的应用程序可以发布到应用商店，并访问主机设备的更多原生功能。此外，实现独特的代码库是可能的，至少苹果和谷歌的两种主要技术是这样的。缺点是，与完全本地的应用程序相比，性能和对原生硬件设备的访问仍然有限。一个值得注意的用于开发混合应用程序的框架是 React Native，我们之前提到过。

最后一个选项显然是开发一个完全本地的应用程序。为此，您将不得不使用为您的特定目标平台提供的语言和工具。

这些语言通常是用于苹果设备的 Swift 或 Objective-C，以及用于安卓设备的 Java 或 Kotlin。供应商还提供用于构建和分发应用程序的开发环境和工具。

这样，您将完全控制设备的性能，并可以利用所有可用资源，这对于某些应用程序来说可能是至关重要的。明显的缺点是，您将不得不管理两条完全不同的开发线，这意味着团队中需要不同的技能，专门的构建管道，总的来说，是重复的工作。

无论您的开发选择如何，您仍然将不得不面对测试的挑战，因为正确检查应用程序在所有可用平台上的行为可能非常昂贵。为了部分解决这个挑战，可以依靠模拟器，这些模拟器用于测试目的，模拟主要的移动设备。另一个可行的替代方案是使用专业服务。有许多公司提供各种移动设备用于测试目的，这些设备可以作为云资源租用，并远程控制以执行测试套件。

在本节中，我们探讨了网页和移动应用程序，这是当今企业服务中最常见的两个渠道。但还有一些其他选项正在越来越多地被使用。我们将在下一节中了解它们。

# 探索 IVR、聊天机器人和语音助手

提供更多客户互动渠道通常是一个非常明智的投资。这意味着触及更多的人，拥有高客户满意度，以及减少对人工交互（如由人工操作员提供的帮助）的需求，这可能既昂贵又不太有效。这些目标非常重要，在本节中，我们将探讨实现这些目标的一些方法。

## 交互式语音响应

**交互式语音响应**（**IVR**）是我们实现上述目标的一种技术。它为人类用户提供了一种通过电话与服务互动的方式。我认为我们中的每一个人都有过与 IVR 系统互动的第一手经验，因为它们在帮助台热线中相当常见。系统提供了一系列可供选择的项目。然后，用户可以使用**双音多频**（**DTMF**）音调（通过按手机数字键盘上的按钮产生的音调）或通过语音识别（与 DTMF 方法相比，语音识别可能更难且成本更高，因为它需要语音到文本的能力）来选择其中一个选项。

每个选项都可以引导到另一组选项。在某个时刻，客户可以通过文本到语音或录音消息获得所需的信息。另一个选项是将电话最终转接到人工操作员那里。虽然仍然需要人工操作员，但 IVR 系统的存在很可能会过滤掉最常见的请求，从而减少所需的人工操作员数量，并且可以为操作员提供从自动交互中收集的数据，例如用户的身份或需要解决的问题。

从算法的角度来看，IVR 系统基本上涉及**树遍历**。客户从根节点开始。在每次交互中，客户都会得到一组选项（子节点）。客户可以选择其中一个节点或退回一个级别（但当然不能超过根节点）。在某个时刻，客户将达到一个叶节点（所需的信息或人工操作员）。

如我们所见，IVR 系统涉及许多不同的技术，从集成电话呼叫（包括入站和出站）到涵盖媒体处理（录音语音播放）、语音到文本和文本到语音。换句话说，它们很少从头开始实现。在几乎所有情况下，为了实现 IVR 系统，通常依赖于打包解决方案。Asterisk，这是一款开源的 PBX 软件，常被用作实现这类系统的常见选择。然而，如今，SaaS 解决方案被广泛使用，只需要进行配置调整即可实现所需的行为。由于与打包解决方案的交互非常标准化，并且在品牌方面你仅限于提供的录音语音，因此定制的 IVR 实现不值得付出努力。

## 聊天机器人

**聊天机器人**基本上是将相同的概念应用到文本聊天中。它们达到相同的目标（在减少对人工操作员压力的同时提供定制化用户体验），但它们不需要文本到语音、语音到文本或录音语音消息。

通过向客户提供多个选项，交互仍然可以被视为一棵树。然而，在大多数聊天机器人平台上，通常向客户提供自由形式的输入，并尝试通过解析消息和执行所谓的**自然语言处理**（**NLP**）来解释客户正在寻找的内容。这个过程可能很复杂，包括寻找关键词来分析客户的请求，甚至解码客户整个消息的含义。

与 IVR 相比，聊天机器人不那么**侵入性**，因为它们不需要与电话基础设施集成。有多个框架可用于实现此类解决方案，并且它们通常被识别为无服务器部署模型的完美用例（见*第九章*，*设计云原生架构*）。然而，与 IVR 技术一样，现在从头开始实现此类解决方案并不常见，更常见的是依赖于打包的应用程序或 SaaS 解决方案。

## 语音助手

**语音助手**是对同一问题的最现代的解决方案之一。从概念上讲，语音助手是 IVR 系统提供的用户体验和聊天机器人提供的用户体验的一种混合。从用户的角度来看，语音助手是通过通常称为*智能扬声器*的专有硬件和软件堆栈消费的。在撰写本文时，最广泛的应用是 Google Home 和 Amazon Alexa。

这个话题特别热门，因为目前语音助手应用仍处于起步阶段，实现它是一项真正独特的功能。然而，要实现这一点，你需要特定的技能，并且每个供应商都依赖于他们自己的 SDK 来构建他们的平台，这些平台通常由背后的云服务提供商（如 AWS 和 Google Cloud Platform）托管和供电。

# 企业应用中的全渠道策略

在本章中，我们探讨了用户交互的多种不同选项，从最常用的用户交互渠道——Web 应用，到移动应用，再到一些替代渠道，如 IVR、聊天机器人和语音助手。

这引发了一个重大考虑，即选择哪种策略是最好的。确实，企业应用通常一次提供许多，如果不是所有这些渠道。作为用户，我们希望无论使用哪种渠道都能与应用程序互动并获得相同的信息和用户体验。

这带来了一些严重的挑战，从用户身份到状态管理。

有许多方法可以应对这些挑战。

最重要的是为所有渠道提供一个统一的后端。为了做到这一点，通常使用相同的服务（例如，用于识别用户或搜索保存的信息），并使用中介层（也称为*前端后端*）来包装这些服务，以优化特定设备（如电话通话、移动应用程序或 Web 用户界面）的输入和输出。这样，我们可以确保无论使用什么渠道进行交互，都能提供相同的结果。

在这样做的时候，我们将提供所谓的**多渠道**功能——相同的特性在不同的渠道和设备上都是可用的（当然，由于每个设备的限制，可能会有一些小的修改）。但还可以采取进一步的步骤以提供更完整的用户体验，这被称为**全渠道**功能。在全渠道体验中，用户可以在复杂交易过程中切换渠道，并且可以在不同类型的设备上继续之前开始的操作，而对用户体验和最终结果的影响最小或没有影响。

经典的例子是抵押贷款申请。用户可以拨打 IVR 系统请求信息以开始抵押贷款申请。然后，该抵押贷款申请可以使用 Web 应用程序继续，客户可以在 Web 应用程序中更舒适地提供个人信息。在异步审批过程之后，客户可以在移动应用程序上收到抵押贷款申请结果的通知，并在移动应用程序中完成整个过程。

为了实现全渠道方法，我们的企业应用程序必须能够将多步交易的**状态和细节**（例如，我们示例中的抵押贷款申请）存储在所谓的**状态机**中，通常作为业务流程（如第八章，*设计应用程序集成和业务自动化*）实现。然后，将需要实现一些服务以从期望的渠道（如之前提到的，使用中介或前端后端模式）与工作流程进行交互。

另一个常见的策略是将一些检查（可能通过使用业务规则）**编码化**，以确定哪些步骤可以由哪个特定的渠道（和设备）实现，因为由于每个渠道的特定性，可能在某些设备上执行某些步骤是不可能的（或者至少是不建议的）。一个典型的例子是 IVR。通常很难在电话通话中正确识别客户。可以检查电话号码并要求输入 PIN 码，但这可能不足以进行某些更适合移动设备（我们可以要求生物识别认证）或 Web 应用程序（我们可以强制执行**双因素认证**（**2FA**））的操作。

在本节中，我们已经完成了对我们用户最常见交互渠道的概述。

让我们总结一下本章所学的内容。

# 摘要

在本章中，我们探讨了 JEE 平台（JSP 和 JSF）提供的核心服务器端 Web 技术。我们探讨了这些技术的优缺点以及它们背后的主要思想，包括与其他 JEE 技术和标准交互。

然后，我们转向构建单页应用（SPA）的客户端框架。我们看到了 React 框架的简单和强大，以及它是如何被用来实现组件化界面的。

我们还研究了移动应用开发的基础，这对于提供完整的客户体验现在变得至关重要，并且可以利用一些网络应用开发的概念。

此外，我们还考察了其他交互渠道，例如电话（使用 IVR 系统）、文本聊天（使用聊天机器人）和语音助手。最后，我们探讨了如何将这些技术和谐地整合到多渠道和全渠道用户体验中。

在下一章中，我们将关注数据层。这包括关系型数据库以及替代方案，如键值存储和 NoSQL。这将代表应用架构的另一个基本层。

# 进一步阅读

+   Eclipse 基金会 – JSP 规范([`projects.eclipse.org/projects/ee4j.jsp`](https://projects.eclipse.org/projects/ee4j.jsp))

+   *JSP 的问题*，*贾森·亨特* ([`servlets.com/soapbox/problems-jsp.html`](http://servlets.com/soapbox/problems-jsp.html))

+   Jakarta EE – JSF 规范 ([`jakarta.ee/specifications/faces/`](https://jakarta.ee/specifications/faces/))

+   *为什么你应该避免使用 JSF*，*延斯·绍德* ([`dzone.com/articles/why-you-should-avoid-jsf`](https://dzone.com/articles/why-you-should-avoid-jsf))

+   Meta Platforms, Inc. – 官方 React 网站 ([`reactjs.org/`](https://reactjs.org/))

+   W3Schools – *React 教程* ([`www.w3schools.com/react/`](https://www.w3schools.com/react/))
